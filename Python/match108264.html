<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ro220.py &amp; ism.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ro220.py &amp; ism.py
      </h3>
<h1 align="center">
        4.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ro220.py (36.11111%)<th>ism.py (2.5390625%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(25-31)<td><a href="#" name="0">(59-63)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ro220.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 from .common import InfoExtractor
3 from ..compat import compat_urllib_parse_unquote
4 class Ro220IE(InfoExtractor):
5     IE_NAME = '220.ro'
6     _VALID_URL = r'(?x)(?:https?://)?(?:www\.)?220\.ro/(?P&lt;category&gt;[^/]+)/(?P&lt;shorttitle&gt;[^/]+)/(?P&lt;id&gt;[^/]+)'
7     _TEST = {
8         'url': 'http://www.220.ro/sport/Luati-Le-Banii-Sez-4-Ep-1/LYV6doKo7f/',
9         'md5': '03af18b73a07b4088753930db7a34add',
10         'info_dict': {
11             'id': 'LYV6doKo7f',
12             'ext': 'mp4',
13             'title': 'Luati-le Banii sez 4 ep 1',
14             'description': r're:^Iata-ne reveniti dupa o binemeritata vacanta\. +Va astept si pe Facebook cu pareri si comentarii.$',
15         }
16     }
17     def _real_extract(self, url):
18         webpage = self._download_webpage(url, video_id)
19         url = compat_urllib_parse_unquote(self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._search_regex(
20             r'(?s)clip\s*:\s*{.*?url\s*:\s*\'([^\']+)\'', webpage, 'url'))
21         title = self._og_search_title(webpage)
22         description = self._og_search_description(webpage)
23         thumbnail = self._og_search_thumbnail(webpage)
24         formats = [{</b></font>
25             'format_id': 'sd',
26             'url': url,
27             'ext': 'mp4',
28         }]
29         return {
30             'id': video_id,
31             'formats': formats,
32             'title': title,
33             'description': description,
34             'thumbnail': thumbnail,
35         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ism.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import time
3 import binascii
4 import io
5 from .fragment import FragmentFD
6 from ..compat import (
7     compat_Struct,
8     compat_urllib_error,
9 )
10 u8 = compat_Struct('&gt;B')
11 u88 = compat_Struct('&gt;Bx')
12 u16 = compat_Struct('&gt;H')
13 u1616 = compat_Struct('&gt;Hxx')
14 u32 = compat_Struct('&gt;I')
15 u64 = compat_Struct('&gt;Q')
16 s88 = compat_Struct('&gt;bx')
17 s16 = compat_Struct('&gt;h')
18 s1616 = compat_Struct('&gt;hxx')
19 s32 = compat_Struct('&gt;i')
20 unity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)
21 TRACK_ENABLED = 0x1
22 TRACK_IN_MOVIE = 0x2
23 TRACK_IN_PREVIEW = 0x4
24 SELF_CONTAINED = 0x1
25 def box(box_type, payload):
26     return u32.pack(8 + len(payload)) + box_type + payload
27 def full_box(box_type, version, flags, payload):
28     return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)
29 def write_piff_header(stream, params):
30     track_id = params['track_id']
31     fourcc = params['fourcc']
32     duration = params['duration']
33     timescale = params.get('timescale', 10000000)
34     language = params.get('language', 'und')
35     height = params.get('height', 0)
36     width = params.get('width', 0)
37     is_audio = width == 0 and height == 0
38     creation_time = modification_time = int(time.time())
39     ftyp_payload = b'isml'  # major brand
40     ftyp_payload += u32.pack(1)  # minor version
41     stream.write(box(b'ftyp', ftyp_payload))  # File Type Box
42     mvhd_payload = u64<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.pack(creation_time)
43     mvhd_payload += u64.pack(modification_time)
44     mvhd_payload += u32.pack(timescale)
45     mvhd_payload += u64.pack(duration)
46     mvhd_payload += s1616.</b></font>pack(1)  # rate
47     mvhd_payload += s88.pack(1)  # volume
48     mvhd_payload += u16.pack(0)  # reserved
49     mvhd_payload += u32.pack(0) * 2  # reserved
50     mvhd_payload += unity_matrix
51     mvhd_payload += u32.pack(0) * 6  # pre defined
52     mvhd_payload += u32.pack(0xffffffff)  # next track id
53     moov_payload = full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box
54     tkhd_payload = u64.pack(creation_time)
55     tkhd_payload += u64.pack(modification_time)
56     tkhd_payload += u32.pack(track_id)  # track id
57     tkhd_payload += u32.pack(0)  # reserved
58     tkhd_payload += u64.pack(duration)
59     tkhd_payload += u32.pack(0) * 2  # reserved
60     tkhd_payload += s16.pack(0)  # layer
61     tkhd_payload += s16.pack(0)  # alternate group
62     tkhd_payload += s88.pack(1 if is_audio else 0)  # volume
63     tkhd_payload += u16.pack(0)  # reserved
64     tkhd_payload += unity_matrix
65     tkhd_payload += u1616.pack(width)
66     tkhd_payload += u1616.pack(height)
67     trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box
68     mdhd_payload = u64.pack(creation_time)
69     mdhd_payload += u64.pack(modification_time)
70     mdhd_payload += u32.pack(timescale)
71     mdhd_payload += u64.pack(duration)
72     mdhd_payload += u16.pack(((ord(language[0]) - 0x60) &lt;&lt; 10) | ((ord(language[1]) - 0x60) &lt;&lt; 5) | (ord(language[2]) - 0x60))
73     mdhd_payload += u16.pack(0)  # pre defined
74     mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box
75     hdlr_payload = u32.pack(0)  # pre defined
76     hdlr_payload += b'soun' if is_audio else b'vide'  # handler type
77     hdlr_payload += u32.pack(0) * 3  # reserved
78     hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\0'  # name
79     mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box
80     if is_audio:
81         smhd_payload = s88.pack(0)  # balance
82         smhd_payload += u16.pack(0)  # reserved
83         media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header
84     else:
85         vmhd_payload = u16.pack(0)  # graphics mode
86         vmhd_payload += u16.pack(0) * 3  # opcolor
87         media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header
88     minf_payload = media_header_box
89     dref_payload = u32.pack(1)  # entry count
90     dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box
91     dinf_payload = full_box(b'dref', 0, 0, dref_payload)  # Data Reference Box
92     minf_payload += box(b'dinf', dinf_payload)  # Data Information Box
93     stsd_payload = u32.pack(1)  # entry count
94     sample_entry_payload = u8.pack(0) * 6  # reserved
95     sample_entry_payload += u16.pack(1)  # data reference index
96     if is_audio:
97         sample_entry_payload += u32.pack(0) * 2  # reserved
98         sample_entry_payload += u16.pack(params.get('channels', 2))
99         sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))
100         sample_entry_payload += u16.pack(0)  # pre defined
101         sample_entry_payload += u16.pack(0)  # reserved
102         sample_entry_payload += u1616.pack(params['sampling_rate'])
103         if fourcc == 'AACL':
104             sample_entry_box = box(b'mp4a', sample_entry_payload)
105     else:
106         sample_entry_payload += u16.pack(0)  # pre defined
107         sample_entry_payload += u16.pack(0)  # reserved
108         sample_entry_payload += u32.pack(0) * 3  # pre defined
109         sample_entry_payload += u16.pack(width)
110         sample_entry_payload += u16.pack(height)
111         sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi
112         sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi
113         sample_entry_payload += u32.pack(0)  # reserved
114         sample_entry_payload += u16.pack(1)  # frame count
115         sample_entry_payload += u8.pack(0) * 32  # compressor name
116         sample_entry_payload += u16.pack(0x18)  # depth
117         sample_entry_payload += s16.pack(-1)  # pre defined
118         codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))
119         if fourcc in ('H264', 'AVC1'):
120             sps, pps = codec_private_data.split(u32.pack(1))[1:]
121             avcc_payload = u8.pack(1)  # configuration version
122             avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication
123             avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one
124             avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)
125             avcc_payload += u16.pack(len(sps))
126             avcc_payload += sps
127             avcc_payload += u8.pack(1)  # number of pps
128             avcc_payload += u16.pack(len(pps))
129             avcc_payload += pps
130             sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record
131             sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry
132     stsd_payload += sample_entry_box
133     stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box
134     stts_payload = u32.pack(0)  # entry count
135     stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box
136     stsc_payload = u32.pack(0)  # entry count
137     stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box
138     stco_payload = u32.pack(0)  # entry count
139     stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box
140     minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box
141     mdia_payload += box(b'minf', minf_payload)  # Media Information Box
142     trak_payload += box(b'mdia', mdia_payload)  # Media Box
143     moov_payload += box(b'trak', trak_payload)  # Track Box
144     mehd_payload = u64.pack(duration)
145     mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box
146     trex_payload = u32.pack(track_id)  # track id
147     trex_payload += u32.pack(1)  # default sample description index
148     trex_payload += u32.pack(0)  # default sample duration
149     trex_payload += u32.pack(0)  # default sample size
150     trex_payload += u32.pack(0)  # default sample flags
151     mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box
152     moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box
153     stream.write(box(b'moov', moov_payload))  # Movie Box
154 def extract_box_data(data, box_sequence):
155     data_reader = io.BytesIO(data)
156     while True:
157         box_size = u32.unpack(data_reader.read(4))[0]
158         box_type = data_reader.read(4)
159         if box_type == box_sequence[0]:
160             box_data = data_reader.read(box_size - 8)
161             if len(box_sequence) == 1:
162                 return box_data
163             return extract_box_data(box_data, box_sequence[1:])
164         data_reader.seek(box_size - 8, 1)
165 class IsmFD(FragmentFD):
166     FD_NAME = 'ism'
167     def real_download(self, filename, info_dict):
168         segments = info_dict['fragments'][:1] if self.params.get(
169             'test', False) else info_dict['fragments']
170         ctx = {
171             'filename': filename,
172             'total_frags': len(segments),
173         }
174         self._prepare_and_start_frag_download(ctx)
175         fragment_retries = self.params.get('fragment_retries', 0)
176         skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)
177         track_written = False
178         frag_index = 0
179         for i, segment in enumerate(segments):
180             frag_index += 1
181             if frag_index &lt;= ctx['fragment_index']:
182                 continue
183             count = 0
184             while count &lt;= fragment_retries:
185                 try:
186                     success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)
187                     if not success:
188                         return False
189                     if not track_written:
190                         tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])
191                         info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]
192                         write_piff_header(ctx['dest_stream'], info_dict['_download_params'])
193                         track_written = True
194                     self._append_fragment(ctx, frag_content)
195                     break
196                 except compat_urllib_error.HTTPError as err:
197                     count += 1
198                     if count &lt;= fragment_retries:
199                         self.report_retry_fragment(err, frag_index, count, fragment_retries)
200             if count &gt; fragment_retries:
201                 if skip_unavailable_fragments:
202                     self.report_skip_fragment(frag_index)
203                     continue
204                 self.report_error('giving up after %s fragment retries' % fragment_retries)
205                 return False
206         self._finish_frag_download(ctx)
207         return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
