<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_update.py &amp; state_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_update.py &amp; state_1.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_update.py (9.501411%)<th>state_1.py (1.3687491%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(166-171)<td><a href="#" name="0">(759-764)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(544-552)<td><a href="#" name="1">(2002-2008)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(234-237)<td><a href="#" name="2">(2859-2863)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1074-1079)<td><a href="#" name="3">(4668-4671)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(850-855)<td><a href="#" name="4">(2257-2262)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(751-753)<td><a href="#" name="5">(4745-4749)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(685-690)<td><a href="#" name="6">(3020-3022)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(437-450)<td><a href="#" name="7">(4462-4479)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_update.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import subprocess
3 import salt.utils.args
4 import salt.utils.data
5 import salt.utils.winapi
6 from salt.exceptions import CommandExecutionError
7 try:
8     import win32com.client
9     import pywintypes
10     HAS_PYWIN32 = True
11 except ImportError:
12     HAS_PYWIN32 = False
13 log = logging.getLogger(__name__)
14 REBOOT_BEHAVIOR = {
15     0: "Never Requires Reboot",
16     1: "Always Requires Reboot",
17     2: "Can Require Reboot",
18 }
19 __virtualname__ = "win_update"
20 def __virtual__():
21     if not salt.utils.platform.is_windows():
22         return False, "win_update: Only available on Windows"
23     if not HAS_PYWIN32:
24         return False, "win_update: Missing pywin32"
25     return __virtualname__
26 class Updates:
27     update_types = {1: "Software", 2: "Driver"}
28     def __init__(self):
29         with salt.utils.winapi.Com():
30             self.updates = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
31     def count(self):
32         return self.updates.Count
33     def list(self):
34         if self.count() == 0:
35             return "Nothing to return"
36         log.debug("Building a detailed report of the results.")
37         results = {}
38         for update in self.updates:
39             try:
40                 user_input = bool(update.InstallationBehavior.CanRequestUserInput)
41             except AttributeError:
42                 log.debug(
43                     "Windows Update: Error reading InstallationBehavior COM Object"
44                 )
45                 user_input = False
46             try:
47                 requires_reboot = update.InstallationBehavior.RebootBehavior
48             except AttributeError:
49                 log.debug(
50                     "Windows Update: Error reading InstallationBehavior COM Object"
51                 )
52                 requires_reboot = 2
53             results<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[update.Identity.UpdateID] = {
54                 "guid": update.Identity.UpdateID,
55                 "Title": str(update.Title),
56                 "Type": self.update_types[update.Type],
57                 "Description": update.Description,
58                 "Downloaded": bool(update.</b></font>IsDownloaded),
59                 "Installed": bool(update.IsInstalled),
60                 "Mandatory": bool(update.IsMandatory),
61                 "EULAAccepted": bool(update.EulaAccepted),
62                 "NeedsReboot": bool(update.RebootRequired),
63                 "Severity": str(update.MsrcSeverity),
64                 "UserInput": user_input,
65                 "RebootBehavior": REBOOT_BEHAVIOR[requires_reboot],
66                 "KBs": ["KB" + item for item in update.KBArticleIDs],
67                 "Categories": [item.Name for item in update.Categories],
68                 "SupportUrl": update.SupportUrl,
69             }
70         return results
71     def summary(self):
72         if self.count() == 0:
73             return "Nothing to return"
74         results = {
75             "Total": 0,
76             "Available": 0,
77             "Downloaded": 0,
78             "Installed": 0,
79             "Categories": {},
80             "Severity": {},
81         }
82         for update in self.updates:
83             if not salt<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.data.is_true(
84                 update.IsDownloaded
85             ) and not salt.utils.data.is_true(update.IsInstalled):
86                 results["Available"] +</b></font>= 1
87             if salt.utils.data.is_true(
88                 update.IsDownloaded
89             ) and not salt.utils.data.is_true(update.IsInstalled):
90                 results["Downloaded"] += 1
91             if salt.utils.data.is_true(update.IsInstalled):
92                 results["Installed"] += 1
93             for category in update.Categories:
94                 if category.Name in results["Categories"]:
95                     results["Categories"][category.Name] += 1
96                 else:
97                     results["Categories"][category.Name] = 1
98             if update.MsrcSeverity:
99                 if update.MsrcSeverity in results["Severity"]:
100                     results["Severity"][update.MsrcSeverity] += 1
101                 else:
102                     results["Severity"][update.MsrcSeverity] = 1
103         return results
104 class WindowsUpdateAgent:
105     fail_codes = {
106         -2145107924: "WinHTTP Send/Receive failed: 0x8024402C",
107         -2145124300: "Download failed: 0x80240034",
108         -2145124302: "Invalid search criteria: 0x80240032",
109         -2145124305: "Cancelled by policy: 0x8024002F",
110         -2145124307: "Missing source: 0x8024002D",
111         -2145124308: "Missing source: 0x8024002C",
112         -2145124312: "Uninstall not allowed: 0x80240028",
113         -2145124315: "Prevented by policy: 0x80240025",
114         -2145124316: "No Updates: 0x80240024",
115         -2145124322: "Service being shutdown: 0x8024001E",
116         -2145124325: "Self Update in Progress: 0x8024001B",
117         -2145124327: "Exclusive Install Conflict: 0x80240019",
118         -2145124330: "Install not allowed: 0x80240016",
119         -2145124333: "Duplicate item: 0x80240013",
120         -2145124341: "Operation cancelled: 0x8024000B",
121         -2145124343: "Operation in progress: 0x80240009",
122         -2145124284: "Access Denied: 0x8024044",
123         -2145124283: "Unsupported search scope: 0x80240045",
124         -2147024891: "Access is denied: 0x80070005",
125         -2149843018: "Setup in progress: 0x8024004A",
126         -4292599787: "Install still pending: 0x00242015",
127         -4292607992: "Already downloaded: 0x00240008",
128         -4292607993: "Already uninstalled: 0x00240007",
129         -4292607994: "Already installed: 0x00240006",
130         -4292607995: "Reboot required: 0x00240005",
131     }
132     def __init__(self, online=True):
133         with salt.utils.winapi.Com():
134             self._session = win32com.client.Dispatch("Microsoft.Update.Session")
135             self._updates = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
136         self.refresh(online=online)
137     def updates(self):
138         updates = Updates()
139         found = updates.updates
140         for update in self._updates:
141             found.Add(update)
142         return updates
143     def refresh(self, online=True):
144         search_string = "Type='Software' or Type='Driver'"
145         searcher = self._session.CreateUpdateSearcher()
146         searcher.Online = online
147         self._session.ClientApplicationID = "Salt: Load Updates"
148         try:
149             results = searcher.Search(search_string)
150             if results.Updates.Count == 0:
151                 log.debug("No Updates found for:\n\t\t%s", search_string)
152                 return "No Updates found: {}".format(search_string)
153         except pywintypes.com_error as error:
154             hr, msg, exc, arg = error.args  # pylint: disable=W0633
155             try:
156                 failure_code = self.fail_codes[exc[5]]
157             except KeyError:
158                 failure_code = "Unknown Failure: {}".format(error)
159             log.error("Search Failed: %s\n\t\t%s", failure_code, search_string)
160             raise CommandExecutionError(failure_code)
161         self._updates = results.Updates
162     def installed(self):
163         updates = Updates()
164         for update in self._updates:
165             if salt.utils.data.is_true(update.IsInstalled):
166                 updates.updates.Add(u<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>pdate)
167         return updates
168     def available(
169         self,
170         skip_hidden=True,
171         skip_installed=True,
172         skip_mandatory=False,
173         skip_reboot=False,
174         software=True,
175         drivers=True,
176         categories=None,
177         severities=</b></font>None,
178     ):
179         updates = Updates()
180         found = updates.updates
181         for update in self._updates:
182             if salt.utils.data.is_true(update.IsHidden) and skip_hidden:
183                 continue
184             if salt.utils.data.is_true(update.IsInstalled) and skip_installed:
185                 continue
186             if salt.utils.data.is_true(update.IsMandatory) and skip_mandatory:
187                 continue
188             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try:
189                 requires_reboot = salt.utils.data.is_true(
190                     update.InstallationBehavior.RebootBehavior
191                 )
192             except AttributeError:
193                 log.debug(
194                     "Windows Update: Error reading InstallationBehavior COM Object"
195                 )
196                 requires_reboot =</b></font> True
197             if requires_reboot and skip_reboot:
198                 continue
199             if not software and update.Type == 1:
200                 continue
201             if not drivers and update.Type == 2:
202                 continue
203             if categories is not None:
204                 match = False
205                 for category in update.Categories:
206                     if category.Name in categories:
207                         match = True
208                 if not match:
209                     continue
210             if severities is not None:
211                 if update.MsrcSeverity not in severities:
212                     continue
213             found.Add(update)
214         return updates
215     def search(self, search_string):
216         updates = Updates()
217         found = updates.updates
218         if isinstance(search_string, str):
219             search_string = [search_string]
220         if isinstance(search_string, int):
221             search_string = [str(search_string)]
222         for update in self._updates:
223             for find in search_string:
224                 if find == update.Identity.UpdateID:
225                     found.Add(update)
226                     continue
227                 if find in ["KB" + item for item in update.KBArticleIDs]:
228                     found.Add(update)
229                     continue
230                 if find in [item for item in update.KBArticleIDs]:
231                     found.Add(update)
232                     continue
233                 if find in update.Title:
234                     found.Add(update)
235                     continue
236         return updates
237     def download(self, updates):
238         if updates.count() == 0:
239             ret = {"Success": False, "Updates": "Nothing to download"}
240             return ret
241         downloader = self._session.CreateUpdateDownloader()
242         self._session.ClientApplicationID = "Salt: Download Update"
243         with salt.utils.winapi.Com():
244             download_list = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
245             for update in updates<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.updates:
246                 uid = update.Identity.UpdateID
247                 ret["Updates"][uid] = {}
248                 ret["Updates"][uid]["Title"] = update.</b></font>Title
249                 ret["Updates"][uid]["AlreadyDownloaded"] = bool(update.IsDownloaded)
250                 if not salt.utils.data.is_true(update.EulaAccepted):
251                     log.debug("Accepting EULA: %s", update.Title)
252                     update.AcceptEula()  # pylint: disable=W0104
253                 if not salt.utils.data.is_true(update.IsDownloaded):
254                     log.debug("To Be Downloaded: %s", uid)
255                     log.debug("\tTitle: %s", update.Title)
256                     download_list.Add(update)
257             if download_list.Count == 0:
258                 ret = {"Success": True, "Updates": "Nothing to download"}
259                 return ret
260             downloader.Updates = download_list
261             try:
262                 log.debug("Downloading Updates")
263                 result = downloader.Download()
264             except pywintypes.com_error as error:
265                 hr, msg, exc, arg = error.args  # pylint: disable=W0633
266                 try:
267                     failure_code = self.fail_codes[exc[5]]
268                 except KeyError:
269                     failure_code = "Unknown Failure: {}".format(error)
270                 log.error("Download Failed: %s", failure_code)
271                 raise CommandExecutionError(failure_code)
272             result_code = {
273                 0: "Download Not Started",
274                 1: "Download In Progress",
275                 2: "Download Succeeded",
276                 3: "Download Succeeded With Errors",
277                 4: "Download Failed",
278                 5: "Download Aborted",
279             }
280             log.debug("Download Complete")
281             log.debug(result_code[result.ResultCode])
282             ret["Message"] = result_code[result.ResultCode]
283             if result.ResultCode in [2, 3]:
284                 log.debug("Downloaded Successfully")
285                 ret["Success"] = True
286             else:
287                 log.debug("Download Failed")
288                 ret["Success"] = False
289             for i in range(download_list.Count):
290                 uid = download_list<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Item(i).Identity.UpdateID
291                 ret["Updates"][uid]["Result"] = result_code[
292                     result.GetUpdateResult(i).</b></font>ResultCode
293                 ]
294         return ret
295     def install(self, updates):
296         if updates.count() == 0:
297             ret = {"Success": False, "Updates": "Nothing to install"}
298             return ret
299         installer = self._session.CreateUpdateInstaller()
300         self._session.ClientApplicationID = "Salt: Install Update"
301         with salt.utils.winapi.Com():
302             install_list = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
303             ret = {"Updates": {}}
304             for update in updates.updates:
305                 uid = update.Identity.UpdateID
306                 ret["Updates"][uid] = {}
307                 ret["Updates"][uid]["Title"] = update.Title
308                 ret["Updates"][uid]["AlreadyInstalled"] = bool(update.IsInstalled)
309                 if not salt.utils.data.is_true(update.IsInstalled):
310                     log.debug("To Be Installed: %s", uid)
311                     log.debug("\tTitle: %s", update.Title)
312                     install_list.Add(update)
313             if install_list.Count == 0:
314                 ret = {"Success": True, "Updates": "Nothing to install"}
315                 return ret
316             installer.Updates = install_list
317             try:
318                 log.debug("Installing Updates")
319                 result = installer.Install()
320             except pywintypes.com_error as error:
321                 hr, msg, exc, arg = error.args  # pylint: disable=W0633
322                 try:
323                     failure_code = self.fail_codes[exc[5]]
324                 except KeyError:
325                     failure_code = "Unknown Failure: {}".format(error)
326                 log.error("Install Failed: %s", failure_code)
327                 raise CommandExecutionError(failure_code)
328             result_code = {
329                 0: "Installation Not Started",
330                 1: "Installation In Progress",
331                 2: "Installation Succeeded",
332                 3: "Installation Succeeded With Errors",
333                 4: "Installation Failed",
334                 5: "Installation Aborted",
335             }
336             log.debug("Install Complete")
337             ret["Message"] = result_code[result.ResultCode]
338             if result<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.ResultCode in [2, 3]:
339                 ret["Success"] = True
340                 ret["NeedsReboot"] = result.RebootRequired
341                 log.debug("NeedsReboot: %s", result.RebootRequired)
342             else:
343                 log.debug(</b></font>"Install Failed")
344                 ret["Success"] = False
345             for i in range(install_list.Count):
346                 uid = install_list.Item(i).Identity.UpdateID
347                 ret["Updates"][uid]["Result"] = result_code[
348                     result.GetUpdateResult(i).ResultCode
349                 ]
350                 try:
351                     reboot_behavior = install_list.Item(
352                         i
353                     ).InstallationBehavior.RebootBehavior
354                 except AttributeError:
355                     log.debug(
356                         "Windows Update: Error reading InstallationBehavior COM Object"
357                     )
358                     reboot_behavior = 2
359                 ret["Updates"][uid]["RebootBehavior"] = REBOOT_BEHAVIOR[reboot_behavior]
360         return ret
361     def uninstall(self, updates):
362         if updates.count() == 0:
363             ret = {"Success": False, "Updates": "Nothing to uninstall"}
364             return ret
365         installer = self._session.CreateUpdateInstaller()
366         self._session.ClientApplicationID = "Salt: Uninstall Update"
367         with salt.utils.winapi.Com():
368             uninstall_list = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
369             ret = {"Updates": {}}
370             for update in updates.updates:
371                 uid = update.Identity.UpdateID
372                 ret["Updates"][uid] = {}
373                 ret["Updates"][uid]["Title"] = update.Title
374                 ret["Updates"][uid]["AlreadyUninstalled"] = not bool(update.IsInstalled)
375                 if salt.utils.data.is_true(update.IsInstalled):
376                     log.debug("To Be Uninstalled: %s", uid)
377                     log.debug("\tTitle: %s", update.Title)
378                     uninstall_list.Add(update)
379             if uninstall_list.Count == 0:
380                 ret = {"Success": False, "Updates": "Nothing to uninstall"}
381                 return ret
382             installer.Updates = uninstall_list
383             try:
384                 log.debug("Uninstalling Updates")
385                 result = installer.Uninstall()
386             except pywintypes.com_error as error:
387                 hr, msg, exc, arg = error.args  # pylint: disable=W0633
388                 try:
389                     failure_code = self.fail_codes[exc[5]]
390                 except KeyError:
391                     failure_code = "Unknown Failure: {}".format(error)
392                 if exc[5] == -2145124312:
393                     log.debug("Uninstall Failed with WUA, attempting with DISM")
394                     try:
395                         for item in uninstall_list:
396                             for kb in item.KBArticleIDs:
397                                 cmd = ["dism", "/Online", "/Get-Packages"]
398                                 pkg_list = self._run(cmd)[0].splitlines()
399                                 for item in pkg_list:
400                                     if "kb" + kb in item.lower():
401                                         pkg = item.split(" : ")[1]
402                                         ret["DismPackage"] = pkg
403                                         cmd = [
404                                             "dism",
405                                             "/Online",
406                                             "/Remove-Package",
407                                             "/PackageName:{}".format(pkg),
408                                             "/Quiet",
409                                             "/NoRestart",
410                                         ]
411                                         self._run(cmd)
412                     except CommandExecutionError as exc:
413                         log.debug("Uninstall using DISM failed")
414                         log.debug("Command: %s", " ".join(cmd))
415                         log.debug("Error: %s", exc)
416                         raise CommandExecutionError(
417                             "Uninstall using DISM failed: {}".format(exc)
418                         )
419                     log.debug("Uninstall Completed using DISM")
420                     ret["Success"] = True
421                     ret["Message"] = "Uninstalled using DISM"
422                     ret["NeedsReboot"] = needs_reboot()
423                     log.debug("NeedsReboot: %s", ret["NeedsReboot"])
424                     self.refresh(online=False)
425                     for update in self._updates:
426                         uid = update.Identity.UpdateID
427                         for item in uninstall_list:
428                             if item.Identity.UpdateID == uid:
429                                 if not update.IsInstalled:
430                                     ret["Updates"][uid][
431                                         "Result"
432                                     ] = "Uninstallation Succeeded"
433                                 else:
434                                     ret["Updates"][uid][
435                                         "Result"
436                                     ] = "Uninstallation Failed"
437                                 try:
438                                     requires_reboot = (
439                                         update.InstallationBehavior.RebootBehavior
440                                     )
441                                 except AttributeError:
442                                     log.debug(
443                                         "Windows Update: Error reading"
444                                         " InstallationBehavior COM Object"
445                                     )
446                                     requires_reboot = 2
447                                 ret["Updates"][uid]["RebootBehavior"] = REBOOT_BEHAVIOR[
448                                     requires_reboot
449                                 ]
450                     return ret
451                 log.error("Uninstall Failed: %s", failure_code)
452                 raise CommandExecutionError(failure_code)
453             result_code = {
454                 0: "Uninstallation Not Started",
455                 1: "Uninstallation In Progress",
456                 2: "Uninstallation Succeeded",
457                 3: "Uninstallation Succeeded With Errors",
458                 4: "Uninstallation Failed",
459                 5: "Uninstallation Aborted",
460             }
461             log.debug("Uninstall Complete")
462             log.debug(result_code[result.ResultCode])
463             if result.ResultCode in [2, 3]:
464                 ret<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["Success"] = True
465                 ret["NeedsReboot"] = result.RebootRequired
466                 log.debug("NeedsReboot: %s", result.RebootRequired)
467             else:
468                 log.debug("Uninstall Failed")
469                 ret["Success"] =</b></font> False
470             for i in range(uninstall_list.Count):
471                 uid = uninstall_list.Item(i).Identity.UpdateID
472                 ret["Updates"][uid]["Result"] = result_code[
473                     result.GetUpdateResult(i).ResultCode
474                 ]
475                 try:
476                     reboot_behavior = uninstall_list.Item(
477                         i
478                     ).InstallationBehavior.RebootBehavior
479                 except AttributeError:
480                     log.debug(
481                         "Windows Update: Error reading InstallationBehavior COM Object"
482                     )
483                     reboot_behavior = 2
484                 ret["Updates"][uid]["RebootBehavior"] = REBOOT_BEHAVIOR[reboot_behavior]
485         return ret
486     def _run(self, cmd):
487         if isinstance(cmd, str):
488             cmd = salt.utils.args.shlex_split(cmd)
489         try:
490             log.debug(cmd)
491             p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
492             return p.communicate()
493         except OSError as exc:
494             log.debug("Command Failed: %s", " ".join(cmd))
495             log.debug("Error: %s", exc)
496             raise CommandExecutionError(exc)
497 def needs_reboot():
498     with salt.utils.winapi.Com():
499         try:
500             obj_sys = win32com.client.Dispatch("Microsoft.Update.SystemInfo")
501         except pywintypes.com_error as exc:
502             _, msg, _, _ = exc.args
503             log.debug("Failed to create SystemInfo object: %s", msg)
504             return False
505         return salt.utils.data.is_true(obj_sys.RebootRequired)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>state_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import fnmatch
4 import importlib
5 import logging
6 import os
7 import random
8 import re
9 import site
10 import sys
11 import time
12 import traceback
13 import salt.channel.client
14 import salt.fileclient
15 import salt.loader
16 import salt.minion
17 import salt.pillar
18 import salt.syspaths as syspaths
19 import salt.utils.args
20 import salt.utils.crypt
21 import salt.utils.data
22 import salt.utils.decorators.state
23 import salt.utils.dictupdate
24 import salt.utils.event
25 import salt.utils.files
26 import salt.utils.hashutils
27 import salt.utils.immutabletypes as immutabletypes
28 import salt.utils.msgpack
29 import salt.utils.platform
30 import salt.utils.process
31 import salt.utils.url
32 import salt.utils.yamlloader as yamlloader
33 from salt.exceptions import CommandExecutionError, SaltRenderError, SaltReqTimeoutError
34 from salt.serializers.msgpack import deserialize as msgpack_deserialize
35 from salt.serializers.msgpack import serialize as msgpack_serialize
36 from salt.template import compile_template, compile_template_str
37 from salt.utils.odict import DefaultOrderedDict, OrderedDict
38 log = logging.getLogger(__name__)
39 STATE_REQUISITE_KEYWORDS = frozenset(
40     [
41         "onchanges",
42         "onchanges_any",
43         "onfail",
44         "onfail_any",
45         "onfail_all",
46         "onfail_stop",
47         "prereq",
48         "prerequired",
49         "watch",
50         "watch_any",
51         "require",
52         "require_any",
53         "listen",
54     ]
55 )
56 STATE_REQUISITE_IN_KEYWORDS = frozenset(
57     ["onchanges_in", "onfail_in", "prereq_in", "watch_in", "require_in", "listen_in"]
58 )
59 STATE_RUNTIME_KEYWORDS = frozenset(
60     [
61         "fun",
62         "state",
63         "check_cmd",
64         "failhard",
65         "onlyif",
66         "unless",
67         "creates",
68         "retry",
69         "order",
70         "parallel",
71         "prereq",
72         "prereq_in",
73         "prerequired",
74         "reload_modules",
75         "reload_grains",
76         "reload_pillar",
77         "runas",
78         "runas_password",
79         "fire_event",
80         "saltenv",
81         "use",
82         "use_in",
83         "__env__",
84         "__sls__",
85         "__id__",
86         "__orchestration_jid__",
87         "__pub_user",
88         "__pub_arg",
89         "__pub_jid",
90         "__pub_fun",
91         "__pub_tgt",
92         "__pub_ret",
93         "__pub_pid",
94         "__pub_tgt_type",
95         "__prereq__",
96         "__prerequired__",
97     ]
98 )
99 STATE_INTERNAL_KEYWORDS = STATE_REQUISITE_KEYWORDS.union(
100     STATE_REQUISITE_IN_KEYWORDS
101 ).union(STATE_RUNTIME_KEYWORDS)
102 def _odict_hashable(self):
103     return id(self)
104 OrderedDict.__hash__ = _odict_hashable
105 def split_low_tag(tag):
106     state, id_, name, fun = tag.split("_|-")
107     return {"state": state, "__id__": id_, "name": name, "fun": fun}
108 def _gen_tag(low):
109     return "{0[state]}_|-{0[__id__]}_|-{0[name]}_|-{0[fun]}".format(low)
110 def _clean_tag(tag):
111     return salt.utils.files.safe_filename_leaf(tag)
112 def _l_tag(name, id_):
113     low = {
114         "name": "listen_{}".format(name),
115         "__id__": "listen_{}".format(id_),
116         "state": "Listen_Error",
117         "fun": "Listen_Error",
118     }
119     return _gen_tag(low)
120 def _calculate_fake_duration():
121     utc_start_time = datetime.datetime.utcnow()
122     local_start_time = utc_start_time - (
123         datetime.datetime.utcnow() - datetime.datetime.now()
124     )
125     utc_finish_time = datetime.datetime.utcnow()
126     start_time = local_start_time.time().isoformat()
127     delta = utc_finish_time - utc_start_time
128     duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
129     return start_time, duration
130 def get_accumulator_dir(cachedir):
131     fn_ = os.path.join(cachedir, "accumulator")
132     if not os.path.isdir(fn_):
133         os.makedirs(fn_)
134     return fn_
135 def trim_req(req):
136     reqfirst = next(iter(req))
137     if "." in reqfirst:
138         return {reqfirst.split(".")[0]: req[reqfirst]}
139     return req
140 def state_args(id_, state, high):
141     args = set()
142     if id_ not in high:
143         return args
144     if state not in high[id_]:
145         return args
146     for item in high[id_][state]:
147         if not isinstance(item, dict):
148             continue
149         if len(item) != 1:
150             continue
151         args.add(next(iter(item)))
152     return args
153 def find_name(name, state, high, strict=False):
154     ext_id = []
155     if strict is False:
156         check2 = True
157     else:
158         check2 = state in high.get(name, {})
159     if name in high and check2:
160         ext_id.append((name, state))
161     elif state == "sls":
162         for nid, item in high.items():
163             if item["__sls__"] == name:
164                 ext_id.append((nid, next(iter(item))))
165     else:
166         for nid in high:
167             if state in high[nid]:
168                 if isinstance(high[nid][state], list):
169                     for arg in high[nid][state]:
170                         if not isinstance(arg, dict):
171                             continue
172                         if len(arg) != 1:
173                             continue
174                         if arg[next(iter(arg))] == name:
175                             ext_id.append((nid, state))
176     return ext_id
177 def find_sls_ids(sls, high):
178     ret = []
179     for nid, item in high.items():
180         try:
181             sls_tgt = item["__sls__"]
182         except TypeError:
183             if nid != "__exclude__":
184                 log.error(
185                     "Invalid non-dict item '%s' in high data. Value: %r", nid, item
186                 )
187             continue
188         else:
189             if sls_tgt == sls:
190                 for st_ in item:
191                     if st_.startswith("__"):
192                         continue
193                     ret.append((nid, st_))
194     return ret
195 def format_log(ret):
196     msg = ""
197     if isinstance(ret, dict):
198         if "changes" in ret:
199             chg = ret["changes"]
200             if not chg:
201                 if ret["comment"]:
202                     msg = ret["comment"]
203                 else:
204                     msg = "No changes made for {0[name]}".format(ret)
205             elif isinstance(chg, dict):
206                 if "diff" in chg:
207                     if isinstance(chg["diff"], str):
208                         msg = "File changed:\n{}".format(chg["diff"])
209                 if all([isinstance(x, dict) for x in chg.values()]):
210                     if all([("old" in x and "new" in x) for x in chg.values()]):
211                         msg = "Made the following changes:\n"
212                         for pkg in chg:
213                             old = chg[pkg]["old"]
214                             if not old and old not in (False, None):
215                                 old = "absent"
216                             new = chg[pkg]["new"]
217                             if not new and new not in (False, None):
218                                 new = "absent"
219                             msg += "'{}' changed from '{}' to '{}'\n".format(
220                                 pkg, old, new
221                             )
222             if not msg:
223                 msg = str(ret["changes"])
224             if ret["result"] is True or ret["result"] is None:
225                 log.info(msg)
226             else:
227                 log.error(msg)
228     else:
229         log.info(str(ret))
230 def master_compile(master_opts, minion_opts, grains, id_, saltenv):
231     st_ = MasterHighState(master_opts, minion_opts, grains, id_, saltenv)
232     return st_.compile_highstate()
233 def ishashable(obj):
234     try:
235         hash(obj)
236     except TypeError:
237         return False
238     return True
239 def mock_ret(cdata):
240     if cdata["args"]:
241         name = cdata["args"][0]
242     else:
243         name = cdata["kwargs"]["name"]
244     return {
245         "name": name,
246         "comment": "Not called, mocked",
247         "changes": {},
248         "result": True,
249     }
250 class StateError(Exception):
251 class Compiler:
252     def __init__(self, opts, renderers):
253         self.opts = opts
254         self.rend = renderers
255     def render_template(self, template, **kwargs):
256         high = compile_template(
257             template,
258             self.rend,
259             self.opts["renderer"],
260             self.opts["renderer_blacklist"],
261             self.opts["renderer_whitelist"],
262             **kwargs
263         )
264         if not high:
265             return high
266         return self.pad_funcs(high)
267     def pad_funcs(self, high):
268         for name in high:
269             if not isinstance(high[name], dict):
270                 if isinstance(high[name], str):
271                     if "." in high[name]:
272                         comps = high[name].split(".")
273                         if len(comps) &gt;= 2:
274                             comps[1] = ".".join(comps[1 : len(comps)])
275                         high[name] = {
276                             comps[0]: [comps[1]]
277                         }
278                         continue
279                     continue
280             skeys = set()
281             for key in sorted(high[name]):
282                 if key.startswith("_"):
283                     continue
284                 if not isinstance(high[name][key], list):
285                     continue
286                 if "." in key:
287                     comps = key.split(".")
288                     if len(comps) &gt;= 2:
289                         comps[1] = ".".join(comps[1 : len(comps)])
290                     if comps[0] in skeys:
291                         continue
292                     high[name][comps[0]] = high[name].pop(key)
293                     high[name][comps[0]].append(comps[1])
294                     skeys.add(comps[0])
295                     continue
296                 skeys.add(key)
297         return high
298     def verify_high(self, high):
299         errors = []
300         if not isinstance(high, dict):
301             errors.append("High data is not a dictionary and is invalid")
302         reqs = OrderedDict()
303         for name, body in high.items():
304             if name.startswith("__"):
305                 continue
306             if not isinstance(name, str):
307                 errors.append(
308                     "ID '{}' in SLS '{}' is not formed as a string, but is a {}".format(
309                         name, body["__sls__"], type(name).__name__
310                     )
311                 )
312             if not isinstance(body, dict):
313                 err = "The type {} in {} is not formatted as a dictionary".format(
314                     name, body
315                 )
316                 errors.append(err)
317                 continue
318             for state in body:
319                 if state.startswith("__"):
320                     continue
321                 if not isinstance(body[state], list):
322                     errors.append(
323                         "State '{}' in SLS '{}' is not formed as a list".format(
324                             name, body["__sls__"]
325                         )
326                     )
327                 else:
328                     fun = 0
329                     if "." in state:
330                         fun += 1
331                     for arg in body[state]:
332                         if isinstance(arg, str):
333                             fun += 1
334                             if " " in arg.strip():
335                                 errors.append(
336                                     'The function "{}" in state '
337                                     '"{}" in SLS "{}" has '
338                                     "whitespace, a function with whitespace is "
339                                     "not supported, perhaps this is an argument "
340                                     'that is missing a ":"'.format(
341                                         arg, name, body["__sls__"]
342                                     )
343                                 )
344                         elif isinstance(arg, dict):
345                             argfirst = next(iter(arg))
346                             if argfirst in ("require", "watch", "prereq", "onchanges"):
347                                 if not isinstance(arg[argfirst], list):
348                                     errors.append(
349                                         "The {} statement in state '{}' in SLS '{}' "
350                                         "needs to be formed as a list".format(
351                                             argfirst, name, body["__sls__"]
352                                         )
353                                     )
354                                 else:
355                                     reqs[name] = {"state": state}
356                                     for req in arg[argfirst]:
357                                         if isinstance(req, str):
358                                             req = {"id": req}
359                                         if not isinstance(req, dict):
360                                             errors.append(
361                                                 "Requisite declaration {} in SLS {} "
362                                                 "is not formed as a single key "
363                                                 "dictionary".format(
364                                                     req, body["__sls__"]
365                                                 )
366                                             )
367                                             continue
368                                         req_key = next(iter(req))
369                                         req_val = req[req_key]
370                                         if "." in req_key:
371                                             errors.append(
372                                                 "Invalid requisite type '{}' "
373                                                 "in state '{}', in SLS "
374                                                 "'{}'. Requisite types must "
375                                                 "not contain dots, did you "
376                                                 "mean '{}'?".format(
377                                                     req_key,
378                                                     name,
379                                                     body["__sls__"],
380                                                     req_key[: req_key.find(".")],
381                                                 )
382                                             )
383                                         if not ishashable(req_val):
384                                             errors.append(
385                                                 'Illegal requisite "{}", is SLS {}\n'.format(
386                                                     str(req_val),
387                                                     body["__sls__"],
388                                                 )
389                                             )
390                                             continue
391                                         reqs[name][req_val] = req_key
392                                         if req_val in reqs:
393                                             if name in reqs[req_val]:
394                                                 if reqs[req_val][name] == state:
395                                                     if (
396                                                         reqs[req_val]["state"]
397                                                         == reqs[name][req_val]
398                                                     ):
399                                                         errors.append(
400                                                             "A recursive requisite was"
401                                                             ' found, SLS "{}" ID "{}"'
402                                                             ' ID "{}"'.format(
403                                                                 body["__sls__"],
404                                                                 name,
405                                                                 req_val,
406                                                             )
407                                                         )
408                                 if len(list(arg)) != 1:
409                                     errors.append(
410                                         "Multiple dictionaries defined in argument "
411                                         "of state '{}' in SLS '{}'".format(
412                                             name, body["__sls__"]
413                                         )
414                                     )
415                     if not fun:
416                         if state == "require" or state == "watch":
417                             continue
418                         errors.append(
419                             "No function declared in state '{}' in SLS '{}'".format(
420                                 state, body["__sls__"]
421                             )
422                         )
423                     elif fun &gt; 1:
424                         errors.append(
425                             "Too many functions declared in state '{}' in "
426                             "SLS '{}'".format(state, body["__sls__"])
427                         )
428         return errors
429     def order_chunks(self, chunks):
430         cap = 1
431         for chunk in chunks:
432             if "order" in chunk:
433                 if not isinstance(chunk["order"], int):
434                     continue
435                 chunk_order = chunk["order"]
436                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
437                     cap = chunk_order + 100
438         for chunk in chunks:
439             if "order" not in chunk:
440                 chunk["order"] = cap
441                 continue
442             if not isinstance(chunk["order"], (int, float)):
443                 if chunk["order"] == "last":
444                     chunk["order"] = cap + 1000000
445                 elif chunk["order"] == "first":
446                     chunk["order"] = 0
447                 else:
448                     chunk["order"] = cap
449             if "name_order" in chunk:
450                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
451             if chunk["order"] &lt; 0:
452                 chunk["order"] = cap + 1000000 + chunk["order"]
453             chunk["name"] = salt.utils.data.decode(chunk["name"])
454         chunks.sort(
455             key=lambda chunk: (
456                 chunk["order"],
457                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
458             )
459         )
460         return chunks
461     def compile_high_data(self, high):
462         chunks = []
463         for name, body in high.items():
464             if name.startswith("__"):
465                 continue
466             for state, run in body.items():
467                 funcs = set()
468                 names = []
469                 if state.startswith("__"):
470                     continue
471                 chunk = {"state": state, "name": name}
472                 if "__sls__" in body:
473                     chunk["__sls__"] = body["__sls__"]
474                 if "__env__" in body:
475                     chunk["__env__"] = body["__env__"]
476                 chunk["__id__"] = name
477                 for arg in run:
478                     if isinstance(arg, str):
479                         funcs.add(arg)
480                         continue
481                     if isinstance(arg, dict):
482                         for key, val in arg.items():
483                             if key == "names":
484                                 for _name in val:
485                                     if _name not in names:
486                                         names.append(_name)
487                                 continue
488                             else:
489                                 chunk.update(arg)
490                 if names:
491                     name_order = 1
492                     for entry in names:
493                         live = copy.deepcopy(chunk)
494                         if isinstance(entry, dict):
495                             low_name = next(iter(entry.keys()))
496                             live["name"] = low_name
497                             list(map(live.update, entry[low_name]))
498                         else:
499                             live["name"] = entry
500                         live["name_order"] = name_order
501                         name_order = name_order + 1
502                         for fun in funcs:
503                             live["fun"] = fun
504                             chunks.append(live)
505                 else:
506                     live = copy.deepcopy(chunk)
507                     for fun in funcs:
508                         live["fun"] = fun
509                         chunks.append(live)
510         chunks = self.order_chunks(chunks)
511         return chunks
512     def apply_exclude(self, high):
513         if "__exclude__" not in high:
514             return high
515         ex_sls = set()
516         ex_id = set()
517         exclude = high.pop("__exclude__")
518         for exc in exclude:
519             if isinstance(exc, str):
520                 ex_sls.add(exc)
521             if isinstance(exc, dict):
522                 if len(exc) != 1:
523                     continue
524                 key = next(iter(exc.keys()))
525                 if key == "sls":
526                     ex_sls.add(exc["sls"])
527                 elif key == "id":
528                     ex_id.add(exc["id"])
529         if ex_sls:
530             for name, body in high.items():
531                 if name.startswith("__"):
532                     continue
533                 if body.get("__sls__", "") in ex_sls:
534                     ex_id.add(name)
535         for id_ in ex_id:
536             if id_ in high:
537                 high.pop(id_)
538         return high
539 class State:
540     def __init__(
541         self,
542         opts,
543         pillar_override=None,
544         jid=None,
545         pillar_enc=None,
546         proxy=None,
547         context=None,
548         mocked=False,
549         loader="states",
550         initial_pillar=None,
551     ):
552         self.states_loader = loader
553         if "grains" not in opts:
554             opts["grains"] = salt.loader.grains(opts)
555         self.opts = opts
556         self.proxy = proxy
557         self._pillar_override = pillar_override
558         if pillar_enc is not None:
559             try:
560                 pillar_enc = pillar_enc.lower()
561             except AttributeError:
562                 pillar_enc = str(pillar_enc).lower()
563         self._pillar_enc = pillar_enc
564         log.debug("Gathering pillar data for state run")
565         if initial_pillar and not self._pillar_override:
566             self.opts["pillar"] = initial_pillar
567         else:
568             self.opts["pillar"] = self._gather_pillar()
569             if self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._pillar_override:
570                 self.opts["pillar"] = salt.utils.dictupdate.merge(
571                     self.opts["pillar"],
572                     self._pillar_override,
573                     self.opts.get("pillar_source_merging_strategy", "smart"),
574                     self.</b></font>opts.get("renderer", "yaml"),
575                     self.opts.get("pillar_merge_lists", False),
576                 )
577         log.debug("Finished gathering pillar data for state run")
578         self.state_con = context or {}
579         self.load_modules()
580         self.active = set()
581         self.mod_init = set()
582         self.pre = {}
583         self.__run_num = 0
584         self.jid = jid
585         self.instance_id = str(id(self))
586         self.inject_globals = {}
587         self.mocked = mocked
588     def _gather_pillar(self):
589         if self._pillar_override:
590             if self._pillar_enc:
591                 try:
592                     self._pillar_override = salt.utils.crypt.decrypt(
593                         self._pillar_override,
594                         self._pillar_enc,
595                         translate_newlines=True,
596                         renderers=getattr(self, "rend", None),
597                         opts=self.opts,
598                         valid_rend=self.opts["decrypt_pillar_renderers"],
599                     )
600                 except Exception as exc:  # pylint: disable=broad-except
601                     log.error("Failed to decrypt pillar override: %s", exc)
602             if isinstance(self._pillar_override, str):
603                 try:
604                     self._pillar_override = yamlloader.load(
605                         self._pillar_override, Loader=yamlloader.SaltYamlSafeLoader
606                     )
607                 except Exception as exc:  # pylint: disable=broad-except
608                     log.error("Failed to load CLI pillar override")
609                     log.exception(exc)
610             if not isinstance(self._pillar_override, dict):
611                 log.error("Pillar override was not passed as a dictionary")
612                 self._pillar_override = None
613         pillar = salt.pillar.get_pillar(
614             self.opts,
615             self.opts["grains"],
616             self.opts["id"],
617             self.opts["saltenv"],
618             pillar_override=self._pillar_override,
619             pillarenv=self.opts.get("pillarenv"),
620         )
621         return pillar.compile_pillar()
622     def _mod_init(self, low):
623         try:
624             self.states[
625                 "{}.{}".format(low["state"], low["fun"])
626             ]  # pylint: disable=W0106
627         except KeyError:
628             return
629         minit = "{}.mod_init".format(low["state"])
630         if low["state"] not in self.mod_init:
631             if minit in self.states._dict:
632                 mret = self.states[minit](low)
633                 if not mret:
634                     return
635                 self.mod_init.add(low["state"])
636     def _aggregate_requisites(self, low, chunks):
637         requisites = {}
638         low_state = low["state"]
639         for chunk in chunks:
640             if chunk["state"] == low["state"] and chunk.get("__agg__"):
641                 for req in frozenset.union(
642                     *[STATE_REQUISITE_KEYWORDS, STATE_REQUISITE_IN_KEYWORDS]
643                 ):
644                     if req in chunk:
645                         if req in requisites:
646                             requisites[req].extend(chunk[req])
647                         else:
648                             requisites[req] = chunk[req]
649         low.update(requisites)
650         return low
651     def _mod_aggregate(self, low, running, chunks):
652         agg_opt = self.functions["config.option"]("state_aggregate")
653         if "aggregate" in low:
654             agg_opt = low["aggregate"]
655         if agg_opt is True:
656             agg_opt = [low["state"]]
657         elif not isinstance(agg_opt, list):
658             return low
659         if low["state"] in agg_opt and not low.get("__agg__"):
660             agg_fun = "{}.mod_aggregate".format(low["state"])
661             if agg_fun in self.states:
662                 try:
663                     low = self.states[agg_fun](low, chunks, running)
664                     low = self._aggregate_requisites(low, chunks)
665                     low["__agg__"] = True
666                 except TypeError:
667                     log.error("Failed to execute aggregate for state %s", low["state"])
668         return low
669     def _run_check(self, low_data):
670         ret = {"result": False, "comment": []}
671         cmd_opts = {}
672         POSSIBLE_CMD_ARGS = (
673             "cwd",
674             "root",
675             "runas",
676             "env",
677             "prepend_path",
678             "umask",
679             "timeout",
680             "success_retcodes",
681         )
682         for run_cmd_arg in POSSIBLE_CMD_ARGS:
683             cmd_opts[run_cmd_arg] = low_data.get(run_cmd_arg)
684         if "shell" in low_data:
685             cmd_opts["shell"] = low_data["shell"]
686         elif "shell" in self.opts["grains"]:
687             cmd_opts["shell"] = self.opts["grains"].get("shell")
688         if "onlyif" in low_data:
689             _ret = self._run_check_onlyif(low_data, cmd_opts)
690             ret["result"] = _ret["result"]
691             ret["comment"].append(_ret["comment"])
692             if "skip_watch" in _ret:
693                 ret["skip_watch"] = _ret["skip_watch"]
694         if "unless" in low_data:
695             _ret = self._run_check_unless(low_data, cmd_opts)
696             ret["result"] = _ret["result"] or ret["result"]
697             ret["comment"].append(_ret["comment"])
698             if "skip_watch" in _ret:
699                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
700         if "creates" in low_data:
701             _ret = self._run_check_creates(low_data)
702             ret["result"] = _ret["result"] or ret["result"]
703             ret["comment"].append(_ret["comment"])
704             if "skip_watch" in _ret:
705                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
706         return ret
707     def _run_check_function(self, entry):
708         fun = entry.pop("fun")
709         args = entry.pop("args") if "args" in entry else []
710         cdata = {"args": args, "kwargs": entry}
711         self.format_slots(cdata)
712         return self.functions[fun](*cdata["args"], **cdata["kwargs"])
713     def _run_check_onlyif(self, low_data, cmd_opts):
714         ret = {"result": False}
715         if not isinstance(low_data["onlyif"], list):
716             low_data_onlyif = [low_data["onlyif"]]
717         else:
718             low_data_onlyif = low_data["onlyif"]
719         def _check_cmd(cmd):
720             if cmd != 0 and ret["result"] is False:
721                 ret.update(
722                     {
723                         "comment": "onlyif condition is false",
724                         "skip_watch": True,
725                         "result": True,
726                     }
727                 )
728                 return False
729             elif cmd == 0:
730                 ret.update({"comment": "onlyif condition is true", "result": False})
731             return True
732         for entry in low_data_onlyif:
733             if isinstance(entry, str):
734                 try:
735                     cmd = self.functions["cmd.retcode"](
736                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
737                     )
738                 except CommandExecutionError:
739                     cmd = 100
740                 log.debug("Last command return code: %s", cmd)
741                 if not _check_cmd(cmd):
742                     return ret
743             elif isinstance(entry, dict):
744                 if "fun" not in entry:
745                     ret["comment"] = "no `fun` argument in onlyif: {}".format(entry)
746                     log.warning(ret["comment"])
747                     return ret
748                 get_return = entry.pop("get_return", None)
749                 result = self._run_check_function(entry)
750                 if get_return:
751                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
752                 if self.state_con.get("retcode", 0):
753                     if not _check_cmd(self.state_con["retcode"]):
754                         return ret
755                 elif not result:
756                     ret.update(
757                         {
758                             "comment": "onlyif condition is false",
759                             "skip_watch": True,
760                             "result": True,
761                         }
762                     )
763                     return ret
764                 else:
765                     ret.update({"comment": "onlyif condition is true", "result": False})
766             else:
767                 ret.update(
768                     {
769                         "comment": "onlyif execution failed, bad type passed",
770                         "result": False,
771                     }
772                 )
773                 return ret
774         return ret
775     def _run_check_unless(self, low_data, cmd_opts):
776         ret = {"result": False}
777         if not isinstance(low_data["unless"], list):
778             low_data_unless = [low_data["unless"]]
779         else:
780             low_data_unless = low_data["unless"]
781         def _check_cmd(cmd):
782             if cmd == 0:
783                 ret.update(
784                     {
785                         "comment": "unless condition is true",
786                         "skip_watch": True,
787                         "result": True,
788                     }
789                 )
790                 return False
791             else:
792                 ret.pop("skip_watch", None)
793                 ret.update({"comment": "unless condition is false", "result": False})
794                 return True
795         for entry in low_data_unless:
796             if isinstance(entry, str):
797                 try:
798                     cmd = self.functions["cmd.retcode"](
799                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
800                     )
801                     log.debug("Last command return code: %s", cmd)
802                 except CommandExecutionError:
803                     cmd = 0
804                 if _check_cmd(cmd):
805                     return ret
806             elif isinstance(entry, dict):
807                 if "fun" not in entry:
808                     ret["comment"] = "no `fun` argument in unless: {}".format(entry)
809                     log.warning(ret["comment"])
810                     return ret
811                 get_return = entry.pop("get_return", None)
812                 result = self._run_check_function(entry)
813                 if get_return:
814                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
815                 if self.state_con.get("retcode", 0):
816                     if _check_cmd(self.state_con["retcode"]):
817                         return ret
818                 elif result:
819                     ret.update(
820                         {
821                             "comment": "unless condition is true",
822                             "skip_watch": True,
823                             "result": True,
824                         }
825                     )
826                 else:
827                     ret.update(
828                         {"comment": "unless condition is false", "result": False}
829                     )
830                     return ret
831             else:
832                 ret.update(
833                     {
834                         "comment": "unless condition is false, bad type passed",
835                         "result": False,
836                     }
837                 )
838         return ret
839     def _run_check_cmd(self, low_data):
840         ret = {"result": False}
841         cmd_opts = {}
842         if "shell" in self.opts["grains"]:
843             cmd_opts["shell"] = self.opts["grains"].get("shell")
844         for entry in low_data["check_cmd"]:
845             cmd = self.functions["cmd.retcode"](
846                 entry, ignore_retcode=True, python_shell=True, **cmd_opts
847             )
848             log.debug("Last command return code: %s", cmd)
849             if cmd == 0 and ret["result"] is False:
850                 ret.update(
851                     {
852                         "comment": "check_cmd determined the state succeeded",
853                         "result": True,
854                     }
855                 )
856             elif cmd != 0:
857                 ret.update(
858                     {
859                         "comment": "check_cmd determined the state failed",
860                         "result": False,
861                     }
862                 )
863                 return ret
864         return ret
865     def _run_check_creates(self, low_data):
866         ret = {"result": False}
867         if isinstance(low_data["creates"], str) and os.path.exists(low_data["creates"]):
868             ret["comment"] = "{} exists".format(low_data["creates"])
869             ret["result"] = True
870             ret["skip_watch"] = True
871         elif isinstance(low_data["creates"], list) and all(
872             [os.path.exists(path) for path in low_data["creates"]]
873         ):
874             ret["comment"] = "All files in creates exist"
875             ret["result"] = True
876             ret["skip_watch"] = True
877         else:
878             ret["comment"] = "Creates files not found"
879             ret["result"] = False
880         return ret
881     def reset_run_num(self):
882         self.__run_num = 0
883     def _load_states(self):
884         if self.states_loader == "thorium":
885             self.states = salt.loader.thorium(
886                 self.opts, self.functions, {}
887             )  # TODO: Add runners, proxy?
888         else:
889             self.states = salt.loader.states(
890                 self.opts,
891                 self.functions,
892                 self.utils,
893                 self.serializers,
894                 context=self.state_con,
895                 proxy=self.proxy,
896             )
897     def load_modules(self, data=None, proxy=None):
898         log.info("Loading fresh modules for state activity")
899         self.utils = salt.loader.utils(self.opts)
900         self.functions = salt.loader.minion_mods(
901             self.opts, self.state_con, utils=self.utils, proxy=self.proxy
902         )
903         if isinstance(data, dict):
904             if data.get("provider", False):
905                 if isinstance(data["provider"], str):
906                     providers = [{data["state"]: data["provider"]}]
907                 elif isinstance(data["provider"], list):
908                     providers = data["provider"]
909                 else:
910                     providers = {}
911                 for provider in providers:
912                     for mod in provider:
913                         funcs = salt.loader.raw_mod(
914                             self.opts, provider[mod], self.functions
915                         )
916                         if funcs:
917                             for func in funcs:
918                                 f_key = "{}{}".format(mod, func[func.rindex(".") :])
919                                 self.functions[f_key] = funcs[func]
920         self.serializers = salt.loader.serializers(self.opts)
921         self._load_states()
922         self.rend = salt.loader.render(
923             self.opts,
924             self.functions,
925             states=self.states,
926             proxy=self.proxy,
927             context=self.state_con,
928         )
929     def module_refresh(self):
930         log.debug("Refreshing modules...")
931         if self.opts["grains"].get("os") != "MacOS":
932             try:
933                 importlib.reload(site)
934             except RuntimeError:
935                 log.error(
936                     "Error encountered during module reload. Modules were not reloaded."
937                 )
938             except TypeError:
939                 log.error(
940                     "Error encountered during module reload. Modules were not reloaded."
941                 )
942         self.load_modules()
943         if not self.opts.get("local", False) and self.opts.get("multiprocessing", True):
944             self.functions["saltutil.refresh_modules"]()
945     def check_refresh(self, data, ret):
946         _reload_modules = False
947         if data.get("reload_grains", False):
948             log.debug("Refreshing grains...")
949             self.opts["grains"] = salt.loader.grains(self.opts)
950             _reload_modules = True
951         if data.get("reload_pillar", False):
952             log.debug("Refreshing pillar...")
953             self.opts["pillar"] = self._gather_pillar()
954             _reload_modules = True
955         if not ret["changes"]:
956             if data.get("force_reload_modules", False):
957                 self.module_refresh()
958             return
959         if data.get("reload_modules", False) or _reload_modules:
960             self.module_refresh()
961             return
962         if data["state"] == "file":
963             if data["fun"] == "managed":
964                 if data["name"].endswith((".py", ".pyx", ".pyo", ".pyc", ".so")):
965                     self.module_refresh()
966             elif data["fun"] == "recurse":
967                 self.module_refresh()
968             elif data["fun"] == "symlink":
969                 if "bin" in data["name"]:
970                     self.module_refresh()
971         elif data["state"] in ("pkg", "ports", "pip"):
972             self.module_refresh()
973     def verify_data(self, data):
974         errors = []
975         if "state" not in data:
976             errors.append('Missing "state" data')
977         if "fun" not in data:
978             errors.append('Missing "fun" data')
979         if "name" not in data:
980             errors.append('Missing "name" data')
981         if data["name"] and not isinstance(data["name"], str):
982             errors.append(
983                 "ID '{}' {}is not formed as a string, but is a {}".format(
984                     data["name"],
985                     "in SLS '{}' ".format(data["__sls__"]) if "__sls__" in data else "",
986                     type(data["name"]).__name__,
987                 )
988             )
989         if errors:
990             return errors
991         full = data["state"] + "." + data["fun"]
992         if full not in self.states:
993             if "__sls__" in data:
994                 errors.append(
995                     "State '{}' was not found in SLS '{}'".format(full, data["__sls__"])
996                 )
997                 reason = self.states.missing_fun_string(full)
998                 if reason:
999                     errors.append("Reason: {}".format(reason))
1000             else:
1001                 errors.append("Specified state '{}' was not found".format(full))
1002         else:
1003             aspec = salt.utils.args.get_function_argspec(self.states[full])
1004             arglen = 0
1005             deflen = 0
1006             if isinstance(aspec.args, list):
1007                 arglen = len(aspec.args)
1008             if isinstance(aspec.defaults, tuple):
1009                 deflen = len(aspec.defaults)
1010             for ind in range(arglen - deflen):
1011                 if aspec.args[ind] not in data:
1012                     errors.append(
1013                         "Missing parameter {} for state {}".format(
1014                             aspec.args[ind], full
1015                         )
1016                     )
1017         reqdec = ""
1018         if "require" in data:
1019             reqdec = "require"
1020         if "watch" in data:
1021             if "{}.mod_watch".format(data["state"]) not in self.states:
1022                 if "require" in data:
1023                     data["require"].extend(data.pop("watch"))
1024                 else:
1025                     data["require"] = data.pop("watch")
1026                 reqdec = "require"
1027             else:
1028                 reqdec = "watch"
1029         if reqdec:
1030             for req in data[reqdec]:
1031                 reqfirst = next(iter(req))
1032                 if data["state"] == reqfirst:
1033                     if fnmatch.fnmatch(data["name"], req[reqfirst]) or fnmatch.fnmatch(
1034                         data["__id__"], req[reqfirst]
1035                     ):
1036                         errors.append(
1037                             "Recursive require detected in SLS {} for "
1038                             "require {} in ID {}".format(
1039                                 data["__sls__"], req, data["__id__"]
1040                             )
1041                         )
1042         return errors
1043     def verify_high(self, high):
1044         errors = []
1045         if not isinstance(high, dict):
1046             errors.append("High data is not a dictionary and is invalid")
1047         reqs = OrderedDict()
1048         for name, body in high.items():
1049             try:
1050                 if name.startswith("__"):
1051                     continue
1052             except AttributeError:
1053                 pass
1054             if not isinstance(name, str):
1055                 errors.append(
1056                     "ID '{}' in SLS '{}' is not formed as a string, but "
1057                     "is a {}. It may need to be quoted.".format(
1058                         name, body["__sls__"], type(name).__name__
1059                     )
1060                 )
1061             if not isinstance(body, dict):
1062                 err = "The type {} in {} is not formatted as a dictionary".format(
1063                     name, body
1064                 )
1065                 errors.append(err)
1066                 continue
1067             for state in body:
1068                 if state.startswith("__"):
1069                     continue
1070                 if body[state] is None:
1071                     errors.append(
1072                         "ID '{}' in SLS '{}' contains a short declaration "
1073                         "({}) with a trailing colon. When not passing any "
1074                         "arguments to a state, the colon must be omitted.".format(
1075                             name, body["__sls__"], state
1076                         )
1077                     )
1078                     continue
1079                 if not isinstance(body[state], list):
1080                     errors.append(
1081                         "State '{}' in SLS '{}' is not formed as a list".format(
1082                             name, body["__sls__"]
1083                         )
1084                     )
1085                 else:
1086                     fun = 0
1087                     if "." in state:
1088                         fun += 1
1089                     for arg in body[state]:
1090                         if isinstance(arg, str):
1091                             fun += 1
1092                             if " " in arg.strip():
1093                                 errors.append(
1094                                     'The function "{}" in state "{}" in SLS "{}" has '
1095                                     "whitespace, a function with whitespace is not "
1096                                     "supported, perhaps this is an argument that is "
1097                                     'missing a ":"'.format(arg, name, body["__sls__"])
1098                                 )
1099                         elif isinstance(arg, dict):
1100                             argfirst = next(iter(arg))
1101                             if argfirst == "names":
1102                                 if not isinstance(arg[argfirst], list):
1103                                     errors.append(
1104                                         "The 'names' argument in state "
1105                                         "'{}' in SLS '{}' needs to be "
1106                                         "formed as a list".format(name, body["__sls__"])
1107                                     )
1108                             if argfirst in ("require", "watch", "prereq", "onchanges"):
1109                                 if not isinstance(arg[argfirst], list):
1110                                     errors.append(
1111                                         "The {} statement in state '{}' in "
1112                                         "SLS '{}' needs to be formed as a "
1113                                         "list".format(argfirst, name, body["__sls__"])
1114                                     )
1115                                 else:
1116                                     reqs[name] = OrderedDict(state=state)
1117                                     for req in arg[argfirst]:
1118                                         if isinstance(req, str):
1119                                             req = {"id": req}
1120                                         if not isinstance(req, dict):
1121                                             errors.append(
1122                                                 "Requisite declaration {} in SLS {} is"
1123                                                 " not formed as a single key dictionary".format(
1124                                                     req, body["__sls__"]
1125                                                 )
1126                                             )
1127                                             continue
1128                                         req_key = next(iter(req))
1129                                         req_val = req[req_key]
1130                                         if "." in req_key:
1131                                             errors.append(
1132                                                 "Invalid requisite type '{}' "
1133                                                 "in state '{}', in SLS "
1134                                                 "'{}'. Requisite types must "
1135                                                 "not contain dots, did you "
1136                                                 "mean '{}'?".format(
1137                                                     req_key,
1138                                                     name,
1139                                                     body["__sls__"],
1140                                                     req_key[: req_key.find(".")],
1141                                                 )
1142                                             )
1143                                         if not ishashable(req_val):
1144                                             errors.append(
1145                                                 'Illegal requisite "{}", please check '
1146                                                 "your syntax.\n".format(req_val)
1147                                             )
1148                                             continue
1149                                         reqs[name][req_val] = req_key
1150                                         if req_val in reqs:
1151                                             if name in reqs[req_val]:
1152                                                 if reqs[req_val][name] == state:
1153                                                     if (
1154                                                         reqs[req_val]["state"]
1155                                                         == reqs[name][req_val]
1156                                                     ):
1157                                                         errors.append(
1158                                                             "A recursive requisite was"
1159                                                             ' found, SLS "{}" ID "{}"'
1160                                                             ' ID "{}"'.format(
1161                                                                 body["__sls__"],
1162                                                                 name,
1163                                                                 req_val,
1164                                                             )
1165                                                         )
1166                                 if len(list(arg)) != 1:
1167                                     errors.append(
1168                                         "Multiple dictionaries defined in "
1169                                         "argument of state '{}' in SLS '{}'".format(
1170                                             name, body["__sls__"]
1171                                         )
1172                                     )
1173                     if not fun:
1174                         if state == "require" or state == "watch":
1175                             continue
1176                         errors.append(
1177                             "No function declared in state '{}' in SLS '{}'".format(
1178                                 state, body["__sls__"]
1179                             )
1180                         )
1181                     elif fun &gt; 1:
1182                         errors.append(
1183                             "Too many functions declared in state '{}' in "
1184                             "SLS '{}'".format(state, body["__sls__"])
1185                         )
1186         return errors
1187     def verify_chunks(self, chunks):
1188         err = []
1189         for chunk in chunks:
1190             err.extend(self.verify_data(chunk))
1191         return err
1192     def order_chunks(self, chunks):
1193         cap = 1
1194         for chunk in chunks:
1195             if "order" in chunk:
1196                 if not isinstance(chunk["order"], int):
1197                     continue
1198                 chunk_order = chunk["order"]
1199                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
1200                     cap = chunk_order + 100
1201         for chunk in chunks:
1202             if "order" not in chunk:
1203                 chunk["order"] = cap
1204                 continue
1205             if not isinstance(chunk["order"], (int, float)):
1206                 if chunk["order"] == "last":
1207                     chunk["order"] = cap + 1000000
1208                 elif chunk["order"] == "first":
1209                     chunk["order"] = 0
1210                 else:
1211                     chunk["order"] = cap
1212             if "name_order" in chunk:
1213                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
1214             if chunk["order"] &lt; 0:
1215                 chunk["order"] = cap + 1000000 + chunk["order"]
1216         chunks.sort(
1217             key=lambda chunk: (
1218                 chunk["order"],
1219                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
1220             )
1221         )
1222         return chunks
1223     def compile_high_data(self, high, orchestration_jid=None):
1224         chunks = []
1225         for name, body in high.items():
1226             if name.startswith("__"):
1227                 continue
1228             for state, run in body.items():
1229                 funcs = set()
1230                 names = []
1231                 if state.startswith("__"):
1232                     continue
1233                 chunk = {"state": state, "name": name}
1234                 if orchestration_jid is not None:
1235                     chunk["__orchestration_jid__"] = orchestration_jid
1236                 if "__sls__" in body:
1237                     chunk["__sls__"] = body["__sls__"]
1238                 if "__env__" in body:
1239                     chunk["__env__"] = body["__env__"]
1240                 chunk["__id__"] = name
1241                 for arg in run:
1242                     if isinstance(arg, str):
1243                         funcs.add(arg)
1244                         continue
1245                     if isinstance(arg, dict):
1246                         for key, val in arg.items():
1247                             if key == "names":
1248                                 for _name in val:
1249                                     if _name not in names:
1250                                         names.append(_name)
1251                             elif key == "state":
1252                                 continue
1253                             elif key == "name" and not isinstance(val, str):
1254                                 chunk[key] = name
1255                             else:
1256                                 chunk[key] = val
1257                 if names:
1258                     name_order = 1
1259                     for entry in names:
1260                         live = copy.deepcopy(chunk)
1261                         if isinstance(entry, dict):
1262                             low_name = next(iter(entry.keys()))
1263                             live["name"] = low_name
1264                             list(map(live.update, entry[low_name]))
1265                         else:
1266                             live["name"] = entry
1267                         live["name_order"] = name_order
1268                         name_order += 1
1269                         for fun in funcs:
1270                             live["fun"] = fun
1271                             chunks.append(live)
1272                 else:
1273                     live = copy.deepcopy(chunk)
1274                     for fun in funcs:
1275                         live["fun"] = fun
1276                         chunks.append(live)
1277         chunks = self.order_chunks(chunks)
1278         return chunks
1279     def reconcile_extend(self, high, strict=False):
1280         errors = []
1281         if "__extend__" not in high:
1282             return high, errors
1283         ext = high.pop("__extend__")
1284         for ext_chunk in ext:
1285             for name, body in ext_chunk.items():
1286                 state_type = next(x for x in body if not x.startswith("__"))
1287                 if name not in high or state_type not in high[name]:
1288                     ids = find_name(name, state_type, high, strict=strict)
1289                     if len(ids) != 1:
1290                         errors.append(
1291                             "Cannot extend ID '{0}' in '{1}:{2}'. It is not "
1292                             "part of the high state.\n"
1293                             "This is likely due to a missing include statement "
1294                             "or an incorrectly typed ID.\nEnsure that a "
1295                             "state with an ID of '{0}' is available\nin "
1296                             "environment '{1}' and to SLS '{2}'".format(
1297                                 name,
1298                                 body.get("__env__", "base"),
1299                                 body.get("__sls__", "base"),
1300                             )
1301                         )
1302                         continue
1303                     else:
1304                         name = ids[0][0]
1305                 for state, run in body.items():
1306                     if state.startswith("__"):
1307                         continue
1308                     if state not in high[name]:
1309                         high[name][state] = run
1310                         continue
1311                     for arg in run:
1312                         update = False
1313                         for hind, val in enumerate(high[name][state]):
1314                             if isinstance(arg, str) and isinstance(val, str):
1315                                 high[name][state].pop(hind)
1316                                 high[name][state].insert(hind, arg)
1317                                 update = True
1318                                 continue
1319                             if isinstance(arg, dict) and isinstance(val, dict):
1320                                 argfirst = next(iter(arg))
1321                                 if argfirst == next(iter(high[name][state][hind])):
1322                                     if argfirst in STATE_REQUISITE_KEYWORDS:
1323                                         high[name][state][hind][argfirst].extend(
1324                                             arg[argfirst]
1325                                         )
1326                                     else:
1327                                         high[name][state][hind] = arg
1328                                     update = True
1329                                 if (
1330                                     argfirst == "name"
1331                                     and next(iter(high[name][state][hind])) == "names"
1332                                 ):
1333                                     high[name][state][hind] = arg
1334                         if not update:
1335                             high[name][state].append(arg)
1336         return high, errors
1337     def apply_exclude(self, high):
1338         if "__exclude__" not in high:
1339             return high
1340         ex_sls = set()
1341         ex_id = set()
1342         exclude = high.pop("__exclude__")
1343         for exc in exclude:
1344             if isinstance(exc, str):
1345                 ex_sls.add(exc)
1346             if isinstance(exc, dict):
1347                 if len(exc) != 1:
1348                     continue
1349                 key = next(iter(exc.keys()))
1350                 if key == "sls":
1351                     ex_sls.add(exc["sls"])
1352                 elif key == "id":
1353                     ex_id.add(exc["id"])
1354         if ex_sls:
1355             for name, body in high.items():
1356                 if name.startswith("__"):
1357                     continue
1358                 sls = body.get("__sls__", "")
1359                 if not sls:
1360                     continue
1361                 for ex_ in ex_sls:
1362                     if fnmatch.fnmatch(sls, ex_):
1363                         ex_id.add(name)
1364         for id_ in ex_id:
1365             if id_ in high:
1366                 high.pop(id_)
1367         return high
1368     def requisite_in(self, high):
1369         req_in = {
1370             "require_in",
1371             "watch_in",
1372             "onfail_in",
1373             "onchanges_in",
1374             "use",
1375             "use_in",
1376             "prereq",
1377             "prereq_in",
1378         }
1379         req_in_all = req_in.union(
1380             {"require", "watch", "onfail", "onfail_stop", "onchanges"}
1381         )
1382         extend = {}
1383         errors = []
1384         disabled_reqs = self.opts.get("disabled_requisites", [])
1385         if not isinstance(disabled_reqs, list):
1386             disabled_reqs = [disabled_reqs]
1387         for id_, body in high.items():
1388             if not isinstance(body, dict):
1389                 continue
1390             for state, run in body.items():
1391                 if state.startswith("__"):
1392                     continue
1393                 for arg in run:
1394                     if isinstance(arg, dict):
1395                         if len(arg) &lt; 1:
1396                             continue
1397                         key = next(iter(arg))
1398                         if key not in req_in:
1399                             continue
1400                         if key in disabled_reqs:
1401                             log.warning(
1402                                 "The %s requisite has been disabled, Ignoring.", key
1403                             )
1404                             continue
1405                         rkey = key.split("_")[0]
1406                         items = arg[key]
1407                         if isinstance(items, dict):
1408                             for _state, name in items.items():
1409                                 found = False
1410                                 if name not in extend:
1411                                     extend[name] = OrderedDict()
1412                                 if "." in _state:
1413                                     errors.append(
1414                                         "Invalid requisite in {}: {} for "
1415                                         "{}, in SLS '{}'. Requisites must "
1416                                         "not contain dots, did you mean '{}'?".format(
1417                                             rkey,
1418                                             _state,
1419                                             name,
1420                                             body["__sls__"],
1421                                             _state[: _state.find(".")],
1422                                         )
1423                                     )
1424                                     _state = _state.split(".")[0]
1425                                 if _state not in extend[name]:
1426                                     extend[name][_state] = []
1427                                 extend[name]["__env__"] = body["__env__"]
1428                                 extend[name]["__sls__"] = body["__sls__"]
1429                                 for ind in range(len(extend[name][_state])):
1430                                     if next(iter(extend[name][_state][ind])) == rkey:
1431                                         extend[name][_state][ind][rkey].append(
1432                                             {state: id_}
1433                                         )
1434                                         found = True
1435                                 if found:
1436                                     continue
1437                                 extend[name][_state].append({rkey: [{state: id_}]})
1438                         if isinstance(items, list):
1439                             hinges = []
1440                             for ind in items:
1441                                 if not isinstance(ind, dict):
1442                                     if ind in high:
1443                                         _ind_high = [
1444                                             x
1445                                             for x in high[ind]
1446                                             if not x.startswith("__")
1447                                         ]
1448                                         ind = {_ind_high[0]: ind}
1449                                     else:
1450                                         found = False
1451                                         for _id in iter(high):
1452                                             for state in [
1453                                                 state
1454                                                 for state in iter(high[_id])
1455                                                 if not state.startswith("__")
1456                                             ]:
1457                                                 for j in iter(high[_id][state]):
1458                                                     if (
1459                                                         isinstance(j, dict)
1460                                                         and "name" in j
1461                                                     ):
1462                                                         if j["name"] == ind:
1463                                                             ind = {state: _id}
1464                                                             found = True
1465                                         if not found:
1466                                             continue
1467                                 if len(ind) &lt; 1:
1468                                     continue
1469                                 pstate = next(iter(ind))
1470                                 pname = ind[pstate]
1471                                 if pstate == "sls":
1472                                     hinges = find_sls_ids(pname, high)
1473                                 else:
1474                                     hinges.append((pname, pstate))
1475                                 if "." in pstate:
1476                                     errors.append(
1477                                         "Invalid requisite in {}: {} for "
1478                                         "{}, in SLS '{}'. Requisites must "
1479                                         "not contain dots, did you mean '{}'?".format(
1480                                             rkey,
1481                                             pstate,
1482                                             pname,
1483                                             body["__sls__"],
1484                                             pstate[: pstate.find(".")],
1485                                         )
1486                                     )
1487                                     pstate = pstate.split(".")[0]
1488                                 for tup in hinges:
1489                                     name, _state = tup
1490                                     if key == "prereq_in":
1491                                         if id_ not in extend:
1492                                             extend[id_] = OrderedDict()
1493                                         if state not in extend[id_]:
1494                                             extend[id_][state] = []
1495                                         extend[id_][state].append(
1496                                             {"prerequired": [{_state: name}]}
1497                                         )
1498                                     if key == "prereq":
1499                                         ext_ids = find_name(
1500                                             name, _state, high, strict=True
1501                                         )
1502                                         for ext_id, _req_state in ext_ids:
1503                                             if ext_id not in extend:
1504                                                 extend[ext_id] = OrderedDict()
1505                                             if _req_state not in extend[ext_id]:
1506                                                 extend[ext_id][_req_state] = []
1507                                             extend[ext_id][_req_state].append(
1508                                                 {"prerequired": [{state: id_}]}
1509                                             )
1510                                         continue
1511                                     if key == "use_in":
1512                                         ext_ids = find_name(
1513                                             name, _state, high, strict=True
1514                                         )
1515                                         for ext_id, _req_state in ext_ids:
1516                                             if not ext_id:
1517                                                 continue
1518                                             ext_args = state_args(ext_id, _state, high)
1519                                             if ext_id not in extend:
1520                                                 extend[ext_id] = OrderedDict()
1521                                             if _req_state not in extend[ext_id]:
1522                                                 extend[ext_id][_req_state] = []
1523                                             ignore_args = req_in_all.union(ext_args)
1524                                             for arg in high[id_][state]:
1525                                                 if not isinstance(arg, dict):
1526                                                     continue
1527                                                 if len(arg) != 1:
1528                                                     continue
1529                                                 if next(iter(arg)) in ignore_args:
1530                                                     continue
1531                                                 if next(iter(arg.keys())) == "name":
1532                                                     continue
1533                                                 if next(iter(arg.keys())) == "names":
1534                                                     continue
1535                                                 extend[ext_id][_req_state].append(arg)
1536                                         continue
1537                                     if key == "use":
1538                                         ext_ids = find_name(
1539                                             name, _state, high, strict=True
1540                                         )
1541                                         for ext_id, _req_state in ext_ids:
1542                                             if not ext_id:
1543                                                 continue
1544                                             loc_args = state_args(id_, state, high)
1545                                             if id_ not in extend:
1546                                                 extend[id_] = OrderedDict()
1547                                             if state not in extend[id_]:
1548                                                 extend[id_][state] = []
1549                                             ignore_args = req_in_all.union(loc_args)
1550                                             for arg in high[ext_id][_req_state]:
1551                                                 if not isinstance(arg, dict):
1552                                                     continue
1553                                                 if len(arg) != 1:
1554                                                     continue
1555                                                 if next(iter(arg)) in ignore_args:
1556                                                     continue
1557                                                 if next(iter(arg.keys())) == "name":
1558                                                     continue
1559                                                 if next(iter(arg.keys())) == "names":
1560                                                     continue
1561                                                 extend[id_][state].append(arg)
1562                                         continue
1563                                     found = False
1564                                     if name not in extend:
1565                                         extend[name] = OrderedDict()
1566                                     if _state not in extend[name]:
1567                                         extend[name][_state] = []
1568                                     extend[name]["__env__"] = body["__env__"]
1569                                     extend[name]["__sls__"] = body["__sls__"]
1570                                     for ind in range(len(extend[name][_state])):
1571                                         if (
1572                                             next(iter(extend[name][_state][ind]))
1573                                             == rkey
1574                                         ):
1575                                             extend[name][_state][ind][rkey].append(
1576                                                 {state: id_}
1577                                             )
1578                                             found = True
1579                                     if found:
1580                                         continue
1581                                     extend[name][_state].append({rkey: [{state: id_}]})
1582         high["__extend__"] = []
1583         for key, val in extend.items():
1584             high["__extend__"].append({key: val})
1585         req_in_high, req_in_errors = self.reconcile_extend(high, strict=True)
1586         errors.extend(req_in_errors)
1587         return req_in_high, errors
1588     def _call_parallel_target(self, name, cdata, low):
1589         utc_start_time = datetime.datetime.utcnow()
1590         self.format_slots(cdata)
1591         tag = _gen_tag(low)
1592         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try:
1593             ret = self.states[cdata["full"]](*cdata["args"], **cdata["kwargs"])
1594         except Exception as exc:  # pylint: disable=broad-except
1595             log.debug(
1596                 "An exception occurred in this state: %s",
1597                 exc,
1598                 exc_info_on_loglevel=</b></font>logging.DEBUG,
1599             )
1600             trb = traceback.format_exc()
1601             ret = {
1602                 "result": False,
1603                 "name": name,
1604                 "changes": {},
1605                 "comment": "An exception occurred in this state: {}".format(trb),
1606             }
1607         utc_finish_time = datetime.datetime.utcnow()
1608         delta = utc_finish_time - utc_start_time
1609         duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
1610         ret["duration"] = duration
1611         troot = os.path.join(self.opts["cachedir"], self.jid)
1612         tfile = os.path.join(troot, salt.utils.hashutils.sha1_digest(tag))
1613         if not os.path.isdir(troot):
1614             try:
1615                 os.makedirs(troot)
1616             except OSError:
1617                 pass
1618         with salt.utils.files.fopen(tfile, "wb+") as fp_:
1619             fp_.write(msgpack_serialize(ret))
1620     def call_parallel(self, cdata, low):
1621         name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1622         if not name:
1623             name = low.get("name", low.get("__id__"))
1624         proc = salt.utils.process.Process(
1625             target=self._call_parallel_target,
1626             args=(name, cdata, low),
1627             name="ParallelState({})".format(name),
1628         )
1629         proc.start()
1630         ret = {
1631             "name": name,
1632             "result": None,
1633             "changes": {},
1634             "comment": "Started in a separate process",
1635             "proc": proc,
1636         }
1637         return ret
1638     @salt.utils.decorators.state.OutputUnifier("content_check", "unify")
1639     def call(self, low, chunks=None, running=None, retries=1):
1640         utc_start_time = datetime.datetime.utcnow()
1641         local_start_time = utc_start_time - (
1642             datetime.datetime.utcnow() - datetime.datetime.now()
1643         )
1644         log.info(
1645             "Running state [%s] at time %s",
1646             low["name"].strip() if isinstance(low["name"], str) else low["name"],
1647             local_start_time.time().isoformat(),
1648         )
1649         errors = self.verify_data(low)
1650         if errors:
1651             ret = {
1652                 "result": False,
1653                 "name": low["name"],
1654                 "changes": {},
1655                 "comment": "",
1656             }
1657             for err in errors:
1658                 ret["comment"] += "{}\n".format(err)
1659             ret["__run_num__"] = self.__run_num
1660             self.__run_num += 1
1661             format_log(ret)
1662             self.check_refresh(low, ret)
1663             return ret
1664         else:
1665             ret = {"result": False, "name": low["name"], "changes": {}}
1666         self.state_con["runas"] = low.get("runas", None)
1667         if low["state"] == "cmd" and "password" in low:
1668             self.state_con["runas_password"] = low["password"]
1669         else:
1670             self.state_con["runas_password"] = low.get("runas_password", None)
1671         if not low.get("__prereq__"):
1672             log.info(
1673                 "Executing state %s.%s for [%s]",
1674                 low["state"],
1675                 low["fun"],
1676                 low["name"].strip() if isinstance(low["name"], str) else low["name"],
1677             )
1678         if "provider" in low:
1679             self.load_modules(low)
1680         state_func_name = "{0[state]}.{0[fun]}".format(low)
1681         cdata = salt.utils.args.format_call(
1682             self.states[state_func_name],
1683             low,
1684             initial_ret={"full": state_func_name},
1685             expected_extra_kws=STATE_INTERNAL_KEYWORDS,
1686         )
1687         inject_globals = {
1688             "__low__": immutabletypes.freeze(low),
1689             "__running__": immutabletypes.freeze(running) if running else {},
1690             "__instance_id__": self.instance_id,
1691             "__lowstate__": immutabletypes.freeze(chunks) if chunks else {},
1692         }
1693         if "__env__" in low:
1694             inject_globals["__env__"] = str(low["__env__"])
1695         if self.inject_globals:
1696             inject_globals.update(self.inject_globals)
1697         if low.get("__prereq__"):
1698             test = sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]
1699             sys.modules[self.states[cdata["full"]].__module__].__opts__["test"] = True
1700         try:
1701             req_list = ("unless", "onlyif", "creates")
1702             if (
1703                 any(req in low for req in req_list)
1704                 and "{0[state]}.mod_run_check".format(low) not in self.states
1705             ):
1706                 ret.update(self._run_check(low))
1707             if not self.opts.get("lock_saltenv", False):
1708                 if "saltenv" in low:
1709                     inject_globals["__env__"] = str(low["saltenv"])
1710                 elif isinstance(cdata["kwargs"].get("env", None), str):
1711                     inject_globals["__env__"] = str(cdata["kwargs"]["env"])
1712             if "__env__" not in inject_globals:
1713                 inject_globals["__env__"] = "base"
1714             if "__orchestration_jid__" in low:
1715                 inject_globals["__orchestration_jid__"] = low["__orchestration_jid__"]
1716             if "result" not in ret or ret["result"] is False:
1717                 self.states.inject_globals = inject_globals
1718                 if self.mocked:
1719                     ret = mock_ret(cdata)
1720                 else:
1721                     if not low.get("__prereq__") and low.get("parallel"):
1722                         ret = self.call_parallel(cdata, low)
1723                     else:
1724                         self.format_slots(cdata)
1725                         ret = self.states[cdata["full"]](
1726                             *cdata["args"], **cdata["kwargs"]
1727                         )
1728                 self.states.inject_globals = {}
1729             if (
1730                 "check_cmd" in low
1731                 and "{0[state]}.mod_run_check_cmd".format(low) not in self.states
1732             ):
1733                 ret.update(self._run_check_cmd(low))
1734         except Exception as exc:  # pylint: disable=broad-except
1735             log.debug(
1736                 "An exception occurred in this state: %s",
1737                 exc,
1738                 exc_info_on_loglevel=logging.DEBUG,
1739             )
1740             trb = traceback.format_exc()
1741             name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1742             if not name:
1743                 name = low.get("name", low.get("__id__"))
1744             ret = {
1745                 "result": False,
1746                 "name": name,
1747                 "changes": {},
1748                 "comment": "An exception occurred in this state: {}".format(trb),
1749             }
1750         finally:
1751             if low.get("__prereq__"):
1752                 sys.modules[self.states[cdata["full"]].__module__].__opts__[
1753                     "test"
1754                 ] = test
1755             self.state_con.pop("runas", None)
1756             self.state_con.pop("runas_password", None)
1757         if not isinstance(ret, dict):
1758             return ret
1759         if "warnings" in cdata:
1760             ret.setdefault("warnings", []).extend(cdata["warnings"])
1761         if "provider" in low:
1762             self.load_modules()
1763         if low.get("__prereq__"):
1764             low["__prereq__"] = False
1765             return ret
1766         ret["__sls__"] = low.get("__sls__")
1767         ret["__run_num__"] = self.__run_num
1768         self.__run_num += 1
1769         format_log(ret)
1770         self.check_refresh(low, ret)
1771         utc_finish_time = datetime.datetime.utcnow()
1772         timezone_delta = datetime.datetime.utcnow() - datetime.datetime.now()
1773         local_finish_time = utc_finish_time - timezone_delta
1774         local_start_time = utc_start_time - timezone_delta
1775         delta = utc_finish_time - utc_start_time
1776         duration = (delta<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.seconds * 1000000 + delta.microseconds) / 1000.0
1777         ret["duration"] = duration
1778         ret["__id__"] = low["__id__"]
1779         log.info(
1780             "Completed state [%s] at time %s (duration_in_ms=%s)",
1781             low["name"].strip(</b></font>) if isinstance(low["name"], str) else low["name"],
1782             local_finish_time.time().isoformat(),
1783             duration,
1784         )
1785         if "retry" in low:
1786             low["retry"] = self.verify_retry_data(low["retry"])
1787             if not sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]:
1788                 if low["retry"]["until"] != ret["result"]:
1789                     if low["retry"]["attempts"] &gt; retries:
1790                         interval = low["retry"]["interval"]
1791                         if low["retry"]["splay"] != 0:
1792                             interval = interval + random.randint(
1793                                 0, low["retry"]["splay"]
1794                             )
1795                         log.info(
1796                             "State result does not match retry until value, "
1797                             "state will be re-run in %s seconds",
1798                             interval,
1799                         )
1800                         self.functions["test.sleep"](interval)
1801                         retry_ret = self.call(low, chunks, running, retries=retries + 1)
1802                         orig_ret = ret
1803                         ret = retry_ret
1804                         ret["comment"] = "\n".join(
1805                             [
1806                                 'Attempt {}: Returned a result of "{}", '
1807                                 'with the following comment: "{}"'.format(
1808                                     retries, orig_ret["result"], orig_ret["comment"]
1809                                 ),
1810                                 "" if not ret["comment"] else ret["comment"],
1811                             ]
1812                         )
1813                         ret["duration"] = (
1814                             ret["duration"] + orig_ret["duration"] + (interval * 1000)
1815                         )
1816                         if retries == 1:
1817                             ret["start_time"] = orig_ret["start_time"]
1818             else:
1819                 ret["comment"] = "  ".join(
1820                     [
1821                         "" if not ret["comment"] else str(ret["comment"]),
1822                         "The state would be retried every {interval} seconds "
1823                         "(with a splay of up to {splay} seconds) a maximum of "
1824                         "{attempts} times or until a result of {until} "
1825                         "is returned".format(**low["retry"]),
1826                     ]
1827                 )
1828         return ret
1829     def __eval_slot(self, slot):
1830         log.debug("Evaluating slot: %s", slot)
1831         fmt = slot.split(":", 2)
1832         if len(fmt) != 3:
1833             log.warning("Malformed slot: %s", slot)
1834             return slot
1835         if fmt[1] != "salt":
1836             log.warning("Malformed slot: %s", slot)
1837             log.warning(
1838                 "Only execution modules are currently supported in slots. This means"
1839                 ' slot should start with "__slot__:salt:"'
1840             )
1841             return slot
1842         fun, args, kwargs = salt.utils.args.parse_function(fmt[2])
1843         if not fun or fun not in self.functions:
1844             log.warning("Malformed slot: %s", slot)
1845             log.warning(
1846                 "Execution module should be specified in a function call format: "
1847                 "test.arg('arg', kw='kwarg')"
1848             )
1849             return slot
1850         log.debug("Calling slot: %s(%s, %s)", fun, args, kwargs)
1851         slot_return = self.functions[fun](*args, **kwargs)
1852         slot_text = fmt[2].split("~")[0]
1853         append_data = fmt[2].split("~", 1)[1:]
1854         log.debug("slot_text: %s", slot_text)
1855         log.debug("append_data: %s", append_data)
1856         return_get = None
1857         try:
1858             return_get = slot_text[slot_text.rindex(")") + 1 :]
1859         except ValueError:
1860             pass
1861         if return_get:
1862             return_get = return_get.split(".", 1)[1].strip()
1863             log.debug("Searching slot result %s for %s", slot_return, return_get)
1864             slot_return = salt.utils.data.traverse_dict_and_list(
1865                 slot_return, return_get, default=None, delimiter="."
1866             )
1867         if append_data:
1868             if isinstance(slot_return, str):
1869                 append_data = " ".join(append_data).strip()
1870                 log.debug("appending to slot result: %s", append_data)
1871                 slot_return += append_data
1872             else:
1873                 log.error("Ignoring slot append, slot result is not a string")
1874         return slot_return
1875     def format_slots(self, cdata):
1876         SLOT_TEXT = "__slot__:"
1877         ctx = (("args", enumerate(cdata["args"])), ("kwargs", cdata["kwargs"].items()))
1878         for atype, avalues in ctx:
1879             for ind, arg in avalues:
1880                 arg = salt.utils.data.decode(arg, keep=True)
1881                 if isinstance(arg, dict):
1882                     for key, value in arg.items():
1883                         try:
1884                             if value.startswith(SLOT_TEXT):
1885                                 log.trace("Slot processsing dict value %s", value)
1886                                 cdata[atype][ind][key] = self.__eval_slot(value)
1887                         except AttributeError:
1888                             continue
1889                 elif isinstance(arg, list):
1890                     for idx, listvalue in enumerate(arg):
1891                         log.trace("Slot processing list value: %s", listvalue)
1892                         if isinstance(listvalue, dict):
1893                             for key, value in listvalue.items():
1894                                 try:
1895                                     if value.startswith(SLOT_TEXT):
1896                                         log.trace(
1897                                             "Slot processsing nested dict value %s",
1898                                             value,
1899                                         )
1900                                         cdata[atype][ind][idx][key] = self.__eval_slot(
1901                                             value
1902                                         )
1903                                 except AttributeError:
1904                                     continue
1905                         if isinstance(listvalue, str):
1906                             if listvalue.startswith(SLOT_TEXT):
1907                                 log.trace(
1908                                     "Slot processsing nested string %s", listvalue
1909                                 )
1910                                 cdata[atype][ind][idx] = self.__eval_slot(listvalue)
1911                 elif isinstance(arg, str) and arg.startswith(SLOT_TEXT):
1912                     log.trace("Slot processsing %s", arg)
1913                     cdata[atype][ind] = self.__eval_slot(arg)
1914                 else:
1915                     continue
1916     def verify_retry_data(self, retry_data):
1917         retry_defaults = {
1918             "until": True,
1919             "attempts": 2,
1920             "splay": 0,
1921             "interval": 30,
1922         }
1923         expected_data = {
1924             "until": bool,
1925             "attempts": int,
1926             "interval": int,
1927             "splay": int,
1928         }
1929         validated_retry_data = {}
1930         if isinstance(retry_data, dict):
1931             for expected_key, value_type in expected_data.items():
1932                 if expected_key in retry_data:
1933                     if isinstance(retry_data[expected_key], value_type):
1934                         validated_retry_data[expected_key] = retry_data[expected_key]
1935                     else:
1936                         log.warning(
1937                             "An invalid value was passed for the retry %s, "
1938                             "using default value '%s'",
1939                             expected_key,
1940                             retry_defaults[expected_key],
1941                         )
1942                         validated_retry_data[expected_key] = retry_defaults[
1943                             expected_key
1944                         ]
1945                 else:
1946                     validated_retry_data[expected_key] = retry_defaults[expected_key]
1947         else:
1948             log.warning(
1949                 "State is set to retry, but a valid dict for retry "
1950                 "configuration was not found.  Using retry defaults"
1951             )
1952             validated_retry_data = retry_defaults
1953         return validated_retry_data
1954     def call_chunks(self, chunks):
1955         disabled = {}
1956         if "state_runs_disabled" in self.opts["grains"]:
1957             for low in chunks[:]:
1958                 state_ = "{}.{}".format(low["state"], low["fun"])
1959                 for pat in self.opts["grains"]["state_runs_disabled"]:
1960                     if fnmatch.fnmatch(state_, pat):
1961                         comment = (
1962                             'The state function "{0}" is currently disabled by "{1}", '
1963                             "to re-enable, run state.enable {1}.".format(
1964                                 state_,
1965                                 pat,
1966                             )
1967                         )
1968                         _tag = _gen_tag(low)
1969                         disabled[_tag] = {
1970                             "changes": {},
1971                             "result": False,
1972                             "comment": comment,
1973                             "__run_num__": self.__run_num,
1974                             "__sls__": low["__sls__"],
1975                         }
1976                         self.__run_num += 1
1977                         chunks.remove(low)
1978                         break
1979         running = {}
1980         for low in chunks:
1981             if "__FAILHARD__" in running:
1982                 running.pop("__FAILHARD__")
1983                 return running
1984             tag = _gen_tag(low)
1985             if tag not in running:
1986                 action = self.check_pause(low)
1987                 if action == "kill":
1988                     break
1989                 running = self.call_chunk(low, running, chunks)
1990                 if self.check_failhard(low, running):
1991                     return running
1992             self.active = set()
1993         while True:
1994             if self.reconcile_procs(running):
1995                 break
1996             time.sleep(0.01)
1997         ret = dict(list(disabled.items()) + list(running.items()))
1998         return ret
1999     def check_failhard(self, low, running):
2000         tag = _gen_tag(low)
2001         if self.opts.get("test", False):
2002             return False
2003         if low.get("failhard", self.opts["failhard"]) and tag in running:
2004             if running[tag]["result"] is None:
2005                 return False
2006             return not running[tag]["result"]
2007         return False
2008     def check_pause(self, low):
2009         if not self.jid:
2010             return
2011         pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2012         start = time.time()
2013         if os.path.isfile(pause_path):
2014             try:
2015                 while True:
2016                     tries = 0
2017                     with salt.utils.files.fopen(pause_path, "rb") as fp_:
2018                         try:
2019                             pdat = msgpack_deserialize(fp_.read())
2020                         except salt.utils.msgpack.exceptions.UnpackValueError:
2021                             if tries &gt; 10:
2022                                 return
2023                             tries += 1
2024                             time.sleep(1)
2025                             continue
2026                         id_ = low["__id__"]
2027                         key = ""
2028                         if id_ in pdat:
2029                             key = id_
2030                         elif "__all__" in pdat:
2031                             key = "__all__"
2032                         if key:
2033                             if "duration" in pdat[key]:
2034                                 now = time.time()
2035                                 if now - start &gt; pdat[key]["duration"]:
2036                                     return "run"
2037                             if "kill" in pdat[key]:
2038                                 return "kill"
2039                         else:
2040                             return "run"
2041                         time.sleep(1)
2042             except Exception as exc:  # pylint: disable=broad-except
2043                 log.error(
2044                     "Failed to read in pause data for file located at: %s", pause_path
2045                 )
2046                 return "run"
2047         return "run"
2048     def reconcile_procs(self, running):
2049         retset = set()
2050         for tag in running:
2051             proc = running[tag].get("proc")
2052             if proc:
2053                 if not proc.is_alive():
2054                     ret_cache = os.path.join(
2055                         self.opts["cachedir"],
2056                         self.jid,
2057                         salt.utils.hashutils.sha1_digest(tag),
2058                     )
2059                     if not os.path.isfile(ret_cache):
2060                         ret = {
2061                             "result": False,
2062                             "comment": "Parallel process failed to return",
2063                             "name": running[tag]["name"],
2064                             "changes": {},
2065                         }
2066                     try:
2067                         with salt.utils.files.fopen(ret_cache, "rb") as fp_:
2068                             ret = msgpack_deserialize(fp_.read())
2069                     except OSError:
2070                         ret = {
2071                             "result": False,
2072                             "comment": "Parallel cache failure",
2073                             "name": running[tag]["name"],
2074                             "changes": {},
2075                         }
2076                     running[tag].update(ret)
2077                     running[tag].pop("proc")
2078                 else:
2079                     retset.add(False)
2080         return False not in retset
2081     def check_requisite(self, low, running, chunks, pre=False):
2082         disabled_reqs = self.opts.get("disabled_requisites", [])
2083         if not isinstance(disabled_reqs, list):
2084             disabled_reqs = [disabled_reqs]
2085         present = False
2086         if "watch" in low:
2087             if "{}.mod_watch".format(low["state"]) not in self.states:
2088                 if "require" in low:
2089                     low["require"].extend(low.pop("watch"))
2090                 else:
2091                     low["require"] = low.pop("watch")
2092             else:
2093                 present = True
2094         if "watch_any" in low:
2095             if "{}.mod_watch".format(low["state"]) not in self.states:
2096                 if "require_any" in low:
2097                     low["require_any"].extend(low.pop("watch_any"))
2098                 else:
2099                     low["require_any"] = low.pop("watch_any")
2100             else:
2101                 present = True
2102         if "require" in low:
2103             present = True
2104         if "require_any" in low:
2105             present = True
2106         if "prerequired" in low:
2107             present = True
2108         if "prereq" in low:
2109             present = True
2110         if "onfail" in low:
2111             present = True
2112         if "onfail_any" in low:
2113             present = True
2114         if "onfail_all" in low:
2115             present = True
2116         if "onchanges" in low:
2117             present = True
2118         if "onchanges_any" in low:
2119             present = True
2120         if not present:
2121             return "met", ()
2122         self.reconcile_procs(running)
2123         reqs = {
2124             "require": [],
2125             "require_any": [],
2126             "watch": [],
2127             "watch_any": [],
2128             "prereq": [],
2129             "onfail": [],
2130             "onfail_any": [],
2131             "onfail_all": [],
2132             "onchanges": [],
2133             "onchanges_any": [],
2134         }
2135         if pre:
2136             reqs["prerequired"] = []
2137         for r_state in reqs:
2138             if r_state in low and low[r_state] is not None:
2139                 if r_state in disabled_reqs:
2140                     log.warning(
2141                         "The %s requisite has been disabled, Ignoring.", r_state
2142                     )
2143                     continue
2144                 for req in low[r_state]:
2145                     if isinstance(req, str):
2146                         req = {"id": req}
2147                     req = trim_req(req)
2148                     found = False
2149                     for chunk in chunks:
2150                         req_key = next(iter(req))
2151                         req_val = req[req_key]
2152                         if req_val is None:
2153                             continue
2154                         if req_key == "sls":
2155                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2156                                 found = True
2157                                 reqs[r_state].append(chunk)
2158                             continue
2159                         try:
2160                             if isinstance(req_val, str):
2161                                 if fnmatch.fnmatch(
2162                                     chunk["name"], req_val
2163                                 ) or fnmatch.fnmatch(chunk["__id__"], req_val):
2164                                     if req_key == "id" or chunk["state"] == req_key:
2165                                         found = True
2166                                         reqs[r_state].append(chunk)
2167                             else:
2168                                 raise KeyError
2169                         except KeyError as exc:
2170                             raise SaltRenderError(
2171                                 "Could not locate requisite of [{}] present in state"
2172                                 " with name [{}]".format(req_key, chunk["name"])
2173                             )
2174                         except TypeError:
2175                             raise SaltRenderError(
2176                                 "Could not locate requisite of [{}] present in state"
2177                                 " with name [{}]".format(req_key, chunk["name"])
2178                             )
2179                     if not found:
2180                         return "unmet", ()
2181         fun_stats = set()
2182         for r_state, chunks in reqs.items():
2183             req_stats = set()
2184             if r_state.startswith("prereq") and not r_state.startswith("prerequired"):
2185                 run_dict = self.pre
2186             else:
2187                 run_dict = running
2188             filtered_run_dict = {}
2189             for chunk in chunks:
2190                 tag = _gen_tag(chunk)
2191                 run_dict_chunk = run_dict.get(tag)
2192                 if run_dict_chunk:
2193                     filtered_run_dict[tag] = run_dict_chunk
2194             run_dict = filtered_run_dict
2195             while True:
2196                 if self.reconcile_procs(run_dict):
2197                     break
2198                 time.sleep(0.01)
2199             for chunk in chunks:
2200                 tag = _gen_tag(chunk)
2201                 if tag not in run_dict:
2202                     req_stats.add("unmet")
2203                     continue
2204                 if r_state.startswith("onfail"):
2205                     if run_dict[tag]["result"] is True:
2206                         req_stats.add("onfail")  # At least one state is OK
2207                         continue
2208                 else:
2209                     if run_dict[tag]["result"] is False:
2210                         req_stats.add("fail")
2211                         continue
2212                 if r_state.startswith("onchanges"):
2213                     if not run_dict[tag]["changes"]:
2214                         req_stats.add("onchanges")
2215                     else:
2216                         req_stats.add("onchangesmet")
2217                     continue
2218                 if r_state.startswith("watch") and run_dict[tag]["changes"]:
2219                     req_stats.add("change")
2220                     continue
2221                 if r_state.startswith("prereq") and run_dict[tag]["result"] is None:
2222                     if not r_state.startswith("prerequired"):
2223                         req_stats.add("premet")
2224                 if r_state.startswith("prereq") and not run_dict[tag]["result"] is None:
2225                     if not r_state.startswith("prerequired"):
2226                         req_stats.add("pre")
2227                 else:
2228                     if run_dict[tag].get("__state_ran__", True):
2229                         req_stats.add("met")
2230             if r_state.endswith("_any") or r_state == "onfail":
2231                 if "met" in req_stats or "change" in req_stats:
2232                     if "fail" in req_stats:
2233                         req_stats.remove("fail")
2234                 if "onchangesmet" in req_stats:
2235                     if "onchanges" in req_stats:
2236                         req_stats.remove("onchanges")
2237                     if "fail" in req_stats:
2238                         req_stats.remove("fail")
2239                 if "onfail" in req_stats:
2240                     if "met" in req_stats:
2241                         req_stats.remove("onfail")
2242             if r_state.endswith("_all"):
2243                 if "onfail" in req_stats:
2244                     if "met" in req_stats:
2245                         req_stats.remove("met")
2246             fun_stats.update(req_stats)
2247         if "unmet" in fun_stats:
2248             status = "unmet"
2249         elif "fail" in fun_stats:
2250             status = "fail"
2251         elif "pre" in fun_stats:
2252             if "premet" in fun_stats:
2253                 status = "met"
2254             else:
2255                 status = "pre"
2256         elif "onfail" in fun_stats and "onchangesmet" not in fun_stats:
2257             status = "onfail"
2258         elif "onchanges" in fun_stats and "onchangesmet" not in fun_stats:
2259             status = "onchanges"
2260         elif "change" in fun_stats:
2261             status = "change"
2262         elif "onfail" in fun_stats:
2263             status = "onfail"
2264         else:
2265             status = "met"
2266         return status, reqs
2267     def event(self, chunk_ret, length, fire_event=False):
2268         if not self.opts.get("local") and (
2269             self.opts.get("state_events", True) or fire_event
2270         ):
2271             if not self.opts.get("master_uri"):
2272                 ev_func = (
2273                     lambda ret, tag, preload=None: salt.utils.event.get_master_event(
2274                         self.opts, self.opts["sock_dir"], listen=False
2275                     ).fire_event(ret, tag)
2276                 )
2277             else:
2278                 ev_func = self.functions["event.fire_master"]
2279             ret = {"ret": chunk_ret}
2280             if fire_event is True:
2281                 tag = salt.utils.event.tagify(
2282                     [self.jid, self.opts["id"], str(chunk_ret["name"])],
2283                     "state_result",
2284                 )
2285             elif isinstance(fire_event, str):
2286                 tag = salt.utils.event.tagify(
2287                     [self.jid, self.opts["id"], str(fire_event)],
2288                 )
2289             else:
2290                 tag = salt<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.event.tagify(
2291                     [self.jid, "prog", self.opts["id"], str(chunk_ret["__run_num__"])],
2292                     "job",
2293                 )
2294                 ret["len"] =</b></font> length
2295             preload = {"jid": self.jid}
2296             ev_func(ret, tag, preload=preload)
2297     def call_chunk(self, low, running, chunks):
2298         low = self._mod_aggregate(low, running, chunks)
2299         self._mod_init(low)
2300         tag = _gen_tag(low)
2301         if not low.get("prerequired"):
2302             self.active.add(tag)
2303         requisites = [
2304             "require",
2305             "require_any",
2306             "watch",
2307             "watch_any",
2308             "prereq",
2309             "onfail",
2310             "onfail_any",
2311             "onchanges",
2312             "onchanges_any",
2313         ]
2314         if not low.get("__prereq__"):
2315             requisites.append("prerequired")
2316             status, reqs = self.check_requisite(low, running, chunks, pre=True)
2317         else:
2318             status, reqs = self.check_requisite(low, running, chunks)
2319         if status == "unmet":
2320             lost = {}
2321             reqs = []
2322             for requisite in requisites:
2323                 lost[requisite] = []
2324                 if requisite not in low:
2325                     continue
2326                 for req in low[requisite]:
2327                     if isinstance(req, str):
2328                         req = {"id": req}
2329                     req = trim_req(req)
2330                     found = False
2331                     req_key = next(iter(req))
2332                     req_val = req[req_key]
2333                     for chunk in chunks:
2334                         if req_val is None:
2335                             continue
2336                         if req_key == "sls":
2337                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2338                                 if requisite == "prereq":
2339                                     chunk["__prereq__"] = True
2340                                 reqs.append(chunk)
2341                                 found = True
2342                             continue
2343                         if fnmatch.fnmatch(chunk["name"], req_val) or fnmatch.fnmatch(
2344                             chunk["__id__"], req_val
2345                         ):
2346                             if req_key == "id" or chunk["state"] == req_key:
2347                                 if requisite == "prereq":
2348                                     chunk["__prereq__"] = True
2349                                 elif requisite == "prerequired":
2350                                     chunk["__prerequired__"] = True
2351                                 reqs.append(chunk)
2352                                 found = True
2353                     if not found:
2354                         lost[requisite].append(req)
2355             if (
2356                 lost["require"]
2357                 or lost["watch"]
2358                 or lost["prereq"]
2359                 or lost["onfail"]
2360                 or lost["onchanges"]
2361                 or lost["require_any"]
2362                 or lost["watch_any"]
2363                 or lost["onfail_any"]
2364                 or lost["onchanges_any"]
2365                 or lost.get("prerequired")
2366             ):
2367                 comment = "The following requisites were not found:\n"
2368                 for requisite, lreqs in lost.items():
2369                     if not lreqs:
2370                         continue
2371                     comment += "{}{}:\n".format(" " * 19, requisite)
2372                     for lreq in lreqs:
2373                         req_key = next(iter(lreq))
2374                         req_val = lreq[req_key]
2375                         comment += "{}{}: {}\n".format(" " * 23, req_key, req_val)
2376                 if low.get("__prereq__"):
2377                     run_dict = self.pre
2378                 else:
2379                     run_dict = running
2380                 start_time, duration = _calculate_fake_duration()
2381                 run_dict[tag] = {
2382                     "changes": {},
2383                     "result": False,
2384                     "duration": duration,
2385                     "start_time": start_time,
2386                     "comment": comment,
2387                     "__run_num__": self.__run_num,
2388                     "__sls__": low["__sls__"],
2389                 }
2390                 self.__run_num += 1
2391                 self.event(run_dict[tag], len(chunks), fire_event=low.get("fire_event"))
2392                 return running
2393             for chunk in reqs:
2394                 ctag = _gen_tag(chunk)
2395                 if ctag not in running:
2396                     if ctag in self.active:
2397                         if chunk.get("__prerequired__"):
2398                             if tag not in self.pre:
2399                                 low["__prereq__"] = True
2400                                 self.pre[ctag] = self.call(low, chunks, running)
2401                                 return running
2402                             else:
2403                                 return running
2404                         elif ctag not in running:
2405                             log.error("Recursive requisite found")
2406                             running[tag] = {
2407                                 "changes": {},
2408                                 "result": False,
2409                                 "comment": "Recursive requisite found",
2410                                 "__run_num__": self.__run_num,
2411                                 "__sls__": low["__sls__"],
2412                             }
2413                         self.__run_num += 1
2414                         self.event(
2415                             running[tag], len(chunks), fire_event=low.get("fire_event")
2416                         )
2417                         return running
2418                     running = self.call_chunk(chunk, running, chunks)
2419                     if self.check_failhard(chunk, running):
2420                         running["__FAILHARD__"] = True
2421                         return running
2422             if low.get("__prereq__"):
2423                 status, reqs = self.check_requisite(low, running, chunks)
2424                 self.pre[tag] = self.call(low, chunks, running)
2425                 if not self.pre[tag]["changes"] and status == "change":
2426                     self.pre[tag]["changes"] = {"watch": "watch"}
2427                     self.pre[tag]["result"] = None
2428             else:
2429                 running = self.call_chunk(low, running, chunks)
2430             if self.check_failhard(chunk, running):
2431                 running["__FAILHARD__"] = True
2432                 return running
2433         elif status == "met":
2434             if low.get("__prereq__"):
2435                 self.pre[tag] = self.call(low, chunks, running)
2436             else:
2437                 running[tag] = self.call(low, chunks, running)
2438         elif status == "fail":
2439             if tag in self.pre:
2440                 running<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[tag] = self.pre[tag]
2441                 running[tag]["__run_num__"] = self.__run_num
2442                 running[tag]["__sls__"] = low[</b></font>"__sls__"]
2443             else:
2444                 failed_requisites = set()
2445                 for req_lows in reqs.values():
2446                     for req_low in req_lows:
2447                         req_tag = _gen_tag(req_low)
2448                         req_ret = self.pre.get(req_tag, running.get(req_tag))
2449                         if req_ret is None:
2450                             continue
2451                         if req_ret["result"] is False:
2452                             key = "{sls}.{_id}".format(
2453                                 sls=req_low["__sls__"], _id=req_low["__id__"]
2454                             )
2455                             failed_requisites.add(key)
2456                 _cmt = "One or more requisite failed: {}".format(
2457                     ", ".join(str(i) for i in failed_requisites)
2458                 )
2459                 start_time, duration = _calculate_fake_duration()
2460                 running[tag] = {
2461                     "changes": {},
2462                     "result": False,
2463                     "duration": duration,
2464                     "start_time": start_time,
2465                     "comment": _cmt,
2466                     "__run_num__": self.__run_num,
2467                     "__sls__": low["__sls__"],
2468                 }
2469                 self.pre[tag] = running[tag]
2470             self.__run_num += 1
2471         elif status == "change" and not low.get("__prereq__"):
2472             ret = self.call(low, chunks, running)
2473             if not ret["changes"] and not ret.get("skip_watch", False):
2474                 low = low.copy()
2475                 low["sfun"] = low["fun"]
2476                 low["fun"] = "mod_watch"
2477                 low["__reqs__"] = reqs
2478                 ret = self.call(low, chunks, running)
2479             running[tag] = ret
2480         elif status == "pre":
2481             start_time, duration = _calculate_fake_duration()
2482             pre_ret = {
2483                 "changes": {},
2484                 "result": True,
2485                 "duration": duration,
2486                 "start_time": start_time,
2487                 "comment": "No changes detected",
2488                 "__run_num__": self.__run_num,
2489                 "__sls__": low["__sls__"],
2490             }
2491             running[tag] = pre_ret
2492             self.pre[tag] = pre_ret
2493             self.__run_num += 1
2494         elif status == "onfail":
2495             start_time, duration = _calculate_fake_duration()
2496             running[tag] = {
2497                 "changes": {},
2498                 "result": True,
2499                 "duration": duration,
2500                 "start_time": start_time,
2501                 "comment": "State was not run because onfail req did not change",
2502                 "__state_ran__": False,
2503                 "__run_num__": self.__run_num,
2504                 "__sls__": low["__sls__"],
2505             }
2506             self.__run_num += 1
2507         elif status == "onchanges":
2508             start_time, duration = _calculate_fake_duration()
2509             running[tag] = {
2510                 "changes": {},
2511                 "result": True,
2512                 "duration": duration,
2513                 "start_time": start_time,
2514                 "comment": (
2515                     "State was not run because none of the onchanges reqs changed"
2516                 ),
2517                 "__state_ran__": False,
2518                 "__run_num__": self.__run_num,
2519                 "__sls__": low["__sls__"],
2520             }
2521             self.__run_num += 1
2522         else:
2523             if low.get("__prereq__"):
2524                 self.pre[tag] = self.call(low, chunks, running)
2525             else:
2526                 running[tag] = self.call(low, chunks, running)
2527         if tag in running:
2528             self.event(running[tag], len(chunks), fire_event=low.get("fire_event"))
2529             for sub_state_data in running[tag].pop("sub_state_run", ()):
2530                 start_time, duration = _calculate_fake_duration()
2531                 self.__run_num += 1
2532                 sub_tag = _gen_tag(sub_state_data["low"])
2533                 running[sub_tag] = {
2534                     "name": sub_state_data["low"]["name"],
2535                     "changes": sub_state_data["changes"],
2536                     "result": sub_state_data["result"],
2537                     "duration": sub_state_data.get("duration", duration),
2538                     "start_time": sub_state_data.get("start_time", start_time),
2539                     "comment": sub_state_data.get("comment", ""),
2540                     "__state_ran__": True,
2541                     "__run_num__": self.__run_num,
2542                     "__sls__": low["__sls__"],
2543                 }
2544         return running
2545     def call_beacons(self, chunks, running):
2546         listeners = []
2547         crefs = {}
2548         beacons = []
2549         for chunk in chunks:
2550             if "beacon" in chunk:
2551                 beacons.append(chunk)
2552         mod_beacons = []
2553         errors = {}
2554         for chunk in beacons:
2555             low = chunk.copy()
2556             low["sfun"] = chunk["fun"]
2557             low["fun"] = "mod_beacon"
2558             low["__id__"] = "beacon_{}".format(low["__id__"])
2559             mod_beacons.append(low)
2560         ret = self.call_chunks(mod_beacons)
2561         running.update(ret)
2562         for err in errors:
2563             errors[err]["__run_num__"] = self.__run_num
2564             self.__run_num += 1
2565         running.update(errors)
2566         return running
2567     def call_listen(self, chunks, running):
2568         listeners = []
2569         crefs = {}
2570         for chunk in chunks:
2571             crefs[(chunk["state"], chunk["__id__"], chunk["name"])] = chunk
2572             if "listen" in chunk:
2573                 listeners.append(
2574                     {(chunk["state"], chunk["__id__"], chunk["name"]): chunk["listen"]}
2575                 )
2576             if "listen_in" in chunk:
2577                 for l_in in chunk["listen_in"]:
2578                     for key, val in l_in.items():
2579                         listeners.append(
2580                             {(key, val, "lookup"): [{chunk["state"]: chunk["__id__"]}]}
2581                         )
2582         mod_watchers = []
2583         errors = {}
2584         for l_dict in listeners:
2585             for key, val in l_dict.items():
2586                 for listen_to in val:
2587                     if not isinstance(listen_to, dict):
2588                         found = False
2589                         for chunk in chunks:
2590                             if (
2591                                 chunk["__id__"] == listen_to
2592                                 or chunk["name"] == listen_to
2593                             ):
2594                                 listen_to = {chunk["state"]: chunk["__id__"]}
2595                                 found = True
2596                         if not found:
2597                             continue
2598                     for lkey, lval in listen_to.items():
2599                         if not any(lkey == cref[0] and lval in cref for cref in crefs):
2600                             rerror = {
2601                                 _l_tag(lkey, lval): {
2602                                     "comment": (
2603                                         "Referenced state {}: {} does not exist".format(
2604                                             lkey, lval
2605                                         )
2606                                     ),
2607                                     "name": "listen_{}:{}".format(lkey, lval),
2608                                     "result": False,
2609                                     "changes": {},
2610                                 }
2611                             }
2612                             errors.update(rerror)
2613                             continue
2614                         to_tags = [
2615                             _gen_tag(data)
2616                             for cref, data in crefs.items()
2617                             if lkey == cref[0] and lval in cref
2618                         ]
2619                         for to_tag in to_tags:
2620                             if to_tag not in running:
2621                                 continue
2622                             if running[to_tag]["changes"]:
2623                                 if not any(
2624                                     key[0] == cref[0] and key[1] in cref
2625                                     for cref in crefs
2626                                 ):
2627                                     rerror = {
2628                                         _l_tag(key[0], key[1]): {
2629                                             "comment": (
2630                                                 "Referenced state {}: {} does not exist".format(
2631                                                     key[0], key[1]
2632                                                 )
2633                                             ),
2634                                             "name": "listen_{}:{}".format(
2635                                                 key[0], key[1]
2636                                             ),
2637                                             "result": False,
2638                                             "changes": {},
2639                                         }
2640                                     }
2641                                     errors.update(rerror)
2642                                     continue
2643                                 new_chunks = [
2644                                     data
2645                                     for cref, data in crefs.items()
2646                                     if key[0] == cref[0] and key[1] in cref
2647                                 ]
2648                                 for chunk in new_chunks:
2649                                     low = chunk.copy()
2650                                     low["sfun"] = chunk["fun"]
2651                                     low["fun"] = "mod_watch"
2652                                     low["__id__"] = "listener_{}".format(low["__id__"])
2653                                     for req in STATE_REQUISITE_KEYWORDS:
2654                                         if req in low:
2655                                             low.pop(req)
2656                                     mod_watchers.append(low)
2657         ret = self.call_chunks(mod_watchers)
2658         running.update(ret)
2659         for err in errors:
2660             errors[err]["__run_num__"] = self.__run_num
2661             self.__run_num += 1
2662         running.update(errors)
2663         return running
2664     def call_high(self, high, orchestration_jid=None):
2665         errors = []
2666         high, ext_errors = self.reconcile_extend(high)
2667         errors.extend(ext_errors)
2668         errors.extend(self.verify_high(high))
2669         if errors:
2670             return errors
2671         high, req_in_errors = self.requisite_in(high)
2672         errors.extend(req_in_errors)
2673         high = self.apply_exclude(high)
2674         if errors:
2675             return errors
2676         chunks = self.compile_high_data(high, orchestration_jid)
2677         if errors:
2678             return errors
2679         ret = self.call_chunks(chunks)
2680         ret = self.call_listen(chunks, ret)
2681         ret = self.call_beacons(chunks, ret)
2682         def _cleanup_accumulator_data():
2683             accum_data_path = os.path.join(
2684                 get_accumulator_dir(self.opts["cachedir"]), self.instance_id
2685             )
2686             try:
2687                 os.remove(accum_data_path)
2688                 log.debug("Deleted accumulator data file %s", accum_data_path)
2689             except OSError:
2690                 log.debug("File %s does not exist, no need to cleanup", accum_data_path)
2691         _cleanup_accumulator_data()
2692         if self.jid is not None:
2693             pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2694             if os.path.isfile(pause_path):
2695                 try:
2696                     os.remove(pause_path)
2697                 except OSError:
2698                     pass
2699         return ret
2700     def render_template(self, high, template):
2701         errors = []
2702         if not high:
2703             return high, errors
2704         if not isinstance(high, dict):
2705             errors.append(
2706                 "Template {} does not render to a dictionary".format(template)
2707             )
2708             return high, errors
2709         invalid_items = ("include", "exclude", "extends")
2710         for item in invalid_items:
2711             if item in high:
2712                 errors.append(
2713                     "The '{}' declaration found on '{}' is invalid when "
2714                     "rendering single templates".format(item, template)
2715                 )
2716                 return high, errors
2717         for name in high:
2718             if not isinstance(high[name], dict):
2719                 if isinstance(high[name], str):
2720                     if "." in high[name]:
2721                         comps = high[name].split(".")
2722                         high[name] = {
2723                             comps[0]: [comps[1]]
2724                         }
2725                         continue
2726                     errors.append(
2727                         "ID {} in template {} is not a dictionary".format(
2728                             name, template
2729                         )
2730                     )
2731                     continue
2732             skeys = set()
2733             for key in sorted(high[name]):
2734                 if key.startswith("_"):
2735                     continue
2736                 if high[name][key] is None:
2737                     errors.append(
2738                         "ID '{}' in template {} contains a short "
2739                         "declaration ({}) with a trailing colon. When not "
2740                         "passing any arguments to a state, the colon must be "
2741                         "omitted.".format(name, template, key)
2742                     )
2743                     continue
2744                 if not isinstance(high[name][key], list):
2745                     continue
2746                 if "." in key:
2747                     comps = key.split(".")
2748                     if comps[0] in skeys:
2749                         errors.append(
2750                             "ID '{}' in template '{}' contains multiple "
2751                             "state declarations of the same type".format(name, template)
2752                         )
2753                         continue
2754                     high[name][comps[0]] = high[name].pop(key)
2755                     high[name][comps[0]].append(comps[1])
2756                     skeys.add(comps[0])
2757                     continue
2758                 skeys.add(key)
2759         return high, errors
2760     def call_template(self, template):
2761         high = compile_template(
2762             template,
2763             self.rend,
2764             self.opts["renderer"],
2765             self.opts["renderer_blacklist"],
2766             self.opts["renderer_whitelist"],
2767         )
2768         if not high:
2769             return high
2770         high, errors = self.render_template(high, template)
2771         if errors:
2772             return errors
2773         return self.call_high(high)
2774     def call_template_str(self, template):
2775         high = compile_template_str(
2776             template,
2777             self.rend,
2778             self.opts["renderer"],
2779             self.opts["renderer_blacklist"],
2780             self.opts["renderer_whitelist"],
2781         )
2782         if not high:
2783             return high
2784         high, errors = self.render_template(high, "&lt;template-str&gt;")
2785         if errors:
2786             return errors
2787         return self.call_high(high)
2788 class LazyAvailStates:
2789     def __init__(self, hs):
2790         self._hs = hs
2791         self._avail = {"base": None}
2792         self._filled = False
2793     def _fill(self):
2794         if self._filled:
2795             return
2796         for saltenv in self._hs._get_envs():
2797             if saltenv not in self._avail:
2798                 self._avail[saltenv] = None
2799         self._filled = True
2800     def __contains__(self, saltenv):
2801         if saltenv == "base":
2802             return True
2803         self._fill()
2804         return saltenv in self._avail
2805     def __getitem__(self, saltenv):
2806         if saltenv != "base":
2807             self._fill()
2808         if saltenv not in self._avail or self._avail[saltenv] is None:
2809             self._avail[saltenv] = self._hs.client.list_states(saltenv)
2810         return self._avail[saltenv]
2811     def items(self):
2812         self._fill()
2813         ret = []
2814         for saltenv, states in self._avail.items():
2815             ret.append((saltenv, self.__getitem__(saltenv)))
2816         return ret
2817 class BaseHighState:
2818     def __init__(self, opts):
2819         self.opts = self.__gen_opts(opts)
2820         self.iorder = 10000
2821         self.avail = self.__gather_avail()
2822         self.building_highstate = OrderedDict()
2823     def __gather_avail(self):
2824         return LazyAvailStates(self)
2825     def __gen_opts(self, opts):
2826         if "local_state" in opts:
2827             if opts["local_state"]:
2828                 return opts
2829         mopts = self.client.master_opts()
2830         if not isinstance(mopts, dict):
2831             opts["renderer"] = "jinja|yaml"
2832             opts["failhard"] = False
2833             opts["state_top"] = salt.utils.url.create("top.sls")
2834             opts["nodegroups"] = {}
2835             opts["file_roots"] = {"base": [syspaths.BASE_FILE_ROOTS_DIR]}
2836         else:
2837             opts["renderer"] = mopts["renderer"]
2838             opts["failhard"] = mopts.get("failhard", False)
2839             if mopts["state_top"].startswith("salt://"):
2840                 opts["state_top"] = mopts["state_top"]
2841             elif mopts["state_top"].startswith("/"):
2842                 opts["state_top"] = salt.utils.url.create(mopts["state_top"][1:])
2843             else:
2844                 opts["state_top"] = salt.utils.url.create(mopts["state_top"])
2845             opts["state_top_saltenv"] = mopts.get("state_top_saltenv", None)
2846             opts["nodegroups"] = mopts.get("nodegroups", {})
2847             opts["state_auto_order"] = mopts.get(
2848                 "state_auto_order", opts["state_auto_order"]
2849             )
2850             opts["file_roots"] = mopts["file_roots"]
2851             opts["top_file_merging_strategy"] = mopts.get(
2852                 "top_file_merging_strategy", opts.get("top_file_merging_strategy")
2853             )
2854             opts["env_order"] = mopts.get("env_order", opts.get("env_order", []))
2855             opts["default_top"] = mopts.get("default_top", opts.get("default_top"))
2856             opts["state_events"] = mopts.get("state_events")
2857             opts["state_aggregate"] = (
2858                 opts.get("state_aggregate") or mopts.get("state_aggregate") or False
2859             )
2860             opts["jinja_env"] = mopts.get("jinja_env", {})
2861             opts["jinja_sls_env"] = mopts.get("jinja_sls_env", {})
2862             opts["jinja_lstrip_blocks"] = mopts.get("jinja_lstrip_blocks", False)
2863             opts["jinja_trim_blocks"] = mopts.get("jinja_trim_blocks", False)
2864         return opts
2865     def _get_envs(self):
2866         envs = ["base"]
2867         if "file_roots" in self.opts:
2868             envs.extend([x for x in list(self.opts["file_roots"]) if x not in envs])
2869         env_order = self.opts.get("env_order", [])
2870         members = set()
2871         env_order = [
2872             env for env in env_order if not (env in members or members.add(env))
2873         ]
2874         client_envs = self.client.envs()
2875         if env_order and client_envs:
2876             return [env for env in env_order if env in client_envs]
2877         elif env_order:
2878             return env_order
2879         else:
2880             envs.extend([env for env in client_envs if env not in envs])
2881             return envs
2882     def get_tops(self):
2883         tops = DefaultOrderedDict(list)
2884         include = DefaultOrderedDict(list)
2885         done = DefaultOrderedDict(list)
2886         found = 0  # did we find any contents in the top files?
2887         merging_strategy = self.opts["top_file_merging_strategy"]
2888         if merging_strategy == "same" and not self.opts["saltenv"]:
2889             if not self.opts["default_top"]:
2890                 raise SaltRenderError(
2891                     "top_file_merging_strategy set to 'same', but no "
2892                     "default_top configuration option was set"
2893                 )
2894         if self.opts["saltenv"]:
2895             contents = self.client.cache_file(
2896                 self.opts["state_top"], self.opts["saltenv"]
2897             )
2898             if contents:
2899                 found = 1
2900                 tops[self.opts["saltenv"]] = [
2901                     compile_template(
2902                         contents,
2903                         self.state.rend,
2904                         self.state.opts["renderer"],
2905                         self.state.opts["renderer_blacklist"],
2906                         self.state.opts["renderer_whitelist"],
2907                         saltenv=self.opts["saltenv"],
2908                     )
2909                 ]
2910             else:
2911                 tops[self.opts["saltenv"]] = [{}]
2912         else:
2913             found = 0
2914             state_top_saltenv = self.opts.get("state_top_saltenv", False)
2915             if state_top_saltenv and not isinstance(state_top_saltenv, str):
2916                 state_top_saltenv = str(state_top_saltenv)
2917             for saltenv in (
2918                 [state_top_saltenv] if state_top_saltenv else self._get_envs()
2919             ):
2920                 contents = self.client.cache_file(self.opts["state_top"], saltenv)
2921                 if contents:
2922                     found = found + 1
2923                     tops[saltenv].append(
2924                         compile_template(
2925                             contents,
2926                             self.state.rend,
2927                             self.state.opts["renderer"],
2928                             self.state.opts["renderer_blacklist"],
2929                             self.state.opts["renderer_whitelist"],
2930                             saltenv=saltenv,
2931                         )
2932                     )
2933                 else:
2934                     tops[saltenv].append({})
2935                     log.debug("No contents loaded for saltenv '%s'", saltenv)
2936             if (
2937                 found &gt; 1
2938                 and merging_strategy == "merge"
2939                 and not self.opts.get("env_order", None)
2940             ):
2941                 log.warning(
2942                     "top_file_merging_strategy is set to '%s' and "
2943                     "multiple top files were found. Merging order is not "
2944                     "deterministic, it may be desirable to either set "
2945                     "top_file_merging_strategy to 'same' or use the "
2946                     "'env_order' configuration parameter to specify the "
2947                     "merging order.",
2948                     merging_strategy,
2949                 )
2950         if found == 0:
2951             log.debug(
2952                 "No contents found in top file. If this is not expected, "
2953                 "verify that the 'file_roots' specified in 'etc/master' "
2954                 "are accessible. The 'file_roots' configuration is: %s",
2955                 repr(self.state.opts["file_roots"]),
2956             )
2957         for saltenv, ctops in tops.items():
2958             for ctop in ctops:
2959                 if "include" not in ctop:
2960                     continue
2961                 for sls in ctop["include"]:
2962                     include[saltenv].append(sls)
2963                 ctop.pop("include")
2964         while include:
2965             pops = []
2966             for saltenv, states in include.items():
2967                 pops.append(saltenv)
2968                 if not states:
2969                     continue
2970                 for sls_match in states:
2971                     for sls in fnmatch.filter(self.avail[saltenv], sls_match):
2972                         if sls in done[saltenv]:
2973                             continue
2974                         tops[saltenv].append(
2975                             compile_template(
2976                                 self.client.get_state(sls, saltenv).get("dest", False),
2977                                 self.state.rend,
2978                                 self.state.opts["renderer"],
2979                                 self.state.opts["renderer_blacklist"],
2980                                 self.state.opts["renderer_whitelist"],
2981                                 saltenv,
2982                             )
2983                         )
2984                         done[saltenv].append(sls)
2985             for saltenv in pops:
2986                 if saltenv in include:
2987                     include.pop(saltenv)
2988         return tops
2989     def merge_tops(self, tops):
2990         merging_strategy = self.opts["top_file_merging_strategy"]
2991         try:
2992             merge_attr = "_merge_tops_{}".format(merging_strategy)
2993             merge_func = getattr(self, merge_attr)
2994             if not hasattr(merge_func, "__call__"):
2995                 msg = "'{}' is not callable".format(merge_attr)
2996                 log.error(msg)
2997                 raise TypeError(msg)
2998         except (AttributeError, TypeError):
2999             log.warning(
3000                 "Invalid top_file_merging_strategy '%s', falling back to 'merge'",
3001                 merging_strategy,
3002             )
3003             merge_func = self._merge_tops_merge
3004         return merge_func(tops)
3005     def _merge_tops_merge(self, tops):
3006         top = DefaultOrderedDict(OrderedDict)
3007         base_tops = tops.pop("base", DefaultOrderedDict(OrderedDict))
3008         for ctop in base_tops:
3009             for saltenv, targets in ctop.items():
3010                 if saltenv == "include":
3011                     continue
3012                 try:
3013                     for tgt in targets:
3014                         top[saltenv][tgt] = ctop[saltenv][tgt]
3015                 except TypeError:
3016                     raise SaltRenderError(
3017                         "Unable to render top file. No targets found."
3018                     )
3019         for cenv, ctops in tops.items():
3020             for ctop in ctops:
3021                 for saltenv, targets in ctop.items():
3022                     if saltenv == "include":
3023                         continue
3024                     elif saltenv != cenv:
3025                         log.debug(
3026                             "Section for saltenv '%s' in the '%s' "
3027                             "saltenv's top file will be ignored, as the "
3028                             "top_file_merging_strategy is set to 'merge' "
3029                             "and the saltenvs do not match",
3030                             saltenv,
3031                             cenv,
3032                         )
3033                         continue
3034                     elif saltenv in top:
3035                         log.debug(
3036                             "Section for saltenv '%s' in the '%s' "
3037                             "saltenv's top file will be ignored, as this "
3038                             "saltenv was already defined in the 'base' top "
3039                             "file",
3040                             saltenv,
3041                             cenv,
3042                         )
3043                         continue
3044                     try:
3045                         for tgt in targets:
3046                             top[saltenv][tgt] = ctop[saltenv][tgt]
3047                     except TypeError:
3048                         raise SaltRenderError(
3049                             "Unable to render top file. No targets found."
3050                         )
3051         return top
3052     def _merge_tops_same(self, tops):
3053         top = DefaultOrderedDict(OrderedDict)
3054         for cenv, ctops in tops.items():
3055             if all([x == {} for x in ctops]):
3056                 default_top = self.opts["default_top"]
3057                 fallback_tops = tops.get(default_top, [])
3058                 if all([x == {} for x in fallback_tops]):
3059                     log.error(
3060                         "The '%s' saltenv has no top file, and the fallback "
3061                         "saltenv specified by default_top (%s) also has no "
3062                         "top file",
3063                         cenv,
3064                         default_top,
3065                     )
3066                     continue
3067                 for ctop in fallback_tops:
3068                     for saltenv, targets in ctop.items():
3069                         if saltenv != cenv:
3070                             continue
3071                         log.debug(
3072                             "The '%s' saltenv has no top file, using the "
3073                             "default_top saltenv (%s)",
3074                             cenv,
3075                             default_top,
3076                         )
3077                         for tgt in targets:
3078                             top[saltenv][tgt] = ctop[saltenv][tgt]
3079                         break
3080                     else:
3081                         log.error(
3082                             "The '%s' saltenv has no top file, and no "
3083                             "matches were found in the top file for the "
3084                             "default_top saltenv (%s)",
3085                             cenv,
3086                             default_top,
3087                         )
3088                 continue
3089             else:
3090                 for ctop in ctops:
3091                     for saltenv, targets in ctop.items():
3092                         if saltenv == "include":
3093                             continue
3094                         elif saltenv != cenv:
3095                             log.debug(
3096                                 "Section for saltenv '%s' in the '%s' "
3097                                 "saltenv's top file will be ignored, as the "
3098                                 "top_file_merging_strategy is set to 'same' "
3099                                 "and the saltenvs do not match",
3100                                 saltenv,
3101                                 cenv,
3102                             )
3103                             continue
3104                         try:
3105                             for tgt in targets:
3106                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3107                         except TypeError:
3108                             raise SaltRenderError(
3109                                 "Unable to render top file. No targets found."
3110                             )
3111         return top
3112     def _merge_tops_merge_all(self, tops):
3113         def _read_tgt(tgt):
3114             match_type = None
3115             states = []
3116             for item in tgt:
3117                 if isinstance(item, dict):
3118                     match_type = item
3119                 if isinstance(item, str):
3120                     states.append(item)
3121             return match_type, states
3122         top = DefaultOrderedDict(OrderedDict)
3123         for ctops in tops.values():
3124             for ctop in ctops:
3125                 for saltenv, targets in ctop.items():
3126                     if saltenv == "include":
3127                         continue
3128                     try:
3129                         for tgt in targets:
3130                             if tgt not in top[saltenv]:
3131                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3132                                 continue
3133                             m_type1, m_states1 = _read_tgt(top[saltenv][tgt])
3134                             m_type2, m_states2 = _read_tgt(ctop[saltenv][tgt])
3135                             merged = []
3136                             match_type = m_type2 or m_type1
3137                             if match_type is not None:
3138                                 merged.append(match_type)
3139                             merged.extend(m_states1)
3140                             merged.extend([x for x in m_states2 if x not in merged])
3141                             top[saltenv][tgt] = merged
3142                     except TypeError:
3143                         raise SaltRenderError(
3144                             "Unable to render top file. No targets found."
3145                         )
3146         return top
3147     def verify_tops(self, tops):
3148         errors = []
3149         if not isinstance(tops, dict):
3150             errors.append("Top data was not formed as a dict")
3151             return errors
3152         for saltenv, matches in tops.items():
3153             if saltenv == "include":
3154                 continue
3155             if not isinstance(saltenv, str):
3156                 errors.append(
3157                     "Environment {} in top file is not formed as a string".format(
3158                         saltenv
3159                     )
3160                 )
3161             if saltenv == "":
3162                 errors.append("Empty saltenv statement in top file")
3163             if not isinstance(matches, dict):
3164                 errors.append(
3165                     "The top file matches for saltenv {} are not "
3166                     "formatted as a dict".format(saltenv)
3167                 )
3168             for slsmods in matches.values():
3169                 if not isinstance(slsmods, list):
3170                     errors.append(
3171                         "Malformed topfile (state declarations not formed as a list)"
3172                     )
3173                     continue
3174                 for slsmod in slsmods:
3175                     if isinstance(slsmod, dict):
3176                         for val in slsmod.values():
3177                             if not val:
3178                                 errors.append(
3179                                     "Improperly formatted top file matcher "
3180                                     "in saltenv {}: {} file".format(slsmod, val)
3181                                 )
3182                     elif isinstance(slsmod, str):
3183                         if not slsmod:
3184                             errors.append(
3185                                 "Environment {} contains an empty sls index".format(
3186                                     saltenv
3187                                 )
3188                             )
3189         return errors
3190     def get_top(self):
3191         try:
3192             tops = self.get_tops()
3193         except SaltRenderError as err:
3194             log.error("Unable to render top file: %s", err.error)
3195             return {}
3196         return self.merge_tops(tops)
3197     def top_matches(self, top):
3198         matches = DefaultOrderedDict(OrderedDict)
3199         for saltenv, body in top.items():
3200             if self.opts["saltenv"]:
3201                 if saltenv != self.opts["saltenv"]:
3202                     continue
3203             for match, data in body.items():
3204                 def _filter_matches(_match, _data, _opts):
3205                     if isinstance(_data, str):
3206                         _data = [_data]
3207                     if self.matchers["confirm_top.confirm_top"](_match, _data, _opts):
3208                         if saltenv not in matches:
3209                             matches[saltenv] = []
3210                         for item in _data:
3211                             if "subfilter" in item:
3212                                 _tmpdata = item.pop("subfilter")
3213                                 for match, data in _tmpdata.items():
3214                                     _filter_matches(match, data, _opts)
3215                             if isinstance(item, str):
3216                                 matches[saltenv].append(item)
3217                             elif isinstance(item, dict):
3218                                 env_key, inc_sls = item.popitem()
3219                                 if env_key not in self.avail:
3220                                     continue
3221                                 if env_key not in matches:
3222                                     matches[env_key] = []
3223                                 matches[env_key].append(inc_sls)
3224                 _filter_matches(match, data, self.opts["nodegroups"])
3225         ext_matches = self._master_tops()
3226         for saltenv in ext_matches:
3227             top_file_matches = matches.get(saltenv, [])
3228             if self.opts.get("master_tops_first"):
3229                 first = ext_matches[saltenv]
3230                 second = top_file_matches
3231             else:
3232                 first = top_file_matches
3233                 second = ext_matches[saltenv]
3234             matches[saltenv] = first + [x for x in second if x not in first]
3235         return matches
3236     def _master_tops(self):
3237         return self.client.master_tops()
3238     def load_dynamic(self, matches):
3239         if not self.opts["autoload_dynamic_modules"]:
3240             return
3241         syncd = self.state.functions["saltutil.sync_all"](list(matches), refresh=False)
3242         if syncd["grains"]:
3243             self.opts["grains"] = salt.loader.grains(self.opts)
3244             self.state.opts["pillar"] = self.state._gather_pillar()
3245         self.state.module_refresh()
3246     def render_state(self, sls, saltenv, mods, matches, local=False, context=None):
3247         errors = []
3248         if not local:
3249             state_data = self.client.get_state(sls, saltenv)
3250             fn_ = state_data.get("dest", False)
3251         else:
3252             fn_ = sls
3253             if not os.path.isfile(fn_):
3254                 errors.append(
3255                     "Specified SLS {} on local filesystem cannot be found.".format(sls)
3256                 )
3257         state = None
3258         if not fn_:
3259             errors.append(
3260                 "Specified SLS {} in saltenv {} is not "
3261                 "available on the salt master or through a configured "
3262                 "fileserver".format(sls, saltenv)
3263             )
3264         else:
3265             try:
3266                 state = compile_template(
3267                     fn_,
3268                     self.state.rend,
3269                     self.state.opts["renderer"],
3270                     self.state.opts["renderer_blacklist"],
3271                     self.state.opts["renderer_whitelist"],
3272                     saltenv,
3273                     sls,
3274                     rendered_sls=mods,
3275                     context=context,
3276                 )
3277             except SaltRenderError as exc:
3278                 msg = "Rendering SLS '{}:{}' failed: {}".format(saltenv, sls, exc)
3279                 log.critical(msg)
3280                 errors.append(msg)
3281             except Exception as exc:  # pylint: disable=broad-except
3282                 msg = "Rendering SLS {} failed, render error: {}".format(sls, exc)
3283                 log.critical(
3284                     msg,
3285                     exc_info_on_loglevel=logging.DEBUG,
3286                 )
3287                 errors.append("{}\n{}".format(msg, traceback.format_exc()))
3288             try:
3289                 mods.add("{}:{}".format(saltenv, sls))
3290             except AttributeError:
3291                 pass
3292         if state:
3293             if not isinstance(state, dict):
3294                 errors.append("SLS {} does not render to a dictionary".format(sls))
3295             else:
3296                 include = []
3297                 if "include" in state:
3298                     if not isinstance(state["include"], list):
3299                         err = (
3300                             "Include Declaration in SLS {} is not formed "
3301                             "as a list".format(sls)
3302                         )
3303                         errors.append(err)
3304                     else:
3305                         include = state.pop("include")
3306                 self._handle_extend(state, sls, saltenv, errors)
3307                 self._handle_exclude(state, sls, saltenv, errors)
3308                 self._handle_state_decls(state, sls, saltenv, errors)
3309                 for inc_sls in include:
3310                     xenv_key = "_xenv"
3311                     if isinstance(inc_sls, dict):
3312                         env_key, inc_sls = inc_sls.popitem()
3313                     else:
3314                         env_key = saltenv
3315                     if env_key not in self.avail and "__env__" not in self.avail:
3316                         msg = (
3317                             "Nonexistent saltenv '{}' found in include "
3318                             "of '{}' within SLS '{}:{}'".format(
3319                                 env_key, inc_sls, saltenv, sls
3320                             )
3321                         )
3322                         log.error(msg)
3323                         errors.append(msg)
3324                         continue
3325                     if inc_sls.startswith("."):
3326                         match = re.match(r"^(\.+)(.*)$", inc_sls)
3327                         if match:
3328                             levels, include = match.groups()
3329                         else:
3330                             msg = (
3331                                 "Badly formatted include {} found in include "
3332                                 "in SLS '{}:{}'".format(inc_sls, saltenv, sls)
3333                             )
3334                             log.error(msg)
3335                             errors.append(msg)
3336                             continue
3337                         level_count = len(levels)
3338                         p_comps = sls.split(".")
3339                         if state_data.get("source", "").endswith("/init.sls"):
3340                             p_comps.append("init")
3341                         if level_count &gt; len(p_comps):
3342                             msg = (
3343                                 "Attempted relative include of '{}' "
3344                                 "within SLS '{}:{}' "
3345                                 "goes beyond top level package ".format(
3346                                     inc_sls, saltenv, sls
3347                                 )
3348                             )
3349                             log.error(msg)
3350                             errors.append(msg)
3351                             continue
3352                         inc_sls = ".".join(p_comps[:-level_count] + [include])
3353                     if env_key != xenv_key:
3354                         if matches is None:
3355                             matches = []
3356                         if env_key in matches or fnmatch.filter(
3357                             self.avail[env_key], inc_sls
3358                         ):
3359                             resolved_envs = [env_key]
3360                         else:
3361                             resolved_envs = []
3362                     else:
3363                         resolved_envs = [
3364                             aenv
3365                             for aenv in matches
3366                             if fnmatch.filter(self.avail[aenv], inc_sls)
3367                         ]
3368                     if len(resolved_envs) == 1 or saltenv in resolved_envs:
3369                         sls_targets = fnmatch.filter(self.avail[saltenv], inc_sls) or [
3370                             inc_sls
3371                         ]
3372                         for sls_target in sls_targets:
3373                             r_env = (
3374                                 resolved_envs[0] if len(resolved_envs) == 1 else saltenv
3375                             )
3376                             mod_tgt = "{}:{}".format(r_env, sls_target)
3377                             if mod_tgt not in mods:
3378                                 nstate, err = self.render_state(
3379                                     sls_target, r_env, mods, matches
3380                                 )
3381                                 if nstate:
3382                                     self.merge_included_states(state, nstate, errors)
3383                                     state.update(nstate)
3384                                 if err:
3385                                     errors.extend(err)
3386                     else:
3387                         msg = ""
3388                         if not resolved_envs:
3389                             msg = (
3390                                 "Unknown include: Specified SLS {}: {} is not available"
3391                                 " on the salt master in saltenv(s): {} ".format(
3392                                     env_key,
3393                                     inc_sls,
3394                                     ", ".join(matches)
3395                                     if env_key == xenv_key
3396                                     else env_key,
3397                                 )
3398                             )
3399                         elif len(resolved_envs) &gt; 1:
3400                             msg = (
3401                                 "Ambiguous include: Specified SLS {}: {} is available"
3402                                 " on the salt master in multiple available saltenvs: {}".format(
3403                                     env_key, inc_sls, ", ".join(resolved_envs)
3404                                 )
3405                             )
3406                         log.critical(msg)
3407                         errors.append(msg)
3408                 try:
3409                     self._handle_iorder(state)
3410                 except TypeError:
3411                     log.critical("Could not render SLS %s. Syntax error detected.", sls)
3412         else:
3413             state = {}
3414         return state, errors
3415     def _handle_iorder(self, state):
3416         if self.opts["state_auto_order"]:
3417             for name in state:
3418                 for s_dec in state[name]:
3419                     if not isinstance(s_dec, str):
3420                         continue
3421                     if not isinstance(state[name], dict):
3422                         continue
3423                     if not isinstance(state[name][s_dec], list):
3424                         continue
3425                     found = False
3426                     if s_dec.startswith("_"):
3427                         continue
3428                     for arg in state[name][s_dec]:
3429                         if isinstance(arg, dict):
3430                             if len(arg) &gt; 0:
3431                                 if next(iter(arg.keys())) == "order":
3432                                     found = True
3433                     if not found:
3434                         if not isinstance(state[name][s_dec], list):
3435                             continue
3436                         state[name][s_dec].append({"order": self.iorder})
3437                         self.iorder += 1
3438         return state
3439     def _handle_state_decls(self, state, sls, saltenv, errors):
3440         for name in state:
3441             if not isinstance(state[name], dict):
3442                 if name == "__extend__":
3443                     continue
3444                 if name == "__exclude__":
3445                     continue
3446                 if isinstance(state[name], str):
3447                     if "." in state[name]:
3448                         comps = state[name].split(".")
3449                         state[name] = {
3450                             "__sls__": sls,
3451                             "__env__": saltenv,
3452                             comps[0]: [comps[1]],
3453                         }
3454                         continue
3455                 errors.append("ID {} in SLS {} is not a dictionary".format(name, sls))
3456                 continue
3457             skeys = set()
3458             for key in list(state[name]):
3459                 if key.startswith("_"):
3460                     continue
3461                 if not isinstance(state[name][key], list):
3462                     continue
3463                 if "." in key:
3464                     comps = key.split(".")
3465                     if comps[0] in skeys:
3466                         errors.append(
3467                             "ID '{}' in SLS '{}' contains multiple state "
3468                             "declarations of the same type".format(name, sls)
3469                         )
3470                         continue
3471                     state[name][comps[0]] = state[name].pop(key)
3472                     state[name][comps[0]].append(comps[1])
3473                     skeys.add(comps[0])
3474                     continue
3475                 skeys.add(key)
3476             if "__sls__" not in state[name]:
3477                 state[name]["__sls__"] = sls
3478             if "__env__" not in state[name]:
3479                 state[name]["__env__"] = saltenv
3480     def _handle_extend(self, state, sls, saltenv, errors):
3481         if "extend" in state:
3482             ext = state.pop("extend")
3483             if not isinstance(ext, dict):
3484                 errors.append(
3485                     "Extension value in SLS '{}' is not a dictionary".format(sls)
3486                 )
3487                 return
3488             for name in ext:
3489                 if not isinstance(ext[name], dict):
3490                     errors.append(
3491                         "Extension name '{}' in SLS '{}' is not a dictionary".format(
3492                             name, sls
3493                         )
3494                     )
3495                     continue
3496                 if "__sls__" not in ext[name]:
3497                     ext[name]["__sls__"] = sls
3498                 if "__env__" not in ext[name]:
3499                     ext[name]["__env__"] = saltenv
3500                 for key in list(ext[name]):
3501                     if key.startswith("_"):
3502                         continue
3503                     if not isinstance(ext[name][key], list):
3504                         continue
3505                     if "." in key:
3506                         comps = key.split(".")
3507                         ext[name][comps[0]] = ext[name].pop(key)
3508                         ext[name][comps[0]].append(comps[1])
3509             state.setdefault("__extend__", []).append(ext)
3510     def _handle_exclude(self, state, sls, saltenv, errors):
3511         if "exclude" in state:
3512             exc = state.pop("exclude")
3513             if not isinstance(exc, list):
3514                 err = "Exclude Declaration in SLS {} is not formed as a list".format(
3515                     sls
3516                 )
3517                 errors.append(err)
3518             state.setdefault("__exclude__", []).extend(exc)
3519     def render_highstate(self, matches, context=None):
3520         highstate = self.building_highstate
3521         all_errors = []
3522         mods = set()
3523         statefiles = []
3524         for saltenv, states in matches.items():
3525             for sls_match in states:
3526                 if saltenv in self.avail:
3527                     statefiles = fnmatch.filter(self.avail[saltenv], sls_match)
3528                 elif "__env__" in self.avail:
3529                     statefiles = fnmatch.filter(self.avail["__env__"], sls_match)
3530                 else:
3531                     all_errors.append(
3532                         "No matching salt environment for environment "
3533                         "'{}' found".format(saltenv)
3534                     )
3535                 if not statefiles:
3536                     statefiles = [sls_match]
3537                 for sls in statefiles:
3538                     r_env = "{}:{}".format(saltenv, sls)
3539                     if r_env in mods:
3540                         continue
3541                     state, errors = self.render_state(
3542                         sls, saltenv, mods, matches, context=context
3543                     )
3544                     if state:
3545                         self.merge_included_states(highstate, state, errors)
3546                     for i, error in enumerate(errors[:]):
3547                         if "is not available" in error:
3548                             this_sls = "SLS {} in saltenv".format(sls_match)
3549                             if this_sls in error:
3550                                 errors[
3551                                     i
3552                                 ] = "No matching sls found for '{}' in env '{}'".format(
3553                                     sls_match, saltenv
3554                                 )
3555                     all_errors.extend(errors)
3556         self.clean_duplicate_extends(highstate)
3557         return highstate, all_errors
3558     def clean_duplicate_extends(self, highstate):
3559         if "__extend__" in highstate:
3560             highext = []
3561             for items in (ext.items() for ext in highstate["__extend__"]):
3562                 for item in items:
3563                     if item not in highext:
3564                         highext.append(item)
3565             highstate["__extend__"] = [{t[0]: t[1]} for t in highext]
3566     def merge_included_states(self, highstate, state, errors):
3567         if "__extend__" in state:
3568             highstate.setdefault("__extend__", []).extend(state.pop("__extend__"))
3569         if "__exclude__" in state:
3570             highstate.setdefault("__exclude__", []).extend(state.pop("__exclude__"))
3571         for id_ in state:
3572             if id_ in highstate:
3573                 if highstate[id_] != state[id_]:
3574                     errors.append(
3575                         "Detected conflicting IDs, SLS"
3576                         " IDs need to be globally unique.\n    The"
3577                         " conflicting ID is '{}' and is found in SLS"
3578                         " '{}:{}' and SLS '{}:{}'".format(
3579                             id_,
3580                             highstate[id_]["__env__"],
3581                             highstate[id_]["__sls__"],
3582                             state[id_]["__env__"],
3583                             state[id_]["__sls__"],
3584                         )
3585                     )
3586         try:
3587             highstate.update(state)
3588         except ValueError:
3589             errors.append("Error when rendering state with contents: {}".format(state))
3590     def _check_pillar(self, force=False):
3591         if force:
3592             return True
3593         if "_errors" in self.state.opts["pillar"]:
3594             return False
3595         return True
3596     def matches_whitelist(self, matches, whitelist):
3597         if not whitelist:
3598             return matches
3599         ret_matches = {}
3600         if not isinstance(whitelist, list):
3601             whitelist = whitelist.split(",")
3602         for env in matches:
3603                 if sls in whitelist:
3604                     ret_matches[env] = ret_matches[env] if env in ret_matches else []
3605                     ret_matches[env].append(sl<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>s)
3606         return ret_matches
3607     def call_highstate(
3608         self,
3609         exclude=None,
3610         cache=None,
3611         cache_name="highstate",
3612         force=False,
3613         whitelist=None,
3614         orchestration_jid=None,
3615     ):
3616         tag_name = "no_|-states_|-states_|-None"
3617         ret =</b></font> {
3618             tag_name: {
3619                 "result": False,
3620                 "comment": "No states found for this minion",
3621                 "name": "No States",
3622                 "changes": {},
3623                 "__run_num__": 0,
3624             }
3625         }
3626         cfn = os.path.join(self.opts["cachedir"], "{}.cache.p".format(cache_name))
3627         if cache:
3628             if os.path.isfile(cfn):
3629                 with salt.utils.files.fopen(cfn, "rb") as fp_:
3630                     high = salt.payload.load(fp_)
3631                     return self.state.call_high(high, orchestration_jid)
3632         err = []
3633         try:
3634             top = self.get_top()
3635         except SaltRenderError as err:
3636             ret[tag_name]["comment"] = "Unable to render top file: "
3637             ret[tag_name]["comment"] += str(err.error)
3638             return ret
3639         except Exception:  # pylint: disable=broad-except
3640             trb = traceback.format_exc()
3641             err.append(trb)
3642             return err
3643         err += self.verify_tops(top)
3644         matches = self.top_matches(top)
3645         if not matches:
3646             msg = (
3647                 "No Top file or master_tops data matches found. Please see "
3648                 "master log for details."
3649             )
3650             ret[tag_name]["comment"] = msg
3651             return ret
3652         matches = self.matches_whitelist(matches, whitelist)
3653         self.load_dynamic(matches)
3654         if not self._check_pillar(force):
3655             err += ["Pillar failed to render with the following messages:"]
3656             err += self.state.opts["pillar"]["_errors"]
3657         else:
3658             high, errors = self.render_highstate(matches)
3659             if exclude:
3660                 if isinstance(exclude, str):
3661                     exclude = exclude.split(",")
3662                 if "__exclude__" in high:
3663                     high["__exclude__"].extend(exclude)
3664                 else:
3665                     high["__exclude__"] = exclude
3666             err += errors
3667         if err:
3668             return err
3669         if not high:
3670             return ret
3671         with salt.utils.files.set_umask(0o077):
3672             try:
3673                 if salt.utils.platform.is_windows():
3674                     self.state.functions["cmd.run"](
3675                         ["attrib", "-R", cfn],
3676                         python_shell=False,
3677                         output_loglevel="quiet",
3678                     )
3679                 with salt.utils.files.fopen(cfn, "w+b") as fp_:
3680                     try:
3681                         salt.payload.dump(high, fp_)
3682                     except TypeError:
3683                         pass
3684             except OSError:
3685                 log.error('Unable to write to "state.highstate" cache file %s', cfn)
3686         return self.state.call_high(high, orchestration_jid)
3687     def compile_highstate(self):
3688         err = []
3689         top = self.get_top()
3690         err += self.verify_tops(top)
3691         matches = self.top_matches(top)
3692         high, errors = self.render_highstate(matches)
3693         err += errors
3694         if err:
3695             return err
3696         return high
3697     def compile_low_chunks(self):
3698         top = self.get_top()
3699         matches = self.top_matches(top)
3700         high, errors = self.render_highstate(matches)
3701         high, ext_errors = self.state.reconcile_extend(high)
3702         errors += ext_errors
3703         errors += self.state.verify_high(high)
3704         high, req_in_errors = self.state.requisite_in(high)
3705         errors += req_in_errors
3706         high = self.state.apply_exclude(high)
3707         if errors:
3708             return errors
3709         chunks = self.state.compile_high_data(high)
3710         return chunks
3711     def compile_state_usage(self):
3712         err = []
3713         top = self.get_top()
3714         err += self.verify_tops(top)
3715         if err:
3716             return err
3717         matches = self.top_matches(top)
3718         state_usage = {}
3719         for saltenv, states in self.avail.items():
3720             env_usage = {
3721                 "used": [],
3722                 "unused": [],
3723                 "count_all": 0,
3724                 "count_used": 0,
3725                 "count_unused": 0,
3726             }
3727             env_matches = matches.get(saltenv, [])
3728             for state in states:
3729                 env_usage["count_all"] += 1
3730                 if state in env_matches:
3731                     env_usage["count_used"] += 1
3732                     env_usage["used"].append(state)
3733                 else:
3734                     env_usage["count_unused"] += 1
3735                     env_usage["unused"].append(state)
3736             state_usage[saltenv] = env_usage
3737         return state_usage
3738     def destroy(self):
3739         raise NotImplementedError
3740     def __enter__(self):
3741         return self
3742     def __exit__(self, *_):
3743         self.destroy()
3744 class HighState(BaseHighState):
3745     stack = []
3746     def __init__(
3747         self,
3748         opts,
3749         pillar_override=None,
3750         jid=None,
3751         pillar_enc=None,
3752         proxy=None,
3753         context=None,
3754         mocked=False,
3755         initial_pillar=None,
3756     ):
3757         self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.opts = opts
3758         self.client = salt.fileclient.get_file_client(self.opts)
3759         BaseHighState.__init__(self, opts)
3760         self.state =</b></font> State(
3761             self.opts,
3762             pillar_override,
3763             jid,
3764             pillar_enc,
3765             proxy=proxy,
3766             context=context,
3767             mocked=mocked,
3768             loader=loader,
3769             initial_pillar=initial_pillar,
3770         )
3771         self.matchers = salt.loader.matchers(self.opts)
3772         self.proxy = proxy
3773         self._pydsl_all_decls = {}
3774         self._pydsl_render_stack = []
3775     def push_active(self):
3776         self.stack.append(self)
3777     @classmethod
3778     def clear_active(cls):
3779         cls.stack = []
3780     @classmethod
3781     def pop_active(cls):
3782         cls.stack.pop()
3783     @classmethod
3784     def get_active(cls):
3785         try:
3786             return cls.stack[-1]
3787         except IndexError:
3788             return None
3789     def destroy(self):
3790         self.client.destroy()
3791     def __enter__(self):
3792         return self
3793     def __exit__(self, *_):
3794         self.destroy()
3795 class MasterState(State):
3796     def __init__(self, opts, minion):
3797         State.__init__(self, opts)
3798     def load_modules(self, data=None, proxy=None):
3799         log.info("Loading fresh modules for state activity")
3800         self.functions = salt.client.FunctionWrapper(self.opts, self.opts["id"])
3801         self.utils = salt.loader.utils(self.opts)
3802         self.serializers = salt.loader.serializers(self.opts)
3803         self.states = salt.loader<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.states(
3804             self.opts, self.functions, self.utils, self.serializers
3805         )
3806         self.rend = salt.loader.render(
3807             self.</b></font>opts, self.functions, states=self.states, context=self.state_con
3808         )
3809 class MasterHighState(HighState):
3810     def __init__(self, master_opts, minion_opts, grains, id_, saltenv=None):
3811         opts = copy.deepcopy(minion_opts)
3812         opts["file_client"] = "local"
3813         opts["file_roots"] = master_opts["master_roots"]
3814         opts["renderer"] = master_opts["renderer"]
3815         opts["state_top"] = master_opts["state_top"]
3816         opts["id"] = id_
3817         opts["grains"] = grains
3818         HighState.__init__(self, opts)
3819 class RemoteHighState:
3820     def __init__(self, opts, grains):
3821         self.opts = opts
3822         self.grains = grains
3823         self.channel = salt.channel.client.ReqChannel.factory(self.opts["master_uri"])
3824         self._closing = False
3825     def compile_master(self):
3826         load = {"grains": self.grains, "opts": self.opts, "cmd": "_master_state"}
3827         try:
3828             return self.channel.send(load, tries=3, timeout=72000)
3829         except SaltReqTimeoutError:
3830             return {}
3831     def destroy(self):
3832         if self._closing:
3833             return
3834         self._closing = True
3835         self.channel.close()
3836     def __del__(self):
3837         self.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
