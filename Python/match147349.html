<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_update.py &amp; state_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_update.py &amp; state_1.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_update.py (9.501411%)<th>state_1.py (1.3687491%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(166-171)<td><a href="#" name="0">(759-764)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(544-552)<td><a href="#" name="1">(2002-2008)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(234-237)<td><a href="#" name="2">(2859-2863)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1074-1079)<td><a href="#" name="3">(4668-4671)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(850-855)<td><a href="#" name="4">(2257-2262)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(751-753)<td><a href="#" name="5">(4745-4749)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(685-690)<td><a href="#" name="6">(3020-3022)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(437-450)<td><a href="#" name="7">(4462-4479)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_update.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import subprocess
3 import salt.utils.args
4 import salt.utils.data
5 import salt.utils.winapi
6 from salt.exceptions import CommandExecutionError
7 try:
8     import win32com.client
9     import pywintypes
10     HAS_PYWIN32 = True
11 except ImportError:
12     HAS_PYWIN32 = False
13 log = logging.getLogger(__name__)
14 REBOOT_BEHAVIOR = {
15     0: "Never Requires Reboot",
16     1: "Always Requires Reboot",
17     2: "Can Require Reboot",
18 }
19 __virtualname__ = "win_update"
20 def __virtual__():
21     if not salt.utils.platform.is_windows():
22         return False, "win_update: Only available on Windows"
23     if not HAS_PYWIN32:
24         return False, "win_update: Missing pywin32"
25     return __virtualname__
26 class Updates:
27     update_types = {1: "Software", 2: "Driver"}
28     def __init__(self):
29         with salt.utils.winapi.Com():
30             self.updates = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
31     def count(self):
32         return self.updates.Count
33     def list(self):
34         if self.count() == 0:
35             return "Nothing to return"
36         log.debug("Building a detailed report of the results.")
37         results = {}
38         for update in self.updates:
39             try:
40                 user_input = bool(update.InstallationBehavior.CanRequestUserInput)
41             except AttributeError:
42                 log.debug(
43                     "Windows Update: Error reading InstallationBehavior COM Object"
44                 )
45                 user_input = False
46             try:
47                 requires_reboot = update.InstallationBehavior.RebootBehavior
48             except AttributeError:
49                 log.debug(
50                     "Windows Update: Error reading InstallationBehavior COM Object"
51                 )
52                 requires_reboot = 2
53 <a name="0"></a>
54             results<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>[update.Identity.UpdateID] = {
55                 "guid": update.Identity.UpdateID,
56                 "Title": str(update.Title),
57                 "Type": self.update_types[update.Type],
58                 "Description": update.Description,
59                 "Downloaded": bool(update.</b></font>IsDownloaded),
60                 "Installed": bool(update.IsInstalled),
61                 "Mandatory": bool(update.IsMandatory),
62                 "EULAAccepted": bool(update.EulaAccepted),
63                 "NeedsReboot": bool(update.RebootRequired),
64                 "Severity": str(update.MsrcSeverity),
65                 "UserInput": user_input,
66                 "RebootBehavior": REBOOT_BEHAVIOR[requires_reboot],
67                 "KBs": ["KB" + item for item in update.KBArticleIDs],
68                 "Categories": [item.Name for item in update.Categories],
69                 "SupportUrl": update.SupportUrl,
70             }
71         return results
72     def summary(self):
73         if self.count() == 0:
74             return "Nothing to return"
75         results = {
76             "Total": 0,
77             "Available": 0,
78             "Downloaded": 0,
79             "Installed": 0,
80             "Categories": {},
81             "Severity": {},
82         }
83         for update in self.updates:
84 <a name="2"></a>            results["Total"] += 1
85             if not salt<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.data.is_true(
86                 update.IsDownloaded
87             ) and not salt.utils.data.is_true(update.IsInstalled):
88                 results["Available"] +</b></font>= 1
89             if salt.utils.data.is_true(
90                 update.IsDownloaded
91             ) and not salt.utils.data.is_true(update.IsInstalled):
92                 results["Downloaded"] += 1
93             if salt.utils.data.is_true(update.IsInstalled):
94                 results["Installed"] += 1
95             for category in update.Categories:
96                 if category.Name in results["Categories"]:
97                     results["Categories"][category.Name] += 1
98                 else:
99                     results["Categories"][category.Name] = 1
100             if update.MsrcSeverity:
101                 if update.MsrcSeverity in results["Severity"]:
102                     results["Severity"][update.MsrcSeverity] += 1
103                 else:
104                     results["Severity"][update.MsrcSeverity] = 1
105         return results
106 class WindowsUpdateAgent:
107     fail_codes = {
108         -2145107924: "WinHTTP Send/Receive failed: 0x8024402C",
109         -2145124300: "Download failed: 0x80240034",
110         -2145124302: "Invalid search criteria: 0x80240032",
111         -2145124305: "Cancelled by policy: 0x8024002F",
112         -2145124307: "Missing source: 0x8024002D",
113         -2145124308: "Missing source: 0x8024002C",
114         -2145124312: "Uninstall not allowed: 0x80240028",
115         -2145124315: "Prevented by policy: 0x80240025",
116         -2145124316: "No Updates: 0x80240024",
117         -2145124322: "Service being shutdown: 0x8024001E",
118         -2145124325: "Self Update in Progress: 0x8024001B",
119         -2145124327: "Exclusive Install Conflict: 0x80240019",
120         -2145124330: "Install not allowed: 0x80240016",
121         -2145124333: "Duplicate item: 0x80240013",
122         -2145124341: "Operation cancelled: 0x8024000B",
123         -2145124343: "Operation in progress: 0x80240009",
124         -2145124284: "Access Denied: 0x8024044",
125         -2145124283: "Unsupported search scope: 0x80240045",
126         -2147024891: "Access is denied: 0x80070005",
127         -2149843018: "Setup in progress: 0x8024004A",
128         -4292599787: "Install still pending: 0x00242015",
129         -4292607992: "Already downloaded: 0x00240008",
130         -4292607993: "Already uninstalled: 0x00240007",
131         -4292607994: "Already installed: 0x00240006",
132         -4292607995: "Reboot required: 0x00240005",
133     }
134     def __init__(self, online=True):
135         with salt.utils.winapi.Com():
136             self._session = win32com.client.Dispatch("Microsoft.Update.Session")
137             self._updates = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
138         self.refresh(online=online)
139     def updates(self):
140         updates = Updates()
141         found = updates.updates
142         for update in self._updates:
143             found.Add(update)
144         return updates
145     def refresh(self, online=True):
146         search_string = "Type='Software' or Type='Driver'"
147         searcher = self._session.CreateUpdateSearcher()
148         searcher.Online = online
149         self._session.ClientApplicationID = "Salt: Load Updates"
150         try:
151             results = searcher.Search(search_string)
152             if results.Updates.Count == 0:
153                 log.debug("No Updates found for:\n\t\t%s", search_string)
154                 return "No Updates found: {}".format(search_string)
155         except pywintypes.com_error as error:
156             hr, msg, exc, arg = error.args  # pylint: disable=W0633
157             try:
158                 failure_code = self.fail_codes[exc[5]]
159             except KeyError:
160                 failure_code = "Unknown Failure: {}".format(error)
161             log.error("Search Failed: %s\n\t\t%s", failure_code, search_string)
162             raise CommandExecutionError(failure_code)
163         self._updates = results.Updates
164     def installed(self):
165         updates = Updates()
166 <a name="7"></a>
167         for update in self._updates:
168             if salt.utils.data.is_true(update.IsInstalled):
169                 updates.updates.Add(u<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>pdate)
170         return updates
171     def available(
172         self,
173         skip_hidden=True,
174         skip_installed=True,
175         skip_mandatory=False,
176         skip_reboot=False,
177         software=True,
178         drivers=True,
179         categories=None,
180         severities=</b></font>None,
181     ):
182         updates = Updates()
183         found = updates.updates
184         for update in self._updates:
185             if salt.utils.data.is_true(update.IsHidden) and skip_hidden:
186                 continue
187             if salt.utils.data.is_true(update.IsInstalled) and skip_installed:
188                 continue
189             if salt.utils.data.is_true(update.IsMandatory) and skip_mandatory:
190                 continue
191             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>try:
192                 requires_reboot = salt.utils.data.is_true(
193                     update.InstallationBehavior.RebootBehavior
194                 )
195             except AttributeError:
196                 log.debug(
197                     "Windows Update: Error reading InstallationBehavior COM Object"
198                 )
199                 requires_reboot =</b></font> True
200             if requires_reboot and skip_reboot:
201                 continue
202             if not software and update.Type == 1:
203                 continue
204             if not drivers and update.Type == 2:
205                 continue
206             if categories is not None:
207                 match = False
208                 for category in update.Categories:
209                     if category.Name in categories:
210                         match = True
211                 if not match:
212                     continue
213             if severities is not None:
214                 if update.MsrcSeverity not in severities:
215                     continue
216             found.Add(update)
217         return updates
218     def search(self, search_string):
219         updates = Updates()
220         found = updates.updates
221         if isinstance(search_string, str):
222             search_string = [search_string]
223         if isinstance(search_string, int):
224             search_string = [str(search_string)]
225         for update in self._updates:
226             for find in search_string:
227                 if find == update.Identity.UpdateID:
228                     found.Add(update)
229                     continue
230                 if find in ["KB" + item for item in update.KBArticleIDs]:
231                     found.Add(update)
232                     continue
233                 if find in [item for item in update.KBArticleIDs]:
234                     found.Add(update)
235                     continue
236                 if find in update.Title:
237                     found.Add(update)
238                     continue
239         return updates
240     def download(self, updates):
241         if updates.count() == 0:
242             ret = {"Success": False, "Updates": "Nothing to download"}
243             return ret
244         downloader = self._session.CreateUpdateDownloader()
245         self._session.ClientApplicationID = "Salt: Download Update"
246         with salt.utils.winapi.Com():
247             download_list = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
248 <a name="6"></a>            ret = {"Updates": {}}
249             for update in updates<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.updates:
250                 uid = update.Identity.UpdateID
251                 ret["Updates"][uid] = {}
252                 ret["Updates"][uid]["Title"] = update.</b></font>Title
253                 ret["Updates"][uid]["AlreadyDownloaded"] = bool(update.IsDownloaded)
254                 if not salt.utils.data.is_true(update.EulaAccepted):
255                     log.debug("Accepting EULA: %s", update.Title)
256                     update.AcceptEula()  # pylint: disable=W0104
257                 if not salt.utils.data.is_true(update.IsDownloaded):
258                     log.debug("To Be Downloaded: %s", uid)
259                     log.debug("\tTitle: %s", update.Title)
260                     download_list.Add(update)
261             if download_list.Count == 0:
262                 ret = {"Success": True, "Updates": "Nothing to download"}
263                 return ret
264             downloader.Updates = download_list
265             try:
266                 log.debug("Downloading Updates")
267                 result = downloader.Download()
268             except pywintypes.com_error as error:
269                 hr, msg, exc, arg = error.args  # pylint: disable=W0633
270                 try:
271                     failure_code = self.fail_codes[exc[5]]
272                 except KeyError:
273                     failure_code = "Unknown Failure: {}".format(error)
274                 log.error("Download Failed: %s", failure_code)
275                 raise CommandExecutionError(failure_code)
276             result_code = {
277                 0: "Download Not Started",
278                 1: "Download In Progress",
279                 2: "Download Succeeded",
280                 3: "Download Succeeded With Errors",
281                 4: "Download Failed",
282                 5: "Download Aborted",
283             }
284             log.debug("Download Complete")
285             log.debug(result_code[result.ResultCode])
286             ret["Message"] = result_code[result.ResultCode]
287             if result.ResultCode in [2, 3]:
288                 log.debug("Downloaded Successfully")
289                 ret["Success"] = True
290             else:
291                 log.debug("Download Failed")
292                 ret["Success"] = False
293 <a name="5"></a>
294             for i in range(download_list.Count):
295                 uid = download_list<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.Item(i).Identity.UpdateID
296                 ret["Updates"][uid]["Result"] = result_code[
297                     result.GetUpdateResult(i).</b></font>ResultCode
298                 ]
299         return ret
300     def install(self, updates):
301         if updates.count() == 0:
302             ret = {"Success": False, "Updates": "Nothing to install"}
303             return ret
304         installer = self._session.CreateUpdateInstaller()
305         self._session.ClientApplicationID = "Salt: Install Update"
306         with salt.utils.winapi.Com():
307             install_list = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
308             ret = {"Updates": {}}
309             for update in updates.updates:
310                 uid = update.Identity.UpdateID
311                 ret["Updates"][uid] = {}
312                 ret["Updates"][uid]["Title"] = update.Title
313                 ret["Updates"][uid]["AlreadyInstalled"] = bool(update.IsInstalled)
314                 if not salt.utils.data.is_true(update.IsInstalled):
315                     log.debug("To Be Installed: %s", uid)
316                     log.debug("\tTitle: %s", update.Title)
317                     install_list.Add(update)
318             if install_list.Count == 0:
319                 ret = {"Success": True, "Updates": "Nothing to install"}
320                 return ret
321             installer.Updates = install_list
322             try:
323                 log.debug("Installing Updates")
324                 result = installer.Install()
325             except pywintypes.com_error as error:
326                 hr, msg, exc, arg = error.args  # pylint: disable=W0633
327                 try:
328                     failure_code = self.fail_codes[exc[5]]
329                 except KeyError:
330                     failure_code = "Unknown Failure: {}".format(error)
331                 log.error("Install Failed: %s", failure_code)
332                 raise CommandExecutionError(failure_code)
333             result_code = {
334                 0: "Installation Not Started",
335                 1: "Installation In Progress",
336                 2: "Installation Succeeded",
337                 3: "Installation Succeeded With Errors",
338                 4: "Installation Failed",
339                 5: "Installation Aborted",
340             }
341             log.debug("Install Complete")
342 <a name="4"></a>            log.debug(result_code[result.ResultCode])
343             ret["Message"] = result_code[result.ResultCode]
344             if result<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.ResultCode in [2, 3]:
345                 ret["Success"] = True
346                 ret["NeedsReboot"] = result.RebootRequired
347                 log.debug("NeedsReboot: %s", result.RebootRequired)
348             else:
349                 log.debug(</b></font>"Install Failed")
350                 ret["Success"] = False
351             for i in range(install_list.Count):
352                 uid = install_list.Item(i).Identity.UpdateID
353                 ret["Updates"][uid]["Result"] = result_code[
354                     result.GetUpdateResult(i).ResultCode
355                 ]
356                 try:
357                     reboot_behavior = install_list.Item(
358                         i
359                     ).InstallationBehavior.RebootBehavior
360                 except AttributeError:
361                     log.debug(
362                         "Windows Update: Error reading InstallationBehavior COM Object"
363                     )
364                     reboot_behavior = 2
365                 ret["Updates"][uid]["RebootBehavior"] = REBOOT_BEHAVIOR[reboot_behavior]
366         return ret
367     def uninstall(self, updates):
368         if updates.count() == 0:
369             ret = {"Success": False, "Updates": "Nothing to uninstall"}
370             return ret
371         installer = self._session.CreateUpdateInstaller()
372         self._session.ClientApplicationID = "Salt: Uninstall Update"
373         with salt.utils.winapi.Com():
374             uninstall_list = win32com.client.Dispatch("Microsoft.Update.UpdateColl")
375             ret = {"Updates": {}}
376             for update in updates.updates:
377                 uid = update.Identity.UpdateID
378                 ret["Updates"][uid] = {}
379                 ret["Updates"][uid]["Title"] = update.Title
380                 ret["Updates"][uid]["AlreadyUninstalled"] = not bool(update.IsInstalled)
381                 if salt.utils.data.is_true(update.IsInstalled):
382                     log.debug("To Be Uninstalled: %s", uid)
383                     log.debug("\tTitle: %s", update.Title)
384                     uninstall_list.Add(update)
385             if uninstall_list.Count == 0:
386                 ret = {"Success": False, "Updates": "Nothing to uninstall"}
387                 return ret
388             installer.Updates = uninstall_list
389             try:
390                 log.debug("Uninstalling Updates")
391                 result = installer.Uninstall()
392             except pywintypes.com_error as error:
393                 hr, msg, exc, arg = error.args  # pylint: disable=W0633
394                 try:
395                     failure_code = self.fail_codes[exc[5]]
396                 except KeyError:
397                     failure_code = "Unknown Failure: {}".format(error)
398                 if exc[5] == -2145124312:
399                     log.debug("Uninstall Failed with WUA, attempting with DISM")
400                     try:
401                         for item in uninstall_list:
402                             for kb in item.KBArticleIDs:
403                                 cmd = ["dism", "/Online", "/Get-Packages"]
404                                 pkg_list = self._run(cmd)[0].splitlines()
405                                 for item in pkg_list:
406                                     if "kb" + kb in item.lower():
407                                         pkg = item.split(" : ")[1]
408                                         ret["DismPackage"] = pkg
409                                         cmd = [
410                                             "dism",
411                                             "/Online",
412                                             "/Remove-Package",
413                                             "/PackageName:{}".format(pkg),
414                                             "/Quiet",
415                                             "/NoRestart",
416                                         ]
417                                         self._run(cmd)
418                     except CommandExecutionError as exc:
419                         log.debug("Uninstall using DISM failed")
420                         log.debug("Command: %s", " ".join(cmd))
421                         log.debug("Error: %s", exc)
422                         raise CommandExecutionError(
423                             "Uninstall using DISM failed: {}".format(exc)
424                         )
425                     log.debug("Uninstall Completed using DISM")
426                     ret["Success"] = True
427                     ret["Message"] = "Uninstalled using DISM"
428                     ret["NeedsReboot"] = needs_reboot()
429                     log.debug("NeedsReboot: %s", ret["NeedsReboot"])
430                     self.refresh(online=False)
431                     for update in self._updates:
432                         uid = update.Identity.UpdateID
433                         for item in uninstall_list:
434                             if item.Identity.UpdateID == uid:
435                                 if not update.IsInstalled:
436                                     ret["Updates"][uid][
437                                         "Result"
438                                     ] = "Uninstallation Succeeded"
439                                 else:
440                                     ret["Updates"][uid][
441                                         "Result"
442                                     ] = "Uninstallation Failed"
443                                 try:
444                                     requires_reboot = (
445                                         update.InstallationBehavior.RebootBehavior
446                                     )
447                                 except AttributeError:
448                                     log.debug(
449                                         "Windows Update: Error reading"
450                                         " InstallationBehavior COM Object"
451                                     )
452                                     requires_reboot = 2
453                                 ret["Updates"][uid]["RebootBehavior"] = REBOOT_BEHAVIOR[
454                                     requires_reboot
455                                 ]
456                     return ret
457                 log.error("Uninstall Failed: %s", failure_code)
458                 raise CommandExecutionError(failure_code)
459             result_code = {
460                 0: "Uninstallation Not Started",
461                 1: "Uninstallation In Progress",
462                 2: "Uninstallation Succeeded",
463                 3: "Uninstallation Succeeded With Errors",
464                 4: "Uninstallation Failed",
465                 5: "Uninstallation Aborted",
466             }
467             log.debug("Uninstall Complete")
468             log.debug(result_code[result.ResultCode])
469 <a name="3"></a>            ret["Message"] = result_code[result.ResultCode]
470             if result.ResultCode in [2, 3]:
471                 ret<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["Success"] = True
472                 ret["NeedsReboot"] = result.RebootRequired
473                 log.debug("NeedsReboot: %s", result.RebootRequired)
474             else:
475                 log.debug("Uninstall Failed")
476                 ret["Success"] =</b></font> False
477             for i in range(uninstall_list.Count):
478                 uid = uninstall_list.Item(i).Identity.UpdateID
479                 ret["Updates"][uid]["Result"] = result_code[
480                     result.GetUpdateResult(i).ResultCode
481                 ]
482                 try:
483                     reboot_behavior = uninstall_list.Item(
484                         i
485                     ).InstallationBehavior.RebootBehavior
486                 except AttributeError:
487                     log.debug(
488                         "Windows Update: Error reading InstallationBehavior COM Object"
489                     )
490                     reboot_behavior = 2
491                 ret["Updates"][uid]["RebootBehavior"] = REBOOT_BEHAVIOR[reboot_behavior]
492         return ret
493     def _run(self, cmd):
494         if isinstance(cmd, str):
495             cmd = salt.utils.args.shlex_split(cmd)
496         try:
497             log.debug(cmd)
498             p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
499             return p.communicate()
500         except OSError as exc:
501             log.debug("Command Failed: %s", " ".join(cmd))
502             log.debug("Error: %s", exc)
503             raise CommandExecutionError(exc)
504 def needs_reboot():
505     with salt.utils.winapi.Com():
506         try:
507             obj_sys = win32com.client.Dispatch("Microsoft.Update.SystemInfo")
508         except pywintypes.com_error as exc:
509             _, msg, _, _ = exc.args
510             log.debug("Failed to create SystemInfo object: %s", msg)
511             return False
512         return salt.utils.data.is_true(obj_sys.RebootRequired)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>state_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import datetime
3 import fnmatch
4 import importlib
5 import logging
6 import os
7 import random
8 import re
9 import site
10 import sys
11 import time
12 import traceback
13 import salt.channel.client
14 import salt.fileclient
15 import salt.loader
16 import salt.minion
17 import salt.pillar
18 import salt.syspaths as syspaths
19 import salt.utils.args
20 import salt.utils.crypt
21 import salt.utils.data
22 import salt.utils.decorators.state
23 import salt.utils.dictupdate
24 import salt.utils.event
25 import salt.utils.files
26 import salt.utils.hashutils
27 import salt.utils.immutabletypes as immutabletypes
28 import salt.utils.msgpack
29 import salt.utils.platform
30 import salt.utils.process
31 import salt.utils.url
32 import salt.utils.yamlloader as yamlloader
33 from salt.exceptions import CommandExecutionError, SaltRenderError, SaltReqTimeoutError
34 from salt.serializers.msgpack import deserialize as msgpack_deserialize
35 from salt.serializers.msgpack import serialize as msgpack_serialize
36 from salt.template import compile_template, compile_template_str
37 from salt.utils.odict import DefaultOrderedDict, OrderedDict
38 log = logging.getLogger(__name__)
39 STATE_REQUISITE_KEYWORDS = frozenset(
40     [
41         "onchanges",
42         "onchanges_any",
43         "onfail",
44         "onfail_any",
45         "onfail_all",
46         "onfail_stop",
47         "prereq",
48         "prerequired",
49         "watch",
50         "watch_any",
51         "require",
52         "require_any",
53         "listen",
54     ]
55 )
56 STATE_REQUISITE_IN_KEYWORDS = frozenset(
57     ["onchanges_in", "onfail_in", "prereq_in", "watch_in", "require_in", "listen_in"]
58 )
59 STATE_RUNTIME_KEYWORDS = frozenset(
60     [
61         "fun",
62         "state",
63         "check_cmd",
64         "failhard",
65         "onlyif",
66         "unless",
67         "creates",
68         "retry",
69         "order",
70         "parallel",
71         "prereq",
72         "prereq_in",
73         "prerequired",
74         "reload_modules",
75         "reload_grains",
76         "reload_pillar",
77         "runas",
78         "runas_password",
79         "fire_event",
80         "saltenv",
81         "use",
82         "use_in",
83         "__env__",
84         "__sls__",
85         "__id__",
86         "__orchestration_jid__",
87         "__pub_user",
88         "__pub_arg",
89         "__pub_jid",
90         "__pub_fun",
91         "__pub_tgt",
92         "__pub_ret",
93         "__pub_pid",
94         "__pub_tgt_type",
95         "__prereq__",
96         "__prerequired__",
97     ]
98 )
99 STATE_INTERNAL_KEYWORDS = STATE_REQUISITE_KEYWORDS.union(
100     STATE_REQUISITE_IN_KEYWORDS
101 ).union(STATE_RUNTIME_KEYWORDS)
102 def _odict_hashable(self):
103     return id(self)
104 OrderedDict.__hash__ = _odict_hashable
105 def split_low_tag(tag):
106     state, id_, name, fun = tag.split("_|-")
107     return {"state": state, "__id__": id_, "name": name, "fun": fun}
108 def _gen_tag(low):
109     return "{0[state]}_|-{0[__id__]}_|-{0[name]}_|-{0[fun]}".format(low)
110 def _clean_tag(tag):
111     return salt.utils.files.safe_filename_leaf(tag)
112 def _l_tag(name, id_):
113     low = {
114         "name": "listen_{}".format(name),
115         "__id__": "listen_{}".format(id_),
116         "state": "Listen_Error",
117         "fun": "Listen_Error",
118     }
119     return _gen_tag(low)
120 def _calculate_fake_duration():
121     utc_start_time = datetime.datetime.utcnow()
122     local_start_time = utc_start_time - (
123         datetime.datetime.utcnow() - datetime.datetime.now()
124     )
125     utc_finish_time = datetime.datetime.utcnow()
126     start_time = local_start_time.time().isoformat()
127     delta = utc_finish_time - utc_start_time
128     duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
129     return start_time, duration
130 def get_accumulator_dir(cachedir):
131     fn_ = os.path.join(cachedir, "accumulator")
132     if not os.path.isdir(fn_):
133         os.makedirs(fn_)
134     return fn_
135 def trim_req(req):
136     reqfirst = next(iter(req))
137     if "." in reqfirst:
138         return {reqfirst.split(".")[0]: req[reqfirst]}
139     return req
140 def state_args(id_, state, high):
141     args = set()
142     if id_ not in high:
143         return args
144     if state not in high[id_]:
145         return args
146     for item in high[id_][state]:
147         if not isinstance(item, dict):
148             continue
149         if len(item) != 1:
150             continue
151         args.add(next(iter(item)))
152     return args
153 def find_name(name, state, high, strict=False):
154     ext_id = []
155     if strict is False:
156         check2 = True
157     else:
158         check2 = state in high.get(name, {})
159     if name in high and check2:
160         ext_id.append((name, state))
161     elif state == "sls":
162         for nid, item in high.items():
163             if item["__sls__"] == name:
164                 ext_id.append((nid, next(iter(item))))
165     else:
166         for nid in high:
167             if state in high[nid]:
168                 if isinstance(high[nid][state], list):
169                     for arg in high[nid][state]:
170                         if not isinstance(arg, dict):
171                             continue
172                         if len(arg) != 1:
173                             continue
174                         if arg[next(iter(arg))] == name:
175                             ext_id.append((nid, state))
176     return ext_id
177 def find_sls_ids(sls, high):
178     ret = []
179     for nid, item in high.items():
180         try:
181             sls_tgt = item["__sls__"]
182         except TypeError:
183             if nid != "__exclude__":
184                 log.error(
185                     "Invalid non-dict item '%s' in high data. Value: %r", nid, item
186                 )
187             continue
188         else:
189             if sls_tgt == sls:
190                 for st_ in item:
191                     if st_.startswith("__"):
192                         continue
193                     ret.append((nid, st_))
194     return ret
195 def format_log(ret):
196     msg = ""
197     if isinstance(ret, dict):
198         if "changes" in ret:
199             chg = ret["changes"]
200             if not chg:
201                 if ret["comment"]:
202                     msg = ret["comment"]
203                 else:
204                     msg = "No changes made for {0[name]}".format(ret)
205             elif isinstance(chg, dict):
206                 if "diff" in chg:
207                     if isinstance(chg["diff"], str):
208                         msg = "File changed:\n{}".format(chg["diff"])
209                 if all([isinstance(x, dict) for x in chg.values()]):
210                     if all([("old" in x and "new" in x) for x in chg.values()]):
211                         msg = "Made the following changes:\n"
212                         for pkg in chg:
213                             old = chg[pkg]["old"]
214                             if not old and old not in (False, None):
215                                 old = "absent"
216                             new = chg[pkg]["new"]
217                             if not new and new not in (False, None):
218                                 new = "absent"
219                             msg += "'{}' changed from '{}' to '{}'\n".format(
220                                 pkg, old, new
221                             )
222             if not msg:
223                 msg = str(ret["changes"])
224             if ret["result"] is True or ret["result"] is None:
225                 log.info(msg)
226             else:
227                 log.error(msg)
228     else:
229         log.info(str(ret))
230 def master_compile(master_opts, minion_opts, grains, id_, saltenv):
231     st_ = MasterHighState(master_opts, minion_opts, grains, id_, saltenv)
232     return st_.compile_highstate()
233 def ishashable(obj):
234     try:
235         hash(obj)
236     except TypeError:
237         return False
238     return True
239 def mock_ret(cdata):
240     if cdata["args"]:
241         name = cdata["args"][0]
242     else:
243         name = cdata["kwargs"]["name"]
244     return {
245         "name": name,
246         "comment": "Not called, mocked",
247         "changes": {},
248         "result": True,
249     }
250 class StateError(Exception):
251 class Compiler:
252     def __init__(self, opts, renderers):
253         self.opts = opts
254         self.rend = renderers
255     def render_template(self, template, **kwargs):
256         high = compile_template(
257             template,
258             self.rend,
259             self.opts["renderer"],
260             self.opts["renderer_blacklist"],
261             self.opts["renderer_whitelist"],
262             **kwargs
263         )
264         if not high:
265             return high
266         return self.pad_funcs(high)
267     def pad_funcs(self, high):
268         for name in high:
269             if not isinstance(high[name], dict):
270                 if isinstance(high[name], str):
271                     if "." in high[name]:
272                         comps = high[name].split(".")
273                         if len(comps) &gt;= 2:
274                             comps[1] = ".".join(comps[1 : len(comps)])
275                         high[name] = {
276                             comps[0]: [comps[1]]
277                         }
278                         continue
279                     continue
280             skeys = set()
281             for key in sorted(high[name]):
282                 if key.startswith("_"):
283                     continue
284                 if not isinstance(high[name][key], list):
285                     continue
286                 if "." in key:
287                     comps = key.split(".")
288                     if len(comps) &gt;= 2:
289                         comps[1] = ".".join(comps[1 : len(comps)])
290                     if comps[0] in skeys:
291                         continue
292                     high[name][comps[0]] = high[name].pop(key)
293                     high[name][comps[0]].append(comps[1])
294                     skeys.add(comps[0])
295                     continue
296                 skeys.add(key)
297         return high
298     def verify_high(self, high):
299         errors = []
300         if not isinstance(high, dict):
301             errors.append("High data is not a dictionary and is invalid")
302         reqs = OrderedDict()
303         for name, body in high.items():
304             if name.startswith("__"):
305                 continue
306             if not isinstance(name, str):
307                 errors.append(
308                     "ID '{}' in SLS '{}' is not formed as a string, but is a {}".format(
309                         name, body["__sls__"], type(name).__name__
310                     )
311                 )
312             if not isinstance(body, dict):
313                 err = "The type {} in {} is not formatted as a dictionary".format(
314                     name, body
315                 )
316                 errors.append(err)
317                 continue
318             for state in body:
319                 if state.startswith("__"):
320                     continue
321                 if not isinstance(body[state], list):
322                     errors.append(
323                         "State '{}' in SLS '{}' is not formed as a list".format(
324                             name, body["__sls__"]
325                         )
326                     )
327                 else:
328                     fun = 0
329                     if "." in state:
330                         fun += 1
331                     for arg in body[state]:
332                         if isinstance(arg, str):
333                             fun += 1
334                             if " " in arg.strip():
335                                 errors.append(
336                                     'The function "{}" in state '
337                                     '"{}" in SLS "{}" has '
338                                     "whitespace, a function with whitespace is "
339                                     "not supported, perhaps this is an argument "
340                                     'that is missing a ":"'.format(
341                                         arg, name, body["__sls__"]
342                                     )
343                                 )
344                         elif isinstance(arg, dict):
345                             argfirst = next(iter(arg))
346                             if argfirst in ("require", "watch", "prereq", "onchanges"):
347                                 if not isinstance(arg[argfirst], list):
348                                     errors.append(
349                                         "The {} statement in state '{}' in SLS '{}' "
350                                         "needs to be formed as a list".format(
351                                             argfirst, name, body["__sls__"]
352                                         )
353                                     )
354                                 else:
355                                     reqs[name] = {"state": state}
356                                     for req in arg[argfirst]:
357                                         if isinstance(req, str):
358                                             req = {"id": req}
359                                         if not isinstance(req, dict):
360                                             errors.append(
361                                                 "Requisite declaration {} in SLS {} "
362                                                 "is not formed as a single key "
363                                                 "dictionary".format(
364                                                     req, body["__sls__"]
365                                                 )
366                                             )
367                                             continue
368                                         req_key = next(iter(req))
369                                         req_val = req[req_key]
370                                         if "." in req_key:
371                                             errors.append(
372                                                 "Invalid requisite type '{}' "
373                                                 "in state '{}', in SLS "
374                                                 "'{}'. Requisite types must "
375                                                 "not contain dots, did you "
376                                                 "mean '{}'?".format(
377                                                     req_key,
378                                                     name,
379                                                     body["__sls__"],
380                                                     req_key[: req_key.find(".")],
381                                                 )
382                                             )
383                                         if not ishashable(req_val):
384                                             errors.append(
385                                                 'Illegal requisite "{}", is SLS {}\n'.format(
386                                                     str(req_val),
387                                                     body["__sls__"],
388                                                 )
389                                             )
390                                             continue
391                                         reqs[name][req_val] = req_key
392                                         if req_val in reqs:
393                                             if name in reqs[req_val]:
394                                                 if reqs[req_val][name] == state:
395                                                     if (
396                                                         reqs[req_val]["state"]
397                                                         == reqs[name][req_val]
398                                                     ):
399                                                         errors.append(
400                                                             "A recursive requisite was"
401                                                             ' found, SLS "{}" ID "{}"'
402                                                             ' ID "{}"'.format(
403                                                                 body["__sls__"],
404                                                                 name,
405                                                                 req_val,
406                                                             )
407                                                         )
408                                 if len(list(arg)) != 1:
409                                     errors.append(
410                                         "Multiple dictionaries defined in argument "
411                                         "of state '{}' in SLS '{}'".format(
412                                             name, body["__sls__"]
413                                         )
414                                     )
415                     if not fun:
416                         if state == "require" or state == "watch":
417                             continue
418                         errors.append(
419                             "No function declared in state '{}' in SLS '{}'".format(
420                                 state, body["__sls__"]
421                             )
422                         )
423                     elif fun &gt; 1:
424                         errors.append(
425                             "Too many functions declared in state '{}' in "
426                             "SLS '{}'".format(state, body["__sls__"])
427                         )
428         return errors
429     def order_chunks(self, chunks):
430         cap = 1
431         for chunk in chunks:
432             if "order" in chunk:
433                 if not isinstance(chunk["order"], int):
434                     continue
435                 chunk_order = chunk["order"]
436                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
437                     cap = chunk_order + 100
438         for chunk in chunks:
439             if "order" not in chunk:
440                 chunk["order"] = cap
441                 continue
442             if not isinstance(chunk["order"], (int, float)):
443                 if chunk["order"] == "last":
444                     chunk["order"] = cap + 1000000
445                 elif chunk["order"] == "first":
446                     chunk["order"] = 0
447                 else:
448                     chunk["order"] = cap
449             if "name_order" in chunk:
450                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
451             if chunk["order"] &lt; 0:
452                 chunk["order"] = cap + 1000000 + chunk["order"]
453             chunk["name"] = salt.utils.data.decode(chunk["name"])
454         chunks.sort(
455             key=lambda chunk: (
456                 chunk["order"],
457                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
458             )
459         )
460         return chunks
461     def compile_high_data(self, high):
462         chunks = []
463         for name, body in high.items():
464             if name.startswith("__"):
465                 continue
466             for state, run in body.items():
467                 funcs = set()
468                 names = []
469                 if state.startswith("__"):
470                     continue
471                 chunk = {"state": state, "name": name}
472                 if "__sls__" in body:
473                     chunk["__sls__"] = body["__sls__"]
474                 if "__env__" in body:
475                     chunk["__env__"] = body["__env__"]
476                 chunk["__id__"] = name
477                 for arg in run:
478                     if isinstance(arg, str):
479                         funcs.add(arg)
480                         continue
481                     if isinstance(arg, dict):
482                         for key, val in arg.items():
483                             if key == "names":
484                                 for _name in val:
485                                     if _name not in names:
486                                         names.append(_name)
487                                 continue
488                             else:
489                                 chunk.update(arg)
490                 if names:
491                     name_order = 1
492                     for entry in names:
493                         live = copy.deepcopy(chunk)
494                         if isinstance(entry, dict):
495                             low_name = next(iter(entry.keys()))
496                             live["name"] = low_name
497                             list(map(live.update, entry[low_name]))
498                         else:
499                             live["name"] = entry
500                         live["name_order"] = name_order
501                         name_order = name_order + 1
502                         for fun in funcs:
503                             live["fun"] = fun
504                             chunks.append(live)
505                 else:
506                     live = copy.deepcopy(chunk)
507                     for fun in funcs:
508                         live["fun"] = fun
509                         chunks.append(live)
510         chunks = self.order_chunks(chunks)
511         return chunks
512     def apply_exclude(self, high):
513         if "__exclude__" not in high:
514             return high
515         ex_sls = set()
516         ex_id = set()
517         exclude = high.pop("__exclude__")
518         for exc in exclude:
519             if isinstance(exc, str):
520                 ex_sls.add(exc)
521             if isinstance(exc, dict):
522                 if len(exc) != 1:
523                     continue
524                 key = next(iter(exc.keys()))
525                 if key == "sls":
526                     ex_sls.add(exc["sls"])
527                 elif key == "id":
528                     ex_id.add(exc["id"])
529         if ex_sls:
530             for name, body in high.items():
531                 if name.startswith("__"):
532                     continue
533                 if body.get("__sls__", "") in ex_sls:
534                     ex_id.add(name)
535         for id_ in ex_id:
536             if id_ in high:
537                 high.pop(id_)
538         return high
539 class State:
540     def __init__(
541         self,
542         opts,
543         pillar_override=None,
544         jid=None,
545         pillar_enc=None,
546         proxy=None,
547         context=None,
548         mocked=False,
549         loader="states",
550         initial_pillar=None,
551     ):
552         self.states_loader = loader
553         if "grains" not in opts:
554             opts["grains"] = salt.loader.grains(opts)
555         self.opts = opts
556         self.proxy = proxy
557         self._pillar_override = pillar_override
558         if pillar_enc is not None:
559             try:
560                 pillar_enc = pillar_enc.lower()
561             except AttributeError:
562                 pillar_enc = str(pillar_enc).lower()
563         self._pillar_enc = pillar_enc
564         log.debug("Gathering pillar data for state run")
565         if initial_pillar and not self._pillar_override:
566             self.opts["pillar"] = initial_pillar
567         else:
568             self.opts["pillar"] = self._gather_pillar()
569             if self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._pillar_override:
570                 self.opts["pillar"] = salt.utils.dictupdate.merge(
571                     self.opts["pillar"],
572                     self._pillar_override,
573                     self.opts.get("pillar_source_merging_strategy", "smart"),
574                     self.</b></font>opts.get("renderer", "yaml"),
575                     self.opts.get("pillar_merge_lists", False),
576                 )
577         log.debug("Finished gathering pillar data for state run")
578         self.state_con = context or {}
579         self.load_modules()
580         self.active = set()
581         self.mod_init = set()
582         self.pre = {}
583         self.__run_num = 0
584         self.jid = jid
585         self.instance_id = str(id(self))
586         self.inject_globals = {}
587         self.mocked = mocked
588     def _gather_pillar(self):
589         if self._pillar_override:
590             if self._pillar_enc:
591                 try:
592                     self._pillar_override = salt.utils.crypt.decrypt(
593                         self._pillar_override,
594                         self._pillar_enc,
595                         translate_newlines=True,
596                         renderers=getattr(self, "rend", None),
597                         opts=self.opts,
598                         valid_rend=self.opts["decrypt_pillar_renderers"],
599                     )
600                 except Exception as exc:  # pylint: disable=broad-except
601                     log.error("Failed to decrypt pillar override: %s", exc)
602             if isinstance(self._pillar_override, str):
603                 try:
604                     self._pillar_override = yamlloader.load(
605                         self._pillar_override, Loader=yamlloader.SaltYamlSafeLoader
606                     )
607                 except Exception as exc:  # pylint: disable=broad-except
608                     log.error("Failed to load CLI pillar override")
609                     log.exception(exc)
610             if not isinstance(self._pillar_override, dict):
611                 log.error("Pillar override was not passed as a dictionary")
612                 self._pillar_override = None
613         pillar = salt.pillar.get_pillar(
614             self.opts,
615             self.opts["grains"],
616             self.opts["id"],
617             self.opts["saltenv"],
618             pillar_override=self._pillar_override,
619             pillarenv=self.opts.get("pillarenv"),
620         )
621         return pillar.compile_pillar()
622     def _mod_init(self, low):
623         try:
624             self.states[
625                 "{}.{}".format(low["state"], low["fun"])
626             ]  # pylint: disable=W0106
627         except KeyError:
628             return
629         minit = "{}.mod_init".format(low["state"])
630         if low["state"] not in self.mod_init:
631             if minit in self.states._dict:
632                 mret = self.states[minit](low)
633                 if not mret:
634                     return
635                 self.mod_init.add(low["state"])
636     def _aggregate_requisites(self, low, chunks):
637         requisites = {}
638         low_state = low["state"]
639         for chunk in chunks:
640             if chunk["state"] == low["state"] and chunk.get("__agg__"):
641                 for req in frozenset.union(
642                     *[STATE_REQUISITE_KEYWORDS, STATE_REQUISITE_IN_KEYWORDS]
643                 ):
644                     if req in chunk:
645                         if req in requisites:
646                             requisites[req].extend(chunk[req])
647                         else:
648                             requisites[req] = chunk[req]
649         low.update(requisites)
650         return low
651     def _mod_aggregate(self, low, running, chunks):
652         agg_opt = self.functions["config.option"]("state_aggregate")
653         if "aggregate" in low:
654             agg_opt = low["aggregate"]
655         if agg_opt is True:
656             agg_opt = [low["state"]]
657         elif not isinstance(agg_opt, list):
658             return low
659         if low["state"] in agg_opt and not low.get("__agg__"):
660             agg_fun = "{}.mod_aggregate".format(low["state"])
661             if agg_fun in self.states:
662                 try:
663                     low = self.states[agg_fun](low, chunks, running)
664                     low = self._aggregate_requisites(low, chunks)
665                     low["__agg__"] = True
666                 except TypeError:
667                     log.error("Failed to execute aggregate for state %s", low["state"])
668         return low
669     def _run_check(self, low_data):
670         ret = {"result": False, "comment": []}
671         cmd_opts = {}
672         POSSIBLE_CMD_ARGS = (
673             "cwd",
674             "root",
675             "runas",
676             "env",
677             "prepend_path",
678             "umask",
679             "timeout",
680             "success_retcodes",
681         )
682         for run_cmd_arg in POSSIBLE_CMD_ARGS:
683             cmd_opts[run_cmd_arg] = low_data.get(run_cmd_arg)
684         if "shell" in low_data:
685             cmd_opts["shell"] = low_data["shell"]
686         elif "shell" in self.opts["grains"]:
687             cmd_opts["shell"] = self.opts["grains"].get("shell")
688         if "onlyif" in low_data:
689             _ret = self._run_check_onlyif(low_data, cmd_opts)
690             ret["result"] = _ret["result"]
691             ret["comment"].append(_ret["comment"])
692             if "skip_watch" in _ret:
693                 ret["skip_watch"] = _ret["skip_watch"]
694         if "unless" in low_data:
695             _ret = self._run_check_unless(low_data, cmd_opts)
696             ret["result"] = _ret["result"] or ret["result"]
697             ret["comment"].append(_ret["comment"])
698             if "skip_watch" in _ret:
699                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
700         if "creates" in low_data:
701             _ret = self._run_check_creates(low_data)
702             ret["result"] = _ret["result"] or ret["result"]
703             ret["comment"].append(_ret["comment"])
704             if "skip_watch" in _ret:
705                 ret["skip_watch"] = _ret["skip_watch"] or ret["skip_watch"]
706         return ret
707     def _run_check_function(self, entry):
708         fun = entry.pop("fun")
709         args = entry.pop("args") if "args" in entry else []
710         cdata = {"args": args, "kwargs": entry}
711         self.format_slots(cdata)
712         return self.functions[fun](*cdata["args"], **cdata["kwargs"])
713     def _run_check_onlyif(self, low_data, cmd_opts):
714         ret = {"result": False}
715         if not isinstance(low_data["onlyif"], list):
716             low_data_onlyif = [low_data["onlyif"]]
717         else:
718             low_data_onlyif = low_data["onlyif"]
719         def _check_cmd(cmd):
720             if cmd != 0 and ret["result"] is False:
721                 ret.update(
722                     {
723                         "comment": "onlyif condition is false",
724                         "skip_watch": True,
725                         "result": True,
726                     }
727                 )
728                 return False
729             elif cmd == 0:
730                 ret.update({"comment": "onlyif condition is true", "result": False})
731             return True
732         for entry in low_data_onlyif:
733             if isinstance(entry, str):
734                 try:
735                     cmd = self.functions["cmd.retcode"](
736                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
737                     )
738                 except CommandExecutionError:
739                     cmd = 100
740                 log.debug("Last command return code: %s", cmd)
741                 if not _check_cmd(cmd):
742                     return ret
743             elif isinstance(entry, dict):
744                 if "fun" not in entry:
745                     ret["comment"] = "no `fun` argument in onlyif: {}".format(entry)
746                     log.warning(ret["comment"])
747                     return ret
748                 get_return = entry.pop("get_return", None)
749                 result = self._run_check_function(entry)
750                 if get_return:
751                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
752                 if self.state_con.get("retcode", 0):
753                     if not _check_cmd(self.state_con["retcode"]):
754                         return ret
755                 elif not result:
756                     ret.update(
757                         {
758                             "comment": "onlyif condition is false",
759                             "skip_watch": True,
760                             "result": True,
761                         }
762                     )
763                     return ret
764                 else:
765                     ret.update({"comment": "onlyif condition is true", "result": False})
766             else:
767                 ret.update(
768                     {
769                         "comment": "onlyif execution failed, bad type passed",
770                         "result": False,
771                     }
772                 )
773                 return ret
774         return ret
775     def _run_check_unless(self, low_data, cmd_opts):
776         ret = {"result": False}
777         if not isinstance(low_data["unless"], list):
778             low_data_unless = [low_data["unless"]]
779         else:
780             low_data_unless = low_data["unless"]
781         def _check_cmd(cmd):
782             if cmd == 0:
783                 ret.update(
784                     {
785                         "comment": "unless condition is true",
786                         "skip_watch": True,
787                         "result": True,
788                     }
789                 )
790                 return False
791             else:
792                 ret.pop("skip_watch", None)
793                 ret.update({"comment": "unless condition is false", "result": False})
794                 return True
795         for entry in low_data_unless:
796             if isinstance(entry, str):
797                 try:
798                     cmd = self.functions["cmd.retcode"](
799                         entry, ignore_retcode=True, python_shell=True, **cmd_opts
800                     )
801                     log.debug("Last command return code: %s", cmd)
802                 except CommandExecutionError:
803                     cmd = 0
804                 if _check_cmd(cmd):
805                     return ret
806             elif isinstance(entry, dict):
807                 if "fun" not in entry:
808                     ret["comment"] = "no `fun` argument in unless: {}".format(entry)
809                     log.warning(ret["comment"])
810                     return ret
811                 get_return = entry.pop("get_return", None)
812                 result = self._run_check_function(entry)
813                 if get_return:
814                     result = salt.utils.data.traverse_dict_and_list(result, get_return)
815                 if self.state_con.get("retcode", 0):
816                     if _check_cmd(self.state_con["retcode"]):
817                         return ret
818                 elif result:
819                     ret.update(
820                         {
821                             "comment": "unless condition is true",
822                             "skip_watch": True,
823                             "result": True,
824                         }
825                     )
826                 else:
827                     ret.update(
828                         {"comment": "unless condition is false", "result": False}
829                     )
830                     return ret
831             else:
832                 ret.update(
833                     {
834                         "comment": "unless condition is false, bad type passed",
835                         "result": False,
836                     }
837                 )
838         return ret
839     def _run_check_cmd(self, low_data):
840         ret = {"result": False}
841         cmd_opts = {}
842         if "shell" in self.opts["grains"]:
843             cmd_opts["shell"] = self.opts["grains"].get("shell")
844         for entry in low_data["check_cmd"]:
845             cmd = self.functions["cmd.retcode"](
846                 entry, ignore_retcode=True, python_shell=True, **cmd_opts
847             )
848             log.debug("Last command return code: %s", cmd)
849             if cmd == 0 and ret["result"] is False:
850                 ret.update(
851                     {
852                         "comment": "check_cmd determined the state succeeded",
853                         "result": True,
854                     }
855                 )
856             elif cmd != 0:
857                 ret.update(
858                     {
859                         "comment": "check_cmd determined the state failed",
860                         "result": False,
861                     }
862                 )
863                 return ret
864         return ret
865     def _run_check_creates(self, low_data):
866         ret = {"result": False}
867         if isinstance(low_data["creates"], str) and os.path.exists(low_data["creates"]):
868             ret["comment"] = "{} exists".format(low_data["creates"])
869             ret["result"] = True
870             ret["skip_watch"] = True
871         elif isinstance(low_data["creates"], list) and all(
872             [os.path.exists(path) for path in low_data["creates"]]
873         ):
874             ret["comment"] = "All files in creates exist"
875             ret["result"] = True
876             ret["skip_watch"] = True
877         else:
878             ret["comment"] = "Creates files not found"
879             ret["result"] = False
880         return ret
881     def reset_run_num(self):
882         self.__run_num = 0
883     def _load_states(self):
884         if self.states_loader == "thorium":
885             self.states = salt.loader.thorium(
886                 self.opts, self.functions, {}
887             )  # TODO: Add runners, proxy?
888         else:
889             self.states = salt.loader.states(
890                 self.opts,
891                 self.functions,
892                 self.utils,
893                 self.serializers,
894                 context=self.state_con,
895                 proxy=self.proxy,
896             )
897     def load_modules(self, data=None, proxy=None):
898         log.info("Loading fresh modules for state activity")
899         self.utils = salt.loader.utils(self.opts)
900         self.functions = salt.loader.minion_mods(
901             self.opts, self.state_con, utils=self.utils, proxy=self.proxy
902         )
903         if isinstance(data, dict):
904             if data.get("provider", False):
905                 if isinstance(data["provider"], str):
906                     providers = [{data["state"]: data["provider"]}]
907                 elif isinstance(data["provider"], list):
908                     providers = data["provider"]
909                 else:
910                     providers = {}
911                 for provider in providers:
912                     for mod in provider:
913                         funcs = salt.loader.raw_mod(
914                             self.opts, provider[mod], self.functions
915                         )
916                         if funcs:
917                             for func in funcs:
918                                 f_key = "{}{}".format(mod, func[func.rindex(".") :])
919                                 self.functions[f_key] = funcs[func]
920         self.serializers = salt.loader.serializers(self.opts)
921         self._load_states()
922         self.rend = salt.loader.render(
923             self.opts,
924             self.functions,
925             states=self.states,
926             proxy=self.proxy,
927             context=self.state_con,
928         )
929     def module_refresh(self):
930         log.debug("Refreshing modules...")
931         if self.opts["grains"].get("os") != "MacOS":
932             try:
933                 importlib.reload(site)
934             except RuntimeError:
935                 log.error(
936                     "Error encountered during module reload. Modules were not reloaded."
937                 )
938             except TypeError:
939                 log.error(
940                     "Error encountered during module reload. Modules were not reloaded."
941                 )
942         self.load_modules()
943         if not self.opts.get("local", False) and self.opts.get("multiprocessing", True):
944             self.functions["saltutil.refresh_modules"]()
945     def check_refresh(self, data, ret):
946         _reload_modules = False
947         if data.get("reload_grains", False):
948             log.debug("Refreshing grains...")
949             self.opts["grains"] = salt.loader.grains(self.opts)
950             _reload_modules = True
951         if data.get("reload_pillar", False):
952             log.debug("Refreshing pillar...")
953             self.opts["pillar"] = self._gather_pillar()
954             _reload_modules = True
955         if not ret["changes"]:
956             if data.get("force_reload_modules", False):
957                 self.module_refresh()
958             return
959         if data.get("reload_modules", False) or _reload_modules:
960             self.module_refresh()
961             return
962         if data["state"] == "file":
963             if data["fun"] == "managed":
964                 if data["name"].endswith((".py", ".pyx", ".pyo", ".pyc", ".so")):
965                     self.module_refresh()
966             elif data["fun"] == "recurse":
967                 self.module_refresh()
968             elif data["fun"] == "symlink":
969                 if "bin" in data["name"]:
970                     self.module_refresh()
971         elif data["state"] in ("pkg", "ports", "pip"):
972             self.module_refresh()
973     def verify_data(self, data):
974         errors = []
975         if "state" not in data:
976             errors.append('Missing "state" data')
977         if "fun" not in data:
978             errors.append('Missing "fun" data')
979         if "name" not in data:
980             errors.append('Missing "name" data')
981         if data["name"] and not isinstance(data["name"], str):
982             errors.append(
983                 "ID '{}' {}is not formed as a string, but is a {}".format(
984                     data["name"],
985                     "in SLS '{}' ".format(data["__sls__"]) if "__sls__" in data else "",
986                     type(data["name"]).__name__,
987                 )
988             )
989         if errors:
990             return errors
991         full = data["state"] + "." + data["fun"]
992         if full not in self.states:
993             if "__sls__" in data:
994                 errors.append(
995                     "State '{}' was not found in SLS '{}'".format(full, data["__sls__"])
996                 )
997                 reason = self.states.missing_fun_string(full)
998                 if reason:
999                     errors.append("Reason: {}".format(reason))
1000             else:
1001                 errors.append("Specified state '{}' was not found".format(full))
1002         else:
1003             aspec = salt.utils.args.get_function_argspec(self.states[full])
1004             arglen = 0
1005             deflen = 0
1006             if isinstance(aspec.args, list):
1007                 arglen = len(aspec.args)
1008             if isinstance(aspec.defaults, tuple):
1009                 deflen = len(aspec.defaults)
1010             for ind in range(arglen - deflen):
1011                 if aspec.args[ind] not in data:
1012                     errors.append(
1013                         "Missing parameter {} for state {}".format(
1014                             aspec.args[ind], full
1015                         )
1016                     )
1017         reqdec = ""
1018         if "require" in data:
1019             reqdec = "require"
1020         if "watch" in data:
1021             if "{}.mod_watch".format(data["state"]) not in self.states:
1022                 if "require" in data:
1023                     data["require"].extend(data.pop("watch"))
1024                 else:
1025                     data["require"] = data.pop("watch")
1026                 reqdec = "require"
1027             else:
1028                 reqdec = "watch"
1029         if reqdec:
1030             for req in data[reqdec]:
1031                 reqfirst = next(iter(req))
1032                 if data["state"] == reqfirst:
1033                     if fnmatch.fnmatch(data["name"], req[reqfirst]) or fnmatch.fnmatch(
1034                         data["__id__"], req[reqfirst]
1035                     ):
1036                         errors.append(
1037                             "Recursive require detected in SLS {} for "
1038                             "require {} in ID {}".format(
1039                                 data["__sls__"], req, data["__id__"]
1040                             )
1041                         )
1042         return errors
1043     def verify_high(self, high):
1044         errors = []
1045         if not isinstance(high, dict):
1046             errors.append("High data is not a dictionary and is invalid")
1047         reqs = OrderedDict()
1048         for name, body in high.items():
1049             try:
1050                 if name.startswith("__"):
1051                     continue
1052             except AttributeError:
1053                 pass
1054             if not isinstance(name, str):
1055                 errors.append(
1056                     "ID '{}' in SLS '{}' is not formed as a string, but "
1057                     "is a {}. It may need to be quoted.".format(
1058                         name, body["__sls__"], type(name).__name__
1059                     )
1060                 )
1061             if not isinstance(body, dict):
1062                 err = "The type {} in {} is not formatted as a dictionary".format(
1063                     name, body
1064                 )
1065                 errors.append(err)
1066                 continue
1067             for state in body:
1068                 if state.startswith("__"):
1069                     continue
1070                 if body[state] is None:
1071                     errors.append(
1072                         "ID '{}' in SLS '{}' contains a short declaration "
1073                         "({}) with a trailing colon. When not passing any "
1074                         "arguments to a state, the colon must be omitted.".format(
1075                             name, body["__sls__"], state
1076                         )
1077                     )
1078                     continue
1079                 if not isinstance(body[state], list):
1080                     errors.append(
1081                         "State '{}' in SLS '{}' is not formed as a list".format(
1082                             name, body["__sls__"]
1083                         )
1084                     )
1085                 else:
1086                     fun = 0
1087                     if "." in state:
1088                         fun += 1
1089                     for arg in body[state]:
1090                         if isinstance(arg, str):
1091                             fun += 1
1092                             if " " in arg.strip():
1093                                 errors.append(
1094                                     'The function "{}" in state "{}" in SLS "{}" has '
1095                                     "whitespace, a function with whitespace is not "
1096                                     "supported, perhaps this is an argument that is "
1097                                     'missing a ":"'.format(arg, name, body["__sls__"])
1098                                 )
1099                         elif isinstance(arg, dict):
1100                             argfirst = next(iter(arg))
1101                             if argfirst == "names":
1102                                 if not isinstance(arg[argfirst], list):
1103                                     errors.append(
1104                                         "The 'names' argument in state "
1105                                         "'{}' in SLS '{}' needs to be "
1106                                         "formed as a list".format(name, body["__sls__"])
1107                                     )
1108                             if argfirst in ("require", "watch", "prereq", "onchanges"):
1109                                 if not isinstance(arg[argfirst], list):
1110                                     errors.append(
1111                                         "The {} statement in state '{}' in "
1112                                         "SLS '{}' needs to be formed as a "
1113                                         "list".format(argfirst, name, body["__sls__"])
1114                                     )
1115                                 else:
1116                                     reqs[name] = OrderedDict(state=state)
1117                                     for req in arg[argfirst]:
1118                                         if isinstance(req, str):
1119                                             req = {"id": req}
1120                                         if not isinstance(req, dict):
1121                                             errors.append(
1122                                                 "Requisite declaration {} in SLS {} is"
1123                                                 " not formed as a single key dictionary".format(
1124                                                     req, body["__sls__"]
1125                                                 )
1126                                             )
1127                                             continue
1128                                         req_key = next(iter(req))
1129                                         req_val = req[req_key]
1130                                         if "." in req_key:
1131                                             errors.append(
1132                                                 "Invalid requisite type '{}' "
1133                                                 "in state '{}', in SLS "
1134                                                 "'{}'. Requisite types must "
1135                                                 "not contain dots, did you "
1136                                                 "mean '{}'?".format(
1137                                                     req_key,
1138                                                     name,
1139                                                     body["__sls__"],
1140                                                     req_key[: req_key.find(".")],
1141                                                 )
1142                                             )
1143                                         if not ishashable(req_val):
1144                                             errors.append(
1145                                                 'Illegal requisite "{}", please check '
1146                                                 "your syntax.\n".format(req_val)
1147                                             )
1148                                             continue
1149                                         reqs[name][req_val] = req_key
1150                                         if req_val in reqs:
1151                                             if name in reqs[req_val]:
1152                                                 if reqs[req_val][name] == state:
1153                                                     if (
1154                                                         reqs[req_val]["state"]
1155                                                         == reqs[name][req_val]
1156                                                     ):
1157                                                         errors.append(
1158                                                             "A recursive requisite was"
1159                                                             ' found, SLS "{}" ID "{}"'
1160                                                             ' ID "{}"'.format(
1161                                                                 body["__sls__"],
1162                                                                 name,
1163                                                                 req_val,
1164                                                             )
1165                                                         )
1166                                 if len(list(arg)) != 1:
1167                                     errors.append(
1168                                         "Multiple dictionaries defined in "
1169                                         "argument of state '{}' in SLS '{}'".format(
1170                                             name, body["__sls__"]
1171                                         )
1172                                     )
1173                     if not fun:
1174                         if state == "require" or state == "watch":
1175                             continue
1176                         errors.append(
1177                             "No function declared in state '{}' in SLS '{}'".format(
1178                                 state, body["__sls__"]
1179                             )
1180                         )
1181                     elif fun &gt; 1:
1182                         errors.append(
1183                             "Too many functions declared in state '{}' in "
1184                             "SLS '{}'".format(state, body["__sls__"])
1185                         )
1186         return errors
1187     def verify_chunks(self, chunks):
1188         err = []
1189         for chunk in chunks:
1190             err.extend(self.verify_data(chunk))
1191         return err
1192     def order_chunks(self, chunks):
1193         cap = 1
1194         for chunk in chunks:
1195             if "order" in chunk:
1196                 if not isinstance(chunk["order"], int):
1197                     continue
1198                 chunk_order = chunk["order"]
1199                 if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
1200                     cap = chunk_order + 100
1201         for chunk in chunks:
1202             if "order" not in chunk:
1203                 chunk["order"] = cap
1204                 continue
1205             if not isinstance(chunk["order"], (int, float)):
1206                 if chunk["order"] == "last":
1207                     chunk["order"] = cap + 1000000
1208                 elif chunk["order"] == "first":
1209                     chunk["order"] = 0
1210                 else:
1211                     chunk["order"] = cap
1212             if "name_order" in chunk:
1213                 chunk["order"] = chunk["order"] + chunk.pop("name_order") / 10000.0
1214             if chunk["order"] &lt; 0:
1215                 chunk["order"] = cap + 1000000 + chunk["order"]
1216         chunks.sort(
1217             key=lambda chunk: (
1218                 chunk["order"],
1219                 "{0[state]}{0[name]}{0[fun]}".format(chunk),
1220             )
1221         )
1222         return chunks
1223     def compile_high_data(self, high, orchestration_jid=None):
1224         chunks = []
1225         for name, body in high.items():
1226             if name.startswith("__"):
1227                 continue
1228             for state, run in body.items():
1229                 funcs = set()
1230                 names = []
1231                 if state.startswith("__"):
1232                     continue
1233                 chunk = {"state": state, "name": name}
1234                 if orchestration_jid is not None:
1235                     chunk["__orchestration_jid__"] = orchestration_jid
1236                 if "__sls__" in body:
1237                     chunk["__sls__"] = body["__sls__"]
1238                 if "__env__" in body:
1239                     chunk["__env__"] = body["__env__"]
1240                 chunk["__id__"] = name
1241                 for arg in run:
1242                     if isinstance(arg, str):
1243                         funcs.add(arg)
1244                         continue
1245                     if isinstance(arg, dict):
1246                         for key, val in arg.items():
1247                             if key == "names":
1248                                 for _name in val:
1249                                     if _name not in names:
1250                                         names.append(_name)
1251                             elif key == "state":
1252                                 continue
1253                             elif key == "name" and not isinstance(val, str):
1254                                 chunk[key] = name
1255                             else:
1256                                 chunk[key] = val
1257                 if names:
1258                     name_order = 1
1259                     for entry in names:
1260                         live = copy.deepcopy(chunk)
1261                         if isinstance(entry, dict):
1262                             low_name = next(iter(entry.keys()))
1263                             live["name"] = low_name
1264                             list(map(live.update, entry[low_name]))
1265                         else:
1266                             live["name"] = entry
1267                         live["name_order"] = name_order
1268                         name_order += 1
1269                         for fun in funcs:
1270                             live["fun"] = fun
1271                             chunks.append(live)
1272                 else:
1273                     live = copy.deepcopy(chunk)
1274                     for fun in funcs:
1275                         live["fun"] = fun
1276                         chunks.append(live)
1277         chunks = self.order_chunks(chunks)
1278         return chunks
1279     def reconcile_extend(self, high, strict=False):
1280         errors = []
1281         if "__extend__" not in high:
1282             return high, errors
1283         ext = high.pop("__extend__")
1284         for ext_chunk in ext:
1285             for name, body in ext_chunk.items():
1286                 state_type = next(x for x in body if not x.startswith("__"))
1287                 if name not in high or state_type not in high[name]:
1288                     ids = find_name(name, state_type, high, strict=strict)
1289                     if len(ids) != 1:
1290                         errors.append(
1291                             "Cannot extend ID '{0}' in '{1}:{2}'. It is not "
1292                             "part of the high state.\n"
1293                             "This is likely due to a missing include statement "
1294                             "or an incorrectly typed ID.\nEnsure that a "
1295                             "state with an ID of '{0}' is available\nin "
1296                             "environment '{1}' and to SLS '{2}'".format(
1297                                 name,
1298                                 body.get("__env__", "base"),
1299                                 body.get("__sls__", "base"),
1300                             )
1301                         )
1302                         continue
1303                     else:
1304                         name = ids[0][0]
1305                 for state, run in body.items():
1306                     if state.startswith("__"):
1307                         continue
1308                     if state not in high[name]:
1309                         high[name][state] = run
1310                         continue
1311                     for arg in run:
1312                         update = False
1313                         for hind, val in enumerate(high[name][state]):
1314                             if isinstance(arg, str) and isinstance(val, str):
1315                                 high[name][state].pop(hind)
1316                                 high[name][state].insert(hind, arg)
1317                                 update = True
1318                                 continue
1319                             if isinstance(arg, dict) and isinstance(val, dict):
1320                                 argfirst = next(iter(arg))
1321                                 if argfirst == next(iter(high[name][state][hind])):
1322                                     if argfirst in STATE_REQUISITE_KEYWORDS:
1323                                         high[name][state][hind][argfirst].extend(
1324                                             arg[argfirst]
1325                                         )
1326                                     else:
1327                                         high[name][state][hind] = arg
1328                                     update = True
1329                                 if (
1330                                     argfirst == "name"
1331                                     and next(iter(high[name][state][hind])) == "names"
1332                                 ):
1333                                     high[name][state][hind] = arg
1334                         if not update:
1335                             high[name][state].append(arg)
1336         return high, errors
1337     def apply_exclude(self, high):
1338         if "__exclude__" not in high:
1339             return high
1340         ex_sls = set()
1341         ex_id = set()
1342         exclude = high.pop("__exclude__")
1343         for exc in exclude:
1344             if isinstance(exc, str):
1345                 ex_sls.add(exc)
1346             if isinstance(exc, dict):
1347                 if len(exc) != 1:
1348                     continue
1349                 key = next(iter(exc.keys()))
1350                 if key == "sls":
1351                     ex_sls.add(exc["sls"])
1352                 elif key == "id":
1353                     ex_id.add(exc["id"])
1354         if ex_sls:
1355             for name, body in high.items():
1356                 if name.startswith("__"):
1357                     continue
1358                 sls = body.get("__sls__", "")
1359                 if not sls:
1360                     continue
1361                 for ex_ in ex_sls:
1362                     if fnmatch.fnmatch(sls, ex_):
1363                         ex_id.add(name)
1364         for id_ in ex_id:
1365             if id_ in high:
1366                 high.pop(id_)
1367         return high
1368     def requisite_in(self, high):
1369         req_in = {
1370             "require_in",
1371             "watch_in",
1372             "onfail_in",
1373             "onchanges_in",
1374             "use",
1375             "use_in",
1376             "prereq",
1377             "prereq_in",
1378         }
1379         req_in_all = req_in.union(
1380             {"require", "watch", "onfail", "onfail_stop", "onchanges"}
1381         )
1382         extend = {}
1383         errors = []
1384         disabled_reqs = self.opts.get("disabled_requisites", [])
1385         if not isinstance(disabled_reqs, list):
1386             disabled_reqs = [disabled_reqs]
1387         for id_, body in high.items():
1388             if not isinstance(body, dict):
1389                 continue
1390             for state, run in body.items():
1391                 if state.startswith("__"):
1392                     continue
1393                 for arg in run:
1394                     if isinstance(arg, dict):
1395                         if len(arg) &lt; 1:
1396                             continue
1397                         key = next(iter(arg))
1398                         if key not in req_in:
1399                             continue
1400                         if key in disabled_reqs:
1401                             log.warning(
1402                                 "The %s requisite has been disabled, Ignoring.", key
1403                             )
1404                             continue
1405                         rkey = key.split("_")[0]
1406                         items = arg[key]
1407                         if isinstance(items, dict):
1408                             for _state, name in items.items():
1409                                 found = False
1410                                 if name not in extend:
1411                                     extend[name] = OrderedDict()
1412                                 if "." in _state:
1413                                     errors.append(
1414                                         "Invalid requisite in {}: {} for "
1415                                         "{}, in SLS '{}'. Requisites must "
1416                                         "not contain dots, did you mean '{}'?".format(
1417                                             rkey,
1418                                             _state,
1419                                             name,
1420                                             body["__sls__"],
1421                                             _state[: _state.find(".")],
1422                                         )
1423                                     )
1424                                     _state = _state.split(".")[0]
1425                                 if _state not in extend[name]:
1426                                     extend[name][_state] = []
1427                                 extend[name]["__env__"] = body["__env__"]
1428                                 extend[name]["__sls__"] = body["__sls__"]
1429                                 for ind in range(len(extend[name][_state])):
1430                                     if next(iter(extend[name][_state][ind])) == rkey:
1431                                         extend[name][_state][ind][rkey].append(
1432                                             {state: id_}
1433                                         )
1434                                         found = True
1435                                 if found:
1436                                     continue
1437                                 extend[name][_state].append({rkey: [{state: id_}]})
1438                         if isinstance(items, list):
1439                             hinges = []
1440                             for ind in items:
1441                                 if not isinstance(ind, dict):
1442                                     if ind in high:
1443                                         _ind_high = [
1444                                             x
1445                                             for x in high[ind]
1446                                             if not x.startswith("__")
1447                                         ]
1448                                         ind = {_ind_high[0]: ind}
1449                                     else:
1450                                         found = False
1451                                         for _id in iter(high):
1452                                             for state in [
1453                                                 state
1454                                                 for state in iter(high[_id])
1455                                                 if not state.startswith("__")
1456                                             ]:
1457                                                 for j in iter(high[_id][state]):
1458                                                     if (
1459                                                         isinstance(j, dict)
1460                                                         and "name" in j
1461                                                     ):
1462                                                         if j["name"] == ind:
1463                                                             ind = {state: _id}
1464                                                             found = True
1465                                         if not found:
1466                                             continue
1467                                 if len(ind) &lt; 1:
1468                                     continue
1469                                 pstate = next(iter(ind))
1470                                 pname = ind[pstate]
1471                                 if pstate == "sls":
1472                                     hinges = find_sls_ids(pname, high)
1473                                 else:
1474                                     hinges.append((pname, pstate))
1475                                 if "." in pstate:
1476                                     errors.append(
1477                                         "Invalid requisite in {}: {} for "
1478                                         "{}, in SLS '{}'. Requisites must "
1479                                         "not contain dots, did you mean '{}'?".format(
1480                                             rkey,
1481                                             pstate,
1482                                             pname,
1483                                             body["__sls__"],
1484                                             pstate[: pstate.find(".")],
1485                                         )
1486                                     )
1487                                     pstate = pstate.split(".")[0]
1488                                 for tup in hinges:
1489                                     name, _state = tup
1490                                     if key == "prereq_in":
1491                                         if id_ not in extend:
1492                                             extend[id_] = OrderedDict()
1493                                         if state not in extend[id_]:
1494                                             extend[id_][state] = []
1495                                         extend[id_][state].append(
1496                                             {"prerequired": [{_state: name}]}
1497                                         )
1498                                     if key == "prereq":
1499                                         ext_ids = find_name(
1500                                             name, _state, high, strict=True
1501                                         )
1502                                         for ext_id, _req_state in ext_ids:
1503                                             if ext_id not in extend:
1504                                                 extend[ext_id] = OrderedDict()
1505                                             if _req_state not in extend[ext_id]:
1506                                                 extend[ext_id][_req_state] = []
1507                                             extend[ext_id][_req_state].append(
1508                                                 {"prerequired": [{state: id_}]}
1509                                             )
1510                                         continue
1511                                     if key == "use_in":
1512                                         ext_ids = find_name(
1513                                             name, _state, high, strict=True
1514                                         )
1515                                         for ext_id, _req_state in ext_ids:
1516                                             if not ext_id:
1517                                                 continue
1518                                             ext_args = state_args(ext_id, _state, high)
1519                                             if ext_id not in extend:
1520                                                 extend[ext_id] = OrderedDict()
1521                                             if _req_state not in extend[ext_id]:
1522                                                 extend[ext_id][_req_state] = []
1523                                             ignore_args = req_in_all.union(ext_args)
1524                                             for arg in high[id_][state]:
1525                                                 if not isinstance(arg, dict):
1526                                                     continue
1527                                                 if len(arg) != 1:
1528                                                     continue
1529                                                 if next(iter(arg)) in ignore_args:
1530                                                     continue
1531                                                 if next(iter(arg.keys())) == "name":
1532                                                     continue
1533                                                 if next(iter(arg.keys())) == "names":
1534                                                     continue
1535                                                 extend[ext_id][_req_state].append(arg)
1536                                         continue
1537                                     if key == "use":
1538                                         ext_ids = find_name(
1539                                             name, _state, high, strict=True
1540                                         )
1541                                         for ext_id, _req_state in ext_ids:
1542                                             if not ext_id:
1543                                                 continue
1544                                             loc_args = state_args(id_, state, high)
1545                                             if id_ not in extend:
1546                                                 extend[id_] = OrderedDict()
1547                                             if state not in extend[id_]:
1548                                                 extend[id_][state] = []
1549                                             ignore_args = req_in_all.union(loc_args)
1550                                             for arg in high[ext_id][_req_state]:
1551                                                 if not isinstance(arg, dict):
1552                                                     continue
1553                                                 if len(arg) != 1:
1554                                                     continue
1555                                                 if next(iter(arg)) in ignore_args:
1556                                                     continue
1557                                                 if next(iter(arg.keys())) == "name":
1558                                                     continue
1559                                                 if next(iter(arg.keys())) == "names":
1560                                                     continue
1561                                                 extend[id_][state].append(arg)
1562                                         continue
1563                                     found = False
1564                                     if name not in extend:
1565                                         extend[name] = OrderedDict()
1566                                     if _state not in extend[name]:
1567                                         extend[name][_state] = []
1568                                     extend[name]["__env__"] = body["__env__"]
1569                                     extend[name]["__sls__"] = body["__sls__"]
1570                                     for ind in range(len(extend[name][_state])):
1571                                         if (
1572                                             next(iter(extend[name][_state][ind]))
1573                                             == rkey
1574                                         ):
1575                                             extend[name][_state][ind][rkey].append(
1576                                                 {state: id_}
1577                                             )
1578                                             found = True
1579                                     if found:
1580                                         continue
1581                                     extend[name][_state].append({rkey: [{state: id_}]})
1582         high["__extend__"] = []
1583         for key, val in extend.items():
1584             high["__extend__"].append({key: val})
1585         req_in_high, req_in_errors = self.reconcile_extend(high, strict=True)
1586         errors.extend(req_in_errors)
1587         return req_in_high, errors
1588     def _call_parallel_target(self, name, cdata, low):
1589         utc_start_time = datetime.datetime.utcnow()
1590 <a name="1"></a>
1591         self.format_slots(cdata)
1592         tag = _gen_tag(low)
1593         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>try:
1594             ret = self.states[cdata["full"]](*cdata["args"], **cdata["kwargs"])
1595         except Exception as exc:  # pylint: disable=broad-except
1596             log.debug(
1597                 "An exception occurred in this state: %s",
1598                 exc,
1599                 exc_info_on_loglevel=</b></font>logging.DEBUG,
1600             )
1601             trb = traceback.format_exc()
1602             ret = {
1603                 "result": False,
1604                 "name": name,
1605                 "changes": {},
1606                 "comment": "An exception occurred in this state: {}".format(trb),
1607             }
1608         utc_finish_time = datetime.datetime.utcnow()
1609         delta = utc_finish_time - utc_start_time
1610         duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
1611         ret["duration"] = duration
1612         troot = os.path.join(self.opts["cachedir"], self.jid)
1613         tfile = os.path.join(troot, salt.utils.hashutils.sha1_digest(tag))
1614         if not os.path.isdir(troot):
1615             try:
1616                 os.makedirs(troot)
1617             except OSError:
1618                 pass
1619         with salt.utils.files.fopen(tfile, "wb+") as fp_:
1620             fp_.write(msgpack_serialize(ret))
1621     def call_parallel(self, cdata, low):
1622         name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1623         if not name:
1624             name = low.get("name", low.get("__id__"))
1625         proc = salt.utils.process.Process(
1626             target=self._call_parallel_target,
1627             args=(name, cdata, low),
1628             name="ParallelState({})".format(name),
1629         )
1630         proc.start()
1631         ret = {
1632             "name": name,
1633             "result": None,
1634             "changes": {},
1635             "comment": "Started in a separate process",
1636             "proc": proc,
1637         }
1638         return ret
1639     @salt.utils.decorators.state.OutputUnifier("content_check", "unify")
1640     def call(self, low, chunks=None, running=None, retries=1):
1641         utc_start_time = datetime.datetime.utcnow()
1642         local_start_time = utc_start_time - (
1643             datetime.datetime.utcnow() - datetime.datetime.now()
1644         )
1645         log.info(
1646             "Running state [%s] at time %s",
1647             low["name"].strip() if isinstance(low["name"], str) else low["name"],
1648             local_start_time.time().isoformat(),
1649         )
1650         errors = self.verify_data(low)
1651         if errors:
1652             ret = {
1653                 "result": False,
1654                 "name": low["name"],
1655                 "changes": {},
1656                 "comment": "",
1657             }
1658             for err in errors:
1659                 ret["comment"] += "{}\n".format(err)
1660             ret["__run_num__"] = self.__run_num
1661             self.__run_num += 1
1662             format_log(ret)
1663             self.check_refresh(low, ret)
1664             return ret
1665         else:
1666             ret = {"result": False, "name": low["name"], "changes": {}}
1667         self.state_con["runas"] = low.get("runas", None)
1668         if low["state"] == "cmd" and "password" in low:
1669             self.state_con["runas_password"] = low["password"]
1670         else:
1671             self.state_con["runas_password"] = low.get("runas_password", None)
1672         if not low.get("__prereq__"):
1673             log.info(
1674                 "Executing state %s.%s for [%s]",
1675                 low["state"],
1676                 low["fun"],
1677                 low["name"].strip() if isinstance(low["name"], str) else low["name"],
1678             )
1679         if "provider" in low:
1680             self.load_modules(low)
1681         state_func_name = "{0[state]}.{0[fun]}".format(low)
1682         cdata = salt.utils.args.format_call(
1683             self.states[state_func_name],
1684             low,
1685             initial_ret={"full": state_func_name},
1686             expected_extra_kws=STATE_INTERNAL_KEYWORDS,
1687         )
1688         inject_globals = {
1689             "__low__": immutabletypes.freeze(low),
1690             "__running__": immutabletypes.freeze(running) if running else {},
1691             "__instance_id__": self.instance_id,
1692             "__lowstate__": immutabletypes.freeze(chunks) if chunks else {},
1693         }
1694         if "__env__" in low:
1695             inject_globals["__env__"] = str(low["__env__"])
1696         if self.inject_globals:
1697             inject_globals.update(self.inject_globals)
1698         if low.get("__prereq__"):
1699             test = sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]
1700             sys.modules[self.states[cdata["full"]].__module__].__opts__["test"] = True
1701         try:
1702             req_list = ("unless", "onlyif", "creates")
1703             if (
1704                 any(req in low for req in req_list)
1705                 and "{0[state]}.mod_run_check".format(low) not in self.states
1706             ):
1707                 ret.update(self._run_check(low))
1708             if not self.opts.get("lock_saltenv", False):
1709                 if "saltenv" in low:
1710                     inject_globals["__env__"] = str(low["saltenv"])
1711                 elif isinstance(cdata["kwargs"].get("env", None), str):
1712                     inject_globals["__env__"] = str(cdata["kwargs"]["env"])
1713             if "__env__" not in inject_globals:
1714                 inject_globals["__env__"] = "base"
1715             if "__orchestration_jid__" in low:
1716                 inject_globals["__orchestration_jid__"] = low["__orchestration_jid__"]
1717             if "result" not in ret or ret["result"] is False:
1718                 self.states.inject_globals = inject_globals
1719                 if self.mocked:
1720                     ret = mock_ret(cdata)
1721                 else:
1722                     if not low.get("__prereq__") and low.get("parallel"):
1723                         ret = self.call_parallel(cdata, low)
1724                     else:
1725                         self.format_slots(cdata)
1726                         ret = self.states[cdata["full"]](
1727                             *cdata["args"], **cdata["kwargs"]
1728                         )
1729                 self.states.inject_globals = {}
1730             if (
1731                 "check_cmd" in low
1732                 and "{0[state]}.mod_run_check_cmd".format(low) not in self.states
1733             ):
1734                 ret.update(self._run_check_cmd(low))
1735         except Exception as exc:  # pylint: disable=broad-except
1736             log.debug(
1737                 "An exception occurred in this state: %s",
1738                 exc,
1739                 exc_info_on_loglevel=logging.DEBUG,
1740             )
1741             trb = traceback.format_exc()
1742             name = (cdata.get("args") or [None])[0] or cdata["kwargs"].get("name")
1743             if not name:
1744                 name = low.get("name", low.get("__id__"))
1745             ret = {
1746                 "result": False,
1747                 "name": name,
1748                 "changes": {},
1749                 "comment": "An exception occurred in this state: {}".format(trb),
1750             }
1751         finally:
1752             if low.get("__prereq__"):
1753                 sys.modules[self.states[cdata["full"]].__module__].__opts__[
1754                     "test"
1755                 ] = test
1756             self.state_con.pop("runas", None)
1757             self.state_con.pop("runas_password", None)
1758         if not isinstance(ret, dict):
1759             return ret
1760         if "warnings" in cdata:
1761             ret.setdefault("warnings", []).extend(cdata["warnings"])
1762         if "provider" in low:
1763             self.load_modules()
1764         if low.get("__prereq__"):
1765             low["__prereq__"] = False
1766             return ret
1767         ret["__sls__"] = low.get("__sls__")
1768         ret["__run_num__"] = self.__run_num
1769         self.__run_num += 1
1770         format_log(ret)
1771         self.check_refresh(low, ret)
1772         utc_finish_time = datetime.datetime.utcnow()
1773         timezone_delta = datetime.datetime.utcnow() - datetime.datetime.now()
1774         local_finish_time = utc_finish_time - timezone_delta
1775         local_start_time = utc_start_time - timezone_delta
1776 <a name="4"></a>        ret["start_time"] = local_start_time.time().isoformat()
1777         delta = utc_finish_time - utc_start_time
1778         duration = (delta<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.seconds * 1000000 + delta.microseconds) / 1000.0
1779         ret["duration"] = duration
1780         ret["__id__"] = low["__id__"]
1781         log.info(
1782             "Completed state [%s] at time %s (duration_in_ms=%s)",
1783             low["name"].strip(</b></font>) if isinstance(low["name"], str) else low["name"],
1784             local_finish_time.time().isoformat(),
1785             duration,
1786         )
1787         if "retry" in low:
1788             low["retry"] = self.verify_retry_data(low["retry"])
1789             if not sys.modules[self.states[cdata["full"]].__module__].__opts__["test"]:
1790                 if low["retry"]["until"] != ret["result"]:
1791                     if low["retry"]["attempts"] &gt; retries:
1792                         interval = low["retry"]["interval"]
1793                         if low["retry"]["splay"] != 0:
1794                             interval = interval + random.randint(
1795                                 0, low["retry"]["splay"]
1796                             )
1797                         log.info(
1798                             "State result does not match retry until value, "
1799                             "state will be re-run in %s seconds",
1800                             interval,
1801                         )
1802                         self.functions["test.sleep"](interval)
1803                         retry_ret = self.call(low, chunks, running, retries=retries + 1)
1804                         orig_ret = ret
1805                         ret = retry_ret
1806                         ret["comment"] = "\n".join(
1807                             [
1808                                 'Attempt {}: Returned a result of "{}", '
1809                                 'with the following comment: "{}"'.format(
1810                                     retries, orig_ret["result"], orig_ret["comment"]
1811                                 ),
1812                                 "" if not ret["comment"] else ret["comment"],
1813                             ]
1814                         )
1815                         ret["duration"] = (
1816                             ret["duration"] + orig_ret["duration"] + (interval * 1000)
1817                         )
1818                         if retries == 1:
1819                             ret["start_time"] = orig_ret["start_time"]
1820             else:
1821                 ret["comment"] = "  ".join(
1822                     [
1823                         "" if not ret["comment"] else str(ret["comment"]),
1824                         "The state would be retried every {interval} seconds "
1825                         "(with a splay of up to {splay} seconds) a maximum of "
1826                         "{attempts} times or until a result of {until} "
1827                         "is returned".format(**low["retry"]),
1828                     ]
1829                 )
1830         return ret
1831     def __eval_slot(self, slot):
1832         log.debug("Evaluating slot: %s", slot)
1833         fmt = slot.split(":", 2)
1834         if len(fmt) != 3:
1835             log.warning("Malformed slot: %s", slot)
1836             return slot
1837         if fmt[1] != "salt":
1838             log.warning("Malformed slot: %s", slot)
1839             log.warning(
1840                 "Only execution modules are currently supported in slots. This means"
1841                 ' slot should start with "__slot__:salt:"'
1842             )
1843             return slot
1844         fun, args, kwargs = salt.utils.args.parse_function(fmt[2])
1845         if not fun or fun not in self.functions:
1846             log.warning("Malformed slot: %s", slot)
1847             log.warning(
1848                 "Execution module should be specified in a function call format: "
1849                 "test.arg('arg', kw='kwarg')"
1850             )
1851             return slot
1852         log.debug("Calling slot: %s(%s, %s)", fun, args, kwargs)
1853         slot_return = self.functions[fun](*args, **kwargs)
1854         slot_text = fmt[2].split("~")[0]
1855         append_data = fmt[2].split("~", 1)[1:]
1856         log.debug("slot_text: %s", slot_text)
1857         log.debug("append_data: %s", append_data)
1858         return_get = None
1859         try:
1860             return_get = slot_text[slot_text.rindex(")") + 1 :]
1861         except ValueError:
1862             pass
1863         if return_get:
1864             return_get = return_get.split(".", 1)[1].strip()
1865             log.debug("Searching slot result %s for %s", slot_return, return_get)
1866             slot_return = salt.utils.data.traverse_dict_and_list(
1867                 slot_return, return_get, default=None, delimiter="."
1868             )
1869         if append_data:
1870             if isinstance(slot_return, str):
1871                 append_data = " ".join(append_data).strip()
1872                 log.debug("appending to slot result: %s", append_data)
1873                 slot_return += append_data
1874             else:
1875                 log.error("Ignoring slot append, slot result is not a string")
1876         return slot_return
1877     def format_slots(self, cdata):
1878         SLOT_TEXT = "__slot__:"
1879         ctx = (("args", enumerate(cdata["args"])), ("kwargs", cdata["kwargs"].items()))
1880         for atype, avalues in ctx:
1881             for ind, arg in avalues:
1882                 arg = salt.utils.data.decode(arg, keep=True)
1883                 if isinstance(arg, dict):
1884                     for key, value in arg.items():
1885                         try:
1886                             if value.startswith(SLOT_TEXT):
1887                                 log.trace("Slot processsing dict value %s", value)
1888                                 cdata[atype][ind][key] = self.__eval_slot(value)
1889                         except AttributeError:
1890                             continue
1891                 elif isinstance(arg, list):
1892                     for idx, listvalue in enumerate(arg):
1893                         log.trace("Slot processing list value: %s", listvalue)
1894                         if isinstance(listvalue, dict):
1895                             for key, value in listvalue.items():
1896                                 try:
1897                                     if value.startswith(SLOT_TEXT):
1898                                         log.trace(
1899                                             "Slot processsing nested dict value %s",
1900                                             value,
1901                                         )
1902                                         cdata[atype][ind][idx][key] = self.__eval_slot(
1903                                             value
1904                                         )
1905                                 except AttributeError:
1906                                     continue
1907                         if isinstance(listvalue, str):
1908                             if listvalue.startswith(SLOT_TEXT):
1909                                 log.trace(
1910                                     "Slot processsing nested string %s", listvalue
1911                                 )
1912                                 cdata[atype][ind][idx] = self.__eval_slot(listvalue)
1913                 elif isinstance(arg, str) and arg.startswith(SLOT_TEXT):
1914                     log.trace("Slot processsing %s", arg)
1915                     cdata[atype][ind] = self.__eval_slot(arg)
1916                 else:
1917                     continue
1918     def verify_retry_data(self, retry_data):
1919         retry_defaults = {
1920             "until": True,
1921             "attempts": 2,
1922             "splay": 0,
1923             "interval": 30,
1924         }
1925         expected_data = {
1926             "until": bool,
1927             "attempts": int,
1928             "interval": int,
1929             "splay": int,
1930         }
1931         validated_retry_data = {}
1932         if isinstance(retry_data, dict):
1933             for expected_key, value_type in expected_data.items():
1934                 if expected_key in retry_data:
1935                     if isinstance(retry_data[expected_key], value_type):
1936                         validated_retry_data[expected_key] = retry_data[expected_key]
1937                     else:
1938                         log.warning(
1939                             "An invalid value was passed for the retry %s, "
1940                             "using default value '%s'",
1941                             expected_key,
1942                             retry_defaults[expected_key],
1943                         )
1944                         validated_retry_data[expected_key] = retry_defaults[
1945                             expected_key
1946                         ]
1947                 else:
1948                     validated_retry_data[expected_key] = retry_defaults[expected_key]
1949         else:
1950             log.warning(
1951                 "State is set to retry, but a valid dict for retry "
1952                 "configuration was not found.  Using retry defaults"
1953             )
1954             validated_retry_data = retry_defaults
1955         return validated_retry_data
1956     def call_chunks(self, chunks):
1957         disabled = {}
1958         if "state_runs_disabled" in self.opts["grains"]:
1959             for low in chunks[:]:
1960                 state_ = "{}.{}".format(low["state"], low["fun"])
1961                 for pat in self.opts["grains"]["state_runs_disabled"]:
1962                     if fnmatch.fnmatch(state_, pat):
1963                         comment = (
1964                             'The state function "{0}" is currently disabled by "{1}", '
1965                             "to re-enable, run state.enable {1}.".format(
1966                                 state_,
1967                                 pat,
1968                             )
1969                         )
1970                         _tag = _gen_tag(low)
1971                         disabled[_tag] = {
1972                             "changes": {},
1973                             "result": False,
1974                             "comment": comment,
1975                             "__run_num__": self.__run_num,
1976                             "__sls__": low["__sls__"],
1977                         }
1978                         self.__run_num += 1
1979                         chunks.remove(low)
1980                         break
1981         running = {}
1982         for low in chunks:
1983             if "__FAILHARD__" in running:
1984                 running.pop("__FAILHARD__")
1985                 return running
1986             tag = _gen_tag(low)
1987             if tag not in running:
1988                 action = self.check_pause(low)
1989                 if action == "kill":
1990                     break
1991                 running = self.call_chunk(low, running, chunks)
1992                 if self.check_failhard(low, running):
1993                     return running
1994             self.active = set()
1995         while True:
1996             if self.reconcile_procs(running):
1997                 break
1998             time.sleep(0.01)
1999         ret = dict(list(disabled.items()) + list(running.items()))
2000         return ret
2001     def check_failhard(self, low, running):
2002         tag = _gen_tag(low)
2003         if self.opts.get("test", False):
2004             return False
2005         if low.get("failhard", self.opts["failhard"]) and tag in running:
2006             if running[tag]["result"] is None:
2007                 return False
2008             return not running[tag]["result"]
2009         return False
2010     def check_pause(self, low):
2011         if not self.jid:
2012             return
2013         pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2014         start = time.time()
2015         if os.path.isfile(pause_path):
2016             try:
2017                 while True:
2018                     tries = 0
2019                     with salt.utils.files.fopen(pause_path, "rb") as fp_:
2020                         try:
2021                             pdat = msgpack_deserialize(fp_.read())
2022                         except salt.utils.msgpack.exceptions.UnpackValueError:
2023                             if tries &gt; 10:
2024                                 return
2025                             tries += 1
2026                             time.sleep(1)
2027                             continue
2028                         id_ = low["__id__"]
2029                         key = ""
2030                         if id_ in pdat:
2031                             key = id_
2032                         elif "__all__" in pdat:
2033                             key = "__all__"
2034                         if key:
2035                             if "duration" in pdat[key]:
2036                                 now = time.time()
2037                                 if now - start &gt; pdat[key]["duration"]:
2038                                     return "run"
2039                             if "kill" in pdat[key]:
2040                                 return "kill"
2041                         else:
2042                             return "run"
2043                         time.sleep(1)
2044             except Exception as exc:  # pylint: disable=broad-except
2045                 log.error(
2046                     "Failed to read in pause data for file located at: %s", pause_path
2047                 )
2048                 return "run"
2049         return "run"
2050     def reconcile_procs(self, running):
2051         retset = set()
2052         for tag in running:
2053             proc = running[tag].get("proc")
2054             if proc:
2055                 if not proc.is_alive():
2056                     ret_cache = os.path.join(
2057                         self.opts["cachedir"],
2058                         self.jid,
2059                         salt.utils.hashutils.sha1_digest(tag),
2060                     )
2061                     if not os.path.isfile(ret_cache):
2062                         ret = {
2063                             "result": False,
2064                             "comment": "Parallel process failed to return",
2065                             "name": running[tag]["name"],
2066                             "changes": {},
2067                         }
2068                     try:
2069                         with salt.utils.files.fopen(ret_cache, "rb") as fp_:
2070                             ret = msgpack_deserialize(fp_.read())
2071                     except OSError:
2072                         ret = {
2073                             "result": False,
2074                             "comment": "Parallel cache failure",
2075                             "name": running[tag]["name"],
2076                             "changes": {},
2077                         }
2078                     running[tag].update(ret)
2079                     running[tag].pop("proc")
2080                 else:
2081                     retset.add(False)
2082         return False not in retset
2083     def check_requisite(self, low, running, chunks, pre=False):
2084         disabled_reqs = self.opts.get("disabled_requisites", [])
2085         if not isinstance(disabled_reqs, list):
2086             disabled_reqs = [disabled_reqs]
2087         present = False
2088         if "watch" in low:
2089             if "{}.mod_watch".format(low["state"]) not in self.states:
2090                 if "require" in low:
2091                     low["require"].extend(low.pop("watch"))
2092                 else:
2093                     low["require"] = low.pop("watch")
2094             else:
2095                 present = True
2096         if "watch_any" in low:
2097             if "{}.mod_watch".format(low["state"]) not in self.states:
2098                 if "require_any" in low:
2099                     low["require_any"].extend(low.pop("watch_any"))
2100                 else:
2101                     low["require_any"] = low.pop("watch_any")
2102             else:
2103                 present = True
2104         if "require" in low:
2105             present = True
2106         if "require_any" in low:
2107             present = True
2108         if "prerequired" in low:
2109             present = True
2110         if "prereq" in low:
2111             present = True
2112         if "onfail" in low:
2113             present = True
2114         if "onfail_any" in low:
2115             present = True
2116         if "onfail_all" in low:
2117             present = True
2118         if "onchanges" in low:
2119             present = True
2120         if "onchanges_any" in low:
2121             present = True
2122         if not present:
2123             return "met", ()
2124         self.reconcile_procs(running)
2125         reqs = {
2126             "require": [],
2127             "require_any": [],
2128             "watch": [],
2129             "watch_any": [],
2130             "prereq": [],
2131             "onfail": [],
2132             "onfail_any": [],
2133             "onfail_all": [],
2134             "onchanges": [],
2135             "onchanges_any": [],
2136         }
2137         if pre:
2138             reqs["prerequired"] = []
2139         for r_state in reqs:
2140             if r_state in low and low[r_state] is not None:
2141                 if r_state in disabled_reqs:
2142                     log.warning(
2143                         "The %s requisite has been disabled, Ignoring.", r_state
2144                     )
2145                     continue
2146                 for req in low[r_state]:
2147                     if isinstance(req, str):
2148                         req = {"id": req}
2149                     req = trim_req(req)
2150                     found = False
2151                     for chunk in chunks:
2152                         req_key = next(iter(req))
2153                         req_val = req[req_key]
2154                         if req_val is None:
2155                             continue
2156                         if req_key == "sls":
2157                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2158                                 found = True
2159                                 reqs[r_state].append(chunk)
2160                             continue
2161                         try:
2162                             if isinstance(req_val, str):
2163                                 if fnmatch.fnmatch(
2164                                     chunk["name"], req_val
2165                                 ) or fnmatch.fnmatch(chunk["__id__"], req_val):
2166                                     if req_key == "id" or chunk["state"] == req_key:
2167                                         found = True
2168                                         reqs[r_state].append(chunk)
2169                             else:
2170                                 raise KeyError
2171                         except KeyError as exc:
2172                             raise SaltRenderError(
2173                                 "Could not locate requisite of [{}] present in state"
2174                                 " with name [{}]".format(req_key, chunk["name"])
2175                             )
2176                         except TypeError:
2177                             raise SaltRenderError(
2178                                 "Could not locate requisite of [{}] present in state"
2179                                 " with name [{}]".format(req_key, chunk["name"])
2180                             )
2181                     if not found:
2182                         return "unmet", ()
2183         fun_stats = set()
2184         for r_state, chunks in reqs.items():
2185             req_stats = set()
2186             if r_state.startswith("prereq") and not r_state.startswith("prerequired"):
2187                 run_dict = self.pre
2188             else:
2189                 run_dict = running
2190             filtered_run_dict = {}
2191             for chunk in chunks:
2192                 tag = _gen_tag(chunk)
2193                 run_dict_chunk = run_dict.get(tag)
2194                 if run_dict_chunk:
2195                     filtered_run_dict[tag] = run_dict_chunk
2196             run_dict = filtered_run_dict
2197             while True:
2198                 if self.reconcile_procs(run_dict):
2199                     break
2200                 time.sleep(0.01)
2201             for chunk in chunks:
2202                 tag = _gen_tag(chunk)
2203                 if tag not in run_dict:
2204                     req_stats.add("unmet")
2205                     continue
2206                 if r_state.startswith("onfail"):
2207                     if run_dict[tag]["result"] is True:
2208                         req_stats.add("onfail")  # At least one state is OK
2209                         continue
2210                 else:
2211                     if run_dict[tag]["result"] is False:
2212                         req_stats.add("fail")
2213                         continue
2214                 if r_state.startswith("onchanges"):
2215                     if not run_dict[tag]["changes"]:
2216                         req_stats.add("onchanges")
2217                     else:
2218                         req_stats.add("onchangesmet")
2219                     continue
2220                 if r_state.startswith("watch") and run_dict[tag]["changes"]:
2221                     req_stats.add("change")
2222                     continue
2223                 if r_state.startswith("prereq") and run_dict[tag]["result"] is None:
2224                     if not r_state.startswith("prerequired"):
2225                         req_stats.add("premet")
2226                 if r_state.startswith("prereq") and not run_dict[tag]["result"] is None:
2227                     if not r_state.startswith("prerequired"):
2228                         req_stats.add("pre")
2229                 else:
2230                     if run_dict[tag].get("__state_ran__", True):
2231                         req_stats.add("met")
2232             if r_state.endswith("_any") or r_state == "onfail":
2233                 if "met" in req_stats or "change" in req_stats:
2234                     if "fail" in req_stats:
2235                         req_stats.remove("fail")
2236                 if "onchangesmet" in req_stats:
2237                     if "onchanges" in req_stats:
2238                         req_stats.remove("onchanges")
2239                     if "fail" in req_stats:
2240                         req_stats.remove("fail")
2241                 if "onfail" in req_stats:
2242                     if "met" in req_stats:
2243                         req_stats.remove("onfail")
2244             if r_state.endswith("_all"):
2245                 if "onfail" in req_stats:
2246                     if "met" in req_stats:
2247                         req_stats.remove("met")
2248             fun_stats.update(req_stats)
2249         if "unmet" in fun_stats:
2250             status = "unmet"
2251         elif "fail" in fun_stats:
2252             status = "fail"
2253         elif "pre" in fun_stats:
2254             if "premet" in fun_stats:
2255                 status = "met"
2256             else:
2257                 status = "pre"
2258         elif "onfail" in fun_stats and "onchangesmet" not in fun_stats:
2259             status = "onfail"
2260         elif "onchanges" in fun_stats and "onchangesmet" not in fun_stats:
2261             status = "onchanges"
2262         elif "change" in fun_stats:
2263             status = "change"
2264         elif "onfail" in fun_stats:
2265             status = "onfail"
2266         else:
2267             status = "met"
2268         return status, reqs
2269     def event(self, chunk_ret, length, fire_event=False):
2270         if not self.opts.get("local") and (
2271             self.opts.get("state_events", True) or fire_event
2272         ):
2273             if not self.opts.get("master_uri"):
2274                 ev_func = (
2275                     lambda ret, tag, preload=None: salt.utils.event.get_master_event(
2276                         self.opts, self.opts["sock_dir"], listen=False
2277                     ).fire_event(ret, tag)
2278                 )
2279             else:
2280                 ev_func = self.functions["event.fire_master"]
2281             ret = {"ret": chunk_ret}
2282             if fire_event is True:
2283                 tag = salt.utils.event.tagify(
2284                     [self.jid, self.opts["id"], str(chunk_ret["name"])],
2285                     "state_result",
2286                 )
2287             elif isinstance(fire_event, str):
2288                 tag = salt.utils.event.tagify(
2289                     [self.jid, self.opts["id"], str(fire_event)],
2290 <a name="2"></a>                    "state_result",
2291                 )
2292             else:
2293                 tag = salt<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.event.tagify(
2294                     [self.jid, "prog", self.opts["id"], str(chunk_ret["__run_num__"])],
2295                     "job",
2296                 )
2297                 ret["len"] =</b></font> length
2298             preload = {"jid": self.jid}
2299             ev_func(ret, tag, preload=preload)
2300     def call_chunk(self, low, running, chunks):
2301         low = self._mod_aggregate(low, running, chunks)
2302         self._mod_init(low)
2303         tag = _gen_tag(low)
2304         if not low.get("prerequired"):
2305             self.active.add(tag)
2306         requisites = [
2307             "require",
2308             "require_any",
2309             "watch",
2310             "watch_any",
2311             "prereq",
2312             "onfail",
2313             "onfail_any",
2314             "onchanges",
2315             "onchanges_any",
2316         ]
2317         if not low.get("__prereq__"):
2318             requisites.append("prerequired")
2319             status, reqs = self.check_requisite(low, running, chunks, pre=True)
2320         else:
2321             status, reqs = self.check_requisite(low, running, chunks)
2322         if status == "unmet":
2323             lost = {}
2324             reqs = []
2325             for requisite in requisites:
2326                 lost[requisite] = []
2327                 if requisite not in low:
2328                     continue
2329                 for req in low[requisite]:
2330                     if isinstance(req, str):
2331                         req = {"id": req}
2332                     req = trim_req(req)
2333                     found = False
2334                     req_key = next(iter(req))
2335                     req_val = req[req_key]
2336                     for chunk in chunks:
2337                         if req_val is None:
2338                             continue
2339                         if req_key == "sls":
2340                             if fnmatch.fnmatch(chunk["__sls__"], req_val):
2341                                 if requisite == "prereq":
2342                                     chunk["__prereq__"] = True
2343                                 reqs.append(chunk)
2344                                 found = True
2345                             continue
2346                         if fnmatch.fnmatch(chunk["name"], req_val) or fnmatch.fnmatch(
2347                             chunk["__id__"], req_val
2348                         ):
2349                             if req_key == "id" or chunk["state"] == req_key:
2350                                 if requisite == "prereq":
2351                                     chunk["__prereq__"] = True
2352                                 elif requisite == "prerequired":
2353                                     chunk["__prerequired__"] = True
2354                                 reqs.append(chunk)
2355                                 found = True
2356                     if not found:
2357                         lost[requisite].append(req)
2358             if (
2359                 lost["require"]
2360                 or lost["watch"]
2361                 or lost["prereq"]
2362                 or lost["onfail"]
2363                 or lost["onchanges"]
2364                 or lost["require_any"]
2365                 or lost["watch_any"]
2366                 or lost["onfail_any"]
2367                 or lost["onchanges_any"]
2368                 or lost.get("prerequired")
2369             ):
2370                 comment = "The following requisites were not found:\n"
2371                 for requisite, lreqs in lost.items():
2372                     if not lreqs:
2373                         continue
2374                     comment += "{}{}:\n".format(" " * 19, requisite)
2375                     for lreq in lreqs:
2376                         req_key = next(iter(lreq))
2377                         req_val = lreq[req_key]
2378                         comment += "{}{}: {}\n".format(" " * 23, req_key, req_val)
2379                 if low.get("__prereq__"):
2380                     run_dict = self.pre
2381                 else:
2382                     run_dict = running
2383                 start_time, duration = _calculate_fake_duration()
2384                 run_dict[tag] = {
2385                     "changes": {},
2386                     "result": False,
2387                     "duration": duration,
2388                     "start_time": start_time,
2389                     "comment": comment,
2390                     "__run_num__": self.__run_num,
2391                     "__sls__": low["__sls__"],
2392                 }
2393                 self.__run_num += 1
2394                 self.event(run_dict[tag], len(chunks), fire_event=low.get("fire_event"))
2395                 return running
2396             for chunk in reqs:
2397                 ctag = _gen_tag(chunk)
2398                 if ctag not in running:
2399                     if ctag in self.active:
2400                         if chunk.get("__prerequired__"):
2401                             if tag not in self.pre:
2402                                 low["__prereq__"] = True
2403                                 self.pre[ctag] = self.call(low, chunks, running)
2404                                 return running
2405                             else:
2406                                 return running
2407                         elif ctag not in running:
2408                             log.error("Recursive requisite found")
2409                             running[tag] = {
2410                                 "changes": {},
2411                                 "result": False,
2412                                 "comment": "Recursive requisite found",
2413                                 "__run_num__": self.__run_num,
2414                                 "__sls__": low["__sls__"],
2415                             }
2416                         self.__run_num += 1
2417                         self.event(
2418                             running[tag], len(chunks), fire_event=low.get("fire_event")
2419                         )
2420                         return running
2421                     running = self.call_chunk(chunk, running, chunks)
2422                     if self.check_failhard(chunk, running):
2423                         running["__FAILHARD__"] = True
2424                         return running
2425             if low.get("__prereq__"):
2426                 status, reqs = self.check_requisite(low, running, chunks)
2427                 self.pre[tag] = self.call(low, chunks, running)
2428                 if not self.pre[tag]["changes"] and status == "change":
2429                     self.pre[tag]["changes"] = {"watch": "watch"}
2430                     self.pre[tag]["result"] = None
2431             else:
2432                 running = self.call_chunk(low, running, chunks)
2433             if self.check_failhard(chunk, running):
2434                 running["__FAILHARD__"] = True
2435                 return running
2436         elif status == "met":
2437             if low.get("__prereq__"):
2438                 self.pre[tag] = self.call(low, chunks, running)
2439             else:
2440                 running[tag] = self.call(low, chunks, running)
2441         elif status == "fail":
2442             if tag in self.pre:
2443                 running<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[tag] = self.pre[tag]
2444                 running[tag]["__run_num__"] = self.__run_num
2445                 running[tag]["__sls__"] = low[</b></font>"__sls__"]
2446             else:
2447                 failed_requisites = set()
2448                 for req_lows in reqs.values():
2449                     for req_low in req_lows:
2450                         req_tag = _gen_tag(req_low)
2451                         req_ret = self.pre.get(req_tag, running.get(req_tag))
2452                         if req_ret is None:
2453                             continue
2454                         if req_ret["result"] is False:
2455                             key = "{sls}.{_id}".format(
2456                                 sls=req_low["__sls__"], _id=req_low["__id__"]
2457                             )
2458                             failed_requisites.add(key)
2459                 _cmt = "One or more requisite failed: {}".format(
2460                     ", ".join(str(i) for i in failed_requisites)
2461                 )
2462                 start_time, duration = _calculate_fake_duration()
2463                 running[tag] = {
2464                     "changes": {},
2465                     "result": False,
2466                     "duration": duration,
2467                     "start_time": start_time,
2468                     "comment": _cmt,
2469                     "__run_num__": self.__run_num,
2470                     "__sls__": low["__sls__"],
2471                 }
2472                 self.pre[tag] = running[tag]
2473             self.__run_num += 1
2474         elif status == "change" and not low.get("__prereq__"):
2475             ret = self.call(low, chunks, running)
2476             if not ret["changes"] and not ret.get("skip_watch", False):
2477                 low = low.copy()
2478                 low["sfun"] = low["fun"]
2479                 low["fun"] = "mod_watch"
2480                 low["__reqs__"] = reqs
2481                 ret = self.call(low, chunks, running)
2482             running[tag] = ret
2483         elif status == "pre":
2484             start_time, duration = _calculate_fake_duration()
2485             pre_ret = {
2486                 "changes": {},
2487                 "result": True,
2488                 "duration": duration,
2489                 "start_time": start_time,
2490                 "comment": "No changes detected",
2491                 "__run_num__": self.__run_num,
2492                 "__sls__": low["__sls__"],
2493             }
2494             running[tag] = pre_ret
2495             self.pre[tag] = pre_ret
2496             self.__run_num += 1
2497         elif status == "onfail":
2498             start_time, duration = _calculate_fake_duration()
2499             running[tag] = {
2500                 "changes": {},
2501                 "result": True,
2502                 "duration": duration,
2503                 "start_time": start_time,
2504                 "comment": "State was not run because onfail req did not change",
2505                 "__state_ran__": False,
2506                 "__run_num__": self.__run_num,
2507                 "__sls__": low["__sls__"],
2508             }
2509             self.__run_num += 1
2510         elif status == "onchanges":
2511             start_time, duration = _calculate_fake_duration()
2512             running[tag] = {
2513                 "changes": {},
2514                 "result": True,
2515                 "duration": duration,
2516                 "start_time": start_time,
2517                 "comment": (
2518                     "State was not run because none of the onchanges reqs changed"
2519                 ),
2520                 "__state_ran__": False,
2521                 "__run_num__": self.__run_num,
2522                 "__sls__": low["__sls__"],
2523             }
2524             self.__run_num += 1
2525         else:
2526             if low.get("__prereq__"):
2527                 self.pre[tag] = self.call(low, chunks, running)
2528             else:
2529                 running[tag] = self.call(low, chunks, running)
2530         if tag in running:
2531             self.event(running[tag], len(chunks), fire_event=low.get("fire_event"))
2532             for sub_state_data in running[tag].pop("sub_state_run", ()):
2533                 start_time, duration = _calculate_fake_duration()
2534                 self.__run_num += 1
2535                 sub_tag = _gen_tag(sub_state_data["low"])
2536                 running[sub_tag] = {
2537                     "name": sub_state_data["low"]["name"],
2538                     "changes": sub_state_data["changes"],
2539                     "result": sub_state_data["result"],
2540                     "duration": sub_state_data.get("duration", duration),
2541                     "start_time": sub_state_data.get("start_time", start_time),
2542                     "comment": sub_state_data.get("comment", ""),
2543                     "__state_ran__": True,
2544                     "__run_num__": self.__run_num,
2545                     "__sls__": low["__sls__"],
2546                 }
2547         return running
2548     def call_beacons(self, chunks, running):
2549         listeners = []
2550         crefs = {}
2551         beacons = []
2552         for chunk in chunks:
2553             if "beacon" in chunk:
2554                 beacons.append(chunk)
2555         mod_beacons = []
2556         errors = {}
2557         for chunk in beacons:
2558             low = chunk.copy()
2559             low["sfun"] = chunk["fun"]
2560             low["fun"] = "mod_beacon"
2561             low["__id__"] = "beacon_{}".format(low["__id__"])
2562             mod_beacons.append(low)
2563         ret = self.call_chunks(mod_beacons)
2564         running.update(ret)
2565         for err in errors:
2566             errors[err]["__run_num__"] = self.__run_num
2567             self.__run_num += 1
2568         running.update(errors)
2569         return running
2570     def call_listen(self, chunks, running):
2571         listeners = []
2572         crefs = {}
2573         for chunk in chunks:
2574             crefs[(chunk["state"], chunk["__id__"], chunk["name"])] = chunk
2575             if "listen" in chunk:
2576                 listeners.append(
2577                     {(chunk["state"], chunk["__id__"], chunk["name"]): chunk["listen"]}
2578                 )
2579             if "listen_in" in chunk:
2580                 for l_in in chunk["listen_in"]:
2581                     for key, val in l_in.items():
2582                         listeners.append(
2583                             {(key, val, "lookup"): [{chunk["state"]: chunk["__id__"]}]}
2584                         )
2585         mod_watchers = []
2586         errors = {}
2587         for l_dict in listeners:
2588             for key, val in l_dict.items():
2589                 for listen_to in val:
2590                     if not isinstance(listen_to, dict):
2591                         found = False
2592                         for chunk in chunks:
2593                             if (
2594                                 chunk["__id__"] == listen_to
2595                                 or chunk["name"] == listen_to
2596                             ):
2597                                 listen_to = {chunk["state"]: chunk["__id__"]}
2598                                 found = True
2599                         if not found:
2600                             continue
2601                     for lkey, lval in listen_to.items():
2602                         if not any(lkey == cref[0] and lval in cref for cref in crefs):
2603                             rerror = {
2604                                 _l_tag(lkey, lval): {
2605                                     "comment": (
2606                                         "Referenced state {}: {} does not exist".format(
2607                                             lkey, lval
2608                                         )
2609                                     ),
2610                                     "name": "listen_{}:{}".format(lkey, lval),
2611                                     "result": False,
2612                                     "changes": {},
2613                                 }
2614                             }
2615                             errors.update(rerror)
2616                             continue
2617                         to_tags = [
2618                             _gen_tag(data)
2619                             for cref, data in crefs.items()
2620                             if lkey == cref[0] and lval in cref
2621                         ]
2622                         for to_tag in to_tags:
2623                             if to_tag not in running:
2624                                 continue
2625                             if running[to_tag]["changes"]:
2626                                 if not any(
2627                                     key[0] == cref[0] and key[1] in cref
2628                                     for cref in crefs
2629                                 ):
2630                                     rerror = {
2631                                         _l_tag(key[0], key[1]): {
2632                                             "comment": (
2633                                                 "Referenced state {}: {} does not exist".format(
2634                                                     key[0], key[1]
2635                                                 )
2636                                             ),
2637                                             "name": "listen_{}:{}".format(
2638                                                 key[0], key[1]
2639                                             ),
2640                                             "result": False,
2641                                             "changes": {},
2642                                         }
2643                                     }
2644                                     errors.update(rerror)
2645                                     continue
2646                                 new_chunks = [
2647                                     data
2648                                     for cref, data in crefs.items()
2649                                     if key[0] == cref[0] and key[1] in cref
2650                                 ]
2651                                 for chunk in new_chunks:
2652                                     low = chunk.copy()
2653                                     low["sfun"] = chunk["fun"]
2654                                     low["fun"] = "mod_watch"
2655                                     low["__id__"] = "listener_{}".format(low["__id__"])
2656                                     for req in STATE_REQUISITE_KEYWORDS:
2657                                         if req in low:
2658                                             low.pop(req)
2659                                     mod_watchers.append(low)
2660         ret = self.call_chunks(mod_watchers)
2661         running.update(ret)
2662         for err in errors:
2663             errors[err]["__run_num__"] = self.__run_num
2664             self.__run_num += 1
2665         running.update(errors)
2666         return running
2667     def call_high(self, high, orchestration_jid=None):
2668         errors = []
2669         high, ext_errors = self.reconcile_extend(high)
2670         errors.extend(ext_errors)
2671         errors.extend(self.verify_high(high))
2672         if errors:
2673             return errors
2674         high, req_in_errors = self.requisite_in(high)
2675         errors.extend(req_in_errors)
2676         high = self.apply_exclude(high)
2677         if errors:
2678             return errors
2679         chunks = self.compile_high_data(high, orchestration_jid)
2680         if errors:
2681             return errors
2682         ret = self.call_chunks(chunks)
2683         ret = self.call_listen(chunks, ret)
2684         ret = self.call_beacons(chunks, ret)
2685         def _cleanup_accumulator_data():
2686             accum_data_path = os.path.join(
2687                 get_accumulator_dir(self.opts["cachedir"]), self.instance_id
2688             )
2689             try:
2690                 os.remove(accum_data_path)
2691                 log.debug("Deleted accumulator data file %s", accum_data_path)
2692             except OSError:
2693                 log.debug("File %s does not exist, no need to cleanup", accum_data_path)
2694         _cleanup_accumulator_data()
2695         if self.jid is not None:
2696             pause_path = os.path.join(self.opts["cachedir"], "state_pause", self.jid)
2697             if os.path.isfile(pause_path):
2698                 try:
2699                     os.remove(pause_path)
2700                 except OSError:
2701                     pass
2702         return ret
2703     def render_template(self, high, template):
2704         errors = []
2705         if not high:
2706             return high, errors
2707         if not isinstance(high, dict):
2708             errors.append(
2709                 "Template {} does not render to a dictionary".format(template)
2710             )
2711             return high, errors
2712         invalid_items = ("include", "exclude", "extends")
2713         for item in invalid_items:
2714             if item in high:
2715                 errors.append(
2716                     "The '{}' declaration found on '{}' is invalid when "
2717                     "rendering single templates".format(item, template)
2718                 )
2719                 return high, errors
2720         for name in high:
2721             if not isinstance(high[name], dict):
2722                 if isinstance(high[name], str):
2723                     if "." in high[name]:
2724                         comps = high[name].split(".")
2725                         high[name] = {
2726                             comps[0]: [comps[1]]
2727                         }
2728                         continue
2729                     errors.append(
2730                         "ID {} in template {} is not a dictionary".format(
2731                             name, template
2732                         )
2733                     )
2734                     continue
2735             skeys = set()
2736             for key in sorted(high[name]):
2737                 if key.startswith("_"):
2738                     continue
2739                 if high[name][key] is None:
2740                     errors.append(
2741                         "ID '{}' in template {} contains a short "
2742                         "declaration ({}) with a trailing colon. When not "
2743                         "passing any arguments to a state, the colon must be "
2744                         "omitted.".format(name, template, key)
2745                     )
2746                     continue
2747                 if not isinstance(high[name][key], list):
2748                     continue
2749                 if "." in key:
2750                     comps = key.split(".")
2751                     if comps[0] in skeys:
2752                         errors.append(
2753                             "ID '{}' in template '{}' contains multiple "
2754                             "state declarations of the same type".format(name, template)
2755                         )
2756                         continue
2757                     high[name][comps[0]] = high[name].pop(key)
2758                     high[name][comps[0]].append(comps[1])
2759                     skeys.add(comps[0])
2760                     continue
2761                 skeys.add(key)
2762         return high, errors
2763     def call_template(self, template):
2764         high = compile_template(
2765             template,
2766             self.rend,
2767             self.opts["renderer"],
2768             self.opts["renderer_blacklist"],
2769             self.opts["renderer_whitelist"],
2770         )
2771         if not high:
2772             return high
2773         high, errors = self.render_template(high, template)
2774         if errors:
2775             return errors
2776         return self.call_high(high)
2777     def call_template_str(self, template):
2778         high = compile_template_str(
2779             template,
2780             self.rend,
2781             self.opts["renderer"],
2782             self.opts["renderer_blacklist"],
2783             self.opts["renderer_whitelist"],
2784         )
2785         if not high:
2786             return high
2787         high, errors = self.render_template(high, "&lt;template-str&gt;")
2788         if errors:
2789             return errors
2790         return self.call_high(high)
2791 class LazyAvailStates:
2792     def __init__(self, hs):
2793         self._hs = hs
2794         self._avail = {"base": None}
2795         self._filled = False
2796     def _fill(self):
2797         if self._filled:
2798             return
2799         for saltenv in self._hs._get_envs():
2800             if saltenv not in self._avail:
2801                 self._avail[saltenv] = None
2802         self._filled = True
2803     def __contains__(self, saltenv):
2804         if saltenv == "base":
2805             return True
2806         self._fill()
2807         return saltenv in self._avail
2808     def __getitem__(self, saltenv):
2809         if saltenv != "base":
2810             self._fill()
2811         if saltenv not in self._avail or self._avail[saltenv] is None:
2812             self._avail[saltenv] = self._hs.client.list_states(saltenv)
2813         return self._avail[saltenv]
2814     def items(self):
2815         self._fill()
2816         ret = []
2817         for saltenv, states in self._avail.items():
2818             ret.append((saltenv, self.__getitem__(saltenv)))
2819         return ret
2820 class BaseHighState:
2821     def __init__(self, opts):
2822         self.opts = self.__gen_opts(opts)
2823         self.iorder = 10000
2824         self.avail = self.__gather_avail()
2825         self.building_highstate = OrderedDict()
2826     def __gather_avail(self):
2827         return LazyAvailStates(self)
2828     def __gen_opts(self, opts):
2829         if "local_state" in opts:
2830             if opts["local_state"]:
2831                 return opts
2832         mopts = self.client.master_opts()
2833         if not isinstance(mopts, dict):
2834             opts["renderer"] = "jinja|yaml"
2835             opts["failhard"] = False
2836             opts["state_top"] = salt.utils.url.create("top.sls")
2837             opts["nodegroups"] = {}
2838             opts["file_roots"] = {"base": [syspaths.BASE_FILE_ROOTS_DIR]}
2839         else:
2840             opts["renderer"] = mopts["renderer"]
2841             opts["failhard"] = mopts.get("failhard", False)
2842             if mopts["state_top"].startswith("salt://"):
2843                 opts["state_top"] = mopts["state_top"]
2844             elif mopts["state_top"].startswith("/"):
2845                 opts["state_top"] = salt.utils.url.create(mopts["state_top"][1:])
2846             else:
2847                 opts["state_top"] = salt.utils.url.create(mopts["state_top"])
2848             opts["state_top_saltenv"] = mopts.get("state_top_saltenv", None)
2849             opts["nodegroups"] = mopts.get("nodegroups", {})
2850             opts["state_auto_order"] = mopts.get(
2851                 "state_auto_order", opts["state_auto_order"]
2852             )
2853             opts["file_roots"] = mopts["file_roots"]
2854             opts["top_file_merging_strategy"] = mopts.get(
2855                 "top_file_merging_strategy", opts.get("top_file_merging_strategy")
2856             )
2857             opts["env_order"] = mopts.get("env_order", opts.get("env_order", []))
2858             opts["default_top"] = mopts.get("default_top", opts.get("default_top"))
2859             opts["state_events"] = mopts.get("state_events")
2860             opts["state_aggregate"] = (
2861                 opts.get("state_aggregate") or mopts.get("state_aggregate") or False
2862             )
2863             opts["jinja_env"] = mopts.get("jinja_env", {})
2864             opts["jinja_sls_env"] = mopts.get("jinja_sls_env", {})
2865             opts["jinja_lstrip_blocks"] = mopts.get("jinja_lstrip_blocks", False)
2866             opts["jinja_trim_blocks"] = mopts.get("jinja_trim_blocks", False)
2867         return opts
2868     def _get_envs(self):
2869         envs = ["base"]
2870         if "file_roots" in self.opts:
2871             envs.extend([x for x in list(self.opts["file_roots"]) if x not in envs])
2872         env_order = self.opts.get("env_order", [])
2873         members = set()
2874         env_order = [
2875             env for env in env_order if not (env in members or members.add(env))
2876         ]
2877         client_envs = self.client.envs()
2878         if env_order and client_envs:
2879             return [env for env in env_order if env in client_envs]
2880         elif env_order:
2881             return env_order
2882         else:
2883             envs.extend([env for env in client_envs if env not in envs])
2884             return envs
2885     def get_tops(self):
2886         tops = DefaultOrderedDict(list)
2887         include = DefaultOrderedDict(list)
2888         done = DefaultOrderedDict(list)
2889         found = 0  # did we find any contents in the top files?
2890         merging_strategy = self.opts["top_file_merging_strategy"]
2891         if merging_strategy == "same" and not self.opts["saltenv"]:
2892             if not self.opts["default_top"]:
2893                 raise SaltRenderError(
2894                     "top_file_merging_strategy set to 'same', but no "
2895                     "default_top configuration option was set"
2896                 )
2897         if self.opts["saltenv"]:
2898             contents = self.client.cache_file(
2899                 self.opts["state_top"], self.opts["saltenv"]
2900             )
2901             if contents:
2902                 found = 1
2903                 tops[self.opts["saltenv"]] = [
2904                     compile_template(
2905                         contents,
2906                         self.state.rend,
2907                         self.state.opts["renderer"],
2908                         self.state.opts["renderer_blacklist"],
2909                         self.state.opts["renderer_whitelist"],
2910                         saltenv=self.opts["saltenv"],
2911                     )
2912                 ]
2913             else:
2914                 tops[self.opts["saltenv"]] = [{}]
2915         else:
2916             found = 0
2917             state_top_saltenv = self.opts.get("state_top_saltenv", False)
2918             if state_top_saltenv and not isinstance(state_top_saltenv, str):
2919                 state_top_saltenv = str(state_top_saltenv)
2920             for saltenv in (
2921                 [state_top_saltenv] if state_top_saltenv else self._get_envs()
2922             ):
2923                 contents = self.client.cache_file(self.opts["state_top"], saltenv)
2924                 if contents:
2925                     found = found + 1
2926                     tops[saltenv].append(
2927                         compile_template(
2928                             contents,
2929                             self.state.rend,
2930                             self.state.opts["renderer"],
2931                             self.state.opts["renderer_blacklist"],
2932                             self.state.opts["renderer_whitelist"],
2933                             saltenv=saltenv,
2934                         )
2935                     )
2936                 else:
2937                     tops[saltenv].append({})
2938                     log.debug("No contents loaded for saltenv '%s'", saltenv)
2939             if (
2940                 found &gt; 1
2941                 and merging_strategy == "merge"
2942                 and not self.opts.get("env_order", None)
2943             ):
2944                 log.warning(
2945                     "top_file_merging_strategy is set to '%s' and "
2946                     "multiple top files were found. Merging order is not "
2947                     "deterministic, it may be desirable to either set "
2948                     "top_file_merging_strategy to 'same' or use the "
2949                     "'env_order' configuration parameter to specify the "
2950                     "merging order.",
2951                     merging_strategy,
2952                 )
2953         if found == 0:
2954             log.debug(
2955                 "No contents found in top file. If this is not expected, "
2956                 "verify that the 'file_roots' specified in 'etc/master' "
2957                 "are accessible. The 'file_roots' configuration is: %s",
2958                 repr(self.state.opts["file_roots"]),
2959             )
2960         for saltenv, ctops in tops.items():
2961             for ctop in ctops:
2962                 if "include" not in ctop:
2963                     continue
2964                 for sls in ctop["include"]:
2965                     include[saltenv].append(sls)
2966                 ctop.pop("include")
2967         while include:
2968             pops = []
2969             for saltenv, states in include.items():
2970                 pops.append(saltenv)
2971                 if not states:
2972                     continue
2973                 for sls_match in states:
2974                     for sls in fnmatch.filter(self.avail[saltenv], sls_match):
2975                         if sls in done[saltenv]:
2976                             continue
2977                         tops[saltenv].append(
2978                             compile_template(
2979                                 self.client.get_state(sls, saltenv).get("dest", False),
2980                                 self.state.rend,
2981                                 self.state.opts["renderer"],
2982                                 self.state.opts["renderer_blacklist"],
2983                                 self.state.opts["renderer_whitelist"],
2984                                 saltenv,
2985                             )
2986                         )
2987                         done[saltenv].append(sls)
2988             for saltenv in pops:
2989                 if saltenv in include:
2990                     include.pop(saltenv)
2991         return tops
2992     def merge_tops(self, tops):
2993         merging_strategy = self.opts["top_file_merging_strategy"]
2994         try:
2995             merge_attr = "_merge_tops_{}".format(merging_strategy)
2996             merge_func = getattr(self, merge_attr)
2997             if not hasattr(merge_func, "__call__"):
2998                 msg = "'{}' is not callable".format(merge_attr)
2999                 log.error(msg)
3000                 raise TypeError(msg)
3001         except (AttributeError, TypeError):
3002             log.warning(
3003                 "Invalid top_file_merging_strategy '%s', falling back to 'merge'",
3004                 merging_strategy,
3005             )
3006             merge_func = self._merge_tops_merge
3007         return merge_func(tops)
3008     def _merge_tops_merge(self, tops):
3009         top = DefaultOrderedDict(OrderedDict)
3010         base_tops = tops.pop("base", DefaultOrderedDict(OrderedDict))
3011         for ctop in base_tops:
3012             for saltenv, targets in ctop.items():
3013                 if saltenv == "include":
3014                     continue
3015                 try:
3016                     for tgt in targets:
3017                         top[saltenv][tgt] = ctop[saltenv][tgt]
3018                 except TypeError:
3019                     raise SaltRenderError(
3020                         "Unable to render top file. No targets found."
3021                     )
3022         for cenv, ctops in tops.items():
3023             for ctop in ctops:
3024                 for saltenv, targets in ctop.items():
3025                     if saltenv == "include":
3026                         continue
3027                     elif saltenv != cenv:
3028                         log.debug(
3029                             "Section for saltenv '%s' in the '%s' "
3030                             "saltenv's top file will be ignored, as the "
3031                             "top_file_merging_strategy is set to 'merge' "
3032                             "and the saltenvs do not match",
3033                             saltenv,
3034                             cenv,
3035                         )
3036                         continue
3037                     elif saltenv in top:
3038                         log.debug(
3039                             "Section for saltenv '%s' in the '%s' "
3040                             "saltenv's top file will be ignored, as this "
3041                             "saltenv was already defined in the 'base' top "
3042                             "file",
3043                             saltenv,
3044                             cenv,
3045                         )
3046                         continue
3047                     try:
3048                         for tgt in targets:
3049                             top[saltenv][tgt] = ctop[saltenv][tgt]
3050                     except TypeError:
3051                         raise SaltRenderError(
3052                             "Unable to render top file. No targets found."
3053                         )
3054         return top
3055     def _merge_tops_same(self, tops):
3056         top = DefaultOrderedDict(OrderedDict)
3057         for cenv, ctops in tops.items():
3058             if all([x == {} for x in ctops]):
3059                 default_top = self.opts["default_top"]
3060                 fallback_tops = tops.get(default_top, [])
3061                 if all([x == {} for x in fallback_tops]):
3062                     log.error(
3063                         "The '%s' saltenv has no top file, and the fallback "
3064                         "saltenv specified by default_top (%s) also has no "
3065                         "top file",
3066                         cenv,
3067                         default_top,
3068                     )
3069                     continue
3070                 for ctop in fallback_tops:
3071                     for saltenv, targets in ctop.items():
3072                         if saltenv != cenv:
3073                             continue
3074                         log.debug(
3075                             "The '%s' saltenv has no top file, using the "
3076                             "default_top saltenv (%s)",
3077                             cenv,
3078                             default_top,
3079                         )
3080                         for tgt in targets:
3081                             top[saltenv][tgt] = ctop[saltenv][tgt]
3082                         break
3083                     else:
3084                         log.error(
3085                             "The '%s' saltenv has no top file, and no "
3086                             "matches were found in the top file for the "
3087                             "default_top saltenv (%s)",
3088                             cenv,
3089                             default_top,
3090                         )
3091                 continue
3092             else:
3093                 for ctop in ctops:
3094                     for saltenv, targets in ctop.items():
3095                         if saltenv == "include":
3096                             continue
3097                         elif saltenv != cenv:
3098                             log.debug(
3099                                 "Section for saltenv '%s' in the '%s' "
3100                                 "saltenv's top file will be ignored, as the "
3101                                 "top_file_merging_strategy is set to 'same' "
3102                                 "and the saltenvs do not match",
3103                                 saltenv,
3104                                 cenv,
3105                             )
3106                             continue
3107                         try:
3108                             for tgt in targets:
3109                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3110                         except TypeError:
3111                             raise SaltRenderError(
3112                                 "Unable to render top file. No targets found."
3113                             )
3114         return top
3115     def _merge_tops_merge_all(self, tops):
3116         def _read_tgt(tgt):
3117             match_type = None
3118             states = []
3119             for item in tgt:
3120                 if isinstance(item, dict):
3121                     match_type = item
3122                 if isinstance(item, str):
3123                     states.append(item)
3124             return match_type, states
3125         top = DefaultOrderedDict(OrderedDict)
3126         for ctops in tops.values():
3127             for ctop in ctops:
3128                 for saltenv, targets in ctop.items():
3129                     if saltenv == "include":
3130                         continue
3131                     try:
3132                         for tgt in targets:
3133                             if tgt not in top[saltenv]:
3134                                 top[saltenv][tgt] = ctop[saltenv][tgt]
3135                                 continue
3136                             m_type1, m_states1 = _read_tgt(top[saltenv][tgt])
3137                             m_type2, m_states2 = _read_tgt(ctop[saltenv][tgt])
3138                             merged = []
3139                             match_type = m_type2 or m_type1
3140                             if match_type is not None:
3141                                 merged.append(match_type)
3142                             merged.extend(m_states1)
3143                             merged.extend([x for x in m_states2 if x not in merged])
3144                             top[saltenv][tgt] = merged
3145                     except TypeError:
3146                         raise SaltRenderError(
3147                             "Unable to render top file. No targets found."
3148                         )
3149         return top
3150     def verify_tops(self, tops):
3151         errors = []
3152         if not isinstance(tops, dict):
3153             errors.append("Top data was not formed as a dict")
3154             return errors
3155         for saltenv, matches in tops.items():
3156             if saltenv == "include":
3157                 continue
3158             if not isinstance(saltenv, str):
3159                 errors.append(
3160                     "Environment {} in top file is not formed as a string".format(
3161                         saltenv
3162                     )
3163                 )
3164             if saltenv == "":
3165                 errors.append("Empty saltenv statement in top file")
3166             if not isinstance(matches, dict):
3167                 errors.append(
3168                     "The top file matches for saltenv {} are not "
3169                     "formatted as a dict".format(saltenv)
3170                 )
3171             for slsmods in matches.values():
3172                 if not isinstance(slsmods, list):
3173                     errors.append(
3174                         "Malformed topfile (state declarations not formed as a list)"
3175                     )
3176                     continue
3177                 for slsmod in slsmods:
3178                     if isinstance(slsmod, dict):
3179                         for val in slsmod.values():
3180                             if not val:
3181                                 errors.append(
3182                                     "Improperly formatted top file matcher "
3183                                     "in saltenv {}: {} file".format(slsmod, val)
3184                                 )
3185                     elif isinstance(slsmod, str):
3186                         if not slsmod:
3187                             errors.append(
3188                                 "Environment {} contains an empty sls index".format(
3189                                     saltenv
3190                                 )
3191                             )
3192         return errors
3193     def get_top(self):
3194         try:
3195             tops = self.get_tops()
3196         except SaltRenderError as err:
3197             log.error("Unable to render top file: %s", err.error)
3198             return {}
3199         return self.merge_tops(tops)
3200     def top_matches(self, top):
3201         matches = DefaultOrderedDict(OrderedDict)
3202         for saltenv, body in top.items():
3203             if self.opts["saltenv"]:
3204                 if saltenv != self.opts["saltenv"]:
3205                     continue
3206             for match, data in body.items():
3207                 def _filter_matches(_match, _data, _opts):
3208                     if isinstance(_data, str):
3209                         _data = [_data]
3210                     if self.matchers["confirm_top.confirm_top"](_match, _data, _opts):
3211                         if saltenv not in matches:
3212                             matches[saltenv] = []
3213                         for item in _data:
3214                             if "subfilter" in item:
3215                                 _tmpdata = item.pop("subfilter")
3216                                 for match, data in _tmpdata.items():
3217                                     _filter_matches(match, data, _opts)
3218                             if isinstance(item, str):
3219                                 matches[saltenv].append(item)
3220                             elif isinstance(item, dict):
3221                                 env_key, inc_sls = item.popitem()
3222                                 if env_key not in self.avail:
3223                                     continue
3224                                 if env_key not in matches:
3225                                     matches[env_key] = []
3226                                 matches[env_key].append(inc_sls)
3227                 _filter_matches(match, data, self.opts["nodegroups"])
3228         ext_matches = self._master_tops()
3229         for saltenv in ext_matches:
3230             top_file_matches = matches.get(saltenv, [])
3231             if self.opts.get("master_tops_first"):
3232                 first = ext_matches[saltenv]
3233                 second = top_file_matches
3234             else:
3235                 first = top_file_matches
3236                 second = ext_matches[saltenv]
3237             matches[saltenv] = first + [x for x in second if x not in first]
3238         return matches
3239     def _master_tops(self):
3240         return self.client.master_tops()
3241     def load_dynamic(self, matches):
3242         if not self.opts["autoload_dynamic_modules"]:
3243             return
3244         syncd = self.state.functions["saltutil.sync_all"](list(matches), refresh=False)
3245         if syncd["grains"]:
3246             self.opts["grains"] = salt.loader.grains(self.opts)
3247             self.state.opts["pillar"] = self.state._gather_pillar()
3248         self.state.module_refresh()
3249     def render_state(self, sls, saltenv, mods, matches, local=False, context=None):
3250         errors = []
3251         if not local:
3252             state_data = self.client.get_state(sls, saltenv)
3253             fn_ = state_data.get("dest", False)
3254         else:
3255             fn_ = sls
3256             if not os.path.isfile(fn_):
3257                 errors.append(
3258                     "Specified SLS {} on local filesystem cannot be found.".format(sls)
3259                 )
3260         state = None
3261         if not fn_:
3262             errors.append(
3263                 "Specified SLS {} in saltenv {} is not "
3264                 "available on the salt master or through a configured "
3265                 "fileserver".format(sls, saltenv)
3266             )
3267         else:
3268             try:
3269                 state = compile_template(
3270                     fn_,
3271                     self.state.rend,
3272                     self.state.opts["renderer"],
3273                     self.state.opts["renderer_blacklist"],
3274                     self.state.opts["renderer_whitelist"],
3275                     saltenv,
3276                     sls,
3277                     rendered_sls=mods,
3278                     context=context,
3279                 )
3280             except SaltRenderError as exc:
3281                 msg = "Rendering SLS '{}:{}' failed: {}".format(saltenv, sls, exc)
3282                 log.critical(msg)
3283                 errors.append(msg)
3284             except Exception as exc:  # pylint: disable=broad-except
3285                 msg = "Rendering SLS {} failed, render error: {}".format(sls, exc)
3286                 log.critical(
3287                     msg,
3288                     exc_info_on_loglevel=logging.DEBUG,
3289                 )
3290                 errors.append("{}\n{}".format(msg, traceback.format_exc()))
3291             try:
3292                 mods.add("{}:{}".format(saltenv, sls))
3293             except AttributeError:
3294                 pass
3295         if state:
3296             if not isinstance(state, dict):
3297                 errors.append("SLS {} does not render to a dictionary".format(sls))
3298             else:
3299                 include = []
3300                 if "include" in state:
3301                     if not isinstance(state["include"], list):
3302                         err = (
3303                             "Include Declaration in SLS {} is not formed "
3304                             "as a list".format(sls)
3305                         )
3306                         errors.append(err)
3307                     else:
3308                         include = state.pop("include")
3309                 self._handle_extend(state, sls, saltenv, errors)
3310                 self._handle_exclude(state, sls, saltenv, errors)
3311                 self._handle_state_decls(state, sls, saltenv, errors)
3312                 for inc_sls in include:
3313                     xenv_key = "_xenv"
3314                     if isinstance(inc_sls, dict):
3315                         env_key, inc_sls = inc_sls.popitem()
3316                     else:
3317                         env_key = saltenv
3318                     if env_key not in self.avail and "__env__" not in self.avail:
3319                         msg = (
3320                             "Nonexistent saltenv '{}' found in include "
3321                             "of '{}' within SLS '{}:{}'".format(
3322                                 env_key, inc_sls, saltenv, sls
3323                             )
3324                         )
3325                         log.error(msg)
3326                         errors.append(msg)
3327                         continue
3328                     if inc_sls.startswith("."):
3329                         match = re.match(r"^(\.+)(.*)$", inc_sls)
3330                         if match:
3331                             levels, include = match.groups()
3332                         else:
3333                             msg = (
3334                                 "Badly formatted include {} found in include "
3335                                 "in SLS '{}:{}'".format(inc_sls, saltenv, sls)
3336                             )
3337                             log.error(msg)
3338                             errors.append(msg)
3339                             continue
3340                         level_count = len(levels)
3341                         p_comps = sls.split(".")
3342                         if state_data.get("source", "").endswith("/init.sls"):
3343                             p_comps.append("init")
3344                         if level_count &gt; len(p_comps):
3345                             msg = (
3346                                 "Attempted relative include of '{}' "
3347                                 "within SLS '{}:{}' "
3348                                 "goes beyond top level package ".format(
3349                                     inc_sls, saltenv, sls
3350                                 )
3351                             )
3352                             log.error(msg)
3353                             errors.append(msg)
3354                             continue
3355                         inc_sls = ".".join(p_comps[:-level_count] + [include])
3356                     if env_key != xenv_key:
3357                         if matches is None:
3358                             matches = []
3359                         if env_key in matches or fnmatch.filter(
3360                             self.avail[env_key], inc_sls
3361                         ):
3362                             resolved_envs = [env_key]
3363                         else:
3364                             resolved_envs = []
3365                     else:
3366                         resolved_envs = [
3367                             aenv
3368                             for aenv in matches
3369                             if fnmatch.filter(self.avail[aenv], inc_sls)
3370                         ]
3371                     if len(resolved_envs) == 1 or saltenv in resolved_envs:
3372                         sls_targets = fnmatch.filter(self.avail[saltenv], inc_sls) or [
3373                             inc_sls
3374                         ]
3375                         for sls_target in sls_targets:
3376                             r_env = (
3377                                 resolved_envs[0] if len(resolved_envs) == 1 else saltenv
3378                             )
3379                             mod_tgt = "{}:{}".format(r_env, sls_target)
3380                             if mod_tgt not in mods:
3381                                 nstate, err = self.render_state(
3382                                     sls_target, r_env, mods, matches
3383                                 )
3384                                 if nstate:
3385                                     self.merge_included_states(state, nstate, errors)
3386                                     state.update(nstate)
3387                                 if err:
3388                                     errors.extend(err)
3389                     else:
3390                         msg = ""
3391                         if not resolved_envs:
3392                             msg = (
3393                                 "Unknown include: Specified SLS {}: {} is not available"
3394                                 " on the salt master in saltenv(s): {} ".format(
3395                                     env_key,
3396                                     inc_sls,
3397                                     ", ".join(matches)
3398                                     if env_key == xenv_key
3399                                     else env_key,
3400                                 )
3401                             )
3402                         elif len(resolved_envs) &gt; 1:
3403                             msg = (
3404                                 "Ambiguous include: Specified SLS {}: {} is available"
3405                                 " on the salt master in multiple available saltenvs: {}".format(
3406                                     env_key, inc_sls, ", ".join(resolved_envs)
3407                                 )
3408                             )
3409                         log.critical(msg)
3410                         errors.append(msg)
3411                 try:
3412                     self._handle_iorder(state)
3413                 except TypeError:
3414                     log.critical("Could not render SLS %s. Syntax error detected.", sls)
3415         else:
3416             state = {}
3417         return state, errors
3418     def _handle_iorder(self, state):
3419         if self.opts["state_auto_order"]:
3420             for name in state:
3421                 for s_dec in state[name]:
3422                     if not isinstance(s_dec, str):
3423                         continue
3424                     if not isinstance(state[name], dict):
3425                         continue
3426                     if not isinstance(state[name][s_dec], list):
3427                         continue
3428                     found = False
3429                     if s_dec.startswith("_"):
3430                         continue
3431                     for arg in state[name][s_dec]:
3432                         if isinstance(arg, dict):
3433                             if len(arg) &gt; 0:
3434                                 if next(iter(arg.keys())) == "order":
3435                                     found = True
3436                     if not found:
3437                         if not isinstance(state[name][s_dec], list):
3438                             continue
3439                         state[name][s_dec].append({"order": self.iorder})
3440                         self.iorder += 1
3441         return state
3442     def _handle_state_decls(self, state, sls, saltenv, errors):
3443         for name in state:
3444             if not isinstance(state[name], dict):
3445                 if name == "__extend__":
3446                     continue
3447                 if name == "__exclude__":
3448                     continue
3449                 if isinstance(state[name], str):
3450                     if "." in state[name]:
3451                         comps = state[name].split(".")
3452                         state[name] = {
3453                             "__sls__": sls,
3454                             "__env__": saltenv,
3455                             comps[0]: [comps[1]],
3456                         }
3457                         continue
3458                 errors.append("ID {} in SLS {} is not a dictionary".format(name, sls))
3459                 continue
3460             skeys = set()
3461             for key in list(state[name]):
3462                 if key.startswith("_"):
3463                     continue
3464                 if not isinstance(state[name][key], list):
3465                     continue
3466                 if "." in key:
3467                     comps = key.split(".")
3468                     if comps[0] in skeys:
3469                         errors.append(
3470                             "ID '{}' in SLS '{}' contains multiple state "
3471                             "declarations of the same type".format(name, sls)
3472                         )
3473                         continue
3474                     state[name][comps[0]] = state[name].pop(key)
3475                     state[name][comps[0]].append(comps[1])
3476                     skeys.add(comps[0])
3477                     continue
3478                 skeys.add(key)
3479             if "__sls__" not in state[name]:
3480                 state[name]["__sls__"] = sls
3481             if "__env__" not in state[name]:
3482                 state[name]["__env__"] = saltenv
3483     def _handle_extend(self, state, sls, saltenv, errors):
3484         if "extend" in state:
3485             ext = state.pop("extend")
3486             if not isinstance(ext, dict):
3487                 errors.append(
3488                     "Extension value in SLS '{}' is not a dictionary".format(sls)
3489                 )
3490                 return
3491             for name in ext:
3492                 if not isinstance(ext[name], dict):
3493                     errors.append(
3494                         "Extension name '{}' in SLS '{}' is not a dictionary".format(
3495                             name, sls
3496                         )
3497                     )
3498                     continue
3499                 if "__sls__" not in ext[name]:
3500                     ext[name]["__sls__"] = sls
3501                 if "__env__" not in ext[name]:
3502                     ext[name]["__env__"] = saltenv
3503                 for key in list(ext[name]):
3504                     if key.startswith("_"):
3505                         continue
3506                     if not isinstance(ext[name][key], list):
3507                         continue
3508                     if "." in key:
3509                         comps = key.split(".")
3510                         ext[name][comps[0]] = ext[name].pop(key)
3511                         ext[name][comps[0]].append(comps[1])
3512             state.setdefault("__extend__", []).append(ext)
3513     def _handle_exclude(self, state, sls, saltenv, errors):
3514         if "exclude" in state:
3515             exc = state.pop("exclude")
3516             if not isinstance(exc, list):
3517                 err = "Exclude Declaration in SLS {} is not formed as a list".format(
3518                     sls
3519                 )
3520                 errors.append(err)
3521             state.setdefault("__exclude__", []).extend(exc)
3522     def render_highstate(self, matches, context=None):
3523         highstate = self.building_highstate
3524         all_errors = []
3525         mods = set()
3526         statefiles = []
3527         for saltenv, states in matches.items():
3528             for sls_match in states:
3529                 if saltenv in self.avail:
3530                     statefiles = fnmatch.filter(self.avail[saltenv], sls_match)
3531                 elif "__env__" in self.avail:
3532                     statefiles = fnmatch.filter(self.avail["__env__"], sls_match)
3533                 else:
3534                     all_errors.append(
3535                         "No matching salt environment for environment "
3536                         "'{}' found".format(saltenv)
3537                     )
3538                 if not statefiles:
3539                     statefiles = [sls_match]
3540                 for sls in statefiles:
3541                     r_env = "{}:{}".format(saltenv, sls)
3542                     if r_env in mods:
3543                         continue
3544                     state, errors = self.render_state(
3545                         sls, saltenv, mods, matches, context=context
3546                     )
3547                     if state:
3548                         self.merge_included_states(highstate, state, errors)
3549                     for i, error in enumerate(errors[:]):
3550                         if "is not available" in error:
3551                             this_sls = "SLS {} in saltenv".format(sls_match)
3552                             if this_sls in error:
3553                                 errors[
3554                                     i
3555                                 ] = "No matching sls found for '{}' in env '{}'".format(
3556                                     sls_match, saltenv
3557                                 )
3558                     all_errors.extend(errors)
3559         self.clean_duplicate_extends(highstate)
3560         return highstate, all_errors
3561     def clean_duplicate_extends(self, highstate):
3562         if "__extend__" in highstate:
3563             highext = []
3564             for items in (ext.items() for ext in highstate["__extend__"]):
3565                 for item in items:
3566                     if item not in highext:
3567                         highext.append(item)
3568             highstate["__extend__"] = [{t[0]: t[1]} for t in highext]
3569     def merge_included_states(self, highstate, state, errors):
3570         if "__extend__" in state:
3571             highstate.setdefault("__extend__", []).extend(state.pop("__extend__"))
3572         if "__exclude__" in state:
3573             highstate.setdefault("__exclude__", []).extend(state.pop("__exclude__"))
3574         for id_ in state:
3575             if id_ in highstate:
3576                 if highstate[id_] != state[id_]:
3577                     errors.append(
3578                         "Detected conflicting IDs, SLS"
3579                         " IDs need to be globally unique.\n    The"
3580                         " conflicting ID is '{}' and is found in SLS"
3581                         " '{}:{}' and SLS '{}:{}'".format(
3582                             id_,
3583                             highstate[id_]["__env__"],
3584                             highstate[id_]["__sls__"],
3585                             state[id_]["__env__"],
3586                             state[id_]["__sls__"],
3587                         )
3588                     )
3589         try:
3590             highstate.update(state)
3591         except ValueError:
3592             errors.append("Error when rendering state with contents: {}".format(state))
3593     def _check_pillar(self, force=False):
3594         if force:
3595             return True
3596         if "_errors" in self.state.opts["pillar"]:
3597             return False
3598         return True
3599     def matches_whitelist(self, matches, whitelist):
3600         if not whitelist:
3601             return matches
3602         ret_matches = {}
3603         if not isinstance(whitelist, list):
3604             whitelist = whitelist.split(",")
3605         for env in matches:
3606 <a name="7"></a>            for sls in matches[env]:
3607                 if sls in whitelist:
3608                     ret_matches[env] = ret_matches[env] if env in ret_matches else []
3609                     ret_matches[env].append(sl<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>s)
3610         return ret_matches
3611     def call_highstate(
3612         self,
3613         exclude=None,
3614         cache=None,
3615         cache_name="highstate",
3616         force=False,
3617         whitelist=None,
3618         orchestration_jid=None,
3619     ):
3620         tag_name = "no_|-states_|-states_|-None"
3621         ret =</b></font> {
3622             tag_name: {
3623                 "result": False,
3624                 "comment": "No states found for this minion",
3625                 "name": "No States",
3626                 "changes": {},
3627                 "__run_num__": 0,
3628             }
3629         }
3630         cfn = os.path.join(self.opts["cachedir"], "{}.cache.p".format(cache_name))
3631         if cache:
3632             if os.path.isfile(cfn):
3633                 with salt.utils.files.fopen(cfn, "rb") as fp_:
3634                     high = salt.payload.load(fp_)
3635                     return self.state.call_high(high, orchestration_jid)
3636         err = []
3637         try:
3638             top = self.get_top()
3639         except SaltRenderError as err:
3640             ret[tag_name]["comment"] = "Unable to render top file: "
3641             ret[tag_name]["comment"] += str(err.error)
3642             return ret
3643         except Exception:  # pylint: disable=broad-except
3644             trb = traceback.format_exc()
3645             err.append(trb)
3646             return err
3647         err += self.verify_tops(top)
3648         matches = self.top_matches(top)
3649         if not matches:
3650             msg = (
3651                 "No Top file or master_tops data matches found. Please see "
3652                 "master log for details."
3653             )
3654             ret[tag_name]["comment"] = msg
3655             return ret
3656         matches = self.matches_whitelist(matches, whitelist)
3657         self.load_dynamic(matches)
3658         if not self._check_pillar(force):
3659             err += ["Pillar failed to render with the following messages:"]
3660             err += self.state.opts["pillar"]["_errors"]
3661         else:
3662             high, errors = self.render_highstate(matches)
3663             if exclude:
3664                 if isinstance(exclude, str):
3665                     exclude = exclude.split(",")
3666                 if "__exclude__" in high:
3667                     high["__exclude__"].extend(exclude)
3668                 else:
3669                     high["__exclude__"] = exclude
3670             err += errors
3671         if err:
3672             return err
3673         if not high:
3674             return ret
3675         with salt.utils.files.set_umask(0o077):
3676             try:
3677                 if salt.utils.platform.is_windows():
3678                     self.state.functions["cmd.run"](
3679                         ["attrib", "-R", cfn],
3680                         python_shell=False,
3681                         output_loglevel="quiet",
3682                     )
3683                 with salt.utils.files.fopen(cfn, "w+b") as fp_:
3684                     try:
3685                         salt.payload.dump(high, fp_)
3686                     except TypeError:
3687                         pass
3688             except OSError:
3689                 log.error('Unable to write to "state.highstate" cache file %s', cfn)
3690         return self.state.call_high(high, orchestration_jid)
3691     def compile_highstate(self):
3692         err = []
3693         top = self.get_top()
3694         err += self.verify_tops(top)
3695         matches = self.top_matches(top)
3696         high, errors = self.render_highstate(matches)
3697         err += errors
3698         if err:
3699             return err
3700         return high
3701     def compile_low_chunks(self):
3702         top = self.get_top()
3703         matches = self.top_matches(top)
3704         high, errors = self.render_highstate(matches)
3705         high, ext_errors = self.state.reconcile_extend(high)
3706         errors += ext_errors
3707         errors += self.state.verify_high(high)
3708         high, req_in_errors = self.state.requisite_in(high)
3709         errors += req_in_errors
3710         high = self.state.apply_exclude(high)
3711         if errors:
3712             return errors
3713         chunks = self.state.compile_high_data(high)
3714         return chunks
3715     def compile_state_usage(self):
3716         err = []
3717         top = self.get_top()
3718         err += self.verify_tops(top)
3719         if err:
3720             return err
3721         matches = self.top_matches(top)
3722         state_usage = {}
3723         for saltenv, states in self.avail.items():
3724             env_usage = {
3725                 "used": [],
3726                 "unused": [],
3727                 "count_all": 0,
3728                 "count_used": 0,
3729                 "count_unused": 0,
3730             }
3731             env_matches = matches.get(saltenv, [])
3732             for state in states:
3733                 env_usage["count_all"] += 1
3734                 if state in env_matches:
3735                     env_usage["count_used"] += 1
3736                     env_usage["used"].append(state)
3737                 else:
3738                     env_usage["count_unused"] += 1
3739                     env_usage["unused"].append(state)
3740             state_usage[saltenv] = env_usage
3741         return state_usage
3742     def destroy(self):
3743         raise NotImplementedError
3744     def __enter__(self):
3745         return self
3746     def __exit__(self, *_):
3747         self.destroy()
3748 class HighState(BaseHighState):
3749     stack = []
3750     def __init__(
3751         self,
3752         opts,
3753         pillar_override=None,
3754         jid=None,
3755         pillar_enc=None,
3756         proxy=None,
3757         context=None,
3758         mocked=False,
3759 <a name="3"></a>        loader="states",
3760         initial_pillar=None,
3761     ):
3762         self<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.opts = opts
3763         self.client = salt.fileclient.get_file_client(self.opts)
3764         BaseHighState.__init__(self, opts)
3765         self.state =</b></font> State(
3766             self.opts,
3767             pillar_override,
3768             jid,
3769             pillar_enc,
3770             proxy=proxy,
3771             context=context,
3772             mocked=mocked,
3773             loader=loader,
3774             initial_pillar=initial_pillar,
3775         )
3776         self.matchers = salt.loader.matchers(self.opts)
3777         self.proxy = proxy
3778         self._pydsl_all_decls = {}
3779         self._pydsl_render_stack = []
3780     def push_active(self):
3781         self.stack.append(self)
3782     @classmethod
3783     def clear_active(cls):
3784         cls.stack = []
3785     @classmethod
3786     def pop_active(cls):
3787         cls.stack.pop()
3788     @classmethod
3789     def get_active(cls):
3790         try:
3791             return cls.stack[-1]
3792         except IndexError:
3793             return None
3794     def destroy(self):
3795         self.client.destroy()
3796     def __enter__(self):
3797         return self
3798     def __exit__(self, *_):
3799         self.destroy()
3800 class MasterState(State):
3801     def __init__(self, opts, minion):
3802         State.__init__(self, opts)
3803     def load_modules(self, data=None, proxy=None):
3804         log.info("Loading fresh modules for state activity")
3805         self.functions = salt.client.FunctionWrapper(self.opts, self.opts["id"])
3806         self.utils = salt.loader.utils(self.opts)
3807         self.serializers = salt.loader.serializers(self.opts)
3808         self.states = salt.loader<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.states(
3809             self.opts, self.functions, self.utils, self.serializers
3810         )
3811         self.rend = salt.loader.render(
3812             self.</b></font>opts, self.functions, states=self.states, context=self.state_con
3813         )
3814 class MasterHighState(HighState):
3815     def __init__(self, master_opts, minion_opts, grains, id_, saltenv=None):
3816         opts = copy.deepcopy(minion_opts)
3817         opts["file_client"] = "local"
3818         opts["file_roots"] = master_opts["master_roots"]
3819         opts["renderer"] = master_opts["renderer"]
3820         opts["state_top"] = master_opts["state_top"]
3821         opts["id"] = id_
3822         opts["grains"] = grains
3823         HighState.__init__(self, opts)
3824 class RemoteHighState:
3825     def __init__(self, opts, grains):
3826         self.opts = opts
3827         self.grains = grains
3828         self.channel = salt.channel.client.ReqChannel.factory(self.opts["master_uri"])
3829         self._closing = False
3830     def compile_master(self):
3831         load = {"grains": self.grains, "opts": self.opts, "cmd": "_master_state"}
3832         try:
3833             return self.channel.send(load, tries=3, timeout=72000)
3834         except SaltReqTimeoutError:
3835             return {}
3836     def destroy(self):
3837         if self._closing:
3838             return
3839         self._closing = True
3840         self.channel.close()
3841     def __del__(self):
3842         self.destroy()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
