<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for win_update.py & state_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for win_update.py & state_1.py
      </h3>
      <h1 align="center">
        2.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>win_update.py (9.501411%)<TH>state_1.py (1.3687491%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#0',2,'match147349-1.html#0',3)" NAME="0">(166-171)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#0',2,'match147349-1.html#0',3)" NAME="0">(759-764)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#1',2,'match147349-1.html#1',3)" NAME="1">(544-552)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#1',2,'match147349-1.html#1',3)" NAME="1">(2002-2008)</A><TD ALIGN=center><FONT COLOR="#dd0000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#2',2,'match147349-1.html#2',3)" NAME="2">(234-237)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#2',2,'match147349-1.html#2',3)" NAME="2">(2859-2863)</A><TD ALIGN=center><FONT COLOR="#dd0000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#3',2,'match147349-1.html#3',3)" NAME="3">(1074-1079)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#3',2,'match147349-1.html#3',3)" NAME="3">(4668-4671)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#4',2,'match147349-1.html#4',3)" NAME="4">(850-855)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#4',2,'match147349-1.html#4',3)" NAME="4">(2257-2262)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#5',2,'match147349-1.html#5',3)" NAME="5">(751-753)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#5',2,'match147349-1.html#5',3)" NAME="5">(4745-4749)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#6',2,'match147349-1.html#6',3)" NAME="6">(685-690)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#6',2,'match147349-1.html#6',3)" NAME="6">(3020-3022)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match147349-0.html#7',2,'match147349-1.html#7',3)" NAME="7">(437-450)<TD><A HREF="javascript:ZweiFrames('match147349-0.html#7',2,'match147349-1.html#7',3)" NAME="7">(4462-4479)</A><TD ALIGN=center><FONT COLOR="#cc0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_update.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Classes for working with Windows Update Agent
&quot;&quot;&quot;
import logging
import subprocess

import salt.utils.args
import salt.utils.data
import salt.utils.winapi
from salt.exceptions import CommandExecutionError

try:
    import win32com.client
    import pywintypes

    HAS_PYWIN32 = True
except ImportError:
    HAS_PYWIN32 = False

log = logging.getLogger(__name__)

REBOOT_BEHAVIOR = {
    0: &quot;Never Requires Reboot&quot;,
    1: &quot;Always Requires Reboot&quot;,
    2: &quot;Can Require Reboot&quot;,
}

__virtualname__ = &quot;win_update&quot;


def __virtual__():
    if not salt.utils.platform.is_windows():
        return False, &quot;win_update: Only available on Windows&quot;
    if not HAS_PYWIN32:
        return False, &quot;win_update: Missing pywin32&quot;
    return __virtualname__


class Updates:
    &quot;&quot;&quot;
    Wrapper around the 'Microsoft.Update.UpdateColl' instance
    Adds the list and summary functions. For use by the WindowUpdateAgent class.

    Code Example:

    .. code-block:: python

        # Create an instance
        updates = Updates()

        # Bind to the collection object
        found = updates.updates

        # This exposes Collections properties and methods
        # https://msdn.microsoft.com/en-us/library/windows/desktop/aa386107(v=vs.85).aspx
        found.Count
        found.Add

        # To use custom functions, use the original instance
        # Return the number of updates inside the collection
        updates.count()

        # Return a list of updates in the collection and details in a dictionary
        updates.list()

        # Return a summary of the contents of the updates collection
        updates.summary()
    &quot;&quot;&quot;

    update_types = {1: &quot;Software&quot;, 2: &quot;Driver&quot;}

    def __init__(self):
        &quot;&quot;&quot;
        Initialize the updates collection. Can be accessed via
        ``Updates.updates``
        &quot;&quot;&quot;
        with salt.utils.winapi.Com():
            self.updates = win32com.client.Dispatch(&quot;Microsoft.Update.UpdateColl&quot;)

    def count(self):
        &quot;&quot;&quot;
        Return how many records are in the Microsoft Update Collection

        Returns:
            int: The number of updates in the collection

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            updates = salt.utils.win_update.Updates()
            updates.count()
        &quot;&quot;&quot;
        return self.updates.Count

    def list(self):
        &quot;&quot;&quot;
        Create a dictionary with the details for the updates in the collection.

        Returns:
            dict: Details about each update

        .. code-block:: cfg

            Dict of Updates:
            {'&lt;GUID&gt;': {
                'Title': &lt;title&gt;,
                'KB': &lt;KB&gt;,
                'GUID': &lt;the globally unique identifier for the update&gt;,
                'Description': &lt;description&gt;,
                'Downloaded': &lt;has the update been downloaded&gt;,
                'Installed': &lt;has the update been installed&gt;,
                'Mandatory': &lt;is the update mandatory&gt;,
                'UserInput': &lt;is user input required&gt;,
                'EULAAccepted': &lt;has the EULA been accepted&gt;,
                'Severity': &lt;update severity&gt;,
                'NeedsReboot': &lt;is the update installed and awaiting reboot&gt;,
                'RebootBehavior': &lt;will the update require a reboot&gt;,
                'Categories': [
                    '&lt;category 1&gt;',
                    '&lt;category 2&gt;',
                    ... ]
            }}

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            updates = salt.utils.win_update.Updates()
            updates.list()
        &quot;&quot;&quot;
        # https://msdn.microsoft.com/en-us/library/windows/desktop/aa386099(v=vs.85).aspx
        if self.count() == 0:
            return &quot;Nothing to return&quot;

        log.debug(&quot;Building a detailed report of the results.&quot;)

        # Build a dictionary containing details for each update
        results = {}
        for update in self.updates:

            # Windows 10 build 2004 introduced some problems with the
            # InstallationBehavior COM Object. See
            # https://github.com/saltstack/salt/issues/57762 for more details.
            # The following 2 try/except blocks will output sane defaults
            try:
                user_input = bool(update.InstallationBehavior.CanRequestUserInput)
            except AttributeError:
                log.debug(
                    &quot;Windows Update: Error reading InstallationBehavior COM Object&quot;
                )
                user_input = False

            try:
                requires_reboot = update.InstallationBehavior.RebootBehavior
            except AttributeError:
                log.debug(
                    &quot;Windows Update: Error reading InstallationBehavior COM Object&quot;
                )
                requires_reboot = 2
<A NAME="0"></A>
            # IUpdate Properties
            # https://docs.microsoft.com/en-us/windows/win32/wua_sdk/iupdate-properties
            results<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match147349-1.html#0',3,'match147349-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[update.Identity.UpdateID] = {
                &quot;guid&quot;: update.Identity.UpdateID,
                &quot;Title&quot;: str(update.Title),
                &quot;Type&quot;: self.update_types[update.Type],
                &quot;Description&quot;: update.Description,
                &quot;Downloaded&quot;: bool(update.</B></FONT>IsDownloaded),
                &quot;Installed&quot;: bool(update.IsInstalled),
                &quot;Mandatory&quot;: bool(update.IsMandatory),
                &quot;EULAAccepted&quot;: bool(update.EulaAccepted),
                &quot;NeedsReboot&quot;: bool(update.RebootRequired),
                &quot;Severity&quot;: str(update.MsrcSeverity),
                &quot;UserInput&quot;: user_input,
                &quot;RebootBehavior&quot;: REBOOT_BEHAVIOR[requires_reboot],
                &quot;KBs&quot;: [&quot;KB&quot; + item for item in update.KBArticleIDs],
                &quot;Categories&quot;: [item.Name for item in update.Categories],
                &quot;SupportUrl&quot;: update.SupportUrl,
            }

        return results

    def summary(self):
        &quot;&quot;&quot;
        Create a dictionary with a summary of the updates in the collection.

        Returns:
            dict: Summary of the contents of the collection

        .. code-block:: cfg

            Summary of Updates:
            {'Total': &lt;total number of updates returned&gt;,
             'Available': &lt;updates that are not downloaded or installed&gt;,
             'Downloaded': &lt;updates that are downloaded but not installed&gt;,
             'Installed': &lt;updates installed (usually 0 unless installed=True)&gt;,
             'Categories': {
                &lt;category 1&gt;: &lt;total for that category&gt;,
                &lt;category 2&gt;: &lt;total for category 2&gt;,
                ... }
            }

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            updates = salt.utils.win_update.Updates()
            updates.summary()
        &quot;&quot;&quot;
        # https://msdn.microsoft.com/en-us/library/windows/desktop/aa386099(v=vs.85).aspx
        if self.count() == 0:
            return &quot;Nothing to return&quot;

        # Build a dictionary containing a summary of updates available
        results = {
            &quot;Total&quot;: 0,
            &quot;Available&quot;: 0,
            &quot;Downloaded&quot;: 0,
            &quot;Installed&quot;: 0,
            &quot;Categories&quot;: {},
            &quot;Severity&quot;: {},
        }

        for update in self.updates:

            # Count the total number of updates available
<A NAME="2"></A>            results[&quot;Total&quot;] += 1

            # Updates available for download
            if not salt<FONT color="#980517"><A HREF="javascript:ZweiFrames('match147349-1.html#2',3,'match147349-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.utils.data.is_true(
                update.IsDownloaded
            ) and not salt.utils.data.is_true(update.IsInstalled):
                results[&quot;Available&quot;] +</B></FONT>= 1

            # Updates downloaded awaiting install
            if salt.utils.data.is_true(
                update.IsDownloaded
            ) and not salt.utils.data.is_true(update.IsInstalled):
                results[&quot;Downloaded&quot;] += 1

            # Updates installed
            if salt.utils.data.is_true(update.IsInstalled):
                results[&quot;Installed&quot;] += 1

            # Add Categories and increment total for each one
            # The sum will be more than the total because each update can have
            # multiple categories
            for category in update.Categories:
                if category.Name in results[&quot;Categories&quot;]:
                    results[&quot;Categories&quot;][category.Name] += 1
                else:
                    results[&quot;Categories&quot;][category.Name] = 1

            # Add Severity Summary
            if update.MsrcSeverity:
                if update.MsrcSeverity in results[&quot;Severity&quot;]:
                    results[&quot;Severity&quot;][update.MsrcSeverity] += 1
                else:
                    results[&quot;Severity&quot;][update.MsrcSeverity] = 1

        return results


class WindowsUpdateAgent:
    &quot;&quot;&quot;
    Class for working with the Windows update agent
    &quot;&quot;&quot;

    # Error codes found at the following site:
    # https://msdn.microsoft.com/en-us/library/windows/desktop/hh968413(v=vs.85).aspx
    # https://technet.microsoft.com/en-us/library/cc720442(v=ws.10).aspx
    fail_codes = {
        -2145107924: &quot;WinHTTP Send/Receive failed: 0x8024402C&quot;,
        -2145124300: &quot;Download failed: 0x80240034&quot;,
        -2145124302: &quot;Invalid search criteria: 0x80240032&quot;,
        -2145124305: &quot;Cancelled by policy: 0x8024002F&quot;,
        -2145124307: &quot;Missing source: 0x8024002D&quot;,
        -2145124308: &quot;Missing source: 0x8024002C&quot;,
        -2145124312: &quot;Uninstall not allowed: 0x80240028&quot;,
        -2145124315: &quot;Prevented by policy: 0x80240025&quot;,
        -2145124316: &quot;No Updates: 0x80240024&quot;,
        -2145124322: &quot;Service being shutdown: 0x8024001E&quot;,
        -2145124325: &quot;Self Update in Progress: 0x8024001B&quot;,
        -2145124327: &quot;Exclusive Install Conflict: 0x80240019&quot;,
        -2145124330: &quot;Install not allowed: 0x80240016&quot;,
        -2145124333: &quot;Duplicate item: 0x80240013&quot;,
        -2145124341: &quot;Operation cancelled: 0x8024000B&quot;,
        -2145124343: &quot;Operation in progress: 0x80240009&quot;,
        -2145124284: &quot;Access Denied: 0x8024044&quot;,
        -2145124283: &quot;Unsupported search scope: 0x80240045&quot;,
        -2147024891: &quot;Access is denied: 0x80070005&quot;,
        -2149843018: &quot;Setup in progress: 0x8024004A&quot;,
        -4292599787: &quot;Install still pending: 0x00242015&quot;,
        -4292607992: &quot;Already downloaded: 0x00240008&quot;,
        -4292607993: &quot;Already uninstalled: 0x00240007&quot;,
        -4292607994: &quot;Already installed: 0x00240006&quot;,
        -4292607995: &quot;Reboot required: 0x00240005&quot;,
    }

    def __init__(self, online=True):
        &quot;&quot;&quot;
        Initialize the session and load all updates into the ``_updates``
        collection. This collection is used by the other class functions instead
        of querying Windows update (expensive).

        Args:

            online (bool):
                Tells the Windows Update Agent go online to update its local
                update database. ``True`` will go online. ``False`` will use the
                local update database as is. Default is ``True``

                .. versionadded:: 3001

        Need to look at the possibility of loading this into ``__context__``
        &quot;&quot;&quot;
        # Initialize the PyCom system
        with salt.utils.winapi.Com():

            # Create a session with the Windows Update Agent
            self._session = win32com.client.Dispatch(&quot;Microsoft.Update.Session&quot;)

            # Create Collection for Updates
            self._updates = win32com.client.Dispatch(&quot;Microsoft.Update.UpdateColl&quot;)

        self.refresh(online=online)

    def updates(self):
        &quot;&quot;&quot;
        Get the contents of ``_updates`` (all updates) and puts them in an
        Updates class to expose the list and summary functions.

        Returns:

            Updates:
                An instance of the Updates class with all updates for the
                system.

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent()
            updates = wua.updates()

            # To get a list
            updates.list()

            # To get a summary
            updates.summary()
        &quot;&quot;&quot;
        updates = Updates()
        found = updates.updates

        for update in self._updates:
            found.Add(update)

        return updates

    def refresh(self, online=True):
        &quot;&quot;&quot;
        Refresh the contents of the ``_updates`` collection. This gets all
        updates in the Windows Update system and loads them into the collection.
        This is the part that is slow.

        Args:

            online (bool):
                Tells the Windows Update Agent go online to update its local
                update database. ``True`` will go online. ``False`` will use the
                local update database as is. Default is ``True``

                .. versionadded:: 3001

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent()
            wua.refresh()
        &quot;&quot;&quot;
        # https://msdn.microsoft.com/en-us/library/windows/desktop/aa386526(v=vs.85).aspx
        search_string = &quot;Type='Software' or Type='Driver'&quot;

        # Create searcher object
        searcher = self._session.CreateUpdateSearcher()
        searcher.Online = online
        self._session.ClientApplicationID = &quot;Salt: Load Updates&quot;

        # Load all updates into the updates collection
        try:
            results = searcher.Search(search_string)
            if results.Updates.Count == 0:
                log.debug(&quot;No Updates found for:\n\t\t%s&quot;, search_string)
                return &quot;No Updates found: {}&quot;.format(search_string)
        except pywintypes.com_error as error:
            # Something happened, raise an error
            hr, msg, exc, arg = error.args  # pylint: disable=W0633
            try:
                failure_code = self.fail_codes[exc[5]]
            except KeyError:
                failure_code = &quot;Unknown Failure: {}&quot;.format(error)

            log.error(&quot;Search Failed: %s\n\t\t%s&quot;, failure_code, search_string)
            raise CommandExecutionError(failure_code)

        self._updates = results.Updates

    def installed(self):
        &quot;&quot;&quot;
        Gets a list of all updates available on the system that have the
        ``IsInstalled`` attribute set to ``True``.

        Returns:

            Updates: An instance of Updates with the results.

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent(online=False)
            installed_updates = wua.installed()
        &quot;&quot;&quot;
        # https://msdn.microsoft.com/en-us/library/windows/desktop/aa386099(v=vs.85).aspx
        updates = Updates()
<A NAME="7"></A>
        for update in self._updates:
            if salt.utils.data.is_true(update.IsInstalled):
                updates.updates.Add(u<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match147349-1.html#7',3,'match147349-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>pdate)

        return updates

    def available(
        self,
        skip_hidden=True,
        skip_installed=True,
        skip_mandatory=False,
        skip_reboot=False,
        software=True,
        drivers=True,
        categories=None,
        severities=</B></FONT>None,
    ):
        &quot;&quot;&quot;
        Gets a list of all updates available on the system that match the passed
        criteria.

        Args:

            skip_hidden (bool):
                Skip hidden updates. Default is ``True``

            skip_installed (bool):
                Skip installed updates. Default is ``True``

            skip_mandatory (bool):
                Skip mandatory updates. Default is ``False``

            skip_reboot (bool):
                Skip updates that can or do require reboot. Default is ``False``

            software (bool):
                Include software updates. Default is ``True``

            drivers (bool):
                Include driver updates. Default is ``True``

            categories (list):
                Include updates that have these categories. Default is none
                (all categories). Categories include the following:

                * Critical Updates
                * Definition Updates
                * Drivers (make sure you set drivers=True)
                * Feature Packs
                * Security Updates
                * Update Rollups
                * Updates
                * Update Rollups
                * Windows 7
                * Windows 8.1
                * Windows 8.1 drivers
                * Windows 8.1 and later drivers
                * Windows Defender

            severities (list):
                Include updates that have these severities. Default is none
                (all severities). Severities include the following:

                * Critical
                * Important

        .. note::

            All updates are either software or driver updates. If both
            ``software`` and ``drivers`` is ``False``, nothing will be returned.

        Returns:

            Updates: An instance of Updates with the results of the search.

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent()

            # Gets all updates and shows a summary
            updates = wua.available()
            updates.summary()

            # Get a list of Critical updates
            updates = wua.available(categories=['Critical Updates'])
            updates.list()
        &quot;&quot;&quot;
        # https://msdn.microsoft.com/en-us/library/windows/desktop/aa386099(v=vs.85).aspx
        updates = Updates()
        found = updates.updates

        for update in self._updates:

            if salt.utils.data.is_true(update.IsHidden) and skip_hidden:
                continue

            if salt.utils.data.is_true(update.IsInstalled) and skip_installed:
                continue

            if salt.utils.data.is_true(update.IsMandatory) and skip_mandatory:
                continue

            # Windows 10 build 2004 introduced some problems with the
<A NAME="1"></A>            # InstallationBehavior COM Object. See
            # https://github.com/saltstack/salt/issues/57762 for more details.
            # The following try/except block will default to True
            <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match147349-1.html#1',3,'match147349-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>try:
                requires_reboot = salt.utils.data.is_true(
                    update.InstallationBehavior.RebootBehavior
                )
            except AttributeError:
                log.debug(
                    &quot;Windows Update: Error reading InstallationBehavior COM Object&quot;
                )
                requires_reboot =</B></FONT> True

            if requires_reboot and skip_reboot:
                continue

            if not software and update.Type == 1:
                continue

            if not drivers and update.Type == 2:
                continue

            if categories is not None:
                match = False
                for category in update.Categories:
                    if category.Name in categories:
                        match = True
                if not match:
                    continue

            if severities is not None:
                if update.MsrcSeverity not in severities:
                    continue

            found.Add(update)

        return updates

    def search(self, search_string):
        &quot;&quot;&quot;
        Search for either a single update or a specific list of updates. GUIDs
        are searched first, then KB numbers, and finally Titles.

        Args:

            search_string (str, list):
                The search string to use to find the update. This can be the
                GUID or KB of the update (preferred). It can also be the full
                Title of the update or any part of the Title. A partial Title
                search is less specific and can return multiple results.

        Returns:
            Updates: An instance of Updates with the results of the search

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent()

            # search for a single update and show its details
            updates = wua.search('KB3194343')
            updates.list()

            # search for a list of updates and show their details
            updates = wua.search(['KB3195432', '12345678-abcd-1234-abcd-1234567890ab'])
            updates.list()
        &quot;&quot;&quot;
        updates = Updates()
        found = updates.updates

        if isinstance(search_string, str):
            search_string = [search_string]

        if isinstance(search_string, int):
            search_string = [str(search_string)]

        for update in self._updates:

            for find in search_string:

                # Search by GUID
                if find == update.Identity.UpdateID:
                    found.Add(update)
                    continue

                # Search by KB
                if find in [&quot;KB&quot; + item for item in update.KBArticleIDs]:
                    found.Add(update)
                    continue

                # Search by KB without the KB in front
                if find in [item for item in update.KBArticleIDs]:
                    found.Add(update)
                    continue

                # Search by Title
                if find in update.Title:
                    found.Add(update)
                    continue

        return updates

    def download(self, updates):
        &quot;&quot;&quot;
        Download the updates passed in the updates collection. Load the updates
        collection using ``search`` or ``available``

        Args:

            updates (Updates):
                An instance of the Updates class containing a the updates to be
                downloaded.

        Returns:
            dict: A dictionary containing the results of the download

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent()

            # Download KB3195454
            updates = wua.search('KB3195454')
            results = wua.download(updates)
        &quot;&quot;&quot;

        # Check for empty list
        if updates.count() == 0:
            ret = {&quot;Success&quot;: False, &quot;Updates&quot;: &quot;Nothing to download&quot;}
            return ret

        # Initialize the downloader object and list collection
        downloader = self._session.CreateUpdateDownloader()
        self._session.ClientApplicationID = &quot;Salt: Download Update&quot;
        with salt.utils.winapi.Com():
            download_list = win32com.client.Dispatch(&quot;Microsoft.Update.UpdateColl&quot;)

<A NAME="6"></A>            ret = {&quot;Updates&quot;: {}}

            # Check for updates that aren't already downloaded
            for update in updates<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match147349-1.html#6',3,'match147349-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.updates:

                # Define uid to keep the lines shorter
                uid = update.Identity.UpdateID
                ret[&quot;Updates&quot;][uid] = {}
                ret[&quot;Updates&quot;][uid][&quot;Title&quot;] = update.</B></FONT>Title
                ret[&quot;Updates&quot;][uid][&quot;AlreadyDownloaded&quot;] = bool(update.IsDownloaded)

                # Accept EULA
                if not salt.utils.data.is_true(update.EulaAccepted):
                    log.debug(&quot;Accepting EULA: %s&quot;, update.Title)
                    update.AcceptEula()  # pylint: disable=W0104

                # Update already downloaded
                if not salt.utils.data.is_true(update.IsDownloaded):
                    log.debug(&quot;To Be Downloaded: %s&quot;, uid)
                    log.debug(&quot;\tTitle: %s&quot;, update.Title)
                    download_list.Add(update)

            # Check the download list
            if download_list.Count == 0:
                ret = {&quot;Success&quot;: True, &quot;Updates&quot;: &quot;Nothing to download&quot;}
                return ret

            # Send the list to the downloader
            downloader.Updates = download_list

            # Download the list
            try:
                log.debug(&quot;Downloading Updates&quot;)
                result = downloader.Download()
            except pywintypes.com_error as error:
                # Something happened, raise an error
                hr, msg, exc, arg = error.args  # pylint: disable=W0633
                try:
                    failure_code = self.fail_codes[exc[5]]
                except KeyError:
                    failure_code = &quot;Unknown Failure: {}&quot;.format(error)

                log.error(&quot;Download Failed: %s&quot;, failure_code)
                raise CommandExecutionError(failure_code)

            # Lookup dictionary
            result_code = {
                0: &quot;Download Not Started&quot;,
                1: &quot;Download In Progress&quot;,
                2: &quot;Download Succeeded&quot;,
                3: &quot;Download Succeeded With Errors&quot;,
                4: &quot;Download Failed&quot;,
                5: &quot;Download Aborted&quot;,
            }

            log.debug(&quot;Download Complete&quot;)
            log.debug(result_code[result.ResultCode])
            ret[&quot;Message&quot;] = result_code[result.ResultCode]

            # Was the download successful?
            if result.ResultCode in [2, 3]:
                log.debug(&quot;Downloaded Successfully&quot;)
                ret[&quot;Success&quot;] = True
            else:
                log.debug(&quot;Download Failed&quot;)
                ret[&quot;Success&quot;] = False
<A NAME="5"></A>
            # Report results for each update
            for i in range(download_list.Count):
                uid = download_list<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match147349-1.html#5',3,'match147349-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.Item(i).Identity.UpdateID
                ret[&quot;Updates&quot;][uid][&quot;Result&quot;] = result_code[
                    result.GetUpdateResult(i).</B></FONT>ResultCode
                ]

        return ret

    def install(self, updates):
        &quot;&quot;&quot;
        Install the updates passed in the updates collection. Load the updates
        collection using the ``search`` or ``available`` functions. If the
        updates need to be downloaded, use the ``download`` function.

        Args:

            updates (Updates):
                An instance of the Updates class containing a the updates to be
                installed.

        Returns:
            dict: A dictionary containing the results of the installation

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent()

            # install KB3195454
            updates = wua.search('KB3195454')
            results = wua.download(updates)
            results = wua.install(updates)
        &quot;&quot;&quot;
        # Check for empty list
        if updates.count() == 0:
            ret = {&quot;Success&quot;: False, &quot;Updates&quot;: &quot;Nothing to install&quot;}
            return ret

        installer = self._session.CreateUpdateInstaller()
        self._session.ClientApplicationID = &quot;Salt: Install Update&quot;
        with salt.utils.winapi.Com():
            install_list = win32com.client.Dispatch(&quot;Microsoft.Update.UpdateColl&quot;)

            ret = {&quot;Updates&quot;: {}}

            # Check for updates that aren't already installed
            for update in updates.updates:

                # Define uid to keep the lines shorter
                uid = update.Identity.UpdateID
                ret[&quot;Updates&quot;][uid] = {}
                ret[&quot;Updates&quot;][uid][&quot;Title&quot;] = update.Title
                ret[&quot;Updates&quot;][uid][&quot;AlreadyInstalled&quot;] = bool(update.IsInstalled)

                # Make sure the update has actually been installed
                if not salt.utils.data.is_true(update.IsInstalled):
                    log.debug(&quot;To Be Installed: %s&quot;, uid)
                    log.debug(&quot;\tTitle: %s&quot;, update.Title)
                    install_list.Add(update)

            # Check the install list
            if install_list.Count == 0:
                ret = {&quot;Success&quot;: True, &quot;Updates&quot;: &quot;Nothing to install&quot;}
                return ret

            # Send the list to the installer
            installer.Updates = install_list

            # Install the list
            try:
                log.debug(&quot;Installing Updates&quot;)
                result = installer.Install()

            except pywintypes.com_error as error:
                # Something happened, raise an error
                hr, msg, exc, arg = error.args  # pylint: disable=W0633
                try:
                    failure_code = self.fail_codes[exc[5]]
                except KeyError:
                    failure_code = &quot;Unknown Failure: {}&quot;.format(error)

                log.error(&quot;Install Failed: %s&quot;, failure_code)
                raise CommandExecutionError(failure_code)

            # Lookup dictionary
            result_code = {
                0: &quot;Installation Not Started&quot;,
                1: &quot;Installation In Progress&quot;,
                2: &quot;Installation Succeeded&quot;,
                3: &quot;Installation Succeeded With Errors&quot;,
                4: &quot;Installation Failed&quot;,
                5: &quot;Installation Aborted&quot;,
            }

            log.debug(&quot;Install Complete&quot;)
<A NAME="4"></A>            log.debug(result_code[result.ResultCode])
            ret[&quot;Message&quot;] = result_code[result.ResultCode]

            if result<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match147349-1.html#4',3,'match147349-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.ResultCode in [2, 3]:
                ret[&quot;Success&quot;] = True
                ret[&quot;NeedsReboot&quot;] = result.RebootRequired
                log.debug(&quot;NeedsReboot: %s&quot;, result.RebootRequired)
            else:
                log.debug(</B></FONT>&quot;Install Failed&quot;)
                ret[&quot;Success&quot;] = False

            for i in range(install_list.Count):
                uid = install_list.Item(i).Identity.UpdateID
                ret[&quot;Updates&quot;][uid][&quot;Result&quot;] = result_code[
                    result.GetUpdateResult(i).ResultCode
                ]
                # Windows 10 build 2004 introduced some problems with the
                # InstallationBehavior COM Object. See
                # https://github.com/saltstack/salt/issues/57762 for more details.
                # The following try/except block will default to 2
                try:
                    reboot_behavior = install_list.Item(
                        i
                    ).InstallationBehavior.RebootBehavior
                except AttributeError:
                    log.debug(
                        &quot;Windows Update: Error reading InstallationBehavior COM Object&quot;
                    )
                    reboot_behavior = 2
                ret[&quot;Updates&quot;][uid][&quot;RebootBehavior&quot;] = REBOOT_BEHAVIOR[reboot_behavior]

        return ret

    def uninstall(self, updates):
        &quot;&quot;&quot;
        Uninstall the updates passed in the updates collection. Load the updates
        collection using the ``search`` or ``available`` functions.

        .. note::

            Starting with Windows 10 the Windows Update Agent is unable to
            uninstall updates. An ``Uninstall Not Allowed`` error is returned.
            If this error is encountered this function will instead attempt to
            use ``dism.exe`` to perform the un-installation. ``dism.exe`` may
            fail to to find the KB number for the package. In that case, removal
            will fail.

        Args:

            updates (Updates):
                An instance of the Updates class containing a the updates to be
                uninstalled.

        Returns:
            dict: A dictionary containing the results of the un-installation

        Code Example:

        .. code-block:: python

            import salt.utils.win_update
            wua = salt.utils.win_update.WindowsUpdateAgent()

            # uninstall KB3195454
            updates = wua.search('KB3195454')
            results = wua.uninstall(updates)
        &quot;&quot;&quot;
        # This doesn't work with the WUA API since Windows 10. It always returns
        # &quot;0x80240028 # Uninstall not allowed&quot;. The full message is: &quot;The update
        # could not be uninstalled because the request did not originate from a
        # Windows Server Update Services (WSUS) server.

        # Check for empty list
        if updates.count() == 0:
            ret = {&quot;Success&quot;: False, &quot;Updates&quot;: &quot;Nothing to uninstall&quot;}
            return ret

        installer = self._session.CreateUpdateInstaller()
        self._session.ClientApplicationID = &quot;Salt: Uninstall Update&quot;
        with salt.utils.winapi.Com():
            uninstall_list = win32com.client.Dispatch(&quot;Microsoft.Update.UpdateColl&quot;)

            ret = {&quot;Updates&quot;: {}}

            # Check for updates that aren't already installed
            for update in updates.updates:

                # Define uid to keep the lines shorter
                uid = update.Identity.UpdateID
                ret[&quot;Updates&quot;][uid] = {}
                ret[&quot;Updates&quot;][uid][&quot;Title&quot;] = update.Title
                ret[&quot;Updates&quot;][uid][&quot;AlreadyUninstalled&quot;] = not bool(update.IsInstalled)

                # Make sure the update has actually been Uninstalled
                if salt.utils.data.is_true(update.IsInstalled):
                    log.debug(&quot;To Be Uninstalled: %s&quot;, uid)
                    log.debug(&quot;\tTitle: %s&quot;, update.Title)
                    uninstall_list.Add(update)

            # Check the install list
            if uninstall_list.Count == 0:
                ret = {&quot;Success&quot;: False, &quot;Updates&quot;: &quot;Nothing to uninstall&quot;}
                return ret

            # Send the list to the installer
            installer.Updates = uninstall_list

            # Uninstall the list
            try:
                log.debug(&quot;Uninstalling Updates&quot;)
                result = installer.Uninstall()

            except pywintypes.com_error as error:
                # Something happened, return error or try using DISM
                hr, msg, exc, arg = error.args  # pylint: disable=W0633
                try:
                    failure_code = self.fail_codes[exc[5]]
                except KeyError:
                    failure_code = &quot;Unknown Failure: {}&quot;.format(error)

                # If &quot;Uninstall Not Allowed&quot; error, try using DISM
                if exc[5] == -2145124312:
                    log.debug(&quot;Uninstall Failed with WUA, attempting with DISM&quot;)
                    try:

                        # Go through each update...
                        for item in uninstall_list:

                            # Look for the KB numbers
                            for kb in item.KBArticleIDs:

                                # Get the list of packages
                                cmd = [&quot;dism&quot;, &quot;/Online&quot;, &quot;/Get-Packages&quot;]
                                pkg_list = self._run(cmd)[0].splitlines()

                                # Find the KB in the pkg_list
                                for item in pkg_list:

                                    # Uninstall if found
                                    if &quot;kb&quot; + kb in item.lower():
                                        pkg = item.split(&quot; : &quot;)[1]

                                        ret[&quot;DismPackage&quot;] = pkg

                                        cmd = [
                                            &quot;dism&quot;,
                                            &quot;/Online&quot;,
                                            &quot;/Remove-Package&quot;,
                                            &quot;/PackageName:{}&quot;.format(pkg),
                                            &quot;/Quiet&quot;,
                                            &quot;/NoRestart&quot;,
                                        ]

                                        self._run(cmd)

                    except CommandExecutionError as exc:
                        log.debug(&quot;Uninstall using DISM failed&quot;)
                        log.debug(&quot;Command: %s&quot;, &quot; &quot;.join(cmd))
                        log.debug(&quot;Error: %s&quot;, exc)
                        raise CommandExecutionError(
                            &quot;Uninstall using DISM failed: {}&quot;.format(exc)
                        )

                    # DISM Uninstall Completed Successfully
                    log.debug(&quot;Uninstall Completed using DISM&quot;)

                    # Populate the return dictionary
                    ret[&quot;Success&quot;] = True
                    ret[&quot;Message&quot;] = &quot;Uninstalled using DISM&quot;
                    ret[&quot;NeedsReboot&quot;] = needs_reboot()
                    log.debug(&quot;NeedsReboot: %s&quot;, ret[&quot;NeedsReboot&quot;])

                    # Refresh the Updates Table
                    self.refresh(online=False)

                    # Check the status of each update
                    for update in self._updates:
                        uid = update.Identity.UpdateID
                        for item in uninstall_list:
                            if item.Identity.UpdateID == uid:
                                if not update.IsInstalled:
                                    ret[&quot;Updates&quot;][uid][
                                        &quot;Result&quot;
                                    ] = &quot;Uninstallation Succeeded&quot;
                                else:
                                    ret[&quot;Updates&quot;][uid][
                                        &quot;Result&quot;
                                    ] = &quot;Uninstallation Failed&quot;
                                # Windows 10 build 2004 introduced some problems with the
                                # InstallationBehavior COM Object. See
                                # https://github.com/saltstack/salt/issues/57762 for more details.
                                # The following try/except block will default to 2
                                try:
                                    requires_reboot = (
                                        update.InstallationBehavior.RebootBehavior
                                    )
                                except AttributeError:
                                    log.debug(
                                        &quot;Windows Update: Error reading&quot;
                                        &quot; InstallationBehavior COM Object&quot;
                                    )
                                    requires_reboot = 2
                                ret[&quot;Updates&quot;][uid][&quot;RebootBehavior&quot;] = REBOOT_BEHAVIOR[
                                    requires_reboot
                                ]

                    return ret

                # Found a different exception, Raise error
                log.error(&quot;Uninstall Failed: %s&quot;, failure_code)
                raise CommandExecutionError(failure_code)

            # Lookup dictionary
            result_code = {
                0: &quot;Uninstallation Not Started&quot;,
                1: &quot;Uninstallation In Progress&quot;,
                2: &quot;Uninstallation Succeeded&quot;,
                3: &quot;Uninstallation Succeeded With Errors&quot;,
                4: &quot;Uninstallation Failed&quot;,
                5: &quot;Uninstallation Aborted&quot;,
            }

            log.debug(&quot;Uninstall Complete&quot;)
            log.debug(result_code[result.ResultCode])
<A NAME="3"></A>            ret[&quot;Message&quot;] = result_code[result.ResultCode]

            if result.ResultCode in [2, 3]:
                ret<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match147349-1.html#3',3,'match147349-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;Success&quot;] = True
                ret[&quot;NeedsReboot&quot;] = result.RebootRequired
                log.debug(&quot;NeedsReboot: %s&quot;, result.RebootRequired)
            else:
                log.debug(&quot;Uninstall Failed&quot;)
                ret[&quot;Success&quot;] =</B></FONT> False

            for i in range(uninstall_list.Count):
                uid = uninstall_list.Item(i).Identity.UpdateID
                ret[&quot;Updates&quot;][uid][&quot;Result&quot;] = result_code[
                    result.GetUpdateResult(i).ResultCode
                ]
                # Windows 10 build 2004 introduced some problems with the
                # InstallationBehavior COM Object. See
                # https://github.com/saltstack/salt/issues/57762 for more details.
                # The following try/except block will default to 2
                try:
                    reboot_behavior = uninstall_list.Item(
                        i
                    ).InstallationBehavior.RebootBehavior
                except AttributeError:
                    log.debug(
                        &quot;Windows Update: Error reading InstallationBehavior COM Object&quot;
                    )
                    reboot_behavior = 2
                ret[&quot;Updates&quot;][uid][&quot;RebootBehavior&quot;] = REBOOT_BEHAVIOR[reboot_behavior]

        return ret

    def _run(self, cmd):
        &quot;&quot;&quot;
        Internal function for running commands. Used by the uninstall function.

        Args:
            cmd (str, list):
                The command to run

        Returns:
            str: The stdout of the command
        &quot;&quot;&quot;

        if isinstance(cmd, str):
            cmd = salt.utils.args.shlex_split(cmd)

        try:
            log.debug(cmd)
            p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return p.communicate()

        except OSError as exc:
            log.debug(&quot;Command Failed: %s&quot;, &quot; &quot;.join(cmd))
            log.debug(&quot;Error: %s&quot;, exc)
            raise CommandExecutionError(exc)


def needs_reboot():
    &quot;&quot;&quot;
    Determines if the system needs to be rebooted.

    Returns:

        bool: ``True`` if the system requires a reboot, ``False`` if not

    CLI Examples:

    .. code-block:: bash

        import salt.utils.win_update

        salt.utils.win_update.needs_reboot()

    &quot;&quot;&quot;
    # Initialize the PyCom system
    with salt.utils.winapi.Com():
        # Create an AutoUpdate object
        try:
            obj_sys = win32com.client.Dispatch(&quot;Microsoft.Update.SystemInfo&quot;)
        except pywintypes.com_error as exc:
            _, msg, _, _ = exc.args
            log.debug(&quot;Failed to create SystemInfo object: %s&quot;, msg)
            return False
        return salt.utils.data.is_true(obj_sys.RebootRequired)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>state_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
The State Compiler is used to execute states in Salt. A state is unlike
an execution module in that instead of just executing a command, it
ensures that a certain state is present on the system.

The data sent to the state calls is as follows:
    { 'state': '&lt;state module name&gt;',
      'fun': '&lt;state function name&gt;',
      'name': '&lt;the name argument passed to all states&gt;'
      'argn': '&lt;arbitrary argument, can have many of these&gt;'
      }
&quot;&quot;&quot;


import copy
import datetime
import fnmatch
import importlib
import logging
import os
import random
import re
import site
import sys
import time
import traceback

import salt.channel.client
import salt.fileclient
import salt.loader
import salt.minion
import salt.pillar
import salt.syspaths as syspaths
import salt.utils.args
import salt.utils.crypt
import salt.utils.data
import salt.utils.decorators.state
import salt.utils.dictupdate
import salt.utils.event
import salt.utils.files
import salt.utils.hashutils
import salt.utils.immutabletypes as immutabletypes
import salt.utils.msgpack
import salt.utils.platform
import salt.utils.process
import salt.utils.url

# Explicit late import to avoid circular import. DO NOT MOVE THIS.
import salt.utils.yamlloader as yamlloader
from salt.exceptions import CommandExecutionError, SaltRenderError, SaltReqTimeoutError
from salt.serializers.msgpack import deserialize as msgpack_deserialize
from salt.serializers.msgpack import serialize as msgpack_serialize
from salt.template import compile_template, compile_template_str
from salt.utils.odict import DefaultOrderedDict, OrderedDict

log = logging.getLogger(__name__)


# These are keywords passed to state module functions which are to be used
# by salt in this state module and not on the actual state module function
STATE_REQUISITE_KEYWORDS = frozenset(
    [
        &quot;onchanges&quot;,
        &quot;onchanges_any&quot;,
        &quot;onfail&quot;,
        &quot;onfail_any&quot;,
        &quot;onfail_all&quot;,
        &quot;onfail_stop&quot;,
        &quot;prereq&quot;,
        &quot;prerequired&quot;,
        &quot;watch&quot;,
        &quot;watch_any&quot;,
        &quot;require&quot;,
        &quot;require_any&quot;,
        &quot;listen&quot;,
    ]
)
STATE_REQUISITE_IN_KEYWORDS = frozenset(
    [&quot;onchanges_in&quot;, &quot;onfail_in&quot;, &quot;prereq_in&quot;, &quot;watch_in&quot;, &quot;require_in&quot;, &quot;listen_in&quot;]
)
STATE_RUNTIME_KEYWORDS = frozenset(
    [
        &quot;fun&quot;,
        &quot;state&quot;,
        &quot;check_cmd&quot;,
        &quot;failhard&quot;,
        &quot;onlyif&quot;,
        &quot;unless&quot;,
        &quot;creates&quot;,
        &quot;retry&quot;,
        &quot;order&quot;,
        &quot;parallel&quot;,
        &quot;prereq&quot;,
        &quot;prereq_in&quot;,
        &quot;prerequired&quot;,
        &quot;reload_modules&quot;,
        &quot;reload_grains&quot;,
        &quot;reload_pillar&quot;,
        &quot;runas&quot;,
        &quot;runas_password&quot;,
        &quot;fire_event&quot;,
        &quot;saltenv&quot;,
        &quot;use&quot;,
        &quot;use_in&quot;,
        &quot;__env__&quot;,
        &quot;__sls__&quot;,
        &quot;__id__&quot;,
        &quot;__orchestration_jid__&quot;,
        &quot;__pub_user&quot;,
        &quot;__pub_arg&quot;,
        &quot;__pub_jid&quot;,
        &quot;__pub_fun&quot;,
        &quot;__pub_tgt&quot;,
        &quot;__pub_ret&quot;,
        &quot;__pub_pid&quot;,
        &quot;__pub_tgt_type&quot;,
        &quot;__prereq__&quot;,
        &quot;__prerequired__&quot;,
    ]
)

STATE_INTERNAL_KEYWORDS = STATE_REQUISITE_KEYWORDS.union(
    STATE_REQUISITE_IN_KEYWORDS
).union(STATE_RUNTIME_KEYWORDS)


def _odict_hashable(self):
    return id(self)


OrderedDict.__hash__ = _odict_hashable


def split_low_tag(tag):
    &quot;&quot;&quot;
    Take a low tag and split it back into the low dict that it came from
    &quot;&quot;&quot;
    state, id_, name, fun = tag.split(&quot;_|-&quot;)

    return {&quot;state&quot;: state, &quot;__id__&quot;: id_, &quot;name&quot;: name, &quot;fun&quot;: fun}


def _gen_tag(low):
    &quot;&quot;&quot;
    Generate the running dict tag string from the low data structure
    &quot;&quot;&quot;
    return &quot;{0[state]}_|-{0[__id__]}_|-{0[name]}_|-{0[fun]}&quot;.format(low)


def _clean_tag(tag):
    &quot;&quot;&quot;
    Make tag name safe for filenames
    &quot;&quot;&quot;
    return salt.utils.files.safe_filename_leaf(tag)


def _l_tag(name, id_):
    low = {
        &quot;name&quot;: &quot;listen_{}&quot;.format(name),
        &quot;__id__&quot;: &quot;listen_{}&quot;.format(id_),
        &quot;state&quot;: &quot;Listen_Error&quot;,
        &quot;fun&quot;: &quot;Listen_Error&quot;,
    }
    return _gen_tag(low)


def _calculate_fake_duration():
    &quot;&quot;&quot;
    Generate a NULL duration for when states do not run
    but we want the results to be consistent.
    &quot;&quot;&quot;
    utc_start_time = datetime.datetime.utcnow()
    local_start_time = utc_start_time - (
        datetime.datetime.utcnow() - datetime.datetime.now()
    )
    utc_finish_time = datetime.datetime.utcnow()
    start_time = local_start_time.time().isoformat()
    delta = utc_finish_time - utc_start_time
    # duration in milliseconds.microseconds
    duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0

    return start_time, duration


def get_accumulator_dir(cachedir):
    &quot;&quot;&quot;
    Return the directory that accumulator data is stored in, creating it if it
    doesn't exist.
    &quot;&quot;&quot;
    fn_ = os.path.join(cachedir, &quot;accumulator&quot;)
    if not os.path.isdir(fn_):
        # accumulator_dir is not present, create it
        os.makedirs(fn_)
    return fn_


def trim_req(req):
    &quot;&quot;&quot;
    Trim any function off of a requisite
    &quot;&quot;&quot;
    reqfirst = next(iter(req))
    if &quot;.&quot; in reqfirst:
        return {reqfirst.split(&quot;.&quot;)[0]: req[reqfirst]}
    return req


def state_args(id_, state, high):
    &quot;&quot;&quot;
    Return a set of the arguments passed to the named state
    &quot;&quot;&quot;
    args = set()
    if id_ not in high:
        return args
    if state not in high[id_]:
        return args
    for item in high[id_][state]:
        if not isinstance(item, dict):
            continue
        if len(item) != 1:
            continue
        args.add(next(iter(item)))
    return args


def find_name(name, state, high, strict=False):
    &quot;&quot;&quot;
    Scan high data for the id referencing the given name and return a list of (IDs, state) tuples that match

    Note: if `state` is sls, then we are looking for all IDs that match the given SLS
    &quot;&quot;&quot;
    ext_id = []
    if strict is False:
        check2 = True
    else:
        check2 = state in high.get(name, {})
    if name in high and check2:
        ext_id.append((name, state))
    # if we are requiring an entire SLS, then we need to add ourselves to everything in that SLS
    elif state == &quot;sls&quot;:
        for nid, item in high.items():
            if item[&quot;__sls__&quot;] == name:
                ext_id.append((nid, next(iter(item))))
    # otherwise we are requiring a single state, lets find it
    else:
        # We need to scan for the name
        for nid in high:
            if state in high[nid]:
                if isinstance(high[nid][state], list):
                    for arg in high[nid][state]:
                        if not isinstance(arg, dict):
                            continue
                        if len(arg) != 1:
                            continue
                        if arg[next(iter(arg))] == name:
                            ext_id.append((nid, state))
    return ext_id


def find_sls_ids(sls, high):
    &quot;&quot;&quot;
    Scan for all ids in the given sls and return them in a dict; {name: state}
    &quot;&quot;&quot;
    ret = []
    for nid, item in high.items():
        try:
            sls_tgt = item[&quot;__sls__&quot;]
        except TypeError:
            if nid != &quot;__exclude__&quot;:
                log.error(
                    &quot;Invalid non-dict item '%s' in high data. Value: %r&quot;, nid, item
                )
            continue
        else:
            if sls_tgt == sls:
                for st_ in item:
                    if st_.startswith(&quot;__&quot;):
                        continue
                    ret.append((nid, st_))
    return ret


def format_log(ret):
    &quot;&quot;&quot;
    Format the state into a log message
    &quot;&quot;&quot;
    msg = &quot;&quot;
    if isinstance(ret, dict):
        # Looks like the ret may be a valid state return
        if &quot;changes&quot; in ret:
            # Yep, looks like a valid state return
            chg = ret[&quot;changes&quot;]
            if not chg:
                if ret[&quot;comment&quot;]:
                    msg = ret[&quot;comment&quot;]
                else:
                    msg = &quot;No changes made for {0[name]}&quot;.format(ret)
            elif isinstance(chg, dict):
                if &quot;diff&quot; in chg:
                    if isinstance(chg[&quot;diff&quot;], str):
                        msg = &quot;File changed:\n{}&quot;.format(chg[&quot;diff&quot;])
                if all([isinstance(x, dict) for x in chg.values()]):
                    if all([(&quot;old&quot; in x and &quot;new&quot; in x) for x in chg.values()]):
                        msg = &quot;Made the following changes:\n&quot;
                        for pkg in chg:
                            old = chg[pkg][&quot;old&quot;]
                            if not old and old not in (False, None):
                                old = &quot;absent&quot;
                            new = chg[pkg][&quot;new&quot;]
                            if not new and new not in (False, None):
                                new = &quot;absent&quot;
                            # This must be able to handle unicode as some package names contain
                            # non-ascii characters like &quot;Français&quot; or &quot;Español&quot;. See Issue #33605.
                            msg += &quot;'{}' changed from '{}' to '{}'\n&quot;.format(
                                pkg, old, new
                            )
            if not msg:
                msg = str(ret[&quot;changes&quot;])
            if ret[&quot;result&quot;] is True or ret[&quot;result&quot;] is None:
                log.info(msg)
            else:
                log.error(msg)
    else:
        # catch unhandled data
        log.info(str(ret))


def master_compile(master_opts, minion_opts, grains, id_, saltenv):
    &quot;&quot;&quot;
    Compile the master side low state data, and build the hidden state file
    &quot;&quot;&quot;
    st_ = MasterHighState(master_opts, minion_opts, grains, id_, saltenv)
    return st_.compile_highstate()


def ishashable(obj):
    try:
        hash(obj)
    except TypeError:
        return False
    return True


def mock_ret(cdata):
    &quot;&quot;&quot;
    Returns a mocked return dict with information about the run, without
    executing the state function
    &quot;&quot;&quot;
    # As this is expanded it should be sent into the execution module
    # layer or it should be turned into a standalone loader system
    if cdata[&quot;args&quot;]:
        name = cdata[&quot;args&quot;][0]
    else:
        name = cdata[&quot;kwargs&quot;][&quot;name&quot;]
    return {
        &quot;name&quot;: name,
        &quot;comment&quot;: &quot;Not called, mocked&quot;,
        &quot;changes&quot;: {},
        &quot;result&quot;: True,
    }


class StateError(Exception):
    &quot;&quot;&quot;
    Custom exception class.
    &quot;&quot;&quot;


class Compiler:
    &quot;&quot;&quot;
    Class used to compile and manage the High Data structure
    &quot;&quot;&quot;

    def __init__(self, opts, renderers):
        self.opts = opts
        self.rend = renderers

    def render_template(self, template, **kwargs):
        &quot;&quot;&quot;
        Enforce the states in a template
        &quot;&quot;&quot;
        high = compile_template(
            template,
            self.rend,
            self.opts[&quot;renderer&quot;],
            self.opts[&quot;renderer_blacklist&quot;],
            self.opts[&quot;renderer_whitelist&quot;],
            **kwargs
        )
        if not high:
            return high
        return self.pad_funcs(high)

    def pad_funcs(self, high):
        &quot;&quot;&quot;
        Turns dot delimited function refs into function strings
        &quot;&quot;&quot;
        for name in high:
            if not isinstance(high[name], dict):
                if isinstance(high[name], str):
                    # Is this is a short state? It needs to be padded!
                    if &quot;.&quot; in high[name]:
                        comps = high[name].split(&quot;.&quot;)
                        if len(comps) &gt;= 2:
                            # Merge the comps
                            comps[1] = &quot;.&quot;.join(comps[1 : len(comps)])
                        high[name] = {
                            # '__sls__': template,
                            # '__env__': None,
                            comps[0]: [comps[1]]
                        }
                        continue
                    continue
            skeys = set()
            for key in sorted(high[name]):
                if key.startswith(&quot;_&quot;):
                    continue
                if not isinstance(high[name][key], list):
                    continue
                if &quot;.&quot; in key:
                    comps = key.split(&quot;.&quot;)
                    if len(comps) &gt;= 2:
                        # Merge the comps
                        comps[1] = &quot;.&quot;.join(comps[1 : len(comps)])
                    # Salt doesn't support state files such as:
                    #
                    # /etc/redis/redis.conf:
                    #   file.managed:
                    #     - user: redis
                    #     - group: redis
                    #     - mode: 644
                    #   file.comment:
                    #     - regex: ^requirepass
                    if comps[0] in skeys:
                        continue
                    high[name][comps[0]] = high[name].pop(key)
                    high[name][comps[0]].append(comps[1])
                    skeys.add(comps[0])
                    continue
                skeys.add(key)
        return high

    def verify_high(self, high):
        &quot;&quot;&quot;
        Verify that the high data is viable and follows the data structure
        &quot;&quot;&quot;
        errors = []
        if not isinstance(high, dict):
            errors.append(&quot;High data is not a dictionary and is invalid&quot;)
        reqs = OrderedDict()
        for name, body in high.items():
            if name.startswith(&quot;__&quot;):
                continue
            if not isinstance(name, str):
                errors.append(
                    &quot;ID '{}' in SLS '{}' is not formed as a string, but is a {}&quot;.format(
                        name, body[&quot;__sls__&quot;], type(name).__name__
                    )
                )
            if not isinstance(body, dict):
                err = &quot;The type {} in {} is not formatted as a dictionary&quot;.format(
                    name, body
                )
                errors.append(err)
                continue
            for state in body:
                if state.startswith(&quot;__&quot;):
                    continue
                if not isinstance(body[state], list):
                    errors.append(
                        &quot;State '{}' in SLS '{}' is not formed as a list&quot;.format(
                            name, body[&quot;__sls__&quot;]
                        )
                    )
                else:
                    fun = 0
                    if &quot;.&quot; in state:
                        fun += 1
                    for arg in body[state]:
                        if isinstance(arg, str):
                            fun += 1
                            if &quot; &quot; in arg.strip():
                                errors.append(
                                    'The function &quot;{}&quot; in state '
                                    '&quot;{}&quot; in SLS &quot;{}&quot; has '
                                    &quot;whitespace, a function with whitespace is &quot;
                                    &quot;not supported, perhaps this is an argument &quot;
                                    'that is missing a &quot;:&quot;'.format(
                                        arg, name, body[&quot;__sls__&quot;]
                                    )
                                )
                        elif isinstance(arg, dict):
                            # The arg is a dict, if the arg is require or
                            # watch, it must be a list.
                            #
                            # Add the requires to the reqs dict and check them
                            # all for recursive requisites.
                            argfirst = next(iter(arg))
                            if argfirst in (&quot;require&quot;, &quot;watch&quot;, &quot;prereq&quot;, &quot;onchanges&quot;):
                                if not isinstance(arg[argfirst], list):
                                    errors.append(
                                        &quot;The {} statement in state '{}' in SLS '{}' &quot;
                                        &quot;needs to be formed as a list&quot;.format(
                                            argfirst, name, body[&quot;__sls__&quot;]
                                        )
                                    )
                                # It is a list, verify that the members of the
                                # list are all single key dicts.
                                else:
                                    reqs[name] = {&quot;state&quot;: state}
                                    for req in arg[argfirst]:
                                        if isinstance(req, str):
                                            req = {&quot;id&quot;: req}
                                        if not isinstance(req, dict):
                                            errors.append(
                                                &quot;Requisite declaration {} in SLS {} &quot;
                                                &quot;is not formed as a single key &quot;
                                                &quot;dictionary&quot;.format(
                                                    req, body[&quot;__sls__&quot;]
                                                )
                                            )
                                            continue
                                        req_key = next(iter(req))
                                        req_val = req[req_key]
                                        if &quot;.&quot; in req_key:
                                            errors.append(
                                                &quot;Invalid requisite type '{}' &quot;
                                                &quot;in state '{}', in SLS &quot;
                                                &quot;'{}'. Requisite types must &quot;
                                                &quot;not contain dots, did you &quot;
                                                &quot;mean '{}'?&quot;.format(
                                                    req_key,
                                                    name,
                                                    body[&quot;__sls__&quot;],
                                                    req_key[: req_key.find(&quot;.&quot;)],
                                                )
                                            )
                                        if not ishashable(req_val):
                                            errors.append(
                                                'Illegal requisite &quot;{}&quot;, is SLS {}\n'.format(
                                                    str(req_val),
                                                    body[&quot;__sls__&quot;],
                                                )
                                            )
                                            continue

                                        # Check for global recursive requisites
                                        reqs[name][req_val] = req_key
                                        # I am going beyond 80 chars on
                                        # purpose, this is just too much
                                        # of a pain to deal with otherwise
                                        if req_val in reqs:
                                            if name in reqs[req_val]:
                                                if reqs[req_val][name] == state:
                                                    if (
                                                        reqs[req_val][&quot;state&quot;]
                                                        == reqs[name][req_val]
                                                    ):
                                                        errors.append(
                                                            &quot;A recursive requisite was&quot;
                                                            ' found, SLS &quot;{}&quot; ID &quot;{}&quot;'
                                                            ' ID &quot;{}&quot;'.format(
                                                                body[&quot;__sls__&quot;],
                                                                name,
                                                                req_val,
                                                            )
                                                        )
                                # Make sure that there is only one key in the
                                # dict
                                if len(list(arg)) != 1:
                                    errors.append(
                                        &quot;Multiple dictionaries defined in argument &quot;
                                        &quot;of state '{}' in SLS '{}'&quot;.format(
                                            name, body[&quot;__sls__&quot;]
                                        )
                                    )
                    if not fun:
                        if state == &quot;require&quot; or state == &quot;watch&quot;:
                            continue
                        errors.append(
                            &quot;No function declared in state '{}' in SLS '{}'&quot;.format(
                                state, body[&quot;__sls__&quot;]
                            )
                        )
                    elif fun &gt; 1:
                        errors.append(
                            &quot;Too many functions declared in state '{}' in &quot;
                            &quot;SLS '{}'&quot;.format(state, body[&quot;__sls__&quot;])
                        )
        return errors

    def order_chunks(self, chunks):
        &quot;&quot;&quot;
        Sort the chunk list verifying that the chunks follow the order
        specified in the order options.
        &quot;&quot;&quot;
        cap = 1
        for chunk in chunks:
            if &quot;order&quot; in chunk:
                if not isinstance(chunk[&quot;order&quot;], int):
                    continue

                chunk_order = chunk[&quot;order&quot;]
                if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
                    cap = chunk_order + 100
        for chunk in chunks:
            if &quot;order&quot; not in chunk:
                chunk[&quot;order&quot;] = cap
                continue

            if not isinstance(chunk[&quot;order&quot;], (int, float)):
                if chunk[&quot;order&quot;] == &quot;last&quot;:
                    chunk[&quot;order&quot;] = cap + 1000000
                elif chunk[&quot;order&quot;] == &quot;first&quot;:
                    chunk[&quot;order&quot;] = 0
                else:
                    chunk[&quot;order&quot;] = cap
            if &quot;name_order&quot; in chunk:
                chunk[&quot;order&quot;] = chunk[&quot;order&quot;] + chunk.pop(&quot;name_order&quot;) / 10000.0
            if chunk[&quot;order&quot;] &lt; 0:
                chunk[&quot;order&quot;] = cap + 1000000 + chunk[&quot;order&quot;]
            chunk[&quot;name&quot;] = salt.utils.data.decode(chunk[&quot;name&quot;])
        chunks.sort(
            key=lambda chunk: (
                chunk[&quot;order&quot;],
                &quot;{0[state]}{0[name]}{0[fun]}&quot;.format(chunk),
            )
        )
        return chunks

    def compile_high_data(self, high):
        &quot;&quot;&quot;
        &quot;Compile&quot; the high data as it is retrieved from the CLI or YAML into
        the individual state executor structures
        &quot;&quot;&quot;
        chunks = []
        for name, body in high.items():
            if name.startswith(&quot;__&quot;):
                continue
            for state, run in body.items():
                funcs = set()
                names = []
                if state.startswith(&quot;__&quot;):
                    continue
                chunk = {&quot;state&quot;: state, &quot;name&quot;: name}
                if &quot;__sls__&quot; in body:
                    chunk[&quot;__sls__&quot;] = body[&quot;__sls__&quot;]
                if &quot;__env__&quot; in body:
                    chunk[&quot;__env__&quot;] = body[&quot;__env__&quot;]
                chunk[&quot;__id__&quot;] = name
                for arg in run:
                    if isinstance(arg, str):
                        funcs.add(arg)
                        continue
                    if isinstance(arg, dict):
                        for key, val in arg.items():
                            if key == &quot;names&quot;:
                                for _name in val:
                                    if _name not in names:
                                        names.append(_name)
                                continue
                            else:
                                chunk.update(arg)
                if names:
                    name_order = 1
                    for entry in names:
                        live = copy.deepcopy(chunk)
                        if isinstance(entry, dict):
                            low_name = next(iter(entry.keys()))
                            live[&quot;name&quot;] = low_name
                            list(map(live.update, entry[low_name]))
                        else:
                            live[&quot;name&quot;] = entry
                        live[&quot;name_order&quot;] = name_order
                        name_order = name_order + 1
                        for fun in funcs:
                            live[&quot;fun&quot;] = fun
                            chunks.append(live)
                else:
                    live = copy.deepcopy(chunk)
                    for fun in funcs:
                        live[&quot;fun&quot;] = fun
                        chunks.append(live)
        chunks = self.order_chunks(chunks)
        return chunks

    def apply_exclude(self, high):
        &quot;&quot;&quot;
        Read in the __exclude__ list and remove all excluded objects from the
        high data
        &quot;&quot;&quot;
        if &quot;__exclude__&quot; not in high:
            return high
        ex_sls = set()
        ex_id = set()
        exclude = high.pop(&quot;__exclude__&quot;)
        for exc in exclude:
            if isinstance(exc, str):
                # The exclude statement is a string, assume it is an sls
                ex_sls.add(exc)
            if isinstance(exc, dict):
                # Explicitly declared exclude
                if len(exc) != 1:
                    continue
                key = next(iter(exc.keys()))
                if key == &quot;sls&quot;:
                    ex_sls.add(exc[&quot;sls&quot;])
                elif key == &quot;id&quot;:
                    ex_id.add(exc[&quot;id&quot;])
        # Now the excludes have been simplified, use them
        if ex_sls:
            # There are sls excludes, find the associtaed ids
            for name, body in high.items():
                if name.startswith(&quot;__&quot;):
                    continue
                if body.get(&quot;__sls__&quot;, &quot;&quot;) in ex_sls:
                    ex_id.add(name)
        for id_ in ex_id:
            if id_ in high:
                high.pop(id_)
        return high


class State:
    &quot;&quot;&quot;
    Class used to execute salt states
    &quot;&quot;&quot;

    def __init__(
        self,
        opts,
        pillar_override=None,
        jid=None,
        pillar_enc=None,
        proxy=None,
        context=None,
        mocked=False,
        loader=&quot;states&quot;,
        initial_pillar=None,
    ):
        self.states_loader = loader
        if &quot;grains&quot; not in opts:
            opts[&quot;grains&quot;] = salt.loader.grains(opts)
        self.opts = opts
        self.proxy = proxy
        self._pillar_override = pillar_override
        if pillar_enc is not None:
            try:
                pillar_enc = pillar_enc.lower()
            except AttributeError:
                pillar_enc = str(pillar_enc).lower()
        self._pillar_enc = pillar_enc
        log.debug(&quot;Gathering pillar data for state run&quot;)
        if initial_pillar and not self._pillar_override:
            self.opts[&quot;pillar&quot;] = initial_pillar
        else:
<A NAME="0"></A>            # Compile pillar data
            self.opts[&quot;pillar&quot;] = self._gather_pillar()
            # Reapply overrides on top of compiled pillar
            if self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#0',2,'match147349-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>._pillar_override:
                self.opts[&quot;pillar&quot;] = salt.utils.dictupdate.merge(
                    self.opts[&quot;pillar&quot;],
                    self._pillar_override,
                    self.opts.get(&quot;pillar_source_merging_strategy&quot;, &quot;smart&quot;),
                    self.</B></FONT>opts.get(&quot;renderer&quot;, &quot;yaml&quot;),
                    self.opts.get(&quot;pillar_merge_lists&quot;, False),
                )
        log.debug(&quot;Finished gathering pillar data for state run&quot;)
        self.state_con = context or {}
        self.load_modules()
        self.active = set()
        self.mod_init = set()
        self.pre = {}
        self.__run_num = 0
        self.jid = jid
        self.instance_id = str(id(self))
        self.inject_globals = {}
        self.mocked = mocked

    def _gather_pillar(self):
        &quot;&quot;&quot;
        Whenever a state run starts, gather the pillar data fresh
        &quot;&quot;&quot;
        if self._pillar_override:
            if self._pillar_enc:
                try:
                    self._pillar_override = salt.utils.crypt.decrypt(
                        self._pillar_override,
                        self._pillar_enc,
                        translate_newlines=True,
                        renderers=getattr(self, &quot;rend&quot;, None),
                        opts=self.opts,
                        valid_rend=self.opts[&quot;decrypt_pillar_renderers&quot;],
                    )
                except Exception as exc:  # pylint: disable=broad-except
                    log.error(&quot;Failed to decrypt pillar override: %s&quot;, exc)

            if isinstance(self._pillar_override, str):
                # This can happen if an entire pillar dictionary was passed as
                # a single encrypted string. The override will have been
                # decrypted above, and should now be a stringified dictionary.
                # Use the YAML loader to convert that to a Python dictionary.
                try:
                    self._pillar_override = yamlloader.load(
                        self._pillar_override, Loader=yamlloader.SaltYamlSafeLoader
                    )
                except Exception as exc:  # pylint: disable=broad-except
                    log.error(&quot;Failed to load CLI pillar override&quot;)
                    log.exception(exc)

            if not isinstance(self._pillar_override, dict):
                log.error(&quot;Pillar override was not passed as a dictionary&quot;)
                self._pillar_override = None

        pillar = salt.pillar.get_pillar(
            self.opts,
            self.opts[&quot;grains&quot;],
            self.opts[&quot;id&quot;],
            self.opts[&quot;saltenv&quot;],
            pillar_override=self._pillar_override,
            pillarenv=self.opts.get(&quot;pillarenv&quot;),
        )
        return pillar.compile_pillar()

    def _mod_init(self, low):
        &quot;&quot;&quot;
        Check the module initialization function, if this is the first run
        of a state package that has a mod_init function, then execute the
        mod_init function in the state module.
        &quot;&quot;&quot;
        # ensure that the module is loaded
        try:
            self.states[
                &quot;{}.{}&quot;.format(low[&quot;state&quot;], low[&quot;fun&quot;])
            ]  # pylint: disable=W0106
        except KeyError:
            return
        minit = &quot;{}.mod_init&quot;.format(low[&quot;state&quot;])
        if low[&quot;state&quot;] not in self.mod_init:
            if minit in self.states._dict:
                mret = self.states[minit](low)
                if not mret:
                    return
                self.mod_init.add(low[&quot;state&quot;])

    def _aggregate_requisites(self, low, chunks):
        &quot;&quot;&quot;
        Aggregate the requisites
        &quot;&quot;&quot;
        requisites = {}
        low_state = low[&quot;state&quot;]
        for chunk in chunks:
            # if the state function in the chunk matches
            # the state function in the low we're looking at
            # and __agg__ is True, add the requisites from the
            # chunk to those in the low.
            if chunk[&quot;state&quot;] == low[&quot;state&quot;] and chunk.get(&quot;__agg__&quot;):
                for req in frozenset.union(
                    *[STATE_REQUISITE_KEYWORDS, STATE_REQUISITE_IN_KEYWORDS]
                ):
                    if req in chunk:
                        if req in requisites:
                            requisites[req].extend(chunk[req])
                        else:
                            requisites[req] = chunk[req]
        low.update(requisites)
        return low

    def _mod_aggregate(self, low, running, chunks):
        &quot;&quot;&quot;
        Execute the aggregation systems to runtime modify the low chunk
        &quot;&quot;&quot;
        agg_opt = self.functions[&quot;config.option&quot;](&quot;state_aggregate&quot;)
        if &quot;aggregate&quot; in low:
            agg_opt = low[&quot;aggregate&quot;]
        if agg_opt is True:
            agg_opt = [low[&quot;state&quot;]]
        elif not isinstance(agg_opt, list):
            return low
        if low[&quot;state&quot;] in agg_opt and not low.get(&quot;__agg__&quot;):
            agg_fun = &quot;{}.mod_aggregate&quot;.format(low[&quot;state&quot;])
            if agg_fun in self.states:
                try:
                    low = self.states[agg_fun](low, chunks, running)
                    low = self._aggregate_requisites(low, chunks)
                    low[&quot;__agg__&quot;] = True
                except TypeError:
                    log.error(&quot;Failed to execute aggregate for state %s&quot;, low[&quot;state&quot;])
        return low

    def _run_check(self, low_data):
        &quot;&quot;&quot;
        Check that unless doesn't return 0, and that onlyif returns a 0.
        &quot;&quot;&quot;
        ret = {&quot;result&quot;: False, &quot;comment&quot;: []}
        cmd_opts = {}

        # Set arguments from cmd.run state as appropriate
        POSSIBLE_CMD_ARGS = (
            &quot;cwd&quot;,
            &quot;root&quot;,
            &quot;runas&quot;,
            &quot;env&quot;,
            &quot;prepend_path&quot;,
            &quot;umask&quot;,
            &quot;timeout&quot;,
            &quot;success_retcodes&quot;,
        )
        for run_cmd_arg in POSSIBLE_CMD_ARGS:
            cmd_opts[run_cmd_arg] = low_data.get(run_cmd_arg)

        if &quot;shell&quot; in low_data:
            cmd_opts[&quot;shell&quot;] = low_data[&quot;shell&quot;]
        elif &quot;shell&quot; in self.opts[&quot;grains&quot;]:
            cmd_opts[&quot;shell&quot;] = self.opts[&quot;grains&quot;].get(&quot;shell&quot;)

        if &quot;onlyif&quot; in low_data:
            _ret = self._run_check_onlyif(low_data, cmd_opts)
            ret[&quot;result&quot;] = _ret[&quot;result&quot;]
            ret[&quot;comment&quot;].append(_ret[&quot;comment&quot;])
            if &quot;skip_watch&quot; in _ret:
                ret[&quot;skip_watch&quot;] = _ret[&quot;skip_watch&quot;]

        if &quot;unless&quot; in low_data:
            _ret = self._run_check_unless(low_data, cmd_opts)
            # If either result is True, the returned result should be True
            ret[&quot;result&quot;] = _ret[&quot;result&quot;] or ret[&quot;result&quot;]
            ret[&quot;comment&quot;].append(_ret[&quot;comment&quot;])
            if &quot;skip_watch&quot; in _ret:
                # If either result is True, the returned result should be True
                ret[&quot;skip_watch&quot;] = _ret[&quot;skip_watch&quot;] or ret[&quot;skip_watch&quot;]

        if &quot;creates&quot; in low_data:
            _ret = self._run_check_creates(low_data)
            ret[&quot;result&quot;] = _ret[&quot;result&quot;] or ret[&quot;result&quot;]
            ret[&quot;comment&quot;].append(_ret[&quot;comment&quot;])
            if &quot;skip_watch&quot; in _ret:
                # If either result is True, the returned result should be True
                ret[&quot;skip_watch&quot;] = _ret[&quot;skip_watch&quot;] or ret[&quot;skip_watch&quot;]

        return ret

    def _run_check_function(self, entry):
        &quot;&quot;&quot;Format slot args and run unless/onlyif function.&quot;&quot;&quot;
        fun = entry.pop(&quot;fun&quot;)
        args = entry.pop(&quot;args&quot;) if &quot;args&quot; in entry else []
        cdata = {&quot;args&quot;: args, &quot;kwargs&quot;: entry}
        self.format_slots(cdata)
        return self.functions[fun](*cdata[&quot;args&quot;], **cdata[&quot;kwargs&quot;])

    def _run_check_onlyif(self, low_data, cmd_opts):
        &quot;&quot;&quot;
        Make sure that all commands return True for the state to run. If any
        command returns False (non 0), the state will not run
        &quot;&quot;&quot;
        ret = {&quot;result&quot;: False}

        if not isinstance(low_data[&quot;onlyif&quot;], list):
            low_data_onlyif = [low_data[&quot;onlyif&quot;]]
        else:
            low_data_onlyif = low_data[&quot;onlyif&quot;]

        # If any are False the state will NOT run
        def _check_cmd(cmd):
            # Don't run condition (False)
            if cmd != 0 and ret[&quot;result&quot;] is False:
                ret.update(
                    {
                        &quot;comment&quot;: &quot;onlyif condition is false&quot;,
                        &quot;skip_watch&quot;: True,
                        &quot;result&quot;: True,
                    }
                )
                return False
            elif cmd == 0:
                ret.update({&quot;comment&quot;: &quot;onlyif condition is true&quot;, &quot;result&quot;: False})
            return True

        for entry in low_data_onlyif:
            if isinstance(entry, str):
                try:
                    cmd = self.functions[&quot;cmd.retcode&quot;](
                        entry, ignore_retcode=True, python_shell=True, **cmd_opts
                    )
                except CommandExecutionError:
                    # Command failed, notify onlyif to skip running the item
                    cmd = 100
                log.debug(&quot;Last command return code: %s&quot;, cmd)
                if not _check_cmd(cmd):
                    return ret
            elif isinstance(entry, dict):
                if &quot;fun&quot; not in entry:
                    ret[&quot;comment&quot;] = &quot;no `fun` argument in onlyif: {}&quot;.format(entry)
                    log.warning(ret[&quot;comment&quot;])
                    return ret

                get_return = entry.pop(&quot;get_return&quot;, None)
                result = self._run_check_function(entry)
                if get_return:
                    result = salt.utils.data.traverse_dict_and_list(result, get_return)
                if self.state_con.get(&quot;retcode&quot;, 0):
                    if not _check_cmd(self.state_con[&quot;retcode&quot;]):
                        return ret
                elif not result:
                    ret.update(
                        {
                            &quot;comment&quot;: &quot;onlyif condition is false&quot;,
                            &quot;skip_watch&quot;: True,
                            &quot;result&quot;: True,
                        }
                    )
                    return ret
                else:
                    ret.update({&quot;comment&quot;: &quot;onlyif condition is true&quot;, &quot;result&quot;: False})

            else:
                ret.update(
                    {
                        &quot;comment&quot;: &quot;onlyif execution failed, bad type passed&quot;,
                        &quot;result&quot;: False,
                    }
                )
                return ret
        return ret

    def _run_check_unless(self, low_data, cmd_opts):
        &quot;&quot;&quot;
        Check if any of the commands return False (non 0). If any are False the
        state will run.
        &quot;&quot;&quot;
        ret = {&quot;result&quot;: False}

        if not isinstance(low_data[&quot;unless&quot;], list):
            low_data_unless = [low_data[&quot;unless&quot;]]
        else:
            low_data_unless = low_data[&quot;unless&quot;]

        # If any are False the state will run
        def _check_cmd(cmd):
            # Don't run condition (True)
            if cmd == 0:
                ret.update(
                    {
                        &quot;comment&quot;: &quot;unless condition is true&quot;,
                        &quot;skip_watch&quot;: True,
                        &quot;result&quot;: True,
                    }
                )
                return False
            else:
                ret.pop(&quot;skip_watch&quot;, None)
                ret.update({&quot;comment&quot;: &quot;unless condition is false&quot;, &quot;result&quot;: False})
                return True

        for entry in low_data_unless:
            if isinstance(entry, str):
                try:
                    cmd = self.functions[&quot;cmd.retcode&quot;](
                        entry, ignore_retcode=True, python_shell=True, **cmd_opts
                    )
                    log.debug(&quot;Last command return code: %s&quot;, cmd)
                except CommandExecutionError:
                    # Command failed, so notify unless to skip the item
                    cmd = 0
                if _check_cmd(cmd):
                    return ret
            elif isinstance(entry, dict):
                if &quot;fun&quot; not in entry:
                    ret[&quot;comment&quot;] = &quot;no `fun` argument in unless: {}&quot;.format(entry)
                    log.warning(ret[&quot;comment&quot;])
                    return ret

                get_return = entry.pop(&quot;get_return&quot;, None)
                result = self._run_check_function(entry)
                if get_return:
                    result = salt.utils.data.traverse_dict_and_list(result, get_return)
                if self.state_con.get(&quot;retcode&quot;, 0):
                    if _check_cmd(self.state_con[&quot;retcode&quot;]):
                        return ret
                elif result:
                    ret.update(
                        {
                            &quot;comment&quot;: &quot;unless condition is true&quot;,
                            &quot;skip_watch&quot;: True,
                            &quot;result&quot;: True,
                        }
                    )
                else:
                    ret.update(
                        {&quot;comment&quot;: &quot;unless condition is false&quot;, &quot;result&quot;: False}
                    )
                    return ret
            else:
                ret.update(
                    {
                        &quot;comment&quot;: &quot;unless condition is false, bad type passed&quot;,
                        &quot;result&quot;: False,
                    }
                )

        # No reason to stop, return ret
        return ret

    def _run_check_cmd(self, low_data):
        &quot;&quot;&quot;
        Alter the way a successful state run is determined
        &quot;&quot;&quot;
        ret = {&quot;result&quot;: False}
        cmd_opts = {}
        if &quot;shell&quot; in self.opts[&quot;grains&quot;]:
            cmd_opts[&quot;shell&quot;] = self.opts[&quot;grains&quot;].get(&quot;shell&quot;)
        for entry in low_data[&quot;check_cmd&quot;]:
            cmd = self.functions[&quot;cmd.retcode&quot;](
                entry, ignore_retcode=True, python_shell=True, **cmd_opts
            )
            log.debug(&quot;Last command return code: %s&quot;, cmd)
            if cmd == 0 and ret[&quot;result&quot;] is False:
                ret.update(
                    {
                        &quot;comment&quot;: &quot;check_cmd determined the state succeeded&quot;,
                        &quot;result&quot;: True,
                    }
                )
            elif cmd != 0:
                ret.update(
                    {
                        &quot;comment&quot;: &quot;check_cmd determined the state failed&quot;,
                        &quot;result&quot;: False,
                    }
                )
                return ret
        return ret

    def _run_check_creates(self, low_data):
        &quot;&quot;&quot;
        Check that listed files exist
        &quot;&quot;&quot;
        ret = {&quot;result&quot;: False}

        if isinstance(low_data[&quot;creates&quot;], str) and os.path.exists(low_data[&quot;creates&quot;]):
            ret[&quot;comment&quot;] = &quot;{} exists&quot;.format(low_data[&quot;creates&quot;])
            ret[&quot;result&quot;] = True
            ret[&quot;skip_watch&quot;] = True
        elif isinstance(low_data[&quot;creates&quot;], list) and all(
            [os.path.exists(path) for path in low_data[&quot;creates&quot;]]
        ):
            ret[&quot;comment&quot;] = &quot;All files in creates exist&quot;
            ret[&quot;result&quot;] = True
            ret[&quot;skip_watch&quot;] = True
        else:
            ret[&quot;comment&quot;] = &quot;Creates files not found&quot;
            ret[&quot;result&quot;] = False

        return ret

    def reset_run_num(self):
        &quot;&quot;&quot;
        Rest the run_num value to 0
        &quot;&quot;&quot;
        self.__run_num = 0

    def _load_states(self):
        &quot;&quot;&quot;
        Read the state loader value and loadup the correct states subsystem
        &quot;&quot;&quot;
        if self.states_loader == &quot;thorium&quot;:
            self.states = salt.loader.thorium(
                self.opts, self.functions, {}
            )  # TODO: Add runners, proxy?
        else:
            self.states = salt.loader.states(
                self.opts,
                self.functions,
                self.utils,
                self.serializers,
                context=self.state_con,
                proxy=self.proxy,
            )

    def load_modules(self, data=None, proxy=None):
        &quot;&quot;&quot;
        Load the modules into the state
        &quot;&quot;&quot;
        log.info(&quot;Loading fresh modules for state activity&quot;)
        self.utils = salt.loader.utils(self.opts)
        self.functions = salt.loader.minion_mods(
            self.opts, self.state_con, utils=self.utils, proxy=self.proxy
        )
        if isinstance(data, dict):
            if data.get(&quot;provider&quot;, False):
                if isinstance(data[&quot;provider&quot;], str):
                    providers = [{data[&quot;state&quot;]: data[&quot;provider&quot;]}]
                elif isinstance(data[&quot;provider&quot;], list):
                    providers = data[&quot;provider&quot;]
                else:
                    providers = {}
                for provider in providers:
                    for mod in provider:
                        funcs = salt.loader.raw_mod(
                            self.opts, provider[mod], self.functions
                        )
                        if funcs:
                            for func in funcs:
                                f_key = &quot;{}{}&quot;.format(mod, func[func.rindex(&quot;.&quot;) :])
                                self.functions[f_key] = funcs[func]
        self.serializers = salt.loader.serializers(self.opts)
        self._load_states()
        self.rend = salt.loader.render(
            self.opts,
            self.functions,
            states=self.states,
            proxy=self.proxy,
            context=self.state_con,
        )

    def module_refresh(self):
        &quot;&quot;&quot;
        Refresh all the modules
        &quot;&quot;&quot;
        log.debug(&quot;Refreshing modules...&quot;)
        if self.opts[&quot;grains&quot;].get(&quot;os&quot;) != &quot;MacOS&quot;:
            # In case a package has been installed into the current python
            # process 'site-packages', the 'site' module needs to be reloaded in
            # order for the newly installed package to be importable.
            try:
                importlib.reload(site)
            except RuntimeError:
                log.error(
                    &quot;Error encountered during module reload. Modules were not reloaded.&quot;
                )
            except TypeError:
                log.error(
                    &quot;Error encountered during module reload. Modules were not reloaded.&quot;
                )
        self.load_modules()
        if not self.opts.get(&quot;local&quot;, False) and self.opts.get(&quot;multiprocessing&quot;, True):
            self.functions[&quot;saltutil.refresh_modules&quot;]()

    def check_refresh(self, data, ret):
        &quot;&quot;&quot;
        Check to see if the modules for this state instance need to be updated,
        only update if the state is a file or a package and if it changed
        something. If the file function is managed check to see if the file is a
        possible module type, e.g. a python, pyx, or .so. Always refresh if the
        function is recurse, since that can lay down anything.
        &quot;&quot;&quot;
        _reload_modules = False
        if data.get(&quot;reload_grains&quot;, False):
            log.debug(&quot;Refreshing grains...&quot;)
            self.opts[&quot;grains&quot;] = salt.loader.grains(self.opts)
            _reload_modules = True

        if data.get(&quot;reload_pillar&quot;, False):
            log.debug(&quot;Refreshing pillar...&quot;)
            self.opts[&quot;pillar&quot;] = self._gather_pillar()
            _reload_modules = True

        if not ret[&quot;changes&quot;]:
            if data.get(&quot;force_reload_modules&quot;, False):
                self.module_refresh()
            return

        if data.get(&quot;reload_modules&quot;, False) or _reload_modules:
            # User explicitly requests a reload
            self.module_refresh()
            return

        if data[&quot;state&quot;] == &quot;file&quot;:
            if data[&quot;fun&quot;] == &quot;managed&quot;:
                if data[&quot;name&quot;].endswith((&quot;.py&quot;, &quot;.pyx&quot;, &quot;.pyo&quot;, &quot;.pyc&quot;, &quot;.so&quot;)):
                    self.module_refresh()
            elif data[&quot;fun&quot;] == &quot;recurse&quot;:
                self.module_refresh()
            elif data[&quot;fun&quot;] == &quot;symlink&quot;:
                if &quot;bin&quot; in data[&quot;name&quot;]:
                    self.module_refresh()
        elif data[&quot;state&quot;] in (&quot;pkg&quot;, &quot;ports&quot;, &quot;pip&quot;):
            self.module_refresh()

    def verify_data(self, data):
        &quot;&quot;&quot;
        Verify the data, return an error statement if something is wrong
        &quot;&quot;&quot;
        errors = []
        if &quot;state&quot; not in data:
            errors.append('Missing &quot;state&quot; data')
        if &quot;fun&quot; not in data:
            errors.append('Missing &quot;fun&quot; data')
        if &quot;name&quot; not in data:
            errors.append('Missing &quot;name&quot; data')
        if data[&quot;name&quot;] and not isinstance(data[&quot;name&quot;], str):
            errors.append(
                &quot;ID '{}' {}is not formed as a string, but is a {}&quot;.format(
                    data[&quot;name&quot;],
                    &quot;in SLS '{}' &quot;.format(data[&quot;__sls__&quot;]) if &quot;__sls__&quot; in data else &quot;&quot;,
                    type(data[&quot;name&quot;]).__name__,
                )
            )
        if errors:
            return errors
        full = data[&quot;state&quot;] + &quot;.&quot; + data[&quot;fun&quot;]
        if full not in self.states:
            if &quot;__sls__&quot; in data:
                errors.append(
                    &quot;State '{}' was not found in SLS '{}'&quot;.format(full, data[&quot;__sls__&quot;])
                )
                reason = self.states.missing_fun_string(full)
                if reason:
                    errors.append(&quot;Reason: {}&quot;.format(reason))
            else:
                errors.append(&quot;Specified state '{}' was not found&quot;.format(full))
        else:
            # First verify that the parameters are met
            aspec = salt.utils.args.get_function_argspec(self.states[full])
            arglen = 0
            deflen = 0
            if isinstance(aspec.args, list):
                arglen = len(aspec.args)
            if isinstance(aspec.defaults, tuple):
                deflen = len(aspec.defaults)
            for ind in range(arglen - deflen):
                if aspec.args[ind] not in data:
                    errors.append(
                        &quot;Missing parameter {} for state {}&quot;.format(
                            aspec.args[ind], full
                        )
                    )
        # If this chunk has a recursive require, then it will cause a
        # recursive loop when executing, check for it
        reqdec = &quot;&quot;
        if &quot;require&quot; in data:
            reqdec = &quot;require&quot;
        if &quot;watch&quot; in data:
            # Check to see if the service has a mod_watch function, if it does
            # not, then just require
            # to just require extend the require statement with the contents
            # of watch so that the mod_watch function is not called and the
            # requisite capability is still used
            if &quot;{}.mod_watch&quot;.format(data[&quot;state&quot;]) not in self.states:
                if &quot;require&quot; in data:
                    data[&quot;require&quot;].extend(data.pop(&quot;watch&quot;))
                else:
                    data[&quot;require&quot;] = data.pop(&quot;watch&quot;)
                reqdec = &quot;require&quot;
            else:
                reqdec = &quot;watch&quot;
        if reqdec:
            for req in data[reqdec]:
                reqfirst = next(iter(req))
                if data[&quot;state&quot;] == reqfirst:
                    if fnmatch.fnmatch(data[&quot;name&quot;], req[reqfirst]) or fnmatch.fnmatch(
                        data[&quot;__id__&quot;], req[reqfirst]
                    ):
                        errors.append(
                            &quot;Recursive require detected in SLS {} for &quot;
                            &quot;require {} in ID {}&quot;.format(
                                data[&quot;__sls__&quot;], req, data[&quot;__id__&quot;]
                            )
                        )
        return errors

    def verify_high(self, high):
        &quot;&quot;&quot;
        Verify that the high data is viable and follows the data structure
        &quot;&quot;&quot;
        errors = []
        if not isinstance(high, dict):
            errors.append(&quot;High data is not a dictionary and is invalid&quot;)
        reqs = OrderedDict()
        for name, body in high.items():
            try:
                if name.startswith(&quot;__&quot;):
                    continue
            except AttributeError:
                pass
            if not isinstance(name, str):
                errors.append(
                    &quot;ID '{}' in SLS '{}' is not formed as a string, but &quot;
                    &quot;is a {}. It may need to be quoted.&quot;.format(
                        name, body[&quot;__sls__&quot;], type(name).__name__
                    )
                )
            if not isinstance(body, dict):
                err = &quot;The type {} in {} is not formatted as a dictionary&quot;.format(
                    name, body
                )
                errors.append(err)
                continue
            for state in body:
                if state.startswith(&quot;__&quot;):
                    continue
                if body[state] is None:
                    errors.append(
                        &quot;ID '{}' in SLS '{}' contains a short declaration &quot;
                        &quot;({}) with a trailing colon. When not passing any &quot;
                        &quot;arguments to a state, the colon must be omitted.&quot;.format(
                            name, body[&quot;__sls__&quot;], state
                        )
                    )
                    continue
                if not isinstance(body[state], list):
                    errors.append(
                        &quot;State '{}' in SLS '{}' is not formed as a list&quot;.format(
                            name, body[&quot;__sls__&quot;]
                        )
                    )
                else:
                    fun = 0
                    if &quot;.&quot; in state:
                        fun += 1
                    for arg in body[state]:
                        if isinstance(arg, str):
                            fun += 1
                            if &quot; &quot; in arg.strip():
                                errors.append(
                                    'The function &quot;{}&quot; in state &quot;{}&quot; in SLS &quot;{}&quot; has '
                                    &quot;whitespace, a function with whitespace is not &quot;
                                    &quot;supported, perhaps this is an argument that is &quot;
                                    'missing a &quot;:&quot;'.format(arg, name, body[&quot;__sls__&quot;])
                                )
                        elif isinstance(arg, dict):
                            # The arg is a dict, if the arg is require or
                            # watch, it must be a list.
                            #
                            # Add the requires to the reqs dict and check them
                            # all for recursive requisites.
                            argfirst = next(iter(arg))
                            if argfirst == &quot;names&quot;:
                                if not isinstance(arg[argfirst], list):
                                    errors.append(
                                        &quot;The 'names' argument in state &quot;
                                        &quot;'{}' in SLS '{}' needs to be &quot;
                                        &quot;formed as a list&quot;.format(name, body[&quot;__sls__&quot;])
                                    )
                            if argfirst in (&quot;require&quot;, &quot;watch&quot;, &quot;prereq&quot;, &quot;onchanges&quot;):
                                if not isinstance(arg[argfirst], list):
                                    errors.append(
                                        &quot;The {} statement in state '{}' in &quot;
                                        &quot;SLS '{}' needs to be formed as a &quot;
                                        &quot;list&quot;.format(argfirst, name, body[&quot;__sls__&quot;])
                                    )
                                # It is a list, verify that the members of the
                                # list are all single key dicts.
                                else:
                                    reqs[name] = OrderedDict(state=state)
                                    for req in arg[argfirst]:
                                        if isinstance(req, str):
                                            req = {&quot;id&quot;: req}
                                        if not isinstance(req, dict):
                                            errors.append(
                                                &quot;Requisite declaration {} in SLS {} is&quot;
                                                &quot; not formed as a single key dictionary&quot;.format(
                                                    req, body[&quot;__sls__&quot;]
                                                )
                                            )
                                            continue
                                        req_key = next(iter(req))
                                        req_val = req[req_key]
                                        if &quot;.&quot; in req_key:
                                            errors.append(
                                                &quot;Invalid requisite type '{}' &quot;
                                                &quot;in state '{}', in SLS &quot;
                                                &quot;'{}'. Requisite types must &quot;
                                                &quot;not contain dots, did you &quot;
                                                &quot;mean '{}'?&quot;.format(
                                                    req_key,
                                                    name,
                                                    body[&quot;__sls__&quot;],
                                                    req_key[: req_key.find(&quot;.&quot;)],
                                                )
                                            )
                                        if not ishashable(req_val):
                                            errors.append(
                                                'Illegal requisite &quot;{}&quot;, please check '
                                                &quot;your syntax.\n&quot;.format(req_val)
                                            )
                                            continue

                                        # Check for global recursive requisites
                                        reqs[name][req_val] = req_key
                                        # I am going beyond 80 chars on
                                        # purpose, this is just too much
                                        # of a pain to deal with otherwise
                                        if req_val in reqs:
                                            if name in reqs[req_val]:
                                                if reqs[req_val][name] == state:
                                                    if (
                                                        reqs[req_val][&quot;state&quot;]
                                                        == reqs[name][req_val]
                                                    ):
                                                        errors.append(
                                                            &quot;A recursive requisite was&quot;
                                                            ' found, SLS &quot;{}&quot; ID &quot;{}&quot;'
                                                            ' ID &quot;{}&quot;'.format(
                                                                body[&quot;__sls__&quot;],
                                                                name,
                                                                req_val,
                                                            )
                                                        )
                                # Make sure that there is only one key in the
                                # dict
                                if len(list(arg)) != 1:
                                    errors.append(
                                        &quot;Multiple dictionaries defined in &quot;
                                        &quot;argument of state '{}' in SLS '{}'&quot;.format(
                                            name, body[&quot;__sls__&quot;]
                                        )
                                    )
                    if not fun:
                        if state == &quot;require&quot; or state == &quot;watch&quot;:
                            continue
                        errors.append(
                            &quot;No function declared in state '{}' in SLS '{}'&quot;.format(
                                state, body[&quot;__sls__&quot;]
                            )
                        )
                    elif fun &gt; 1:
                        errors.append(
                            &quot;Too many functions declared in state '{}' in &quot;
                            &quot;SLS '{}'&quot;.format(state, body[&quot;__sls__&quot;])
                        )
        return errors

    def verify_chunks(self, chunks):
        &quot;&quot;&quot;
        Verify the chunks in a list of low data structures
        &quot;&quot;&quot;
        err = []
        for chunk in chunks:
            err.extend(self.verify_data(chunk))
        return err

    def order_chunks(self, chunks):
        &quot;&quot;&quot;
        Sort the chunk list verifying that the chunks follow the order
        specified in the order options.
        &quot;&quot;&quot;
        cap = 1
        for chunk in chunks:
            if &quot;order&quot; in chunk:
                if not isinstance(chunk[&quot;order&quot;], int):
                    continue

                chunk_order = chunk[&quot;order&quot;]
                if chunk_order &gt; cap - 1 and chunk_order &gt; 0:
                    cap = chunk_order + 100
        for chunk in chunks:
            if &quot;order&quot; not in chunk:
                chunk[&quot;order&quot;] = cap
                continue

            if not isinstance(chunk[&quot;order&quot;], (int, float)):
                if chunk[&quot;order&quot;] == &quot;last&quot;:
                    chunk[&quot;order&quot;] = cap + 1000000
                elif chunk[&quot;order&quot;] == &quot;first&quot;:
                    chunk[&quot;order&quot;] = 0
                else:
                    chunk[&quot;order&quot;] = cap
            if &quot;name_order&quot; in chunk:
                chunk[&quot;order&quot;] = chunk[&quot;order&quot;] + chunk.pop(&quot;name_order&quot;) / 10000.0
            if chunk[&quot;order&quot;] &lt; 0:
                chunk[&quot;order&quot;] = cap + 1000000 + chunk[&quot;order&quot;]
        chunks.sort(
            key=lambda chunk: (
                chunk[&quot;order&quot;],
                &quot;{0[state]}{0[name]}{0[fun]}&quot;.format(chunk),
            )
        )
        return chunks

    def compile_high_data(self, high, orchestration_jid=None):
        &quot;&quot;&quot;
        &quot;Compile&quot; the high data as it is retrieved from the CLI or YAML into
        the individual state executor structures
        &quot;&quot;&quot;
        chunks = []
        for name, body in high.items():
            if name.startswith(&quot;__&quot;):
                continue
            for state, run in body.items():
                funcs = set()
                names = []
                if state.startswith(&quot;__&quot;):
                    continue
                chunk = {&quot;state&quot;: state, &quot;name&quot;: name}
                if orchestration_jid is not None:
                    chunk[&quot;__orchestration_jid__&quot;] = orchestration_jid
                if &quot;__sls__&quot; in body:
                    chunk[&quot;__sls__&quot;] = body[&quot;__sls__&quot;]
                if &quot;__env__&quot; in body:
                    chunk[&quot;__env__&quot;] = body[&quot;__env__&quot;]
                chunk[&quot;__id__&quot;] = name
                for arg in run:
                    if isinstance(arg, str):
                        funcs.add(arg)
                        continue
                    if isinstance(arg, dict):
                        for key, val in arg.items():
                            if key == &quot;names&quot;:
                                for _name in val:
                                    if _name not in names:
                                        names.append(_name)
                            elif key == &quot;state&quot;:
                                # Don't pass down a state override
                                continue
                            elif key == &quot;name&quot; and not isinstance(val, str):
                                # Invalid name, fall back to ID
                                chunk[key] = name
                            else:
                                chunk[key] = val
                if names:
                    name_order = 1
                    for entry in names:
                        live = copy.deepcopy(chunk)
                        if isinstance(entry, dict):
                            low_name = next(iter(entry.keys()))
                            live[&quot;name&quot;] = low_name
                            list(map(live.update, entry[low_name]))
                        else:
                            live[&quot;name&quot;] = entry
                        live[&quot;name_order&quot;] = name_order
                        name_order += 1
                        for fun in funcs:
                            live[&quot;fun&quot;] = fun
                            chunks.append(live)
                else:
                    live = copy.deepcopy(chunk)
                    for fun in funcs:
                        live[&quot;fun&quot;] = fun
                        chunks.append(live)
        chunks = self.order_chunks(chunks)
        return chunks

    def reconcile_extend(self, high, strict=False):
        &quot;&quot;&quot;
        Pull the extend data and add it to the respective high data
        &quot;&quot;&quot;
        errors = []
        if &quot;__extend__&quot; not in high:
            return high, errors
        ext = high.pop(&quot;__extend__&quot;)
        for ext_chunk in ext:
            for name, body in ext_chunk.items():
                state_type = next(x for x in body if not x.startswith(&quot;__&quot;))
                if name not in high or state_type not in high[name]:
                    # Check for a matching 'name' override in high data
                    ids = find_name(name, state_type, high, strict=strict)
                    if len(ids) != 1:
                        errors.append(
                            &quot;Cannot extend ID '{0}' in '{1}:{2}'. It is not &quot;
                            &quot;part of the high state.\n&quot;
                            &quot;This is likely due to a missing include statement &quot;
                            &quot;or an incorrectly typed ID.\nEnsure that a &quot;
                            &quot;state with an ID of '{0}' is available\nin &quot;
                            &quot;environment '{1}' and to SLS '{2}'&quot;.format(
                                name,
                                body.get(&quot;__env__&quot;, &quot;base&quot;),
                                body.get(&quot;__sls__&quot;, &quot;base&quot;),
                            )
                        )
                        continue
                    else:
                        name = ids[0][0]

                for state, run in body.items():
                    if state.startswith(&quot;__&quot;):
                        continue
                    if state not in high[name]:
                        high[name][state] = run
                        continue
                    # high[name][state] is extended by run, both are lists
                    for arg in run:
                        update = False
                        for hind, val in enumerate(high[name][state]):
                            if isinstance(arg, str) and isinstance(val, str):
                                # replacing the function, replace the index
                                high[name][state].pop(hind)
                                high[name][state].insert(hind, arg)
                                update = True
                                continue
                            if isinstance(arg, dict) and isinstance(val, dict):
                                # It is an option, make sure the options match
                                argfirst = next(iter(arg))
                                if argfirst == next(iter(high[name][state][hind])):
                                    # If argfirst is a requisite then we must merge
                                    # our requisite with that of the target state
                                    if argfirst in STATE_REQUISITE_KEYWORDS:
                                        high[name][state][hind][argfirst].extend(
                                            arg[argfirst]
                                        )
                                    # otherwise, its not a requisite and we are just extending (replacing)
                                    else:
                                        high[name][state][hind] = arg
                                    update = True
                                if (
                                    argfirst == &quot;name&quot;
                                    and next(iter(high[name][state][hind])) == &quot;names&quot;
                                ):
                                    # If names are overwritten by name use the name
                                    high[name][state][hind] = arg
                        if not update:
                            high[name][state].append(arg)
        return high, errors

    def apply_exclude(self, high):
        &quot;&quot;&quot;
        Read in the __exclude__ list and remove all excluded objects from the
        high data
        &quot;&quot;&quot;
        if &quot;__exclude__&quot; not in high:
            return high
        ex_sls = set()
        ex_id = set()
        exclude = high.pop(&quot;__exclude__&quot;)
        for exc in exclude:
            if isinstance(exc, str):
                # The exclude statement is a string, assume it is an sls
                ex_sls.add(exc)
            if isinstance(exc, dict):
                # Explicitly declared exclude
                if len(exc) != 1:
                    continue
                key = next(iter(exc.keys()))
                if key == &quot;sls&quot;:
                    ex_sls.add(exc[&quot;sls&quot;])
                elif key == &quot;id&quot;:
                    ex_id.add(exc[&quot;id&quot;])
        # Now the excludes have been simplified, use them
        if ex_sls:
            # There are sls excludes, find the associated ids
            for name, body in high.items():
                if name.startswith(&quot;__&quot;):
                    continue
                sls = body.get(&quot;__sls__&quot;, &quot;&quot;)
                if not sls:
                    continue
                for ex_ in ex_sls:
                    if fnmatch.fnmatch(sls, ex_):
                        ex_id.add(name)
        for id_ in ex_id:
            if id_ in high:
                high.pop(id_)
        return high

    def requisite_in(self, high):
        &quot;&quot;&quot;
        Extend the data reference with requisite_in arguments
        &quot;&quot;&quot;
        req_in = {
            &quot;require_in&quot;,
            &quot;watch_in&quot;,
            &quot;onfail_in&quot;,
            &quot;onchanges_in&quot;,
            &quot;use&quot;,
            &quot;use_in&quot;,
            &quot;prereq&quot;,
            &quot;prereq_in&quot;,
        }
        req_in_all = req_in.union(
            {&quot;require&quot;, &quot;watch&quot;, &quot;onfail&quot;, &quot;onfail_stop&quot;, &quot;onchanges&quot;}
        )
        extend = {}
        errors = []
        disabled_reqs = self.opts.get(&quot;disabled_requisites&quot;, [])
        if not isinstance(disabled_reqs, list):
            disabled_reqs = [disabled_reqs]
        for id_, body in high.items():
            if not isinstance(body, dict):
                continue
            for state, run in body.items():
                if state.startswith(&quot;__&quot;):
                    continue
                for arg in run:
                    if isinstance(arg, dict):
                        # It is not a function, verify that the arg is a
                        # requisite in statement
                        if len(arg) &lt; 1:
                            # Empty arg dict
                            # How did we get this far?
                            continue
                        # Split out the components
                        key = next(iter(arg))
                        if key not in req_in:
                            continue
                        if key in disabled_reqs:
                            log.warning(
                                &quot;The %s requisite has been disabled, Ignoring.&quot;, key
                            )
                            continue
                        rkey = key.split(&quot;_&quot;)[0]
                        items = arg[key]
                        if isinstance(items, dict):
                            # Formatted as a single req_in
                            for _state, name in items.items():

                                # Not a use requisite_in
                                found = False
                                if name not in extend:
                                    extend[name] = OrderedDict()
                                if &quot;.&quot; in _state:
                                    errors.append(
                                        &quot;Invalid requisite in {}: {} for &quot;
                                        &quot;{}, in SLS '{}'. Requisites must &quot;
                                        &quot;not contain dots, did you mean '{}'?&quot;.format(
                                            rkey,
                                            _state,
                                            name,
                                            body[&quot;__sls__&quot;],
                                            _state[: _state.find(&quot;.&quot;)],
                                        )
                                    )
                                    _state = _state.split(&quot;.&quot;)[0]
                                if _state not in extend[name]:
                                    extend[name][_state] = []
                                extend[name][&quot;__env__&quot;] = body[&quot;__env__&quot;]
                                extend[name][&quot;__sls__&quot;] = body[&quot;__sls__&quot;]
                                for ind in range(len(extend[name][_state])):
                                    if next(iter(extend[name][_state][ind])) == rkey:
                                        # Extending again
                                        extend[name][_state][ind][rkey].append(
                                            {state: id_}
                                        )
                                        found = True
                                if found:
                                    continue
                                # The rkey is not present yet, create it
                                extend[name][_state].append({rkey: [{state: id_}]})

                        if isinstance(items, list):
                            # Formed as a list of requisite additions
                            hinges = []
                            for ind in items:
                                if not isinstance(ind, dict):
                                    # Malformed req_in
                                    if ind in high:
                                        _ind_high = [
                                            x
                                            for x in high[ind]
                                            if not x.startswith(&quot;__&quot;)
                                        ]
                                        ind = {_ind_high[0]: ind}
                                    else:
                                        found = False
                                        for _id in iter(high):
                                            for state in [
                                                state
                                                for state in iter(high[_id])
                                                if not state.startswith(&quot;__&quot;)
                                            ]:
                                                for j in iter(high[_id][state]):
                                                    if (
                                                        isinstance(j, dict)
                                                        and &quot;name&quot; in j
                                                    ):
                                                        if j[&quot;name&quot;] == ind:
                                                            ind = {state: _id}
                                                            found = True
                                        if not found:
                                            continue
                                if len(ind) &lt; 1:
                                    continue
                                pstate = next(iter(ind))
                                pname = ind[pstate]
                                if pstate == &quot;sls&quot;:
                                    # Expand hinges here
                                    hinges = find_sls_ids(pname, high)
                                else:
                                    hinges.append((pname, pstate))
                                if &quot;.&quot; in pstate:
                                    errors.append(
                                        &quot;Invalid requisite in {}: {} for &quot;
                                        &quot;{}, in SLS '{}'. Requisites must &quot;
                                        &quot;not contain dots, did you mean '{}'?&quot;.format(
                                            rkey,
                                            pstate,
                                            pname,
                                            body[&quot;__sls__&quot;],
                                            pstate[: pstate.find(&quot;.&quot;)],
                                        )
                                    )
                                    pstate = pstate.split(&quot;.&quot;)[0]
                                for tup in hinges:
                                    name, _state = tup
                                    if key == &quot;prereq_in&quot;:
                                        # Add prerequired to origin
                                        if id_ not in extend:
                                            extend[id_] = OrderedDict()
                                        if state not in extend[id_]:
                                            extend[id_][state] = []
                                        extend[id_][state].append(
                                            {&quot;prerequired&quot;: [{_state: name}]}
                                        )
                                    if key == &quot;prereq&quot;:
                                        # Add prerequired to prereqs
                                        ext_ids = find_name(
                                            name, _state, high, strict=True
                                        )
                                        for ext_id, _req_state in ext_ids:
                                            if ext_id not in extend:
                                                extend[ext_id] = OrderedDict()
                                            if _req_state not in extend[ext_id]:
                                                extend[ext_id][_req_state] = []
                                            extend[ext_id][_req_state].append(
                                                {&quot;prerequired&quot;: [{state: id_}]}
                                            )
                                        continue
                                    if key == &quot;use_in&quot;:
                                        # Add the running states args to the
                                        # use_in states
                                        ext_ids = find_name(
                                            name, _state, high, strict=True
                                        )
                                        for ext_id, _req_state in ext_ids:
                                            if not ext_id:
                                                continue
                                            ext_args = state_args(ext_id, _state, high)
                                            if ext_id not in extend:
                                                extend[ext_id] = OrderedDict()
                                            if _req_state not in extend[ext_id]:
                                                extend[ext_id][_req_state] = []
                                            ignore_args = req_in_all.union(ext_args)
                                            for arg in high[id_][state]:
                                                if not isinstance(arg, dict):
                                                    continue
                                                if len(arg) != 1:
                                                    continue
                                                if next(iter(arg)) in ignore_args:
                                                    continue
                                                # Don't use name or names
                                                if next(iter(arg.keys())) == &quot;name&quot;:
                                                    continue
                                                if next(iter(arg.keys())) == &quot;names&quot;:
                                                    continue
                                                extend[ext_id][_req_state].append(arg)
                                        continue
                                    if key == &quot;use&quot;:
                                        # Add the use state's args to the
                                        # running state
                                        ext_ids = find_name(
                                            name, _state, high, strict=True
                                        )
                                        for ext_id, _req_state in ext_ids:
                                            if not ext_id:
                                                continue
                                            loc_args = state_args(id_, state, high)
                                            if id_ not in extend:
                                                extend[id_] = OrderedDict()
                                            if state not in extend[id_]:
                                                extend[id_][state] = []
                                            ignore_args = req_in_all.union(loc_args)
                                            for arg in high[ext_id][_req_state]:
                                                if not isinstance(arg, dict):
                                                    continue
                                                if len(arg) != 1:
                                                    continue
                                                if next(iter(arg)) in ignore_args:
                                                    continue
                                                # Don't use name or names
                                                if next(iter(arg.keys())) == &quot;name&quot;:
                                                    continue
                                                if next(iter(arg.keys())) == &quot;names&quot;:
                                                    continue
                                                extend[id_][state].append(arg)
                                        continue
                                    found = False
                                    if name not in extend:
                                        extend[name] = OrderedDict()
                                    if _state not in extend[name]:
                                        extend[name][_state] = []
                                    extend[name][&quot;__env__&quot;] = body[&quot;__env__&quot;]
                                    extend[name][&quot;__sls__&quot;] = body[&quot;__sls__&quot;]
                                    for ind in range(len(extend[name][_state])):
                                        if (
                                            next(iter(extend[name][_state][ind]))
                                            == rkey
                                        ):
                                            # Extending again
                                            extend[name][_state][ind][rkey].append(
                                                {state: id_}
                                            )
                                            found = True
                                    if found:
                                        continue
                                    # The rkey is not present yet, create it
                                    extend[name][_state].append({rkey: [{state: id_}]})
        high[&quot;__extend__&quot;] = []
        for key, val in extend.items():
            high[&quot;__extend__&quot;].append({key: val})
        req_in_high, req_in_errors = self.reconcile_extend(high, strict=True)
        errors.extend(req_in_errors)
        return req_in_high, errors

    def _call_parallel_target(self, name, cdata, low):
        &quot;&quot;&quot;
        The target function to call that will create the parallel thread/process
        &quot;&quot;&quot;
        # we need to re-record start/end duration here because it is impossible to
        # correctly calculate further down the chain
        utc_start_time = datetime.datetime.utcnow()
<A NAME="1"></A>
        self.format_slots(cdata)
        tag = _gen_tag(low)
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#1',2,'match147349-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>try:
            ret = self.states[cdata[&quot;full&quot;]](*cdata[&quot;args&quot;], **cdata[&quot;kwargs&quot;])
        except Exception as exc:  # pylint: disable=broad-except
            log.debug(
                &quot;An exception occurred in this state: %s&quot;,
                exc,
                exc_info_on_loglevel=</B></FONT>logging.DEBUG,
            )
            trb = traceback.format_exc()
            ret = {
                &quot;result&quot;: False,
                &quot;name&quot;: name,
                &quot;changes&quot;: {},
                &quot;comment&quot;: &quot;An exception occurred in this state: {}&quot;.format(trb),
            }

        utc_finish_time = datetime.datetime.utcnow()
        delta = utc_finish_time - utc_start_time
        # duration in milliseconds.microseconds
        duration = (delta.seconds * 1000000 + delta.microseconds) / 1000.0
        ret[&quot;duration&quot;] = duration

        troot = os.path.join(self.opts[&quot;cachedir&quot;], self.jid)
        tfile = os.path.join(troot, salt.utils.hashutils.sha1_digest(tag))
        if not os.path.isdir(troot):
            try:
                os.makedirs(troot)
            except OSError:
                # Looks like the directory was created between the check
                # and the attempt, we are safe to pass
                pass
        with salt.utils.files.fopen(tfile, &quot;wb+&quot;) as fp_:
            fp_.write(msgpack_serialize(ret))

    def call_parallel(self, cdata, low):
        &quot;&quot;&quot;
        Call the state defined in the given cdata in parallel
        &quot;&quot;&quot;
        # There are a number of possibilities to not have the cdata
        # populated with what we might have expected, so just be smart
        # enough to not raise another KeyError as the name is easily
        # guessable and fallback in all cases to present the real
        # exception to the user
        name = (cdata.get(&quot;args&quot;) or [None])[0] or cdata[&quot;kwargs&quot;].get(&quot;name&quot;)
        if not name:
            name = low.get(&quot;name&quot;, low.get(&quot;__id__&quot;))

        proc = salt.utils.process.Process(
            target=self._call_parallel_target,
            args=(name, cdata, low),
            name=&quot;ParallelState({})&quot;.format(name),
        )
        proc.start()
        ret = {
            &quot;name&quot;: name,
            &quot;result&quot;: None,
            &quot;changes&quot;: {},
            &quot;comment&quot;: &quot;Started in a separate process&quot;,
            &quot;proc&quot;: proc,
        }
        return ret

    @salt.utils.decorators.state.OutputUnifier(&quot;content_check&quot;, &quot;unify&quot;)
    def call(self, low, chunks=None, running=None, retries=1):
        &quot;&quot;&quot;
        Call a state directly with the low data structure, verify data
        before processing.
        &quot;&quot;&quot;
        utc_start_time = datetime.datetime.utcnow()
        local_start_time = utc_start_time - (
            datetime.datetime.utcnow() - datetime.datetime.now()
        )
        log.info(
            &quot;Running state [%s] at time %s&quot;,
            low[&quot;name&quot;].strip() if isinstance(low[&quot;name&quot;], str) else low[&quot;name&quot;],
            local_start_time.time().isoformat(),
        )
        errors = self.verify_data(low)
        if errors:
            ret = {
                &quot;result&quot;: False,
                &quot;name&quot;: low[&quot;name&quot;],
                &quot;changes&quot;: {},
                &quot;comment&quot;: &quot;&quot;,
            }
            for err in errors:
                ret[&quot;comment&quot;] += &quot;{}\n&quot;.format(err)
            ret[&quot;__run_num__&quot;] = self.__run_num
            self.__run_num += 1
            format_log(ret)
            self.check_refresh(low, ret)
            return ret
        else:
            ret = {&quot;result&quot;: False, &quot;name&quot;: low[&quot;name&quot;], &quot;changes&quot;: {}}

        self.state_con[&quot;runas&quot;] = low.get(&quot;runas&quot;, None)

        if low[&quot;state&quot;] == &quot;cmd&quot; and &quot;password&quot; in low:
            self.state_con[&quot;runas_password&quot;] = low[&quot;password&quot;]
        else:
            self.state_con[&quot;runas_password&quot;] = low.get(&quot;runas_password&quot;, None)

        if not low.get(&quot;__prereq__&quot;):
            log.info(
                &quot;Executing state %s.%s for [%s]&quot;,
                low[&quot;state&quot;],
                low[&quot;fun&quot;],
                low[&quot;name&quot;].strip() if isinstance(low[&quot;name&quot;], str) else low[&quot;name&quot;],
            )

        if &quot;provider&quot; in low:
            self.load_modules(low)

        state_func_name = &quot;{0[state]}.{0[fun]}&quot;.format(low)
        cdata = salt.utils.args.format_call(
            self.states[state_func_name],
            low,
            initial_ret={&quot;full&quot;: state_func_name},
            expected_extra_kws=STATE_INTERNAL_KEYWORDS,
        )
        inject_globals = {
            # Pass a copy of the running dictionary, the low state chunks and
            # the current state dictionaries.
            # We pass deep copies here because we don't want any misbehaving
            # state module to change these at runtime.
            &quot;__low__&quot;: immutabletypes.freeze(low),
            &quot;__running__&quot;: immutabletypes.freeze(running) if running else {},
            &quot;__instance_id__&quot;: self.instance_id,
            &quot;__lowstate__&quot;: immutabletypes.freeze(chunks) if chunks else {},
        }

        if &quot;__env__&quot; in low:
            inject_globals[&quot;__env__&quot;] = str(low[&quot;__env__&quot;])

        if self.inject_globals:
            inject_globals.update(self.inject_globals)

        if low.get(&quot;__prereq__&quot;):
            test = sys.modules[self.states[cdata[&quot;full&quot;]].__module__].__opts__[&quot;test&quot;]
            sys.modules[self.states[cdata[&quot;full&quot;]].__module__].__opts__[&quot;test&quot;] = True
        try:
            # Let's get a reference to the salt environment to use within this
            # state call.
            #
            # If the state function accepts an 'env' keyword argument, it
            # allows the state to be overridden(we look for that in cdata). If
            # that's not found in cdata, we look for what we're being passed in
            # the original data, namely, the special dunder __env__. If that's
            # not found we default to 'base'
            req_list = (&quot;unless&quot;, &quot;onlyif&quot;, &quot;creates&quot;)
            if (
                any(req in low for req in req_list)
                and &quot;{0[state]}.mod_run_check&quot;.format(low) not in self.states
            ):
                ret.update(self._run_check(low))

            if not self.opts.get(&quot;lock_saltenv&quot;, False):
                # NOTE: Overriding the saltenv when lock_saltenv is blocked in
                # salt/modules/state.py, before we ever get here, but this
                # additional check keeps use of the State class outside of the
                # salt/modules/state.py from getting around this setting.
                if &quot;saltenv&quot; in low:
                    inject_globals[&quot;__env__&quot;] = str(low[&quot;saltenv&quot;])
                elif isinstance(cdata[&quot;kwargs&quot;].get(&quot;env&quot;, None), str):
                    # User is using a deprecated env setting which was parsed by
                    # format_call.
                    # We check for a string type since module functions which
                    # allow setting the OS environ also make use of the &quot;env&quot;
                    # keyword argument, which is not a string
                    inject_globals[&quot;__env__&quot;] = str(cdata[&quot;kwargs&quot;][&quot;env&quot;])

            if &quot;__env__&quot; not in inject_globals:
                # Let's use the default environment
                inject_globals[&quot;__env__&quot;] = &quot;base&quot;

            if &quot;__orchestration_jid__&quot; in low:
                inject_globals[&quot;__orchestration_jid__&quot;] = low[&quot;__orchestration_jid__&quot;]

            if &quot;result&quot; not in ret or ret[&quot;result&quot;] is False:
                self.states.inject_globals = inject_globals
                if self.mocked:
                    ret = mock_ret(cdata)
                else:
                    # Execute the state function
                    if not low.get(&quot;__prereq__&quot;) and low.get(&quot;parallel&quot;):
                        # run the state call in parallel, but only if not in a prereq
                        ret = self.call_parallel(cdata, low)
                    else:
                        self.format_slots(cdata)
                        ret = self.states[cdata[&quot;full&quot;]](
                            *cdata[&quot;args&quot;], **cdata[&quot;kwargs&quot;]
                        )
                self.states.inject_globals = {}
            if (
                &quot;check_cmd&quot; in low
                and &quot;{0[state]}.mod_run_check_cmd&quot;.format(low) not in self.states
            ):
                ret.update(self._run_check_cmd(low))
        except Exception as exc:  # pylint: disable=broad-except
            log.debug(
                &quot;An exception occurred in this state: %s&quot;,
                exc,
                exc_info_on_loglevel=logging.DEBUG,
            )
            trb = traceback.format_exc()
            # There are a number of possibilities to not have the cdata
            # populated with what we might have expected, so just be smart
            # enough to not raise another KeyError as the name is easily
            # guessable and fallback in all cases to present the real
            # exception to the user
            name = (cdata.get(&quot;args&quot;) or [None])[0] or cdata[&quot;kwargs&quot;].get(&quot;name&quot;)
            if not name:
                name = low.get(&quot;name&quot;, low.get(&quot;__id__&quot;))

            ret = {
                &quot;result&quot;: False,
                &quot;name&quot;: name,
                &quot;changes&quot;: {},
                &quot;comment&quot;: &quot;An exception occurred in this state: {}&quot;.format(trb),
            }
        finally:
            if low.get(&quot;__prereq__&quot;):
                sys.modules[self.states[cdata[&quot;full&quot;]].__module__].__opts__[
                    &quot;test&quot;
                ] = test

            self.state_con.pop(&quot;runas&quot;, None)
            self.state_con.pop(&quot;runas_password&quot;, None)

        if not isinstance(ret, dict):
            return ret

        # If format_call got any warnings, let's show them to the user
        if &quot;warnings&quot; in cdata:
            ret.setdefault(&quot;warnings&quot;, []).extend(cdata[&quot;warnings&quot;])

        if &quot;provider&quot; in low:
            self.load_modules()

        if low.get(&quot;__prereq__&quot;):
            low[&quot;__prereq__&quot;] = False
            return ret

        ret[&quot;__sls__&quot;] = low.get(&quot;__sls__&quot;)
        ret[&quot;__run_num__&quot;] = self.__run_num
        self.__run_num += 1
        format_log(ret)
        self.check_refresh(low, ret)
        utc_finish_time = datetime.datetime.utcnow()
        timezone_delta = datetime.datetime.utcnow() - datetime.datetime.now()
        local_finish_time = utc_finish_time - timezone_delta
        local_start_time = utc_start_time - timezone_delta
<A NAME="4"></A>        ret[&quot;start_time&quot;] = local_start_time.time().isoformat()
        delta = utc_finish_time - utc_start_time
        # duration in milliseconds.microseconds
        duration = (delta<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#4',2,'match147349-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.seconds * 1000000 + delta.microseconds) / 1000.0
        ret[&quot;duration&quot;] = duration
        ret[&quot;__id__&quot;] = low[&quot;__id__&quot;]
        log.info(
            &quot;Completed state [%s] at time %s (duration_in_ms=%s)&quot;,
            low[&quot;name&quot;].strip(</B></FONT>) if isinstance(low[&quot;name&quot;], str) else low[&quot;name&quot;],
            local_finish_time.time().isoformat(),
            duration,
        )
        if &quot;retry&quot; in low:
            low[&quot;retry&quot;] = self.verify_retry_data(low[&quot;retry&quot;])
            if not sys.modules[self.states[cdata[&quot;full&quot;]].__module__].__opts__[&quot;test&quot;]:
                if low[&quot;retry&quot;][&quot;until&quot;] != ret[&quot;result&quot;]:
                    if low[&quot;retry&quot;][&quot;attempts&quot;] &gt; retries:
                        interval = low[&quot;retry&quot;][&quot;interval&quot;]
                        if low[&quot;retry&quot;][&quot;splay&quot;] != 0:
                            interval = interval + random.randint(
                                0, low[&quot;retry&quot;][&quot;splay&quot;]
                            )
                        log.info(
                            &quot;State result does not match retry until value, &quot;
                            &quot;state will be re-run in %s seconds&quot;,
                            interval,
                        )
                        self.functions[&quot;test.sleep&quot;](interval)
                        retry_ret = self.call(low, chunks, running, retries=retries + 1)
                        orig_ret = ret
                        ret = retry_ret
                        ret[&quot;comment&quot;] = &quot;\n&quot;.join(
                            [
                                'Attempt {}: Returned a result of &quot;{}&quot;, '
                                'with the following comment: &quot;{}&quot;'.format(
                                    retries, orig_ret[&quot;result&quot;], orig_ret[&quot;comment&quot;]
                                ),
                                &quot;&quot; if not ret[&quot;comment&quot;] else ret[&quot;comment&quot;],
                            ]
                        )
                        ret[&quot;duration&quot;] = (
                            ret[&quot;duration&quot;] + orig_ret[&quot;duration&quot;] + (interval * 1000)
                        )
                        if retries == 1:
                            ret[&quot;start_time&quot;] = orig_ret[&quot;start_time&quot;]
            else:
                ret[&quot;comment&quot;] = &quot;  &quot;.join(
                    [
                        &quot;&quot; if not ret[&quot;comment&quot;] else str(ret[&quot;comment&quot;]),
                        &quot;The state would be retried every {interval} seconds &quot;
                        &quot;(with a splay of up to {splay} seconds) a maximum of &quot;
                        &quot;{attempts} times or until a result of {until} &quot;
                        &quot;is returned&quot;.format(**low[&quot;retry&quot;]),
                    ]
                )
        return ret

    def __eval_slot(self, slot):
        log.debug(&quot;Evaluating slot: %s&quot;, slot)
        fmt = slot.split(&quot;:&quot;, 2)
        if len(fmt) != 3:
            log.warning(&quot;Malformed slot: %s&quot;, slot)
            return slot
        if fmt[1] != &quot;salt&quot;:
            log.warning(&quot;Malformed slot: %s&quot;, slot)
            log.warning(
                &quot;Only execution modules are currently supported in slots. This means&quot;
                ' slot should start with &quot;__slot__:salt:&quot;'
            )
            return slot
        fun, args, kwargs = salt.utils.args.parse_function(fmt[2])
        if not fun or fun not in self.functions:
            log.warning(&quot;Malformed slot: %s&quot;, slot)
            log.warning(
                &quot;Execution module should be specified in a function call format: &quot;
                &quot;test.arg('arg', kw='kwarg')&quot;
            )
            return slot
        log.debug(&quot;Calling slot: %s(%s, %s)&quot;, fun, args, kwargs)
        slot_return = self.functions[fun](*args, **kwargs)

        # Given input  __slot__:salt:test.arg(somekey=&quot;value&quot;).not.exist ~ /appended
        # slot_text should be __slot...).not.exist
        # append_data should be ~ /appended
        slot_text = fmt[2].split(&quot;~&quot;)[0]
        append_data = fmt[2].split(&quot;~&quot;, 1)[1:]
        log.debug(&quot;slot_text: %s&quot;, slot_text)
        log.debug(&quot;append_data: %s&quot;, append_data)

        # Support parsing slot dict response
        # return_get should result in a kwargs.nested.dict path by getting
        # everything after first closing paren: )
        return_get = None
        try:
            return_get = slot_text[slot_text.rindex(&quot;)&quot;) + 1 :]
        except ValueError:
            pass
        if return_get:
            # remove first period
            return_get = return_get.split(&quot;.&quot;, 1)[1].strip()
            log.debug(&quot;Searching slot result %s for %s&quot;, slot_return, return_get)
            slot_return = salt.utils.data.traverse_dict_and_list(
                slot_return, return_get, default=None, delimiter=&quot;.&quot;
            )

        if append_data:
            if isinstance(slot_return, str):
                # Append text to slot string result
                append_data = &quot; &quot;.join(append_data).strip()
                log.debug(&quot;appending to slot result: %s&quot;, append_data)
                slot_return += append_data
            else:
                log.error(&quot;Ignoring slot append, slot result is not a string&quot;)

        return slot_return

    def format_slots(self, cdata):
        &quot;&quot;&quot;
        Read in the arguments from the low level slot syntax to make a last
        minute runtime call to gather relevant data for the specific routine

        Will parse strings, first level of dictionary values, and strings and
        first level dict values inside of lists
        &quot;&quot;&quot;
        # __slot__:salt.cmd.run(foo, bar, baz=qux)
        SLOT_TEXT = &quot;__slot__:&quot;
        ctx = ((&quot;args&quot;, enumerate(cdata[&quot;args&quot;])), (&quot;kwargs&quot;, cdata[&quot;kwargs&quot;].items()))
        for atype, avalues in ctx:
            for ind, arg in avalues:
                arg = salt.utils.data.decode(arg, keep=True)
                if isinstance(arg, dict):
                    # Search dictionary values for __slot__:
                    for key, value in arg.items():
                        try:
                            if value.startswith(SLOT_TEXT):
                                log.trace(&quot;Slot processsing dict value %s&quot;, value)
                                cdata[atype][ind][key] = self.__eval_slot(value)
                        except AttributeError:
                            # Not a string/slot
                            continue
                elif isinstance(arg, list):
                    for idx, listvalue in enumerate(arg):
                        log.trace(&quot;Slot processing list value: %s&quot;, listvalue)
                        if isinstance(listvalue, dict):
                            # Search dict values in list for __slot__:
                            for key, value in listvalue.items():
                                try:
                                    if value.startswith(SLOT_TEXT):
                                        log.trace(
                                            &quot;Slot processsing nested dict value %s&quot;,
                                            value,
                                        )
                                        cdata[atype][ind][idx][key] = self.__eval_slot(
                                            value
                                        )
                                except AttributeError:
                                    # Not a string/slot
                                    continue
                        if isinstance(listvalue, str):
                            # Search strings in a list for __slot__:
                            if listvalue.startswith(SLOT_TEXT):
                                log.trace(
                                    &quot;Slot processsing nested string %s&quot;, listvalue
                                )
                                cdata[atype][ind][idx] = self.__eval_slot(listvalue)
                elif isinstance(arg, str) and arg.startswith(SLOT_TEXT):
                    # Search strings for __slot__:
                    log.trace(&quot;Slot processsing %s&quot;, arg)
                    cdata[atype][ind] = self.__eval_slot(arg)
                else:
                    # Not a slot, skip it
                    continue

    def verify_retry_data(self, retry_data):
        &quot;&quot;&quot;
        verifies the specified retry data
        &quot;&quot;&quot;
        retry_defaults = {
            &quot;until&quot;: True,
            &quot;attempts&quot;: 2,
            &quot;splay&quot;: 0,
            &quot;interval&quot;: 30,
        }
        expected_data = {
            &quot;until&quot;: bool,
            &quot;attempts&quot;: int,
            &quot;interval&quot;: int,
            &quot;splay&quot;: int,
        }
        validated_retry_data = {}
        if isinstance(retry_data, dict):
            for expected_key, value_type in expected_data.items():
                if expected_key in retry_data:
                    if isinstance(retry_data[expected_key], value_type):
                        validated_retry_data[expected_key] = retry_data[expected_key]
                    else:
                        log.warning(
                            &quot;An invalid value was passed for the retry %s, &quot;
                            &quot;using default value '%s'&quot;,
                            expected_key,
                            retry_defaults[expected_key],
                        )
                        validated_retry_data[expected_key] = retry_defaults[
                            expected_key
                        ]
                else:
                    validated_retry_data[expected_key] = retry_defaults[expected_key]
        else:
            log.warning(
                &quot;State is set to retry, but a valid dict for retry &quot;
                &quot;configuration was not found.  Using retry defaults&quot;
            )
            validated_retry_data = retry_defaults
        return validated_retry_data

    def call_chunks(self, chunks):
        &quot;&quot;&quot;
        Iterate over a list of chunks and call them, checking for requires.
        &quot;&quot;&quot;
        # Check for any disabled states
        disabled = {}
        if &quot;state_runs_disabled&quot; in self.opts[&quot;grains&quot;]:
            for low in chunks[:]:
                state_ = &quot;{}.{}&quot;.format(low[&quot;state&quot;], low[&quot;fun&quot;])
                for pat in self.opts[&quot;grains&quot;][&quot;state_runs_disabled&quot;]:
                    if fnmatch.fnmatch(state_, pat):
                        comment = (
                            'The state function &quot;{0}&quot; is currently disabled by &quot;{1}&quot;, '
                            &quot;to re-enable, run state.enable {1}.&quot;.format(
                                state_,
                                pat,
                            )
                        )
                        _tag = _gen_tag(low)
                        disabled[_tag] = {
                            &quot;changes&quot;: {},
                            &quot;result&quot;: False,
                            &quot;comment&quot;: comment,
                            &quot;__run_num__&quot;: self.__run_num,
                            &quot;__sls__&quot;: low[&quot;__sls__&quot;],
                        }
                        self.__run_num += 1
                        chunks.remove(low)
                        break
        running = {}
        for low in chunks:
            if &quot;__FAILHARD__&quot; in running:
                running.pop(&quot;__FAILHARD__&quot;)
                return running
            tag = _gen_tag(low)
            if tag not in running:
                # Check if this low chunk is paused
                action = self.check_pause(low)
                if action == &quot;kill&quot;:
                    break
                running = self.call_chunk(low, running, chunks)
                if self.check_failhard(low, running):
                    return running
            self.active = set()
        while True:
            if self.reconcile_procs(running):
                break
            time.sleep(0.01)
        ret = dict(list(disabled.items()) + list(running.items()))
        return ret

    def check_failhard(self, low, running):
        &quot;&quot;&quot;
        Check if the low data chunk should send a failhard signal
        &quot;&quot;&quot;
        tag = _gen_tag(low)
        if self.opts.get(&quot;test&quot;, False):
            return False
        if low.get(&quot;failhard&quot;, self.opts[&quot;failhard&quot;]) and tag in running:
            if running[tag][&quot;result&quot;] is None:
                return False
            return not running[tag][&quot;result&quot;]
        return False

    def check_pause(self, low):
        &quot;&quot;&quot;
        Check to see if this low chunk has been paused
        &quot;&quot;&quot;
        if not self.jid:
            # Can't pause on salt-ssh since we can't track continuous state
            return
        pause_path = os.path.join(self.opts[&quot;cachedir&quot;], &quot;state_pause&quot;, self.jid)
        start = time.time()
        if os.path.isfile(pause_path):
            try:
                while True:
                    tries = 0
                    with salt.utils.files.fopen(pause_path, &quot;rb&quot;) as fp_:
                        try:
                            pdat = msgpack_deserialize(fp_.read())
                        except salt.utils.msgpack.exceptions.UnpackValueError:
                            # Reading race condition
                            if tries &gt; 10:
                                # Break out if there are a ton of read errors
                                return
                            tries += 1
                            time.sleep(1)
                            continue
                        id_ = low[&quot;__id__&quot;]
                        key = &quot;&quot;
                        if id_ in pdat:
                            key = id_
                        elif &quot;__all__&quot; in pdat:
                            key = &quot;__all__&quot;
                        if key:
                            if &quot;duration&quot; in pdat[key]:
                                now = time.time()
                                if now - start &gt; pdat[key][&quot;duration&quot;]:
                                    return &quot;run&quot;
                            if &quot;kill&quot; in pdat[key]:
                                return &quot;kill&quot;
                        else:
                            return &quot;run&quot;
                        time.sleep(1)
            except Exception as exc:  # pylint: disable=broad-except
                log.error(
                    &quot;Failed to read in pause data for file located at: %s&quot;, pause_path
                )
                return &quot;run&quot;
        return &quot;run&quot;

    def reconcile_procs(self, running):
        &quot;&quot;&quot;
        Check the running dict for processes and resolve them
        &quot;&quot;&quot;
        retset = set()
        for tag in running:
            proc = running[tag].get(&quot;proc&quot;)
            if proc:
                if not proc.is_alive():
                    ret_cache = os.path.join(
                        self.opts[&quot;cachedir&quot;],
                        self.jid,
                        salt.utils.hashutils.sha1_digest(tag),
                    )
                    if not os.path.isfile(ret_cache):
                        ret = {
                            &quot;result&quot;: False,
                            &quot;comment&quot;: &quot;Parallel process failed to return&quot;,
                            &quot;name&quot;: running[tag][&quot;name&quot;],
                            &quot;changes&quot;: {},
                        }
                    try:
                        with salt.utils.files.fopen(ret_cache, &quot;rb&quot;) as fp_:
                            ret = msgpack_deserialize(fp_.read())
                    except OSError:
                        ret = {
                            &quot;result&quot;: False,
                            &quot;comment&quot;: &quot;Parallel cache failure&quot;,
                            &quot;name&quot;: running[tag][&quot;name&quot;],
                            &quot;changes&quot;: {},
                        }
                    running[tag].update(ret)
                    running[tag].pop(&quot;proc&quot;)
                else:
                    retset.add(False)
        return False not in retset

    def check_requisite(self, low, running, chunks, pre=False):
        &quot;&quot;&quot;
        Look into the running data to check the status of all requisite
        states
        &quot;&quot;&quot;
        disabled_reqs = self.opts.get(&quot;disabled_requisites&quot;, [])
        if not isinstance(disabled_reqs, list):
            disabled_reqs = [disabled_reqs]
        present = False
        # If mod_watch is not available make it a require
        if &quot;watch&quot; in low:
            if &quot;{}.mod_watch&quot;.format(low[&quot;state&quot;]) not in self.states:
                if &quot;require&quot; in low:
                    low[&quot;require&quot;].extend(low.pop(&quot;watch&quot;))
                else:
                    low[&quot;require&quot;] = low.pop(&quot;watch&quot;)
            else:
                present = True
        if &quot;watch_any&quot; in low:
            if &quot;{}.mod_watch&quot;.format(low[&quot;state&quot;]) not in self.states:
                if &quot;require_any&quot; in low:
                    low[&quot;require_any&quot;].extend(low.pop(&quot;watch_any&quot;))
                else:
                    low[&quot;require_any&quot;] = low.pop(&quot;watch_any&quot;)
            else:
                present = True
        if &quot;require&quot; in low:
            present = True
        if &quot;require_any&quot; in low:
            present = True
        if &quot;prerequired&quot; in low:
            present = True
        if &quot;prereq&quot; in low:
            present = True
        if &quot;onfail&quot; in low:
            present = True
        if &quot;onfail_any&quot; in low:
            present = True
        if &quot;onfail_all&quot; in low:
            present = True
        if &quot;onchanges&quot; in low:
            present = True
        if &quot;onchanges_any&quot; in low:
            present = True
        if not present:
            return &quot;met&quot;, ()
        self.reconcile_procs(running)
        reqs = {
            &quot;require&quot;: [],
            &quot;require_any&quot;: [],
            &quot;watch&quot;: [],
            &quot;watch_any&quot;: [],
            &quot;prereq&quot;: [],
            &quot;onfail&quot;: [],
            &quot;onfail_any&quot;: [],
            &quot;onfail_all&quot;: [],
            &quot;onchanges&quot;: [],
            &quot;onchanges_any&quot;: [],
        }
        if pre:
            reqs[&quot;prerequired&quot;] = []
        for r_state in reqs:
            if r_state in low and low[r_state] is not None:
                if r_state in disabled_reqs:
                    log.warning(
                        &quot;The %s requisite has been disabled, Ignoring.&quot;, r_state
                    )
                    continue
                for req in low[r_state]:
                    if isinstance(req, str):
                        req = {&quot;id&quot;: req}
                    req = trim_req(req)
                    found = False
                    for chunk in chunks:
                        req_key = next(iter(req))
                        req_val = req[req_key]
                        if req_val is None:
                            continue
                        if req_key == &quot;sls&quot;:
                            # Allow requisite tracking of entire sls files
                            if fnmatch.fnmatch(chunk[&quot;__sls__&quot;], req_val):
                                found = True
                                reqs[r_state].append(chunk)
                            continue
                        try:
                            if isinstance(req_val, str):
                                if fnmatch.fnmatch(
                                    chunk[&quot;name&quot;], req_val
                                ) or fnmatch.fnmatch(chunk[&quot;__id__&quot;], req_val):
                                    if req_key == &quot;id&quot; or chunk[&quot;state&quot;] == req_key:
                                        found = True
                                        reqs[r_state].append(chunk)
                            else:
                                raise KeyError
                        except KeyError as exc:
                            raise SaltRenderError(
                                &quot;Could not locate requisite of [{}] present in state&quot;
                                &quot; with name [{}]&quot;.format(req_key, chunk[&quot;name&quot;])
                            )
                        except TypeError:
                            # On Python 2, the above req_val, being an OrderedDict, will raise a KeyError,
                            # however on Python 3 it will raise a TypeError
                            # This was found when running tests.unit.test_state.StateCompilerTestCase.test_render_error_on_invalid_requisite
                            raise SaltRenderError(
                                &quot;Could not locate requisite of [{}] present in state&quot;
                                &quot; with name [{}]&quot;.format(req_key, chunk[&quot;name&quot;])
                            )
                    if not found:
                        return &quot;unmet&quot;, ()
        fun_stats = set()
        for r_state, chunks in reqs.items():
            req_stats = set()
            if r_state.startswith(&quot;prereq&quot;) and not r_state.startswith(&quot;prerequired&quot;):
                run_dict = self.pre
            else:
                run_dict = running

            filtered_run_dict = {}
            for chunk in chunks:
                tag = _gen_tag(chunk)
                run_dict_chunk = run_dict.get(tag)
                if run_dict_chunk:
                    filtered_run_dict[tag] = run_dict_chunk
            run_dict = filtered_run_dict

            while True:
                if self.reconcile_procs(run_dict):
                    break
                time.sleep(0.01)

            for chunk in chunks:
                tag = _gen_tag(chunk)
                if tag not in run_dict:
                    req_stats.add(&quot;unmet&quot;)
                    continue
                if r_state.startswith(&quot;onfail&quot;):
                    if run_dict[tag][&quot;result&quot;] is True:
                        req_stats.add(&quot;onfail&quot;)  # At least one state is OK
                        continue
                else:
                    if run_dict[tag][&quot;result&quot;] is False:
                        req_stats.add(&quot;fail&quot;)
                        continue
                if r_state.startswith(&quot;onchanges&quot;):
                    if not run_dict[tag][&quot;changes&quot;]:
                        req_stats.add(&quot;onchanges&quot;)
                    else:
                        req_stats.add(&quot;onchangesmet&quot;)
                    continue
                if r_state.startswith(&quot;watch&quot;) and run_dict[tag][&quot;changes&quot;]:
                    req_stats.add(&quot;change&quot;)
                    continue
                if r_state.startswith(&quot;prereq&quot;) and run_dict[tag][&quot;result&quot;] is None:
                    if not r_state.startswith(&quot;prerequired&quot;):
                        req_stats.add(&quot;premet&quot;)
                if r_state.startswith(&quot;prereq&quot;) and not run_dict[tag][&quot;result&quot;] is None:
                    if not r_state.startswith(&quot;prerequired&quot;):
                        req_stats.add(&quot;pre&quot;)
                else:
                    if run_dict[tag].get(&quot;__state_ran__&quot;, True):
                        req_stats.add(&quot;met&quot;)
            if r_state.endswith(&quot;_any&quot;) or r_state == &quot;onfail&quot;:
                if &quot;met&quot; in req_stats or &quot;change&quot; in req_stats:
                    if &quot;fail&quot; in req_stats:
                        req_stats.remove(&quot;fail&quot;)
                if &quot;onchangesmet&quot; in req_stats:
                    if &quot;onchanges&quot; in req_stats:
                        req_stats.remove(&quot;onchanges&quot;)
                    if &quot;fail&quot; in req_stats:
                        req_stats.remove(&quot;fail&quot;)
                if &quot;onfail&quot; in req_stats:
                    # a met requisite in this case implies a success
                    if &quot;met&quot; in req_stats:
                        req_stats.remove(&quot;onfail&quot;)
            if r_state.endswith(&quot;_all&quot;):
                if &quot;onfail&quot; in req_stats:
                    # a met requisite in this case implies a failure
                    if &quot;met&quot; in req_stats:
                        req_stats.remove(&quot;met&quot;)
            fun_stats.update(req_stats)

        if &quot;unmet&quot; in fun_stats:
            status = &quot;unmet&quot;
        elif &quot;fail&quot; in fun_stats:
            status = &quot;fail&quot;
        elif &quot;pre&quot; in fun_stats:
            if &quot;premet&quot; in fun_stats:
                status = &quot;met&quot;
            else:
                status = &quot;pre&quot;
        elif &quot;onfail&quot; in fun_stats and &quot;onchangesmet&quot; not in fun_stats:
            status = &quot;onfail&quot;
        elif &quot;onchanges&quot; in fun_stats and &quot;onchangesmet&quot; not in fun_stats:
            status = &quot;onchanges&quot;
        elif &quot;change&quot; in fun_stats:
            status = &quot;change&quot;
        elif &quot;onfail&quot; in fun_stats:
            status = &quot;onfail&quot;
        else:
            status = &quot;met&quot;

        return status, reqs

    def event(self, chunk_ret, length, fire_event=False):
        &quot;&quot;&quot;
        Fire an event on the master bus

        If `fire_event` is set to True an event will be sent with the
        chunk name in the tag and the chunk result in the event data.

        If `fire_event` is set to a string such as `mystate/is/finished`,
        an event will be sent with the string added to the tag and the chunk
        result in the event data.

        If the `state_events` is set to True in the config, then after the
        chunk is evaluated an event will be set up to the master with the
        results.
        &quot;&quot;&quot;
        if not self.opts.get(&quot;local&quot;) and (
            self.opts.get(&quot;state_events&quot;, True) or fire_event
        ):
            if not self.opts.get(&quot;master_uri&quot;):
                ev_func = (
                    lambda ret, tag, preload=None: salt.utils.event.get_master_event(
                        self.opts, self.opts[&quot;sock_dir&quot;], listen=False
                    ).fire_event(ret, tag)
                )
            else:
                ev_func = self.functions[&quot;event.fire_master&quot;]

            ret = {&quot;ret&quot;: chunk_ret}
            if fire_event is True:
                tag = salt.utils.event.tagify(
                    [self.jid, self.opts[&quot;id&quot;], str(chunk_ret[&quot;name&quot;])],
                    &quot;state_result&quot;,
                )
            elif isinstance(fire_event, str):
                tag = salt.utils.event.tagify(
                    [self.jid, self.opts[&quot;id&quot;], str(fire_event)],
<A NAME="2"></A>                    &quot;state_result&quot;,
                )
            else:
                tag = salt<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#2',2,'match147349-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.utils.event.tagify(
                    [self.jid, &quot;prog&quot;, self.opts[&quot;id&quot;], str(chunk_ret[&quot;__run_num__&quot;])],
                    &quot;job&quot;,
                )
                ret[&quot;len&quot;] =</B></FONT> length
            preload = {&quot;jid&quot;: self.jid}
            ev_func(ret, tag, preload=preload)

    def call_chunk(self, low, running, chunks):
        &quot;&quot;&quot;
        Check if a chunk has any requires, execute the requires and then
        the chunk
        &quot;&quot;&quot;
        low = self._mod_aggregate(low, running, chunks)
        self._mod_init(low)
        tag = _gen_tag(low)
        if not low.get(&quot;prerequired&quot;):
            self.active.add(tag)
        requisites = [
            &quot;require&quot;,
            &quot;require_any&quot;,
            &quot;watch&quot;,
            &quot;watch_any&quot;,
            &quot;prereq&quot;,
            &quot;onfail&quot;,
            &quot;onfail_any&quot;,
            &quot;onchanges&quot;,
            &quot;onchanges_any&quot;,
        ]
        if not low.get(&quot;__prereq__&quot;):
            requisites.append(&quot;prerequired&quot;)
            status, reqs = self.check_requisite(low, running, chunks, pre=True)
        else:
            status, reqs = self.check_requisite(low, running, chunks)
        if status == &quot;unmet&quot;:
            lost = {}
            reqs = []
            for requisite in requisites:
                lost[requisite] = []
                if requisite not in low:
                    continue
                for req in low[requisite]:
                    if isinstance(req, str):
                        req = {&quot;id&quot;: req}
                    req = trim_req(req)
                    found = False
                    req_key = next(iter(req))
                    req_val = req[req_key]
                    for chunk in chunks:
                        if req_val is None:
                            continue
                        if req_key == &quot;sls&quot;:
                            # Allow requisite tracking of entire sls files
                            if fnmatch.fnmatch(chunk[&quot;__sls__&quot;], req_val):
                                if requisite == &quot;prereq&quot;:
                                    chunk[&quot;__prereq__&quot;] = True
                                reqs.append(chunk)
                                found = True
                            continue
                        if fnmatch.fnmatch(chunk[&quot;name&quot;], req_val) or fnmatch.fnmatch(
                            chunk[&quot;__id__&quot;], req_val
                        ):
                            if req_key == &quot;id&quot; or chunk[&quot;state&quot;] == req_key:
                                if requisite == &quot;prereq&quot;:
                                    chunk[&quot;__prereq__&quot;] = True
                                elif requisite == &quot;prerequired&quot;:
                                    chunk[&quot;__prerequired__&quot;] = True
                                reqs.append(chunk)
                                found = True
                    if not found:
                        lost[requisite].append(req)
            if (
                lost[&quot;require&quot;]
                or lost[&quot;watch&quot;]
                or lost[&quot;prereq&quot;]
                or lost[&quot;onfail&quot;]
                or lost[&quot;onchanges&quot;]
                or lost[&quot;require_any&quot;]
                or lost[&quot;watch_any&quot;]
                or lost[&quot;onfail_any&quot;]
                or lost[&quot;onchanges_any&quot;]
                or lost.get(&quot;prerequired&quot;)
            ):
                comment = &quot;The following requisites were not found:\n&quot;
                for requisite, lreqs in lost.items():
                    if not lreqs:
                        continue
                    comment += &quot;{}{}:\n&quot;.format(&quot; &quot; * 19, requisite)
                    for lreq in lreqs:
                        req_key = next(iter(lreq))
                        req_val = lreq[req_key]
                        comment += &quot;{}{}: {}\n&quot;.format(&quot; &quot; * 23, req_key, req_val)
                if low.get(&quot;__prereq__&quot;):
                    run_dict = self.pre
                else:
                    run_dict = running
                start_time, duration = _calculate_fake_duration()
                run_dict[tag] = {
                    &quot;changes&quot;: {},
                    &quot;result&quot;: False,
                    &quot;duration&quot;: duration,
                    &quot;start_time&quot;: start_time,
                    &quot;comment&quot;: comment,
                    &quot;__run_num__&quot;: self.__run_num,
                    &quot;__sls__&quot;: low[&quot;__sls__&quot;],
                }
                self.__run_num += 1
                self.event(run_dict[tag], len(chunks), fire_event=low.get(&quot;fire_event&quot;))
                return running
            for chunk in reqs:
                # Check to see if the chunk has been run, only run it if
                # it has not been run already
                ctag = _gen_tag(chunk)
                if ctag not in running:
                    if ctag in self.active:
                        if chunk.get(&quot;__prerequired__&quot;):
                            # Prereq recusive, run this chunk with prereq on
                            if tag not in self.pre:
                                low[&quot;__prereq__&quot;] = True
                                self.pre[ctag] = self.call(low, chunks, running)
                                return running
                            else:
                                return running
                        elif ctag not in running:
                            log.error(&quot;Recursive requisite found&quot;)
                            running[tag] = {
                                &quot;changes&quot;: {},
                                &quot;result&quot;: False,
                                &quot;comment&quot;: &quot;Recursive requisite found&quot;,
                                &quot;__run_num__&quot;: self.__run_num,
                                &quot;__sls__&quot;: low[&quot;__sls__&quot;],
                            }
                        self.__run_num += 1
                        self.event(
                            running[tag], len(chunks), fire_event=low.get(&quot;fire_event&quot;)
                        )
                        return running
                    running = self.call_chunk(chunk, running, chunks)
                    if self.check_failhard(chunk, running):
                        running[&quot;__FAILHARD__&quot;] = True
                        return running
            if low.get(&quot;__prereq__&quot;):
                status, reqs = self.check_requisite(low, running, chunks)
                self.pre[tag] = self.call(low, chunks, running)
                if not self.pre[tag][&quot;changes&quot;] and status == &quot;change&quot;:
                    self.pre[tag][&quot;changes&quot;] = {&quot;watch&quot;: &quot;watch&quot;}
                    self.pre[tag][&quot;result&quot;] = None
            else:
                running = self.call_chunk(low, running, chunks)
            if self.check_failhard(chunk, running):
                running[&quot;__FAILHARD__&quot;] = True
                return running
        elif status == &quot;met&quot;:
            if low.get(&quot;__prereq__&quot;):
                self.pre[tag] = self.call(low, chunks, running)
            else:
                running[tag] = self.call(low, chunks, running)
        elif status == &quot;fail&quot;:
<A NAME="6"></A>            # if the requisite that failed was due to a prereq on this low state
            # show the normal error
            if tag in self.pre:
                running<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#6',2,'match147349-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[tag] = self.pre[tag]
                running[tag][&quot;__run_num__&quot;] = self.__run_num
                running[tag][&quot;__sls__&quot;] = low[</B></FONT>&quot;__sls__&quot;]
            # otherwise the failure was due to a requisite down the chain
            else:
                # determine what the requisite failures where, and return
                # a nice error message
                failed_requisites = set()
                # look at all requisite types for a failure
                for req_lows in reqs.values():
                    for req_low in req_lows:
                        req_tag = _gen_tag(req_low)
                        req_ret = self.pre.get(req_tag, running.get(req_tag))
                        # if there is no run output for the requisite it
                        # can't be the failure
                        if req_ret is None:
                            continue
                        # If the result was False (not None) it was a failure
                        if req_ret[&quot;result&quot;] is False:
                            # use SLS.ID for the key-- so its easier to find
                            key = &quot;{sls}.{_id}&quot;.format(
                                sls=req_low[&quot;__sls__&quot;], _id=req_low[&quot;__id__&quot;]
                            )
                            failed_requisites.add(key)

                _cmt = &quot;One or more requisite failed: {}&quot;.format(
                    &quot;, &quot;.join(str(i) for i in failed_requisites)
                )
                start_time, duration = _calculate_fake_duration()
                running[tag] = {
                    &quot;changes&quot;: {},
                    &quot;result&quot;: False,
                    &quot;duration&quot;: duration,
                    &quot;start_time&quot;: start_time,
                    &quot;comment&quot;: _cmt,
                    &quot;__run_num__&quot;: self.__run_num,
                    &quot;__sls__&quot;: low[&quot;__sls__&quot;],
                }
                self.pre[tag] = running[tag]
            self.__run_num += 1
        elif status == &quot;change&quot; and not low.get(&quot;__prereq__&quot;):
            ret = self.call(low, chunks, running)
            if not ret[&quot;changes&quot;] and not ret.get(&quot;skip_watch&quot;, False):
                low = low.copy()
                low[&quot;sfun&quot;] = low[&quot;fun&quot;]
                low[&quot;fun&quot;] = &quot;mod_watch&quot;
                low[&quot;__reqs__&quot;] = reqs
                ret = self.call(low, chunks, running)
            running[tag] = ret
        elif status == &quot;pre&quot;:
            start_time, duration = _calculate_fake_duration()
            pre_ret = {
                &quot;changes&quot;: {},
                &quot;result&quot;: True,
                &quot;duration&quot;: duration,
                &quot;start_time&quot;: start_time,
                &quot;comment&quot;: &quot;No changes detected&quot;,
                &quot;__run_num__&quot;: self.__run_num,
                &quot;__sls__&quot;: low[&quot;__sls__&quot;],
            }
            running[tag] = pre_ret
            self.pre[tag] = pre_ret
            self.__run_num += 1
        elif status == &quot;onfail&quot;:
            start_time, duration = _calculate_fake_duration()
            running[tag] = {
                &quot;changes&quot;: {},
                &quot;result&quot;: True,
                &quot;duration&quot;: duration,
                &quot;start_time&quot;: start_time,
                &quot;comment&quot;: &quot;State was not run because onfail req did not change&quot;,
                &quot;__state_ran__&quot;: False,
                &quot;__run_num__&quot;: self.__run_num,
                &quot;__sls__&quot;: low[&quot;__sls__&quot;],
            }
            self.__run_num += 1
        elif status == &quot;onchanges&quot;:
            start_time, duration = _calculate_fake_duration()
            running[tag] = {
                &quot;changes&quot;: {},
                &quot;result&quot;: True,
                &quot;duration&quot;: duration,
                &quot;start_time&quot;: start_time,
                &quot;comment&quot;: (
                    &quot;State was not run because none of the onchanges reqs changed&quot;
                ),
                &quot;__state_ran__&quot;: False,
                &quot;__run_num__&quot;: self.__run_num,
                &quot;__sls__&quot;: low[&quot;__sls__&quot;],
            }
            self.__run_num += 1
        else:
            if low.get(&quot;__prereq__&quot;):
                self.pre[tag] = self.call(low, chunks, running)
            else:
                running[tag] = self.call(low, chunks, running)
        if tag in running:
            self.event(running[tag], len(chunks), fire_event=low.get(&quot;fire_event&quot;))

            for sub_state_data in running[tag].pop(&quot;sub_state_run&quot;, ()):
                start_time, duration = _calculate_fake_duration()
                self.__run_num += 1
                sub_tag = _gen_tag(sub_state_data[&quot;low&quot;])
                running[sub_tag] = {
                    &quot;name&quot;: sub_state_data[&quot;low&quot;][&quot;name&quot;],
                    &quot;changes&quot;: sub_state_data[&quot;changes&quot;],
                    &quot;result&quot;: sub_state_data[&quot;result&quot;],
                    &quot;duration&quot;: sub_state_data.get(&quot;duration&quot;, duration),
                    &quot;start_time&quot;: sub_state_data.get(&quot;start_time&quot;, start_time),
                    &quot;comment&quot;: sub_state_data.get(&quot;comment&quot;, &quot;&quot;),
                    &quot;__state_ran__&quot;: True,
                    &quot;__run_num__&quot;: self.__run_num,
                    &quot;__sls__&quot;: low[&quot;__sls__&quot;],
                }

        return running

    def call_beacons(self, chunks, running):
        &quot;&quot;&quot;
        Find all of the beacon routines and call the associated mod_beacon runs
        &quot;&quot;&quot;
        listeners = []
        crefs = {}
        beacons = []
        for chunk in chunks:
            if &quot;beacon&quot; in chunk:
                beacons.append(chunk)
        mod_beacons = []
        errors = {}
        for chunk in beacons:
            low = chunk.copy()
            low[&quot;sfun&quot;] = chunk[&quot;fun&quot;]
            low[&quot;fun&quot;] = &quot;mod_beacon&quot;
            low[&quot;__id__&quot;] = &quot;beacon_{}&quot;.format(low[&quot;__id__&quot;])
            mod_beacons.append(low)
        ret = self.call_chunks(mod_beacons)

        running.update(ret)
        for err in errors:
            errors[err][&quot;__run_num__&quot;] = self.__run_num
            self.__run_num += 1
        running.update(errors)
        return running

    def call_listen(self, chunks, running):
        &quot;&quot;&quot;
        Find all of the listen routines and call the associated mod_watch runs
        &quot;&quot;&quot;
        listeners = []
        crefs = {}
        for chunk in chunks:
            crefs[(chunk[&quot;state&quot;], chunk[&quot;__id__&quot;], chunk[&quot;name&quot;])] = chunk
            if &quot;listen&quot; in chunk:
                listeners.append(
                    {(chunk[&quot;state&quot;], chunk[&quot;__id__&quot;], chunk[&quot;name&quot;]): chunk[&quot;listen&quot;]}
                )
            if &quot;listen_in&quot; in chunk:
                for l_in in chunk[&quot;listen_in&quot;]:
                    for key, val in l_in.items():
                        listeners.append(
                            {(key, val, &quot;lookup&quot;): [{chunk[&quot;state&quot;]: chunk[&quot;__id__&quot;]}]}
                        )

        mod_watchers = []
        errors = {}
        for l_dict in listeners:
            for key, val in l_dict.items():
                for listen_to in val:
                    if not isinstance(listen_to, dict):
                        found = False
                        for chunk in chunks:
                            if (
                                chunk[&quot;__id__&quot;] == listen_to
                                or chunk[&quot;name&quot;] == listen_to
                            ):
                                listen_to = {chunk[&quot;state&quot;]: chunk[&quot;__id__&quot;]}
                                found = True
                        if not found:
                            continue
                    for lkey, lval in listen_to.items():
                        if not any(lkey == cref[0] and lval in cref for cref in crefs):
                            rerror = {
                                _l_tag(lkey, lval): {
                                    &quot;comment&quot;: (
                                        &quot;Referenced state {}: {} does not exist&quot;.format(
                                            lkey, lval
                                        )
                                    ),
                                    &quot;name&quot;: &quot;listen_{}:{}&quot;.format(lkey, lval),
                                    &quot;result&quot;: False,
                                    &quot;changes&quot;: {},
                                }
                            }
                            errors.update(rerror)
                            continue
                        to_tags = [
                            _gen_tag(data)
                            for cref, data in crefs.items()
                            if lkey == cref[0] and lval in cref
                        ]
                        for to_tag in to_tags:
                            if to_tag not in running:
                                continue
                            if running[to_tag][&quot;changes&quot;]:
                                if not any(
                                    key[0] == cref[0] and key[1] in cref
                                    for cref in crefs
                                ):
                                    rerror = {
                                        _l_tag(key[0], key[1]): {
                                            &quot;comment&quot;: (
                                                &quot;Referenced state {}: {} does not exist&quot;.format(
                                                    key[0], key[1]
                                                )
                                            ),
                                            &quot;name&quot;: &quot;listen_{}:{}&quot;.format(
                                                key[0], key[1]
                                            ),
                                            &quot;result&quot;: False,
                                            &quot;changes&quot;: {},
                                        }
                                    }
                                    errors.update(rerror)
                                    continue

                                new_chunks = [
                                    data
                                    for cref, data in crefs.items()
                                    if key[0] == cref[0] and key[1] in cref
                                ]
                                for chunk in new_chunks:
                                    low = chunk.copy()
                                    low[&quot;sfun&quot;] = chunk[&quot;fun&quot;]
                                    low[&quot;fun&quot;] = &quot;mod_watch&quot;
                                    low[&quot;__id__&quot;] = &quot;listener_{}&quot;.format(low[&quot;__id__&quot;])
                                    for req in STATE_REQUISITE_KEYWORDS:
                                        if req in low:
                                            low.pop(req)
                                    mod_watchers.append(low)
        ret = self.call_chunks(mod_watchers)
        running.update(ret)
        for err in errors:
            errors[err][&quot;__run_num__&quot;] = self.__run_num
            self.__run_num += 1
        running.update(errors)
        return running

    def call_high(self, high, orchestration_jid=None):
        &quot;&quot;&quot;
        Process a high data call and ensure the defined states.
        &quot;&quot;&quot;
        errors = []
        # If there is extension data reconcile it
        high, ext_errors = self.reconcile_extend(high)
        errors.extend(ext_errors)
        errors.extend(self.verify_high(high))
        if errors:
            return errors
        high, req_in_errors = self.requisite_in(high)
        errors.extend(req_in_errors)
        high = self.apply_exclude(high)
        # Verify that the high data is structurally sound
        if errors:
            return errors
        # Compile and verify the raw chunks
        chunks = self.compile_high_data(high, orchestration_jid)

        # If there are extensions in the highstate, process them and update
        # the low data chunks
        if errors:
            return errors
        ret = self.call_chunks(chunks)
        ret = self.call_listen(chunks, ret)
        ret = self.call_beacons(chunks, ret)

        def _cleanup_accumulator_data():
            accum_data_path = os.path.join(
                get_accumulator_dir(self.opts[&quot;cachedir&quot;]), self.instance_id
            )
            try:
                os.remove(accum_data_path)
                log.debug(&quot;Deleted accumulator data file %s&quot;, accum_data_path)
            except OSError:
                log.debug(&quot;File %s does not exist, no need to cleanup&quot;, accum_data_path)

        _cleanup_accumulator_data()
        if self.jid is not None:
            pause_path = os.path.join(self.opts[&quot;cachedir&quot;], &quot;state_pause&quot;, self.jid)
            if os.path.isfile(pause_path):
                try:
                    os.remove(pause_path)
                except OSError:
                    # File is not present, all is well
                    pass

        return ret

    def render_template(self, high, template):
        errors = []
        if not high:
            return high, errors

        if not isinstance(high, dict):
            errors.append(
                &quot;Template {} does not render to a dictionary&quot;.format(template)
            )
            return high, errors

        invalid_items = (&quot;include&quot;, &quot;exclude&quot;, &quot;extends&quot;)
        for item in invalid_items:
            if item in high:
                errors.append(
                    &quot;The '{}' declaration found on '{}' is invalid when &quot;
                    &quot;rendering single templates&quot;.format(item, template)
                )
                return high, errors

        for name in high:
            if not isinstance(high[name], dict):
                if isinstance(high[name], str):
                    # Is this is a short state, it needs to be padded
                    if &quot;.&quot; in high[name]:
                        comps = high[name].split(&quot;.&quot;)
                        high[name] = {
                            # '__sls__': template,
                            # '__env__': None,
                            comps[0]: [comps[1]]
                        }
                        continue

                    errors.append(
                        &quot;ID {} in template {} is not a dictionary&quot;.format(
                            name, template
                        )
                    )
                    continue
            skeys = set()
            for key in sorted(high[name]):
                if key.startswith(&quot;_&quot;):
                    continue
                if high[name][key] is None:
                    errors.append(
                        &quot;ID '{}' in template {} contains a short &quot;
                        &quot;declaration ({}) with a trailing colon. When not &quot;
                        &quot;passing any arguments to a state, the colon must be &quot;
                        &quot;omitted.&quot;.format(name, template, key)
                    )
                    continue
                if not isinstance(high[name][key], list):
                    continue
                if &quot;.&quot; in key:
                    comps = key.split(&quot;.&quot;)
                    # Salt doesn't support state files such as:
                    #
                    # /etc/redis/redis.conf:
                    #   file.managed:
                    #     - user: redis
                    #     - group: redis
                    #     - mode: 644
                    #   file.comment:
                    #     - regex: ^requirepass
                    if comps[0] in skeys:
                        errors.append(
                            &quot;ID '{}' in template '{}' contains multiple &quot;
                            &quot;state declarations of the same type&quot;.format(name, template)
                        )
                        continue
                    high[name][comps[0]] = high[name].pop(key)
                    high[name][comps[0]].append(comps[1])
                    skeys.add(comps[0])
                    continue
                skeys.add(key)

        return high, errors

    def call_template(self, template):
        &quot;&quot;&quot;
        Enforce the states in a template
        &quot;&quot;&quot;
        high = compile_template(
            template,
            self.rend,
            self.opts[&quot;renderer&quot;],
            self.opts[&quot;renderer_blacklist&quot;],
            self.opts[&quot;renderer_whitelist&quot;],
        )
        if not high:
            return high
        high, errors = self.render_template(high, template)
        if errors:
            return errors
        return self.call_high(high)

    def call_template_str(self, template):
        &quot;&quot;&quot;
        Enforce the states in a template, pass the template as a string
        &quot;&quot;&quot;
        high = compile_template_str(
            template,
            self.rend,
            self.opts[&quot;renderer&quot;],
            self.opts[&quot;renderer_blacklist&quot;],
            self.opts[&quot;renderer_whitelist&quot;],
        )
        if not high:
            return high
        high, errors = self.render_template(high, &quot;&lt;template-str&gt;&quot;)
        if errors:
            return errors
        return self.call_high(high)


class LazyAvailStates:
    &quot;&quot;&quot;
    The LazyAvailStates lazily loads the list of states of available
    environments.

    This is particularly usefull when top_file_merging_strategy=same and there
    are many environments.
    &quot;&quot;&quot;

    def __init__(self, hs):
        self._hs = hs
        self._avail = {&quot;base&quot;: None}
        self._filled = False

    def _fill(self):
        if self._filled:
            return
        for saltenv in self._hs._get_envs():
            if saltenv not in self._avail:
                self._avail[saltenv] = None
        self._filled = True

    def __contains__(self, saltenv):
        if saltenv == &quot;base&quot;:
            return True
        self._fill()
        return saltenv in self._avail

    def __getitem__(self, saltenv):
        if saltenv != &quot;base&quot;:
            self._fill()
        if saltenv not in self._avail or self._avail[saltenv] is None:
            self._avail[saltenv] = self._hs.client.list_states(saltenv)
        return self._avail[saltenv]

    def items(self):
        self._fill()
        ret = []
        for saltenv, states in self._avail.items():
            ret.append((saltenv, self.__getitem__(saltenv)))
        return ret


class BaseHighState:
    &quot;&quot;&quot;
    The BaseHighState is an abstract base class that is the foundation of
    running a highstate, extend it and add a self.state object of type State.

    When extending this class, please note that ``self.client`` and
    ``self.matcher`` should be instantiated and handled.
    &quot;&quot;&quot;

    def __init__(self, opts):
        self.opts = self.__gen_opts(opts)
        self.iorder = 10000
        self.avail = self.__gather_avail()
        self.building_highstate = OrderedDict()

    def __gather_avail(self):
        &quot;&quot;&quot;
        Lazily gather the lists of available sls data from the master
        &quot;&quot;&quot;
        return LazyAvailStates(self)

    def __gen_opts(self, opts):
        &quot;&quot;&quot;
        The options used by the High State object are derived from options
        on the minion and the master, or just the minion if the high state
        call is entirely local.
        &quot;&quot;&quot;
        # If the state is intended to be applied locally, then the local opts
        # should have all of the needed data, otherwise overwrite the local
        # data items with data from the master
        if &quot;local_state&quot; in opts:
            if opts[&quot;local_state&quot;]:
                return opts
        mopts = self.client.master_opts()
        if not isinstance(mopts, dict):
            # An error happened on the master
            opts[&quot;renderer&quot;] = &quot;jinja|yaml&quot;
            opts[&quot;failhard&quot;] = False
            opts[&quot;state_top&quot;] = salt.utils.url.create(&quot;top.sls&quot;)
            opts[&quot;nodegroups&quot;] = {}
            opts[&quot;file_roots&quot;] = {&quot;base&quot;: [syspaths.BASE_FILE_ROOTS_DIR]}
        else:
            opts[&quot;renderer&quot;] = mopts[&quot;renderer&quot;]
            opts[&quot;failhard&quot;] = mopts.get(&quot;failhard&quot;, False)
            if mopts[&quot;state_top&quot;].startswith(&quot;salt://&quot;):
                opts[&quot;state_top&quot;] = mopts[&quot;state_top&quot;]
            elif mopts[&quot;state_top&quot;].startswith(&quot;/&quot;):
                opts[&quot;state_top&quot;] = salt.utils.url.create(mopts[&quot;state_top&quot;][1:])
            else:
                opts[&quot;state_top&quot;] = salt.utils.url.create(mopts[&quot;state_top&quot;])
            opts[&quot;state_top_saltenv&quot;] = mopts.get(&quot;state_top_saltenv&quot;, None)
            opts[&quot;nodegroups&quot;] = mopts.get(&quot;nodegroups&quot;, {})
            opts[&quot;state_auto_order&quot;] = mopts.get(
                &quot;state_auto_order&quot;, opts[&quot;state_auto_order&quot;]
            )
            opts[&quot;file_roots&quot;] = mopts[&quot;file_roots&quot;]
            opts[&quot;top_file_merging_strategy&quot;] = mopts.get(
                &quot;top_file_merging_strategy&quot;, opts.get(&quot;top_file_merging_strategy&quot;)
            )
            opts[&quot;env_order&quot;] = mopts.get(&quot;env_order&quot;, opts.get(&quot;env_order&quot;, []))
            opts[&quot;default_top&quot;] = mopts.get(&quot;default_top&quot;, opts.get(&quot;default_top&quot;))
            opts[&quot;state_events&quot;] = mopts.get(&quot;state_events&quot;)
            opts[&quot;state_aggregate&quot;] = (
                opts.get(&quot;state_aggregate&quot;) or mopts.get(&quot;state_aggregate&quot;) or False
            )
            opts[&quot;jinja_env&quot;] = mopts.get(&quot;jinja_env&quot;, {})
            opts[&quot;jinja_sls_env&quot;] = mopts.get(&quot;jinja_sls_env&quot;, {})
            opts[&quot;jinja_lstrip_blocks&quot;] = mopts.get(&quot;jinja_lstrip_blocks&quot;, False)
            opts[&quot;jinja_trim_blocks&quot;] = mopts.get(&quot;jinja_trim_blocks&quot;, False)
        return opts

    def _get_envs(self):
        &quot;&quot;&quot;
        Pull the file server environments out of the master options
        &quot;&quot;&quot;
        envs = [&quot;base&quot;]
        if &quot;file_roots&quot; in self.opts:
            envs.extend([x for x in list(self.opts[&quot;file_roots&quot;]) if x not in envs])
        env_order = self.opts.get(&quot;env_order&quot;, [])
        # Remove duplicates while preserving the order
        members = set()
        env_order = [
            env for env in env_order if not (env in members or members.add(env))
        ]
        client_envs = self.client.envs()
        if env_order and client_envs:
            return [env for env in env_order if env in client_envs]

        elif env_order:
            return env_order
        else:
            envs.extend([env for env in client_envs if env not in envs])
            return envs

    def get_tops(self):
        &quot;&quot;&quot;
        Gather the top files
        &quot;&quot;&quot;
        tops = DefaultOrderedDict(list)
        include = DefaultOrderedDict(list)
        done = DefaultOrderedDict(list)
        found = 0  # did we find any contents in the top files?
        # Gather initial top files
        merging_strategy = self.opts[&quot;top_file_merging_strategy&quot;]
        if merging_strategy == &quot;same&quot; and not self.opts[&quot;saltenv&quot;]:
            if not self.opts[&quot;default_top&quot;]:
                raise SaltRenderError(
                    &quot;top_file_merging_strategy set to 'same', but no &quot;
                    &quot;default_top configuration option was set&quot;
                )

        if self.opts[&quot;saltenv&quot;]:
            contents = self.client.cache_file(
                self.opts[&quot;state_top&quot;], self.opts[&quot;saltenv&quot;]
            )
            if contents:
                found = 1
                tops[self.opts[&quot;saltenv&quot;]] = [
                    compile_template(
                        contents,
                        self.state.rend,
                        self.state.opts[&quot;renderer&quot;],
                        self.state.opts[&quot;renderer_blacklist&quot;],
                        self.state.opts[&quot;renderer_whitelist&quot;],
                        saltenv=self.opts[&quot;saltenv&quot;],
                    )
                ]
            else:
                tops[self.opts[&quot;saltenv&quot;]] = [{}]

        else:
            found = 0
            state_top_saltenv = self.opts.get(&quot;state_top_saltenv&quot;, False)
            if state_top_saltenv and not isinstance(state_top_saltenv, str):
                state_top_saltenv = str(state_top_saltenv)

            for saltenv in (
                [state_top_saltenv] if state_top_saltenv else self._get_envs()
            ):
                contents = self.client.cache_file(self.opts[&quot;state_top&quot;], saltenv)
                if contents:
                    found = found + 1
                    tops[saltenv].append(
                        compile_template(
                            contents,
                            self.state.rend,
                            self.state.opts[&quot;renderer&quot;],
                            self.state.opts[&quot;renderer_blacklist&quot;],
                            self.state.opts[&quot;renderer_whitelist&quot;],
                            saltenv=saltenv,
                        )
                    )
                else:
                    tops[saltenv].append({})
                    log.debug(&quot;No contents loaded for saltenv '%s'&quot;, saltenv)

            if (
                found &gt; 1
                and merging_strategy == &quot;merge&quot;
                and not self.opts.get(&quot;env_order&quot;, None)
            ):
                log.warning(
                    &quot;top_file_merging_strategy is set to '%s' and &quot;
                    &quot;multiple top files were found. Merging order is not &quot;
                    &quot;deterministic, it may be desirable to either set &quot;
                    &quot;top_file_merging_strategy to 'same' or use the &quot;
                    &quot;'env_order' configuration parameter to specify the &quot;
                    &quot;merging order.&quot;,
                    merging_strategy,
                )

        if found == 0:
            log.debug(
                &quot;No contents found in top file. If this is not expected, &quot;
                &quot;verify that the 'file_roots' specified in 'etc/master' &quot;
                &quot;are accessible. The 'file_roots' configuration is: %s&quot;,
                repr(self.state.opts[&quot;file_roots&quot;]),
            )

        # Search initial top files for includes
        for saltenv, ctops in tops.items():
            for ctop in ctops:
                if &quot;include&quot; not in ctop:
                    continue
                for sls in ctop[&quot;include&quot;]:
                    include[saltenv].append(sls)
                ctop.pop(&quot;include&quot;)
        # Go through the includes and pull out the extra tops and add them
        while include:
            pops = []
            for saltenv, states in include.items():
                pops.append(saltenv)
                if not states:
                    continue
                for sls_match in states:
                    for sls in fnmatch.filter(self.avail[saltenv], sls_match):
                        if sls in done[saltenv]:
                            continue
                        tops[saltenv].append(
                            compile_template(
                                self.client.get_state(sls, saltenv).get(&quot;dest&quot;, False),
                                self.state.rend,
                                self.state.opts[&quot;renderer&quot;],
                                self.state.opts[&quot;renderer_blacklist&quot;],
                                self.state.opts[&quot;renderer_whitelist&quot;],
                                saltenv,
                            )
                        )
                        done[saltenv].append(sls)
            for saltenv in pops:
                if saltenv in include:
                    include.pop(saltenv)
        return tops

    def merge_tops(self, tops):
        &quot;&quot;&quot;
        Cleanly merge the top files
        &quot;&quot;&quot;
        merging_strategy = self.opts[&quot;top_file_merging_strategy&quot;]
        try:
            merge_attr = &quot;_merge_tops_{}&quot;.format(merging_strategy)
            merge_func = getattr(self, merge_attr)
            if not hasattr(merge_func, &quot;__call__&quot;):
                msg = &quot;'{}' is not callable&quot;.format(merge_attr)
                log.error(msg)
                raise TypeError(msg)
        except (AttributeError, TypeError):
            log.warning(
                &quot;Invalid top_file_merging_strategy '%s', falling back to 'merge'&quot;,
                merging_strategy,
            )
            merge_func = self._merge_tops_merge
        return merge_func(tops)

    def _merge_tops_merge(self, tops):
        &quot;&quot;&quot;
        The default merging strategy. The base env is authoritative, so it is
        checked first, followed by the remaining environments. In top files
        from environments other than &quot;base&quot;, only the section matching the
        environment from the top file will be considered, and it too will be
        ignored if that environment was defined in the &quot;base&quot; top file.
        &quot;&quot;&quot;
        top = DefaultOrderedDict(OrderedDict)

        # Check base env first as it is authoritative
        base_tops = tops.pop(&quot;base&quot;, DefaultOrderedDict(OrderedDict))
        for ctop in base_tops:
            for saltenv, targets in ctop.items():
                if saltenv == &quot;include&quot;:
                    continue
                try:
                    for tgt in targets:
                        top[saltenv][tgt] = ctop[saltenv][tgt]
                except TypeError:
                    raise SaltRenderError(
                        &quot;Unable to render top file. No targets found.&quot;
                    )

        for cenv, ctops in tops.items():
            for ctop in ctops:
                for saltenv, targets in ctop.items():
                    if saltenv == &quot;include&quot;:
                        continue
                    elif saltenv != cenv:
                        log.debug(
                            &quot;Section for saltenv '%s' in the '%s' &quot;
                            &quot;saltenv's top file will be ignored, as the &quot;
                            &quot;top_file_merging_strategy is set to 'merge' &quot;
                            &quot;and the saltenvs do not match&quot;,
                            saltenv,
                            cenv,
                        )
                        continue
                    elif saltenv in top:
                        log.debug(
                            &quot;Section for saltenv '%s' in the '%s' &quot;
                            &quot;saltenv's top file will be ignored, as this &quot;
                            &quot;saltenv was already defined in the 'base' top &quot;
                            &quot;file&quot;,
                            saltenv,
                            cenv,
                        )
                        continue
                    try:
                        for tgt in targets:
                            top[saltenv][tgt] = ctop[saltenv][tgt]
                    except TypeError:
                        raise SaltRenderError(
                            &quot;Unable to render top file. No targets found.&quot;
                        )
        return top

    def _merge_tops_same(self, tops):
        &quot;&quot;&quot;
        For each saltenv, only consider the top file from that saltenv. All
        sections matching a given saltenv, which appear in a different
        saltenv's top file, will be ignored.
        &quot;&quot;&quot;
        top = DefaultOrderedDict(OrderedDict)
        for cenv, ctops in tops.items():
            if all([x == {} for x in ctops]):
                # No top file found in this env, check the default_top
                default_top = self.opts[&quot;default_top&quot;]
                fallback_tops = tops.get(default_top, [])
                if all([x == {} for x in fallback_tops]):
                    # Nothing in the fallback top file
                    log.error(
                        &quot;The '%s' saltenv has no top file, and the fallback &quot;
                        &quot;saltenv specified by default_top (%s) also has no &quot;
                        &quot;top file&quot;,
                        cenv,
                        default_top,
                    )
                    continue

                for ctop in fallback_tops:
                    for saltenv, targets in ctop.items():
                        if saltenv != cenv:
                            continue
                        log.debug(
                            &quot;The '%s' saltenv has no top file, using the &quot;
                            &quot;default_top saltenv (%s)&quot;,
                            cenv,
                            default_top,
                        )
                        for tgt in targets:
                            top[saltenv][tgt] = ctop[saltenv][tgt]
                        break
                    else:
                        log.error(
                            &quot;The '%s' saltenv has no top file, and no &quot;
                            &quot;matches were found in the top file for the &quot;
                            &quot;default_top saltenv (%s)&quot;,
                            cenv,
                            default_top,
                        )

                continue

            else:
                for ctop in ctops:
                    for saltenv, targets in ctop.items():
                        if saltenv == &quot;include&quot;:
                            continue
                        elif saltenv != cenv:
                            log.debug(
                                &quot;Section for saltenv '%s' in the '%s' &quot;
                                &quot;saltenv's top file will be ignored, as the &quot;
                                &quot;top_file_merging_strategy is set to 'same' &quot;
                                &quot;and the saltenvs do not match&quot;,
                                saltenv,
                                cenv,
                            )
                            continue

                        try:
                            for tgt in targets:
                                top[saltenv][tgt] = ctop[saltenv][tgt]
                        except TypeError:
                            raise SaltRenderError(
                                &quot;Unable to render top file. No targets found.&quot;
                            )
        return top

    def _merge_tops_merge_all(self, tops):
        &quot;&quot;&quot;
        Merge the top files into a single dictionary
        &quot;&quot;&quot;

        def _read_tgt(tgt):
            match_type = None
            states = []
            for item in tgt:
                if isinstance(item, dict):
                    match_type = item
                if isinstance(item, str):
                    states.append(item)
            return match_type, states

        top = DefaultOrderedDict(OrderedDict)
        for ctops in tops.values():
            for ctop in ctops:
                for saltenv, targets in ctop.items():
                    if saltenv == &quot;include&quot;:
                        continue
                    try:
                        for tgt in targets:
                            if tgt not in top[saltenv]:
                                top[saltenv][tgt] = ctop[saltenv][tgt]
                                continue
                            m_type1, m_states1 = _read_tgt(top[saltenv][tgt])
                            m_type2, m_states2 = _read_tgt(ctop[saltenv][tgt])
                            merged = []
                            match_type = m_type2 or m_type1
                            if match_type is not None:
                                merged.append(match_type)
                            merged.extend(m_states1)
                            merged.extend([x for x in m_states2 if x not in merged])
                            top[saltenv][tgt] = merged
                    except TypeError:
                        raise SaltRenderError(
                            &quot;Unable to render top file. No targets found.&quot;
                        )
        return top

    def verify_tops(self, tops):
        &quot;&quot;&quot;
        Verify the contents of the top file data
        &quot;&quot;&quot;
        errors = []
        if not isinstance(tops, dict):
            errors.append(&quot;Top data was not formed as a dict&quot;)
            # No further checks will work, bail out
            return errors
        for saltenv, matches in tops.items():
            if saltenv == &quot;include&quot;:
                continue
            if not isinstance(saltenv, str):
                errors.append(
                    &quot;Environment {} in top file is not formed as a string&quot;.format(
                        saltenv
                    )
                )
            if saltenv == &quot;&quot;:
                errors.append(&quot;Empty saltenv statement in top file&quot;)
            if not isinstance(matches, dict):
                errors.append(
                    &quot;The top file matches for saltenv {} are not &quot;
                    &quot;formatted as a dict&quot;.format(saltenv)
                )
            for slsmods in matches.values():
                if not isinstance(slsmods, list):
                    errors.append(
                        &quot;Malformed topfile (state declarations not formed as a list)&quot;
                    )
                    continue
                for slsmod in slsmods:
                    if isinstance(slsmod, dict):
                        # This value is a match option
                        for val in slsmod.values():
                            if not val:
                                errors.append(
                                    &quot;Improperly formatted top file matcher &quot;
                                    &quot;in saltenv {}: {} file&quot;.format(slsmod, val)
                                )
                    elif isinstance(slsmod, str):
                        # This is a sls module
                        if not slsmod:
                            errors.append(
                                &quot;Environment {} contains an empty sls index&quot;.format(
                                    saltenv
                                )
                            )

        return errors

    def get_top(self):
        &quot;&quot;&quot;
        Returns the high data derived from the top file
        &quot;&quot;&quot;
        try:
            tops = self.get_tops()
        except SaltRenderError as err:
            log.error(&quot;Unable to render top file: %s&quot;, err.error)
            return {}
        return self.merge_tops(tops)

    def top_matches(self, top):
        &quot;&quot;&quot;
        Search through the top high data for matches and return the states
        that this minion needs to execute.

        Returns:
        {'saltenv': ['state1', 'state2', ...]}
        &quot;&quot;&quot;
        matches = DefaultOrderedDict(OrderedDict)
        # pylint: disable=cell-var-from-loop
        for saltenv, body in top.items():
            if self.opts[&quot;saltenv&quot;]:
                if saltenv != self.opts[&quot;saltenv&quot;]:
                    continue
            for match, data in body.items():

                def _filter_matches(_match, _data, _opts):
                    if isinstance(_data, str):
                        _data = [_data]
                    if self.matchers[&quot;confirm_top.confirm_top&quot;](_match, _data, _opts):
                        if saltenv not in matches:
                            matches[saltenv] = []
                        for item in _data:
                            if &quot;subfilter&quot; in item:
                                _tmpdata = item.pop(&quot;subfilter&quot;)
                                for match, data in _tmpdata.items():
                                    _filter_matches(match, data, _opts)
                            if isinstance(item, str):
                                matches[saltenv].append(item)
                            elif isinstance(item, dict):
                                env_key, inc_sls = item.popitem()
                                if env_key not in self.avail:
                                    continue
                                if env_key not in matches:
                                    matches[env_key] = []
                                matches[env_key].append(inc_sls)

                _filter_matches(match, data, self.opts[&quot;nodegroups&quot;])
        ext_matches = self._master_tops()
        for saltenv in ext_matches:
            top_file_matches = matches.get(saltenv, [])
            if self.opts.get(&quot;master_tops_first&quot;):
                first = ext_matches[saltenv]
                second = top_file_matches
            else:
                first = top_file_matches
                second = ext_matches[saltenv]
            matches[saltenv] = first + [x for x in second if x not in first]

        # pylint: enable=cell-var-from-loop
        return matches

    def _master_tops(self):
        &quot;&quot;&quot;
        Get results from the master_tops system. Override this function if the
        execution of the master_tops needs customization.
        &quot;&quot;&quot;
        return self.client.master_tops()

    def load_dynamic(self, matches):
        &quot;&quot;&quot;
        If autoload_dynamic_modules is True then automatically load the
        dynamic modules
        &quot;&quot;&quot;
        if not self.opts[&quot;autoload_dynamic_modules&quot;]:
            return
        syncd = self.state.functions[&quot;saltutil.sync_all&quot;](list(matches), refresh=False)
        if syncd[&quot;grains&quot;]:
            self.opts[&quot;grains&quot;] = salt.loader.grains(self.opts)
            self.state.opts[&quot;pillar&quot;] = self.state._gather_pillar()
        self.state.module_refresh()

    def render_state(self, sls, saltenv, mods, matches, local=False, context=None):
        &quot;&quot;&quot;
        Render a state file and retrieve all of the include states
        &quot;&quot;&quot;
        errors = []
        if not local:
            state_data = self.client.get_state(sls, saltenv)
            fn_ = state_data.get(&quot;dest&quot;, False)
        else:
            fn_ = sls
            if not os.path.isfile(fn_):
                errors.append(
                    &quot;Specified SLS {} on local filesystem cannot be found.&quot;.format(sls)
                )
        state = None
        if not fn_:
            errors.append(
                &quot;Specified SLS {} in saltenv {} is not &quot;
                &quot;available on the salt master or through a configured &quot;
                &quot;fileserver&quot;.format(sls, saltenv)
            )
        else:
            try:
                state = compile_template(
                    fn_,
                    self.state.rend,
                    self.state.opts[&quot;renderer&quot;],
                    self.state.opts[&quot;renderer_blacklist&quot;],
                    self.state.opts[&quot;renderer_whitelist&quot;],
                    saltenv,
                    sls,
                    rendered_sls=mods,
                    context=context,
                )
            except SaltRenderError as exc:
                msg = &quot;Rendering SLS '{}:{}' failed: {}&quot;.format(saltenv, sls, exc)
                log.critical(msg)
                errors.append(msg)
            except Exception as exc:  # pylint: disable=broad-except
                msg = &quot;Rendering SLS {} failed, render error: {}&quot;.format(sls, exc)
                log.critical(
                    msg,
                    # Show the traceback if the debug logging level is enabled
                    exc_info_on_loglevel=logging.DEBUG,
                )
                errors.append(&quot;{}\n{}&quot;.format(msg, traceback.format_exc()))
            try:
                mods.add(&quot;{}:{}&quot;.format(saltenv, sls))
            except AttributeError:
                pass

        if state:
            if not isinstance(state, dict):
                errors.append(&quot;SLS {} does not render to a dictionary&quot;.format(sls))
            else:
                include = []
                if &quot;include&quot; in state:
                    if not isinstance(state[&quot;include&quot;], list):
                        err = (
                            &quot;Include Declaration in SLS {} is not formed &quot;
                            &quot;as a list&quot;.format(sls)
                        )
                        errors.append(err)
                    else:
                        include = state.pop(&quot;include&quot;)

                self._handle_extend(state, sls, saltenv, errors)
                self._handle_exclude(state, sls, saltenv, errors)
                self._handle_state_decls(state, sls, saltenv, errors)

                for inc_sls in include:
                    # inc_sls may take the form of:
                    #   'sls.to.include' &lt;- same as {&lt;saltenv&gt;: 'sls.to.include'}
                    #   {&lt;env_key&gt;: 'sls.to.include'}
                    #   {'_xenv': 'sls.to.resolve'}
                    xenv_key = &quot;_xenv&quot;

                    if isinstance(inc_sls, dict):
                        env_key, inc_sls = inc_sls.popitem()
                    else:
                        env_key = saltenv

                    if env_key not in self.avail and &quot;__env__&quot; not in self.avail:
                        msg = (
                            &quot;Nonexistent saltenv '{}' found in include &quot;
                            &quot;of '{}' within SLS '{}:{}'&quot;.format(
                                env_key, inc_sls, saltenv, sls
                            )
                        )
                        log.error(msg)
                        errors.append(msg)
                        continue

                    if inc_sls.startswith(&quot;.&quot;):
                        match = re.match(r&quot;^(\.+)(.*)$&quot;, inc_sls)
                        if match:
                            levels, include = match.groups()
                        else:
                            msg = (
                                &quot;Badly formatted include {} found in include &quot;
                                &quot;in SLS '{}:{}'&quot;.format(inc_sls, saltenv, sls)
                            )
                            log.error(msg)
                            errors.append(msg)
                            continue
                        level_count = len(levels)
                        p_comps = sls.split(&quot;.&quot;)
                        if state_data.get(&quot;source&quot;, &quot;&quot;).endswith(&quot;/init.sls&quot;):
                            p_comps.append(&quot;init&quot;)
                        if level_count &gt; len(p_comps):
                            msg = (
                                &quot;Attempted relative include of '{}' &quot;
                                &quot;within SLS '{}:{}' &quot;
                                &quot;goes beyond top level package &quot;.format(
                                    inc_sls, saltenv, sls
                                )
                            )
                            log.error(msg)
                            errors.append(msg)
                            continue
                        inc_sls = &quot;.&quot;.join(p_comps[:-level_count] + [include])

                    if env_key != xenv_key:
                        if matches is None:
                            matches = []
                        # Resolve inc_sls in the specified environment
                        if env_key in matches or fnmatch.filter(
                            self.avail[env_key], inc_sls
                        ):
                            resolved_envs = [env_key]
                        else:
                            resolved_envs = []
                    else:
                        # Resolve inc_sls in the subset of environment matches
                        resolved_envs = [
                            aenv
                            for aenv in matches
                            if fnmatch.filter(self.avail[aenv], inc_sls)
                        ]

                    # An include must be resolved to a single environment, or
                    # the include must exist in the current environment
                    if len(resolved_envs) == 1 or saltenv in resolved_envs:
                        # Match inc_sls against the available states in the
                        # resolved env, matching wildcards in the process. If
                        # there were no matches, then leave inc_sls as the
                        # target so that the next recursion of render_state
                        # will recognize the error.
                        sls_targets = fnmatch.filter(self.avail[saltenv], inc_sls) or [
                            inc_sls
                        ]

                        for sls_target in sls_targets:
                            r_env = (
                                resolved_envs[0] if len(resolved_envs) == 1 else saltenv
                            )
                            mod_tgt = &quot;{}:{}&quot;.format(r_env, sls_target)
                            if mod_tgt not in mods:
                                nstate, err = self.render_state(
                                    sls_target, r_env, mods, matches
                                )
                                if nstate:
                                    self.merge_included_states(state, nstate, errors)
                                    state.update(nstate)
                                if err:
                                    errors.extend(err)
                    else:
                        msg = &quot;&quot;
                        if not resolved_envs:
                            msg = (
                                &quot;Unknown include: Specified SLS {}: {} is not available&quot;
                                &quot; on the salt master in saltenv(s): {} &quot;.format(
                                    env_key,
                                    inc_sls,
                                    &quot;, &quot;.join(matches)
                                    if env_key == xenv_key
                                    else env_key,
                                )
                            )
                        elif len(resolved_envs) &gt; 1:
                            msg = (
                                &quot;Ambiguous include: Specified SLS {}: {} is available&quot;
                                &quot; on the salt master in multiple available saltenvs: {}&quot;.format(
                                    env_key, inc_sls, &quot;, &quot;.join(resolved_envs)
                                )
                            )
                        log.critical(msg)
                        errors.append(msg)
                try:
                    self._handle_iorder(state)
                except TypeError:
                    log.critical(&quot;Could not render SLS %s. Syntax error detected.&quot;, sls)
        else:
            state = {}
        return state, errors

    def _handle_iorder(self, state):
        &quot;&quot;&quot;
        Take a state and apply the iorder system
        &quot;&quot;&quot;
        if self.opts[&quot;state_auto_order&quot;]:
            for name in state:
                for s_dec in state[name]:
                    if not isinstance(s_dec, str):
                        # PyDSL OrderedDict?
                        continue

                    if not isinstance(state[name], dict):
                        # Include's or excludes as lists?
                        continue
                    if not isinstance(state[name][s_dec], list):
                        # Bad syntax, let the verify seq pick it up later on
                        continue

                    found = False
                    if s_dec.startswith(&quot;_&quot;):
                        continue

                    for arg in state[name][s_dec]:
                        if isinstance(arg, dict):
                            if len(arg) &gt; 0:
                                if next(iter(arg.keys())) == &quot;order&quot;:
                                    found = True
                    if not found:
                        if not isinstance(state[name][s_dec], list):
                            # quite certainly a syntax error, managed elsewhere
                            continue
                        state[name][s_dec].append({&quot;order&quot;: self.iorder})
                        self.iorder += 1
        return state

    def _handle_state_decls(self, state, sls, saltenv, errors):
        &quot;&quot;&quot;
        Add sls and saltenv components to the state
        &quot;&quot;&quot;
        for name in state:
            if not isinstance(state[name], dict):
                if name == &quot;__extend__&quot;:
                    continue
                if name == &quot;__exclude__&quot;:
                    continue

                if isinstance(state[name], str):
                    # Is this is a short state, it needs to be padded
                    if &quot;.&quot; in state[name]:
                        comps = state[name].split(&quot;.&quot;)
                        state[name] = {
                            &quot;__sls__&quot;: sls,
                            &quot;__env__&quot;: saltenv,
                            comps[0]: [comps[1]],
                        }
                        continue
                errors.append(&quot;ID {} in SLS {} is not a dictionary&quot;.format(name, sls))
                continue
            skeys = set()
            for key in list(state[name]):
                if key.startswith(&quot;_&quot;):
                    continue
                if not isinstance(state[name][key], list):
                    continue
                if &quot;.&quot; in key:
                    comps = key.split(&quot;.&quot;)
                    # Salt doesn't support state files such as:
                    #
                    #     /etc/redis/redis.conf:
                    #       file.managed:
                    #         - source: salt://redis/redis.conf
                    #         - user: redis
                    #         - group: redis
                    #         - mode: 644
                    #       file.comment:
                    #           - regex: ^requirepass
                    if comps[0] in skeys:
                        errors.append(
                            &quot;ID '{}' in SLS '{}' contains multiple state &quot;
                            &quot;declarations of the same type&quot;.format(name, sls)
                        )
                        continue
                    state[name][comps[0]] = state[name].pop(key)
                    state[name][comps[0]].append(comps[1])
                    skeys.add(comps[0])
                    continue
                skeys.add(key)
            if &quot;__sls__&quot; not in state[name]:
                state[name][&quot;__sls__&quot;] = sls
            if &quot;__env__&quot; not in state[name]:
                state[name][&quot;__env__&quot;] = saltenv

    def _handle_extend(self, state, sls, saltenv, errors):
        &quot;&quot;&quot;
        Take the extend dec out of state and apply to the highstate global
        dec
        &quot;&quot;&quot;
        if &quot;extend&quot; in state:
            ext = state.pop(&quot;extend&quot;)
            if not isinstance(ext, dict):
                errors.append(
                    &quot;Extension value in SLS '{}' is not a dictionary&quot;.format(sls)
                )
                return
            for name in ext:
                if not isinstance(ext[name], dict):
                    errors.append(
                        &quot;Extension name '{}' in SLS '{}' is not a dictionary&quot;.format(
                            name, sls
                        )
                    )
                    continue
                if &quot;__sls__&quot; not in ext[name]:
                    ext[name][&quot;__sls__&quot;] = sls
                if &quot;__env__&quot; not in ext[name]:
                    ext[name][&quot;__env__&quot;] = saltenv
                for key in list(ext[name]):
                    if key.startswith(&quot;_&quot;):
                        continue
                    if not isinstance(ext[name][key], list):
                        continue
                    if &quot;.&quot; in key:
                        comps = key.split(&quot;.&quot;)
                        ext[name][comps[0]] = ext[name].pop(key)
                        ext[name][comps[0]].append(comps[1])
            state.setdefault(&quot;__extend__&quot;, []).append(ext)

    def _handle_exclude(self, state, sls, saltenv, errors):
        &quot;&quot;&quot;
        Take the exclude dec out of the state and apply it to the highstate
        global dec
        &quot;&quot;&quot;
        if &quot;exclude&quot; in state:
            exc = state.pop(&quot;exclude&quot;)
            if not isinstance(exc, list):
                err = &quot;Exclude Declaration in SLS {} is not formed as a list&quot;.format(
                    sls
                )
                errors.append(err)
            state.setdefault(&quot;__exclude__&quot;, []).extend(exc)

    def render_highstate(self, matches, context=None):
        &quot;&quot;&quot;
        Gather the state files and render them into a single unified salt
        high data structure.
        &quot;&quot;&quot;
        highstate = self.building_highstate
        all_errors = []
        mods = set()
        statefiles = []
        for saltenv, states in matches.items():
            for sls_match in states:
                if saltenv in self.avail:
                    statefiles = fnmatch.filter(self.avail[saltenv], sls_match)
                elif &quot;__env__&quot; in self.avail:
                    statefiles = fnmatch.filter(self.avail[&quot;__env__&quot;], sls_match)
                else:
                    all_errors.append(
                        &quot;No matching salt environment for environment &quot;
                        &quot;'{}' found&quot;.format(saltenv)
                    )
                # if we did not found any sls in the fileserver listing, this
                # may be because the sls was generated or added later, we can
                # try to directly execute it, and if it fails, anyway it will
                # return the former error
                if not statefiles:
                    statefiles = [sls_match]

                for sls in statefiles:
                    r_env = &quot;{}:{}&quot;.format(saltenv, sls)
                    if r_env in mods:
                        continue
                    state, errors = self.render_state(
                        sls, saltenv, mods, matches, context=context
                    )
                    if state:
                        self.merge_included_states(highstate, state, errors)
                    for i, error in enumerate(errors[:]):
                        if &quot;is not available&quot; in error:
                            # match SLS foobar in environment
                            this_sls = &quot;SLS {} in saltenv&quot;.format(sls_match)
                            if this_sls in error:
                                errors[
                                    i
                                ] = &quot;No matching sls found for '{}' in env '{}'&quot;.format(
                                    sls_match, saltenv
                                )
                    all_errors.extend(errors)

        self.clean_duplicate_extends(highstate)
        return highstate, all_errors

    def clean_duplicate_extends(self, highstate):
        if &quot;__extend__&quot; in highstate:
            highext = []
            for items in (ext.items() for ext in highstate[&quot;__extend__&quot;]):
                for item in items:
                    if item not in highext:
                        highext.append(item)
            highstate[&quot;__extend__&quot;] = [{t[0]: t[1]} for t in highext]

    def merge_included_states(self, highstate, state, errors):
        # The extend members can not be treated as globally unique:
        if &quot;__extend__&quot; in state:
            highstate.setdefault(&quot;__extend__&quot;, []).extend(state.pop(&quot;__extend__&quot;))
        if &quot;__exclude__&quot; in state:
            highstate.setdefault(&quot;__exclude__&quot;, []).extend(state.pop(&quot;__exclude__&quot;))
        for id_ in state:
            if id_ in highstate:
                if highstate[id_] != state[id_]:
                    errors.append(
                        &quot;Detected conflicting IDs, SLS&quot;
                        &quot; IDs need to be globally unique.\n    The&quot;
                        &quot; conflicting ID is '{}' and is found in SLS&quot;
                        &quot; '{}:{}' and SLS '{}:{}'&quot;.format(
                            id_,
                            highstate[id_][&quot;__env__&quot;],
                            highstate[id_][&quot;__sls__&quot;],
                            state[id_][&quot;__env__&quot;],
                            state[id_][&quot;__sls__&quot;],
                        )
                    )
        try:
            highstate.update(state)
        except ValueError:
            errors.append(&quot;Error when rendering state with contents: {}&quot;.format(state))

    def _check_pillar(self, force=False):
        &quot;&quot;&quot;
        Check the pillar for errors, refuse to run the state if there are
        errors in the pillar and return the pillar errors
        &quot;&quot;&quot;
        if force:
            return True
        if &quot;_errors&quot; in self.state.opts[&quot;pillar&quot;]:
            return False
        return True

    def matches_whitelist(self, matches, whitelist):
        &quot;&quot;&quot;
        Reads over the matches and returns a matches dict with just the ones
        that are in the whitelist
        &quot;&quot;&quot;
        if not whitelist:
            return matches
        ret_matches = {}
        if not isinstance(whitelist, list):
            whitelist = whitelist.split(&quot;,&quot;)
        for env in matches:
<A NAME="7"></A>            for sls in matches[env]:
                if sls in whitelist:
                    ret_matches[env] = ret_matches[env] if env in ret_matches else []
                    ret_matches[env].append(sl<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#7',2,'match147349-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>s)
        return ret_matches

    def call_highstate(
        self,
        exclude=None,
        cache=None,
        cache_name=&quot;highstate&quot;,
        force=False,
        whitelist=None,
        orchestration_jid=None,
    ):
        &quot;&quot;&quot;
        Run the sequence to execute the salt highstate for this minion
        &quot;&quot;&quot;
        # Check that top file exists
        tag_name = &quot;no_|-states_|-states_|-None&quot;
        ret =</B></FONT> {
            tag_name: {
                &quot;result&quot;: False,
                &quot;comment&quot;: &quot;No states found for this minion&quot;,
                &quot;name&quot;: &quot;No States&quot;,
                &quot;changes&quot;: {},
                &quot;__run_num__&quot;: 0,
            }
        }
        cfn = os.path.join(self.opts[&quot;cachedir&quot;], &quot;{}.cache.p&quot;.format(cache_name))

        if cache:
            if os.path.isfile(cfn):
                with salt.utils.files.fopen(cfn, &quot;rb&quot;) as fp_:
                    high = salt.payload.load(fp_)
                    return self.state.call_high(high, orchestration_jid)
        # File exists so continue
        err = []
        try:
            top = self.get_top()
        except SaltRenderError as err:
            ret[tag_name][&quot;comment&quot;] = &quot;Unable to render top file: &quot;
            ret[tag_name][&quot;comment&quot;] += str(err.error)
            return ret
        except Exception:  # pylint: disable=broad-except
            trb = traceback.format_exc()
            err.append(trb)
            return err
        err += self.verify_tops(top)
        matches = self.top_matches(top)
        if not matches:
            msg = (
                &quot;No Top file or master_tops data matches found. Please see &quot;
                &quot;master log for details.&quot;
            )
            ret[tag_name][&quot;comment&quot;] = msg
            return ret
        matches = self.matches_whitelist(matches, whitelist)
        self.load_dynamic(matches)
        if not self._check_pillar(force):
            err += [&quot;Pillar failed to render with the following messages:&quot;]
            err += self.state.opts[&quot;pillar&quot;][&quot;_errors&quot;]
        else:
            high, errors = self.render_highstate(matches)
            if exclude:
                if isinstance(exclude, str):
                    exclude = exclude.split(&quot;,&quot;)
                if &quot;__exclude__&quot; in high:
                    high[&quot;__exclude__&quot;].extend(exclude)
                else:
                    high[&quot;__exclude__&quot;] = exclude
            err += errors
        if err:
            return err
        if not high:
            return ret
        with salt.utils.files.set_umask(0o077):
            try:
                if salt.utils.platform.is_windows():
                    # Make sure cache file isn't read-only
                    self.state.functions[&quot;cmd.run&quot;](
                        [&quot;attrib&quot;, &quot;-R&quot;, cfn],
                        python_shell=False,
                        output_loglevel=&quot;quiet&quot;,
                    )
                with salt.utils.files.fopen(cfn, &quot;w+b&quot;) as fp_:
                    try:
                        salt.payload.dump(high, fp_)
                    except TypeError:
                        # Can't serialize pydsl
                        pass
            except OSError:
                log.error('Unable to write to &quot;state.highstate&quot; cache file %s', cfn)

        return self.state.call_high(high, orchestration_jid)

    def compile_highstate(self):
        &quot;&quot;&quot;
        Return just the highstate or the errors
        &quot;&quot;&quot;
        err = []
        top = self.get_top()
        err += self.verify_tops(top)
        matches = self.top_matches(top)
        high, errors = self.render_highstate(matches)
        err += errors

        if err:
            return err

        return high

    def compile_low_chunks(self):
        &quot;&quot;&quot;
        Compile the highstate but don't run it, return the low chunks to
        see exactly what the highstate will execute
        &quot;&quot;&quot;
        top = self.get_top()
        matches = self.top_matches(top)
        high, errors = self.render_highstate(matches)

        # If there is extension data reconcile it
        high, ext_errors = self.state.reconcile_extend(high)
        errors += ext_errors

        # Verify that the high data is structurally sound
        errors += self.state.verify_high(high)
        high, req_in_errors = self.state.requisite_in(high)
        errors += req_in_errors
        high = self.state.apply_exclude(high)

        if errors:
            return errors

        # Compile and verify the raw chunks
        chunks = self.state.compile_high_data(high)

        return chunks

    def compile_state_usage(self):
        &quot;&quot;&quot;
        Return all used and unused states for the minion based on the top match data
        &quot;&quot;&quot;
        err = []
        top = self.get_top()
        err += self.verify_tops(top)

        if err:
            return err

        matches = self.top_matches(top)
        state_usage = {}

        for saltenv, states in self.avail.items():
            env_usage = {
                &quot;used&quot;: [],
                &quot;unused&quot;: [],
                &quot;count_all&quot;: 0,
                &quot;count_used&quot;: 0,
                &quot;count_unused&quot;: 0,
            }

            env_matches = matches.get(saltenv, [])

            for state in states:
                env_usage[&quot;count_all&quot;] += 1
                if state in env_matches:
                    env_usage[&quot;count_used&quot;] += 1
                    env_usage[&quot;used&quot;].append(state)
                else:
                    env_usage[&quot;count_unused&quot;] += 1
                    env_usage[&quot;unused&quot;].append(state)

            state_usage[saltenv] = env_usage

        return state_usage

    def destroy(self):
        raise NotImplementedError

    def __enter__(self):
        return self

    def __exit__(self, *_):
        self.destroy()


class HighState(BaseHighState):
    &quot;&quot;&quot;
    Generate and execute the salt &quot;High State&quot;. The High State is the
    compound state derived from a group of template files stored on the
    salt master or in the local cache.
    &quot;&quot;&quot;

    # a stack of active HighState objects during a state.highstate run
    stack = []

    def __init__(
        self,
        opts,
        pillar_override=None,
        jid=None,
        pillar_enc=None,
        proxy=None,
        context=None,
        mocked=False,
<A NAME="3"></A>        loader=&quot;states&quot;,
        initial_pillar=None,
    ):
        self<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#3',2,'match147349-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.opts = opts
        self.client = salt.fileclient.get_file_client(self.opts)
        BaseHighState.__init__(self, opts)
        self.state =</B></FONT> State(
            self.opts,
            pillar_override,
            jid,
            pillar_enc,
            proxy=proxy,
            context=context,
            mocked=mocked,
            loader=loader,
            initial_pillar=initial_pillar,
        )
        self.matchers = salt.loader.matchers(self.opts)
        self.proxy = proxy

        # tracks all pydsl state declarations globally across sls files
        self._pydsl_all_decls = {}

        # a stack of current rendering Sls objects, maintained and used by the pydsl renderer.
        self._pydsl_render_stack = []

    def push_active(self):
        self.stack.append(self)

    @classmethod
    def clear_active(cls):
        # Nuclear option
        #
        # Blow away the entire stack. Used primarily by the test runner but also
        # useful in custom wrappers of the HighState class, to reset the stack
        # to a fresh state.
        cls.stack = []

    @classmethod
    def pop_active(cls):
        cls.stack.pop()

    @classmethod
    def get_active(cls):
        try:
            return cls.stack[-1]
        except IndexError:
            return None

    def destroy(self):
        self.client.destroy()

    def __enter__(self):
        return self

    def __exit__(self, *_):
        self.destroy()


class MasterState(State):
    &quot;&quot;&quot;
    Create a State object for master side compiling
    &quot;&quot;&quot;

    def __init__(self, opts, minion):
        State.__init__(self, opts)

    def load_modules(self, data=None, proxy=None):
        &quot;&quot;&quot;
        Load the modules into the state
        &quot;&quot;&quot;
        log.info(&quot;Loading fresh modules for state activity&quot;)
        # Load a modified client interface that looks like the interface used
        # from the minion, but uses remote execution
        #
        self.functions = salt.client.FunctionWrapper(self.opts, self.opts[&quot;id&quot;])
        # Load the states, but they should not be used in this class apart
<A NAME="5"></A>        # from inspection
        self.utils = salt.loader.utils(self.opts)
        self.serializers = salt.loader.serializers(self.opts)
        self.states = salt.loader<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match147349-0.html#5',2,'match147349-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.states(
            self.opts, self.functions, self.utils, self.serializers
        )
        self.rend = salt.loader.render(
            self.</B></FONT>opts, self.functions, states=self.states, context=self.state_con
        )


class MasterHighState(HighState):
    &quot;&quot;&quot;
    Execute highstate compilation from the master
    &quot;&quot;&quot;

    def __init__(self, master_opts, minion_opts, grains, id_, saltenv=None):
        # Force the fileclient to be local
        opts = copy.deepcopy(minion_opts)
        opts[&quot;file_client&quot;] = &quot;local&quot;
        opts[&quot;file_roots&quot;] = master_opts[&quot;master_roots&quot;]
        opts[&quot;renderer&quot;] = master_opts[&quot;renderer&quot;]
        opts[&quot;state_top&quot;] = master_opts[&quot;state_top&quot;]
        opts[&quot;id&quot;] = id_
        opts[&quot;grains&quot;] = grains
        HighState.__init__(self, opts)


class RemoteHighState:
    &quot;&quot;&quot;
    Manage gathering the data from the master
    &quot;&quot;&quot;

    # XXX: This class doesn't seem to be used anywhere
    def __init__(self, opts, grains):
        self.opts = opts
        self.grains = grains
        # self.auth = salt.crypt.SAuth(opts)
        self.channel = salt.channel.client.ReqChannel.factory(self.opts[&quot;master_uri&quot;])
        self._closing = False

    def compile_master(self):
        &quot;&quot;&quot;
        Return the state data from the master
        &quot;&quot;&quot;
        load = {&quot;grains&quot;: self.grains, &quot;opts&quot;: self.opts, &quot;cmd&quot;: &quot;_master_state&quot;}
        try:
            return self.channel.send(load, tries=3, timeout=72000)
        except SaltReqTimeoutError:
            return {}

    def destroy(self):
        if self._closing:
            return

        self._closing = True
        self.channel.close()

    # pylint: disable=W1701
    def __del__(self):
        self.destroy()

    # pylint: enable=W1701
</PRE>
</div>
  </div>
</body>
</html>
