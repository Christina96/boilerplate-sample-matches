
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 22.920517560073936%, Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp8266.py</h3>
            <pre><code>1  from ..loader import ESPLoader
2  from ..util import FatalError, NotImplementedInROMError
3  class ESP8266ROM(ESPLoader):
4      CHIP_NAME = "ESP8266"
5      IS_STUB = False
6      CHIP_DETECT_MAGIC_VALUE = [0xFFF0C101]
7      ESP_OTP_MAC0 = 0x3FF00050
8      ESP_OTP_MAC1 = 0x3FF00054
9      ESP_OTP_MAC3 = 0x3FF0005C
10      SPI_REG_BASE = 0x60000200
11      SPI_USR_OFFS = 0x1C
12      SPI_USR1_OFFS = 0x20
13      SPI_USR2_OFFS = 0x24
14      SPI_MOSI_DLEN_OFFS = None
15      SPI_MISO_DLEN_OFFS = None
16      SPI_W0_OFFS = 0x40
17      UART_CLKDIV_REG = 0x60000014
18      XTAL_CLK_DIVIDER = 2
19      FLASH_SIZES = {
20          "512KB": 0x00,
21          "256KB": 0x10,
22          "1MB": 0x20,
23          "2MB": 0x30,
24          "4MB": 0x40,
25          "2MB-c1": 0x50,
26          "4MB-c1": 0x60,
27          "8MB": 0x80,
28          "16MB": 0x90,
29      }
30      FLASH_FREQUENCY = {
31          "80m": 0xF,
32          "40m": 0x0,
33          "26m": 0x1,
34          "20m": 0x2,
35      }
36      BOOTLOADER_FLASH_OFFSET = 0
37      MEMORY_MAP = [
38          [0x3FF00000, 0x3FF00010, "DPORT"],
39          [0x3FFE8000, 0x40000000, "DRAM"],
40          [0x40100000, 0x40108000, "IRAM"],
41          [0x40201010, 0x402E1010, "IROM"],
42      ]
<span onclick='openModal()' class='match'>43      def get_efuses(self):
44          result = self.read_reg(0x3FF0005C) << 96
45          result |= self.read_reg(0x3FF00058) << 64
46          result |= self.read_reg(0x3FF00054) << 32
47          result |= self.read_reg(0x3FF00050)
48          return result
49      def _get_flash_size(self, efuses):
50          r0_4 = (efuses & (1 << 4)) != 0
</span>51          r3_25 = (efuses & (1 << 121)) != 0
52          r3_26 = (efuses & (1 << 122)) != 0
53          r3_27 = (efuses & (1 << 123)) != 0
54          if r0_4 and not r3_25:
55              if not r3_27 and not r3_26:
56                  return 1
57              elif not r3_27 and r3_26:
58                  return 2
59          if not r0_4 and r3_25:
60              if not r3_27 and not r3_26:
61                  return 2
62              elif not r3_27 and r3_26:
63                  return 4
64          return -1
65      def get_chip_description(self):
66          efuses = self.get_efuses()
67          is_8285 = (
68              efuses & ((1 << 4) | 1 << 80)
69          ) != 0  # One or the other efuse bit is set for ESP8285
70          if is_8285:
71              flash_size = self._get_flash_size(efuses)
72              max_temp = (
73                  efuses & (1 << 5)
74              ) != 0  # This efuse bit identifies the max flash temperature
75              chip_name = {
76                  1: "ESP8285H08" if max_temp else "ESP8285N08",
77                  2: "ESP8285H16" if max_temp else "ESP8285N16",
78              }.get(flash_size, "ESP8285")
79              return chip_name
80          return "ESP8266EX"
81      def get_chip_features(self):
82          features = ["WiFi"]
83          if "ESP8285" in self.get_chip_description():
84              features += ["Embedded Flash"]
85          return features
86      def flash_spi_attach(self, hspi_arg):
87          if self.IS_STUB:
88              super(ESP8266ROM, self).flash_spi_attach(hspi_arg)
89          else:
90              self.flash_begin(0, 0)
91      def flash_set_parameters(self, size):
92          if self.IS_STUB:
93              super(ESP8266ROM, self).flash_set_parameters(size)
94      def chip_id(self):
95          id0 = self.read_reg(self.ESP_OTP_MAC0)
96          id1 = self.read_reg(self.ESP_OTP_MAC1)
97          return (id0 >> 24) | ((id1 & 0xFFFFFF) << 8)
98      def read_mac(self):
99          mac0 = self.read_reg(self.ESP_OTP_MAC0)
100          mac1 = self.read_reg(self.ESP_OTP_MAC1)
101          mac3 = self.read_reg(self.ESP_OTP_MAC3)
102          if mac3 != 0:
103              oui = ((mac3 >> 16) & 0xFF, (mac3 >> 8) & 0xFF, mac3 & 0xFF)
104          elif ((mac1 >> 16) & 0xFF) == 0:
105              oui = (0x18, 0xFE, 0x34)
106          elif ((mac1 >> 16) & 0xFF) == 1:
107              oui = (0xAC, 0xD0, 0x74)
108          else:
109              raise FatalError("Unknown OUI")
110          return oui + ((mac1 >> 8) & 0xFF, mac1 & 0xFF, (mac0 >> 24) & 0xFF)
111      def get_erase_size(self, offset, size):
112          sectors_per_block = 16
113          sector_size = self.FLASH_SECTOR_SIZE
114          num_sectors = (size + sector_size - 1) // sector_size
115          start_sector = offset // sector_size
116          head_sectors = sectors_per_block - (start_sector % sectors_per_block)
117          if num_sectors < head_sectors:
118              head_sectors = num_sectors
119          if num_sectors < 2 * head_sectors:
120              return (num_sectors + 1) // 2 * sector_size
121          else:
122              return (num_sectors - head_sectors) * sector_size
123      def override_vddsdio(self, new_voltage):
124          raise NotImplementedInROMError(
125              "Overriding VDDSDIO setting only applies to ESP32"
126          )
127  class ESP8266StubLoader(ESP8266ROM):
128      FLASH_WRITE_SIZE = 0x4000  # matches MAX_WRITE_BLOCK in stub_loader.c
129      IS_STUB = True
130      def __init__(self, rom_loader):
131          self.secure_download_mode = rom_loader.secure_download_mode
132          self._port = rom_loader._port
133          self._trace_enabled = rom_loader._trace_enabled
134          self.cache = rom_loader.cache
135          self.flush_input()  # resets _slip_reader
136      def get_erase_size(self, offset, size):
137          return size  # stub doesn't have same size bug as ROM loader
138  ESP8266ROM.STUB_CLASS = ESP8266StubLoader
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32s2.py</h3>
            <pre><code>1  import os
2  import struct
3  from .esp32 import ESP32ROM
4  from ..loader import ESPLoader
5  from ..reset import HardReset
6  from ..util import FatalError, NotImplementedInROMError
7  class ESP32S2ROM(ESP32ROM):
8      CHIP_NAME = "ESP32-S2"
9      IMAGE_CHIP_ID = 2
10      FPGA_SLOW_BOOT = False
11      IROM_MAP_START = 0x40080000
12      IROM_MAP_END = 0x40B80000
13      DROM_MAP_START = 0x3F000000
14      DROM_MAP_END = 0x3F3F0000
15      CHIP_DETECT_MAGIC_VALUE = [0x000007C6]
16      SPI_REG_BASE = 0x3F402000
17      SPI_USR_OFFS = 0x18
18      SPI_USR1_OFFS = 0x1C
19      SPI_USR2_OFFS = 0x20
20      SPI_MOSI_DLEN_OFFS = 0x24
21      SPI_MISO_DLEN_OFFS = 0x28
22      SPI_W0_OFFS = 0x58
23      MAC_EFUSE_REG = 0x3F41A044  # ESP32-S2 has special block for MAC efuses
24      UART_CLKDIV_REG = 0x3F400014
25      SUPPORTS_ENCRYPTED_FLASH = True
26      FLASH_ENCRYPTED_WRITE_ALIGN = 16
27      EFUSE_BASE = 0x3F41A000
28      EFUSE_RD_REG_BASE = EFUSE_BASE + 0x030  # BLOCK0 read base address
29      EFUSE_BLOCK1_ADDR = EFUSE_BASE + 0x044
30      EFUSE_BLOCK2_ADDR = EFUSE_BASE + 0x05C
31      EFUSE_PURPOSE_KEY0_REG = EFUSE_BASE + 0x34
32      EFUSE_PURPOSE_KEY0_SHIFT = 24
33      EFUSE_PURPOSE_KEY1_REG = EFUSE_BASE + 0x34
34      EFUSE_PURPOSE_KEY1_SHIFT = 28
35      EFUSE_PURPOSE_KEY2_REG = EFUSE_BASE + 0x38
36      EFUSE_PURPOSE_KEY2_SHIFT = 0
37      EFUSE_PURPOSE_KEY3_REG = EFUSE_BASE + 0x38
38      EFUSE_PURPOSE_KEY3_SHIFT = 4
39      EFUSE_PURPOSE_KEY4_REG = EFUSE_BASE + 0x38
40      EFUSE_PURPOSE_KEY4_SHIFT = 8
41      EFUSE_PURPOSE_KEY5_REG = EFUSE_BASE + 0x38
42      EFUSE_PURPOSE_KEY5_SHIFT = 12
43      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = EFUSE_RD_REG_BASE
44      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 << 19
45      EFUSE_SPI_BOOT_CRYPT_CNT_REG = EFUSE_BASE + 0x034
46      EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 << 18
47      EFUSE_SECURE_BOOT_EN_REG = EFUSE_BASE + 0x038
48      EFUSE_SECURE_BOOT_EN_MASK = 1 << 20
49      EFUSE_RD_REPEAT_DATA3_REG = EFUSE_BASE + 0x3C
50      EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK = 1 << 9
51      PURPOSE_VAL_XTS_AES256_KEY_1 = 2
52      PURPOSE_VAL_XTS_AES256_KEY_2 = 3
53      PURPOSE_VAL_XTS_AES128_KEY = 4
54      UARTDEV_BUF_NO = 0x3FFFFD14  # Variable in ROM .bss which indicates the port in use
55      UARTDEV_BUF_NO_USB_OTG = 2  # Value of the above indicating that USB-OTG is in use
56      USB_RAM_BLOCK = 0x800  # Max block size USB-OTG is used
57      GPIO_STRAP_REG = 0x3F404038
58      GPIO_STRAP_SPI_BOOT_MASK = 0x8  # Not download mode
59      RTC_CNTL_OPTION1_REG = 0x3F408128
60      RTC_CNTL_FORCE_DOWNLOAD_BOOT_MASK = 0x1  # Is download mode forced over USB?
61      MEMORY_MAP = [
62          [0x00000000, 0x00010000, "PADDING"],
63          [0x3F000000, 0x3FF80000, "DROM"],
64          [0x3F500000, 0x3FF80000, "EXTRAM_DATA"],
65          [0x3FF9E000, 0x3FFA0000, "RTC_DRAM"],
66          [0x3FF9E000, 0x40000000, "BYTE_ACCESSIBLE"],
67          [0x3FF9E000, 0x40072000, "MEM_INTERNAL"],
68          [0x3FFB0000, 0x40000000, "DRAM"],
69          [0x40000000, 0x4001A100, "IROM_MASK"],
70          [0x40020000, 0x40070000, "IRAM"],
71          [0x40070000, 0x40072000, "RTC_IRAM"],
72          [0x40080000, 0x40800000, "IROM"],
73          [0x50000000, 0x50002000, "RTC_DATA"],
74      ]
75      def get_pkg_version(self):
76          num_word = 4
77          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) >> 0) & 0x0F
78      def get_minor_chip_version(self):
79          hi_num_word = 3
80          hi = (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * hi_num_word)) >> 20) & 0x01
81          low_num_word = 4
82          low = (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * low_num_word)) >> 4) & 0x07
83          return (hi << 3) + low
84      def get_major_chip_version(self):
85          num_word = 3
86          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) >> 18) & 0x03
87      def get_flash_version(self):
88          num_word = 3
89          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) >> 21) & 0x0F
90      def get_psram_version(self):
91          num_word = 3
92          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) >> 28) & 0x0F
93      def get_block2_version(self):
94          num_word = 4
95          return (self.read_reg(self.EFUSE_BLOCK2_ADDR + (4 * num_word)) >> 4) & 0x07
<span onclick='openModal()' class='match'>96      def get_chip_description(self):
97          chip_name = {
98              0: "ESP32-S2",
99              1: "ESP32-S2FH2",
100              2: "ESP32-S2FH4",
101              102: "ESP32-S2FNR2",
102              100: "ESP32-S2R2",
103          }.get(
104              self.get_flash_version() + self.get_psram_version() * 100,
105              "unknown ESP32-S2",
106          )
107          major_rev = self.get_major_chip_version()
108          minor_rev = self.get_minor_chip_version()
109          return f"{chip_name} (revision v{major_rev}.{minor_rev})"
110      def get_chip_features(self):
111          features = ["WiFi"]
</span>112          if self.secure_download_mode:
113              features += ["Secure Download Mode Enabled"]
114          flash_version = {
115              0: "No Embedded Flash",
116              1: "Embedded Flash 2MB",
117              2: "Embedded Flash 4MB",
118          }.get(self.get_flash_version(), "Unknown Embedded Flash")
119          features += [flash_version]
120          psram_version = {
121              0: "No Embedded PSRAM",
122              1: "Embedded PSRAM 2MB",
123              2: "Embedded PSRAM 4MB",
124          }.get(self.get_psram_version(), "Unknown Embedded PSRAM")
125          features += [psram_version]
126          block2_version = {
127              0: "No calibration in BLK2 of efuse",
128              1: "ADC and temperature sensor calibration in BLK2 of efuse V1",
129              2: "ADC and temperature sensor calibration in BLK2 of efuse V2",
130          }.get(self.get_block2_version(), "Unknown Calibration in BLK2")
131          features += [block2_version]
132          return features
133      def get_crystal_freq(self):
134          return 40
135      def override_vddsdio(self, new_voltage):
136          raise NotImplementedInROMError(
137              "VDD_SDIO overrides are not supported for ESP32-S2"
138          )
139      def read_mac(self):
140          mac0 = self.read_reg(self.MAC_EFUSE_REG)
141          mac1 = self.read_reg(self.MAC_EFUSE_REG + 4)  # only bottom 16 bits are MAC
142          bitstring = struct.pack(">II", mac1, mac0)[2:]
143          return tuple(bitstring)
144      def flash_type(self):
145          return (
146              1
147              if self.read_reg(self.EFUSE_RD_REPEAT_DATA3_REG)
148              & self.EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK
149              else 0
150          )
151      def get_flash_crypt_config(self):
152          return None  # doesn't exist on ESP32-S2
153      def get_secure_boot_enabled(self):
154          return (
155              self.read_reg(self.EFUSE_SECURE_BOOT_EN_REG)
156              & self.EFUSE_SECURE_BOOT_EN_MASK
157          )
158      def get_key_block_purpose(self, key_block):
159          if key_block < 0 or key_block > 5:
160              raise FatalError("Valid key block numbers must be in range 0-5")
161          reg, shift = [
162              (self.EFUSE_PURPOSE_KEY0_REG, self.EFUSE_PURPOSE_KEY0_SHIFT),
163              (self.EFUSE_PURPOSE_KEY1_REG, self.EFUSE_PURPOSE_KEY1_SHIFT),
164              (self.EFUSE_PURPOSE_KEY2_REG, self.EFUSE_PURPOSE_KEY2_SHIFT),
165              (self.EFUSE_PURPOSE_KEY3_REG, self.EFUSE_PURPOSE_KEY3_SHIFT),
166              (self.EFUSE_PURPOSE_KEY4_REG, self.EFUSE_PURPOSE_KEY4_SHIFT),
167              (self.EFUSE_PURPOSE_KEY5_REG, self.EFUSE_PURPOSE_KEY5_SHIFT),
168          ][key_block]
169          return (self.read_reg(reg) >> shift) & 0xF
170      def is_flash_encryption_key_valid(self):
171          purposes = [self.get_key_block_purpose(b) for b in range(6)]
172          if any(p == self.PURPOSE_VAL_XTS_AES128_KEY for p in purposes):
173              return True
174          return any(p == self.PURPOSE_VAL_XTS_AES256_KEY_1 for p in purposes) and any(
175              p == self.PURPOSE_VAL_XTS_AES256_KEY_2 for p in purposes
176          )
177      def uses_usb_otg(self):
178          if self.secure_download_mode:
179              return False  # can't detect native USB in secure download mode
180          return self.get_uart_no() == self.UARTDEV_BUF_NO_USB_OTG
181      def _post_connect(self):
182          if self.uses_usb_otg():
183              self.ESP_RAM_BLOCK = self.USB_RAM_BLOCK
184      def _check_if_can_reset(self):
185          if os.getenv("ESPTOOL_TESTING") is not None:
186              print("ESPTOOL_TESTING is set, ignoring strapping mode check")
187              return
188          strap_reg = self.read_reg(self.GPIO_STRAP_REG)
189          force_dl_reg = self.read_reg(self.RTC_CNTL_OPTION1_REG)
190          if (
191              strap_reg & self.GPIO_STRAP_SPI_BOOT_MASK == 0
192              and force_dl_reg & self.RTC_CNTL_FORCE_DOWNLOAD_BOOT_MASK == 0
193          ):
194              print(
195                  "WARNING: {} chip was placed into download mode using GPIO0.\n"
196                  "esptool.py can not exit the download mode over USB. "
197                  "To run the app, reset the chip manually.\n"
198                  "To suppress this note, set --after option to 'no_reset'.".format(
199                      self.get_chip_description()
200                  )
201              )
202              raise SystemExit(1)
203      def hard_reset(self):
204          uses_usb_otg = self.uses_usb_otg()
205          if uses_usb_otg:
206              self._check_if_can_reset()
207          print("Hard resetting via RTS pin...")
208          HardReset(self._port, uses_usb_otg)()
209      def change_baud(self, baud):
210          ESPLoader.change_baud(self, baud)
211  class ESP32S2StubLoader(ESP32S2ROM):
212      FLASH_WRITE_SIZE = 0x4000  # matches MAX_WRITE_BLOCK in stub_loader.c
213      STATUS_BYTES_LENGTH = 2  # same as ESP8266, different to ESP32 ROM
214      IS_STUB = True
215      def __init__(self, rom_loader):
216          self.secure_download_mode = rom_loader.secure_download_mode
217          self._port = rom_loader._port
218          self._trace_enabled = rom_loader._trace_enabled
219          self.cache = rom_loader.cache
220          self.flush_input()  # resets _slip_reader
221          if rom_loader.uses_usb_otg():
222              self.ESP_RAM_BLOCK = self.USB_RAM_BLOCK
223              self.FLASH_WRITE_SIZE = self.USB_RAM_BLOCK
224  ESP32S2ROM.STUB_CLASS = ESP32S2StubLoader
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp8266.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32s2.py</div>
                </div>
                <div class="column column_space"><pre><code>43      def get_efuses(self):
44          result = self.read_reg(0x3FF0005C) << 96
45          result |= self.read_reg(0x3FF00058) << 64
46          result |= self.read_reg(0x3FF00054) << 32
47          result |= self.read_reg(0x3FF00050)
48          return result
49      def _get_flash_size(self, efuses):
50          r0_4 = (efuses & (1 << 4)) != 0
</pre></code></div>
                <div class="column column_space"><pre><code>96      def get_chip_description(self):
97          chip_name = {
98              0: "ESP32-S2",
99              1: "ESP32-S2FH2",
100              2: "ESP32-S2FH4",
101              102: "ESP32-S2FNR2",
102              100: "ESP32-S2R2",
103          }.get(
104              self.get_flash_version() + self.get_psram_version() * 100,
105              "unknown ESP32-S2",
106          )
107          major_rev = self.get_major_chip_version()
108          minor_rev = self.get_minor_chip_version()
109          return f"{chip_name} (revision v{major_rev}.{minor_rev})"
110      def get_chip_features(self):
111          features = ["WiFi"]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    