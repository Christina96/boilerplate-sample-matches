<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for random_org.py &amp; auth_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for random_org.py &amp; auth_test.py
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>random_org.py (1.7148982%)<th>auth_test.py (1.6309888%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(146-149)<td><a href="#" name="0">(163-166)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>random_org.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import http.client
import logging
import urllib.request
import salt.utils.http
import salt.utils.json
log = logging.getLogger(__name__)
__virtualname__ = "random_org"
RANDOM_ORG_FUNCTIONS = {
    "1": {
        "getUsage": {"method": "getUsage"},
        "generateIntegers": {"method": "generateIntegers"},
        "generateStrings": {"method": "generateStrings"},
        "generateUUIDs": {"method": "generateUUIDs"},
        "generateDecimalFractions": {"method": "generateDecimalFractions"},
        "generateGaussians": {"method": "generateGaussians"},
        "generateBlobs": {"method": "generateBlobs"},
    }
}
def __virtual__():
    return __virtualname__
def _numeric(n):
    return isinstance(n, (int, float))
def _query(api_version=None, data=None):
    if data is None:
        data = {}
    ret = {"res": True}
    api_url = "https://api.random.org/"
    base_url = urllib.parse.urljoin(api_url, "json-rpc/" + str(api_version) + "/invoke")
    data = salt.utils.json.dumps(data)
    result = salt.utils.http.query(
        base_url,
        method="POST",
        params={},
        data=data,
        decode=True,
        status=True,
        header_dict={},
        opts=__opts__,
    )
    if result.get("status", None) == http.client.OK:
        _result = result["dict"]
        if _result.get("result"):
            return _result.get("result")
        if _result.get("error"):
            return _result.get("error")
        return False
    elif result.get("status", None) == http.client.NO_CONTENT:
        return False
    else:
        ret["message"] = result.text if hasattr(result, "text") else ""
        return ret
def getUsage(api_key=None, api_version=None):
    ret = {"res": True}
    if not api_key or not api_version:
        try:
            options = __salt__["config.option"]("random_org")
            if not api_key:
                api_key = options.get("api_key")
            if not api_version:
                api_version = options.get("api_version")
        except (NameError, KeyError, AttributeError):
            log.error("No Random.org api key found.")
            ret["message"] = "No Random.org api key or api version found."
            ret["res"] = False
            return ret
    if isinstance(api_version, int):
        api_version = str(api_version)
    _function = RANDOM_ORG_FUNCTIONS.get(api_version).get("getUsage").get("method")
    data = {}
    data["id"] = 1911220
    data["jsonrpc"] = "2.0"
    data["method"] = _function
    data["params"] = {"apiKey": api_key}
<a name="0"></a>    result = _query(api_version=api_version, data=data)
    if result:
        ret<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["bitsLeft"] = result.get("bitsLeft")
        ret["requestsLeft"] = result.get("requestsLeft")
        ret["totalBits"] = result.get("totalBits")
        ret["totalRequests"] = result.get(</b></font>"totalRequests")
    else:
        ret["res"] = False
        ret["message"] = result["message"]
    return ret
def generateIntegers(api_key=None, api_version=None, **kwargs):
    ret = {"res": True}
    if not api_key or not api_version:
        try:
            options = __salt__["config.option"]("random_org")
            if not api_key:
                api_key = options.get("api_key")
            if not api_version:
                api_version = options.get("api_version")
        except (NameError, KeyError, AttributeError):
            log.error("No Random.org api key found.")
            ret["message"] = "No Random.org api key or api version found."
            ret["res"] = False
            return ret
    for item in ["number", "minimum", "maximum"]:
        if item not in kwargs:
            ret["res"] = False
            ret["message"] = "Rquired argument, {} is missing.".format(item)
            return ret
    if not _numeric(kwargs["number"]) or not 1 &lt;= kwargs["number"] &lt;= 10000:
        ret["res"] = False
        ret["message"] = "Number of integers must be between 1 and 10000"
        return ret
    if (
        not _numeric(kwargs["minimum"])
        or not -1000000000 &lt;= kwargs["minimum"] &lt;= 1000000000
    ):
        ret["res"] = False
        ret[
            "message"
        ] = "Minimum argument must be between -1,000,000,000 and 1,000,000,000"
        return ret
    if (
        not _numeric(kwargs["maximum"])
        or not -1000000000 &lt;= kwargs["maximum"] &lt;= 1000000000
    ):
        ret["res"] = False
        ret[
            "message"
        ] = "Maximum argument must be between -1,000,000,000 and 1,000,000,000"
        return ret
    if "base" in kwargs:
        base = kwargs["base"]
        if base not in [2, 8, 10, 16]:
            ret["res"] = False
            ret["message"] = "Base must be either 2, 8, 10 or 16."
            return ret
    else:
        base = 10
    if "replacement" not in kwargs:
        replacement = True
    else:
        replacement = kwargs["replacement"]
    if isinstance(api_version, int):
        api_version = str(api_version)
    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version).get("generateIntegers").get("method")
    )
    data = {}
    data["id"] = 1911220
    data["jsonrpc"] = "2.0"
    data["method"] = _function
    data["params"] = {
        "apiKey": api_key,
        "n": kwargs["number"],
        "min": kwargs["minimum"],
        "max": kwargs["maximum"],
        "replacement": replacement,
        "base": base,
    }
    result = _query(api_version=api_version, data=data)
    log.debug("result %s", result)
    if result:
        if "random" in result:
            random_data = result.get("random").get("data")
            ret["data"] = random_data
        else:
            ret["res"] = False
            ret["message"] = result["message"]
    else:
        ret["res"] = False
        ret["message"] = result["message"]
    return ret
def generateStrings(api_key=None, api_version=None, **kwargs):
    ret = {"res": True}
    if not api_key or not api_version:
        try:
            options = __salt__["config.option"]("random_org")
            if not api_key:
                api_key = options.get("api_key")
            if not api_version:
                api_version = options.get("api_version")
        except (NameError, KeyError, AttributeError):
            log.error("No Random.org api key found.")
            ret["message"] = "No Random.org api key or api version found."
            ret["res"] = False
            return ret
    for item in ["number", "length", "characters"]:
        if item not in kwargs:
            ret["res"] = False
            ret["message"] = "Required argument, {} is missing.".format(item)
            return ret
    if not _numeric(kwargs["number"]) or not 1 &lt;= kwargs["number"] &lt;= 10000:
        ret["res"] = False
        ret["message"] = "Number of strings must be between 1 and 10000"
        return ret
    if not _numeric(kwargs["length"]) or not 1 &lt;= kwargs["length"] &lt;= 20:
        ret["res"] = False
        ret["message"] = "Length of strings must be between 1 and 20"
        return ret
    if len(kwargs["characters"]) &gt;= 80:
        ret["res"] = False
        ret["message"] = "Length of characters must be less than 80."
        return ret
    if isinstance(api_version, int):
        api_version = str(api_version)
    if "replacement" not in kwargs:
        replacement = True
    else:
        replacement = kwargs["replacement"]
    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version).get("generateStrings").get("method")
    )
    data = {}
    data["id"] = 1911220
    data["jsonrpc"] = "2.0"
    data["method"] = _function
    data["params"] = {
        "apiKey": api_key,
        "n": kwargs["number"],
        "length": kwargs["length"],
        "characters": kwargs["characters"],
        "replacement": replacement,
    }
    result = _query(api_version=api_version, data=data)
    if result:
        if "random" in result:
            random_data = result.get("random").get("data")
            ret["data"] = random_data
        else:
            ret["res"] = False
            ret["message"] = result["message"]
    else:
        ret["res"] = False
        ret["message"] = result["message"]
    return ret
def generateUUIDs(api_key=None, api_version=None, **kwargs):
    ret = {"res": True}
    if not api_key or not api_version:
        try:
            options = __salt__["config.option"]("random_org")
            if not api_key:
                api_key = options.get("api_key")
            if not api_version:
                api_version = options.get("api_version")
        except (NameError, KeyError, AttributeError):
            log.error("No Random.org api key found.")
            ret["message"] = "No Random.org api key or api version found."
            ret["res"] = False
            return ret
    for item in ["number"]:
        if item not in kwargs:
            ret["res"] = False
            ret["message"] = "Required argument, {} is missing.".format(item)
            return ret
    if isinstance(api_version, int):
        api_version = str(api_version)
    if not _numeric(kwargs["number"]) or not 1 &lt;= kwargs["number"] &lt;= 1000:
        ret["res"] = False
        ret["message"] = "Number of UUIDs must be between 1 and 1000"
        return ret
    _function = RANDOM_ORG_FUNCTIONS.get(api_version).get("generateUUIDs").get("method")
    data = {}
    data["id"] = 1911220
    data["jsonrpc"] = "2.0"
    data["method"] = _function
    data["params"] = {
        "apiKey": api_key,
        "n": kwargs["number"],
    }
    result = _query(api_version=api_version, data=data)
    if result:
        if "random" in result:
            random_data = result.get("random").get("data")
            ret["data"] = random_data
        else:
            ret["res"] = False
            ret["message"] = result["message"]
    else:
        ret["res"] = False
        ret["message"] = result["message"]
    return ret
def generateDecimalFractions(api_key=None, api_version=None, **kwargs):
    ret = {"res": True}
    if not api_key or not api_version:
        try:
            options = __salt__["config.option"]("random_org")
            if not api_key:
                api_key = options.get("api_key")
            if not api_version:
                api_version = options.get("api_version")
        except (NameError, KeyError, AttributeError):
            log.error("No Random.org api key found.")
            ret["message"] = "No Random.org api key or api version found."
            ret["res"] = False
            return ret
    for item in ["number", "decimalPlaces"]:
        if item not in kwargs:
            ret["res"] = False
            ret["message"] = "Required argument, {} is missing.".format(item)
            return ret
    if not isinstance(kwargs["number"], int) or not 1 &lt;= kwargs["number"] &lt;= 10000:
        ret["res"] = False
        ret["message"] = "Number of decimal fractions must be between 1 and 10000"
        return ret
    if not _numeric(kwargs["decimalPlaces"]) or not 1 &lt;= kwargs["decimalPlaces"] &lt;= 20:
        ret["res"] = False
        ret["message"] = "Number of decimal places must be between 1 and 20"
        return ret
    if "replacement" not in kwargs:
        replacement = True
    else:
        replacement = kwargs["replacement"]
    if isinstance(api_version, int):
        api_version = str(api_version)
    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version)
        .get("generateDecimalFractions")
        .get("method")
    )
    data = {}
    data["id"] = 1911220
    data["jsonrpc"] = "2.0"
    data["method"] = _function
    data["params"] = {
        "apiKey": api_key,
        "n": kwargs["number"],
        "decimalPlaces": kwargs["decimalPlaces"],
        "replacement": replacement,
    }
    result = _query(api_version=api_version, data=data)
    if result:
        if "random" in result:
            random_data = result.get("random").get("data")
            ret["data"] = random_data
        else:
            ret["res"] = False
            ret["message"] = result["message"]
    else:
        ret["res"] = False
        ret["message"] = result["message"]
    return ret
def generateGaussians(api_key=None, api_version=None, **kwargs):
    ret = {"res": True}
    if not api_key or not api_version:
        try:
            options = __salt__["config.option"]("random_org")
            if not api_key:
                api_key = options.get("api_key")
            if not api_version:
                api_version = options.get("api_version")
        except (NameError, KeyError, AttributeError):
            log.error("No Random.org api key found.")
            ret["message"] = "No Random.org api key or api version found."
            ret["res"] = False
            return ret
    for item in ["number", "mean", "standardDeviation", "significantDigits"]:
        if item not in kwargs:
            ret["res"] = False
            ret["message"] = "Required argument, {} is missing.".format(item)
            return ret
    if not _numeric(kwargs["number"]) or not 1 &lt;= kwargs["number"] &lt;= 10000:
        ret["res"] = False
        ret["message"] = "Number of decimal fractions must be between 1 and 10000"
        return ret
    if not _numeric(kwargs["mean"]) or not -1000000 &lt;= kwargs["mean"] &lt;= 1000000:
        ret["res"] = False
        ret["message"] = "The distribution's mean must be between -1000000 and 1000000"
        return ret
    if (
        not _numeric(kwargs["standardDeviation"])
        or not -1000000 &lt;= kwargs["standardDeviation"] &lt;= 1000000
    ):
        ret["res"] = False
        ret[
            "message"
        ] = "The distribution's standard deviation must be between -1000000 and 1000000"
        return ret
    if (
        not _numeric(kwargs["significantDigits"])
        or not 2 &lt;= kwargs["significantDigits"] &lt;= 20
    ):
        ret["res"] = False
        ret["message"] = "The number of significant digits must be between 2 and 20"
        return ret
    if isinstance(api_version, int):
        api_version = str(api_version)
    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version).get("generateGaussians").get("method")
    )
    data = {}
    data["id"] = 1911220
    data["jsonrpc"] = "2.0"
    data["method"] = _function
    data["params"] = {
        "apiKey": api_key,
        "n": kwargs["number"],
        "mean": kwargs["mean"],
        "standardDeviation": kwargs["standardDeviation"],
        "significantDigits": kwargs["significantDigits"],
    }
    result = _query(api_version=api_version, data=data)
    if result:
        if "random" in result:
            random_data = result.get("random").get("data")
            ret["data"] = random_data
        else:
            ret["res"] = False
            ret["message"] = result["message"]
    else:
        ret["res"] = False
        ret["message"] = result["message"]
    return ret
def generateBlobs(api_key=None, api_version=None, **kwargs):
    ret = {"res": True}
    if not api_key or not api_version:
        try:
            options = __salt__["config.option"]("random_org")
            if not api_key:
                api_key = options.get("api_key")
            if not api_version:
                api_version = options.get("api_version")
        except (NameError, KeyError, AttributeError):
            log.error("No Random.org api key found.")
            ret["message"] = "No Random.org api key or api version found."
            ret["res"] = False
            return ret
    for item in ["number", "size"]:
        if item not in kwargs:
            ret["res"] = False
            ret["message"] = "Required argument, {} is missing.".format(item)
            return ret
    if not _numeric(kwargs["number"]) or not 1 &lt;= kwargs["number"] &lt;= 100:
        ret["res"] = False
        ret["message"] = "Number of blobs must be between 1 and 100"
        return ret
    if (
        not _numeric(kwargs["size"])
        or not 1 &lt;= kwargs["size"] &lt;= 1048576
        or kwargs["size"] % 8 != 0
    ):
        ret["res"] = False
        ret["message"] = "Number of blobs must be between 1 and 100"
        return ret
    if "format" in kwargs:
        _format = kwargs["format"]
        if _format not in ["base64", "hex"]:
            ret["res"] = False
            ret["message"] = "Format must be either base64 or hex."
            return ret
    else:
        _format = "base64"
    if isinstance(api_version, int):
        api_version = str(api_version)
    _function = RANDOM_ORG_FUNCTIONS.get(api_version).get("generateBlobs").get("method")
    data = {}
    data["id"] = 1911220
    data["jsonrpc"] = "2.0"
    data["method"] = _function
    data["params"] = {
        "apiKey": api_key,
        "n": kwargs["number"],
        "size": kwargs["size"],
        "format": _format,
    }
    result = _query(api_version=api_version, data=data)
    if result:
        if "random" in result:
            random_data = result.get("random").get("data")
            ret["data"] = random_data
        else:
            ret["res"] = False
            ret["message"] = result["message"]
    else:
        ret["res"] = False
        ret["message"] = result["message"]
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>auth_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from __future__ import absolute_import, division, print_function
from salt.ext.tornado.auth import OpenIdMixin, OAuthMixin, OAuth2Mixin, TwitterMixin, AuthError, GoogleOAuth2Mixin, FacebookGraphMixin
from salt.ext.tornado.concurrent import Future
from salt.ext.tornado.escape import json_decode
from salt.ext.tornado import gen
from salt.ext.tornado.httputil import url_concat
from salt.ext.tornado.log import gen_log
from salt.ext.tornado.testing import AsyncHTTPTestCase, ExpectLog
from salt.ext.tornado.web import RequestHandler, Application, asynchronous, HTTPError
class OpenIdClientLoginHandler(RequestHandler, OpenIdMixin):
    def initialize(self, test):
        self._OPENID_ENDPOINT = test.get_url('/openid/server/authenticate')
    @asynchronous
    def get(self):
        if self.get_argument('openid.mode', None):
            self.get_authenticated_user(
                self.on_user, http_client=self.settings['http_client'])
            return
        res = self.authenticate_redirect()
        assert isinstance(res, Future)
        assert res.done()
    def on_user(self, user):
        if user is None:
            raise Exception("user is None")
        self.finish(user)
class OpenIdServerAuthenticateHandler(RequestHandler):
    def post(self):
        if self.get_argument('openid.mode') != 'check_authentication':
            raise Exception("incorrect openid.mode %r")
        self.write('is_valid:true')
class OAuth1ClientLoginHandler(RequestHandler, OAuthMixin):
    def initialize(self, test, version):
        self._OAUTH_VERSION = version
        self._OAUTH_REQUEST_TOKEN_URL = test.get_url('/oauth1/server/request_token')
        self._OAUTH_AUTHORIZE_URL = test.get_url('/oauth1/server/authorize')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/oauth1/server/access_token')
    def _oauth_consumer_token(self):
        return dict(key='asdf', secret='qwer')
    @asynchronous
    def get(self):
        if self.get_argument('oauth_token', None):
            self.get_authenticated_user(
                self.on_user, http_client=self.settings['http_client'])
            return
        res = self.authorize_redirect(http_client=self.settings['http_client'])
        assert isinstance(res, Future)
    def on_user(self, user):
        if user is None:
            raise Exception("user is None")
        self.finish(user)
    def _oauth_get_user(self, access_token, callback):
        if self.get_argument('fail_in_get_user', None):
            raise Exception("failing in get_user")
        if access_token != dict(key='uiop', secret='5678'):
            raise Exception("incorrect access token %r" % access_token)
        callback(dict(email='foo@example.com'))
class OAuth1ClientLoginCoroutineHandler(OAuth1ClientLoginHandler):
    @gen.coroutine
    def get(self):
        if self.get_argument('oauth_token', None):
            try:
                yield self.get_authenticated_user()
            except Exception as e:
                self.set_status(503)
                self.write("got exception: %s" % e)
        else:
            yield self.authorize_redirect()
class OAuth1ClientRequestParametersHandler(RequestHandler, OAuthMixin):
    def initialize(self, version):
        self._OAUTH_VERSION = version
    def _oauth_consumer_token(self):
        return dict(key='asdf', secret='qwer')
    def get(self):
        params = self._oauth_request_parameters(
            'http://www.example.com/api/asdf',
            dict(key='uiop', secret='5678'),
            parameters=dict(foo='bar'))
        self.write(params)
class OAuth1ServerRequestTokenHandler(RequestHandler):
    def get(self):
        self.write('oauth_token=zxcv&amp;oauth_token_secret=1234')
class OAuth1ServerAccessTokenHandler(RequestHandler):
    def get(self):
        self.write('oauth_token=uiop&amp;oauth_token_secret=5678')
class OAuth2ClientLoginHandler(RequestHandler, OAuth2Mixin):
    def initialize(self, test):
        self._OAUTH_AUTHORIZE_URL = test.get_url('/oauth2/server/authorize')
    def get(self):
        res = self.authorize_redirect()
        assert isinstance(res, Future)
        assert res.done()
class FacebookClientLoginHandler(RequestHandler, FacebookGraphMixin):
    def initialize(self, test):
        self._OAUTH_AUTHORIZE_URL = test.get_url('/facebook/server/authorize')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/facebook/server/access_token')
        self._FACEBOOK_BASE_URL = test.get_url('/facebook/server')
    @gen.coroutine
    def get(self):
        if self.get_argument("code", None):
            user = yield self.get_authenticated_user(
                redirect_uri=self.request.full_url(),
                client_id=self.settings["facebook_api_key"],
                client_secret=self.settings["facebook_secret"],
                code=self.get_argument("code"))
            self.write(user)
        else:
            yield self.authorize_redirect(
                redirect_uri=self.request.full_url(),
                client_id=self.settings["facebook_api_key"],
                extra_params={"scope": "read_stream,offline_access"})
class FacebookServerAccessTokenHandler(RequestHandler):
    def get(self):
        self.write(dict(access_token="asdf", expires_in=3600))
class FacebookServerMeHandler(RequestHandler):
    def get(self):
        self.write('{}')
<a name="0"></a>
class TwitterClientHandler(RequestHandler, TwitterMixin):
    def initialize(self, test):
        self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>._OAUTH_REQUEST_TOKEN_URL = test.get_url('/oauth1/server/request_token')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/twitter/server/access_token')
        self._OAUTH_AUTHORIZE_URL = test.get_url('/oauth1/server/authorize')
        self._TWITTER_BASE_URL = test.get_url(</b></font>'/twitter/api')
    def get_auth_http_client(self):
        return self.settings['http_client']
class TwitterClientLoginHandler(TwitterClientHandler):
    @asynchronous
    def get(self):
        if self.get_argument("oauth_token", None):
            self.get_authenticated_user(self.on_user)
            return
        self.authorize_redirect()
    def on_user(self, user):
        if user is None:
            raise Exception("user is None")
        self.finish(user)
class TwitterClientLoginGenEngineHandler(TwitterClientHandler):
    @asynchronous
    @gen.engine
    def get(self):
        if self.get_argument("oauth_token", None):
            user = yield self.get_authenticated_user()
            self.finish(user)
        else:
            self.authorize_redirect()
class TwitterClientLoginGenCoroutineHandler(TwitterClientHandler):
    @gen.coroutine
    def get(self):
        if self.get_argument("oauth_token", None):
            user = yield self.get_authenticated_user()
            self.finish(user)
        else:
            yield self.authorize_redirect()
class TwitterClientShowUserHandler(TwitterClientHandler):
    @asynchronous
    @gen.engine
    def get(self):
        response = yield gen.Task(self.twitter_request,
                                  '/users/show/%s' % self.get_argument('name'),
                                  access_token=dict(key='hjkl', secret='vbnm'))
        if response is None:
            self.set_status(500)
            self.finish('error from twitter request')
        else:
            self.finish(response)
class TwitterClientShowUserFutureHandler(TwitterClientHandler):
    @asynchronous
    @gen.engine
    def get(self):
        try:
            response = yield self.twitter_request(
                '/users/show/%s' % self.get_argument('name'),
                access_token=dict(key='hjkl', secret='vbnm'))
        except AuthError as e:
            self.set_status(500)
            self.finish(str(e))
            return
        assert response is not None
        self.finish(response)
class TwitterServerAccessTokenHandler(RequestHandler):
    def get(self):
        self.write('oauth_token=hjkl&amp;oauth_token_secret=vbnm&amp;screen_name=foo')
class TwitterServerShowUserHandler(RequestHandler):
    def get(self, screen_name):
        if screen_name == 'error':
            raise HTTPError(500)
        assert 'oauth_nonce' in self.request.arguments
        assert 'oauth_timestamp' in self.request.arguments
        assert 'oauth_signature' in self.request.arguments
        assert self.get_argument('oauth_consumer_key') == 'test_twitter_consumer_key'
        assert self.get_argument('oauth_signature_method') == 'HMAC-SHA1'
        assert self.get_argument('oauth_version') == '1.0'
        assert self.get_argument('oauth_token') == 'hjkl'
        self.write(dict(screen_name=screen_name, name=screen_name.capitalize()))
class TwitterServerVerifyCredentialsHandler(RequestHandler):
    def get(self):
        assert 'oauth_nonce' in self.request.arguments
        assert 'oauth_timestamp' in self.request.arguments
        assert 'oauth_signature' in self.request.arguments
        assert self.get_argument('oauth_consumer_key') == 'test_twitter_consumer_key'
        assert self.get_argument('oauth_signature_method') == 'HMAC-SHA1'
        assert self.get_argument('oauth_version') == '1.0'
        assert self.get_argument('oauth_token') == 'hjkl'
        self.write(dict(screen_name='foo', name='Foo'))
class AuthTest(AsyncHTTPTestCase):
    def get_app(self):
        return Application(
            [
                ('/openid/client/login', OpenIdClientLoginHandler, dict(test=self)),
                ('/oauth10/client/login', OAuth1ClientLoginHandler,
                 dict(test=self, version='1.0')),
                ('/oauth10/client/request_params',
                 OAuth1ClientRequestParametersHandler,
                 dict(version='1.0')),
                ('/oauth10a/client/login', OAuth1ClientLoginHandler,
                 dict(test=self, version='1.0a')),
                ('/oauth10a/client/login_coroutine',
                 OAuth1ClientLoginCoroutineHandler,
                 dict(test=self, version='1.0a')),
                ('/oauth10a/client/request_params',
                 OAuth1ClientRequestParametersHandler,
                 dict(version='1.0a')),
                ('/oauth2/client/login', OAuth2ClientLoginHandler, dict(test=self)),
                ('/facebook/client/login', FacebookClientLoginHandler, dict(test=self)),
                ('/twitter/client/login', TwitterClientLoginHandler, dict(test=self)),
                ('/twitter/client/login_gen_engine', TwitterClientLoginGenEngineHandler, dict(test=self)),
                ('/twitter/client/login_gen_coroutine', TwitterClientLoginGenCoroutineHandler, dict(test=self)),
                ('/twitter/client/show_user', TwitterClientShowUserHandler, dict(test=self)),
                ('/twitter/client/show_user_future', TwitterClientShowUserFutureHandler, dict(test=self)),
                ('/openid/server/authenticate', OpenIdServerAuthenticateHandler),
                ('/oauth1/server/request_token', OAuth1ServerRequestTokenHandler),
                ('/oauth1/server/access_token', OAuth1ServerAccessTokenHandler),
                ('/facebook/server/access_token', FacebookServerAccessTokenHandler),
                ('/facebook/server/me', FacebookServerMeHandler),
                ('/twitter/server/access_token', TwitterServerAccessTokenHandler),
                (r'/twitter/api/users/show/(.*)\.json', TwitterServerShowUserHandler),
                (r'/twitter/api/account/verify_credentials\.json', TwitterServerVerifyCredentialsHandler),
            ],
            http_client=self.http_client,
            twitter_consumer_key='test_twitter_consumer_key',
            twitter_consumer_secret='test_twitter_consumer_secret',
            facebook_api_key='test_facebook_api_key',
            facebook_secret='test_facebook_secret')
    def test_openid_redirect(self):
        response = self.fetch('/openid/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(
            '/openid/server/authenticate?' in response.headers['Location'])
    def test_openid_get_user(self):
        response = self.fetch('/openid/client/login?openid.mode=blah&amp;openid.ns.ax=http://openid.net/srv/ax/1.0&amp;openid.ax.type.email=http://axschema.org/contact/email&amp;openid.ax.value.email=foo@example.com')
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed["email"], "foo@example.com")
    def test_oauth10_redirect(self):
        response = self.fetch('/oauth10/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(response.headers['Location'].endswith(
            '/oauth1/server/authorize?oauth_token=zxcv'))
        self.assertTrue(
            '_oauth_request_token="enhjdg==|MTIzNA=="' in response.headers['Set-Cookie'],
            response.headers['Set-Cookie'])
    def test_oauth10_get_user(self):
        response = self.fetch(
            '/oauth10/client/login?oauth_token=zxcv',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['email'], 'foo@example.com')
        self.assertEqual(parsed['access_token'], dict(key='uiop', secret='5678'))
    def test_oauth10_request_parameters(self):
        response = self.fetch('/oauth10/client/request_params')
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['oauth_consumer_key'], 'asdf')
        self.assertEqual(parsed['oauth_token'], 'uiop')
        self.assertTrue('oauth_nonce' in parsed)
        self.assertTrue('oauth_signature' in parsed)
    def test_oauth10a_redirect(self):
        response = self.fetch('/oauth10a/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(response.headers['Location'].endswith(
            '/oauth1/server/authorize?oauth_token=zxcv'))
        self.assertTrue(
            '_oauth_request_token="enhjdg==|MTIzNA=="' in response.headers['Set-Cookie'],
            response.headers['Set-Cookie'])
    def test_oauth10a_get_user(self):
        response = self.fetch(
            '/oauth10a/client/login?oauth_token=zxcv',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['email'], 'foo@example.com')
        self.assertEqual(parsed['access_token'], dict(key='uiop', secret='5678'))
    def test_oauth10a_request_parameters(self):
        response = self.fetch('/oauth10a/client/request_params')
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['oauth_consumer_key'], 'asdf')
        self.assertEqual(parsed['oauth_token'], 'uiop')
        self.assertTrue('oauth_nonce' in parsed)
        self.assertTrue('oauth_signature' in parsed)
    def test_oauth10a_get_user_coroutine_exception(self):
        response = self.fetch(
            '/oauth10a/client/login_coroutine?oauth_token=zxcv&amp;fail_in_get_user=true',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        self.assertEqual(response.code, 503)
    def test_oauth2_redirect(self):
        response = self.fetch('/oauth2/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue('/oauth2/server/authorize?' in response.headers['Location'])
    def test_facebook_login(self):
        response = self.fetch('/facebook/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue('/facebook/server/authorize?' in response.headers['Location'])
        response = self.fetch('/facebook/client/login?code=1234', follow_redirects=False)
        self.assertEqual(response.code, 200)
        user = json_decode(response.body)
        self.assertEqual(user['access_token'], 'asdf')
        self.assertEqual(user['session_expires'], '3600')
    def base_twitter_redirect(self, url):
        response = self.fetch(url, follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(response.headers['Location'].endswith(
            '/oauth1/server/authorize?oauth_token=zxcv'))
        self.assertTrue(
            '_oauth_request_token="enhjdg==|MTIzNA=="' in response.headers['Set-Cookie'],
            response.headers['Set-Cookie'])
    def test_twitter_redirect(self):
        self.base_twitter_redirect('/twitter/client/login')
    def test_twitter_redirect_gen_engine(self):
        self.base_twitter_redirect('/twitter/client/login_gen_engine')
    def test_twitter_redirect_gen_coroutine(self):
        self.base_twitter_redirect('/twitter/client/login_gen_coroutine')
    def test_twitter_get_user(self):
        response = self.fetch(
            '/twitter/client/login?oauth_token=zxcv',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed,
                         {u'access_token': {u'key': u'hjkl',
                                            u'screen_name': u'foo',
                                            u'secret': u'vbnm'},
                          u'name': u'Foo',
                          u'screen_name': u'foo',
                          u'username': u'foo'})
    def test_twitter_show_user(self):
        response = self.fetch('/twitter/client/show_user?name=somebody')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         {'name': 'Somebody', 'screen_name': 'somebody'})
    def test_twitter_show_user_error(self):
        with ExpectLog(gen_log, 'Error response HTTP 500'):
            response = self.fetch('/twitter/client/show_user?name=error')
        self.assertEqual(response.code, 500)
        self.assertEqual(response.body, b'error from twitter request')
    def test_twitter_show_user_future(self):
        response = self.fetch('/twitter/client/show_user_future?name=somebody')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         {'name': 'Somebody', 'screen_name': 'somebody'})
    def test_twitter_show_user_future_error(self):
        response = self.fetch('/twitter/client/show_user_future?name=error')
        self.assertEqual(response.code, 500)
        self.assertIn(b'Error response HTTP 500', response.body)
class GoogleLoginHandler(RequestHandler, GoogleOAuth2Mixin):
    def initialize(self, test):
        self.test = test
        self._OAUTH_REDIRECT_URI = test.get_url('/client/login')
        self._OAUTH_AUTHORIZE_URL = test.get_url('/google/oauth2/authorize')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/google/oauth2/token')
    @gen.coroutine
    def get(self):
        code = self.get_argument('code', None)
        if code is not None:
            access = yield self.get_authenticated_user(self._OAUTH_REDIRECT_URI,
                                                       code)
            user = yield self.oauth2_request(
                self.test.get_url("/google/oauth2/userinfo"),
                access_token=access["access_token"])
            user["access_token"] = access["access_token"]
            self.write(user)
        else:
            yield self.authorize_redirect(
                redirect_uri=self._OAUTH_REDIRECT_URI,
                client_id=self.settings['google_oauth']['key'],
                client_secret=self.settings['google_oauth']['secret'],
                scope=['profile', 'email'],
                response_type='code',
                extra_params={'prompt': 'select_account'})
class GoogleOAuth2AuthorizeHandler(RequestHandler):
    def get(self):
        code = 'fake-authorization-code'
        self.redirect(url_concat(self.get_argument('redirect_uri'),
                                 dict(code=code)))
class GoogleOAuth2TokenHandler(RequestHandler):
    def post(self):
        assert self.get_argument('code') == 'fake-authorization-code'
        self.finish({
            'access_token': 'fake-access-token',
            'expires_in': 'never-expires'
        })
class GoogleOAuth2UserinfoHandler(RequestHandler):
    def get(self):
        assert self.get_argument('access_token') == 'fake-access-token'
        self.finish({
            'name': 'Foo',
            'email': 'foo@example.com'
        })
class GoogleOAuth2Test(AsyncHTTPTestCase):
    def get_app(self):
        return Application(
            [
                ('/client/login', GoogleLoginHandler, dict(test=self)),
                ('/google/oauth2/authorize', GoogleOAuth2AuthorizeHandler),
                ('/google/oauth2/token', GoogleOAuth2TokenHandler),
                ('/google/oauth2/userinfo', GoogleOAuth2UserinfoHandler),
            ],
            google_oauth={
                "key": 'fake_google_client_id',
                "secret": 'fake_google_client_secret'
            })
    def test_google_login(self):
        response = self.fetch('/client/login')
        self.assertDictEqual({
            u'name': u'Foo',
            u'email': u'foo@example.com',
            u'access_token': u'fake-access-token',
        }, json_decode(response.body))
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
