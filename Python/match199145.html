<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for random_org.py & auth_test.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for random_org.py & auth_test.py
      </h3>
      <h1 align="center">
        1.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>random_org.py (1.7148982%)<TH>auth_test.py (1.6309888%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match199145-0.html#0',2,'match199145-1.html#0',3)" NAME="0">(146-149)<TD><A HREF="javascript:ZweiFrames('match199145-0.html#0',2,'match199145-1.html#0',3)" NAME="0">(163-166)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>random_org.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module for retrieving random information from Random.org

.. versionadded:: 2015.5.0

:configuration: This module can be used by either passing an api key and version
    directly or by specifying both in a configuration profile in the salt
    master/minion config.

    For example:

    .. code-block:: yaml

        random_org:
          api_key: 7be1402d-5719-5bd3-a306-3def9f135da5
          api_version: 1
&quot;&quot;&quot;
import http.client
import logging
import urllib.request

import salt.utils.http
import salt.utils.json

log = logging.getLogger(__name__)
__virtualname__ = &quot;random_org&quot;

RANDOM_ORG_FUNCTIONS = {
    &quot;1&quot;: {
        &quot;getUsage&quot;: {&quot;method&quot;: &quot;getUsage&quot;},
        &quot;generateIntegers&quot;: {&quot;method&quot;: &quot;generateIntegers&quot;},
        &quot;generateStrings&quot;: {&quot;method&quot;: &quot;generateStrings&quot;},
        &quot;generateUUIDs&quot;: {&quot;method&quot;: &quot;generateUUIDs&quot;},
        &quot;generateDecimalFractions&quot;: {&quot;method&quot;: &quot;generateDecimalFractions&quot;},
        &quot;generateGaussians&quot;: {&quot;method&quot;: &quot;generateGaussians&quot;},
        &quot;generateBlobs&quot;: {&quot;method&quot;: &quot;generateBlobs&quot;},
    }
}


def __virtual__():
    &quot;&quot;&quot;
    Return virtual name of the module.

    :return: The virtual name of the module.
    &quot;&quot;&quot;
    return __virtualname__


def _numeric(n):
    &quot;&quot;&quot;
    Tell whether an argument is numeric
    &quot;&quot;&quot;
    return isinstance(n, (int, float))


def _query(api_version=None, data=None):
    &quot;&quot;&quot;
    Slack object method function to construct and execute on the API URL.

    :param api_key:     The Random.org api key.
    :param api_version: The version of Random.org api.
    :param data:        The data to be sent for POST method.
    :return:            The json response from the API call or False.
    &quot;&quot;&quot;

    if data is None:
        data = {}

    ret = {&quot;res&quot;: True}

    api_url = &quot;https://api.random.org/&quot;
    base_url = urllib.parse.urljoin(api_url, &quot;json-rpc/&quot; + str(api_version) + &quot;/invoke&quot;)

    data = salt.utils.json.dumps(data)

    result = salt.utils.http.query(
        base_url,
        method=&quot;POST&quot;,
        params={},
        data=data,
        decode=True,
        status=True,
        header_dict={},
        opts=__opts__,
    )

    if result.get(&quot;status&quot;, None) == http.client.OK:
        _result = result[&quot;dict&quot;]
        if _result.get(&quot;result&quot;):
            return _result.get(&quot;result&quot;)
        if _result.get(&quot;error&quot;):
            return _result.get(&quot;error&quot;)
        return False
    elif result.get(&quot;status&quot;, None) == http.client.NO_CONTENT:
        return False
    else:
        ret[&quot;message&quot;] = result.text if hasattr(result, &quot;text&quot;) else &quot;&quot;
        return ret


def getUsage(api_key=None, api_version=None):
    &quot;&quot;&quot;
    Show current usages statistics

    :param api_key: The Random.org api key.
    :param api_version: The Random.org api version.
    :return: The current usage statistics.

    CLI Example:

    .. code-block:: bash

        salt '*' random_org.getUsage

        salt '*' random_org.getUsage api_key=peWcBiMOS9HrZG15peWcBiMOS9HrZG15 api_version=1
    &quot;&quot;&quot;
    ret = {&quot;res&quot;: True}

    if not api_key or not api_version:
        try:
            options = __salt__[&quot;config.option&quot;](&quot;random_org&quot;)
            if not api_key:
                api_key = options.get(&quot;api_key&quot;)
            if not api_version:
                api_version = options.get(&quot;api_version&quot;)
        except (NameError, KeyError, AttributeError):
            log.error(&quot;No Random.org api key found.&quot;)
            ret[&quot;message&quot;] = &quot;No Random.org api key or api version found.&quot;
            ret[&quot;res&quot;] = False
            return ret

    if isinstance(api_version, int):
        api_version = str(api_version)

    _function = RANDOM_ORG_FUNCTIONS.get(api_version).get(&quot;getUsage&quot;).get(&quot;method&quot;)
    data = {}
    data[&quot;id&quot;] = 1911220
    data[&quot;jsonrpc&quot;] = &quot;2.0&quot;
    data[&quot;method&quot;] = _function
    data[&quot;params&quot;] = {&quot;apiKey&quot;: api_key}

<A NAME="0"></A>    result = _query(api_version=api_version, data=data)

    if result:
        ret<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match199145-1.html#0',3,'match199145-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;bitsLeft&quot;] = result.get(&quot;bitsLeft&quot;)
        ret[&quot;requestsLeft&quot;] = result.get(&quot;requestsLeft&quot;)
        ret[&quot;totalBits&quot;] = result.get(&quot;totalBits&quot;)
        ret[&quot;totalRequests&quot;] = result.get(</B></FONT>&quot;totalRequests&quot;)
    else:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = result[&quot;message&quot;]
    return ret


def generateIntegers(api_key=None, api_version=None, **kwargs):
    &quot;&quot;&quot;
    Generate random integers

    :param api_key: The Random.org api key.
    :param api_version: The Random.org api version.
    :param number: The number of integers to generate
    :param minimum: The lower boundary for the range from which the
                    random numbers will be picked. Must be within
                    the [-1e9,1e9] range.
    :param maximum: The upper boundary for the range from which the
                    random numbers will be picked. Must be within
                    the [-1e9,1e9] range.
    :param replacement: Specifies whether the random numbers should
                        be picked with replacement. The default (true)
                        will cause the numbers to be picked with replacement,
                        i.e., the resulting numbers may contain duplicate
                        values (like a series of dice rolls). If you want the
                        numbers picked to be unique (like raffle tickets drawn
                        from a container), set this value to false.
    :param base: Specifies the base that will be used to display the numbers.
                 Values allowed are 2, 8, 10 and 16. This affects the JSON
                 types and formatting of the resulting data as discussed below.
    :return: A list of integers.

    CLI Example:

    .. code-block:: bash

        salt '*' random_org.generateIntegers number=5 minimum=1 maximum=6

        salt '*' random_org.generateIntegers number=5 minimum=2 maximum=255 base=2

    &quot;&quot;&quot;
    ret = {&quot;res&quot;: True}

    if not api_key or not api_version:
        try:
            options = __salt__[&quot;config.option&quot;](&quot;random_org&quot;)
            if not api_key:
                api_key = options.get(&quot;api_key&quot;)
            if not api_version:
                api_version = options.get(&quot;api_version&quot;)
        except (NameError, KeyError, AttributeError):
            log.error(&quot;No Random.org api key found.&quot;)
            ret[&quot;message&quot;] = &quot;No Random.org api key or api version found.&quot;
            ret[&quot;res&quot;] = False
            return ret

    for item in [&quot;number&quot;, &quot;minimum&quot;, &quot;maximum&quot;]:
        if item not in kwargs:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Rquired argument, {} is missing.&quot;.format(item)
            return ret

    if not _numeric(kwargs[&quot;number&quot;]) or not 1 &lt;= kwargs[&quot;number&quot;] &lt;= 10000:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of integers must be between 1 and 10000&quot;
        return ret

    if (
        not _numeric(kwargs[&quot;minimum&quot;])
        or not -1000000000 &lt;= kwargs[&quot;minimum&quot;] &lt;= 1000000000
    ):
        ret[&quot;res&quot;] = False
        ret[
            &quot;message&quot;
        ] = &quot;Minimum argument must be between -1,000,000,000 and 1,000,000,000&quot;
        return ret

    if (
        not _numeric(kwargs[&quot;maximum&quot;])
        or not -1000000000 &lt;= kwargs[&quot;maximum&quot;] &lt;= 1000000000
    ):
        ret[&quot;res&quot;] = False
        ret[
            &quot;message&quot;
        ] = &quot;Maximum argument must be between -1,000,000,000 and 1,000,000,000&quot;
        return ret

    if &quot;base&quot; in kwargs:
        base = kwargs[&quot;base&quot;]
        if base not in [2, 8, 10, 16]:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Base must be either 2, 8, 10 or 16.&quot;
            return ret
    else:
        base = 10

    if &quot;replacement&quot; not in kwargs:
        replacement = True
    else:
        replacement = kwargs[&quot;replacement&quot;]

    if isinstance(api_version, int):
        api_version = str(api_version)

    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version).get(&quot;generateIntegers&quot;).get(&quot;method&quot;)
    )
    data = {}
    data[&quot;id&quot;] = 1911220
    data[&quot;jsonrpc&quot;] = &quot;2.0&quot;
    data[&quot;method&quot;] = _function
    data[&quot;params&quot;] = {
        &quot;apiKey&quot;: api_key,
        &quot;n&quot;: kwargs[&quot;number&quot;],
        &quot;min&quot;: kwargs[&quot;minimum&quot;],
        &quot;max&quot;: kwargs[&quot;maximum&quot;],
        &quot;replacement&quot;: replacement,
        &quot;base&quot;: base,
    }

    result = _query(api_version=api_version, data=data)
    log.debug(&quot;result %s&quot;, result)
    if result:
        if &quot;random&quot; in result:
            random_data = result.get(&quot;random&quot;).get(&quot;data&quot;)
            ret[&quot;data&quot;] = random_data
        else:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = result[&quot;message&quot;]
    else:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = result[&quot;message&quot;]
    return ret


def generateStrings(api_key=None, api_version=None, **kwargs):
    &quot;&quot;&quot;
    Generate random strings.

    :param api_key: The Random.org api key.
    :param api_version: The Random.org api version.
    :param number: The number of strings to generate.
    :param length: The length of each string. Must be
                   within the [1,20] range. All strings
                   will be of the same length
    :param characters: A string that contains the set of
                       characters that are allowed to occur
                       in the random strings. The maximum number
                       of characters is 80.
    :param replacement: Specifies whether the random strings should be picked
                        with replacement. The default (true) will cause the
                        strings to be picked with replacement, i.e., the
                        resulting list of strings may contain duplicates (like
                        a series of dice rolls). If you want the strings to be
                        unique (like raffle tickets drawn from a container), set
                        this value to false.
    :return: A list of strings.

    CLI Example:

    .. code-block:: bash

        salt '*' random_org.generateStrings number=5 length=8 characters='abcdefghijklmnopqrstuvwxyz'

        salt '*' random_org.generateStrings number=10 length=16 characters'abcdefghijklmnopqrstuvwxyz'

    &quot;&quot;&quot;
    ret = {&quot;res&quot;: True}

    if not api_key or not api_version:
        try:
            options = __salt__[&quot;config.option&quot;](&quot;random_org&quot;)
            if not api_key:
                api_key = options.get(&quot;api_key&quot;)
            if not api_version:
                api_version = options.get(&quot;api_version&quot;)
        except (NameError, KeyError, AttributeError):
            log.error(&quot;No Random.org api key found.&quot;)
            ret[&quot;message&quot;] = &quot;No Random.org api key or api version found.&quot;
            ret[&quot;res&quot;] = False
            return ret

    for item in [&quot;number&quot;, &quot;length&quot;, &quot;characters&quot;]:
        if item not in kwargs:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Required argument, {} is missing.&quot;.format(item)
            return ret

    if not _numeric(kwargs[&quot;number&quot;]) or not 1 &lt;= kwargs[&quot;number&quot;] &lt;= 10000:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of strings must be between 1 and 10000&quot;
        return ret

    if not _numeric(kwargs[&quot;length&quot;]) or not 1 &lt;= kwargs[&quot;length&quot;] &lt;= 20:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Length of strings must be between 1 and 20&quot;
        return ret

    if len(kwargs[&quot;characters&quot;]) &gt;= 80:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Length of characters must be less than 80.&quot;
        return ret

    if isinstance(api_version, int):
        api_version = str(api_version)

    if &quot;replacement&quot; not in kwargs:
        replacement = True
    else:
        replacement = kwargs[&quot;replacement&quot;]

    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version).get(&quot;generateStrings&quot;).get(&quot;method&quot;)
    )
    data = {}
    data[&quot;id&quot;] = 1911220
    data[&quot;jsonrpc&quot;] = &quot;2.0&quot;
    data[&quot;method&quot;] = _function
    data[&quot;params&quot;] = {
        &quot;apiKey&quot;: api_key,
        &quot;n&quot;: kwargs[&quot;number&quot;],
        &quot;length&quot;: kwargs[&quot;length&quot;],
        &quot;characters&quot;: kwargs[&quot;characters&quot;],
        &quot;replacement&quot;: replacement,
    }

    result = _query(api_version=api_version, data=data)
    if result:
        if &quot;random&quot; in result:
            random_data = result.get(&quot;random&quot;).get(&quot;data&quot;)
            ret[&quot;data&quot;] = random_data
        else:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = result[&quot;message&quot;]
    else:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = result[&quot;message&quot;]
    return ret


def generateUUIDs(api_key=None, api_version=None, **kwargs):
    &quot;&quot;&quot;
    Generate a list of random UUIDs

    :param api_key: The Random.org api key.
    :param api_version: The Random.org api version.
    :param number: How many random UUIDs you need.
                   Must be within the [1,1e3] range.
    :return: A list of UUIDs

    CLI Example:

    .. code-block:: bash

        salt '*' random_org.generateUUIDs number=5

    &quot;&quot;&quot;
    ret = {&quot;res&quot;: True}

    if not api_key or not api_version:
        try:
            options = __salt__[&quot;config.option&quot;](&quot;random_org&quot;)
            if not api_key:
                api_key = options.get(&quot;api_key&quot;)
            if not api_version:
                api_version = options.get(&quot;api_version&quot;)
        except (NameError, KeyError, AttributeError):
            log.error(&quot;No Random.org api key found.&quot;)
            ret[&quot;message&quot;] = &quot;No Random.org api key or api version found.&quot;
            ret[&quot;res&quot;] = False
            return ret

    for item in [&quot;number&quot;]:
        if item not in kwargs:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Required argument, {} is missing.&quot;.format(item)
            return ret

    if isinstance(api_version, int):
        api_version = str(api_version)

    if not _numeric(kwargs[&quot;number&quot;]) or not 1 &lt;= kwargs[&quot;number&quot;] &lt;= 1000:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of UUIDs must be between 1 and 1000&quot;
        return ret

    _function = RANDOM_ORG_FUNCTIONS.get(api_version).get(&quot;generateUUIDs&quot;).get(&quot;method&quot;)
    data = {}
    data[&quot;id&quot;] = 1911220
    data[&quot;jsonrpc&quot;] = &quot;2.0&quot;
    data[&quot;method&quot;] = _function
    data[&quot;params&quot;] = {
        &quot;apiKey&quot;: api_key,
        &quot;n&quot;: kwargs[&quot;number&quot;],
    }

    result = _query(api_version=api_version, data=data)
    if result:
        if &quot;random&quot; in result:
            random_data = result.get(&quot;random&quot;).get(&quot;data&quot;)
            ret[&quot;data&quot;] = random_data
        else:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = result[&quot;message&quot;]
    else:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = result[&quot;message&quot;]
    return ret


def generateDecimalFractions(api_key=None, api_version=None, **kwargs):
    &quot;&quot;&quot;
    Generates true random decimal fractions

    :param api_key: The Random.org api key.
    :param api_version: The Random.org api version.
    :param number: How many random decimal fractions
                   you need. Must be within the [1,1e4] range.
    :param decimalPlaces: The number of decimal places
                          to use. Must be within the [1,20] range.
    :param replacement: Specifies whether the random numbers should
                        be picked with replacement. The default (true)
                        will cause the numbers to be picked with replacement,
                        i.e., the resulting numbers may contain duplicate
                        values (like a series of dice rolls). If you want the
                        numbers picked to be unique (like raffle tickets drawn
                        from a container), set this value to false.
    :return: A list of decimal fraction

    CLI Example:

    .. code-block:: bash

        salt '*' random_org.generateDecimalFractions number=10 decimalPlaces=4

        salt '*' random_org.generateDecimalFractions number=10 decimalPlaces=4 replacement=True

    &quot;&quot;&quot;
    ret = {&quot;res&quot;: True}

    if not api_key or not api_version:
        try:
            options = __salt__[&quot;config.option&quot;](&quot;random_org&quot;)
            if not api_key:
                api_key = options.get(&quot;api_key&quot;)
            if not api_version:
                api_version = options.get(&quot;api_version&quot;)
        except (NameError, KeyError, AttributeError):
            log.error(&quot;No Random.org api key found.&quot;)
            ret[&quot;message&quot;] = &quot;No Random.org api key or api version found.&quot;
            ret[&quot;res&quot;] = False
            return ret

    for item in [&quot;number&quot;, &quot;decimalPlaces&quot;]:
        if item not in kwargs:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Required argument, {} is missing.&quot;.format(item)
            return ret

    if not isinstance(kwargs[&quot;number&quot;], int) or not 1 &lt;= kwargs[&quot;number&quot;] &lt;= 10000:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of decimal fractions must be between 1 and 10000&quot;
        return ret

    if not _numeric(kwargs[&quot;decimalPlaces&quot;]) or not 1 &lt;= kwargs[&quot;decimalPlaces&quot;] &lt;= 20:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of decimal places must be between 1 and 20&quot;
        return ret

    if &quot;replacement&quot; not in kwargs:
        replacement = True
    else:
        replacement = kwargs[&quot;replacement&quot;]

    if isinstance(api_version, int):
        api_version = str(api_version)

    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version)
        .get(&quot;generateDecimalFractions&quot;)
        .get(&quot;method&quot;)
    )
    data = {}
    data[&quot;id&quot;] = 1911220
    data[&quot;jsonrpc&quot;] = &quot;2.0&quot;
    data[&quot;method&quot;] = _function
    data[&quot;params&quot;] = {
        &quot;apiKey&quot;: api_key,
        &quot;n&quot;: kwargs[&quot;number&quot;],
        &quot;decimalPlaces&quot;: kwargs[&quot;decimalPlaces&quot;],
        &quot;replacement&quot;: replacement,
    }

    result = _query(api_version=api_version, data=data)
    if result:
        if &quot;random&quot; in result:
            random_data = result.get(&quot;random&quot;).get(&quot;data&quot;)
            ret[&quot;data&quot;] = random_data
        else:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = result[&quot;message&quot;]
    else:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = result[&quot;message&quot;]
    return ret


def generateGaussians(api_key=None, api_version=None, **kwargs):
    &quot;&quot;&quot;
    This method generates true random numbers from a
    Gaussian distribution (also known as a normal distribution).

    :param api_key: The Random.org api key.
    :param api_version: The Random.org api version.
    :param number: How many random numbers you need.
                   Must be within the [1,1e4] range.
    :param mean: The distribution's mean. Must be
                 within the [-1e6,1e6] range.
    :param standardDeviation: The distribution's standard
                              deviation. Must be within
                              the [-1e6,1e6] range.
    :param significantDigits: The number of significant digits
                              to use. Must be within the [2,20] range.
    :return: The user list.

    CLI Example:

    .. code-block:: bash

        salt '*' random_org.generateGaussians number=10 mean=0.0 standardDeviation=1.0 significantDigits=8

    &quot;&quot;&quot;
    ret = {&quot;res&quot;: True}

    if not api_key or not api_version:
        try:
            options = __salt__[&quot;config.option&quot;](&quot;random_org&quot;)
            if not api_key:
                api_key = options.get(&quot;api_key&quot;)
            if not api_version:
                api_version = options.get(&quot;api_version&quot;)
        except (NameError, KeyError, AttributeError):
            log.error(&quot;No Random.org api key found.&quot;)
            ret[&quot;message&quot;] = &quot;No Random.org api key or api version found.&quot;
            ret[&quot;res&quot;] = False
            return ret

    for item in [&quot;number&quot;, &quot;mean&quot;, &quot;standardDeviation&quot;, &quot;significantDigits&quot;]:
        if item not in kwargs:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Required argument, {} is missing.&quot;.format(item)
            return ret

    if not _numeric(kwargs[&quot;number&quot;]) or not 1 &lt;= kwargs[&quot;number&quot;] &lt;= 10000:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of decimal fractions must be between 1 and 10000&quot;
        return ret

    if not _numeric(kwargs[&quot;mean&quot;]) or not -1000000 &lt;= kwargs[&quot;mean&quot;] &lt;= 1000000:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;The distribution's mean must be between -1000000 and 1000000&quot;
        return ret

    if (
        not _numeric(kwargs[&quot;standardDeviation&quot;])
        or not -1000000 &lt;= kwargs[&quot;standardDeviation&quot;] &lt;= 1000000
    ):
        ret[&quot;res&quot;] = False
        ret[
            &quot;message&quot;
        ] = &quot;The distribution's standard deviation must be between -1000000 and 1000000&quot;
        return ret

    if (
        not _numeric(kwargs[&quot;significantDigits&quot;])
        or not 2 &lt;= kwargs[&quot;significantDigits&quot;] &lt;= 20
    ):
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;The number of significant digits must be between 2 and 20&quot;
        return ret

    if isinstance(api_version, int):
        api_version = str(api_version)

    _function = (
        RANDOM_ORG_FUNCTIONS.get(api_version).get(&quot;generateGaussians&quot;).get(&quot;method&quot;)
    )
    data = {}
    data[&quot;id&quot;] = 1911220
    data[&quot;jsonrpc&quot;] = &quot;2.0&quot;
    data[&quot;method&quot;] = _function
    data[&quot;params&quot;] = {
        &quot;apiKey&quot;: api_key,
        &quot;n&quot;: kwargs[&quot;number&quot;],
        &quot;mean&quot;: kwargs[&quot;mean&quot;],
        &quot;standardDeviation&quot;: kwargs[&quot;standardDeviation&quot;],
        &quot;significantDigits&quot;: kwargs[&quot;significantDigits&quot;],
    }

    result = _query(api_version=api_version, data=data)
    if result:
        if &quot;random&quot; in result:
            random_data = result.get(&quot;random&quot;).get(&quot;data&quot;)
            ret[&quot;data&quot;] = random_data
        else:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = result[&quot;message&quot;]
    else:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = result[&quot;message&quot;]
    return ret


def generateBlobs(api_key=None, api_version=None, **kwargs):
    &quot;&quot;&quot;
    List all Slack users.

    :param api_key: The Random.org api key.
    :param api_version: The Random.org api version.
    :param format: Specifies the format in which the
                   blobs will be returned. Values
                   allowed are base64 and hex.
    :return: The user list.

    CLI Example:

    .. code-block:: bash

        salt '*' get_integers number=5 min=1 max=6

        salt '*' get_integers number=5 min=1 max=6
    &quot;&quot;&quot;
    ret = {&quot;res&quot;: True}

    if not api_key or not api_version:
        try:
            options = __salt__[&quot;config.option&quot;](&quot;random_org&quot;)
            if not api_key:
                api_key = options.get(&quot;api_key&quot;)
            if not api_version:
                api_version = options.get(&quot;api_version&quot;)
        except (NameError, KeyError, AttributeError):
            log.error(&quot;No Random.org api key found.&quot;)
            ret[&quot;message&quot;] = &quot;No Random.org api key or api version found.&quot;
            ret[&quot;res&quot;] = False
            return ret

    for item in [&quot;number&quot;, &quot;size&quot;]:
        if item not in kwargs:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Required argument, {} is missing.&quot;.format(item)
            return ret

    if not _numeric(kwargs[&quot;number&quot;]) or not 1 &lt;= kwargs[&quot;number&quot;] &lt;= 100:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of blobs must be between 1 and 100&quot;
        return ret

    # size should be between range and divisible by 8
    if (
        not _numeric(kwargs[&quot;size&quot;])
        or not 1 &lt;= kwargs[&quot;size&quot;] &lt;= 1048576
        or kwargs[&quot;size&quot;] % 8 != 0
    ):
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = &quot;Number of blobs must be between 1 and 100&quot;
        return ret

    if &quot;format&quot; in kwargs:
        _format = kwargs[&quot;format&quot;]
        if _format not in [&quot;base64&quot;, &quot;hex&quot;]:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = &quot;Format must be either base64 or hex.&quot;
            return ret
    else:
        _format = &quot;base64&quot;

    if isinstance(api_version, int):
        api_version = str(api_version)

    _function = RANDOM_ORG_FUNCTIONS.get(api_version).get(&quot;generateBlobs&quot;).get(&quot;method&quot;)
    data = {}
    data[&quot;id&quot;] = 1911220
    data[&quot;jsonrpc&quot;] = &quot;2.0&quot;
    data[&quot;method&quot;] = _function
    data[&quot;params&quot;] = {
        &quot;apiKey&quot;: api_key,
        &quot;n&quot;: kwargs[&quot;number&quot;],
        &quot;size&quot;: kwargs[&quot;size&quot;],
        &quot;format&quot;: _format,
    }

    result = _query(api_version=api_version, data=data)
    if result:
        if &quot;random&quot; in result:
            random_data = result.get(&quot;random&quot;).get(&quot;data&quot;)
            ret[&quot;data&quot;] = random_data
        else:
            ret[&quot;res&quot;] = False
            ret[&quot;message&quot;] = result[&quot;message&quot;]
    else:
        ret[&quot;res&quot;] = False
        ret[&quot;message&quot;] = result[&quot;message&quot;]
    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>auth_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# These tests do not currently do much to verify the correct implementation
# of the openid/oauth protocols, they just exercise the major code paths
# and ensure that it doesn't blow up (e.g. with unicode/bytes issues in
# python 3)
# pylint: skip-file


from __future__ import absolute_import, division, print_function
from salt.ext.tornado.auth import OpenIdMixin, OAuthMixin, OAuth2Mixin, TwitterMixin, AuthError, GoogleOAuth2Mixin, FacebookGraphMixin
from salt.ext.tornado.concurrent import Future
from salt.ext.tornado.escape import json_decode
from salt.ext.tornado import gen
from salt.ext.tornado.httputil import url_concat
from salt.ext.tornado.log import gen_log
from salt.ext.tornado.testing import AsyncHTTPTestCase, ExpectLog
from salt.ext.tornado.web import RequestHandler, Application, asynchronous, HTTPError


class OpenIdClientLoginHandler(RequestHandler, OpenIdMixin):
    def initialize(self, test):
        self._OPENID_ENDPOINT = test.get_url('/openid/server/authenticate')

    @asynchronous
    def get(self):
        if self.get_argument('openid.mode', None):
            self.get_authenticated_user(
                self.on_user, http_client=self.settings['http_client'])
            return
        res = self.authenticate_redirect()
        assert isinstance(res, Future)
        assert res.done()

    def on_user(self, user):
        if user is None:
            raise Exception(&quot;user is None&quot;)
        self.finish(user)


class OpenIdServerAuthenticateHandler(RequestHandler):
    def post(self):
        if self.get_argument('openid.mode') != 'check_authentication':
            raise Exception(&quot;incorrect openid.mode %r&quot;)
        self.write('is_valid:true')


class OAuth1ClientLoginHandler(RequestHandler, OAuthMixin):
    def initialize(self, test, version):
        self._OAUTH_VERSION = version
        self._OAUTH_REQUEST_TOKEN_URL = test.get_url('/oauth1/server/request_token')
        self._OAUTH_AUTHORIZE_URL = test.get_url('/oauth1/server/authorize')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/oauth1/server/access_token')

    def _oauth_consumer_token(self):
        return dict(key='asdf', secret='qwer')

    @asynchronous
    def get(self):
        if self.get_argument('oauth_token', None):
            self.get_authenticated_user(
                self.on_user, http_client=self.settings['http_client'])
            return
        res = self.authorize_redirect(http_client=self.settings['http_client'])
        assert isinstance(res, Future)

    def on_user(self, user):
        if user is None:
            raise Exception(&quot;user is None&quot;)
        self.finish(user)

    def _oauth_get_user(self, access_token, callback):
        if self.get_argument('fail_in_get_user', None):
            raise Exception(&quot;failing in get_user&quot;)
        if access_token != dict(key='uiop', secret='5678'):
            raise Exception(&quot;incorrect access token %r&quot; % access_token)
        callback(dict(email='foo@example.com'))


class OAuth1ClientLoginCoroutineHandler(OAuth1ClientLoginHandler):
    &quot;&quot;&quot;Replaces OAuth1ClientLoginCoroutineHandler's get() with a coroutine.&quot;&quot;&quot;
    @gen.coroutine
    def get(self):
        if self.get_argument('oauth_token', None):
            # Ensure that any exceptions are set on the returned Future,
            # not simply thrown into the surrounding StackContext.
            try:
                yield self.get_authenticated_user()
            except Exception as e:
                self.set_status(503)
                self.write(&quot;got exception: %s&quot; % e)
        else:
            yield self.authorize_redirect()


class OAuth1ClientRequestParametersHandler(RequestHandler, OAuthMixin):
    def initialize(self, version):
        self._OAUTH_VERSION = version

    def _oauth_consumer_token(self):
        return dict(key='asdf', secret='qwer')

    def get(self):
        params = self._oauth_request_parameters(
            'http://www.example.com/api/asdf',
            dict(key='uiop', secret='5678'),
            parameters=dict(foo='bar'))
        self.write(params)


class OAuth1ServerRequestTokenHandler(RequestHandler):
    def get(self):
        self.write('oauth_token=zxcv&amp;oauth_token_secret=1234')


class OAuth1ServerAccessTokenHandler(RequestHandler):
    def get(self):
        self.write('oauth_token=uiop&amp;oauth_token_secret=5678')


class OAuth2ClientLoginHandler(RequestHandler, OAuth2Mixin):
    def initialize(self, test):
        self._OAUTH_AUTHORIZE_URL = test.get_url('/oauth2/server/authorize')

    def get(self):
        res = self.authorize_redirect()
        assert isinstance(res, Future)
        assert res.done()


class FacebookClientLoginHandler(RequestHandler, FacebookGraphMixin):
    def initialize(self, test):
        self._OAUTH_AUTHORIZE_URL = test.get_url('/facebook/server/authorize')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/facebook/server/access_token')
        self._FACEBOOK_BASE_URL = test.get_url('/facebook/server')

    @gen.coroutine
    def get(self):
        if self.get_argument(&quot;code&quot;, None):
            user = yield self.get_authenticated_user(
                redirect_uri=self.request.full_url(),
                client_id=self.settings[&quot;facebook_api_key&quot;],
                client_secret=self.settings[&quot;facebook_secret&quot;],
                code=self.get_argument(&quot;code&quot;))
            self.write(user)
        else:
            yield self.authorize_redirect(
                redirect_uri=self.request.full_url(),
                client_id=self.settings[&quot;facebook_api_key&quot;],
                extra_params={&quot;scope&quot;: &quot;read_stream,offline_access&quot;})


class FacebookServerAccessTokenHandler(RequestHandler):
    def get(self):
        self.write(dict(access_token=&quot;asdf&quot;, expires_in=3600))


class FacebookServerMeHandler(RequestHandler):
    def get(self):
        self.write('{}')

<A NAME="0"></A>
class TwitterClientHandler(RequestHandler, TwitterMixin):
    def initialize(self, test):
        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match199145-0.html#0',2,'match199145-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>._OAUTH_REQUEST_TOKEN_URL = test.get_url('/oauth1/server/request_token')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/twitter/server/access_token')
        self._OAUTH_AUTHORIZE_URL = test.get_url('/oauth1/server/authorize')
        self._TWITTER_BASE_URL = test.get_url(</B></FONT>'/twitter/api')

    def get_auth_http_client(self):
        return self.settings['http_client']


class TwitterClientLoginHandler(TwitterClientHandler):
    @asynchronous
    def get(self):
        if self.get_argument(&quot;oauth_token&quot;, None):
            self.get_authenticated_user(self.on_user)
            return
        self.authorize_redirect()

    def on_user(self, user):
        if user is None:
            raise Exception(&quot;user is None&quot;)
        self.finish(user)


class TwitterClientLoginGenEngineHandler(TwitterClientHandler):
    @asynchronous
    @gen.engine
    def get(self):
        if self.get_argument(&quot;oauth_token&quot;, None):
            user = yield self.get_authenticated_user()
            self.finish(user)
        else:
            # Old style: with @gen.engine we can ignore the Future from
            # authorize_redirect.
            self.authorize_redirect()


class TwitterClientLoginGenCoroutineHandler(TwitterClientHandler):
    @gen.coroutine
    def get(self):
        if self.get_argument(&quot;oauth_token&quot;, None):
            user = yield self.get_authenticated_user()
            self.finish(user)
        else:
            # New style: with @gen.coroutine the result must be yielded
            # or else the request will be auto-finished too soon.
            yield self.authorize_redirect()


class TwitterClientShowUserHandler(TwitterClientHandler):
    @asynchronous
    @gen.engine
    def get(self):
        # TODO: would be nice to go through the login flow instead of
        # cheating with a hard-coded access token.
        response = yield gen.Task(self.twitter_request,
                                  '/users/show/%s' % self.get_argument('name'),
                                  access_token=dict(key='hjkl', secret='vbnm'))
        if response is None:
            self.set_status(500)
            self.finish('error from twitter request')
        else:
            self.finish(response)


class TwitterClientShowUserFutureHandler(TwitterClientHandler):
    @asynchronous
    @gen.engine
    def get(self):
        try:
            response = yield self.twitter_request(
                '/users/show/%s' % self.get_argument('name'),
                access_token=dict(key='hjkl', secret='vbnm'))
        except AuthError as e:
            self.set_status(500)
            self.finish(str(e))
            return
        assert response is not None
        self.finish(response)


class TwitterServerAccessTokenHandler(RequestHandler):
    def get(self):
        self.write('oauth_token=hjkl&amp;oauth_token_secret=vbnm&amp;screen_name=foo')


class TwitterServerShowUserHandler(RequestHandler):
    def get(self, screen_name):
        if screen_name == 'error':
            raise HTTPError(500)
        assert 'oauth_nonce' in self.request.arguments
        assert 'oauth_timestamp' in self.request.arguments
        assert 'oauth_signature' in self.request.arguments
        assert self.get_argument('oauth_consumer_key') == 'test_twitter_consumer_key'
        assert self.get_argument('oauth_signature_method') == 'HMAC-SHA1'
        assert self.get_argument('oauth_version') == '1.0'
        assert self.get_argument('oauth_token') == 'hjkl'
        self.write(dict(screen_name=screen_name, name=screen_name.capitalize()))


class TwitterServerVerifyCredentialsHandler(RequestHandler):
    def get(self):
        assert 'oauth_nonce' in self.request.arguments
        assert 'oauth_timestamp' in self.request.arguments
        assert 'oauth_signature' in self.request.arguments
        assert self.get_argument('oauth_consumer_key') == 'test_twitter_consumer_key'
        assert self.get_argument('oauth_signature_method') == 'HMAC-SHA1'
        assert self.get_argument('oauth_version') == '1.0'
        assert self.get_argument('oauth_token') == 'hjkl'
        self.write(dict(screen_name='foo', name='Foo'))


class AuthTest(AsyncHTTPTestCase):
    def get_app(self):
        return Application(
            [
                # test endpoints
                ('/openid/client/login', OpenIdClientLoginHandler, dict(test=self)),
                ('/oauth10/client/login', OAuth1ClientLoginHandler,
                 dict(test=self, version='1.0')),
                ('/oauth10/client/request_params',
                 OAuth1ClientRequestParametersHandler,
                 dict(version='1.0')),
                ('/oauth10a/client/login', OAuth1ClientLoginHandler,
                 dict(test=self, version='1.0a')),
                ('/oauth10a/client/login_coroutine',
                 OAuth1ClientLoginCoroutineHandler,
                 dict(test=self, version='1.0a')),
                ('/oauth10a/client/request_params',
                 OAuth1ClientRequestParametersHandler,
                 dict(version='1.0a')),
                ('/oauth2/client/login', OAuth2ClientLoginHandler, dict(test=self)),

                ('/facebook/client/login', FacebookClientLoginHandler, dict(test=self)),

                ('/twitter/client/login', TwitterClientLoginHandler, dict(test=self)),
                ('/twitter/client/login_gen_engine', TwitterClientLoginGenEngineHandler, dict(test=self)),
                ('/twitter/client/login_gen_coroutine', TwitterClientLoginGenCoroutineHandler, dict(test=self)),
                ('/twitter/client/show_user', TwitterClientShowUserHandler, dict(test=self)),
                ('/twitter/client/show_user_future', TwitterClientShowUserFutureHandler, dict(test=self)),

                # simulated servers
                ('/openid/server/authenticate', OpenIdServerAuthenticateHandler),
                ('/oauth1/server/request_token', OAuth1ServerRequestTokenHandler),
                ('/oauth1/server/access_token', OAuth1ServerAccessTokenHandler),

                ('/facebook/server/access_token', FacebookServerAccessTokenHandler),
                ('/facebook/server/me', FacebookServerMeHandler),
                ('/twitter/server/access_token', TwitterServerAccessTokenHandler),
                (r'/twitter/api/users/show/(.*)\.json', TwitterServerShowUserHandler),
                (r'/twitter/api/account/verify_credentials\.json', TwitterServerVerifyCredentialsHandler),
            ],
            http_client=self.http_client,
            twitter_consumer_key='test_twitter_consumer_key',
            twitter_consumer_secret='test_twitter_consumer_secret',
            facebook_api_key='test_facebook_api_key',
            facebook_secret='test_facebook_secret')

    def test_openid_redirect(self):
        response = self.fetch('/openid/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(
            '/openid/server/authenticate?' in response.headers['Location'])

    def test_openid_get_user(self):
        response = self.fetch('/openid/client/login?openid.mode=blah&amp;openid.ns.ax=http://openid.net/srv/ax/1.0&amp;openid.ax.type.email=http://axschema.org/contact/email&amp;openid.ax.value.email=foo@example.com')
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed[&quot;email&quot;], &quot;foo@example.com&quot;)

    def test_oauth10_redirect(self):
        response = self.fetch('/oauth10/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(response.headers['Location'].endswith(
            '/oauth1/server/authorize?oauth_token=zxcv'))
        # the cookie is base64('zxcv')|base64('1234')
        self.assertTrue(
            '_oauth_request_token=&quot;enhjdg==|MTIzNA==&quot;' in response.headers['Set-Cookie'],
            response.headers['Set-Cookie'])

    def test_oauth10_get_user(self):
        response = self.fetch(
            '/oauth10/client/login?oauth_token=zxcv',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['email'], 'foo@example.com')
        self.assertEqual(parsed['access_token'], dict(key='uiop', secret='5678'))

    def test_oauth10_request_parameters(self):
        response = self.fetch('/oauth10/client/request_params')
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['oauth_consumer_key'], 'asdf')
        self.assertEqual(parsed['oauth_token'], 'uiop')
        self.assertTrue('oauth_nonce' in parsed)
        self.assertTrue('oauth_signature' in parsed)

    def test_oauth10a_redirect(self):
        response = self.fetch('/oauth10a/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(response.headers['Location'].endswith(
            '/oauth1/server/authorize?oauth_token=zxcv'))
        # the cookie is base64('zxcv')|base64('1234')
        self.assertTrue(
            '_oauth_request_token=&quot;enhjdg==|MTIzNA==&quot;' in response.headers['Set-Cookie'],
            response.headers['Set-Cookie'])

    def test_oauth10a_get_user(self):
        response = self.fetch(
            '/oauth10a/client/login?oauth_token=zxcv',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['email'], 'foo@example.com')
        self.assertEqual(parsed['access_token'], dict(key='uiop', secret='5678'))

    def test_oauth10a_request_parameters(self):
        response = self.fetch('/oauth10a/client/request_params')
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed['oauth_consumer_key'], 'asdf')
        self.assertEqual(parsed['oauth_token'], 'uiop')
        self.assertTrue('oauth_nonce' in parsed)
        self.assertTrue('oauth_signature' in parsed)

    def test_oauth10a_get_user_coroutine_exception(self):
        response = self.fetch(
            '/oauth10a/client/login_coroutine?oauth_token=zxcv&amp;fail_in_get_user=true',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        self.assertEqual(response.code, 503)

    def test_oauth2_redirect(self):
        response = self.fetch('/oauth2/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue('/oauth2/server/authorize?' in response.headers['Location'])

    def test_facebook_login(self):
        response = self.fetch('/facebook/client/login', follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue('/facebook/server/authorize?' in response.headers['Location'])
        response = self.fetch('/facebook/client/login?code=1234', follow_redirects=False)
        self.assertEqual(response.code, 200)
        user = json_decode(response.body)
        self.assertEqual(user['access_token'], 'asdf')
        self.assertEqual(user['session_expires'], '3600')

    def base_twitter_redirect(self, url):
        # Same as test_oauth10a_redirect
        response = self.fetch(url, follow_redirects=False)
        self.assertEqual(response.code, 302)
        self.assertTrue(response.headers['Location'].endswith(
            '/oauth1/server/authorize?oauth_token=zxcv'))
        # the cookie is base64('zxcv')|base64('1234')
        self.assertTrue(
            '_oauth_request_token=&quot;enhjdg==|MTIzNA==&quot;' in response.headers['Set-Cookie'],
            response.headers['Set-Cookie'])

    def test_twitter_redirect(self):
        self.base_twitter_redirect('/twitter/client/login')

    def test_twitter_redirect_gen_engine(self):
        self.base_twitter_redirect('/twitter/client/login_gen_engine')

    def test_twitter_redirect_gen_coroutine(self):
        self.base_twitter_redirect('/twitter/client/login_gen_coroutine')

    def test_twitter_get_user(self):
        response = self.fetch(
            '/twitter/client/login?oauth_token=zxcv',
            headers={'Cookie': '_oauth_request_token=enhjdg==|MTIzNA=='})
        response.rethrow()
        parsed = json_decode(response.body)
        self.assertEqual(parsed,
                         {u'access_token': {u'key': u'hjkl',
                                            u'screen_name': u'foo',
                                            u'secret': u'vbnm'},
                          u'name': u'Foo',
                          u'screen_name': u'foo',
                          u'username': u'foo'})

    def test_twitter_show_user(self):
        response = self.fetch('/twitter/client/show_user?name=somebody')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         {'name': 'Somebody', 'screen_name': 'somebody'})

    def test_twitter_show_user_error(self):
        with ExpectLog(gen_log, 'Error response HTTP 500'):
            response = self.fetch('/twitter/client/show_user?name=error')
        self.assertEqual(response.code, 500)
        self.assertEqual(response.body, b'error from twitter request')

    def test_twitter_show_user_future(self):
        response = self.fetch('/twitter/client/show_user_future?name=somebody')
        response.rethrow()
        self.assertEqual(json_decode(response.body),
                         {'name': 'Somebody', 'screen_name': 'somebody'})

    def test_twitter_show_user_future_error(self):
        response = self.fetch('/twitter/client/show_user_future?name=error')
        self.assertEqual(response.code, 500)
        self.assertIn(b'Error response HTTP 500', response.body)


class GoogleLoginHandler(RequestHandler, GoogleOAuth2Mixin):
    def initialize(self, test):
        self.test = test
        self._OAUTH_REDIRECT_URI = test.get_url('/client/login')
        self._OAUTH_AUTHORIZE_URL = test.get_url('/google/oauth2/authorize')
        self._OAUTH_ACCESS_TOKEN_URL = test.get_url('/google/oauth2/token')

    @gen.coroutine
    def get(self):
        code = self.get_argument('code', None)
        if code is not None:
            # retrieve authenticate google user
            access = yield self.get_authenticated_user(self._OAUTH_REDIRECT_URI,
                                                       code)
            user = yield self.oauth2_request(
                self.test.get_url(&quot;/google/oauth2/userinfo&quot;),
                access_token=access[&quot;access_token&quot;])
            # return the user and access token as json
            user[&quot;access_token&quot;] = access[&quot;access_token&quot;]
            self.write(user)
        else:
            yield self.authorize_redirect(
                redirect_uri=self._OAUTH_REDIRECT_URI,
                client_id=self.settings['google_oauth']['key'],
                client_secret=self.settings['google_oauth']['secret'],
                scope=['profile', 'email'],
                response_type='code',
                extra_params={'prompt': 'select_account'})


class GoogleOAuth2AuthorizeHandler(RequestHandler):
    def get(self):
        # issue a fake auth code and redirect to redirect_uri
        code = 'fake-authorization-code'
        self.redirect(url_concat(self.get_argument('redirect_uri'),
                                 dict(code=code)))


class GoogleOAuth2TokenHandler(RequestHandler):
    def post(self):
        assert self.get_argument('code') == 'fake-authorization-code'
        # issue a fake token
        self.finish({
            'access_token': 'fake-access-token',
            'expires_in': 'never-expires'
        })


class GoogleOAuth2UserinfoHandler(RequestHandler):
    def get(self):
        assert self.get_argument('access_token') == 'fake-access-token'
        # return a fake user
        self.finish({
            'name': 'Foo',
            'email': 'foo@example.com'
        })


class GoogleOAuth2Test(AsyncHTTPTestCase):
    def get_app(self):
        return Application(
            [
                # test endpoints
                ('/client/login', GoogleLoginHandler, dict(test=self)),

                # simulated google authorization server endpoints
                ('/google/oauth2/authorize', GoogleOAuth2AuthorizeHandler),
                ('/google/oauth2/token', GoogleOAuth2TokenHandler),
                ('/google/oauth2/userinfo', GoogleOAuth2UserinfoHandler),
            ],
            google_oauth={
                &quot;key&quot;: 'fake_google_client_id',
                &quot;secret&quot;: 'fake_google_client_secret'
            })

    def test_google_login(self):
        response = self.fetch('/client/login')
        self.assertDictEqual({
            u'name': u'Foo',
            u'email': u'foo@example.com',
            u'access_token': u'fake-access-token',
        }, json_decode(response.body))
</PRE>
</div>
  </div>
</body>
</html>
