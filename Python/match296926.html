<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for boto_apigateway.py & junos_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for boto_apigateway.py & junos_1.py
      </h3>
      <h1 align="center">
        0.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>boto_apigateway.py (0.4743083%)<TH>junos_1.py (0.45300114%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match296926-0.html#0',2,'match296926-1.html#0',3)" NAME="0">(2076-2083)<TD><A HREF="javascript:ZweiFrames('match296926-0.html#0',2,'match296926-1.html#0',3)" NAME="0">(1719-1726)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage Apigateway Rest APIs
===========================

.. versionadded:: 2016.11.0

:depends:
  - boto &gt;= 2.8.0
  - boto3 &gt;= 1.2.1
  - botocore &gt;= 1.4.49

Create and destroy rest apis depending on a swagger version 2 definition file.
Be aware that this interacts with Amazon's services, and so may incur charges.

This module uses ``boto3``, which can be installed via package, or pip.

This module accepts explicit vpc credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

If IAM roles are not used you need to specify them either in a pillar file or
in the minion's config file:

.. code-block:: yaml

    vpc.keyid: GKTADJGHEIQSXMKKRBJ08H
    vpc.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile,
either passed in as a dict, or as a string to pull from pillars or minion
config:

.. code-block:: yaml

    myprofile:
      keyid: GKTADJGHEIQSXMKKRBJ08H
      key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
      region: us-east-1

.. code-block:: yaml

    Ensure Apigateway API exists:
      boto_apigateway.present:
        - name: myfunction
        - region: us-east-1
        - keyid: GKTADJGHEIQSXMKKRBJ08H
        - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

&quot;&quot;&quot;


import hashlib
import logging
import os
import re

import salt.utils.files
import salt.utils.json
import salt.utils.yaml

log = logging.getLogger(__name__)


def __virtual__():
    &quot;&quot;&quot;
    Only load if boto is available.
    &quot;&quot;&quot;
    if &quot;boto_apigateway.describe_apis&quot; in __salt__:
        return &quot;boto_apigateway&quot;
    return (False, &quot;boto_apigateway module could not be loaded&quot;)


def present(
    name,
    api_name,
    swagger_file,
    stage_name,
    api_key_required,
    lambda_integration_role,
    lambda_region=None,
    stage_variables=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    lambda_funcname_format=&quot;{stage}_{api}_{resource}_{method}&quot;,
    authorization_type=&quot;NONE&quot;,
    error_response_template=None,
    response_template=None,
):
    &quot;&quot;&quot;
    Ensure the spcified api_name with the corresponding swaggerfile is deployed to the
    given stage_name in AWS ApiGateway.

    this state currently only supports ApiGateway integration with AWS Lambda, and CORS support is
    handled through a Mock integration.

    There may be multiple deployments for the API object, each deployment is tagged with a description
    (i.e. unique label) in pretty printed json format consisting of the following key/values.

    .. code-block:: text

        {
            &quot;api_name&quot;: api_name,
            &quot;swagger_file&quot;: basename_of_swagger_file
            &quot;swagger_file_md5sum&quot;: md5sum_of_swagger_file,
            &quot;swagger_info_object&quot;: info_object_content_in_swagger_file
        }

    Please note that the name of the lambda function to be integrated will be derived
    via the provided lambda_funcname_format parameters:

    - the default lambda_funcname_format is a string with the following
      substitutable keys: &quot;{stage}_{api}_{resource}_{method}&quot;.  The user can
      choose to reorder the known keys.
    - the stage key corresponds to the stage_name passed in.
    - the api key corresponds to the api_name passed in.
    - the resource corresponds to the resource path defined in the passed swagger file.
    - the method corresponds to the method for a resource path defined in the passed swagger file.

    For the default lambda_funcname_format, given the following input:

    .. code-block:: python

        api_name = '  Test    Service'
        stage_name = 'alpha'
        basePath = '/api'
        path = '/a/{b}/c'
        method = 'POST'

    We will end up with the following Lambda Function Name that will be looked
    up: 'test_service_alpha_a_b_c_post'

    The canconicalization of these input parameters is done in the following order:

    1. lambda_funcname_format is formatted with the input parameters as passed,
    2. resulting string is stripped for leading/trailing spaces,
    3. path parameter's curly braces are removed from the resource path,
    4. consecutive spaces and forward slashes in the paths are replaced with '_'
    5. consecutive '_' are replaced with '_'

    Please note that for error response handling, the swagger file must have an error response model
    with the following schema.  The lambda functions should throw exceptions for any non successful responses.
    An optional pattern field can be specified in errorMessage field to aid the response mapping from Lambda
    to the proper error return status codes.

    .. code-block:: yaml

        Error:
          type: object
          properties:
            stackTrace:
              type: array
              items:
                type: array
                items:
                  type: string
              description: call stack
          errorType:
            type: string
            description: error type
          errorMessage:
            type: string
            description: |
              Error message, will be matched based on pattern.
              If no pattern is specified, the default pattern used for response mapping will be +*.

    name
        The name of the state definition

    api_name
        The name of the rest api that we want to ensure exists in AWS API Gateway

    swagger_file
        Name of the location of the swagger rest api definition file in YAML format.

    stage_name
        Name of the stage we want to be associated with the given api_name and swagger_file
        definition

    api_key_required
        True or False - whether the API Key is required to call API methods

    lambda_integration_role
        The name or ARN of the IAM role that the AWS ApiGateway assumes when it
        executes your lambda function to handle incoming requests

    lambda_region
        The region where we expect to find the lambda functions.  This is used to
        determine the region where we should look for the Lambda Function for
        integration purposes.  The region determination is based on the following
        priority:

        1. lambda_region as passed in (is not None)
        2. if lambda_region is None, use the region as if a boto_lambda
           function were executed without explicitly specifying lambda region.
        3. if region determined in (2) is different than the region used by
           boto_apigateway functions, a final lookup will be attempted using
           the boto_apigateway region.

    stage_variables
        A dict with variables and their values, or a pillar key (string) that
        contains a dict with variables and their values.
        key and values in the dict must be strings.  {'string': 'string'}

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    lambda_funcname_format
        Please review the earlier example for the usage.  The only substituable keys in the funcname
        format are {stage}, {api}, {resource}, {method}.
        Any other keys or positional substitution parameters will be flagged as an invalid input.

    authorization_type
        This field can be either 'NONE', or 'AWS_IAM'.  This will be applied to all methods in the given
        swagger spec file.  Default is set to 'NONE'

    error_response_template
        String value that defines the response template mapping that should be applied in cases error occurs.
        Refer to AWS documentation for details: http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html

        If set to None, the following default value is used:

        .. code-block:: text

            '#set($inputRoot = $input.path(\'$\'))\\n'
            '{\\n'
            '  &quot;errorMessage&quot; : &quot;$inputRoot.errorMessage&quot;,\\n'
            '  &quot;errorType&quot; : &quot;$inputRoot.errorType&quot;,\\n'
            '  &quot;stackTrace&quot; : [\\n'
            '#foreach($stackTrace in $inputRoot.stackTrace)\\n'
            '    [\\n'
            '#foreach($elem in $stackTrace)\\n'
            '      &quot;$elem&quot;\\n'
            '#if($foreach.hasNext),#end\\n'
            '#end\\n'
            '    ]\\n'
            '#if($foreach.hasNext),#end\\n'
            '#end\\n'
            '  ]\\n'

        .. versionadded:: 2017.7.0

    response_template
        String value that defines the response template mapping applied in case
        of success (including OPTIONS method) If set to None, empty ({})
        template is assumed, which will transfer response from the lambda
        function as is.

        .. versionadded:: 2017.7.0
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    try:
        common_args = dict(
            [(&quot;region&quot;, region), (&quot;key&quot;, key), (&quot;keyid&quot;, keyid), (&quot;profile&quot;, profile)]
        )

        # try to open the swagger file and basic validation
        swagger = _Swagger(
            api_name,
            stage_name,
            lambda_funcname_format,
            swagger_file,
            error_response_template,
            response_template,
            common_args,
        )

        # retrieve stage variables
        stage_vars = _get_stage_variables(stage_variables)

        # verify if api and stage already exists
        ret = swagger.verify_api(ret)
        if ret.get(&quot;publish&quot;):
            # there is a deployment label with signature matching the given api_name,
            # swagger file name, swagger file md5 sum, and swagger file info object
            # just reassociate the stage_name to the given deployment label.
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = (
                    &quot;[stage: {}] will be reassociated to an already available &quot;
                    &quot;deployment that matched the given [api_name: {}] &quot;
                    &quot;and [swagger_file: {}].\n&quot;
                    &quot;Stage variables will be set &quot;
                    &quot;to {}.&quot;.format(stage_name, api_name, swagger_file, stage_vars)
                )
                ret[&quot;result&quot;] = None
                return ret
            return swagger.publish_api(ret, stage_vars)

        if ret.get(&quot;current&quot;):
            # already at desired state for the stage, swagger_file, and api_name
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = (
                    &quot;[stage: {}] is already at desired state with an associated &quot;
                    &quot;deployment matching the given [api_name: {}] &quot;
                    &quot;and [swagger_file: {}].\n&quot;
                    &quot;Stage variables will be set &quot;
                    &quot;to {}.&quot;.format(stage_name, api_name, swagger_file, stage_vars)
                )
                ret[&quot;result&quot;] = None
            return swagger.overwrite_stage_variables(ret, stage_vars)

        # there doesn't exist any previous deployments for the given swagger_file, we need
        # to redeploy the content of the swagger file to the api, models, and resources object
        # and finally create a new deployment and tie the stage_name to this new deployment
        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = (
                &quot;There is no deployment matching the given [api_name: {}] &quot;
                &quot;and [swagger_file: {}].  A new deployment will be &quot;
                &quot;created and the [stage_name: {}] will then be associated &quot;
                &quot;to the newly created deployment.\n&quot;
                &quot;Stage variables will be set &quot;
                &quot;to {}.&quot;.format(api_name, swagger_file, stage_name, stage_vars)
            )
            ret[&quot;result&quot;] = None
            return ret

        ret = swagger.deploy_api(ret)
        if ret.get(&quot;abort&quot;):
            return ret

        ret = swagger.deploy_models(ret)
        if ret.get(&quot;abort&quot;):
            return ret

        ret = swagger.deploy_resources(
            ret,
            api_key_required=api_key_required,
            lambda_integration_role=lambda_integration_role,
            lambda_region=lambda_region,
            authorization_type=authorization_type,
        )
        if ret.get(&quot;abort&quot;):
            return ret

        ret = swagger.publish_api(ret, stage_vars)

    except (ValueError, OSError) as e:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;{}&quot;.format(e.args)

    return ret


def _get_stage_variables(stage_variables):
    &quot;&quot;&quot;
    Helper function to retrieve stage variables from pillars/options, if the
    input is a string
    &quot;&quot;&quot;
    ret = dict()
    if stage_variables is None:
        return ret

    if isinstance(stage_variables, str):
        if stage_variables in __opts__:
            ret = __opts__[stage_variables]
        master_opts = __pillar__.get(&quot;master&quot;, {})
        if stage_variables in master_opts:
            ret = master_opts[stage_variables]
        if stage_variables in __pillar__:
            ret = __pillar__[stage_variables]
    elif isinstance(stage_variables, dict):
        ret = stage_variables

    if not isinstance(ret, dict):
        ret = dict()

    return ret


def absent(
    name,
    api_name,
    stage_name,
    nuke_api=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure the stage_name associated with the given api_name deployed by boto_apigateway's
    present state is removed.  If the currently associated deployment to the given stage_name has
    no other stages associated with it, the deployment will also be removed.

    name
        Name of the swagger file in YAML format

    api_name
        Name of the rest api on AWS ApiGateway to ensure is absent.

    stage_name
        Name of the stage to be removed irrespective of the swagger file content.
        If the current deployment associated with the stage_name has no other stages associated
        with it, the deployment will also be removed.

    nuke_api
        If True, removes the API itself only if there are no other stages associated with any other
        deployments once the given stage_name is removed.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    try:
        common_args = dict(
            [(&quot;region&quot;, region), (&quot;key&quot;, key), (&quot;keyid&quot;, keyid), (&quot;profile&quot;, profile)]
        )

        swagger = _Swagger(api_name, stage_name, &quot;&quot;, None, None, None, common_args)

        if not swagger.restApiId:
            ret[&quot;comment&quot;] = &quot;[Rest API: {}] does not exist.&quot;.format(api_name)
            return ret

        if __opts__[&quot;test&quot;]:
            if nuke_api:
                ret[&quot;comment&quot;] = (
                    &quot;[stage: {}] will be deleted, if there are no other &quot;
                    &quot;active stages, the [api: {} will also be &quot;
                    &quot;deleted.&quot;.format(stage_name, api_name)
                )
            else:
                ret[&quot;comment&quot;] = &quot;[stage: {}] will be deleted.&quot;.format(stage_name)
            ret[&quot;result&quot;] = None
            return ret

        ret = swagger.delete_stage(ret)

        if ret.get(&quot;abort&quot;):
            return ret

        if nuke_api and swagger.no_more_deployments_remain():
            ret = swagger.delete_api(ret)

    except (ValueError, OSError) as e:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;{}&quot;.format(e.args)

    return ret


# Helper Swagger Class for swagger version 2.0 API specification
def _gen_md5_filehash(fname, *args):
    &quot;&quot;&quot;
    helper function to generate a md5 hash of the swagger definition file
    any extra argument passed to the function is converted to a string
    and participates in the hash calculation
    &quot;&quot;&quot;
    _hash = hashlib.md5()
    with salt.utils.files.fopen(fname, &quot;rb&quot;) as f:
        for chunk in iter(lambda: f.read(4096), b&quot;&quot;):
            _hash.update(chunk)

    for extra_arg in args:
        _hash.update(str(extra_arg).encode())
    return _hash.hexdigest()


def _dict_to_json_pretty(d, sort_keys=True):
    &quot;&quot;&quot;
    helper function to generate pretty printed json output
    &quot;&quot;&quot;
    return salt.utils.json.dumps(
        d, indent=4, separators=(&quot;,&quot;, &quot;: &quot;), sort_keys=sort_keys
    )


# Heuristic on whether or not the property name loosely matches given set of 'interesting' factors
# If you are interested in IDs for example, 'id', 'blah_id', 'blahId' would all match
def _name_matches(name, matches):
    &quot;&quot;&quot;
    Helper function to see if given name has any of the patterns in given matches
    &quot;&quot;&quot;
    for m in matches:
        if name.endswith(m):
            return True
        if name.lower().endswith(&quot;_&quot; + m.lower()):
            return True
        if name.lower() == m.lower():
            return True
    return False


def _object_reducer(
    o,
    names=(
        &quot;id&quot;,
        &quot;name&quot;,
        &quot;path&quot;,
        &quot;httpMethod&quot;,
        &quot;statusCode&quot;,
        &quot;Created&quot;,
        &quot;Deleted&quot;,
        &quot;Updated&quot;,
        &quot;Flushed&quot;,
        &quot;Associated&quot;,
        &quot;Disassociated&quot;,
    ),
):
    &quot;&quot;&quot;
    Helper function to reduce the amount of information that will be kept in the change log
    for API GW related return values
    &quot;&quot;&quot;
    result = {}
    if isinstance(o, dict):
        for k, v in o.items():
            if isinstance(v, dict):
                reduced = v if k == &quot;variables&quot; else _object_reducer(v, names)
                if reduced or _name_matches(k, names):
                    result[k] = reduced
            elif isinstance(v, list):
                newlist = []
                for val in v:
                    reduced = _object_reducer(val, names)
                    if reduced or _name_matches(k, names):
                        newlist.append(reduced)
                if newlist:
                    result[k] = newlist
            else:
                if _name_matches(k, names):
                    result[k] = v
    return result


def _log_changes(ret, changekey, changevalue):
    &quot;&quot;&quot;
    For logging create/update/delete operations to AWS ApiGateway
    &quot;&quot;&quot;
    cl = ret[&quot;changes&quot;].get(&quot;new&quot;, [])
    cl.append({changekey: _object_reducer(changevalue)})
    ret[&quot;changes&quot;][&quot;new&quot;] = cl
    return ret


def _log_error_and_abort(ret, obj):
    &quot;&quot;&quot;
    helper function to update errors in the return structure
    &quot;&quot;&quot;
    ret[&quot;result&quot;] = False
    ret[&quot;abort&quot;] = True
    if &quot;error&quot; in obj:
        ret[&quot;comment&quot;] = &quot;{}&quot;.format(obj.get(&quot;error&quot;))
    return ret


class _Swagger:
    &quot;&quot;&quot;
    this is a helper class that holds the swagger definition file and the associated logic
    related to how to interpret the file and apply it to AWS Api Gateway.

    The main interface to the outside world is in deploy_api, deploy_models, and deploy_resources
    methods.
    &quot;&quot;&quot;

    SWAGGER_OBJ_V2_FIELDS = (
        &quot;swagger&quot;,
        &quot;info&quot;,
        &quot;host&quot;,
        &quot;basePath&quot;,
        &quot;schemes&quot;,
        &quot;consumes&quot;,
        &quot;produces&quot;,
        &quot;paths&quot;,
        &quot;definitions&quot;,
        &quot;parameters&quot;,
        &quot;responses&quot;,
        &quot;securityDefinitions&quot;,
        &quot;security&quot;,
        &quot;tags&quot;,
        &quot;externalDocs&quot;,
    )
    # SWAGGER OBJECT V2 Fields that are required by boto apigateway states.
    SWAGGER_OBJ_V2_FIELDS_REQUIRED = (
        &quot;swagger&quot;,
        &quot;info&quot;,
        &quot;basePath&quot;,
        &quot;schemes&quot;,
        &quot;paths&quot;,
        &quot;definitions&quot;,
    )
    # SWAGGER OPERATION NAMES
    SWAGGER_OPERATION_NAMES = (
        &quot;get&quot;,
        &quot;put&quot;,
        &quot;post&quot;,
        &quot;delete&quot;,
        &quot;options&quot;,
        &quot;head&quot;,
        &quot;patch&quot;,
    )
    SWAGGER_VERSIONS_SUPPORTED = (&quot;2.0&quot;,)

    # VENDOR SPECIFIC FIELD PATTERNS
    VENDOR_EXT_PATTERN = re.compile(&quot;^x-&quot;)

    # JSON_SCHEMA_REF
    JSON_SCHEMA_DRAFT_4 = &quot;http://json-schema.org/draft-04/schema#&quot;

    # AWS integration templates for normal and options methods
    REQUEST_TEMPLATE = {
        &quot;application/json&quot;: (
            &quot;#set($inputRoot = $input.path('$'))\n{\n\&quot;header_params\&quot; : {\n#set ($map&quot;
            &quot; = $input.params().header)\n#foreach( $param in $map.entrySet()&quot;
            ' )\n&quot;$param.key&quot; : &quot;$param.value&quot; #if( $foreach.hasNext ),'
            ' #end\n#end\n},\n&quot;query_params&quot; : {\n#set ($map ='
            &quot; $input.params().querystring)\n#foreach( $param in $map.entrySet()&quot;
            ' )\n&quot;$param.key&quot; : &quot;$param.value&quot; #if( $foreach.hasNext ),'
            ' #end\n#end\n},\n&quot;path_params&quot; : {\n#set ($map ='
            &quot; $input.params().path)\n#foreach( $param in $map.entrySet()&quot;
            ' )\n&quot;$param.key&quot; : &quot;$param.value&quot; #if( $foreach.hasNext ),'
            ' #end\n#end\n},\n&quot;apigw_context&quot; : {\n&quot;apiId&quot;:'
            ' &quot;$context.apiId&quot;,\n&quot;httpMethod&quot;: &quot;$context.httpMethod&quot;,\n&quot;requestId&quot;:'
            ' &quot;$context.requestId&quot;,\n&quot;resourceId&quot;:'
            ' &quot;$context.resourceId&quot;,\n&quot;resourcePath&quot;:'
            ' &quot;$context.resourcePath&quot;,\n&quot;stage&quot;: &quot;$context.stage&quot;,\n&quot;identity&quot;: {\n '
            ' &quot;user&quot;:&quot;$context.identity.user&quot;,\n '
            ' &quot;userArn&quot;:&quot;$context.identity.userArn&quot;,\n '
            ' &quot;userAgent&quot;:&quot;$context.identity.userAgent&quot;,\n '
            ' &quot;sourceIp&quot;:&quot;$context.identity.sourceIp&quot;,\n '
            ' &quot;cognitoIdentityId&quot;:&quot;$context.identity.cognitoIdentityId&quot;,\n '
            ' &quot;cognitoIdentityPoolId&quot;:&quot;$context.identity.cognitoIdentityPoolId&quot;,\n '
            ' &quot;cognitoAuthenticationType&quot;:&quot;$context.identity.cognitoAuthenticationType&quot;,\n'
            '  &quot;cognitoAuthenticationProvider&quot;:[&quot;$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)&quot;],\n'
            '  &quot;caller&quot;:&quot;$context.identity.caller&quot;,\n '
            ' &quot;apiKey&quot;:&quot;$context.identity.apiKey&quot;,\n '
            ' &quot;accountId&quot;:&quot;$context.identity.accountId&quot;\n}\n},\n&quot;body_params&quot; :'
            &quot; $input.json('$'),\n\&quot;stage_variables\&quot;: {\n#foreach($variable in&quot;
            ' $stageVariables.keySet())\n&quot;$variable&quot;:'
            ' &quot;$util.escapeJavaScript($stageVariables.get($variable))&quot;\n#if($foreach.hasNext),'
            &quot; #end\n#end\n}\n}&quot;
        )
    }
    REQUEST_OPTION_TEMPLATE = {&quot;application/json&quot;: '{&quot;statusCode&quot;: 200}'}

    # AWS integration response template mapping to convert stackTrace part or the error
    # to a uniform format containing strings only. Swagger does not seem to allow defining
    # an array of non-uniform types, to it is not possible to create error model to match
    # exactly what comes out of lambda functions in case of error.
    RESPONSE_TEMPLATE = {
        &quot;application/json&quot;: (
            &quot;#set($inputRoot = $input.path('$'))\n&quot;
            &quot;{\n&quot;
            '  &quot;errorMessage&quot; : &quot;$inputRoot.errorMessage&quot;,\n'
            '  &quot;errorType&quot; : &quot;$inputRoot.errorType&quot;,\n'
            '  &quot;stackTrace&quot; : [\n'
            &quot;#foreach($stackTrace in $inputRoot.stackTrace)\n&quot;
            &quot;    [\n&quot;
            &quot;#foreach($elem in $stackTrace)\n&quot;
            '      &quot;$elem&quot;\n'
            &quot;#if($foreach.hasNext),#end\n&quot;
            &quot;#end\n&quot;
            &quot;    ]\n&quot;
            &quot;#if($foreach.hasNext),#end\n&quot;
            &quot;#end\n&quot;
            &quot;  ]\n&quot;
            &quot;}&quot;
        )
    }
    RESPONSE_OPTION_TEMPLATE = {}

    # This string should not be modified, every API created by this state will carry the description
    # below.
    AWS_API_DESCRIPTION = _dict_to_json_pretty(
        {
            &quot;provisioned_by&quot;: &quot;Salt boto_apigateway.present State&quot;,
            &quot;context&quot;: &quot;See deployment or stage description&quot;,
        }
    )

    class SwaggerParameter:
        &quot;&quot;&quot;
        This is a helper class for the Swagger Parameter Object
        &quot;&quot;&quot;

        LOCATIONS = (&quot;body&quot;, &quot;query&quot;, &quot;header&quot;, &quot;path&quot;)

        def __init__(self, paramdict):
            self._paramdict = paramdict

        @property
        def location(self):
            &quot;&quot;&quot;
            returns location in the swagger parameter object
            &quot;&quot;&quot;
            _location = self._paramdict.get(&quot;in&quot;)
            if _location in _Swagger.SwaggerParameter.LOCATIONS:
                return _location
            raise ValueError(
                &quot;Unsupported parameter location: {} in Parameter Object&quot;.format(
                    _location
                )
            )

        @property
        def name(self):
            &quot;&quot;&quot;
            returns parameter name in the swagger parameter object
            &quot;&quot;&quot;
            _name = self._paramdict.get(&quot;name&quot;)
            if _name:
                if self.location == &quot;header&quot;:
                    return &quot;method.request.header.{}&quot;.format(_name)
                elif self.location == &quot;query&quot;:
                    return &quot;method.request.querystring.{}&quot;.format(_name)
                elif self.location == &quot;path&quot;:
                    return &quot;method.request.path.{}&quot;.format(_name)
                return None
            raise ValueError(
                &quot;Parameter must have a name: {}&quot;.format(
                    _dict_to_json_pretty(self._paramdict)
                )
            )

        @property
        def schema(self):
            &quot;&quot;&quot;
            returns the name of the schema given the reference in the swagger parameter object
            &quot;&quot;&quot;
            if self.location == &quot;body&quot;:
                _schema = self._paramdict.get(&quot;schema&quot;)
                if _schema:
                    if &quot;$ref&quot; in _schema:
                        schema_name = _schema.get(&quot;$ref&quot;).split(&quot;/&quot;)[-1]
                        return schema_name
                    raise ValueError(
                        &quot;Body parameter must have a JSON reference &quot;
                        &quot;to the schema definition due to Amazon API restrictions: {}&quot;.format(
                            self.name
                        )
                    )
                raise ValueError(
                    &quot;Body parameter must have a schema: {}&quot;.format(self.name)
                )
            return None

    class SwaggerMethodResponse:
        &quot;&quot;&quot;
        Helper class for Swagger Method Response Object
        &quot;&quot;&quot;

        def __init__(self, r):
            self._r = r

        @property
        def schema(self):
            &quot;&quot;&quot;
            returns the name of the schema given the reference in the swagger method response object
            &quot;&quot;&quot;
            _schema = self._r.get(&quot;schema&quot;)
            if _schema:
                if &quot;$ref&quot; in _schema:
                    return _schema.get(&quot;$ref&quot;).split(&quot;/&quot;)[-1]
                raise ValueError(
                    &quot;Method response must have a JSON reference &quot;
                    &quot;to the schema definition: {}&quot;.format(_schema)
                )
            return None

        @property
        def headers(self):
            &quot;&quot;&quot;
            returns the headers dictionary in the method response object
            &quot;&quot;&quot;
            _headers = self._r.get(&quot;headers&quot;, {})
            return _headers

    def __init__(
        self,
        api_name,
        stage_name,
        lambda_funcname_format,
        swagger_file_path,
        error_response_template,
        response_template,
        common_aws_args,
    ):
        self._api_name = api_name
        self._stage_name = stage_name
        self._lambda_funcname_format = lambda_funcname_format
        self._common_aws_args = common_aws_args
        self._restApiId = &quot;&quot;
        self._deploymentId = &quot;&quot;
        self._error_response_template = error_response_template
        self._response_template = response_template

        if swagger_file_path is not None:
            if os.path.exists(swagger_file_path) and os.path.isfile(swagger_file_path):
                self._swagger_file = swagger_file_path
                self._md5_filehash = _gen_md5_filehash(
                    self._swagger_file, error_response_template, response_template
                )
                with salt.utils.files.fopen(self._swagger_file, &quot;rb&quot;) as sf:
                    self._cfg = salt.utils.yaml.safe_load(sf)
                self._swagger_version = &quot;&quot;
            else:
                raise OSError(&quot;Invalid swagger file path, {}&quot;.format(swagger_file_path))

            self._validate_swagger_file()

        self._validate_lambda_funcname_format()

        self._resolve_api_id()

    def _is_http_error_rescode(self, code):
        &quot;&quot;&quot;
        Helper function to determine if the passed code is in the 400~599 range of http error
        codes
        &quot;&quot;&quot;
        return bool(re.match(r&quot;^\s*[45]\d\d\s*$&quot;, code))

    def _validate_error_response_model(self, paths, mods):
        &quot;&quot;&quot;
        Helper function to help validate the convention established in the swagger file on how
        to handle response code mapping/integration
        &quot;&quot;&quot;
        for path, ops in paths:
            for opname, opobj in ops.items():
                if opname not in _Swagger.SWAGGER_OPERATION_NAMES:
                    continue

                if &quot;responses&quot; not in opobj:
                    raise ValueError(
                        &quot;missing mandatory responses field in path item object&quot;
                    )
                for rescode, resobj in opobj.get(&quot;responses&quot;).items():
                    if not self._is_http_error_rescode(str(rescode)):
                        continue

                    # only check for response code from 400-599
                    if &quot;schema&quot; not in resobj:
                        raise ValueError(
                            &quot;missing schema field in path {}, &quot;
                            &quot;op {}, response {}&quot;.format(path, opname, rescode)
                        )

                    schemaobj = resobj.get(&quot;schema&quot;)
                    if &quot;$ref&quot; not in schemaobj:
                        raise ValueError(
                            &quot;missing $ref field under schema in &quot;
                            &quot;path {}, op {}, response {}&quot;.format(path, opname, rescode)
                        )
                    schemaobjref = schemaobj.get(&quot;$ref&quot;, &quot;/&quot;)
                    modelname = schemaobjref.split(&quot;/&quot;)[-1]

                    if modelname not in mods:
                        raise ValueError(
                            &quot;model schema {} reference not found &quot;
                            &quot;under /definitions&quot;.format(schemaobjref)
                        )
                    model = mods.get(modelname)

                    if model.get(&quot;type&quot;) != &quot;object&quot;:
                        raise ValueError(
                            &quot;model schema {} must be type object&quot;.format(modelname)
                        )
                    if &quot;properties&quot; not in model:
                        raise ValueError(
                            &quot;model schema {} must have properties fields&quot;.format(
                                modelname
                            )
                        )

                    modelprops = model.get(&quot;properties&quot;)
                    if &quot;errorMessage&quot; not in modelprops:
                        raise ValueError(
                            &quot;model schema {} must have errorMessage as a property to &quot;
                            &quot;match AWS convention. If pattern is not set, .+ will &quot;
                            &quot;be used&quot;.format(modelname)
                        )

    def _validate_lambda_funcname_format(self):
        &quot;&quot;&quot;
        Checks if the lambda function name format contains only known elements
        :return: True on success, ValueError raised on error
        &quot;&quot;&quot;
        try:
            if self._lambda_funcname_format:
                known_kwargs = dict(stage=&quot;&quot;, api=&quot;&quot;, resource=&quot;&quot;, method=&quot;&quot;)
                self._lambda_funcname_format.format(**known_kwargs)
            return True
        except Exception:  # pylint: disable=broad-except
            raise ValueError(
                &quot;Invalid lambda_funcname_format {}.  Please review &quot;
                &quot;documentation for known substitutable keys&quot;.format(
                    self._lambda_funcname_format
                )
            )

    def _validate_swagger_file(self):
        &quot;&quot;&quot;
        High level check/validation of the input swagger file based on
        https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md

        This is not a full schema compliance check, but rather make sure that the input file (YAML or
        JSON) can be read into a dictionary, and we check for the content of the Swagger Object for version
        and info.
        &quot;&quot;&quot;

        # check for any invalid fields for Swagger Object V2
        for field in self._cfg:
            if (
                field not in _Swagger.SWAGGER_OBJ_V2_FIELDS
                and not _Swagger.VENDOR_EXT_PATTERN.match(field)
            ):
                raise ValueError(&quot;Invalid Swagger Object Field: {}&quot;.format(field))

        # check for Required Swagger fields by Saltstack boto apigateway state
        for field in _Swagger.SWAGGER_OBJ_V2_FIELDS_REQUIRED:
            if field not in self._cfg:
                raise ValueError(&quot;Missing Swagger Object Field: {}&quot;.format(field))

        # check for Swagger Version
        self._swagger_version = self._cfg.get(&quot;swagger&quot;)
        if self._swagger_version not in _Swagger.SWAGGER_VERSIONS_SUPPORTED:
            raise ValueError(
                &quot;Unsupported Swagger version: {},Supported versions are {}&quot;.format(
                    self._swagger_version, _Swagger.SWAGGER_VERSIONS_SUPPORTED
                )
            )

        log.info(type(self._models))
        self._validate_error_response_model(self.paths, self._models())

    @property
    def md5_filehash(self):
        &quot;&quot;&quot;
        returns md5 hash for the swagger file
        &quot;&quot;&quot;
        return self._md5_filehash

    @property
    def info(self):
        &quot;&quot;&quot;
        returns the swagger info object as a dictionary
        &quot;&quot;&quot;
        info = self._cfg.get(&quot;info&quot;)
        if not info:
            raise ValueError(&quot;Info Object has no values&quot;)
        return info

    @property
    def info_json(self):
        &quot;&quot;&quot;
        returns the swagger info object as a pretty printed json string.
        &quot;&quot;&quot;
        return _dict_to_json_pretty(self.info)

    @property
    def rest_api_name(self):
        &quot;&quot;&quot;
        returns the name of the api
        &quot;&quot;&quot;
        return self._api_name

    @property
    def rest_api_version(self):
        &quot;&quot;&quot;
        returns the version field in the swagger info object
        &quot;&quot;&quot;
        version = self.info.get(&quot;version&quot;)
        if not version:
            raise ValueError(&quot;Missing version value in Info Object&quot;)

        return version

    def _models(self):
        &quot;&quot;&quot;
        returns an iterator for the models specified in the swagger file
        &quot;&quot;&quot;
        models = self._cfg.get(&quot;definitions&quot;)
        if not models:
            raise ValueError(
                &quot;Definitions Object has no values, You need to define them in your&quot;
                &quot; swagger file&quot;
            )

        return models

    def models(self):
        &quot;&quot;&quot;
        generator to return the tuple of model and its schema to create on aws.
        &quot;&quot;&quot;
        model_dict = self._build_all_dependencies()
        while True:
            model = self._get_model_without_dependencies(model_dict)
            if not model:
                break
            yield (model, self._models().get(model))

    @property
    def paths(self):
        &quot;&quot;&quot;
        returns an iterator for the relative resource paths specified in the swagger file
        &quot;&quot;&quot;
        paths = self._cfg.get(&quot;paths&quot;)
        if not paths:
            raise ValueError(
                &quot;Paths Object has no values, You need to define them in your swagger&quot;
                &quot; file&quot;
            )
        for path in paths:
            if not path.startswith(&quot;/&quot;):
                raise ValueError(
                    &quot;Path object {} should start with /. Please fix it&quot;.format(path)
                )
        return paths.items()

    @property
    def basePath(self):
        &quot;&quot;&quot;
        returns the base path field as defined in the swagger file
        &quot;&quot;&quot;
        basePath = self._cfg.get(&quot;basePath&quot;, &quot;&quot;)
        return basePath

    @property
    def restApiId(self):
        &quot;&quot;&quot;
        returns the rest api id as returned by AWS on creation of the rest api
        &quot;&quot;&quot;
        return self._restApiId

    @restApiId.setter
    def restApiId(self, restApiId):
        &quot;&quot;&quot;
        allows the assignment of the rest api id on creation of the rest api
        &quot;&quot;&quot;
        self._restApiId = restApiId

    @property
    def deployment_label_json(self):
        &quot;&quot;&quot;
        this property returns the unique description in pretty printed json for
        a particular api deployment
        &quot;&quot;&quot;
        return _dict_to_json_pretty(self.deployment_label)

    @property
    def deployment_label(self):
        &quot;&quot;&quot;
        this property returns the deployment label dictionary (mainly used by
        stage description)
        &quot;&quot;&quot;
        label = dict()

        label[&quot;swagger_info_object&quot;] = self.info
        label[&quot;api_name&quot;] = self.rest_api_name
        label[&quot;swagger_file&quot;] = os.path.basename(self._swagger_file)
        label[&quot;swagger_file_md5sum&quot;] = self.md5_filehash

        return label

    # methods to interact with boto_apigateway execution modules
    def _one_or_more_stages_remain(self, deploymentId):
        &quot;&quot;&quot;
        Helper function to find whether there are other stages still associated with a deployment
        &quot;&quot;&quot;
        stages = __salt__[&quot;boto_apigateway.describe_api_stages&quot;](
            restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
        ).get(&quot;stages&quot;)
        return bool(stages)

    def no_more_deployments_remain(self):
        &quot;&quot;&quot;
        Helper function to find whether there are deployments left with stages associated
        &quot;&quot;&quot;
        no_more_deployments = True
        deployments = __salt__[&quot;boto_apigateway.describe_api_deployments&quot;](
            restApiId=self.restApiId, **self._common_aws_args
        ).get(&quot;deployments&quot;)
        if deployments:
            for deployment in deployments:
                deploymentId = deployment.get(&quot;id&quot;)
                stages = __salt__[&quot;boto_apigateway.describe_api_stages&quot;](
                    restApiId=self.restApiId,
                    deploymentId=deploymentId,
                    **self._common_aws_args
                ).get(&quot;stages&quot;)
                if stages:
                    no_more_deployments = False
                    break

        return no_more_deployments

    def _get_current_deployment_id(self):
        &quot;&quot;&quot;
        Helper method to find the deployment id that the stage name is currently assocaited with.
        &quot;&quot;&quot;
        deploymentId = &quot;&quot;
        stage = __salt__[&quot;boto_apigateway.describe_api_stage&quot;](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            **self._common_aws_args
        ).get(&quot;stage&quot;)
        if stage:
            deploymentId = stage.get(&quot;deploymentId&quot;)
        return deploymentId

    def _get_current_deployment_label(self):
        &quot;&quot;&quot;
        Helper method to find the deployment label that the stage_name is currently associated with.
        &quot;&quot;&quot;
        deploymentId = self._get_current_deployment_id()
        deployment = __salt__[&quot;boto_apigateway.describe_api_deployment&quot;](
            restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
        ).get(&quot;deployment&quot;)
        if deployment:
            return deployment.get(&quot;description&quot;)
        return None

    def _get_desired_deployment_id(self):
        &quot;&quot;&quot;
        Helper method to return the deployment id matching the desired deployment label for
        this Swagger object based on the given api_name, swagger_file
        &quot;&quot;&quot;
        deployments = __salt__[&quot;boto_apigateway.describe_api_deployments&quot;](
            restApiId=self.restApiId, **self._common_aws_args
        ).get(&quot;deployments&quot;)
        if deployments:
            for deployment in deployments:
                if deployment.get(&quot;description&quot;) == self.deployment_label_json:
                    return deployment.get(&quot;id&quot;)
        return &quot;&quot;

    def overwrite_stage_variables(self, ret, stage_variables):
        &quot;&quot;&quot;
        overwrite the given stage_name's stage variables with the given stage_variables
        &quot;&quot;&quot;
        res = __salt__[&quot;boto_apigateway.overwrite_api_stage_variables&quot;](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            variables=stage_variables,
            **self._common_aws_args
        )

        if not res.get(&quot;overwrite&quot;):
            ret[&quot;result&quot;] = False
            ret[&quot;abort&quot;] = True
            ret[&quot;comment&quot;] = res.get(&quot;error&quot;)
        else:
            ret = _log_changes(ret, &quot;overwrite_stage_variables&quot;, res.get(&quot;stage&quot;))
        return ret

    def _set_current_deployment(self, stage_desc_json, stage_variables):
        &quot;&quot;&quot;
        Helper method to associate the stage_name to the given deploymentId and make this current
        &quot;&quot;&quot;
        stage = __salt__[&quot;boto_apigateway.describe_api_stage&quot;](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            **self._common_aws_args
        ).get(&quot;stage&quot;)
        if not stage:
            stage = __salt__[&quot;boto_apigateway.create_api_stage&quot;](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                deploymentId=self._deploymentId,
                description=stage_desc_json,
                variables=stage_variables,
                **self._common_aws_args
            )
            if not stage.get(&quot;stage&quot;):
                return {&quot;set&quot;: False, &quot;error&quot;: stage.get(&quot;error&quot;)}
        else:
            # overwrite the stage variables
            overwrite = __salt__[&quot;boto_apigateway.overwrite_api_stage_variables&quot;](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                variables=stage_variables,
                **self._common_aws_args
            )
            if not overwrite.get(&quot;stage&quot;):
                return {&quot;set&quot;: False, &quot;error&quot;: overwrite.get(&quot;error&quot;)}

        return __salt__[&quot;boto_apigateway.activate_api_deployment&quot;](
            restApiId=self.restApiId,
            stageName=self._stage_name,
            deploymentId=self._deploymentId,
            **self._common_aws_args
        )

    def _resolve_api_id(self):
        &quot;&quot;&quot;
        returns an Api Id that matches the given api_name and the hardcoded _Swagger.AWS_API_DESCRIPTION
        as the api description
        &quot;&quot;&quot;
        apis = __salt__[&quot;boto_apigateway.describe_apis&quot;](
            name=self.rest_api_name,
            description=_Swagger.AWS_API_DESCRIPTION,
            **self._common_aws_args
        ).get(&quot;restapi&quot;)
        if apis:
            if len(apis) == 1:
                self.restApiId = apis[0].get(&quot;id&quot;)
            else:
                raise ValueError(
                    &quot;Multiple APIs matching given name {} and description {}&quot;.format(
                        self.rest_api_name, self.info_json
                    )
                )

    def delete_stage(self, ret):
        &quot;&quot;&quot;
        Method to delete the given stage_name.  If the current deployment tied to the given
        stage_name has no other stages associated with it, the deployment will be removed
        as well
        &quot;&quot;&quot;
        deploymentId = self._get_current_deployment_id()
        if deploymentId:
            result = __salt__[&quot;boto_apigateway.delete_api_stage&quot;](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                **self._common_aws_args
            )
            if not result.get(&quot;deleted&quot;):
                ret[&quot;abort&quot;] = True
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;delete_stage delete_api_stage, {}&quot;.format(
                    result.get(&quot;error&quot;)
                )
            else:
                # check if it is safe to delete the deployment as well.
                if not self._one_or_more_stages_remain(deploymentId):
                    result = __salt__[&quot;boto_apigateway.delete_api_deployment&quot;](
                        restApiId=self.restApiId,
                        deploymentId=deploymentId,
                        **self._common_aws_args
                    )
                    if not result.get(&quot;deleted&quot;):
                        ret[&quot;abort&quot;] = True
                        ret[&quot;result&quot;] = False
                        ret[
                            &quot;comment&quot;
                        ] = &quot;delete_stage delete_api_deployment, {}&quot;.format(
                            result.get(&quot;error&quot;)
                        )
                else:
                    ret[&quot;comment&quot;] = &quot;stage {} has been deleted.\n&quot;.format(
                        self._stage_name
                    )
        else:
            # no matching stage_name/deployment found
            ret[&quot;comment&quot;] = &quot;stage {} does not exist&quot;.format(self._stage_name)

        return ret

    def verify_api(self, ret):
        &quot;&quot;&quot;
        this method helps determine if the given stage_name is already on a deployment
        label matching the input api_name, swagger_file.

        If yes, returns abort with comment indicating already at desired state.
        If not and there is previous deployment labels in AWS matching the given input api_name and
        swagger file, indicate to the caller that we only need to reassociate stage_name to the
        previously existing deployment label.
        &quot;&quot;&quot;

        if self.restApiId:
            deployed_label_json = self._get_current_deployment_label()
            if deployed_label_json == self.deployment_label_json:
                ret[&quot;comment&quot;] = (
                    &quot;Already at desired state, the stage {} is already at the desired &quot;
                    &quot;deployment label:\n{}&quot;.format(
                        self._stage_name, deployed_label_json
                    )
                )
                ret[&quot;current&quot;] = True
                return ret
            else:
                self._deploymentId = self._get_desired_deployment_id()
                if self._deploymentId:
                    ret[&quot;publish&quot;] = True
        return ret

    def publish_api(self, ret, stage_variables):
        &quot;&quot;&quot;
        this method tie the given stage_name to a deployment matching the given swagger_file
        &quot;&quot;&quot;
        stage_desc = dict()
        stage_desc[&quot;current_deployment_label&quot;] = self.deployment_label
        stage_desc_json = _dict_to_json_pretty(stage_desc)

        if self._deploymentId:
            # just do a reassociate of stage_name to an already existing deployment
            res = self._set_current_deployment(stage_desc_json, stage_variables)
            if not res.get(&quot;set&quot;):
                ret[&quot;abort&quot;] = True
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = res.get(&quot;error&quot;)
            else:
                ret = _log_changes(
                    ret,
                    &quot;publish_api (reassociate deployment, set stage_variables)&quot;,
                    res.get(&quot;response&quot;),
                )
        else:
            # no deployment existed for the given swagger_file for this Swagger object
            res = __salt__[&quot;boto_apigateway.create_api_deployment&quot;](
                restApiId=self.restApiId,
                stageName=self._stage_name,
                stageDescription=stage_desc_json,
                description=self.deployment_label_json,
                variables=stage_variables,
                **self._common_aws_args
            )
            if not res.get(&quot;created&quot;):
                ret[&quot;abort&quot;] = True
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = res.get(&quot;error&quot;)
            else:
                ret = _log_changes(
                    ret, &quot;publish_api (new deployment)&quot;, res.get(&quot;deployment&quot;)
                )
        return ret

    def _cleanup_api(self):
        &quot;&quot;&quot;
        Helper method to clean up resources and models if we detected a change in the swagger file
        for a stage
        &quot;&quot;&quot;
        resources = __salt__[&quot;boto_apigateway.describe_api_resources&quot;](
            restApiId=self.restApiId, **self._common_aws_args
        )
        if resources.get(&quot;resources&quot;):
            res = resources.get(&quot;resources&quot;)[1:]
            res.reverse()
            for resource in res:
                delres = __salt__[&quot;boto_apigateway.delete_api_resources&quot;](
                    restApiId=self.restApiId,
                    path=resource.get(&quot;path&quot;),
                    **self._common_aws_args
                )
                if not delres.get(&quot;deleted&quot;):
                    return delres

        models = __salt__[&quot;boto_apigateway.describe_api_models&quot;](
            restApiId=self.restApiId, **self._common_aws_args
        )
        if models.get(&quot;models&quot;):
            for model in models.get(&quot;models&quot;):
                delres = __salt__[&quot;boto_apigateway.delete_api_model&quot;](
                    restApiId=self.restApiId,
                    modelName=model.get(&quot;name&quot;),
                    **self._common_aws_args
                )
                if not delres.get(&quot;deleted&quot;):
                    return delres

        return {&quot;deleted&quot;: True}

    def deploy_api(self, ret):
        &quot;&quot;&quot;
        this method create the top level rest api in AWS apigateway
        &quot;&quot;&quot;
        if self.restApiId:
            res = self._cleanup_api()
            if not res.get(&quot;deleted&quot;):
                ret[&quot;comment&quot;] = &quot;Failed to cleanup restAreId {}&quot;.format(self.restApiId)
                ret[&quot;abort&quot;] = True
                ret[&quot;result&quot;] = False
                return ret
            return ret

        response = __salt__[&quot;boto_apigateway.create_api&quot;](
            name=self.rest_api_name,
            description=_Swagger.AWS_API_DESCRIPTION,
            **self._common_aws_args
        )

        if not response.get(&quot;created&quot;):
            ret[&quot;result&quot;] = False
            ret[&quot;abort&quot;] = True
            if &quot;error&quot; in response:
                ret[&quot;comment&quot;] = &quot;Failed to create rest api: {}.&quot;.format(
                    response[&quot;error&quot;][&quot;message&quot;]
                )
            return ret

        self.restApiId = response.get(&quot;restapi&quot;, {}).get(&quot;id&quot;)

        return _log_changes(ret, &quot;deploy_api&quot;, response.get(&quot;restapi&quot;))

    def delete_api(self, ret):
        &quot;&quot;&quot;
        Method to delete a Rest Api named defined in the swagger file's Info Object's title value.

        ret
            a dictionary for returning status to Saltstack
        &quot;&quot;&quot;

        exists_response = __salt__[&quot;boto_apigateway.api_exists&quot;](
            name=self.rest_api_name,
            description=_Swagger.AWS_API_DESCRIPTION,
            **self._common_aws_args
        )
        if exists_response.get(&quot;exists&quot;):
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;Rest API named {} is set to be deleted.&quot;.format(
                    self.rest_api_name
                )
                ret[&quot;result&quot;] = None
                ret[&quot;abort&quot;] = True
                return ret

            delete_api_response = __salt__[&quot;boto_apigateway.delete_api&quot;](
                name=self.rest_api_name,
                description=_Swagger.AWS_API_DESCRIPTION,
                **self._common_aws_args
            )
            if not delete_api_response.get(&quot;deleted&quot;):
                ret[&quot;result&quot;] = False
                ret[&quot;abort&quot;] = True
                if &quot;error&quot; in delete_api_response:
                    ret[&quot;comment&quot;] = &quot;Failed to delete rest api: {}.&quot;.format(
                        delete_api_response[&quot;error&quot;][&quot;message&quot;]
                    )
                return ret

            ret = _log_changes(ret, &quot;delete_api&quot;, delete_api_response)
        else:
            ret[&quot;comment&quot;] = &quot;api already absent for swagger file: {}, desc: {}&quot;.format(
                self.rest_api_name, self.info_json
            )

        return ret

    def _aws_model_ref_from_swagger_ref(self, r):
        &quot;&quot;&quot;
        Helper function to reference models created on aws apigw
        &quot;&quot;&quot;
        model_name = r.split(&quot;/&quot;)[-1]
        return &quot;https://apigateway.amazonaws.com/restapis/{}/models/{}&quot;.format(
            self.restApiId, model_name
        )

    def _update_schema_to_aws_notation(self, schema):
        &quot;&quot;&quot;
        Helper function to map model schema to aws notation
        &quot;&quot;&quot;
        result = {}
        for k, v in schema.items():
            if k == &quot;$ref&quot;:
                v = self._aws_model_ref_from_swagger_ref(v)
            if isinstance(v, dict):
                v = self._update_schema_to_aws_notation(v)
            result[k] = v
        return result

    def _build_dependent_model_list(self, obj_schema):
        &quot;&quot;&quot;
        Helper function to build the list of models the given object schema is referencing.
        &quot;&quot;&quot;
        dep_models_list = []

        if obj_schema:
            obj_schema[&quot;type&quot;] = obj_schema.get(&quot;type&quot;, &quot;object&quot;)
        if obj_schema[&quot;type&quot;] == &quot;array&quot;:
            dep_models_list.extend(
                self._build_dependent_model_list(obj_schema.get(&quot;items&quot;, {}))
            )
        else:
            ref = obj_schema.get(&quot;$ref&quot;)
            if ref:
                ref_obj_model = ref.split(&quot;/&quot;)[-1]
                ref_obj_schema = self._models().get(ref_obj_model)
                dep_models_list.extend(self._build_dependent_model_list(ref_obj_schema))
                dep_models_list.extend([ref_obj_model])
            else:
                # need to walk each property object
                properties = obj_schema.get(&quot;properties&quot;)
                if properties:
                    for _, prop_obj_schema in properties.items():
                        dep_models_list.extend(
                            self._build_dependent_model_list(prop_obj_schema)
                        )
        return list(set(dep_models_list))

    def _build_all_dependencies(self):
        &quot;&quot;&quot;
        Helper function to build a map of model to their list of model reference dependencies
        &quot;&quot;&quot;
        ret = {}
        for model, schema in self._models().items():
            dep_list = self._build_dependent_model_list(schema)
            ret[model] = dep_list
        return ret

    def _get_model_without_dependencies(self, models_dict):
        &quot;&quot;&quot;
        Helper function to find the next model that should be created
        &quot;&quot;&quot;
        next_model = None
        if not models_dict:
            return next_model

        for model, dependencies in models_dict.items():
            if dependencies == []:
                next_model = model
                break

        if next_model is None:
            raise ValueError(
                &quot;incomplete model definitions, models in dependency &quot;
                &quot;list not defined: {}&quot;.format(models_dict)
            )

        # remove the model from other depednencies before returning
        models_dict.pop(next_model)
        for model, dep_list in models_dict.items():
            if next_model in dep_list:
                dep_list.remove(next_model)

        return next_model

    def deploy_models(self, ret):
        &quot;&quot;&quot;
        Method to deploy swagger file's definition objects and associated schema to AWS Apigateway as Models

        ret
            a dictionary for returning status to Saltstack
        &quot;&quot;&quot;

        for model, schema in self.models():
            # add in a few attributes into the model schema that AWS expects
            # _schema = schema.copy()
            _schema = self._update_schema_to_aws_notation(schema)
            _schema.update(
                {
                    &quot;$schema&quot;: _Swagger.JSON_SCHEMA_DRAFT_4,
                    &quot;title&quot;: &quot;{} Schema&quot;.format(model),
                }
            )

            # check to see if model already exists, aws has 2 default models [Empty, Error]
            # which may need upate with data from swagger file
            model_exists_response = __salt__[&quot;boto_apigateway.api_model_exists&quot;](
                restApiId=self.restApiId, modelName=model, **self._common_aws_args
            )

            if model_exists_response.get(&quot;exists&quot;):
                update_model_schema_response = __salt__[
                    &quot;boto_apigateway.update_api_model_schema&quot;
                ](
                    restApiId=self.restApiId,
                    modelName=model,
                    schema=_dict_to_json_pretty(_schema),
                    **self._common_aws_args
                )
                if not update_model_schema_response.get(&quot;updated&quot;):
                    ret[&quot;result&quot;] = False
                    ret[&quot;abort&quot;] = True
                    if &quot;error&quot; in update_model_schema_response:
                        ret[
                            &quot;comment&quot;
                        ] = &quot;Failed to update existing model {} with schema {}, &quot; &quot;error: {}&quot;.format(
                            model,
                            _dict_to_json_pretty(schema),
                            update_model_schema_response[&quot;error&quot;][&quot;message&quot;],
                        )
                    return ret

                ret = _log_changes(ret, &quot;deploy_models&quot;, update_model_schema_response)
            else:
                create_model_response = __salt__[&quot;boto_apigateway.create_api_model&quot;](
                    restApiId=self.restApiId,
                    modelName=model,
                    modelDescription=model,
                    schema=_dict_to_json_pretty(_schema),
                    contentType=&quot;application/json&quot;,
                    **self._common_aws_args
                )

                if not create_model_response.get(&quot;created&quot;):
                    ret[&quot;result&quot;] = False
                    ret[&quot;abort&quot;] = True
                    if &quot;error&quot; in create_model_response:
                        ret[
                            &quot;comment&quot;
                        ] = &quot;Failed to create model {}, schema {}, error: {}&quot;.format(
                            model,
                            _dict_to_json_pretty(schema),
                            create_model_response[&quot;error&quot;][&quot;message&quot;],
                        )
                    return ret

                ret = _log_changes(ret, &quot;deploy_models&quot;, create_model_response)

        return ret

    def _lambda_name(self, resourcePath, httpMethod):
        &quot;&quot;&quot;
        Helper method to construct lambda name based on the rule specified in doc string of
        boto_apigateway.api_present function
        &quot;&quot;&quot;
        lambda_name = self._lambda_funcname_format.format(
            stage=self._stage_name,
            api=self.rest_api_name,
            resource=resourcePath,
            method=httpMethod,
        )
        lambda_name = lambda_name.strip()
        lambda_name = re.sub(r&quot;{|}&quot;, &quot;&quot;, lambda_name)
        lambda_name = re.sub(r&quot;\s+|/&quot;, &quot;_&quot;, lambda_name).lower()
        return re.sub(r&quot;_+&quot;, &quot;_&quot;, lambda_name)

    def _lambda_uri(self, lambda_name, lambda_region):
        &quot;&quot;&quot;
        Helper Method to construct the lambda uri for use in method integration
        &quot;&quot;&quot;
        profile = self._common_aws_args.get(&quot;profile&quot;)
        region = self._common_aws_args.get(&quot;region&quot;)

        lambda_region = __utils__[&quot;boto3.get_region&quot;](&quot;lambda&quot;, lambda_region, profile)
        apigw_region = __utils__[&quot;boto3.get_region&quot;](&quot;apigateway&quot;, region, profile)

        lambda_desc = __salt__[&quot;boto_lambda.describe_function&quot;](
            lambda_name, **self._common_aws_args
        )

        if lambda_region != apigw_region:
            if not lambda_desc.get(&quot;function&quot;):
                # try look up in the same region as the apigateway as well if previous lookup failed
                lambda_desc = __salt__[&quot;boto_lambda.describe_function&quot;](
                    lambda_name, **self._common_aws_args
                )

        if not lambda_desc.get(&quot;function&quot;):
            raise ValueError(
                &quot;Could not find lambda function {} in regions [{}, {}].&quot;.format(
                    lambda_name, lambda_region, apigw_region
                )
            )

        lambda_arn = lambda_desc.get(&quot;function&quot;).get(&quot;FunctionArn&quot;)
        lambda_uri = (
            &quot;arn:aws:apigateway:{}:lambda:path/2015-03-31&quot;
            &quot;/functions/{}/invocations&quot;.format(apigw_region, lambda_arn)
        )
        return lambda_uri

    def _parse_method_data(self, method_name, method_data):
        &quot;&quot;&quot;
        Helper function to construct the method request params, models, request_templates and
        integration_type values needed to configure method request integration/mappings.
        &quot;&quot;&quot;
        method_params = {}
        method_models = {}
        if &quot;parameters&quot; in method_data:
            for param in method_data[&quot;parameters&quot;]:
                p = _Swagger.SwaggerParameter(param)
                if p.name:
                    method_params[p.name] = True
                if p.schema:
                    method_models[&quot;application/json&quot;] = p.schema

        request_templates = (
            _Swagger.REQUEST_OPTION_TEMPLATE
            if method_name == &quot;options&quot;
            else _Swagger.REQUEST_TEMPLATE
        )
        integration_type = &quot;MOCK&quot; if method_name == &quot;options&quot; else &quot;AWS&quot;

        return {
            &quot;params&quot;: method_params,
            &quot;models&quot;: method_models,
            &quot;request_templates&quot;: request_templates,
            &quot;integration_type&quot;: integration_type,
        }

    def _find_patterns(self, o):
        result = []
        if isinstance(o, dict):
            for k, v in o.items():
                if isinstance(v, dict):
                    result.extend(self._find_patterns(v))
                else:
                    if k == &quot;pattern&quot;:
                        result.append(v)
        return result

    def _get_pattern_for_schema(self, schema_name, httpStatus):
        &quot;&quot;&quot;
        returns the pattern specified in a response schema
        &quot;&quot;&quot;
        defaultPattern = &quot;.+&quot; if self._is_http_error_rescode(httpStatus) else &quot;.*&quot;
        model = self._models().get(schema_name)
        patterns = self._find_patterns(model)
        return patterns[0] if patterns else defaultPattern

    def _get_response_template(self, method_name, http_status):
        if method_name == &quot;options&quot; or not self._is_http_error_rescode(http_status):
            response_templates = (
                {&quot;application/json&quot;: self._response_template}
                if self._response_template
                else self.RESPONSE_OPTION_TEMPLATE
            )
        else:
            response_templates = (
                {&quot;application/json&quot;: self._error_response_template}
                if self._error_response_template
                else self.RESPONSE_TEMPLATE
            )
        return response_templates

    def _parse_method_response(self, method_name, method_response, httpStatus):
        &quot;&quot;&quot;
        Helper function to construct the method response params, models, and integration_params
        values needed to configure method response integration/mappings.
        &quot;&quot;&quot;
        method_response_models = {}
        method_response_pattern = &quot;.*&quot;
        if method_response.schema:
            method_response_models[&quot;application/json&quot;] = method_response.schema
            method_response_pattern = self._get_pattern_for_schema(
                method_response.schema, httpStatus
            )

        method_response_params = {}
        method_integration_response_params = {}
        for header in method_response.headers:
            response_header = &quot;method.response.header.{}&quot;.format(header)
            method_response_params[response_header] = False
            header_data = method_response.headers.get(header)
            method_integration_response_params[response_header] = (
                &quot;'{}'&quot;.format(header_data.get(&quot;default&quot;))
                if &quot;default&quot; in header_data
                else &quot;'*'&quot;
            )

        response_templates = self._get_response_template(method_name, httpStatus)

        return {
            &quot;params&quot;: method_response_params,
            &quot;models&quot;: method_response_models,
            &quot;integration_params&quot;: method_integration_response_params,
            &quot;pattern&quot;: method_response_pattern,
            &quot;response_templates&quot;: response_templates,
        }

    def _deploy_method(
        self,
        ret,
        resource_path,
        method_name,
        method_data,
        api_key_required,
        lambda_integration_role,
        lambda_region,
        authorization_type,
    ):
        &quot;&quot;&quot;
        Method to create a method for the given resource path, along with its associated
        request and response integrations.

        ret
            a dictionary for returning status to Saltstack

        resource_path
            the full resource path where the named method_name will be associated with.

        method_name
            a string that is one of the following values: 'delete', 'get', 'head', 'options',
            'patch', 'post', 'put'

        method_data
            the value dictionary for this method in the swagger definition file.

        api_key_required
            True or False, whether api key is required to access this method.

        lambda_integration_role
            name of the IAM role or IAM role arn that Api Gateway will assume when executing
            the associated lambda function

        lambda_region
            the region for the lambda function that Api Gateway will integrate to.

        authorization_type
            'NONE' or 'AWS_IAM'

        &quot;&quot;&quot;
        method = self._parse_method_data(method_name.lower(), method_data)

        # for options method to enable CORS, api_key_required will be set to False always.
        # authorization_type will be set to 'NONE' always.
        if method_name.lower() == &quot;options&quot;:
            api_key_required = False
            authorization_type = &quot;NONE&quot;

        m = __salt__[&quot;boto_apigateway.create_api_method&quot;](
            restApiId=self.restApiId,
            resourcePath=resource_path,
            httpMethod=method_name.upper(),
            authorizationType=authorization_type,
            apiKeyRequired=api_key_required,
            requestParameters=method.get(&quot;params&quot;),
            requestModels=method.get(&quot;models&quot;),
            **self._common_aws_args
        )
        if not m.get(&quot;created&quot;):
            ret = _log_error_and_abort(ret, m)
            return ret

        ret = _log_changes(ret, &quot;_deploy_method.create_api_method&quot;, m)

        lambda_uri = &quot;&quot;
        if method_name.lower() != &quot;options&quot;:
            lambda_uri = self._lambda_uri(
                self._lambda_name(resource_path, method_name),
                lambda_region=lambda_region,
            )

        # NOTE: integration method is set to POST always, as otherwise AWS makes wrong assumptions
        # about the intent of the call. HTTP method will be passed to lambda as part of the API gateway context
        integration = __salt__[&quot;boto_apigateway.create_api_integration&quot;](
            restApiId=self.restApiId,
            resourcePath=resource_path,
            httpMethod=method_name.upper(),
            integrationType=method.get(&quot;integration_type&quot;),
            integrationHttpMethod=&quot;POST&quot;,
            uri=lambda_uri,
            credentials=lambda_integration_role,
            requestTemplates=method.get(&quot;request_templates&quot;),
            **self._common_aws_args
        )
        if not integration.get(&quot;created&quot;):
            ret = _log_error_and_abort(ret, integration)
            return ret
        ret = _log_changes(ret, &quot;_deploy_method.create_api_integration&quot;, integration)

        if &quot;responses&quot; in method_data:
            for response, response_data in method_data[&quot;responses&quot;].items():
                httpStatus = str(response)
                method_response = self._parse_method_response(
                    method_name.lower(),
                    _Swagger.SwaggerMethodResponse(response_data),
                    httpStatus,
                )

                mr = __salt__[&quot;boto_apigateway.create_api_method_response&quot;](
                    restApiId=self.restApiId,
                    resourcePath=resource_path,
                    httpMethod=method_name.upper(),
                    statusCode=httpStatus,
                    responseParameters=method_response.get(&quot;params&quot;),
                    responseModels=method_response.get(&quot;models&quot;),
                    **self._common_aws_args
                )
                if not mr.get(&quot;created&quot;):
                    ret = _log_error_and_abort(ret, mr)
                    return ret
                ret = _log_changes(ret, &quot;_deploy_method.create_api_method_response&quot;, mr)

                mir = __salt__[&quot;boto_apigateway.create_api_integration_response&quot;](
                    restApiId=self.restApiId,
                    resourcePath=resource_path,
                    httpMethod=method_name.upper(),
                    statusCode=httpStatus,
                    selectionPattern=method_response.get(&quot;pattern&quot;),
                    responseParameters=method_response.get(&quot;integration_params&quot;),
                    responseTemplates=method_response.get(&quot;response_templates&quot;),
                    **self._common_aws_args
                )
                if not mir.get(&quot;created&quot;):
                    ret = _log_error_and_abort(ret, mir)
                    return ret
                ret = _log_changes(
                    ret, &quot;_deploy_method.create_api_integration_response&quot;, mir
                )
        else:
            raise ValueError(
                &quot;No responses specified for {} {}&quot;.format(resource_path, method_name)
            )

        return ret

    def deploy_resources(
        self,
        ret,
        api_key_required,
        lambda_integration_role,
        lambda_region,
        authorization_type,
    ):
        &quot;&quot;&quot;
        Method to deploy resources defined in the swagger file.

        ret
            a dictionary for returning status to Saltstack

        api_key_required
            True or False, whether api key is required to access this method.

        lambda_integration_role
            name of the IAM role or IAM role arn that Api Gateway will assume when executing
            the associated lambda function

        lambda_region
            the region for the lambda function that Api Gateway will integrate to.

        authorization_type
            'NONE' or 'AWS_IAM'
        &quot;&quot;&quot;

        for path, pathData in self.paths:
            resource = __salt__[&quot;boto_apigateway.create_api_resources&quot;](
                restApiId=self.restApiId, path=path, **self._common_aws_args
            )
            if not resource.get(&quot;created&quot;):
                ret = _log_error_and_abort(ret, resource)
                return ret
            ret = _log_changes(ret, &quot;deploy_resources&quot;, resource)
            for method, method_data in pathData.items():
                if method in _Swagger.SWAGGER_OPERATION_NAMES:
                    ret = self._deploy_method(
                        ret,
                        path,
                        method,
                        method_data,
                        api_key_required,
                        lambda_integration_role,
                        lambda_region,
                        authorization_type,
                    )
        return ret


def usage_plan_present(
    name,
    plan_name,
    description=None,
    throttle=None,
    quota=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure the spcifieda usage plan with the corresponding metrics is deployed

    .. versionadded:: 2017.7.0

    name
        name of the state

    plan_name
        [Required] name of the usage plan

    throttle
        [Optional] throttling parameters expressed as a dictionary.
        If provided, at least one of the throttling parameters must be present

        rateLimit
            rate per second at which capacity bucket is populated

        burstLimit
            maximum rate allowed

    quota
        [Optional] quota on the number of api calls permitted by the plan.
        If provided, limit and period must be present

        limit
            [Required] number of calls permitted per quota period

        offset
            [Optional] number of calls to be subtracted from the limit at the beginning of the period

        period
            [Required] period to which quota applies. Must be DAY, WEEK or MONTH

    .. code-block:: yaml

        UsagePlanPresent:
          boto_apigateway.usage_plan_present:
            - plan_name: my_usage_plan
            - throttle:
                rateLimit: 70
                burstLimit: 100
            - quota:
                limit: 1000
                offset: 0
                period: DAY
            - profile: my_profile

    &quot;&quot;&quot;
    func_params = locals()

    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    try:
        common_args = dict(
            [(&quot;region&quot;, region), (&quot;key&quot;, key), (&quot;keyid&quot;, keyid), (&quot;profile&quot;, profile)]
        )

        existing = __salt__[&quot;boto_apigateway.describe_usage_plans&quot;](
            name=plan_name, **common_args
        )
        if &quot;error&quot; in existing:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to describe existing usage plans&quot;
            return ret

        if not existing[&quot;plans&quot;]:
            # plan does not exist, we need to create it
            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] = &quot;a new usage plan {} would be created&quot;.format(
                    plan_name
                )
                ret[&quot;result&quot;] = None
                return ret

            result = __salt__[&quot;boto_apigateway.create_usage_plan&quot;](
                name=plan_name,
                description=description,
                throttle=throttle,
                quota=quota,
                **common_args
            )
            if &quot;error&quot; in result:
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to create a usage plan {}, {}&quot;.format(
                    plan_name, result[&quot;error&quot;]
                )
                return ret

            ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;plan&quot;: None}
            ret[&quot;comment&quot;] = &quot;A new usage plan {} has been created&quot;.format(plan_name)

        else:
            # need an existing plan modified to match given value
            plan = existing[&quot;plans&quot;][0]
            needs_updating = False

            modifiable_params = (
                (&quot;throttle&quot;, (&quot;rateLimit&quot;, &quot;burstLimit&quot;)),
                (&quot;quota&quot;, (&quot;limit&quot;, &quot;offset&quot;, &quot;period&quot;)),
            )
            for p, fields in modifiable_params:
                for f in fields:
                    actual_param = (
                        {} if func_params.get(p) is None else func_params.get(p)
                    )
                    if plan.get(p, {}).get(f, None) != actual_param.get(f, None):
                        needs_updating = True
<A NAME="0"></A>                        break

            if not needs_updating:
                ret<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match296926-1.html#0',3,'match296926-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;comment&quot;] = &quot;usage plan {} is already in a correct state&quot;.format(
                    plan_name
                )
                ret[&quot;result&quot;] = True
                return ret

            if __opts__[&quot;test&quot;]:
                ret[&quot;comment&quot;] =</B></FONT> &quot;a new usage plan {} would be updated&quot;.format(
                    plan_name
                )
                ret[&quot;result&quot;] = None
                return ret

            result = __salt__[&quot;boto_apigateway.update_usage_plan&quot;](
                plan[&quot;id&quot;], throttle=throttle, quota=quota, **common_args
            )
            if &quot;error&quot; in result:
                ret[&quot;result&quot;] = False
                ret[&quot;comment&quot;] = &quot;Failed to update a usage plan {}, {}&quot;.format(
                    plan_name, result[&quot;error&quot;]
                )
                return ret

            ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;plan&quot;: plan}
            ret[&quot;comment&quot;] = &quot;usage plan {} has been updated&quot;.format(plan_name)

        newstate = __salt__[&quot;boto_apigateway.describe_usage_plans&quot;](
            name=plan_name, **common_args
        )
        if &quot;error&quot; in existing:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to describe existing usage plans after updates&quot;
            return ret

        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;plan&quot;: newstate[&quot;plans&quot;][0]}

    except (ValueError, OSError) as e:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;{}&quot;.format(e.args)

    return ret


def usage_plan_absent(name, plan_name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Ensures usage plan identified by name is no longer present

    .. versionadded:: 2017.7.0

    name
        name of the state

    plan_name
        name of the plan to remove

    .. code-block:: yaml

        usage plan absent:
          boto_apigateway.usage_plan_absent:
            - plan_name: my_usage_plan
            - profile: my_profile

    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    try:
        common_args = dict(
            [(&quot;region&quot;, region), (&quot;key&quot;, key), (&quot;keyid&quot;, keyid), (&quot;profile&quot;, profile)]
        )

        existing = __salt__[&quot;boto_apigateway.describe_usage_plans&quot;](
            name=plan_name, **common_args
        )
        if &quot;error&quot; in existing:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to describe existing usage plans&quot;
            return ret

        if not existing[&quot;plans&quot;]:
            ret[&quot;comment&quot;] = &quot;Usage plan {} does not exist already&quot;.format(plan_name)
            return ret

        if __opts__[&quot;test&quot;]:
            ret[&quot;comment&quot;] = &quot;Usage plan {} exists and would be deleted&quot;.format(
                plan_name
            )
            ret[&quot;result&quot;] = None
            return ret

        plan_id = existing[&quot;plans&quot;][0][&quot;id&quot;]
        result = __salt__[&quot;boto_apigateway.delete_usage_plan&quot;](plan_id, **common_args)

        if &quot;error&quot; in result:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to delete usage plan {}, {}&quot;.format(
                plan_name, result
            )
            return ret

        ret[&quot;comment&quot;] = &quot;Usage plan {} has been deleted&quot;.format(plan_name)
        ret[&quot;changes&quot;][&quot;old&quot;] = {&quot;plan&quot;: existing[&quot;plans&quot;][0]}
        ret[&quot;changes&quot;][&quot;new&quot;] = {&quot;plan&quot;: None}

    except (ValueError, OSError) as e:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;{}&quot;.format(e.args)

    return ret


def usage_plan_association_present(
    name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Ensures usage plan identified by name is added to provided api_stages

    .. versionadded:: 2017.7.0

    name
        name of the state

    plan_name
        name of the plan to use

    api_stages
        list of dictionaries, where each dictionary consists of the following keys:

        apiId
            apiId of the api to attach usage plan to

        stage
            stage name of the api to attach usage plan to

    .. code-block:: yaml

        UsagePlanAssociationPresent:
          boto_apigateway.usage_plan_association_present:
            - plan_name: my_plan
            - api_stages:
              - apiId: 9kb0404ec0
                stage: my_stage
              - apiId: l9v7o2aj90
                stage: my_stage
            - profile: my_profile

    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    try:
        common_args = dict(
            [(&quot;region&quot;, region), (&quot;key&quot;, key), (&quot;keyid&quot;, keyid), (&quot;profile&quot;, profile)]
        )

        existing = __salt__[&quot;boto_apigateway.describe_usage_plans&quot;](
            name=plan_name, **common_args
        )
        if &quot;error&quot; in existing:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to describe existing usage plans&quot;
            return ret

        if not existing[&quot;plans&quot;]:
            ret[&quot;comment&quot;] = &quot;Usage plan {} does not exist&quot;.format(plan_name)
            ret[&quot;result&quot;] = False
            return ret

        if len(existing[&quot;plans&quot;]) != 1:
            ret[&quot;comment&quot;] = (
                &quot;There are multiple usage plans with the same name - it is not&quot;
                &quot; supported&quot;
            )
            ret[&quot;result&quot;] = False
            return ret

        plan = existing[&quot;plans&quot;][0]
        plan_id = plan[&quot;id&quot;]
        plan_stages = plan.get(&quot;apiStages&quot;, [])

        stages_to_add = []
        for api in api_stages:
            if api not in plan_stages:
                stages_to_add.append(api)

        if not stages_to_add:
            ret[&quot;comment&quot;] = &quot;Usage plan is already asssociated to all api stages&quot;
            return ret

        result = __salt__[&quot;boto_apigateway.attach_usage_plan_to_apis&quot;](
            plan_id, stages_to_add, **common_args
        )
        if &quot;error&quot; in result:
            ret[
                &quot;comment&quot;
            ] = &quot;Failed to associate a usage plan {} to the apis {}, {}&quot;.format(
                plan_name, stages_to_add, result[&quot;error&quot;]
            )
            ret[&quot;result&quot;] = False
            return ret

        ret[&quot;comment&quot;] = &quot;successfully associated usage plan to apis&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = plan_stages
        ret[&quot;changes&quot;][&quot;new&quot;] = result.get(&quot;result&quot;, {}).get(&quot;apiStages&quot;, [])

    except (ValueError, OSError) as e:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;{}&quot;.format(e.args)

    return ret


def usage_plan_association_absent(
    name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Ensures usage plan identified by name is removed from provided api_stages
    If a plan is associated to stages not listed in api_stages parameter,
    those associations remain intact.

    .. versionadded:: 2017.7.0

    name
        name of the state

    plan_name
        name of the plan to use

    api_stages
        list of dictionaries, where each dictionary consists of the following keys:

        apiId
            apiId of the api to detach usage plan from

        stage
            stage name of the api to detach usage plan from

    .. code-block:: yaml

        UsagePlanAssociationAbsent:
          boto_apigateway.usage_plan_association_absent:
            - plan_name: my_plan
            - api_stages:
              - apiId: 9kb0404ec0
                stage: my_stage
              - apiId: l9v7o2aj90
                stage: my_stage
            - profile: my_profile

    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}
    try:
        common_args = dict(
            [(&quot;region&quot;, region), (&quot;key&quot;, key), (&quot;keyid&quot;, keyid), (&quot;profile&quot;, profile)]
        )

        existing = __salt__[&quot;boto_apigateway.describe_usage_plans&quot;](
            name=plan_name, **common_args
        )
        if &quot;error&quot; in existing:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to describe existing usage plans&quot;
            return ret

        if not existing[&quot;plans&quot;]:
            ret[&quot;comment&quot;] = &quot;Usage plan {} does not exist&quot;.format(plan_name)
            ret[&quot;result&quot;] = False
            return ret

        if len(existing[&quot;plans&quot;]) != 1:
            ret[&quot;comment&quot;] = (
                &quot;There are multiple usage plans with the same name - it is not&quot;
                &quot; supported&quot;
            )
            ret[&quot;result&quot;] = False
            return ret

        plan = existing[&quot;plans&quot;][0]
        plan_id = plan[&quot;id&quot;]
        plan_stages = plan.get(&quot;apiStages&quot;, [])

        if not plan_stages:
            ret[&quot;comment&quot;] = &quot;Usage plan {} has no associated stages already&quot;.format(
                plan_name
            )
            return ret

        stages_to_remove = []
        for api in api_stages:
            if api in plan_stages:
                stages_to_remove.append(api)

        if not stages_to_remove:
            ret[&quot;comment&quot;] = &quot;Usage plan is already not asssociated to any api stages&quot;
            return ret

        result = __salt__[&quot;boto_apigateway.detach_usage_plan_from_apis&quot;](
            plan_id, stages_to_remove, **common_args
        )
        if &quot;error&quot; in result:
            ret[
                &quot;comment&quot;
            ] = &quot;Failed to disassociate a usage plan {} from the apis {}, {}&quot;.format(
                plan_name, stages_to_remove, result[&quot;error&quot;]
            )
            ret[&quot;result&quot;] = False
            return ret

        ret[&quot;comment&quot;] = &quot;successfully disassociated usage plan from apis&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = plan_stages
        ret[&quot;changes&quot;][&quot;new&quot;] = result.get(&quot;result&quot;, {}).get(&quot;apiStages&quot;, [])

    except (ValueError, OSError) as e:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;{}&quot;.format(e.args)

    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>junos_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module to interact with Junos devices.

:maturity: new
:dependencies: junos-eznc, jxmlease

.. note::

    Those who wish to use junos-eznc (PyEZ) version &gt;= 2.1.0, must
    use the latest salt code from github until the next release.

Refer to :mod:`junos &lt;salt.proxy.junos&gt;` for information on connecting to junos proxy.

&quot;&quot;&quot;

import copy
import json
import logging
import os
import re
from functools import wraps

import salt.utils.args
import salt.utils.files
import salt.utils.json
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import yaml

try:
    from lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree


# Juniper interface libraries
# https://github.com/Juniper/py-junos-eznc
try:
    # pylint: disable=W0611
    import jnpr.junos.cfg
    import jnpr.junos.op as tables_dir
    import jnpr.junos.utils
    import jxmlease
    import yamlordereddictloader
    from jnpr.junos import Device
    from jnpr.junos.exception import (
        ConnectClosedError,
        LockError,
        RpcTimeoutError,
        UnlockError,
    )
    from jnpr.junos.factory.cfgtable import CfgTable
    from jnpr.junos.factory.factory_loader import FactoryLoader
    from jnpr.junos.factory.optable import OpTable
    from jnpr.junos.utils.config import Config
    from jnpr.junos.utils.scp import SCP
    from jnpr.junos.utils.sw import SW

    # pylint: enable=W0611
    HAS_JUNOS = True
except ImportError:
    HAS_JUNOS = False

# Set up logging
log = logging.getLogger(__name__)

# Define the module's virtual name
__virtualname__ = &quot;junos&quot;

__proxyenabled__ = [&quot;junos&quot;]


def __virtual__():
    &quot;&quot;&quot;
    We need the Junos adapter libraries for this
    module to work.  We also need a proxymodule entry in __opts__
    in the opts dictionary
    &quot;&quot;&quot;
    if HAS_JUNOS and &quot;proxy&quot; in __opts__:
        return __virtualname__
    else:
        return (
            False,
            &quot;The junos or dependent module could not be loaded: &quot;
            &quot;junos-eznc or jxmlease or yamlordereddictloader or &quot;
            &quot;proxy could not be loaded.&quot;,
        )


class HandleFileCopy:
    &quot;&quot;&quot;
    To figure out proper path either from proxy local file system
    or proxy cache or on master. If required, then only copy from
    master to proxy

    &quot;&quot;&quot;

    def __init__(self, path, **kwargs):
        self._file_path = path
        self._cached_folder = None
        self._cached_file = None
        self._kwargs = kwargs

    def __enter__(self):
        if self._file_path.startswith(&quot;salt://&quot;):
            # check if file exists in cache
            local_cache_path = __salt__[&quot;cp.is_cached&quot;](self._file_path)
            if local_cache_path:
                master_hash = __salt__[&quot;cp.hash_file&quot;](self._file_path)
                proxy_hash = __salt__[&quot;file.get_hash&quot;](local_cache_path)
                # check if hash is same, else copy newly
                if master_hash.get(&quot;hsum&quot;) == proxy_hash:
                    self._cached_file = salt.utils.files.mkstemp()
                    # local copy is a template, hence need to render
                    with salt.utils.files.fopen(self._cached_file, &quot;w&quot;) as fp:
                        template_string = __salt__[&quot;slsutil.renderer&quot;](
                            path=local_cache_path,
                            default_renderer=&quot;jinja&quot;,
                            **self._kwargs,
                        )
                        fp.write(template_string)
                    return self._cached_file

            # continue for else part
            self._cached_file = salt.utils.files.mkstemp()
            __salt__[&quot;cp.get_template&quot;](
                self._file_path, self._cached_file, **self._kwargs
            )
            if self._cached_file != &quot;&quot;:
                return self._cached_file
        else:
            # check for local location of file
            if __salt__[&quot;file.file_exists&quot;](self._file_path):
                self._cached_file = salt.utils.files.mkstemp()
                with salt.utils.files.fopen(self._cached_file, &quot;w&quot;) as fp:
                    template_string = __salt__[&quot;slsutil.renderer&quot;](
                        path=self._file_path, default_renderer=&quot;jinja&quot;, **self._kwargs
                    )
                    fp.write(template_string)
                return self._cached_file

    def __exit__(self, exc_type, exc_value, exc_traceback):
        if self._cached_file is not None:
            salt.utils.files.safe_rm(self._cached_file)
            log.debug(&quot;Deleted cached file: %s&quot;, self._cached_file)
        if self._cached_folder is not None:
            __salt__[&quot;file.rmdir&quot;](self._cached_folder)
            log.debug(&quot;Deleted cached folder: %s&quot;, self._cached_folder)


def _timeout_decorator(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        if &quot;dev_timeout&quot; in kwargs or &quot;timeout&quot; in kwargs:
            ldev_timeout = max(kwargs.pop(&quot;dev_timeout&quot;, 0), kwargs.pop(&quot;timeout&quot;, 0))
            conn = __proxy__[&quot;junos.conn&quot;]()
            restore_timeout = conn.timeout
            conn.timeout = ldev_timeout
            try:
                result = function(*args, **kwargs)
                conn.timeout = restore_timeout
                return result
            except Exception:  # pylint: disable=broad-except
                conn.timeout = restore_timeout
                raise
        else:
            return function(*args, **kwargs)

    return wrapper


def _timeout_decorator_cleankwargs(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        if &quot;dev_timeout&quot; in kwargs or &quot;timeout&quot; in kwargs:
            ldev_timeout = max(kwargs.pop(&quot;dev_timeout&quot;, 0), kwargs.pop(&quot;timeout&quot;, 0))
            conn = __proxy__[&quot;junos.conn&quot;]()
            restore_timeout = conn.timeout
            conn.timeout = ldev_timeout
            try:
                restore_kwargs = False
                del_list = []
                op = {}
                op.update(kwargs)
                for keychk in kwargs:
                    if keychk.startswith(&quot;__pub&quot;):
                        del_list.append(keychk)
                if del_list:
                    restore_kwargs = True
                    for delkey in del_list:
                        kwargs.pop(delkey)

                result = function(*args, **kwargs)
                if restore_kwargs:
                    kwargs.update(op)

                conn.timeout = restore_timeout
                return result
            except Exception:  # pylint: disable=broad-except
                conn.timeout = restore_timeout
                raise
        else:
            restore_kwargs = False
            del_list = []
            op = {}
            op.update(kwargs)
            for keychk in kwargs:
                if keychk.startswith(&quot;__pub&quot;):
                    del_list.append(keychk)
            if del_list:
                restore_kwargs = True
                for delkey in del_list:
                    kwargs.pop(delkey)

            ret = function(*args, **kwargs)
            if restore_kwargs:
                kwargs.update(op)

            return ret

    return wrapper


def _restart_connection():
    minion_id = __opts__.get(&quot;proxyid&quot;, &quot;&quot;) or __opts__.get(&quot;id&quot;, &quot;&quot;)
    log.info(
        &quot;Junos exception occurred %s (junos proxy) is down. Restarting.&quot;, minion_id
    )
    __salt__[&quot;event.fire_master&quot;](
        {}, &quot;junos/proxy/{}/stop&quot;.format(__opts__[&quot;proxy&quot;][&quot;host&quot;])
    )
    __proxy__[&quot;junos.shutdown&quot;](__opts__)  # safely close connection
    __proxy__[&quot;junos.init&quot;](__opts__)  # reopen connection
    log.debug(&quot;Junos exception occurred, restarted %s (junos proxy)!&quot;, minion_id)


@_timeout_decorator_cleankwargs
def facts_refresh():
    &quot;&quot;&quot;
    Reload the facts dictionary from the device. Usually only needed if,
    the device configuration is changed by some other actor.
    This function will also refresh the facts stored in the salt grains.

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.facts_refresh
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True
    try:
        conn.facts_refresh()
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Execution failed due to &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret

    ret[&quot;facts&quot;] = __proxy__[&quot;junos.get_serialized_facts&quot;]()

    try:
        __salt__[&quot;saltutil.sync_grains&quot;]()
    except Exception as exception:  # pylint: disable=broad-except
        log.error('Grains could not be updated due to &quot;%s&quot;', exception)

    return ret


def facts():
    &quot;&quot;&quot;
    Displays the facts gathered during the connection.
    These facts are also stored in Salt grains.

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.facts
    &quot;&quot;&quot;
    ret = {}
    try:
        ret[&quot;facts&quot;] = __proxy__[&quot;junos.get_serialized_facts&quot;]()
        ret[&quot;out&quot;] = True
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not display facts due to &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()

    return ret


@_timeout_decorator
def rpc(cmd=None, dest=None, **kwargs):
    &quot;&quot;&quot;
    This function executes the RPC provided as arguments on the junos device.
    The returned data can be stored in a file.

    cmd
        The RPC to be executed

    dest
        Destination file where the RPC output is stored. Note that the file
        will be stored on the proxy minion. To push the files to the master use
        :py:func:`cp.push &lt;salt.modules.cp.push&gt;`.

    format : xml
        The format in which the RPC reply is received from the device

    dev_timeout : 30
        The NETCONF RPC timeout (in seconds)

    filter
        Used with the ``get-config`` RPC to get specific configuration

    terse : False
        Amount of information you want

    interface_name
      Name of the interface to query

    CLI Example:

    .. code-block:: bash

        salt 'device' junos.rpc get_config dest=/var/log/config.txt format=text filter='&lt;configuration&gt;&lt;system/&gt;&lt;/configuration&gt;'
        salt 'device' junos.rpc get-interface-information dest=/home/user/interface.xml interface_name='lo0' terse=True
        salt 'device' junos.rpc get-chassis-inventory
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True

    op = dict()
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    elif &quot;__pub_schedule&quot; in kwargs:
        for key, value in kwargs.items():
            if not key.startswith(&quot;__pub_&quot;):
                op[key] = value
    else:
        op.update(kwargs)

    if cmd is None:
        ret[&quot;message&quot;] = &quot;Please provide the rpc to execute.&quot;
        ret[&quot;out&quot;] = False
        return ret

    format_ = op.pop(&quot;format&quot;, &quot;xml&quot;)
    # dest becomes part of op via __pub_arg if not None
    # rpc commands objecting to dest as part of op
    op.pop(&quot;dest&quot;, dest)

    if cmd in [&quot;get-config&quot;, &quot;get_config&quot;]:
        filter_reply = None
        if &quot;filter&quot; in op:
            try:
                filter_reply = etree.XML(op[&quot;filter&quot;])
            except etree.XMLSyntaxError as ex:
                ret[&quot;message&quot;] = &quot;Invalid filter: {}&quot;.format(str(ex))
                ret[&quot;out&quot;] = False
                return ret

            del op[&quot;filter&quot;]

        op.update({&quot;format&quot;: format_})
        try:
            reply = getattr(conn.rpc, cmd.replace(&quot;-&quot;, &quot;_&quot;))(filter_reply, options=op)
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;message&quot;] = 'RPC execution failed due to &quot;{}&quot;'.format(exception)
            ret[&quot;out&quot;] = False
            _restart_connection()
            return ret
    else:
        if &quot;filter&quot; in op:
            log.warning('Filter ignored as it is only used with &quot;get-config&quot; rpc')

        if &quot;dest&quot; in op:
            log.warning(&quot;dest in op, rpc may reject this for cmd '%s'&quot;, cmd)

        try:
            reply = getattr(conn.rpc, cmd.replace(&quot;-&quot;, &quot;_&quot;))({&quot;format&quot;: format_}, **op)
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;message&quot;] = 'RPC execution failed due to &quot;{}&quot;'.format(exception)
            ret[&quot;out&quot;] = False
            _restart_connection()
            return ret

    if format_ == &quot;text&quot;:
        ret[&quot;rpc_reply&quot;] = reply.text
    elif format_ == &quot;json&quot;:
        ret[&quot;rpc_reply&quot;] = reply
    else:
        ret[&quot;rpc_reply&quot;] = jxmlease.parse(etree.tostring(reply))

    if dest:
        if format_ == &quot;text&quot;:
            write_response = reply.text
        elif format_ == &quot;json&quot;:
            write_response = salt.utils.json.dumps(reply, indent=1)
        else:
            write_response = etree.tostring(reply)
        with salt.utils.files.fopen(dest, &quot;w&quot;) as fp:
            fp.write(salt.utils.stringutils.to_str(write_response))

    return ret


@_timeout_decorator
def set_hostname(hostname=None, **kwargs):
    &quot;&quot;&quot;
    Set the device's hostname

    hostname
        The name to be set

    comment
        Provide a comment to the commit

    dev_timeout : 30
        The NETCONF RPC timeout (in seconds)

    confirm
      Provide time in minutes for commit confirmation. If this option is
      specified, the commit will be rolled back in the specified amount of time
      unless the commit is confirmed.

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.set_hostname salt-device
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    if hostname is None:
        ret[&quot;message&quot;] = &quot;Please provide the hostname.&quot;
        ret[&quot;out&quot;] = False
        return ret

    op = dict()
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    # Added to recent versions of JunOs
    # Use text format instead
    set_string = &quot;set system host-name {}&quot;.format(hostname)
    try:
        conn.cu.load(set_string, format=&quot;set&quot;)
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not load configuration due to error &quot;{}&quot;'.format(
            exception
        )
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret

    try:
        commit_ok = conn.cu.commit_check()
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not commit check due to error &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret

    if commit_ok:
        try:
            conn.cu.commit(**op)
            ret[&quot;message&quot;] = &quot;Successfully changed hostname.&quot;
            ret[&quot;out&quot;] = True
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;out&quot;] = False
            ret[
                &quot;message&quot;
            ] = 'Successfully loaded host-name but commit failed with &quot;{}&quot;'.format(
                exception
            )
            _restart_connection()
            return ret
    else:
        ret[&quot;out&quot;] = False
        ret[&quot;message&quot;] = &quot;Successfully loaded host-name but pre-commit check failed.&quot;
        try:
            conn.cu.rollback()
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;out&quot;] = False
            ret[
                &quot;message&quot;
            ] = 'Successfully loaded host-name but rollback before exit failed &quot;{}&quot;'.format(
                exception
            )
            _restart_connection()

    return ret


@_timeout_decorator
def commit(**kwargs):
    &quot;&quot;&quot;
    To commit the changes loaded in the candidate configuration.

    dev_timeout : 30
        The NETCONF RPC timeout (in seconds)

    comment
      Provide a comment for the commit

    confirm
      Provide time in minutes for commit confirmation. If this option is
      specified, the commit will be rolled back in the specified amount of time
      unless the commit is confirmed.

    sync : False
      When ``True``, on dual control plane systems, requests that the candidate
      configuration on one control plane be copied to the other control plane,
      checked for correct syntax, and committed on both Routing Engines.

    force_sync : False
      When ``True``, on dual control plane systems, force the candidate
      configuration on one control plane to be copied to the other control
      plane.

    full
      When ``True``, requires all the daemons to check and evaluate the new
      configuration.

    detail
      When ``True``, return commit detail

    CLI Examples:

    .. code-block:: bash

        salt 'device_name' junos.commit comment='Commiting via saltstack' detail=True
        salt 'device_name' junos.commit dev_timeout=60 confirm=10
        salt 'device_name' junos.commit sync=True dev_timeout=90
    &quot;&quot;&quot;

    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    op = dict()
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    op[&quot;detail&quot;] = op.get(&quot;detail&quot;, False)

    try:
        commit_ok = conn.cu.commit_check()
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not perform commit check due to &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret

    if commit_ok:
        try:
            commit = conn.cu.commit(**op)
            ret[&quot;out&quot;] = True
            if commit:
                if op[&quot;detail&quot;]:
                    ret[&quot;message&quot;] = jxmlease.parse(etree.tostring(commit))
                else:
                    ret[&quot;message&quot;] = &quot;Commit Successful.&quot;
            else:
                ret[&quot;message&quot;] = &quot;Commit failed.&quot;
                ret[&quot;out&quot;] = False
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;out&quot;] = False
            ret[
                &quot;message&quot;
            ] = 'Commit check succeeded but actual commit failed with &quot;{}&quot;'.format(
                exception
            )
            _restart_connection()
    else:
        ret[&quot;out&quot;] = False
        ret[&quot;message&quot;] = &quot;Pre-commit check failed.&quot;
        try:
            conn.cu.rollback()
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;out&quot;] = False
            ret[
                &quot;message&quot;
            ] = 'Pre-commit check failed, and exception during rollback &quot;{}&quot;'.format(
                exception
            )
            _restart_connection()

    return ret


@_timeout_decorator
def rollback(**kwargs):
    &quot;&quot;&quot;
    Roll back the last committed configuration changes and commit

    id : 0
        The rollback ID value (0-49)

    d_id : 0
        The rollback ID value (0-49)

    dev_timeout : 30
        The NETCONF RPC timeout (in seconds)

    comment
      Provide a comment for the commit

    confirm
      Provide time in minutes for commit confirmation. If this option is
      specified, the commit will be rolled back in the specified amount of time
      unless the commit is confirmed.

    diffs_file
      Path to the file where the diff (difference in old configuration and the
      committed configuration) will be stored. Note that the file will be
      stored on the proxy minion. To push the files to the master use
      :py:func:`cp.push &lt;salt.modules.cp.push&gt;`.

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.rollback 10

    NOTE: Because of historical reasons and the internals of the Salt state
    compiler, there are three possible sources of the rollback ID--the
    positional argument, and the `id` and `d_id` kwargs.  The precedence of
    the arguments are `id` (positional), `id` (kwarg), `d_id` (kwarg).  In
    other words, if all three are passed, only the positional argument
    will be used.  A warning is logged if more than one is passed.
    &quot;&quot;&quot;
    ids_passed = 0
    id_ = 0
    if &quot;d_id&quot; in kwargs:
        id_ = kwargs.pop(&quot;d_id&quot;)
        ids_passed = ids_passed + 1
    if &quot;id&quot; in kwargs:
        id_ = kwargs.pop(&quot;id&quot;, 0)
        ids_passed = ids_passed + 1

    if ids_passed &gt; 1:
        log.warning(
            &quot;junos.rollback called with more than one possible ID. &quot;
            &quot;Use only one of the positional argument, `id`, or `d_id` kwargs&quot;
        )

    ret = {}
    conn = __proxy__[&quot;junos.conn&quot;]()

    op = dict()
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    try:
        ret[&quot;out&quot;] = conn.cu.rollback(id_)
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Rollback failed due to &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret

    if ret[&quot;out&quot;]:
        ret[&quot;message&quot;] = &quot;Rollback successful&quot;
    else:
        ret[&quot;message&quot;] = &quot;Rollback failed&quot;
        return ret

    if &quot;diffs_file&quot; in op and op[&quot;diffs_file&quot;] is not None:
        diff = conn.cu.diff()
        if diff is not None:
            with salt.utils.files.fopen(op[&quot;diffs_file&quot;], &quot;w&quot;) as fp:
                fp.write(salt.utils.stringutils.to_str(diff))
        else:
            log.info(
                &quot;No diff between current configuration and &quot;
                &quot;rollbacked configuration, so no diff file created&quot;
            )

    try:
        commit_ok = conn.cu.commit_check()
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not commit check due to &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret

    if commit_ok:
        try:
            conn.cu.commit(**op)
            ret[&quot;out&quot;] = True
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;out&quot;] = False
            ret[
                &quot;message&quot;
            ] = 'Rollback successful but commit failed with error &quot;{}&quot;'.format(
                exception
            )
            _restart_connection()
            return ret
    else:
        ret[&quot;message&quot;] = &quot;Rollback successful but pre-commit check failed.&quot;
        ret[&quot;out&quot;] = False

    return ret


@_timeout_decorator
def diff(**kwargs):
    &quot;&quot;&quot;
    Returns the difference between the candidate and the current configuration

    id : 0
        The rollback ID value (0-49)

    d_id : 0
        The rollback ID value (0-49)

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.diff d_id=3

    NOTE: Because of historical reasons and the internals of the Salt state
    compiler, there are three possible sources of the rollback ID--the
    positional argument, and the `id` and `d_id` kwargs.  The precedence of
    the arguments are `id` (positional), `id` (kwarg), `d_id` (kwarg).  In
    other words, if all three are passed, only the positional argument
    will be used.  A warning is logged if more than one is passed.
    &quot;&quot;&quot;
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    ids_passed = 0
    id_ = 0
    if &quot;d_id&quot; in kwargs:
        id_ = kwargs.pop(&quot;d_id&quot;)
        ids_passed = ids_passed + 1
    if &quot;id&quot; in kwargs:
        id_ = kwargs.pop(&quot;id&quot;, 0)
        ids_passed = ids_passed + 1
    if ids_passed &gt; 1:
        log.warning(
            &quot;junos.rollback called with more than one possible ID. &quot;
            &quot;Use only one of the positional argument, `id`, or `d_id` kwargs&quot;
        )

    if kwargs:
        salt.utils.args.invalid_kwargs(kwargs)

    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True
    try:
        ret[&quot;message&quot;] = conn.cu.diff(rb_id=id_)
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not get diff with error &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()

    return ret


@_timeout_decorator
def ping(dest_ip=None, **kwargs):
    &quot;&quot;&quot;
    Send a ping RPC to a device

    dest_ip
      The IP of the device to ping

    dev_timeout : 30
        The NETCONF RPC timeout (in seconds)

    rapid : False
        When ``True``, executes ping at 100pps instead of 1pps

    ttl
        Maximum number of IP routers (IP hops) allowed between source and
        destination

    routing_instance
      Name of the routing instance to use to send the ping

    interface
      Interface used to send traffic

    count : 5
      Number of packets to send

    CLI Examples:

    .. code-block:: bash

        salt 'device_name' junos.ping '8.8.8.8' count=5
        salt 'device_name' junos.ping '8.8.8.8' ttl=1 rapid=True
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}

    if dest_ip is None:
        ret[&quot;message&quot;] = &quot;Please specify the destination ip to ping.&quot;
        ret[&quot;out&quot;] = False
        return ret

    op = {&quot;host&quot;: dest_ip}
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    op[&quot;count&quot;] = str(op.pop(&quot;count&quot;, 5))
    if &quot;ttl&quot; in op:
        op[&quot;ttl&quot;] = str(op[&quot;ttl&quot;])

    ret[&quot;out&quot;] = True
    try:
        ret[&quot;message&quot;] = jxmlease.parse(etree.tostring(conn.rpc.ping(**op)))
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Execution failed due to &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()

    return ret


@_timeout_decorator
def cli(command=None, **kwargs):
    &quot;&quot;&quot;
    Executes the CLI commands and returns the output in specified format. \
    (default is text) The output can also be stored in a file.

    command (required)
        The command to execute on the Junos CLI

    format : text
        Format in which to get the CLI output (either ``text`` or ``xml``)

    dev_timeout : 30
        The NETCONF RPC timeout (in seconds)

    dest
        Destination file where the RPC output is stored. Note that the file
        will be stored on the proxy minion. To push the files to the master use
        :py:func:`cp.push &lt;salt.modules.cp.push&gt;`.

    CLI Examples:

    .. code-block:: bash

        salt 'device_name' junos.cli 'show system commit'
        salt 'device_name' junos.cli 'show system alarms' format=xml dest=/home/user/cli_output.txt
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()

    format_ = kwargs.pop(&quot;format&quot;, &quot;text&quot;)
    if not format_:
        format_ = &quot;text&quot;

    ret = {}
    if command is None:
        ret[&quot;message&quot;] = &quot;Please provide the CLI command to be executed.&quot;
        ret[&quot;out&quot;] = False
        return ret

    op = dict()
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    try:
        result = conn.cli(command, format_, warning=False)
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Execution failed due to &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret

    if format_ == &quot;text&quot;:
        ret[&quot;message&quot;] = result
    else:
        result = etree.tostring(result)
        ret[&quot;message&quot;] = jxmlease.parse(result)

    if &quot;dest&quot; in op and op[&quot;dest&quot;] is not None:
        try:
            with salt.utils.files.fopen(op[&quot;dest&quot;], &quot;w&quot;) as fp:
                fp.write(salt.utils.stringutils.to_str(result))
        except OSError:
            ret[&quot;message&quot;] = 'Unable to open &quot;{}&quot; to write'.format(op[&quot;dest&quot;])
            ret[&quot;out&quot;] = False
            return ret

    ret[&quot;out&quot;] = True
    return ret


@_timeout_decorator
def shutdown(**kwargs):
    &quot;&quot;&quot;
    Shut down (power off) or reboot a device running Junos OS. This includes
    all Routing Engines in a Virtual Chassis or a dual Routing Engine system.

      .. note::
          One of ``shutdown`` or ``reboot`` must be set to ``True`` or no
          action will be taken.

    shutdown : False
      Set this to ``True`` if you want to shutdown the machine. This is a
      safety mechanism so that the user does not accidentally shutdown the
      junos device.

    reboot : False
      If ``True``, reboot instead of shutting down

    at
      Used when rebooting, to specify the date and time the reboot should take
      place. The value of this option must match the JunOS CLI reboot syntax.

    in_min
        Used when shutting down. Specify the delay (in minutes) before the
        device will be shut down.

    CLI Examples:

    .. code-block:: bash

        salt 'device_name' junos.shutdown reboot=True
        salt 'device_name' junos.shutdown shutdown=True in_min=10
        salt 'device_name' junos.shutdown shutdown=True
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    sw = SW(conn)

    op = {}
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)
    if &quot;shutdown&quot; not in op and &quot;reboot&quot; not in op:
        ret[&quot;message&quot;] = &quot;Provide either one of the arguments: shutdown or reboot.&quot;
        ret[&quot;out&quot;] = False
        return ret

    try:
        if &quot;reboot&quot; in op and op[&quot;reboot&quot;]:
            shut = sw.reboot
        elif &quot;shutdown&quot; in op and op[&quot;shutdown&quot;]:
            shut = sw.poweroff
        else:
            ret[&quot;message&quot;] = &quot;Nothing to be done.&quot;
            ret[&quot;out&quot;] = False
            return ret

        if &quot;in_min&quot; in op:
            shut(in_min=op[&quot;in_min&quot;])
        elif &quot;at&quot; in op:
            shut(at=op[&quot;at&quot;])
        else:
            shut()
        ret[&quot;message&quot;] = &quot;Successfully powered off/rebooted.&quot;
        ret[&quot;out&quot;] = True
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not poweroff/reboot because &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()

    return ret


@_timeout_decorator
def install_config(path=None, **kwargs):
    &quot;&quot;&quot;
    Installs the given configuration file into the candidate configuration.
    Commits the changes if the commit checks or throws an error.

    path (required)
        Path where the configuration/template file is present. If the file has
        a ``.conf`` extension, the content is treated as text format. If the
        file has a ``.xml`` extension, the content is treated as XML format. If
        the file has a ``.set`` extension, the content is treated as Junos OS
        ``set`` commands.

    mode : exclusive
        The mode in which the configuration is locked. Can be one of
        ``private``, ``dynamic``, ``batch``, ``exclusive``, ``ephemeral``

    dev_timeout : 30
        Set NETCONF RPC timeout. Can be used for commands which take a while to
        execute.

    overwrite : False
        Set to ``True`` if you want this file is to completely replace the
        configuration file. Sets action to override

        .. note:: This option cannot be used if **format** is &quot;set&quot;.

    replace : False
        Specify whether the configuration file uses ``replace:`` statements. If
        ``True``, only those statements under the ``replace`` tag will be
        changed.

    merge : False
        If set to ``True`` will set the load-config action to merge.
        the default load-config action is 'replace' for xml/json/text config

    format
        Determines the format of the contents

    update : False
        Compare a complete loaded configuration against the candidate
        configuration. For each hierarchy level or configuration object that is
        different in the two configurations, the version in the loaded
        configuration replaces the version in the candidate configuration. When
        the configuration is later committed, only system processes that are
        affected by the changed configuration elements parse the new
        configuration. This action is supported from PyEZ 2.1.

    comment
      Provide a comment for the commit

    confirm
      Provide time in minutes for commit confirmation. If this option is
      specified, the commit will be rolled back in the specified amount of time
      unless the commit is confirmed.

    diffs_file
      Path to the file where the diff (difference in old configuration and the
      committed configuration) will be stored. Note that the file will be
      stored on the proxy minion. To push the files to the master use:

        py:func:`cp.push &lt;salt.modules.cp.push&gt;`.

    template_vars
      Variables to be passed into the template processing engine in addition to
      those present in pillar, the minion configuration, grains, etc.  You may
      reference these variables in your template like so:

      .. code-block:: jinja

          {{ template_vars[&quot;var_name&quot;] }}

    CLI Examples:

    .. code-block:: bash

        salt 'device_name' junos.install_config 'salt://production/network/routers/config.set'
        salt 'device_name' junos.install_config 'salt://templates/replace_config.conf' replace=True comment='Committed via SaltStack'
        salt 'device_name' junos.install_config 'salt://my_new_configuration.conf' dev_timeout=300 diffs_file='/salt/confs/old_config.conf' overwrite=True
        salt 'device_name' junos.install_config 'salt://syslog_template.conf' template_vars='{&quot;syslog_host&quot;: &quot;10.180.222.7&quot;}'
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True

    if path is None:
        ret[
            &quot;message&quot;
        ] = &quot;Please provide the salt path where the configuration is present&quot;
        ret[&quot;out&quot;] = False
        return ret

    op = {}
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    test = op.pop(&quot;test&quot;, False)

    kwargs = {}
    if &quot;template_vars&quot; in op:
        kwargs.update({&quot;template_vars&quot;: op[&quot;template_vars&quot;]})

    with HandleFileCopy(path, **kwargs) as template_cached_path:
        if template_cached_path is None:
            ret[&quot;message&quot;] = &quot;Invalid file path.&quot;
            ret[&quot;out&quot;] = False
            return ret

        if os.path.getsize(template_cached_path) == 0:
            ret[&quot;message&quot;] = &quot;Template failed to render&quot;
            ret[&quot;out&quot;] = False
            return ret

        write_diff = &quot;&quot;
        if &quot;diffs_file&quot; in op and op[&quot;diffs_file&quot;] is not None:
            write_diff = op[&quot;diffs_file&quot;]
            del op[&quot;diffs_file&quot;]

        op[&quot;path&quot;] = template_cached_path

        if &quot;format&quot; not in op:
            if path.endswith(&quot;set&quot;):
                template_format = &quot;set&quot;
            elif path.endswith(&quot;xml&quot;):
                template_format = &quot;xml&quot;
            elif path.endswith(&quot;json&quot;):
                template_format = &quot;json&quot;
            else:
                template_format = &quot;text&quot;

            op[&quot;format&quot;] = template_format

        if &quot;replace&quot; in op and op[&quot;replace&quot;]:
            op[&quot;merge&quot;] = False
            del op[&quot;replace&quot;]
        elif &quot;overwrite&quot; in op and op[&quot;overwrite&quot;]:
            op[&quot;overwrite&quot;] = True
        elif &quot;overwrite&quot; in op and not op[&quot;overwrite&quot;]:
            op[&quot;merge&quot;] = True
            del op[&quot;overwrite&quot;]

        db_mode = op.pop(&quot;mode&quot;, &quot;exclusive&quot;)
        if write_diff and db_mode in [&quot;dynamic&quot;, &quot;ephemeral&quot;]:
            ret[
                &quot;message&quot;
            ] = &quot;Write diff is not supported with dynamic/ephemeral configuration mode&quot;
            ret[&quot;out&quot;] = False
            return ret

        config_params = {}
        if &quot;ephemeral_instance&quot; in op:
            config_params[&quot;ephemeral_instance&quot;] = op.pop(&quot;ephemeral_instance&quot;)
        try:
            with Config(conn, mode=db_mode, **config_params) as cu:
                try:
                    cu.load(**op)
                except Exception as exception:  # pylint: disable=broad-except
                    ret[
                        &quot;message&quot;
                    ] = 'Could not load configuration due to : &quot;{}&quot;'.format(exception)
                    ret[&quot;format&quot;] = op[&quot;format&quot;]
                    ret[&quot;out&quot;] = False
                    _restart_connection()
                    return ret

                config_diff = None
                if db_mode in [&quot;dynamic&quot;, &quot;ephemeral&quot;]:
                    log.warning(&quot;diff is not supported for dynamic and ephemeral&quot;)
                else:
                    config_diff = cu.diff()
                    if config_diff is None:
                        ret[&quot;message&quot;] = &quot;Configuration already applied!&quot;
                        ret[&quot;out&quot;] = True
                        return ret

                commit_params = {}
                if &quot;confirm&quot; in op:
                    commit_params[&quot;confirm&quot;] = op[&quot;confirm&quot;]
                if &quot;comment&quot; in op:
                    commit_params[&quot;comment&quot;] = op[&quot;comment&quot;]

                # Assume commit_check succeeds and initialize variable check
                check = True
                if db_mode in [&quot;dynamic&quot;, &quot;ephemeral&quot;]:
                    log.warning(&quot;commit check not supported for dynamic and ephemeral&quot;)
                else:
                    try:
                        check = cu.commit_check()
                    except Exception as exception:  # pylint: disable=broad-except
                        ret[
                            &quot;message&quot;
                        ] = 'Commit check threw the following exception: &quot;{}&quot;'.format(
                            exception
                        )
                        ret[&quot;out&quot;] = False
                        _restart_connection()
                        return ret

                if check and not test:
                    try:
                        cu.commit(**commit_params)
                        ret[&quot;message&quot;] = &quot;Successfully loaded and committed!&quot;
                    except Exception as exception:  # pylint: disable=broad-except
                        ret[
                            &quot;message&quot;
                        ] = 'Commit check successful but commit failed with &quot;{}&quot;'.format(
                            exception
                        )
                        ret[&quot;out&quot;] = False
                        _restart_connection()
                        return ret

                elif not check:
                    try:
                        cu.rollback()
                        ret[&quot;message&quot;] = (
                            &quot;Loaded configuration but commit check failed, hence&quot;
                            &quot; rolling back configuration.&quot;
                        )
                    except Exception as exception:  # pylint: disable=broad-except
                        ret[&quot;message&quot;] = (
                            &quot;Loaded configuration but commit check failed, and&quot;
                            ' exception occurred during rolling back configuration &quot;{}&quot;'.format(
                                exception
                            )
                        )
                        _restart_connection()

                    ret[&quot;out&quot;] = False
                else:
                    try:
                        cu.rollback()
                        ret[&quot;message&quot;] = (
                            &quot;Commit check passed, but skipping commit for dry-run and&quot;
                            &quot; rolling back configuration.&quot;
                        )
                        ret[&quot;out&quot;] = True
                    except Exception as exception:  # pylint: disable=broad-except
                        ret[&quot;message&quot;] = (
                            &quot;Commit check passed, but skipping commit for dry-run and&quot;
                            ' while rolling back configuration exception occurred &quot;{}&quot;'.format(
                                exception
                            )
                        )
                        ret[&quot;out&quot;] = False
                        _restart_connection()

                try:
                    if write_diff and config_diff is not None:
                        with salt.utils.files.fopen(write_diff, &quot;w&quot;) as fp:
                            fp.write(salt.utils.stringutils.to_str(config_diff))
                except Exception as exception:  # pylint: disable=broad-except
                    ret[
                        &quot;message&quot;
                    ] = &quot;Could not write into diffs_file due to: '{}'&quot;.format(exception)
                    ret[&quot;out&quot;] = False

        except ValueError as ex:
            message = &quot;install_config failed due to: {}&quot;.format(str(ex))
            log.error(message)
            ret[&quot;message&quot;] = message
            ret[&quot;out&quot;] = False
        except LockError as ex:
            log.error(&quot;Configuration database is locked&quot;)
            ret[&quot;message&quot;] = ex.message
            ret[&quot;out&quot;] = False
        except RpcTimeoutError as ex:
            message = &quot;install_config failed due to timeout error : {}&quot;.format(str(ex))
            log.error(message)
            ret[&quot;message&quot;] = message
            ret[&quot;out&quot;] = False
        except Exception as exc:  # pylint: disable=broad-except
            ret[&quot;message&quot;] = &quot;install_config failed due to exception: '{}'&quot;.format(exc)
            ret[&quot;out&quot;] = False

        return ret


@_timeout_decorator_cleankwargs
def zeroize():
    &quot;&quot;&quot;
    Resets the device to default factory settings

    .. note::
        In case of non-root user, proxy_reconnect will not be able
        to re-connect to the device as zeroize will delete the local
        user's configuration.
        For more details on zeroize functionality, please refer
        https://www.juniper.net/documentation/en_US/junos/topics/reference/command-summary/request-system-zeroize.html

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.zeroize
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True
    try:
        conn.cli(&quot;request system zeroize&quot;)
        ret[&quot;message&quot;] = &quot;Completed zeroize and rebooted&quot;
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = 'Could not zeroize due to : &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()

    return ret


@_timeout_decorator
def install_os(path=None, **kwargs):
    &quot;&quot;&quot;
    Installs the given image on the device. After the installation is complete
    the device is rebooted, if reboot=True is given as a keyworded argument.

    path (required)
        Path where the image file is present on the proxy minion

    remote_path : /var/tmp
        If the value of path  is a file path on the local
        (Salt host's) filesystem, then the image is copied from the local
        filesystem to the :remote_path: directory on the target Junos
        device. The default is ``/var/tmp``. If the value of :path: or
        is a URL, then the value of :remote_path: is unused.

    dev_timeout : 1800
        The NETCONF RPC timeout (in seconds). This argument was added since most of
        the time the &quot;package add&quot; RPC takes a significant amount of time.
        So this :timeout: value will be used in the context of the SW installation
        process.  Defaults to 30 minutes (30*60=1800 seconds)

    timeout : 1800
        Alias to dev_timeout for backward compatibility

    reboot : False
        Whether to reboot after installation

    no_copy : False
        If ``True`` the software package will not be SCPd to the device

    bool validate:
        When ``True`` this method will perform a config validation against
        the new image

    bool issu: False
        When ``True`` allows unified in-service software upgrade
        (ISSU) feature enables you to upgrade between two different Junos OS
        releases with no disruption on the control plane and with minimal
        disruption of traffic.

    bool nssu: False
        When ``True`` allows nonstop software upgrade (NSSU)
        enables you to upgrade the software running on a Juniper Networks
        EX Series Virtual Chassis or a Juniper Networks EX Series Ethernet
        Switch with redundant Routing Engines with a single command and
        minimal disruption to network traffic.

    bool all_re: True
        When True (default), executes the software install on all Routing Engines of the Junos
        device. When False, execute the software install only on the current Routing Engine.

        .. versionadded:: 3001

    .. note::
        Any additional keyword arguments specified are passed down to PyEZ sw.install() as is.
        Please refer to below URl for PyEZ sw.install() documentation:
        https://pyez.readthedocs.io/en/latest/jnpr.junos.utils.html#jnpr.junos.utils.sw.SW.install

    CLI Examples:

    .. code-block:: bash

        salt 'device_name' junos.install_os 'salt://images/junos_image.tgz' reboot=True
        salt 'device_name' junos.install_os 'salt://junos_16_1.tgz' dev_timeout=300
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True

    op = {}
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    # timeout value is not honoured by sw.install if not passed as argument
    # currently, timeout is set to be maximum of default 1800 and user passed timeout value
    # For info: https://github.com/Juniper/salt/issues/116
    dev_timeout = max(op.pop(&quot;dev_timeout&quot;, 0), op.pop(&quot;timeout&quot;, 0))
    timeout = max(1800, conn.timeout, dev_timeout)

    # Reboot should not be passed as a keyword argument to install(),
    # Please refer to https://github.com/Juniper/salt/issues/115 for more details
    reboot = op.pop(&quot;reboot&quot;, False)
    no_copy_ = op.get(&quot;no_copy&quot;, False)

    if path is None:
        ret[
            &quot;message&quot;
        ] = &quot;Please provide the salt path where the junos image is present.&quot;
        ret[&quot;out&quot;] = False
        return ret

    if reboot:
        #  flag reboot active, disables proxy_reconnect since it's probing
        # of connection interferes with the reboot, especially with a
        # package install (time taken to xfer package and install)
        __proxy__[&quot;junos.reboot_active&quot;]()

    install_status = False
    if not no_copy_:
        with HandleFileCopy(path) as image_path:
            if image_path is None:
                ret[&quot;message&quot;] = &quot;Invalid path. Please provide a valid image path&quot;
                ret[&quot;out&quot;] = False
                __proxy__[&quot;junos.reboot_clear&quot;]()
                return ret
            if salt.utils.platform.is_junos():
                # If its native minion running on Junos, pyez dont need to SCP file
                # hence setting no_copy as True, HandleFileCopy already copied file
                # from master to Junos
                tmp_absfile = image_path
                op[&quot;no_copy&quot;] = True
                op[&quot;remote_path&quot;] = os.path.dirname(tmp_absfile)
                image_path = os.path.basename(tmp_absfile)
            try:
                install_status, install_message = conn.sw.install(
                    image_path, progress=True, timeout=timeout, **op
                )
            except Exception as exception:  # pylint: disable=broad-except
                ret[&quot;message&quot;] = 'Installation failed due to: &quot;{}&quot;'.format(exception)
                ret[&quot;out&quot;] = False
                __proxy__[&quot;junos.reboot_clear&quot;]()
                _restart_connection()
                return ret
    else:
        try:
            install_status, install_message = conn.sw.install(
                path, progress=True, timeout=timeout, **op
            )
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;message&quot;] = 'Installation failed due to: &quot;{}&quot;'.format(exception)
            ret[&quot;out&quot;] = False
            __proxy__[&quot;junos.reboot_clear&quot;]()
            _restart_connection()
            return ret

    if install_status is True:
        ret[&quot;out&quot;] = True
        ret[&quot;message&quot;] = &quot;Installed the os.&quot;
    else:
        ret[&quot;message&quot;] = &quot;Installation failed. Reason: {}&quot;.format(install_message)
        ret[&quot;out&quot;] = False
        __proxy__[&quot;junos.reboot_clear&quot;]()
        return ret

    # Handle reboot, after the install has finished
    if reboot is True:
        reboot_kwargs = {}
        if &quot;vmhost&quot; in op and op.get(&quot;vmhost&quot;) is True:
            reboot_kwargs[&quot;vmhost&quot;] = True
        if &quot;all_re&quot; in op:
            reboot_kwargs[&quot;all_re&quot;] = op.get(&quot;all_re&quot;)
        try:
            __proxy__[&quot;junos.reboot_active&quot;]()
            conn.sw.reboot(**reboot_kwargs)
        except Exception as exception:  # pylint: disable=broad-except
            __proxy__[&quot;junos.reboot_clear&quot;]()
            ret[
                &quot;message&quot;
            ] = 'Installation successful but reboot failed due to : &quot;{}&quot;'.format(
                exception
            )
            ret[&quot;out&quot;] = False
            _restart_connection()
            return ret

        __proxy__[&quot;junos.reboot_clear&quot;]()
        ret[&quot;out&quot;] = True
        ret[&quot;message&quot;] = &quot;Successfully installed and rebooted!&quot;

    return ret


@_timeout_decorator_cleankwargs
def file_copy(src, dest):
    &quot;&quot;&quot;
    Copies the file from the local device to the junos device

    .. note::
        This function does not work on Juniper native minions

    src
        The source path where the file is kept.

    dest
        The destination path on the where the file will be copied

    .. versionadded:: 3001

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.file_copy /home/m2/info.txt info_copy.txt
    &quot;&quot;&quot;
    if salt.utils.platform.is_junos():
        return {
            &quot;success&quot;: False,
            &quot;message&quot;: &quot;This method is unsupported on the current operating system!&quot;,
        }

    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True

    with HandleFileCopy(src) as fp:
        if fp is None:
            ret[&quot;message&quot;] = &quot;Invalid source file path {}&quot;.format(src)
            ret[&quot;out&quot;] = False
            return ret

        try:
            with SCP(conn, progress=True) as scp:
                scp.put(fp, dest)
            ret[&quot;message&quot;] = &quot;Successfully copied file from {} to {}&quot;.format(src, dest)
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;message&quot;] = 'Could not copy file : &quot;{}&quot;'.format(exception)
            ret[&quot;out&quot;] = False

        return ret


@_timeout_decorator_cleankwargs
def lock():
    &quot;&quot;&quot;
    Attempts an exclusive lock on the candidate configuration. This
    is a non-blocking call.

    .. note::
        When locking, it is important to remember to call
        :py:func:`junos.unlock &lt;salt.modules.junos.unlock&gt;` once finished. If
        locking during orchestration, remember to include a step in the
        orchestration job to unlock.

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.lock
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True
    try:
        conn.cu.lock()
        ret[&quot;message&quot;] = &quot;Successfully locked the configuration.&quot;
    except RpcTimeoutError as exception:
        ret[&quot;message&quot;] = 'Could not gain lock due to : &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()

    except LockError as exception:
        ret[&quot;message&quot;] = 'Could not gain lock due to : &quot;{}&quot;'.format(exception)
        ret[&quot;out&quot;] = False

    return ret


@_timeout_decorator_cleankwargs
def unlock():
    &quot;&quot;&quot;
    Unlocks the candidate configuration.

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.unlock
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True
    try:
        conn.cu.unlock()
        ret[&quot;message&quot;] = &quot;Successfully unlocked the configuration.&quot;
    except RpcTimeoutError as exception:
        ret[&quot;message&quot;] = 'Could not unlock configuration due to : &quot;{}&quot;'.format(
            exception
        )
        ret[&quot;out&quot;] = False
        _restart_connection()

    except UnlockError as exception:
        ret[&quot;message&quot;] = 'Could not unlock configuration due to : &quot;{}&quot;'.format(
            exception
        )
        ret[&quot;out&quot;] = False

    return ret


@_timeout_decorator
def load(path=None, **kwargs):
    &quot;&quot;&quot;
    Loads the configuration from the file provided onto the device.

    path (required)
        Path where the configuration/template file is present. If the file has
        a ``.conf`` extension, the content is treated as text format. If the
        file has a ``.xml`` extension, the content is treated as XML format. If
        the file has a ``.set`` extension, the content is treated as Junos OS
        ``set`` commands.

    overwrite : False
        Set to ``True`` if you want this file is to completely replace the
        configuration file. Sets action to override

        .. note:: This option cannot be used if **format** is &quot;set&quot;.

    replace : False
        Specify whether the configuration file uses ``replace:`` statements. If
        ``True``, only those statements under the ``replace`` tag will be
        changed.

    merge : False
        If set to ``True`` will set the load-config action to merge.
        the default load-config action is 'replace' for xml/json/text config

    update : False
        Compare a complete loaded configuration against the candidate
        configuration. For each hierarchy level or configuration object that is
        different in the two configurations, the version in the loaded
        configuration replaces the version in the candidate configuration. When
        the configuration is later committed, only system processes that are
        affected by the changed configuration elements parse the new
        configuration. This action is supported from PyEZ 2.1.

    format
        Determines the format of the contents

    template_vars
      Variables to be passed into the template processing engine in addition to
      those present in pillar, the minion configuration, grains, etc.  You may
      reference these variables in your template like so:

      .. code-block:: jinja

          {{ template_vars[&quot;var_name&quot;] }}

    CLI Examples:

    .. code-block:: bash

        salt 'device_name' junos.load 'salt://production/network/routers/config.set'

        salt 'device_name' junos.load 'salt://templates/replace_config.conf' replace=True

        salt 'device_name' junos.load 'salt://my_new_configuration.conf' overwrite=True

        salt 'device_name' junos.load 'salt://syslog_template.conf' template_vars='{&quot;syslog_host&quot;: &quot;10.180.222.7&quot;}'
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True

    if path is None:
        ret[
            &quot;message&quot;
        ] = &quot;Please provide the salt path where the configuration is present&quot;
        ret[&quot;out&quot;] = False
        return ret

    op = {}
    if &quot;__pub_arg&quot; in kwargs:
        if kwargs[&quot;__pub_arg&quot;]:
            if isinstance(kwargs[&quot;__pub_arg&quot;][-1], dict):
                op.update(kwargs[&quot;__pub_arg&quot;][-1])
    else:
        op.update(kwargs)

    kwargs = {}
    if &quot;template_vars&quot; in op:
        kwargs.update({&quot;template_vars&quot;: op[&quot;template_vars&quot;]})

    with HandleFileCopy(path, **kwargs) as template_cached_path:
        if template_cached_path is None:
            ret[&quot;message&quot;] = &quot;Invalid file path.&quot;
            ret[&quot;out&quot;] = False
            return ret

        if os.path.getsize(template_cached_path) == 0:
            ret[&quot;message&quot;] = &quot;Template failed to render&quot;
            ret[&quot;out&quot;] = False
            return ret

        op[&quot;path&quot;] = template_cached_path

        if &quot;format&quot; not in op:
            if path.endswith(&quot;set&quot;):
                template_format = &quot;set&quot;
            elif path.endswith(&quot;xml&quot;):
                template_format = &quot;xml&quot;
            elif path.endswith(&quot;json&quot;):
                template_format = &quot;json&quot;
            else:
                template_format = &quot;text&quot;

            op[&quot;format&quot;] = template_format

        # Currently, four config_actions are supported: overwrite, replace, update, merge
        # Allow only one config_action, providing multiple config_action value is not allowed
        actions = [
            item
            for item in (&quot;overwrite&quot;, &quot;replace&quot;, &quot;update&quot;, &quot;merge&quot;)
<A NAME="0"></A>            if op.get(item, False)
        ]
        if len(list(actions)) &gt; 1:
            ret<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match296926-0.html#0',2,'match296926-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;message&quot;] = &quot;Only one config_action is allowed. Provided: {}&quot;.format(
                actions
            )
            ret[&quot;out&quot;] = False
            return ret

        if &quot;replace&quot; in op and op[&quot;replace&quot;]:
            op[&quot;merge&quot;] =</B></FONT> False
            del op[&quot;replace&quot;]
        elif &quot;overwrite&quot; in op and op[&quot;overwrite&quot;]:
            op[&quot;overwrite&quot;] = True
        elif &quot;merge&quot; in op and op[&quot;merge&quot;]:
            op[&quot;merge&quot;] = True
        elif &quot;overwrite&quot; in op and not op[&quot;overwrite&quot;]:
            op[&quot;merge&quot;] = True
            del op[&quot;overwrite&quot;]

        try:
            conn.cu.load(**op)
            ret[&quot;message&quot;] = &quot;Successfully loaded the configuration.&quot;
        except Exception as exception:  # pylint: disable=broad-except
            ret[&quot;message&quot;] = 'Could not load configuration due to : &quot;{}&quot;'.format(
                exception
            )
            ret[&quot;format&quot;] = op[&quot;format&quot;]
            ret[&quot;out&quot;] = False
            _restart_connection()
            return ret

        return ret


@_timeout_decorator_cleankwargs
def commit_check():
    &quot;&quot;&quot;
    Perform a commit check on the configuration

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.commit_check
    &quot;&quot;&quot;
    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True
    try:
        conn.cu.commit_check()
        ret[&quot;message&quot;] = &quot;Commit check succeeded.&quot;
    except Exception as exception:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = &quot;Commit check failed with {}&quot;.format(exception)
        ret[&quot;out&quot;] = False
        _restart_connection()

    return ret


@_timeout_decorator_cleankwargs
def get_table(
    table,
    table_file,
    path=None,
    target=None,
    key=None,
    key_items=None,
    filters=None,
    table_args=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 3001

    Retrieve data from a Junos device using Tables/Views

    table (required)
        Name of PyEZ Table

    table_file (required)
        YAML file that has the table specified in table parameter

    path:
        Path of location of the YAML file.
        defaults to op directory in jnpr.junos.op

    target:
        if command need to run on FPC, can specify fpc target

    key:
        To overwrite key provided in YAML

    key_items:
        To select only given key items

    filters:
        To select only filter for the dictionary from columns

    table_args:
        key/value pair which should render Jinja template command
        or are passed as args to rpc call in op table

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.get_table RouteTable routes.yml
        salt 'device_name' junos.get_table EthPortTable ethport.yml table_args='{&quot;interface_name&quot;: &quot;ge-3/2/2&quot;}'
        salt 'device_name' junos.get_table EthPortTable ethport.yml salt://tables
    &quot;&quot;&quot;

    conn = __proxy__[&quot;junos.conn&quot;]()
    ret = {}
    ret[&quot;out&quot;] = True
    ret[&quot;hostname&quot;] = conn._hostname
    ret[&quot;tablename&quot;] = table
    get_kvargs = {}
    if target is not None:
        get_kvargs[&quot;target&quot;] = target
    if key is not None:
        get_kvargs[&quot;key&quot;] = key
    if key_items is not None:
        get_kvargs[&quot;key_items&quot;] = key_items
    if filters is not None:
        get_kvargs[&quot;filters&quot;] = filters
    if table_args is not None and isinstance(table_args, dict):
        get_kvargs[&quot;args&quot;] = table_args
    pyez_tables_path = os.path.dirname(os.path.abspath(tables_dir.__file__))
    try:
        if path is not None:
            file_path = os.path.join(path, &quot;{}&quot;.format(table_file))
        else:
            file_path = os.path.join(pyez_tables_path, &quot;{}&quot;.format(table_file))

        with HandleFileCopy(file_path) as file_loc:
            if file_loc is None:
                ret[&quot;message&quot;] = &quot;Given table file {} cannot be located&quot;.format(
                    table_file
                )
                ret[&quot;out&quot;] = False
                return ret
            try:
                with salt.utils.files.fopen(file_loc) as fp:
                    ret[&quot;table&quot;] = yaml.load(
                        fp.read(), Loader=yamlordereddictloader.Loader
                    )
                    globals().update(FactoryLoader().load(ret[&quot;table&quot;]))
            except OSError as err:
                ret[
                    &quot;message&quot;
                ] = &quot;Uncaught exception during YAML Load - please report: {}&quot;.format(
                    str(err)
                )
                ret[&quot;out&quot;] = False
                return ret
            try:
                data = globals()[table](conn)
                data.get(**get_kvargs)
            except KeyError as err:
                ret[
                    &quot;message&quot;
                ] = &quot;Uncaught exception during get API call - please report: {}&quot;.format(
                    str(err)
                )
                ret[&quot;out&quot;] = False
                return ret
            except ConnectClosedError:
                ret[
                    &quot;message&quot;
                ] = &quot;Got ConnectClosedError exception. Connection lost with {}&quot;.format(
                    conn
                )
                ret[&quot;out&quot;] = False
                _restart_connection()
                return ret
            ret[&quot;reply&quot;] = json.loads(data.to_json())
            if data.__class__.__bases__[0] in [OpTable, CfgTable]:
                # Sets key value if not present in YAML. To be used by returner
                if ret[&quot;table&quot;][table].get(&quot;key&quot;) is None:
                    ret[&quot;table&quot;][table][&quot;key&quot;] = data.ITEM_NAME_XPATH
                # If key is provided from salt state file.
                if key is not None:
                    ret[&quot;table&quot;][table][&quot;key&quot;] = data.KEY
                if table_args is not None:
                    args = copy.copy(data.GET_ARGS)
                    args.update(table_args)
                    ret[&quot;table&quot;][table][&quot;args&quot;] = args
            else:
                if target is not None:
                    ret[&quot;table&quot;][table][&quot;target&quot;] = data.TARGET
                if key is not None:
                    ret[&quot;table&quot;][table][&quot;key&quot;] = data.KEY
                if key_items is not None:
                    ret[&quot;table&quot;][table][&quot;key_items&quot;] = data.KEY_ITEMS
                if table_args is not None:
                    args = copy.copy(data.CMD_ARGS)
                    args.update(table_args)
                    ret[&quot;table&quot;][table][&quot;args&quot;] = args
                    ret[&quot;table&quot;][table][&quot;command&quot;] = data.GET_CMD
    except ConnectClosedError:
        ret[
            &quot;message&quot;
        ] = &quot;Got ConnectClosedError exception. Connection lost with {}&quot;.format(
            str(conn)
        )
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret
    except Exception as err:  # pylint: disable=broad-except
        ret[&quot;message&quot;] = &quot;Uncaught exception - please report: {}&quot;.format(str(err))
        ret[&quot;out&quot;] = False
        _restart_connection()
        return ret
    return ret


def _recursive_dict(node):
    &quot;&quot;&quot;
    Convert an lxml.etree node tree into a dict.
    &quot;&quot;&quot;
    result = {}

    for element in node.iterchildren():
        # Remove namespace prefix
        key = element.tag.split(&quot;}&quot;)[1] if &quot;}&quot; in element.tag else element.tag

        # Process element as tree element if the inner XML contains non-whitespace content
        if element.text and element.text.strip():
            value = element.text
        else:
            value = _recursive_dict(element)
        if key in result:

            if type(result[key]) is list:
                result[key].append(value)
            else:
                tempvalue = result[key].copy()
                result[key] = [tempvalue, value]
        else:
            result[key] = value
    return result


@_timeout_decorator
def rpc_file_list(path, **kwargs):
    &quot;&quot;&quot;
    Use the Junos RPC interface to get a list of files and return
    them as a structure dictionary.

    .. versionadded:: 3003

    CLI Example:

    .. code-block:: bash

        salt junos-router junos.rpc_file_list /var/local/salt/etc

        junos-router:
            files:
                directory:
                    directory-name:
                        /var/local/salt/etc
                    file-information:
                        |_
                          file-directory:
                              file-name:
                                  pki
                        |_
                          file-name:
                              proxy
                        |_
                          file-directory:
                              file-name:
                                  proxy.d
                total-file-blocks:
                    10
                total-files:
                    1
        success:
            True

    &quot;&quot;&quot;
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    conn = __proxy__[&quot;junos.conn&quot;]()
    if conn._conn is None:
        return False

    results = conn.rpc.file_list(path=path)

    ret = {}
    ret[&quot;files&quot;] = _recursive_dict(results)
    ret[&quot;success&quot;] = True

    return ret


def _strip_newlines(str):
    stripped = str.replace(&quot;\n&quot;, &quot;&quot;)
    return stripped


def _make_source_list(dir):

    dir_list = []
    if not dir:
        return
    base = rpc_file_list(dir)[&quot;files&quot;][&quot;directory&quot;]

    # No files in this directory
    if &quot;file-information&quot; not in base:
        if &quot;directory_name&quot; not in base:
            return None
        return [os.path.join(_strip_newlines(base.get(&quot;directory-name&quot;, None))) + &quot;/&quot;]

    if isinstance(base[&quot;file-information&quot;], dict):
        dirname = os.path.join(
            dir, _strip_newlines(base[&quot;file-information&quot;][&quot;file-name&quot;])
        )
        if &quot;file-directory&quot; in base[&quot;file-information&quot;]:
            new_list = _make_source_list(os.path.join(dir, dirname))
            return new_list
        else:
            return [dirname]
    for entry in base[&quot;file-information&quot;]:
        if &quot;file-directory&quot; in entry:
            new_list = _make_source_list(
                os.path.join(dir, _strip_newlines(entry[&quot;file-name&quot;]))
            )
            if new_list:
                dir_list.extend(new_list)
        else:
            dir_list.append(os.path.join(dir, _strip_newlines(entry[&quot;file-name&quot;])))

    return dir_list


@_timeout_decorator
def file_compare(file1, file2, **kwargs):
    &quot;&quot;&quot;
    Compare two files and return a dictionary indicating if they
    are different.

    Dictionary includes `success` key.  If False, one or more files do not
    exist or some other error occurred.

    Under the hood, this uses the junos CLI command `file compare files ...`

    .. note::
        This function only works on Juniper native minions

    .. versionadded:: 3003

    CLI Example:

    .. code-block:: bash

        salt junos-router junos.file_compare /var/tmp/backup1/cmt.script /var/tmp/backup2/cmt.script

        junos-router:
            identical:
                False
            success:
                True

    &quot;&quot;&quot;
    if not salt.utils.platform.is_junos():
        return {
            &quot;success&quot;: False,
            &quot;message&quot;: &quot;This method is unsupported on the current operating system!&quot;,
        }

    ret = {&quot;message&quot;: &quot;&quot;, &quot;identical&quot;: False, &quot;success&quot;: True}

    junos_cli = salt.utils.path.which(&quot;cli&quot;)
    if not junos_cli:
        return {&quot;success&quot;: False, &quot;message&quot;: &quot;Cannot find Junos cli command&quot;}

    cliret = __salt__[&quot;cmd.run&quot;](
        &quot;{} file compare files {} {} &quot;.format(junos_cli, file1, file2)
    )
    clilines = cliret.splitlines()

    for r in clilines:
        if r.strip() != &quot;&quot;:
            if &quot;No such file&quot; in r:
                ret[&quot;identical&quot;] = False
                ret[&quot;success&quot;] = False
                return ret

            ret[&quot;identical&quot;] = False
            ret[&quot;success&quot;] = True
            return ret

    ret[&quot;identical&quot;] = True
    ret[&quot;success&quot;] = True
    return ret


@_timeout_decorator
def fsentry_exists(dir, **kwargs):
    &quot;&quot;&quot;
    Returns a dictionary indicating if `dir` refers to a file
    or a non-file (generally a directory) in the file system,
    or if there is no file by that name.

    .. note::
        This function only works on Juniper native minions

    .. versionadded:: 3003

    CLI Example:

    .. code-block:: bash

        salt junos-router junos.fsentry_exists /var/log

        junos-router:
            is_dir:
                True
            exists:
                True

    &quot;&quot;&quot;
    if not salt.utils.platform.is_junos():
        return {
            &quot;success&quot;: False,
            &quot;message&quot;: &quot;This method is unsupported on the current operating system!&quot;,
        }

    junos_cli = salt.utils.path.which(&quot;cli&quot;)
    if not junos_cli:
        return {&quot;success&quot;: False, &quot;message&quot;: &quot;Cannot find Junos cli command&quot;}

    ret = __salt__[&quot;cmd.run&quot;](&quot;{} file show {}&quot;.format(junos_cli, dir))
    retlines = ret.splitlines()
    exists = True
    is_dir = False
    status = {&quot;is_dir&quot;: False, &quot;exists&quot;: True}
    for r in retlines:
        if &quot;could not resolve&quot; in r or &quot;error: Could not connect&quot; in r:
            status[&quot;is_dir&quot;] = False
            status[&quot;exists&quot;] = False
        if &quot;is not a regular file&quot; in r:
            status[&quot;is_dir&quot;] = True
            status[&quot;exists&quot;] = True

    return status


def _find_routing_engines():
    junos_cli = salt.utils.path.which(&quot;cli&quot;)
    if not junos_cli:
        return {&quot;success&quot;: False, &quot;message&quot;: &quot;Cannot find Junos cli command&quot;}

    re_check = __salt__[&quot;cmd.run&quot;](&quot;{} show chassis routing-engine&quot;.format(junos_cli))
    engine_present = True
    engine = {}

    # for l in re_check.splitlines():
    #     if 'error: Unrecognized command' in l:
    #         engine_present = False

    # if not engine_present:
    #     return {'success': False,
    #             'message': 'Device does not have multiple routing engines'}

    current_engine = None
    status = None
    for l in re_check.splitlines():
        if &quot;Slot&quot; in l:
            mat = re.search(&quot;.*(\\d+):.*&quot;, l)
            if mat:
                current_engine = &quot;re&quot; + str(mat.group(1)) + &quot;:&quot;
        if &quot;Current state&quot; in l:
            if &quot;Master&quot; in l:
                status = &quot;Master&quot;
            if &quot;Disabled&quot; in l:
                status = &quot;Disabled&quot;
            if &quot;Backup&quot; in l:
                status = &quot;Backup&quot;

        if current_engine and status:
            engine[current_engine] = status
            current_engine = None
            status = None

    if not engine:
        return {
            &quot;success&quot;: False,
            &quot;message&quot;: &quot;Junos cli command returned no information&quot;,
        }

    engine[&quot;success&quot;] = True
    return engine


@_timeout_decorator
def routing_engine(**kwargs):
    &quot;&quot;&quot;
    Returns a dictionary containing the routing engines on the device and
    their status (Master, Disabled, Backup).

    Under the hood parses the result of `show chassis routing-engine`

    .. versionadded:: 3003

    CLI Example:

    .. code-block:: bash

        salt junos-router junos.routing_engine

        junos-router:
            backup:
              - re1:
            master:
              re0:
            success:
              True

    Returns `success: False` if the device does not appear to have multiple routing engines.

    &quot;&quot;&quot;
    engine_status = _find_routing_engines()
    if not engine_status[&quot;success&quot;]:
        return {&quot;success&quot;: False}

    master = None
    backup = []
    for k, v in engine_status.items():
        if v == &quot;Master&quot;:
            master = k
        if v == &quot;Backup&quot; or v == &quot;Disabled&quot;:
            backup.append(k)

    if master:
        ret = {&quot;master&quot;: master, &quot;backup&quot;: backup, &quot;success&quot;: True}
    else:
        ret = {&quot;master&quot;: master, &quot;backup&quot;: backup, &quot;success&quot;: False}
    log.debug(ret)
    return ret


@_timeout_decorator
def dir_copy(source, dest, force=False, **kwargs):
    &quot;&quot;&quot;
    Copy a directory and recursively its contents from source to dest.

    .. note::
        This function only works on the Juniper native minion

    Parameters:

    source : Directory to use as the source

    dest : Directory in which to place the source and its contents.

    force : This function will not copy identical files unless `force` is `True`

    .. versionadded:: 3003

    CLI Example:

    .. code-block:: bash

        salt 'device_name' junos.dir_copy /etc/salt/pki re1:/

    This will take the `pki` directory, its absolute path and copy it and its
    contents to routing engine 1 root directory. The result will be
    `re1:/etc/salt/pki/&lt;files and dirs in /etc/salt/pki`.

    &quot;&quot;&quot;
    if not salt.utils.platform.is_junos():
        return {
            &quot;success&quot;: False,
            &quot;message&quot;: &quot;This method is unsupported on the current operating system!&quot;,
        }

    junos_cli = salt.utils.path.which(&quot;cli&quot;)
    if not junos_cli:
        return {&quot;success&quot;: False, &quot;message&quot;: &quot;Cannot find Junos cli command&quot;}

    ret = {}
    ret_messages = &quot;&quot;
    if not source.startswith(&quot;/&quot;):
        ret[&quot;message&quot;] = &quot;Source directory must be a fully qualified path.&quot;
        ret[&quot;success&quot;] = False
        return ret

    if not (dest.endswith(&quot;:&quot;) or dest.startswith(&quot;/&quot;)):
        ret[&quot;message&quot;] = (
            &quot;Destination must be a routing engine reference (e.g. re1:) or a fully&quot;
            &quot; qualified path.&quot;
        )
        ret[&quot;success&quot;] = False
        return ret

    check_source = fsentry_exists(source)
    if not check_source[&quot;exists&quot;]:
        ret[&quot;message&quot;] = &quot;Source does not exist&quot;
        ret[&quot;success&quot;] = False
        return ret

    if not check_source[&quot;is_dir&quot;]:
        ret[&quot;message&quot;] = &quot;Source is not a directory.&quot;
        ret[&quot;success&quot;] = False
        return ret

    filelist = _make_source_list(source)
    dirops = []
    for f in filelist:
        splitpath = os.path.split(f)[0]
        fullpath = &quot;/&quot;
        for component in splitpath.split(&quot;/&quot;):
            fullpath = os.path.join(fullpath, component)
            if fullpath not in dirops:
                dirops.append(fullpath)

    for d in dirops:
        target = dest + d
        status = fsentry_exists(target)
        if not status[&quot;exists&quot;]:
            ret = __salt__[&quot;cmd.run&quot;](
                &quot;{} file make-directory {}&quot;.format(junos_cli, target)
            )
            ret = ret_messages + ret
        else:
            ret_messages = ret_messages + &quot;Directory &quot; + target + &quot; already exists.\n&quot;
    for f in filelist:
        if not f.endswith(&quot;/&quot;):
            target = dest + f
            comp_result = file_compare(f, target)

            if not comp_result[&quot;identical&quot;] or force:
                ret = __salt__[&quot;cmd.run&quot;](
                    &quot;{} file copy {} {}&quot;.format(junos_cli, f, target)
                )
                ret = ret_messages + ret
            else:
                ret_messages = (
                    ret_messages
                    + &quot;Files {} and {} are identical, not copying.\n&quot;.format(f, target)
                )

    return ret_messages
</PRE>
</div>
  </div>
</body>
</html>
