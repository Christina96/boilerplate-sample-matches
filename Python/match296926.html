<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_apigateway.py &amp; junos_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_apigateway.py &amp; junos_1.py
      </h3>
<h1 align="center">
        0.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_apigateway.py (0.4743083%)<th>junos_1.py (0.45300114%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2076-2083)<td><a href="#" name="0">(1719-1726)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_apigateway.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import hashlib
2 import logging
3 import os
4 import re
5 import salt.utils.files
6 import salt.utils.json
7 import salt.utils.yaml
8 log = logging.getLogger(__name__)
9 def __virtual__():
10     if "boto_apigateway.describe_apis" in __salt__:
11         return "boto_apigateway"
12     return (False, "boto_apigateway module could not be loaded")
13 def present(
14     name,
15     api_name,
16     swagger_file,
17     stage_name,
18     api_key_required,
19     lambda_integration_role,
20     lambda_region=None,
21     stage_variables=None,
22     region=None,
23     key=None,
24     keyid=None,
25     profile=None,
26     lambda_funcname_format="{stage}_{api}_{resource}_{method}",
27     authorization_type="NONE",
28     error_response_template=None,
29     response_template=None,
30 ):
31     ret = {"name": name, "result": True, "comment": "", "changes": {}}
32     try:
33         common_args = dict(
34             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
35         )
36         swagger = _Swagger(
37             api_name,
38             stage_name,
39             lambda_funcname_format,
40             swagger_file,
41             error_response_template,
42             response_template,
43             common_args,
44         )
45         stage_vars = _get_stage_variables(stage_variables)
46         ret = swagger.verify_api(ret)
47         if ret.get("publish"):
48             if __opts__["test"]:
49                 ret["comment"] = (
50                     "[stage: {}] will be reassociated to an already available "
51                     "deployment that matched the given [api_name: {}] "
52                     "and [swagger_file: {}].\n"
53                     "Stage variables will be set "
54                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
55                 )
56                 ret["result"] = None
57                 return ret
58             return swagger.publish_api(ret, stage_vars)
59         if ret.get("current"):
60             if __opts__["test"]:
61                 ret["comment"] = (
62                     "[stage: {}] is already at desired state with an associated "
63                     "deployment matching the given [api_name: {}] "
64                     "and [swagger_file: {}].\n"
65                     "Stage variables will be set "
66                     "to {}.".format(stage_name, api_name, swagger_file, stage_vars)
67                 )
68                 ret["result"] = None
69             return swagger.overwrite_stage_variables(ret, stage_vars)
70         if __opts__["test"]:
71             ret["comment"] = (
72                 "There is no deployment matching the given [api_name: {}] "
73                 "and [swagger_file: {}].  A new deployment will be "
74                 "created and the [stage_name: {}] will then be associated "
75                 "to the newly created deployment.\n"
76                 "Stage variables will be set "
77                 "to {}.".format(api_name, swagger_file, stage_name, stage_vars)
78             )
79             ret["result"] = None
80             return ret
81         ret = swagger.deploy_api(ret)
82         if ret.get("abort"):
83             return ret
84         ret = swagger.deploy_models(ret)
85         if ret.get("abort"):
86             return ret
87         ret = swagger.deploy_resources(
88             ret,
89             api_key_required=api_key_required,
90             lambda_integration_role=lambda_integration_role,
91             lambda_region=lambda_region,
92             authorization_type=authorization_type,
93         )
94         if ret.get("abort"):
95             return ret
96         ret = swagger.publish_api(ret, stage_vars)
97     except (ValueError, OSError) as e:
98         ret["result"] = False
99         ret["comment"] = "{}".format(e.args)
100     return ret
101 def _get_stage_variables(stage_variables):
102     ret = dict()
103     if stage_variables is None:
104         return ret
105     if isinstance(stage_variables, str):
106         if stage_variables in __opts__:
107             ret = __opts__[stage_variables]
108         master_opts = __pillar__.get("master", {})
109         if stage_variables in master_opts:
110             ret = master_opts[stage_variables]
111         if stage_variables in __pillar__:
112             ret = __pillar__[stage_variables]
113     elif isinstance(stage_variables, dict):
114         ret = stage_variables
115     if not isinstance(ret, dict):
116         ret = dict()
117     return ret
118 def absent(
119     name,
120     api_name,
121     stage_name,
122     nuke_api=False,
123     region=None,
124     key=None,
125     keyid=None,
126     profile=None,
127 ):
128     ret = {"name": name, "result": True, "comment": "", "changes": {}}
129     try:
130         common_args = dict(
131             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
132         )
133         swagger = _Swagger(api_name, stage_name, "", None, None, None, common_args)
134         if not swagger.restApiId:
135             ret["comment"] = "[Rest API: {}] does not exist.".format(api_name)
136             return ret
137         if __opts__["test"]:
138             if nuke_api:
139                 ret["comment"] = (
140                     "[stage: {}] will be deleted, if there are no other "
141                     "active stages, the [api: {} will also be "
142                     "deleted.".format(stage_name, api_name)
143                 )
144             else:
145                 ret["comment"] = "[stage: {}] will be deleted.".format(stage_name)
146             ret["result"] = None
147             return ret
148         ret = swagger.delete_stage(ret)
149         if ret.get("abort"):
150             return ret
151         if nuke_api and swagger.no_more_deployments_remain():
152             ret = swagger.delete_api(ret)
153     except (ValueError, OSError) as e:
154         ret["result"] = False
155         ret["comment"] = "{}".format(e.args)
156     return ret
157 def _gen_md5_filehash(fname, *args):
158     _hash = hashlib.md5()
159     with salt.utils.files.fopen(fname, "rb") as f:
160         for chunk in iter(lambda: f.read(4096), b""):
161             _hash.update(chunk)
162     for extra_arg in args:
163         _hash.update(str(extra_arg).encode())
164     return _hash.hexdigest()
165 def _dict_to_json_pretty(d, sort_keys=True):
166     return salt.utils.json.dumps(
167         d, indent=4, separators=(",", ": "), sort_keys=sort_keys
168     )
169 def _name_matches(name, matches):
170     for m in matches:
171         if name.endswith(m):
172             return True
173         if name.lower().endswith("_" + m.lower()):
174             return True
175         if name.lower() == m.lower():
176             return True
177     return False
178 def _object_reducer(
179     o,
180     names=(
181         "id",
182         "name",
183         "path",
184         "httpMethod",
185         "statusCode",
186         "Created",
187         "Deleted",
188         "Updated",
189         "Flushed",
190         "Associated",
191         "Disassociated",
192     ),
193 ):
194     result = {}
195     if isinstance(o, dict):
196         for k, v in o.items():
197             if isinstance(v, dict):
198                 reduced = v if k == "variables" else _object_reducer(v, names)
199                 if reduced or _name_matches(k, names):
200                     result[k] = reduced
201             elif isinstance(v, list):
202                 newlist = []
203                 for val in v:
204                     reduced = _object_reducer(val, names)
205                     if reduced or _name_matches(k, names):
206                         newlist.append(reduced)
207                 if newlist:
208                     result[k] = newlist
209             else:
210                 if _name_matches(k, names):
211                     result[k] = v
212     return result
213 def _log_changes(ret, changekey, changevalue):
214     cl = ret["changes"].get("new", [])
215     cl.append({changekey: _object_reducer(changevalue)})
216     ret["changes"]["new"] = cl
217     return ret
218 def _log_error_and_abort(ret, obj):
219     ret["result"] = False
220     ret["abort"] = True
221     if "error" in obj:
222         ret["comment"] = "{}".format(obj.get("error"))
223     return ret
224 class _Swagger:
225     SWAGGER_OBJ_V2_FIELDS = (
226         "swagger",
227         "info",
228         "host",
229         "basePath",
230         "schemes",
231         "consumes",
232         "produces",
233         "paths",
234         "definitions",
235         "parameters",
236         "responses",
237         "securityDefinitions",
238         "security",
239         "tags",
240         "externalDocs",
241     )
242     SWAGGER_OBJ_V2_FIELDS_REQUIRED = (
243         "swagger",
244         "info",
245         "basePath",
246         "schemes",
247         "paths",
248         "definitions",
249     )
250     SWAGGER_OPERATION_NAMES = (
251         "get",
252         "put",
253         "post",
254         "delete",
255         "options",
256         "head",
257         "patch",
258     )
259     SWAGGER_VERSIONS_SUPPORTED = ("2.0",)
260     VENDOR_EXT_PATTERN = re.compile("^x-")
261     JSON_SCHEMA_DRAFT_4 = "http://json-schema.org/draft-04/schema#"
262     REQUEST_TEMPLATE = {
263         "application/json": (
264             "#set($inputRoot = $input.path('$'))\n{\n\"header_params\" : {\n#set ($map"
265             " = $input.params().header)\n#foreach( $param in $map.entrySet()"
266             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
267             ' #end\n#end\n},\n"query_params" : {\n#set ($map ='
268             " $input.params().querystring)\n#foreach( $param in $map.entrySet()"
269             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
270             ' #end\n#end\n},\n"path_params" : {\n#set ($map ='
271             " $input.params().path)\n#foreach( $param in $map.entrySet()"
272             ' )\n"$param.key" : "$param.value" #if( $foreach.hasNext ),'
273             ' #end\n#end\n},\n"apigw_context" : {\n"apiId":'
274             ' "$context.apiId",\n"httpMethod": "$context.httpMethod",\n"requestId":'
275             ' "$context.requestId",\n"resourceId":'
276             ' "$context.resourceId",\n"resourcePath":'
277             ' "$context.resourcePath",\n"stage": "$context.stage",\n"identity": {\n '
278             ' "user":"$context.identity.user",\n '
279             ' "userArn":"$context.identity.userArn",\n '
280             ' "userAgent":"$context.identity.userAgent",\n '
281             ' "sourceIp":"$context.identity.sourceIp",\n '
282             ' "cognitoIdentityId":"$context.identity.cognitoIdentityId",\n '
283             ' "cognitoIdentityPoolId":"$context.identity.cognitoIdentityPoolId",\n '
284             ' "cognitoAuthenticationType":"$context.identity.cognitoAuthenticationType",\n'
285             '  "cognitoAuthenticationProvider":["$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)"],\n'
286             '  "caller":"$context.identity.caller",\n '
287             ' "apiKey":"$context.identity.apiKey",\n '
288             ' "accountId":"$context.identity.accountId"\n}\n},\n"body_params" :'
289             " $input.json('$'),\n\"stage_variables\": {\n#foreach($variable in"
290             ' $stageVariables.keySet())\n"$variable":'
291             ' "$util.escapeJavaScript($stageVariables.get($variable))"\n#if($foreach.hasNext),'
292             " #end\n#end\n}\n}"
293         )
294     }
295     REQUEST_OPTION_TEMPLATE = {"application/json": '{"statusCode": 200}'}
296     RESPONSE_TEMPLATE = {
297         "application/json": (
298             "#set($inputRoot = $input.path('$'))\n"
299             "{\n"
300             '  "errorMessage" : "$inputRoot.errorMessage",\n'
301             '  "errorType" : "$inputRoot.errorType",\n'
302             '  "stackTrace" : [\n'
303             "#foreach($stackTrace in $inputRoot.stackTrace)\n"
304             "    [\n"
305             "#foreach($elem in $stackTrace)\n"
306             '      "$elem"\n'
307             "#if($foreach.hasNext),#end\n"
308             "#end\n"
309             "    ]\n"
310             "#if($foreach.hasNext),#end\n"
311             "#end\n"
312             "  ]\n"
313             "}"
314         )
315     }
316     RESPONSE_OPTION_TEMPLATE = {}
317     AWS_API_DESCRIPTION = _dict_to_json_pretty(
318         {
319             "provisioned_by": "Salt boto_apigateway.present State",
320             "context": "See deployment or stage description",
321         }
322     )
323     class SwaggerParameter:
324         LOCATIONS = ("body", "query", "header", "path")
325         def __init__(self, paramdict):
326             self._paramdict = paramdict
327         @property
328         def location(self):
329             _location = self._paramdict.get("in")
330             if _location in _Swagger.SwaggerParameter.LOCATIONS:
331                 return _location
332             raise ValueError(
333                 "Unsupported parameter location: {} in Parameter Object".format(
334                     _location
335                 )
336             )
337         @property
338         def name(self):
339             _name = self._paramdict.get("name")
340             if _name:
341                 if self.location == "header":
342                     return "method.request.header.{}".format(_name)
343                 elif self.location == "query":
344                     return "method.request.querystring.{}".format(_name)
345                 elif self.location == "path":
346                     return "method.request.path.{}".format(_name)
347                 return None
348             raise ValueError(
349                 "Parameter must have a name: {}".format(
350                     _dict_to_json_pretty(self._paramdict)
351                 )
352             )
353         @property
354         def schema(self):
355             if self.location == "body":
356                 _schema = self._paramdict.get("schema")
357                 if _schema:
358                     if "$ref" in _schema:
359                         schema_name = _schema.get("$ref").split("/")[-1]
360                         return schema_name
361                     raise ValueError(
362                         "Body parameter must have a JSON reference "
363                         "to the schema definition due to Amazon API restrictions: {}".format(
364                             self.name
365                         )
366                     )
367                 raise ValueError(
368                     "Body parameter must have a schema: {}".format(self.name)
369                 )
370             return None
371     class SwaggerMethodResponse:
372         def __init__(self, r):
373             self._r = r
374         @property
375         def schema(self):
376             _schema = self._r.get("schema")
377             if _schema:
378                 if "$ref" in _schema:
379                     return _schema.get("$ref").split("/")[-1]
380                 raise ValueError(
381                     "Method response must have a JSON reference "
382                     "to the schema definition: {}".format(_schema)
383                 )
384             return None
385         @property
386         def headers(self):
387             _headers = self._r.get("headers", {})
388             return _headers
389     def __init__(
390         self,
391         api_name,
392         stage_name,
393         lambda_funcname_format,
394         swagger_file_path,
395         error_response_template,
396         response_template,
397         common_aws_args,
398     ):
399         self._api_name = api_name
400         self._stage_name = stage_name
401         self._lambda_funcname_format = lambda_funcname_format
402         self._common_aws_args = common_aws_args
403         self._restApiId = ""
404         self._deploymentId = ""
405         self._error_response_template = error_response_template
406         self._response_template = response_template
407         if swagger_file_path is not None:
408             if os.path.exists(swagger_file_path) and os.path.isfile(swagger_file_path):
409                 self._swagger_file = swagger_file_path
410                 self._md5_filehash = _gen_md5_filehash(
411                     self._swagger_file, error_response_template, response_template
412                 )
413                 with salt.utils.files.fopen(self._swagger_file, "rb") as sf:
414                     self._cfg = salt.utils.yaml.safe_load(sf)
415                 self._swagger_version = ""
416             else:
417                 raise OSError("Invalid swagger file path, {}".format(swagger_file_path))
418             self._validate_swagger_file()
419         self._validate_lambda_funcname_format()
420         self._resolve_api_id()
421     def _is_http_error_rescode(self, code):
422         return bool(re.match(r"^\s*[45]\d\d\s*$", code))
423     def _validate_error_response_model(self, paths, mods):
424         for path, ops in paths:
425             for opname, opobj in ops.items():
426                 if opname not in _Swagger.SWAGGER_OPERATION_NAMES:
427                     continue
428                 if "responses" not in opobj:
429                     raise ValueError(
430                         "missing mandatory responses field in path item object"
431                     )
432                 for rescode, resobj in opobj.get("responses").items():
433                     if not self._is_http_error_rescode(str(rescode)):
434                         continue
435                     if "schema" not in resobj:
436                         raise ValueError(
437                             "missing schema field in path {}, "
438                             "op {}, response {}".format(path, opname, rescode)
439                         )
440                     schemaobj = resobj.get("schema")
441                     if "$ref" not in schemaobj:
442                         raise ValueError(
443                             "missing $ref field under schema in "
444                             "path {}, op {}, response {}".format(path, opname, rescode)
445                         )
446                     schemaobjref = schemaobj.get("$ref", "/")
447                     modelname = schemaobjref.split("/")[-1]
448                     if modelname not in mods:
449                         raise ValueError(
450                             "model schema {} reference not found "
451                             "under /definitions".format(schemaobjref)
452                         )
453                     model = mods.get(modelname)
454                     if model.get("type") != "object":
455                         raise ValueError(
456                             "model schema {} must be type object".format(modelname)
457                         )
458                     if "properties" not in model:
459                         raise ValueError(
460                             "model schema {} must have properties fields".format(
461                                 modelname
462                             )
463                         )
464                     modelprops = model.get("properties")
465                     if "errorMessage" not in modelprops:
466                         raise ValueError(
467                             "model schema {} must have errorMessage as a property to "
468                             "match AWS convention. If pattern is not set, .+ will "
469                             "be used".format(modelname)
470                         )
471     def _validate_lambda_funcname_format(self):
472         try:
473             if self._lambda_funcname_format:
474                 known_kwargs = dict(stage="", api="", resource="", method="")
475                 self._lambda_funcname_format.format(**known_kwargs)
476             return True
477         except Exception:  # pylint: disable=broad-except
478             raise ValueError(
479                 "Invalid lambda_funcname_format {}.  Please review "
480                 "documentation for known substitutable keys".format(
481                     self._lambda_funcname_format
482                 )
483             )
484     def _validate_swagger_file(self):
485         for field in self._cfg:
486             if (
487                 field not in _Swagger.SWAGGER_OBJ_V2_FIELDS
488                 and not _Swagger.VENDOR_EXT_PATTERN.match(field)
489             ):
490                 raise ValueError("Invalid Swagger Object Field: {}".format(field))
491         for field in _Swagger.SWAGGER_OBJ_V2_FIELDS_REQUIRED:
492             if field not in self._cfg:
493                 raise ValueError("Missing Swagger Object Field: {}".format(field))
494         self._swagger_version = self._cfg.get("swagger")
495         if self._swagger_version not in _Swagger.SWAGGER_VERSIONS_SUPPORTED:
496             raise ValueError(
497                 "Unsupported Swagger version: {},Supported versions are {}".format(
498                     self._swagger_version, _Swagger.SWAGGER_VERSIONS_SUPPORTED
499                 )
500             )
501         log.info(type(self._models))
502         self._validate_error_response_model(self.paths, self._models())
503     @property
504     def md5_filehash(self):
505         return self._md5_filehash
506     @property
507     def info(self):
508         info = self._cfg.get("info")
509         if not info:
510             raise ValueError("Info Object has no values")
511         return info
512     @property
513     def info_json(self):
514         return _dict_to_json_pretty(self.info)
515     @property
516     def rest_api_name(self):
517         return self._api_name
518     @property
519     def rest_api_version(self):
520         version = self.info.get("version")
521         if not version:
522             raise ValueError("Missing version value in Info Object")
523         return version
524     def _models(self):
525         models = self._cfg.get("definitions")
526         if not models:
527             raise ValueError(
528                 "Definitions Object has no values, You need to define them in your"
529                 " swagger file"
530             )
531         return models
532     def models(self):
533         model_dict = self._build_all_dependencies()
534         while True:
535             model = self._get_model_without_dependencies(model_dict)
536             if not model:
537                 break
538             yield (model, self._models().get(model))
539     @property
540     def paths(self):
541         paths = self._cfg.get("paths")
542         if not paths:
543             raise ValueError(
544                 "Paths Object has no values, You need to define them in your swagger"
545                 " file"
546             )
547         for path in paths:
548             if not path.startswith("/"):
549                 raise ValueError(
550                     "Path object {} should start with /. Please fix it".format(path)
551                 )
552         return paths.items()
553     @property
554     def basePath(self):
555         basePath = self._cfg.get("basePath", "")
556         return basePath
557     @property
558     def restApiId(self):
559         return self._restApiId
560     @restApiId.setter
561     def restApiId(self, restApiId):
562         self._restApiId = restApiId
563     @property
564     def deployment_label_json(self):
565         return _dict_to_json_pretty(self.deployment_label)
566     @property
567     def deployment_label(self):
568         label = dict()
569         label["swagger_info_object"] = self.info
570         label["api_name"] = self.rest_api_name
571         label["swagger_file"] = os.path.basename(self._swagger_file)
572         label["swagger_file_md5sum"] = self.md5_filehash
573         return label
574     def _one_or_more_stages_remain(self, deploymentId):
575         stages = __salt__["boto_apigateway.describe_api_stages"](
576             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
577         ).get("stages")
578         return bool(stages)
579     def no_more_deployments_remain(self):
580         no_more_deployments = True
581         deployments = __salt__["boto_apigateway.describe_api_deployments"](
582             restApiId=self.restApiId, **self._common_aws_args
583         ).get("deployments")
584         if deployments:
585             for deployment in deployments:
586                 deploymentId = deployment.get("id")
587                 stages = __salt__["boto_apigateway.describe_api_stages"](
588                     restApiId=self.restApiId,
589                     deploymentId=deploymentId,
590                     **self._common_aws_args
591                 ).get("stages")
592                 if stages:
593                     no_more_deployments = False
594                     break
595         return no_more_deployments
596     def _get_current_deployment_id(self):
597         deploymentId = ""
598         stage = __salt__["boto_apigateway.describe_api_stage"](
599             restApiId=self.restApiId,
600             stageName=self._stage_name,
601             **self._common_aws_args
602         ).get("stage")
603         if stage:
604             deploymentId = stage.get("deploymentId")
605         return deploymentId
606     def _get_current_deployment_label(self):
607         deploymentId = self._get_current_deployment_id()
608         deployment = __salt__["boto_apigateway.describe_api_deployment"](
609             restApiId=self.restApiId, deploymentId=deploymentId, **self._common_aws_args
610         ).get("deployment")
611         if deployment:
612             return deployment.get("description")
613         return None
614     def _get_desired_deployment_id(self):
615         deployments = __salt__["boto_apigateway.describe_api_deployments"](
616             restApiId=self.restApiId, **self._common_aws_args
617         ).get("deployments")
618         if deployments:
619             for deployment in deployments:
620                 if deployment.get("description") == self.deployment_label_json:
621                     return deployment.get("id")
622         return ""
623     def overwrite_stage_variables(self, ret, stage_variables):
624         res = __salt__["boto_apigateway.overwrite_api_stage_variables"](
625             restApiId=self.restApiId,
626             stageName=self._stage_name,
627             variables=stage_variables,
628             **self._common_aws_args
629         )
630         if not res.get("overwrite"):
631             ret["result"] = False
632             ret["abort"] = True
633             ret["comment"] = res.get("error")
634         else:
635             ret = _log_changes(ret, "overwrite_stage_variables", res.get("stage"))
636         return ret
637     def _set_current_deployment(self, stage_desc_json, stage_variables):
638         stage = __salt__["boto_apigateway.describe_api_stage"](
639             restApiId=self.restApiId,
640             stageName=self._stage_name,
641             **self._common_aws_args
642         ).get("stage")
643         if not stage:
644             stage = __salt__["boto_apigateway.create_api_stage"](
645                 restApiId=self.restApiId,
646                 stageName=self._stage_name,
647                 deploymentId=self._deploymentId,
648                 description=stage_desc_json,
649                 variables=stage_variables,
650                 **self._common_aws_args
651             )
652             if not stage.get("stage"):
653                 return {"set": False, "error": stage.get("error")}
654         else:
655             overwrite = __salt__["boto_apigateway.overwrite_api_stage_variables"](
656                 restApiId=self.restApiId,
657                 stageName=self._stage_name,
658                 variables=stage_variables,
659                 **self._common_aws_args
660             )
661             if not overwrite.get("stage"):
662                 return {"set": False, "error": overwrite.get("error")}
663         return __salt__["boto_apigateway.activate_api_deployment"](
664             restApiId=self.restApiId,
665             stageName=self._stage_name,
666             deploymentId=self._deploymentId,
667             **self._common_aws_args
668         )
669     def _resolve_api_id(self):
670         apis = __salt__["boto_apigateway.describe_apis"](
671             name=self.rest_api_name,
672             description=_Swagger.AWS_API_DESCRIPTION,
673             **self._common_aws_args
674         ).get("restapi")
675         if apis:
676             if len(apis) == 1:
677                 self.restApiId = apis[0].get("id")
678             else:
679                 raise ValueError(
680                     "Multiple APIs matching given name {} and description {}".format(
681                         self.rest_api_name, self.info_json
682                     )
683                 )
684     def delete_stage(self, ret):
685         deploymentId = self._get_current_deployment_id()
686         if deploymentId:
687             result = __salt__["boto_apigateway.delete_api_stage"](
688                 restApiId=self.restApiId,
689                 stageName=self._stage_name,
690                 **self._common_aws_args
691             )
692             if not result.get("deleted"):
693                 ret["abort"] = True
694                 ret["result"] = False
695                 ret["comment"] = "delete_stage delete_api_stage, {}".format(
696                     result.get("error")
697                 )
698             else:
699                 if not self._one_or_more_stages_remain(deploymentId):
700                     result = __salt__["boto_apigateway.delete_api_deployment"](
701                         restApiId=self.restApiId,
702                         deploymentId=deploymentId,
703                         **self._common_aws_args
704                     )
705                     if not result.get("deleted"):
706                         ret["abort"] = True
707                         ret["result"] = False
708                         ret[
709                             "comment"
710                         ] = "delete_stage delete_api_deployment, {}".format(
711                             result.get("error")
712                         )
713                 else:
714                     ret["comment"] = "stage {} has been deleted.\n".format(
715                         self._stage_name
716                     )
717         else:
718             ret["comment"] = "stage {} does not exist".format(self._stage_name)
719         return ret
720     def verify_api(self, ret):
721         if self.restApiId:
722             deployed_label_json = self._get_current_deployment_label()
723             if deployed_label_json == self.deployment_label_json:
724                 ret["comment"] = (
725                     "Already at desired state, the stage {} is already at the desired "
726                     "deployment label:\n{}".format(
727                         self._stage_name, deployed_label_json
728                     )
729                 )
730                 ret["current"] = True
731                 return ret
732             else:
733                 self._deploymentId = self._get_desired_deployment_id()
734                 if self._deploymentId:
735                     ret["publish"] = True
736         return ret
737     def publish_api(self, ret, stage_variables):
738         stage_desc = dict()
739         stage_desc["current_deployment_label"] = self.deployment_label
740         stage_desc_json = _dict_to_json_pretty(stage_desc)
741         if self._deploymentId:
742             res = self._set_current_deployment(stage_desc_json, stage_variables)
743             if not res.get("set"):
744                 ret["abort"] = True
745                 ret["result"] = False
746                 ret["comment"] = res.get("error")
747             else:
748                 ret = _log_changes(
749                     ret,
750                     "publish_api (reassociate deployment, set stage_variables)",
751                     res.get("response"),
752                 )
753         else:
754             res = __salt__["boto_apigateway.create_api_deployment"](
755                 restApiId=self.restApiId,
756                 stageName=self._stage_name,
757                 stageDescription=stage_desc_json,
758                 description=self.deployment_label_json,
759                 variables=stage_variables,
760                 **self._common_aws_args
761             )
762             if not res.get("created"):
763                 ret["abort"] = True
764                 ret["result"] = False
765                 ret["comment"] = res.get("error")
766             else:
767                 ret = _log_changes(
768                     ret, "publish_api (new deployment)", res.get("deployment")
769                 )
770         return ret
771     def _cleanup_api(self):
772         resources = __salt__["boto_apigateway.describe_api_resources"](
773             restApiId=self.restApiId, **self._common_aws_args
774         )
775         if resources.get("resources"):
776             res = resources.get("resources")[1:]
777             res.reverse()
778             for resource in res:
779                 delres = __salt__["boto_apigateway.delete_api_resources"](
780                     restApiId=self.restApiId,
781                     path=resource.get("path"),
782                     **self._common_aws_args
783                 )
784                 if not delres.get("deleted"):
785                     return delres
786         models = __salt__["boto_apigateway.describe_api_models"](
787             restApiId=self.restApiId, **self._common_aws_args
788         )
789         if models.get("models"):
790             for model in models.get("models"):
791                 delres = __salt__["boto_apigateway.delete_api_model"](
792                     restApiId=self.restApiId,
793                     modelName=model.get("name"),
794                     **self._common_aws_args
795                 )
796                 if not delres.get("deleted"):
797                     return delres
798         return {"deleted": True}
799     def deploy_api(self, ret):
800         if self.restApiId:
801             res = self._cleanup_api()
802             if not res.get("deleted"):
803                 ret["comment"] = "Failed to cleanup restAreId {}".format(self.restApiId)
804                 ret["abort"] = True
805                 ret["result"] = False
806                 return ret
807             return ret
808         response = __salt__["boto_apigateway.create_api"](
809             name=self.rest_api_name,
810             description=_Swagger.AWS_API_DESCRIPTION,
811             **self._common_aws_args
812         )
813         if not response.get("created"):
814             ret["result"] = False
815             ret["abort"] = True
816             if "error" in response:
817                 ret["comment"] = "Failed to create rest api: {}.".format(
818                     response["error"]["message"]
819                 )
820             return ret
821         self.restApiId = response.get("restapi", {}).get("id")
822         return _log_changes(ret, "deploy_api", response.get("restapi"))
823     def delete_api(self, ret):
824         exists_response = __salt__["boto_apigateway.api_exists"](
825             name=self.rest_api_name,
826             description=_Swagger.AWS_API_DESCRIPTION,
827             **self._common_aws_args
828         )
829         if exists_response.get("exists"):
830             if __opts__["test"]:
831                 ret["comment"] = "Rest API named {} is set to be deleted.".format(
832                     self.rest_api_name
833                 )
834                 ret["result"] = None
835                 ret["abort"] = True
836                 return ret
837             delete_api_response = __salt__["boto_apigateway.delete_api"](
838                 name=self.rest_api_name,
839                 description=_Swagger.AWS_API_DESCRIPTION,
840                 **self._common_aws_args
841             )
842             if not delete_api_response.get("deleted"):
843                 ret["result"] = False
844                 ret["abort"] = True
845                 if "error" in delete_api_response:
846                     ret["comment"] = "Failed to delete rest api: {}.".format(
847                         delete_api_response["error"]["message"]
848                     )
849                 return ret
850             ret = _log_changes(ret, "delete_api", delete_api_response)
851         else:
852             ret["comment"] = "api already absent for swagger file: {}, desc: {}".format(
853                 self.rest_api_name, self.info_json
854             )
855         return ret
856     def _aws_model_ref_from_swagger_ref(self, r):
857         model_name = r.split("/")[-1]
858         return "https://apigateway.amazonaws.com/restapis/{}/models/{}".format(
859             self.restApiId, model_name
860         )
861     def _update_schema_to_aws_notation(self, schema):
862         result = {}
863         for k, v in schema.items():
864             if k == "$ref":
865                 v = self._aws_model_ref_from_swagger_ref(v)
866             if isinstance(v, dict):
867                 v = self._update_schema_to_aws_notation(v)
868             result[k] = v
869         return result
870     def _build_dependent_model_list(self, obj_schema):
871         dep_models_list = []
872         if obj_schema:
873             obj_schema["type"] = obj_schema.get("type", "object")
874         if obj_schema["type"] == "array":
875             dep_models_list.extend(
876                 self._build_dependent_model_list(obj_schema.get("items", {}))
877             )
878         else:
879             ref = obj_schema.get("$ref")
880             if ref:
881                 ref_obj_model = ref.split("/")[-1]
882                 ref_obj_schema = self._models().get(ref_obj_model)
883                 dep_models_list.extend(self._build_dependent_model_list(ref_obj_schema))
884                 dep_models_list.extend([ref_obj_model])
885             else:
886                 properties = obj_schema.get("properties")
887                 if properties:
888                     for _, prop_obj_schema in properties.items():
889                         dep_models_list.extend(
890                             self._build_dependent_model_list(prop_obj_schema)
891                         )
892         return list(set(dep_models_list))
893     def _build_all_dependencies(self):
894         ret = {}
895         for model, schema in self._models().items():
896             dep_list = self._build_dependent_model_list(schema)
897             ret[model] = dep_list
898         return ret
899     def _get_model_without_dependencies(self, models_dict):
900         next_model = None
901         if not models_dict:
902             return next_model
903         for model, dependencies in models_dict.items():
904             if dependencies == []:
905                 next_model = model
906                 break
907         if next_model is None:
908             raise ValueError(
909                 "incomplete model definitions, models in dependency "
910                 "list not defined: {}".format(models_dict)
911             )
912         models_dict.pop(next_model)
913         for model, dep_list in models_dict.items():
914             if next_model in dep_list:
915                 dep_list.remove(next_model)
916         return next_model
917     def deploy_models(self, ret):
918         for model, schema in self.models():
919             _schema = self._update_schema_to_aws_notation(schema)
920             _schema.update(
921                 {
922                     "$schema": _Swagger.JSON_SCHEMA_DRAFT_4,
923                     "title": "{} Schema".format(model),
924                 }
925             )
926             model_exists_response = __salt__["boto_apigateway.api_model_exists"](
927                 restApiId=self.restApiId, modelName=model, **self._common_aws_args
928             )
929             if model_exists_response.get("exists"):
930                 update_model_schema_response = __salt__[
931                     "boto_apigateway.update_api_model_schema"
932                 ](
933                     restApiId=self.restApiId,
934                     modelName=model,
935                     schema=_dict_to_json_pretty(_schema),
936                     **self._common_aws_args
937                 )
938                 if not update_model_schema_response.get("updated"):
939                     ret["result"] = False
940                     ret["abort"] = True
941                     if "error" in update_model_schema_response:
942                         ret[
943                             "comment"
944                         ] = "Failed to update existing model {} with schema {}, " "error: {}".format(
945                             model,
946                             _dict_to_json_pretty(schema),
947                             update_model_schema_response["error"]["message"],
948                         )
949                     return ret
950                 ret = _log_changes(ret, "deploy_models", update_model_schema_response)
951             else:
952                 create_model_response = __salt__["boto_apigateway.create_api_model"](
953                     restApiId=self.restApiId,
954                     modelName=model,
955                     modelDescription=model,
956                     schema=_dict_to_json_pretty(_schema),
957                     contentType="application/json",
958                     **self._common_aws_args
959                 )
960                 if not create_model_response.get("created"):
961                     ret["result"] = False
962                     ret["abort"] = True
963                     if "error" in create_model_response:
964                         ret[
965                             "comment"
966                         ] = "Failed to create model {}, schema {}, error: {}".format(
967                             model,
968                             _dict_to_json_pretty(schema),
969                             create_model_response["error"]["message"],
970                         )
971                     return ret
972                 ret = _log_changes(ret, "deploy_models", create_model_response)
973         return ret
974     def _lambda_name(self, resourcePath, httpMethod):
975         lambda_name = self._lambda_funcname_format.format(
976             stage=self._stage_name,
977             api=self.rest_api_name,
978             resource=resourcePath,
979             method=httpMethod,
980         )
981         lambda_name = lambda_name.strip()
982         lambda_name = re.sub(r"{|}", "", lambda_name)
983         lambda_name = re.sub(r"\s+|/", "_", lambda_name).lower()
984         return re.sub(r"_+", "_", lambda_name)
985     def _lambda_uri(self, lambda_name, lambda_region):
986         profile = self._common_aws_args.get("profile")
987         region = self._common_aws_args.get("region")
988         lambda_region = __utils__["boto3.get_region"]("lambda", lambda_region, profile)
989         apigw_region = __utils__["boto3.get_region"]("apigateway", region, profile)
990         lambda_desc = __salt__["boto_lambda.describe_function"](
991             lambda_name, **self._common_aws_args
992         )
993         if lambda_region != apigw_region:
994             if not lambda_desc.get("function"):
995                 lambda_desc = __salt__["boto_lambda.describe_function"](
996                     lambda_name, **self._common_aws_args
997                 )
998         if not lambda_desc.get("function"):
999             raise ValueError(
1000                 "Could not find lambda function {} in regions [{}, {}].".format(
1001                     lambda_name, lambda_region, apigw_region
1002                 )
1003             )
1004         lambda_arn = lambda_desc.get("function").get("FunctionArn")
1005         lambda_uri = (
1006             "arn:aws:apigateway:{}:lambda:path/2015-03-31"
1007             "/functions/{}/invocations".format(apigw_region, lambda_arn)
1008         )
1009         return lambda_uri
1010     def _parse_method_data(self, method_name, method_data):
1011         method_params = {}
1012         method_models = {}
1013         if "parameters" in method_data:
1014             for param in method_data["parameters"]:
1015                 p = _Swagger.SwaggerParameter(param)
1016                 if p.name:
1017                     method_params[p.name] = True
1018                 if p.schema:
1019                     method_models["application/json"] = p.schema
1020         request_templates = (
1021             _Swagger.REQUEST_OPTION_TEMPLATE
1022             if method_name == "options"
1023             else _Swagger.REQUEST_TEMPLATE
1024         )
1025         integration_type = "MOCK" if method_name == "options" else "AWS"
1026         return {
1027             "params": method_params,
1028             "models": method_models,
1029             "request_templates": request_templates,
1030             "integration_type": integration_type,
1031         }
1032     def _find_patterns(self, o):
1033         result = []
1034         if isinstance(o, dict):
1035             for k, v in o.items():
1036                 if isinstance(v, dict):
1037                     result.extend(self._find_patterns(v))
1038                 else:
1039                     if k == "pattern":
1040                         result.append(v)
1041         return result
1042     def _get_pattern_for_schema(self, schema_name, httpStatus):
1043         defaultPattern = ".+" if self._is_http_error_rescode(httpStatus) else ".*"
1044         model = self._models().get(schema_name)
1045         patterns = self._find_patterns(model)
1046         return patterns[0] if patterns else defaultPattern
1047     def _get_response_template(self, method_name, http_status):
1048         if method_name == "options" or not self._is_http_error_rescode(http_status):
1049             response_templates = (
1050                 {"application/json": self._response_template}
1051                 if self._response_template
1052                 else self.RESPONSE_OPTION_TEMPLATE
1053             )
1054         else:
1055             response_templates = (
1056                 {"application/json": self._error_response_template}
1057                 if self._error_response_template
1058                 else self.RESPONSE_TEMPLATE
1059             )
1060         return response_templates
1061     def _parse_method_response(self, method_name, method_response, httpStatus):
1062         method_response_models = {}
1063         method_response_pattern = ".*"
1064         if method_response.schema:
1065             method_response_models["application/json"] = method_response.schema
1066             method_response_pattern = self._get_pattern_for_schema(
1067                 method_response.schema, httpStatus
1068             )
1069         method_response_params = {}
1070         method_integration_response_params = {}
1071         for header in method_response.headers:
1072             response_header = "method.response.header.{}".format(header)
1073             method_response_params[response_header] = False
1074             header_data = method_response.headers.get(header)
1075             method_integration_response_params[response_header] = (
1076                 "'{}'".format(header_data.get("default"))
1077                 if "default" in header_data
1078                 else "'*'"
1079             )
1080         response_templates = self._get_response_template(method_name, httpStatus)
1081         return {
1082             "params": method_response_params,
1083             "models": method_response_models,
1084             "integration_params": method_integration_response_params,
1085             "pattern": method_response_pattern,
1086             "response_templates": response_templates,
1087         }
1088     def _deploy_method(
1089         self,
1090         ret,
1091         resource_path,
1092         method_name,
1093         method_data,
1094         api_key_required,
1095         lambda_integration_role,
1096         lambda_region,
1097         authorization_type,
1098     ):
1099         method = self._parse_method_data(method_name.lower(), method_data)
1100         if method_name.lower() == "options":
1101             api_key_required = False
1102             authorization_type = "NONE"
1103         m = __salt__["boto_apigateway.create_api_method"](
1104             restApiId=self.restApiId,
1105             resourcePath=resource_path,
1106             httpMethod=method_name.upper(),
1107             authorizationType=authorization_type,
1108             apiKeyRequired=api_key_required,
1109             requestParameters=method.get("params"),
1110             requestModels=method.get("models"),
1111             **self._common_aws_args
1112         )
1113         if not m.get("created"):
1114             ret = _log_error_and_abort(ret, m)
1115             return ret
1116         ret = _log_changes(ret, "_deploy_method.create_api_method", m)
1117         lambda_uri = ""
1118         if method_name.lower() != "options":
1119             lambda_uri = self._lambda_uri(
1120                 self._lambda_name(resource_path, method_name),
1121                 lambda_region=lambda_region,
1122             )
1123         integration = __salt__["boto_apigateway.create_api_integration"](
1124             restApiId=self.restApiId,
1125             resourcePath=resource_path,
1126             httpMethod=method_name.upper(),
1127             integrationType=method.get("integration_type"),
1128             integrationHttpMethod="POST",
1129             uri=lambda_uri,
1130             credentials=lambda_integration_role,
1131             requestTemplates=method.get("request_templates"),
1132             **self._common_aws_args
1133         )
1134         if not integration.get("created"):
1135             ret = _log_error_and_abort(ret, integration)
1136             return ret
1137         ret = _log_changes(ret, "_deploy_method.create_api_integration", integration)
1138         if "responses" in method_data:
1139             for response, response_data in method_data["responses"].items():
1140                 httpStatus = str(response)
1141                 method_response = self._parse_method_response(
1142                     method_name.lower(),
1143                     _Swagger.SwaggerMethodResponse(response_data),
1144                     httpStatus,
1145                 )
1146                 mr = __salt__["boto_apigateway.create_api_method_response"](
1147                     restApiId=self.restApiId,
1148                     resourcePath=resource_path,
1149                     httpMethod=method_name.upper(),
1150                     statusCode=httpStatus,
1151                     responseParameters=method_response.get("params"),
1152                     responseModels=method_response.get("models"),
1153                     **self._common_aws_args
1154                 )
1155                 if not mr.get("created"):
1156                     ret = _log_error_and_abort(ret, mr)
1157                     return ret
1158                 ret = _log_changes(ret, "_deploy_method.create_api_method_response", mr)
1159                 mir = __salt__["boto_apigateway.create_api_integration_response"](
1160                     restApiId=self.restApiId,
1161                     resourcePath=resource_path,
1162                     httpMethod=method_name.upper(),
1163                     statusCode=httpStatus,
1164                     selectionPattern=method_response.get("pattern"),
1165                     responseParameters=method_response.get("integration_params"),
1166                     responseTemplates=method_response.get("response_templates"),
1167                     **self._common_aws_args
1168                 )
1169                 if not mir.get("created"):
1170                     ret = _log_error_and_abort(ret, mir)
1171                     return ret
1172                 ret = _log_changes(
1173                     ret, "_deploy_method.create_api_integration_response", mir
1174                 )
1175         else:
1176             raise ValueError(
1177                 "No responses specified for {} {}".format(resource_path, method_name)
1178             )
1179         return ret
1180     def deploy_resources(
1181         self,
1182         ret,
1183         api_key_required,
1184         lambda_integration_role,
1185         lambda_region,
1186         authorization_type,
1187     ):
1188         for path, pathData in self.paths:
1189             resource = __salt__["boto_apigateway.create_api_resources"](
1190                 restApiId=self.restApiId, path=path, **self._common_aws_args
1191             )
1192             if not resource.get("created"):
1193                 ret = _log_error_and_abort(ret, resource)
1194                 return ret
1195             ret = _log_changes(ret, "deploy_resources", resource)
1196             for method, method_data in pathData.items():
1197                 if method in _Swagger.SWAGGER_OPERATION_NAMES:
1198                     ret = self._deploy_method(
1199                         ret,
1200                         path,
1201                         method,
1202                         method_data,
1203                         api_key_required,
1204                         lambda_integration_role,
1205                         lambda_region,
1206                         authorization_type,
1207                     )
1208         return ret
1209 def usage_plan_present(
1210     name,
1211     plan_name,
1212     description=None,
1213     throttle=None,
1214     quota=None,
1215     region=None,
1216     key=None,
1217     keyid=None,
1218     profile=None,
1219 ):
1220     func_params = locals()
1221     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1222     try:
1223         common_args = dict(
1224             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1225         )
1226         existing = __salt__["boto_apigateway.describe_usage_plans"](
1227             name=plan_name, **common_args
1228         )
1229         if "error" in existing:
1230             ret["result"] = False
1231             ret["comment"] = "Failed to describe existing usage plans"
1232             return ret
1233         if not existing["plans"]:
1234             if __opts__["test"]:
1235                 ret["comment"] = "a new usage plan {} would be created".format(
1236                     plan_name
1237                 )
1238                 ret["result"] = None
1239                 return ret
1240             result = __salt__["boto_apigateway.create_usage_plan"](
1241                 name=plan_name,
1242                 description=description,
1243                 throttle=throttle,
1244                 quota=quota,
1245                 **common_args
1246             )
1247             if "error" in result:
1248                 ret["result"] = False
1249                 ret["comment"] = "Failed to create a usage plan {}, {}".format(
1250                     plan_name, result["error"]
1251                 )
1252                 return ret
1253             ret["changes"]["old"] = {"plan": None}
1254             ret["comment"] = "A new usage plan {} has been created".format(plan_name)
1255         else:
1256             plan = existing["plans"][0]
1257             needs_updating = False
1258             modifiable_params = (
1259                 ("throttle", ("rateLimit", "burstLimit")),
1260                 ("quota", ("limit", "offset", "period")),
1261             )
1262             for p, fields in modifiable_params:
1263                 for f in fields:
1264                     actual_param = (
1265                         {} if func_params.get(p) is None else func_params.get(p)
1266                     )
1267                     if plan.get(p, {}).get(f, None) != actual_param.get(f, None):
1268                         needs_updating = True
1269 <a name="0"></a>                        break
1270             if not needs_updating:
1271                 ret<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "usage plan {} is already in a correct state".format(
1272                     plan_name
1273                 )
1274                 ret["result"] = True
1275                 return ret
1276             if __opts__["test"]:
1277                 ret["comment"] =</b></font> "a new usage plan {} would be updated".format(
1278                     plan_name
1279                 )
1280                 ret["result"] = None
1281                 return ret
1282             result = __salt__["boto_apigateway.update_usage_plan"](
1283                 plan["id"], throttle=throttle, quota=quota, **common_args
1284             )
1285             if "error" in result:
1286                 ret["result"] = False
1287                 ret["comment"] = "Failed to update a usage plan {}, {}".format(
1288                     plan_name, result["error"]
1289                 )
1290                 return ret
1291             ret["changes"]["old"] = {"plan": plan}
1292             ret["comment"] = "usage plan {} has been updated".format(plan_name)
1293         newstate = __salt__["boto_apigateway.describe_usage_plans"](
1294             name=plan_name, **common_args
1295         )
1296         if "error" in existing:
1297             ret["result"] = False
1298             ret["comment"] = "Failed to describe existing usage plans after updates"
1299             return ret
1300         ret["changes"]["new"] = {"plan": newstate["plans"][0]}
1301     except (ValueError, OSError) as e:
1302         ret["result"] = False
1303         ret["comment"] = "{}".format(e.args)
1304     return ret
1305 def usage_plan_absent(name, plan_name, region=None, key=None, keyid=None, profile=None):
1306     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1307     try:
1308         common_args = dict(
1309             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1310         )
1311         existing = __salt__["boto_apigateway.describe_usage_plans"](
1312             name=plan_name, **common_args
1313         )
1314         if "error" in existing:
1315             ret["result"] = False
1316             ret["comment"] = "Failed to describe existing usage plans"
1317             return ret
1318         if not existing["plans"]:
1319             ret["comment"] = "Usage plan {} does not exist already".format(plan_name)
1320             return ret
1321         if __opts__["test"]:
1322             ret["comment"] = "Usage plan {} exists and would be deleted".format(
1323                 plan_name
1324             )
1325             ret["result"] = None
1326             return ret
1327         plan_id = existing["plans"][0]["id"]
1328         result = __salt__["boto_apigateway.delete_usage_plan"](plan_id, **common_args)
1329         if "error" in result:
1330             ret["result"] = False
1331             ret["comment"] = "Failed to delete usage plan {}, {}".format(
1332                 plan_name, result
1333             )
1334             return ret
1335         ret["comment"] = "Usage plan {} has been deleted".format(plan_name)
1336         ret["changes"]["old"] = {"plan": existing["plans"][0]}
1337         ret["changes"]["new"] = {"plan": None}
1338     except (ValueError, OSError) as e:
1339         ret["result"] = False
1340         ret["comment"] = "{}".format(e.args)
1341     return ret
1342 def usage_plan_association_present(
1343     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1344 ):
1345     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1346     try:
1347         common_args = dict(
1348             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1349         )
1350         existing = __salt__["boto_apigateway.describe_usage_plans"](
1351             name=plan_name, **common_args
1352         )
1353         if "error" in existing:
1354             ret["result"] = False
1355             ret["comment"] = "Failed to describe existing usage plans"
1356             return ret
1357         if not existing["plans"]:
1358             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1359             ret["result"] = False
1360             return ret
1361         if len(existing["plans"]) != 1:
1362             ret["comment"] = (
1363                 "There are multiple usage plans with the same name - it is not"
1364                 " supported"
1365             )
1366             ret["result"] = False
1367             return ret
1368         plan = existing["plans"][0]
1369         plan_id = plan["id"]
1370         plan_stages = plan.get("apiStages", [])
1371         stages_to_add = []
1372         for api in api_stages:
1373             if api not in plan_stages:
1374                 stages_to_add.append(api)
1375         if not stages_to_add:
1376             ret["comment"] = "Usage plan is already asssociated to all api stages"
1377             return ret
1378         result = __salt__["boto_apigateway.attach_usage_plan_to_apis"](
1379             plan_id, stages_to_add, **common_args
1380         )
1381         if "error" in result:
1382             ret[
1383                 "comment"
1384             ] = "Failed to associate a usage plan {} to the apis {}, {}".format(
1385                 plan_name, stages_to_add, result["error"]
1386             )
1387             ret["result"] = False
1388             return ret
1389         ret["comment"] = "successfully associated usage plan to apis"
1390         ret["changes"]["old"] = plan_stages
1391         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1392     except (ValueError, OSError) as e:
1393         ret["result"] = False
1394         ret["comment"] = "{}".format(e.args)
1395     return ret
1396 def usage_plan_association_absent(
1397     name, plan_name, api_stages, region=None, key=None, keyid=None, profile=None
1398 ):
1399     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1400     try:
1401         common_args = dict(
1402             [("region", region), ("key", key), ("keyid", keyid), ("profile", profile)]
1403         )
1404         existing = __salt__["boto_apigateway.describe_usage_plans"](
1405             name=plan_name, **common_args
1406         )
1407         if "error" in existing:
1408             ret["result"] = False
1409             ret["comment"] = "Failed to describe existing usage plans"
1410             return ret
1411         if not existing["plans"]:
1412             ret["comment"] = "Usage plan {} does not exist".format(plan_name)
1413             ret["result"] = False
1414             return ret
1415         if len(existing["plans"]) != 1:
1416             ret["comment"] = (
1417                 "There are multiple usage plans with the same name - it is not"
1418                 " supported"
1419             )
1420             ret["result"] = False
1421             return ret
1422         plan = existing["plans"][0]
1423         plan_id = plan["id"]
1424         plan_stages = plan.get("apiStages", [])
1425         if not plan_stages:
1426             ret["comment"] = "Usage plan {} has no associated stages already".format(
1427                 plan_name
1428             )
1429             return ret
1430         stages_to_remove = []
1431         for api in api_stages:
1432             if api in plan_stages:
1433                 stages_to_remove.append(api)
1434         if not stages_to_remove:
1435             ret["comment"] = "Usage plan is already not asssociated to any api stages"
1436             return ret
1437         result = __salt__["boto_apigateway.detach_usage_plan_from_apis"](
1438             plan_id, stages_to_remove, **common_args
1439         )
1440         if "error" in result:
1441             ret[
1442                 "comment"
1443             ] = "Failed to disassociate a usage plan {} from the apis {}, {}".format(
1444                 plan_name, stages_to_remove, result["error"]
1445             )
1446             ret["result"] = False
1447             return ret
1448         ret["comment"] = "successfully disassociated usage plan from apis"
1449         ret["changes"]["old"] = plan_stages
1450         ret["changes"]["new"] = result.get("result", {}).get("apiStages", [])
1451     except (ValueError, OSError) as e:
1452         ret["result"] = False
1453         ret["comment"] = "{}".format(e.args)
1454     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>junos_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import json
3 import logging
4 import os
5 import re
6 from functools import wraps
7 import salt.utils.args
8 import salt.utils.files
9 import salt.utils.json
10 import salt.utils.path
11 import salt.utils.platform
12 import salt.utils.stringutils
13 import yaml
14 try:
15     from lxml import etree
16 except ImportError:
17     import xml.etree.ElementTree as etree
18 try:
19     import jnpr.junos.cfg
20     import jnpr.junos.op as tables_dir
21     import jnpr.junos.utils
22     import jxmlease
23     import yamlordereddictloader
24     from jnpr.junos import Device
25     from jnpr.junos.exception import (
26         ConnectClosedError,
27         LockError,
28         RpcTimeoutError,
29         UnlockError,
30     )
31     from jnpr.junos.factory.cfgtable import CfgTable
32     from jnpr.junos.factory.factory_loader import FactoryLoader
33     from jnpr.junos.factory.optable import OpTable
34     from jnpr.junos.utils.config import Config
35     from jnpr.junos.utils.scp import SCP
36     from jnpr.junos.utils.sw import SW
37     HAS_JUNOS = True
38 except ImportError:
39     HAS_JUNOS = False
40 log = logging.getLogger(__name__)
41 __virtualname__ = "junos"
42 __proxyenabled__ = ["junos"]
43 def __virtual__():
44     if HAS_JUNOS and "proxy" in __opts__:
45         return __virtualname__
46     else:
47         return (
48             False,
49             "The junos or dependent module could not be loaded: "
50             "junos-eznc or jxmlease or yamlordereddictloader or "
51             "proxy could not be loaded.",
52         )
53 class HandleFileCopy:
54     def __init__(self, path, **kwargs):
55         self._file_path = path
56         self._cached_folder = None
57         self._cached_file = None
58         self._kwargs = kwargs
59     def __enter__(self):
60         if self._file_path.startswith("salt://"):
61             local_cache_path = __salt__["cp.is_cached"](self._file_path)
62             if local_cache_path:
63                 master_hash = __salt__["cp.hash_file"](self._file_path)
64                 proxy_hash = __salt__["file.get_hash"](local_cache_path)
65                 if master_hash.get("hsum") == proxy_hash:
66                     self._cached_file = salt.utils.files.mkstemp()
67                     with salt.utils.files.fopen(self._cached_file, "w") as fp:
68                         template_string = __salt__["slsutil.renderer"](
69                             path=local_cache_path,
70                             default_renderer="jinja",
71                             **self._kwargs,
72                         )
73                         fp.write(template_string)
74                     return self._cached_file
75             self._cached_file = salt.utils.files.mkstemp()
76             __salt__["cp.get_template"](
77                 self._file_path, self._cached_file, **self._kwargs
78             )
79             if self._cached_file != "":
80                 return self._cached_file
81         else:
82             if __salt__["file.file_exists"](self._file_path):
83                 self._cached_file = salt.utils.files.mkstemp()
84                 with salt.utils.files.fopen(self._cached_file, "w") as fp:
85                     template_string = __salt__["slsutil.renderer"](
86                         path=self._file_path, default_renderer="jinja", **self._kwargs
87                     )
88                     fp.write(template_string)
89                 return self._cached_file
90     def __exit__(self, exc_type, exc_value, exc_traceback):
91         if self._cached_file is not None:
92             salt.utils.files.safe_rm(self._cached_file)
93             log.debug("Deleted cached file: %s", self._cached_file)
94         if self._cached_folder is not None:
95             __salt__["file.rmdir"](self._cached_folder)
96             log.debug("Deleted cached folder: %s", self._cached_folder)
97 def _timeout_decorator(function):
98     @wraps(function)
99     def wrapper(*args, **kwargs):
100         if "dev_timeout" in kwargs or "timeout" in kwargs:
101             ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
102             conn = __proxy__["junos.conn"]()
103             restore_timeout = conn.timeout
104             conn.timeout = ldev_timeout
105             try:
106                 result = function(*args, **kwargs)
107                 conn.timeout = restore_timeout
108                 return result
109             except Exception:  # pylint: disable=broad-except
110                 conn.timeout = restore_timeout
111                 raise
112         else:
113             return function(*args, **kwargs)
114     return wrapper
115 def _timeout_decorator_cleankwargs(function):
116     @wraps(function)
117     def wrapper(*args, **kwargs):
118         if "dev_timeout" in kwargs or "timeout" in kwargs:
119             ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
120             conn = __proxy__["junos.conn"]()
121             restore_timeout = conn.timeout
122             conn.timeout = ldev_timeout
123             try:
124                 restore_kwargs = False
125                 del_list = []
126                 op = {}
127                 op.update(kwargs)
128                 for keychk in kwargs:
129                     if keychk.startswith("__pub"):
130                         del_list.append(keychk)
131                 if del_list:
132                     restore_kwargs = True
133                     for delkey in del_list:
134                         kwargs.pop(delkey)
135                 result = function(*args, **kwargs)
136                 if restore_kwargs:
137                     kwargs.update(op)
138                 conn.timeout = restore_timeout
139                 return result
140             except Exception:  # pylint: disable=broad-except
141                 conn.timeout = restore_timeout
142                 raise
143         else:
144             restore_kwargs = False
145             del_list = []
146             op = {}
147             op.update(kwargs)
148             for keychk in kwargs:
149                 if keychk.startswith("__pub"):
150                     del_list.append(keychk)
151             if del_list:
152                 restore_kwargs = True
153                 for delkey in del_list:
154                     kwargs.pop(delkey)
155             ret = function(*args, **kwargs)
156             if restore_kwargs:
157                 kwargs.update(op)
158             return ret
159     return wrapper
160 def _restart_connection():
161     minion_id = __opts__.get("proxyid", "") or __opts__.get("id", "")
162     log.info(
163         "Junos exception occurred %s (junos proxy) is down. Restarting.", minion_id
164     )
165     __salt__["event.fire_master"](
166         {}, "junos/proxy/{}/stop".format(__opts__["proxy"]["host"])
167     )
168     __proxy__["junos.shutdown"](__opts__)  # safely close connection
169     __proxy__["junos.init"](__opts__)  # reopen connection
170     log.debug("Junos exception occurred, restarted %s (junos proxy)!", minion_id)
171 @_timeout_decorator_cleankwargs
172 def facts_refresh():
173     conn = __proxy__["junos.conn"]()
174     ret = {}
175     ret["out"] = True
176     try:
177         conn.facts_refresh()
178     except Exception as exception:  # pylint: disable=broad-except
179         ret["message"] = 'Execution failed due to "{}"'.format(exception)
180         ret["out"] = False
181         _restart_connection()
182         return ret
183     ret["facts"] = __proxy__["junos.get_serialized_facts"]()
184     try:
185         __salt__["saltutil.sync_grains"]()
186     except Exception as exception:  # pylint: disable=broad-except
187         log.error('Grains could not be updated due to "%s"', exception)
188     return ret
189 def facts():
190     ret = {}
191     try:
192         ret["facts"] = __proxy__["junos.get_serialized_facts"]()
193         ret["out"] = True
194     except Exception as exception:  # pylint: disable=broad-except
195         ret["message"] = 'Could not display facts due to "{}"'.format(exception)
196         ret["out"] = False
197         _restart_connection()
198     return ret
199 @_timeout_decorator
200 def rpc(cmd=None, dest=None, **kwargs):
201     conn = __proxy__["junos.conn"]()
202     ret = {}
203     ret["out"] = True
204     op = dict()
205     if "__pub_arg" in kwargs:
206         if kwargs["__pub_arg"]:
207             if isinstance(kwargs["__pub_arg"][-1], dict):
208                 op.update(kwargs["__pub_arg"][-1])
209     elif "__pub_schedule" in kwargs:
210         for key, value in kwargs.items():
211             if not key.startswith("__pub_"):
212                 op[key] = value
213     else:
214         op.update(kwargs)
215     if cmd is None:
216         ret["message"] = "Please provide the rpc to execute."
217         ret["out"] = False
218         return ret
219     format_ = op.pop("format", "xml")
220     op.pop("dest", dest)
221     if cmd in ["get-config", "get_config"]:
222         filter_reply = None
223         if "filter" in op:
224             try:
225                 filter_reply = etree.XML(op["filter"])
226             except etree.XMLSyntaxError as ex:
227                 ret["message"] = "Invalid filter: {}".format(str(ex))
228                 ret["out"] = False
229                 return ret
230             del op["filter"]
231         op.update({"format": format_})
232         try:
233             reply = getattr(conn.rpc, cmd.replace("-", "_"))(filter_reply, options=op)
234         except Exception as exception:  # pylint: disable=broad-except
235             ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
236             ret["out"] = False
237             _restart_connection()
238             return ret
239     else:
240         if "filter" in op:
241             log.warning('Filter ignored as it is only used with "get-config" rpc')
242         if "dest" in op:
243             log.warning("dest in op, rpc may reject this for cmd '%s'", cmd)
244         try:
245             reply = getattr(conn.rpc, cmd.replace("-", "_"))({"format": format_}, **op)
246         except Exception as exception:  # pylint: disable=broad-except
247             ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
248             ret["out"] = False
249             _restart_connection()
250             return ret
251     if format_ == "text":
252         ret["rpc_reply"] = reply.text
253     elif format_ == "json":
254         ret["rpc_reply"] = reply
255     else:
256         ret["rpc_reply"] = jxmlease.parse(etree.tostring(reply))
257     if dest:
258         if format_ == "text":
259             write_response = reply.text
260         elif format_ == "json":
261             write_response = salt.utils.json.dumps(reply, indent=1)
262         else:
263             write_response = etree.tostring(reply)
264         with salt.utils.files.fopen(dest, "w") as fp:
265             fp.write(salt.utils.stringutils.to_str(write_response))
266     return ret
267 @_timeout_decorator
268 def set_hostname(hostname=None, **kwargs):
269     conn = __proxy__["junos.conn"]()
270     ret = {}
271     if hostname is None:
272         ret["message"] = "Please provide the hostname."
273         ret["out"] = False
274         return ret
275     op = dict()
276     if "__pub_arg" in kwargs:
277         if kwargs["__pub_arg"]:
278             if isinstance(kwargs["__pub_arg"][-1], dict):
279                 op.update(kwargs["__pub_arg"][-1])
280     else:
281         op.update(kwargs)
282     set_string = "set system host-name {}".format(hostname)
283     try:
284         conn.cu.load(set_string, format="set")
285     except Exception as exception:  # pylint: disable=broad-except
286         ret["message"] = 'Could not load configuration due to error "{}"'.format(
287             exception
288         )
289         ret["out"] = False
290         _restart_connection()
291         return ret
292     try:
293         commit_ok = conn.cu.commit_check()
294     except Exception as exception:  # pylint: disable=broad-except
295         ret["message"] = 'Could not commit check due to error "{}"'.format(exception)
296         ret["out"] = False
297         _restart_connection()
298         return ret
299     if commit_ok:
300         try:
301             conn.cu.commit(**op)
302             ret["message"] = "Successfully changed hostname."
303             ret["out"] = True
304         except Exception as exception:  # pylint: disable=broad-except
305             ret["out"] = False
306             ret[
307                 "message"
308             ] = 'Successfully loaded host-name but commit failed with "{}"'.format(
309                 exception
310             )
311             _restart_connection()
312             return ret
313     else:
314         ret["out"] = False
315         ret["message"] = "Successfully loaded host-name but pre-commit check failed."
316         try:
317             conn.cu.rollback()
318         except Exception as exception:  # pylint: disable=broad-except
319             ret["out"] = False
320             ret[
321                 "message"
322             ] = 'Successfully loaded host-name but rollback before exit failed "{}"'.format(
323                 exception
324             )
325             _restart_connection()
326     return ret
327 @_timeout_decorator
328 def commit(**kwargs):
329     conn = __proxy__["junos.conn"]()
330     ret = {}
331     op = dict()
332     if "__pub_arg" in kwargs:
333         if kwargs["__pub_arg"]:
334             if isinstance(kwargs["__pub_arg"][-1], dict):
335                 op.update(kwargs["__pub_arg"][-1])
336     else:
337         op.update(kwargs)
338     op["detail"] = op.get("detail", False)
339     try:
340         commit_ok = conn.cu.commit_check()
341     except Exception as exception:  # pylint: disable=broad-except
342         ret["message"] = 'Could not perform commit check due to "{}"'.format(exception)
343         ret["out"] = False
344         _restart_connection()
345         return ret
346     if commit_ok:
347         try:
348             commit = conn.cu.commit(**op)
349             ret["out"] = True
350             if commit:
351                 if op["detail"]:
352                     ret["message"] = jxmlease.parse(etree.tostring(commit))
353                 else:
354                     ret["message"] = "Commit Successful."
355             else:
356                 ret["message"] = "Commit failed."
357                 ret["out"] = False
358         except Exception as exception:  # pylint: disable=broad-except
359             ret["out"] = False
360             ret[
361                 "message"
362             ] = 'Commit check succeeded but actual commit failed with "{}"'.format(
363                 exception
364             )
365             _restart_connection()
366     else:
367         ret["out"] = False
368         ret["message"] = "Pre-commit check failed."
369         try:
370             conn.cu.rollback()
371         except Exception as exception:  # pylint: disable=broad-except
372             ret["out"] = False
373             ret[
374                 "message"
375             ] = 'Pre-commit check failed, and exception during rollback "{}"'.format(
376                 exception
377             )
378             _restart_connection()
379     return ret
380 @_timeout_decorator
381 def rollback(**kwargs):
382     ids_passed = 0
383     id_ = 0
384     if "d_id" in kwargs:
385         id_ = kwargs.pop("d_id")
386         ids_passed = ids_passed + 1
387     if "id" in kwargs:
388         id_ = kwargs.pop("id", 0)
389         ids_passed = ids_passed + 1
390     if ids_passed &gt; 1:
391         log.warning(
392             "junos.rollback called with more than one possible ID. "
393             "Use only one of the positional argument, `id`, or `d_id` kwargs"
394         )
395     ret = {}
396     conn = __proxy__["junos.conn"]()
397     op = dict()
398     if "__pub_arg" in kwargs:
399         if kwargs["__pub_arg"]:
400             if isinstance(kwargs["__pub_arg"][-1], dict):
401                 op.update(kwargs["__pub_arg"][-1])
402     else:
403         op.update(kwargs)
404     try:
405         ret["out"] = conn.cu.rollback(id_)
406     except Exception as exception:  # pylint: disable=broad-except
407         ret["message"] = 'Rollback failed due to "{}"'.format(exception)
408         ret["out"] = False
409         _restart_connection()
410         return ret
411     if ret["out"]:
412         ret["message"] = "Rollback successful"
413     else:
414         ret["message"] = "Rollback failed"
415         return ret
416     if "diffs_file" in op and op["diffs_file"] is not None:
417         diff = conn.cu.diff()
418         if diff is not None:
419             with salt.utils.files.fopen(op["diffs_file"], "w") as fp:
420                 fp.write(salt.utils.stringutils.to_str(diff))
421         else:
422             log.info(
423                 "No diff between current configuration and "
424                 "rollbacked configuration, so no diff file created"
425             )
426     try:
427         commit_ok = conn.cu.commit_check()
428     except Exception as exception:  # pylint: disable=broad-except
429         ret["message"] = 'Could not commit check due to "{}"'.format(exception)
430         ret["out"] = False
431         _restart_connection()
432         return ret
433     if commit_ok:
434         try:
435             conn.cu.commit(**op)
436             ret["out"] = True
437         except Exception as exception:  # pylint: disable=broad-except
438             ret["out"] = False
439             ret[
440                 "message"
441             ] = 'Rollback successful but commit failed with error "{}"'.format(
442                 exception
443             )
444             _restart_connection()
445             return ret
446     else:
447         ret["message"] = "Rollback successful but pre-commit check failed."
448         ret["out"] = False
449     return ret
450 @_timeout_decorator
451 def diff(**kwargs):
452     kwargs = salt.utils.args.clean_kwargs(**kwargs)
453     ids_passed = 0
454     id_ = 0
455     if "d_id" in kwargs:
456         id_ = kwargs.pop("d_id")
457         ids_passed = ids_passed + 1
458     if "id" in kwargs:
459         id_ = kwargs.pop("id", 0)
460         ids_passed = ids_passed + 1
461     if ids_passed &gt; 1:
462         log.warning(
463             "junos.rollback called with more than one possible ID. "
464             "Use only one of the positional argument, `id`, or `d_id` kwargs"
465         )
466     if kwargs:
467         salt.utils.args.invalid_kwargs(kwargs)
468     conn = __proxy__["junos.conn"]()
469     ret = {}
470     ret["out"] = True
471     try:
472         ret["message"] = conn.cu.diff(rb_id=id_)
473     except Exception as exception:  # pylint: disable=broad-except
474         ret["message"] = 'Could not get diff with error "{}"'.format(exception)
475         ret["out"] = False
476         _restart_connection()
477     return ret
478 @_timeout_decorator
479 def ping(dest_ip=None, **kwargs):
480     conn = __proxy__["junos.conn"]()
481     ret = {}
482     if dest_ip is None:
483         ret["message"] = "Please specify the destination ip to ping."
484         ret["out"] = False
485         return ret
486     op = {"host": dest_ip}
487     if "__pub_arg" in kwargs:
488         if kwargs["__pub_arg"]:
489             if isinstance(kwargs["__pub_arg"][-1], dict):
490                 op.update(kwargs["__pub_arg"][-1])
491     else:
492         op.update(kwargs)
493     op["count"] = str(op.pop("count", 5))
494     if "ttl" in op:
495         op["ttl"] = str(op["ttl"])
496     ret["out"] = True
497     try:
498         ret["message"] = jxmlease.parse(etree.tostring(conn.rpc.ping(**op)))
499     except Exception as exception:  # pylint: disable=broad-except
500         ret["message"] = 'Execution failed due to "{}"'.format(exception)
501         ret["out"] = False
502         _restart_connection()
503     return ret
504 @_timeout_decorator
505 def cli(command=None, **kwargs):
506     conn = __proxy__["junos.conn"]()
507     format_ = kwargs.pop("format", "text")
508     if not format_:
509         format_ = "text"
510     ret = {}
511     if command is None:
512         ret["message"] = "Please provide the CLI command to be executed."
513         ret["out"] = False
514         return ret
515     op = dict()
516     if "__pub_arg" in kwargs:
517         if kwargs["__pub_arg"]:
518             if isinstance(kwargs["__pub_arg"][-1], dict):
519                 op.update(kwargs["__pub_arg"][-1])
520     else:
521         op.update(kwargs)
522     try:
523         result = conn.cli(command, format_, warning=False)
524     except Exception as exception:  # pylint: disable=broad-except
525         ret["message"] = 'Execution failed due to "{}"'.format(exception)
526         ret["out"] = False
527         _restart_connection()
528         return ret
529     if format_ == "text":
530         ret["message"] = result
531     else:
532         result = etree.tostring(result)
533         ret["message"] = jxmlease.parse(result)
534     if "dest" in op and op["dest"] is not None:
535         try:
536             with salt.utils.files.fopen(op["dest"], "w") as fp:
537                 fp.write(salt.utils.stringutils.to_str(result))
538         except OSError:
539             ret["message"] = 'Unable to open "{}" to write'.format(op["dest"])
540             ret["out"] = False
541             return ret
542     ret["out"] = True
543     return ret
544 @_timeout_decorator
545 def shutdown(**kwargs):
546     conn = __proxy__["junos.conn"]()
547     ret = {}
548     sw = SW(conn)
549     op = {}
550     if "__pub_arg" in kwargs:
551         if kwargs["__pub_arg"]:
552             if isinstance(kwargs["__pub_arg"][-1], dict):
553                 op.update(kwargs["__pub_arg"][-1])
554     else:
555         op.update(kwargs)
556     if "shutdown" not in op and "reboot" not in op:
557         ret["message"] = "Provide either one of the arguments: shutdown or reboot."
558         ret["out"] = False
559         return ret
560     try:
561         if "reboot" in op and op["reboot"]:
562             shut = sw.reboot
563         elif "shutdown" in op and op["shutdown"]:
564             shut = sw.poweroff
565         else:
566             ret["message"] = "Nothing to be done."
567             ret["out"] = False
568             return ret
569         if "in_min" in op:
570             shut(in_min=op["in_min"])
571         elif "at" in op:
572             shut(at=op["at"])
573         else:
574             shut()
575         ret["message"] = "Successfully powered off/rebooted."
576         ret["out"] = True
577     except Exception as exception:  # pylint: disable=broad-except
578         ret["message"] = 'Could not poweroff/reboot because "{}"'.format(exception)
579         ret["out"] = False
580         _restart_connection()
581     return ret
582 @_timeout_decorator
583 def install_config(path=None, **kwargs):
584     conn = __proxy__["junos.conn"]()
585     ret = {}
586     ret["out"] = True
587     if path is None:
588         ret[
589             "message"
590         ] = "Please provide the salt path where the configuration is present"
591         ret["out"] = False
592         return ret
593     op = {}
594     if "__pub_arg" in kwargs:
595         if kwargs["__pub_arg"]:
596             if isinstance(kwargs["__pub_arg"][-1], dict):
597                 op.update(kwargs["__pub_arg"][-1])
598     else:
599         op.update(kwargs)
600     test = op.pop("test", False)
601     kwargs = {}
602     if "template_vars" in op:
603         kwargs.update({"template_vars": op["template_vars"]})
604     with HandleFileCopy(path, **kwargs) as template_cached_path:
605         if template_cached_path is None:
606             ret["message"] = "Invalid file path."
607             ret["out"] = False
608             return ret
609         if os.path.getsize(template_cached_path) == 0:
610             ret["message"] = "Template failed to render"
611             ret["out"] = False
612             return ret
613         write_diff = ""
614         if "diffs_file" in op and op["diffs_file"] is not None:
615             write_diff = op["diffs_file"]
616             del op["diffs_file"]
617         op["path"] = template_cached_path
618         if "format" not in op:
619             if path.endswith("set"):
620                 template_format = "set"
621             elif path.endswith("xml"):
622                 template_format = "xml"
623             elif path.endswith("json"):
624                 template_format = "json"
625             else:
626                 template_format = "text"
627             op["format"] = template_format
628         if "replace" in op and op["replace"]:
629             op["merge"] = False
630             del op["replace"]
631         elif "overwrite" in op and op["overwrite"]:
632             op["overwrite"] = True
633         elif "overwrite" in op and not op["overwrite"]:
634             op["merge"] = True
635             del op["overwrite"]
636         db_mode = op.pop("mode", "exclusive")
637         if write_diff and db_mode in ["dynamic", "ephemeral"]:
638             ret[
639                 "message"
640             ] = "Write diff is not supported with dynamic/ephemeral configuration mode"
641             ret["out"] = False
642             return ret
643         config_params = {}
644         if "ephemeral_instance" in op:
645             config_params["ephemeral_instance"] = op.pop("ephemeral_instance")
646         try:
647             with Config(conn, mode=db_mode, **config_params) as cu:
648                 try:
649                     cu.load(**op)
650                 except Exception as exception:  # pylint: disable=broad-except
651                     ret[
652                         "message"
653                     ] = 'Could not load configuration due to : "{}"'.format(exception)
654                     ret["format"] = op["format"]
655                     ret["out"] = False
656                     _restart_connection()
657                     return ret
658                 config_diff = None
659                 if db_mode in ["dynamic", "ephemeral"]:
660                     log.warning("diff is not supported for dynamic and ephemeral")
661                 else:
662                     config_diff = cu.diff()
663                     if config_diff is None:
664                         ret["message"] = "Configuration already applied!"
665                         ret["out"] = True
666                         return ret
667                 commit_params = {}
668                 if "confirm" in op:
669                     commit_params["confirm"] = op["confirm"]
670                 if "comment" in op:
671                     commit_params["comment"] = op["comment"]
672                 check = True
673                 if db_mode in ["dynamic", "ephemeral"]:
674                     log.warning("commit check not supported for dynamic and ephemeral")
675                 else:
676                     try:
677                         check = cu.commit_check()
678                     except Exception as exception:  # pylint: disable=broad-except
679                         ret[
680                             "message"
681                         ] = 'Commit check threw the following exception: "{}"'.format(
682                             exception
683                         )
684                         ret["out"] = False
685                         _restart_connection()
686                         return ret
687                 if check and not test:
688                     try:
689                         cu.commit(**commit_params)
690                         ret["message"] = "Successfully loaded and committed!"
691                     except Exception as exception:  # pylint: disable=broad-except
692                         ret[
693                             "message"
694                         ] = 'Commit check successful but commit failed with "{}"'.format(
695                             exception
696                         )
697                         ret["out"] = False
698                         _restart_connection()
699                         return ret
700                 elif not check:
701                     try:
702                         cu.rollback()
703                         ret["message"] = (
704                             "Loaded configuration but commit check failed, hence"
705                             " rolling back configuration."
706                         )
707                     except Exception as exception:  # pylint: disable=broad-except
708                         ret["message"] = (
709                             "Loaded configuration but commit check failed, and"
710                             ' exception occurred during rolling back configuration "{}"'.format(
711                                 exception
712                             )
713                         )
714                         _restart_connection()
715                     ret["out"] = False
716                 else:
717                     try:
718                         cu.rollback()
719                         ret["message"] = (
720                             "Commit check passed, but skipping commit for dry-run and"
721                             " rolling back configuration."
722                         )
723                         ret["out"] = True
724                     except Exception as exception:  # pylint: disable=broad-except
725                         ret["message"] = (
726                             "Commit check passed, but skipping commit for dry-run and"
727                             ' while rolling back configuration exception occurred "{}"'.format(
728                                 exception
729                             )
730                         )
731                         ret["out"] = False
732                         _restart_connection()
733                 try:
734                     if write_diff and config_diff is not None:
735                         with salt.utils.files.fopen(write_diff, "w") as fp:
736                             fp.write(salt.utils.stringutils.to_str(config_diff))
737                 except Exception as exception:  # pylint: disable=broad-except
738                     ret[
739                         "message"
740                     ] = "Could not write into diffs_file due to: '{}'".format(exception)
741                     ret["out"] = False
742         except ValueError as ex:
743             message = "install_config failed due to: {}".format(str(ex))
744             log.error(message)
745             ret["message"] = message
746             ret["out"] = False
747         except LockError as ex:
748             log.error("Configuration database is locked")
749             ret["message"] = ex.message
750             ret["out"] = False
751         except RpcTimeoutError as ex:
752             message = "install_config failed due to timeout error : {}".format(str(ex))
753             log.error(message)
754             ret["message"] = message
755             ret["out"] = False
756         except Exception as exc:  # pylint: disable=broad-except
757             ret["message"] = "install_config failed due to exception: '{}'".format(exc)
758             ret["out"] = False
759         return ret
760 @_timeout_decorator_cleankwargs
761 def zeroize():
762     conn = __proxy__["junos.conn"]()
763     ret = {}
764     ret["out"] = True
765     try:
766         conn.cli("request system zeroize")
767         ret["message"] = "Completed zeroize and rebooted"
768     except Exception as exception:  # pylint: disable=broad-except
769         ret["message"] = 'Could not zeroize due to : "{}"'.format(exception)
770         ret["out"] = False
771         _restart_connection()
772     return ret
773 @_timeout_decorator
774 def install_os(path=None, **kwargs):
775     conn = __proxy__["junos.conn"]()
776     ret = {}
777     ret["out"] = True
778     op = {}
779     if "__pub_arg" in kwargs:
780         if kwargs["__pub_arg"]:
781             if isinstance(kwargs["__pub_arg"][-1], dict):
782                 op.update(kwargs["__pub_arg"][-1])
783     else:
784         op.update(kwargs)
785     dev_timeout = max(op.pop("dev_timeout", 0), op.pop("timeout", 0))
786     timeout = max(1800, conn.timeout, dev_timeout)
787     reboot = op.pop("reboot", False)
788     no_copy_ = op.get("no_copy", False)
789     if path is None:
790         ret[
791             "message"
792         ] = "Please provide the salt path where the junos image is present."
793         ret["out"] = False
794         return ret
795     if reboot:
796         __proxy__["junos.reboot_active"]()
797     install_status = False
798     if not no_copy_:
799         with HandleFileCopy(path) as image_path:
800             if image_path is None:
801                 ret["message"] = "Invalid path. Please provide a valid image path"
802                 ret["out"] = False
803                 __proxy__["junos.reboot_clear"]()
804                 return ret
805             if salt.utils.platform.is_junos():
806                 tmp_absfile = image_path
807                 op["no_copy"] = True
808                 op["remote_path"] = os.path.dirname(tmp_absfile)
809                 image_path = os.path.basename(tmp_absfile)
810             try:
811                 install_status, install_message = conn.sw.install(
812                     image_path, progress=True, timeout=timeout, **op
813                 )
814             except Exception as exception:  # pylint: disable=broad-except
815                 ret["message"] = 'Installation failed due to: "{}"'.format(exception)
816                 ret["out"] = False
817                 __proxy__["junos.reboot_clear"]()
818                 _restart_connection()
819                 return ret
820     else:
821         try:
822             install_status, install_message = conn.sw.install(
823                 path, progress=True, timeout=timeout, **op
824             )
825         except Exception as exception:  # pylint: disable=broad-except
826             ret["message"] = 'Installation failed due to: "{}"'.format(exception)
827             ret["out"] = False
828             __proxy__["junos.reboot_clear"]()
829             _restart_connection()
830             return ret
831     if install_status is True:
832         ret["out"] = True
833         ret["message"] = "Installed the os."
834     else:
835         ret["message"] = "Installation failed. Reason: {}".format(install_message)
836         ret["out"] = False
837         __proxy__["junos.reboot_clear"]()
838         return ret
839     if reboot is True:
840         reboot_kwargs = {}
841         if "vmhost" in op and op.get("vmhost") is True:
842             reboot_kwargs["vmhost"] = True
843         if "all_re" in op:
844             reboot_kwargs["all_re"] = op.get("all_re")
845         try:
846             __proxy__["junos.reboot_active"]()
847             conn.sw.reboot(**reboot_kwargs)
848         except Exception as exception:  # pylint: disable=broad-except
849             __proxy__["junos.reboot_clear"]()
850             ret[
851                 "message"
852             ] = 'Installation successful but reboot failed due to : "{}"'.format(
853                 exception
854             )
855             ret["out"] = False
856             _restart_connection()
857             return ret
858         __proxy__["junos.reboot_clear"]()
859         ret["out"] = True
860         ret["message"] = "Successfully installed and rebooted!"
861     return ret
862 @_timeout_decorator_cleankwargs
863 def file_copy(src, dest):
864     if salt.utils.platform.is_junos():
865         return {
866             "success": False,
867             "message": "This method is unsupported on the current operating system!",
868         }
869     conn = __proxy__["junos.conn"]()
870     ret = {}
871     ret["out"] = True
872     with HandleFileCopy(src) as fp:
873         if fp is None:
874             ret["message"] = "Invalid source file path {}".format(src)
875             ret["out"] = False
876             return ret
877         try:
878             with SCP(conn, progress=True) as scp:
879                 scp.put(fp, dest)
880             ret["message"] = "Successfully copied file from {} to {}".format(src, dest)
881         except Exception as exception:  # pylint: disable=broad-except
882             ret["message"] = 'Could not copy file : "{}"'.format(exception)
883             ret["out"] = False
884         return ret
885 @_timeout_decorator_cleankwargs
886 def lock():
887     conn = __proxy__["junos.conn"]()
888     ret = {}
889     ret["out"] = True
890     try:
891         conn.cu.lock()
892         ret["message"] = "Successfully locked the configuration."
893     except RpcTimeoutError as exception:
894         ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
895         ret["out"] = False
896         _restart_connection()
897     except LockError as exception:
898         ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
899         ret["out"] = False
900     return ret
901 @_timeout_decorator_cleankwargs
902 def unlock():
903     conn = __proxy__["junos.conn"]()
904     ret = {}
905     ret["out"] = True
906     try:
907         conn.cu.unlock()
908         ret["message"] = "Successfully unlocked the configuration."
909     except RpcTimeoutError as exception:
910         ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
911             exception
912         )
913         ret["out"] = False
914         _restart_connection()
915     except UnlockError as exception:
916         ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
917             exception
918         )
919         ret["out"] = False
920     return ret
921 @_timeout_decorator
922 def load(path=None, **kwargs):
923     conn = __proxy__["junos.conn"]()
924     ret = {}
925     ret["out"] = True
926     if path is None:
927         ret[
928             "message"
929         ] = "Please provide the salt path where the configuration is present"
930         ret["out"] = False
931         return ret
932     op = {}
933     if "__pub_arg" in kwargs:
934         if kwargs["__pub_arg"]:
935             if isinstance(kwargs["__pub_arg"][-1], dict):
936                 op.update(kwargs["__pub_arg"][-1])
937     else:
938         op.update(kwargs)
939     kwargs = {}
940     if "template_vars" in op:
941         kwargs.update({"template_vars": op["template_vars"]})
942     with HandleFileCopy(path, **kwargs) as template_cached_path:
943         if template_cached_path is None:
944             ret["message"] = "Invalid file path."
945             ret["out"] = False
946             return ret
947         if os.path.getsize(template_cached_path) == 0:
948             ret["message"] = "Template failed to render"
949             ret["out"] = False
950             return ret
951         op["path"] = template_cached_path
952         if "format" not in op:
953             if path.endswith("set"):
954                 template_format = "set"
955             elif path.endswith("xml"):
956                 template_format = "xml"
957             elif path.endswith("json"):
958                 template_format = "json"
959             else:
960                 template_format = "text"
961             op["format"] = template_format
962         actions = [
963             item
964             for item in ("overwrite", "replace", "update", "merge")
965 <a name="0"></a>            if op.get(item, False)
966         ]
967         if len(list(actions)) &gt; 1:
968             ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["message"] = "Only one config_action is allowed. Provided: {}".format(
969                 actions
970             )
971             ret["out"] = False
972             return ret
973         if "replace" in op and op["replace"]:
974             op["merge"] =</b></font> False
975             del op["replace"]
976         elif "overwrite" in op and op["overwrite"]:
977             op["overwrite"] = True
978         elif "merge" in op and op["merge"]:
979             op["merge"] = True
980         elif "overwrite" in op and not op["overwrite"]:
981             op["merge"] = True
982             del op["overwrite"]
983         try:
984             conn.cu.load(**op)
985             ret["message"] = "Successfully loaded the configuration."
986         except Exception as exception:  # pylint: disable=broad-except
987             ret["message"] = 'Could not load configuration due to : "{}"'.format(
988                 exception
989             )
990             ret["format"] = op["format"]
991             ret["out"] = False
992             _restart_connection()
993             return ret
994         return ret
995 @_timeout_decorator_cleankwargs
996 def commit_check():
997     conn = __proxy__["junos.conn"]()
998     ret = {}
999     ret["out"] = True
1000     try:
1001         conn.cu.commit_check()
1002         ret["message"] = "Commit check succeeded."
1003     except Exception as exception:  # pylint: disable=broad-except
1004         ret["message"] = "Commit check failed with {}".format(exception)
1005         ret["out"] = False
1006         _restart_connection()
1007     return ret
1008 @_timeout_decorator_cleankwargs
1009 def get_table(
1010     table,
1011     table_file,
1012     path=None,
1013     target=None,
1014     key=None,
1015     key_items=None,
1016     filters=None,
1017     table_args=None,
1018 ):
1019     conn = __proxy__["junos.conn"]()
1020     ret = {}
1021     ret["out"] = True
1022     ret["hostname"] = conn._hostname
1023     ret["tablename"] = table
1024     get_kvargs = {}
1025     if target is not None:
1026         get_kvargs["target"] = target
1027     if key is not None:
1028         get_kvargs["key"] = key
1029     if key_items is not None:
1030         get_kvargs["key_items"] = key_items
1031     if filters is not None:
1032         get_kvargs["filters"] = filters
1033     if table_args is not None and isinstance(table_args, dict):
1034         get_kvargs["args"] = table_args
1035     pyez_tables_path = os.path.dirname(os.path.abspath(tables_dir.__file__))
1036     try:
1037         if path is not None:
1038             file_path = os.path.join(path, "{}".format(table_file))
1039         else:
1040             file_path = os.path.join(pyez_tables_path, "{}".format(table_file))
1041         with HandleFileCopy(file_path) as file_loc:
1042             if file_loc is None:
1043                 ret["message"] = "Given table file {} cannot be located".format(
1044                     table_file
1045                 )
1046                 ret["out"] = False
1047                 return ret
1048             try:
1049                 with salt.utils.files.fopen(file_loc) as fp:
1050                     ret["table"] = yaml.load(
1051                         fp.read(), Loader=yamlordereddictloader.Loader
1052                     )
1053                     globals().update(FactoryLoader().load(ret["table"]))
1054             except OSError as err:
1055                 ret[
1056                     "message"
1057                 ] = "Uncaught exception during YAML Load - please report: {}".format(
1058                     str(err)
1059                 )
1060                 ret["out"] = False
1061                 return ret
1062             try:
1063                 data = globals()[table](conn)
1064                 data.get(**get_kvargs)
1065             except KeyError as err:
1066                 ret[
1067                     "message"
1068                 ] = "Uncaught exception during get API call - please report: {}".format(
1069                     str(err)
1070                 )
1071                 ret["out"] = False
1072                 return ret
1073             except ConnectClosedError:
1074                 ret[
1075                     "message"
1076                 ] = "Got ConnectClosedError exception. Connection lost with {}".format(
1077                     conn
1078                 )
1079                 ret["out"] = False
1080                 _restart_connection()
1081                 return ret
1082             ret["reply"] = json.loads(data.to_json())
1083             if data.__class__.__bases__[0] in [OpTable, CfgTable]:
1084                 if ret["table"][table].get("key") is None:
1085                     ret["table"][table]["key"] = data.ITEM_NAME_XPATH
1086                 if key is not None:
1087                     ret["table"][table]["key"] = data.KEY
1088                 if table_args is not None:
1089                     args = copy.copy(data.GET_ARGS)
1090                     args.update(table_args)
1091                     ret["table"][table]["args"] = args
1092             else:
1093                 if target is not None:
1094                     ret["table"][table]["target"] = data.TARGET
1095                 if key is not None:
1096                     ret["table"][table]["key"] = data.KEY
1097                 if key_items is not None:
1098                     ret["table"][table]["key_items"] = data.KEY_ITEMS
1099                 if table_args is not None:
1100                     args = copy.copy(data.CMD_ARGS)
1101                     args.update(table_args)
1102                     ret["table"][table]["args"] = args
1103                     ret["table"][table]["command"] = data.GET_CMD
1104     except ConnectClosedError:
1105         ret[
1106             "message"
1107         ] = "Got ConnectClosedError exception. Connection lost with {}".format(
1108             str(conn)
1109         )
1110         ret["out"] = False
1111         _restart_connection()
1112         return ret
1113     except Exception as err:  # pylint: disable=broad-except
1114         ret["message"] = "Uncaught exception - please report: {}".format(str(err))
1115         ret["out"] = False
1116         _restart_connection()
1117         return ret
1118     return ret
1119 def _recursive_dict(node):
1120     result = {}
1121     for element in node.iterchildren():
1122         key = element.tag.split("}")[1] if "}" in element.tag else element.tag
1123         if element.text and element.text.strip():
1124             value = element.text
1125         else:
1126             value = _recursive_dict(element)
1127         if key in result:
1128             if type(result[key]) is list:
1129                 result[key].append(value)
1130             else:
1131                 tempvalue = result[key].copy()
1132                 result[key] = [tempvalue, value]
1133         else:
1134             result[key] = value
1135     return result
1136 @_timeout_decorator
1137 def rpc_file_list(path, **kwargs):
1138     kwargs = salt.utils.args.clean_kwargs(**kwargs)
1139     conn = __proxy__["junos.conn"]()
1140     if conn._conn is None:
1141         return False
1142     results = conn.rpc.file_list(path=path)
1143     ret = {}
1144     ret["files"] = _recursive_dict(results)
1145     ret["success"] = True
1146     return ret
1147 def _strip_newlines(str):
1148     stripped = str.replace("\n", "")
1149     return stripped
1150 def _make_source_list(dir):
1151     dir_list = []
1152     if not dir:
1153         return
1154     base = rpc_file_list(dir)["files"]["directory"]
1155     if "file-information" not in base:
1156         if "directory_name" not in base:
1157             return None
1158         return [os.path.join(_strip_newlines(base.get("directory-name", None))) + "/"]
1159     if isinstance(base["file-information"], dict):
1160         dirname = os.path.join(
1161             dir, _strip_newlines(base["file-information"]["file-name"])
1162         )
1163         if "file-directory" in base["file-information"]:
1164             new_list = _make_source_list(os.path.join(dir, dirname))
1165             return new_list
1166         else:
1167             return [dirname]
1168     for entry in base["file-information"]:
1169         if "file-directory" in entry:
1170             new_list = _make_source_list(
1171                 os.path.join(dir, _strip_newlines(entry["file-name"]))
1172             )
1173             if new_list:
1174                 dir_list.extend(new_list)
1175         else:
1176             dir_list.append(os.path.join(dir, _strip_newlines(entry["file-name"])))
1177     return dir_list
1178 @_timeout_decorator
1179 def file_compare(file1, file2, **kwargs):
1180     if not salt.utils.platform.is_junos():
1181         return {
1182             "success": False,
1183             "message": "This method is unsupported on the current operating system!",
1184         }
1185     ret = {"message": "", "identical": False, "success": True}
1186     junos_cli = salt.utils.path.which("cli")
1187     if not junos_cli:
1188         return {"success": False, "message": "Cannot find Junos cli command"}
1189     cliret = __salt__["cmd.run"](
1190         "{} file compare files {} {} ".format(junos_cli, file1, file2)
1191     )
1192     clilines = cliret.splitlines()
1193     for r in clilines:
1194         if r.strip() != "":
1195             if "No such file" in r:
1196                 ret["identical"] = False
1197                 ret["success"] = False
1198                 return ret
1199             ret["identical"] = False
1200             ret["success"] = True
1201             return ret
1202     ret["identical"] = True
1203     ret["success"] = True
1204     return ret
1205 @_timeout_decorator
1206 def fsentry_exists(dir, **kwargs):
1207     if not salt.utils.platform.is_junos():
1208         return {
1209             "success": False,
1210             "message": "This method is unsupported on the current operating system!",
1211         }
1212     junos_cli = salt.utils.path.which("cli")
1213     if not junos_cli:
1214         return {"success": False, "message": "Cannot find Junos cli command"}
1215     ret = __salt__["cmd.run"]("{} file show {}".format(junos_cli, dir))
1216     retlines = ret.splitlines()
1217     exists = True
1218     is_dir = False
1219     status = {"is_dir": False, "exists": True}
1220     for r in retlines:
1221         if "could not resolve" in r or "error: Could not connect" in r:
1222             status["is_dir"] = False
1223             status["exists"] = False
1224         if "is not a regular file" in r:
1225             status["is_dir"] = True
1226             status["exists"] = True
1227     return status
1228 def _find_routing_engines():
1229     junos_cli = salt.utils.path.which("cli")
1230     if not junos_cli:
1231         return {"success": False, "message": "Cannot find Junos cli command"}
1232     re_check = __salt__["cmd.run"]("{} show chassis routing-engine".format(junos_cli))
1233     engine_present = True
1234     engine = {}
1235     current_engine = None
1236     status = None
1237     for l in re_check.splitlines():
1238         if "Slot" in l:
1239             mat = re.search(".*(\\d+):.*", l)
1240             if mat:
1241                 current_engine = "re" + str(mat.group(1)) + ":"
1242         if "Current state" in l:
1243             if "Master" in l:
1244                 status = "Master"
1245             if "Disabled" in l:
1246                 status = "Disabled"
1247             if "Backup" in l:
1248                 status = "Backup"
1249         if current_engine and status:
1250             engine[current_engine] = status
1251             current_engine = None
1252             status = None
1253     if not engine:
1254         return {
1255             "success": False,
1256             "message": "Junos cli command returned no information",
1257         }
1258     engine["success"] = True
1259     return engine
1260 @_timeout_decorator
1261 def routing_engine(**kwargs):
1262     engine_status = _find_routing_engines()
1263     if not engine_status["success"]:
1264         return {"success": False}
1265     master = None
1266     backup = []
1267     for k, v in engine_status.items():
1268         if v == "Master":
1269             master = k
1270         if v == "Backup" or v == "Disabled":
1271             backup.append(k)
1272     if master:
1273         ret = {"master": master, "backup": backup, "success": True}
1274     else:
1275         ret = {"master": master, "backup": backup, "success": False}
1276     log.debug(ret)
1277     return ret
1278 @_timeout_decorator
1279 def dir_copy(source, dest, force=False, **kwargs):
1280     if not salt.utils.platform.is_junos():
1281         return {
1282             "success": False,
1283             "message": "This method is unsupported on the current operating system!",
1284         }
1285     junos_cli = salt.utils.path.which("cli")
1286     if not junos_cli:
1287         return {"success": False, "message": "Cannot find Junos cli command"}
1288     ret = {}
1289     ret_messages = ""
1290     if not source.startswith("/"):
1291         ret["message"] = "Source directory must be a fully qualified path."
1292         ret["success"] = False
1293         return ret
1294     if not (dest.endswith(":") or dest.startswith("/")):
1295         ret["message"] = (
1296             "Destination must be a routing engine reference (e.g. re1:) or a fully"
1297             " qualified path."
1298         )
1299         ret["success"] = False
1300         return ret
1301     check_source = fsentry_exists(source)
1302     if not check_source["exists"]:
1303         ret["message"] = "Source does not exist"
1304         ret["success"] = False
1305         return ret
1306     if not check_source["is_dir"]:
1307         ret["message"] = "Source is not a directory."
1308         ret["success"] = False
1309         return ret
1310     filelist = _make_source_list(source)
1311     dirops = []
1312     for f in filelist:
1313         splitpath = os.path.split(f)[0]
1314         fullpath = "/"
1315         for component in splitpath.split("/"):
1316             fullpath = os.path.join(fullpath, component)
1317             if fullpath not in dirops:
1318                 dirops.append(fullpath)
1319     for d in dirops:
1320         target = dest + d
1321         status = fsentry_exists(target)
1322         if not status["exists"]:
1323             ret = __salt__["cmd.run"](
1324                 "{} file make-directory {}".format(junos_cli, target)
1325             )
1326             ret = ret_messages + ret
1327         else:
1328             ret_messages = ret_messages + "Directory " + target + " already exists.\n"
1329     for f in filelist:
1330         if not f.endswith("/"):
1331             target = dest + f
1332             comp_result = file_compare(f, target)
1333             if not comp_result["identical"] or force:
1334                 ret = __salt__["cmd.run"](
1335                     "{} file copy {} {}".format(junos_cli, f, target)
1336                 )
1337                 ret = ret_messages + ret
1338             else:
1339                 ret_messages = (
1340                     ret_messages
1341                     + "Files {} and {} are identical, not copying.\n".format(f, target)
1342                 )
1343     return ret_messages
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
