<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for travisci.py &amp; httpserver_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for travisci.py &amp; httpserver_test.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>travisci.py (15.584415%)<th>httpserver_test.py (0.5722461%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(75-78)<td><a href="#" name="0">(685-687)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>travisci.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import urllib.parse
3 import salt.utils.json
4 from salt.utils.versions import LooseVersion as _LooseVersion
5 try:
6     import OpenSSL
7     import OpenSSL.crypto
8     HAS_OPENSSL = True
9 except ImportError:
10     HAS_OPENSSL = False
11 OPENSSL_MIN_VER = "16.0.0"
12 __virtualname__ = "travisci"
13 def __virtual__():
14     if HAS_OPENSSL is False:
15         return (
16             False,
17             "The travisci module was unable to be loaded: Install pyOpenssl &gt;= {}".format(
18                 OPENSSL_MIN_VER
19             ),
20         )
21     cur_version = _LooseVersion(OpenSSL.__version__)
22     min_version = _LooseVersion(OPENSSL_MIN_VER)
23     if cur_version &lt; min_version:
24         return (
25             False,
26             "The travisci module was unable to be loaded: Install pyOpenssl &gt;= {}".format(
27                 OPENSSL_MIN_VER
28             ),
29         )
30     return __virtualname__
31 def verify_webhook(signature, body):
32     public_key = __utils__["http.query"]("https://api.travis-ci.org/config")["config"][
33         "notifications"
34     ]["webhook"]["public_key"]
35     pkey_public_key = OpenSSL.crypto.load_publickey(
36         OpenSSL.crypto.FILETYPE_PEM, public_key
37     )
38     certificate = OpenSSL.crypto.X509()
39     signature = base64<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.b64decode(signature)
40     payload = salt.utils.json.loads(urllib.parse.parse_qs(body)["payload"][</b></font>0])
41     try:
42         OpenSSL.crypto.verify(certificate, signature, payload, "sha1")
43     except OpenSSL.crypto.Error:
44         return False
45     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpserver_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado import netutil
3 from salt.ext.tornado.escape import json_decode, json_encode, utf8, _unicode, recursive_unicode, native_str
4 from salt.ext.tornado import gen
5 from salt.ext.tornado.http1connection import HTTP1Connection
6 from salt.ext.tornado.httpserver import HTTPServer
7 from salt.ext.tornado.httputil import HTTPHeaders, HTTPMessageDelegate, HTTPServerConnectionDelegate, ResponseStartLine
8 from salt.ext.tornado.iostream import IOStream
9 from salt.ext.tornado.log import gen_log
10 from salt.ext.tornado.netutil import ssl_options_to_context
11 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipOnTravis
14 from salt.ext.tornado.web import Application, RequestHandler, asynchronous, stream_request_body
15 from contextlib import closing
16 import datetime
17 import gzip
18 import os
19 import shutil
20 import socket
21 import ssl
22 import sys
23 import tempfile
24 from io import BytesIO
25 def read_stream_body(stream, callback):
26         read_stream_body(self.stream, self.stop)
27         headers, response = self.wait()
28         self.assertEqual(json_decode(response), {u'foo': [u'bar']})
29     def test_chunked_request_uppercase(self):
30         self.stream.write(b"""\
31 POST /echo HTTP/1.1
32 Transfer-Encoding: Chunked
33 Content-Type: application/x-www-form-urlencoded
34 4
35 foo=
36 3
37 bar
38 0
39             self.stream.read_until_close(self.stop)
40             self.wait()
41 class XHeaderTest(HandlerBaseTestCase):
42     class Handler(RequestHandler):
43         def get(self):
44             self.write(dict(remote_ip=self.request.remote_ip,
45                             remote_protocol=self.request.protocol))
46     def get_httpserver_options(self):
47         return dict(xheaders=True, trusted_downstream=['5.5.5.5'])
48     def test_ip_headers(self):
49         self.assertEqual(self.fetch_json("/")["remote_ip"], "127.0.0.1")
50         valid_ipv4 = {"X-Real-IP": "4.4.4.4"}
51         self.assertEqual(
52             self.fetch_json("/", headers=valid_ipv4)["remote_ip"],
53             "4.4.4.4")
54         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4"}
55         self.assertEqual(
56             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
57             "4.4.4.4")
58         valid_ipv6 = {"X-Real-IP": "2620:0:1cfe:face:b00c::3"}
59         self.assertEqual(
60             self.fetch_json("/", headers=valid_ipv6)["remote_ip"],
61             "2620:0:1cfe:face:b00c::3")
62         valid_ipv6_list = {"X-Forwarded-For": "::1, 2620:0:1cfe:face:b00c::3"}
63         self.assertEqual(
64             self.fetch_json("/", headers=valid_ipv6_list)["remote_ip"],
65             "2620:0:1cfe:face:b00c::3")
66         invalid_chars = {"X-Real-IP": "4.4.4.4&lt;script&gt;"}
67         self.assertEqual(
68             self.fetch_json("/", headers=invalid_chars)["remote_ip"],
69             "127.0.0.1")
70         invalid_chars_list = {"X-Forwarded-For": "4.4.4.4, 5.5.5.5&lt;script&gt;"}
71         self.assertEqual(
72             self.fetch_json("/", headers=invalid_chars_list)["remote_ip"],
73             "127.0.0.1")
74         invalid_host = {"X-Real-IP": "www.google.com"}
75         self.assertEqual(
76             self.fetch_json("/", headers=invalid_host)["remote_ip"],
77             "127.0.0.1")
78     def test_trusted_downstream(self):
79         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4, 5.5.5.5"}
80         self.assertEqual(
81             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
82             "4.4.4.4")
83     def test_scheme_headers(self):
84         self.assertEqual(self.fetch_json("/")["remote_protocol"], "http")
85         https_scheme = {"X-Scheme": "https"}
86         self.assertEqual(
87             self.fetch_json("/", headers=https_scheme)["remote_protocol"],
88             "https")
89         https_forwarded = {"X-Forwarded-Proto": "https"}
90         self.assertEqual(
91             self.fetch_json("/", headers=https_forwarded)["remote_protocol"],
92             "https")
93         bad_forwarded = {"X-Forwarded-Proto": "unknown"}
94         self.assertEqual(
95             self.fetch_json("/", headers=bad_forwarded)["remote_protocol"],
96             "http")
97 class SSLXHeaderTest(AsyncHTTPSTestCase, HandlerBaseTestCase):
98     def get_app(self):
99         return Application([('/', XHeaderTest.Handler)])
100     def get_httpserver_options(self):
101         output = super(SSLXHeaderTest, self).get_httpserver_options()
102         output['xheaders'] = True
103         return output
104     def test_request_without_xprotocol(self):
105         self.assertEqual(self.fetch_json("/")["remote_protocol"], "https")
106         http_scheme = {"X-Scheme": "http"}
107         self.assertEqual(
108             self.fetch_json("/", headers=http_scheme)["remote_protocol"], "http")
109         bad_scheme = {"X-Scheme": "unknown"}
110         self.assertEqual(
111             self.fetch_json("/", headers=bad_scheme)["remote_protocol"], "https")
112 class ManualProtocolTest(HandlerBaseTestCase):
113     class Handler(RequestHandler):
114         def get(self):
115             self.write(dict(protocol=self.request.protocol))
116     def get_httpserver_options(self):
117         return dict(protocol='https')
118     def test_manual_protocol(self):
119         self.assertEqual(self.fetch_json('/')['protocol'], 'https')
120 @unittest.skipIf(not hasattr(socket, 'AF_UNIX') or sys.platform == 'cygwin',
121                  "unix sockets not supported on this platform")
122 class UnixSocketTest(AsyncTestCase):
123     def setUp(self):
124         super(UnixSocketTest, self).setUp()
125         self.tmpdir = tempfile.mkdtemp()
126         self.sockfile = os.path.join(self.tmpdir, "test.sock")
127         sock = netutil.bind_unix_socket(self.sockfile)
128         app = Application([("/hello", HelloWorldRequestHandler)])
129         self.server = HTTPServer(app, io_loop=self.io_loop)
130         self.server.add_socket(sock)
131         self.stream = IOStream(socket.socket(socket.AF_UNIX), io_loop=self.io_loop)
132         self.stream.connect(self.sockfile, self.stop)
133         self.wait()
134     def tearDown(self):
135         self.stream.close()
136         self.server.stop()
137         shutil.rmtree(self.tmpdir)
138         super(UnixSocketTest, self).tearDown()
139     def test_unix_socket(self):
140         self.stream.write(b"GET /hello HTTP/1.0\r\n\r\n")
141         self.stream.read_until(b"\r\n", self.stop)
142         response = self.wait()
143         self.assertEqual(response, b"HTTP/1.1 200 OK\r\n")
144         self.stream.read_until(b"\r\n\r\n", self.stop)
145         headers = HTTPHeaders.parse(self.wait().decode('latin1'))
146         self.stream.read_bytes(int(headers["Content-Length"]), self.stop)
147         body = self.wait()
148         self.assertEqual(body, b"Hello world")
149     def test_unix_socket_bad_request(self):
150         with ExpectLog(gen_log, "Malformed HTTP message from"):
151             self.stream.write(b"garbage\r\n\r\n")
152             self.stream.read_until_close(self.stop)
153             response = self.wait()
154         self.assertEqual(response, b"")
155 class KeepAliveTest(AsyncHTTPTestCase):
156     def get_app(self):
157         class HelloHandler(RequestHandler):
158             def get(self):
159                 self.finish('Hello world')
160             def post(self):
161                 self.finish('Hello world')
162         class LargeHandler(RequestHandler):
163             def get(self):
164                 self.write(''.join(chr(i % 256) * 1024 for i in range(512)))
165         class FinishOnCloseHandler(RequestHandler):
166             @asynchronous
167             def get(self):
168                 self.flush()
169             def on_connection_close(self):
170                 self.finish('closed')
171         return Application([('/', HelloHandler),
172                             ('/large', LargeHandler),
173                             ('/finish_on_close', FinishOnCloseHandler)])
174     def setUp(self):
175         super(KeepAliveTest, self).setUp()
176         self.http_version = b'HTTP/1.1'
177     def tearDown(self):
178         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
179         self.wait()
180         if hasattr(self, 'stream'):
181             self.stream.close()
182         super(KeepAliveTest, self).tearDown()
183     def connect(self):
184         self.stream = IOStream(socket<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.socket(), io_loop=self.io_loop)
185         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
186         self.</b></font>wait()
187     def read_headers(self):
188         self.stream.read_until(b'\r\n', self.stop)
189         first_line = self.wait()
190         self.assertTrue(first_line.startswith(b'HTTP/1.1 200'), first_line)
191         self.stream.read_until(b'\r\n\r\n', self.stop)
192         header_bytes = self.wait()
193         headers = HTTPHeaders.parse(header_bytes.decode('latin1'))
194         return headers
195     def read_response(self):
196         self.headers = self.read_headers()
197         self.stream.read_bytes(int(self.headers['Content-Length']), self.stop)
198         body = self.wait()
199         self.assertEqual(b'Hello world', body)
200     def close(self):
201         self.stream.close()
202         del self.stream
203     def test_two_requests(self):
204         self.connect()
205         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
206         self.read_response()
207         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
208         self.read_response()
209         self.close()
210     def test_request_close(self):
211         self.connect()
212         self.stream.write(b'GET / HTTP/1.1\r\nConnection: close\r\n\r\n')
213         self.read_response()
214         self.stream.read_until_close(callback=self.stop)
215         data = self.wait()
216         self.assertTrue(not data)
217         self.close()
218     def test_http10(self):
219         self.http_version = b'HTTP/1.0'
220         self.connect()
221         self.stream.write(b'GET / HTTP/1.0\r\n\r\n')
222         self.read_response()
223         self.stream.read_until_close(callback=self.stop)
224         data = self.wait()
225         self.assertTrue(not data)
226         self.assertTrue('Connection' not in self.headers)
227         self.close()
228     def test_http10_keepalive(self):
229         self.http_version = b'HTTP/1.0'
230         self.connect()
231         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
232         self.read_response()
233         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
234         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
235         self.read_response()
236         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
237         self.close()
238     def test_http10_keepalive_extra_crlf(self):
239         self.http_version = b'HTTP/1.0'
240         self.connect()
241         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n\r\n')
242         self.read_response()
243         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
244         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
245         self.read_response()
246         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
247         self.close()
248     def test_pipelined_requests(self):
249         self.connect()
250         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
251         self.read_response()
252         self.read_response()
253         self.close()
254     def test_pipelined_cancel(self):
255         self.connect()
256         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
257         self.read_response()
258         self.close()
259     def test_cancel_during_download(self):
260         self.connect()
261         self.stream.write(b'GET /large HTTP/1.1\r\n\r\n')
262         self.read_headers()
263         self.stream.read_bytes(1024, self.stop)
264         self.wait()
265         self.close()
266     def test_finish_while_closed(self):
267         self.connect()
268         self.stream.write(b'GET /finish_on_close HTTP/1.1\r\n\r\n')
269         self.read_headers()
270         self.close()
271     def test_keepalive_chunked(self):
272         self.http_version = b'HTTP/1.0'
273         self.connect()
274         self.stream.write(b'POST / HTTP/1.0\r\n'
275                           b'Connection: keep-alive\r\n'
276                           b'Transfer-Encoding: chunked\r\n'
277                           b'\r\n'
278                           b'0\r\n'
279                           b'\r\n')
280         self.read_response()
281         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
282         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
283         self.read_response()
284         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
285         self.close()
286 class GzipBaseTest(object):
287     def get_app(self):
288         return Application([('/', EchoHandler)])
289     def post_gzip(self, body):
290         bytesio = BytesIO()
291         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
292         gzip_file.write(utf8(body))
293         gzip_file.close()
294         compressed_body = bytesio.getvalue()
295         return self.fetch('/', method='POST', body=compressed_body,
296                           headers={'Content-Encoding': 'gzip'})
297     def test_uncompressed(self):
298         response = self.fetch('/', method='POST', body='foo=bar')
299         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
300 class GzipTest(GzipBaseTest, AsyncHTTPTestCase):
301     def get_httpserver_options(self):
302         return dict(decompress_request=True)
303     def test_gzip(self):
304         response = self.post_gzip('foo=bar')
305         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
306 class GzipUnsupportedTest(GzipBaseTest, AsyncHTTPTestCase):
307     def test_gzip_unsupported(self):
308         with ExpectLog(gen_log, "Unsupported Content-Encoding"):
309             response = self.post_gzip('foo=bar')
310         self.assertEquals(json_decode(response.body), {})
311 class StreamingChunkSizeTest(AsyncHTTPTestCase):
312     BODY = b'01234567890123456789012345678901234567890123456789'
313     CHUNK_SIZE = 16
314     def get_http_client(self):
315         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
316     def get_httpserver_options(self):
317         return dict(chunk_size=self.CHUNK_SIZE, decompress_request=True)
318     class MessageDelegate(HTTPMessageDelegate):
319         def __init__(self, connection):
320             self.connection = connection
321         def headers_received(self, start_line, headers):
322             self.chunk_lengths = []
323         def data_received(self, chunk):
324             self.chunk_lengths.append(len(chunk))
325         def finish(self):
326             response_body = utf8(json_encode(self.chunk_lengths))
327             self.connection.write_headers(
328                 ResponseStartLine('HTTP/1.1', 200, 'OK'),
329                 HTTPHeaders({'Content-Length': str(len(response_body))}))
330             self.connection.write(response_body)
331             self.connection.finish()
332     def get_app(self):
333         class App(HTTPServerConnectionDelegate):
334             def start_request(self, server_conn, request_conn):
335                 return StreamingChunkSizeTest.MessageDelegate(request_conn)
336         return App()
337     def fetch_chunk_sizes(self, **kwargs):
338         response = self.fetch('/', method='POST', **kwargs)
339         response.rethrow()
340         chunks = json_decode(response.body)
341         self.assertEqual(len(self.BODY), sum(chunks))
342         for chunk_size in chunks:
343             self.assertLessEqual(chunk_size, self.CHUNK_SIZE,
344                                  'oversized chunk: ' + str(chunks))
345             self.assertGreater(chunk_size, 0,
346                                'empty chunk: ' + str(chunks))
347         return chunks
348     def compress(self, body):
349         bytesio = BytesIO()
350         gzfile = gzip.GzipFile(mode='w', fileobj=bytesio)
351         gzfile.write(body)
352         gzfile.close()
353         compressed = bytesio.getvalue()
354         if len(compressed) &gt;= len(body):
355             raise Exception("body did not shrink when compressed")
356         return compressed
357     def test_regular_body(self):
358         chunks = self.fetch_chunk_sizes(body=self.BODY)
359         self.assertEqual([16, 16, 16, 2], chunks)
360     def test_compressed_body(self):
361         self.fetch_chunk_sizes(body=self.compress(self.BODY),
362                                headers={'Content-Encoding': 'gzip'})
363     def test_chunked_body(self):
364         def body_producer(write):
365             write(self.BODY[:20])
366             write(self.BODY[20:])
367         chunks = self.fetch_chunk_sizes(body_producer=body_producer)
368         self.assertEqual([16, 4, 16, 14], chunks)
369     def test_chunked_compressed(self):
370         compressed = self.compress(self.BODY)
371         self.assertGreater(len(compressed), 20)
372         def body_producer(write):
373             write(compressed[:20])
374             write(compressed[20:])
375         self.fetch_chunk_sizes(body_producer=body_producer,
376                                headers={'Content-Encoding': 'gzip'})
377 class MaxHeaderSizeTest(AsyncHTTPTestCase):
378     def get_app(self):
379         return Application([('/', HelloWorldRequestHandler)])
380     def get_httpserver_options(self):
381         return dict(max_header_size=1024)
382     def test_small_headers(self):
383         response = self.fetch("/", headers={'X-Filler': 'a' * 100})
384         response.rethrow()
385         self.assertEqual(response.body, b"Hello world")
386     def test_large_headers(self):
387         with ExpectLog(gen_log, "Unsatisfiable read", required=False):
388             response = self.fetch("/", headers={'X-Filler': 'a' * 1000})
389         self.assertIn(response.code, (431, 599))
390 @skipOnTravis
391 class IdleTimeoutTest(AsyncHTTPTestCase):
392     def get_app(self):
393         return Application([('/', HelloWorldRequestHandler)])
394     def get_httpserver_options(self):
395         return dict(idle_connection_timeout=0.1)
396     def setUp(self):
397         super(IdleTimeoutTest, self).setUp()
398         self.streams = []
399     def tearDown(self):
400         super(IdleTimeoutTest, self).tearDown()
401         for stream in self.streams:
402             stream.close()
403     def connect(self):
404         stream = IOStream(socket.socket())
405         stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
406         self.wait()
407         self.streams.append(stream)
408         return stream
409     def test_unused_connection(self):
410         stream = self.connect()
411         stream.set_close_callback(self.stop)
412         self.wait()
413     def test_idle_after_use(self):
414         stream = self.connect()
415         stream.set_close_callback(lambda: self.stop("closed"))
416         for i in range(2):
417             stream.write(b"GET / HTTP/1.1\r\n\r\n")
418             stream.read_until(b"\r\n\r\n", self.stop)
419             self.wait()
420             stream.read_bytes(11, self.stop)
421             data = self.wait()
422             self.assertEqual(data, b"Hello world")
423         data = self.wait()
424         self.assertEqual(data, "closed")
425 class BodyLimitsTest(AsyncHTTPTestCase):
426     def get_app(self):
427         class BufferedHandler(RequestHandler):
428             def put(self):
429                 self.write(str(len(self.request.body)))
430         @stream_request_body
431         class StreamingHandler(RequestHandler):
432             def initialize(self):
433                 self.bytes_read = 0
434             def prepare(self):
435                 if 'expected_size' in self.request.arguments:
436                     self.request.connection.set_max_body_size(
437                         int(self.get_argument('expected_size')))
438                 if 'body_timeout' in self.request.arguments:
439                     self.request.connection.set_body_timeout(
440                         float(self.get_argument('body_timeout')))
441             def data_received(self, data):
442                 self.bytes_read += len(data)
443             def put(self):
444                 self.write(str(self.bytes_read))
445         return Application([('/buffered', BufferedHandler),
446                             ('/streaming', StreamingHandler)])
447     def get_httpserver_options(self):
448         return dict(body_timeout=3600, max_body_size=4096)
449     def get_http_client(self):
450         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
451     def test_small_body(self):
452         response = self.fetch('/buffered', method='PUT', body=b'a' * 4096)
453         self.assertEqual(response.body, b'4096')
454         response = self.fetch('/streaming', method='PUT', body=b'a' * 4096)
455         self.assertEqual(response.body, b'4096')
456     def test_large_body_buffered(self):
457         with ExpectLog(gen_log, '.*Content-Length too long'):
458             response = self.fetch('/buffered', method='PUT', body=b'a' * 10240)
459         self.assertEqual(response.code, 599)
460     def test_large_body_buffered_chunked(self):
461         with ExpectLog(gen_log, '.*chunked body too large'):
462             response = self.fetch('/buffered', method='PUT',
463                                   body_producer=lambda write: write(b'a' * 10240))
464         self.assertEqual(response.code, 599)
465     def test_large_body_streaming(self):
466         with ExpectLog(gen_log, '.*Content-Length too long'):
467             response = self.fetch('/streaming', method='PUT', body=b'a' * 10240)
468         self.assertEqual(response.code, 599)
469     def test_large_body_streaming_chunked(self):
470         with ExpectLog(gen_log, '.*chunked body too large'):
471             response = self.fetch('/streaming', method='PUT',
472                                   body_producer=lambda write: write(b'a' * 10240))
473         self.assertEqual(response.code, 599)
474     def test_large_body_streaming_override(self):
475         response = self.fetch('/streaming?expected_size=10240', method='PUT',
476                               body=b'a' * 10240)
477         self.assertEqual(response.body, b'10240')
478     def test_large_body_streaming_chunked_override(self):
479         response = self.fetch('/streaming?expected_size=10240', method='PUT',
480                               body_producer=lambda write: write(b'a' * 10240))
481         self.assertEqual(response.body, b'10240')
482     @gen_test
483     def test_timeout(self):
484         stream = IOStream(socket.socket())
485         try:
486             yield stream.connect(('127.0.0.1', self.get_http_port()))
487             stream.write(b'PUT /streaming?body_timeout=0.1 HTTP/1.0\r\n'
488                          b'Content-Length: 42\r\n\r\n')
489             with ExpectLog(gen_log, 'Timeout reading body'):
490                 response = yield stream.read_until_close()
491             self.assertEqual(response, b'')
492         finally:
493             stream.close()
494     @gen_test
495     def test_body_size_override_reset(self):
496         stream = IOStream(socket.socket())
497         try:
498             yield stream.connect(('127.0.0.1', self.get_http_port()))
499             stream.write(b'PUT /streaming?expected_size=10240 HTTP/1.1\r\n'
500                          b'Content-Length: 10240\r\n\r\n')
501             stream.write(b'a' * 10240)
502             headers, response = yield gen.Task(read_stream_body, stream)
503             self.assertEqual(response, b'10240')
504             stream.write(b'PUT /streaming HTTP/1.1\r\n'
505                          b'Content-Length: 10240\r\n\r\n')
506             with ExpectLog(gen_log, '.*Content-Length too long'):
507                 data = yield stream.read_until_close()
508             self.assertEqual(data, b'')
509         finally:
510             stream.close()
511 class LegacyInterfaceTest(AsyncHTTPTestCase):
512     def get_app(self):
513         def handle_request(request):
514             self.http1 = request.version.startswith("HTTP/1.")
515             if not self.http1:
516                 request.connection.write_headers(
517                     ResponseStartLine('', 200, 'OK'),
518                     HTTPHeaders())
519                 request.connection.finish()
520                 return
521             message = b"Hello world"
522             request.write(utf8("HTTP/1.1 200 OK\r\n"
523                                "Content-Length: %d\r\n\r\n" % len(message)))
524             request.write(message)
525             request.finish()
526         return handle_request
527     def test_legacy_interface(self):
528         response = self.fetch('/')
529         if not self.http1:
530             self.skipTest("requires HTTP/1.x")
531         self.assertEqual(response.body, b"Hello world")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
