<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for travisci.py &amp; httpserver_test.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for travisci.py &amp; httpserver_test.py
      </h3>
<h1 align="center">
        1.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>travisci.py (15.584415%)<th>httpserver_test.py (0.5722461%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(75-78)<td><a href="#" name="0">(685-687)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>travisci.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import urllib.parse
3 import salt.utils.json
4 from salt.utils.versions import LooseVersion as _LooseVersion
5 try:
6     import OpenSSL
7     import OpenSSL.crypto
8     HAS_OPENSSL = True
9 except ImportError:
10     HAS_OPENSSL = False
11 OPENSSL_MIN_VER = "16.0.0"
12 __virtualname__ = "travisci"
13 def __virtual__():
14     if HAS_OPENSSL is False:
15         return (
16             False,
17             "The travisci module was unable to be loaded: Install pyOpenssl &gt;= {}".format(
18                 OPENSSL_MIN_VER
19             ),
20         )
21     cur_version = _LooseVersion(OpenSSL.__version__)
22     min_version = _LooseVersion(OPENSSL_MIN_VER)
23     if cur_version &lt; min_version:
24         return (
25             False,
26             "The travisci module was unable to be loaded: Install pyOpenssl &gt;= {}".format(
27                 OPENSSL_MIN_VER
28             ),
29         )
30     return __virtualname__
31 def verify_webhook(signature, body):
32     public_key = __utils__["http.query"]("https://api.travis-ci.org/config")["config"][
33         "notifications"
34     ]["webhook"]["public_key"]
35     pkey_public_key = OpenSSL.crypto.load_publickey(
36         OpenSSL.crypto.FILETYPE_PEM, public_key
37     )
38     certificate = OpenSSL.crypto.X509()
39 <a name="0"></a>    certificate.set_pubkey(pkey_public_key)
40     signature = base64<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.b64decode(signature)
41     payload = salt.utils.json.loads(urllib.parse.parse_qs(body)["payload"][</b></font>0])
42     try:
43         OpenSSL.crypto.verify(certificate, signature, payload, "sha1")
44     except OpenSSL.crypto.Error:
45         return False
46     return True
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>httpserver_test.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado import netutil
3 from salt.ext.tornado.escape import json_decode, json_encode, utf8, _unicode, recursive_unicode, native_str
4 from salt.ext.tornado import gen
5 from salt.ext.tornado.http1connection import HTTP1Connection
6 from salt.ext.tornado.httpserver import HTTPServer
7 from salt.ext.tornado.httputil import HTTPHeaders, HTTPMessageDelegate, HTTPServerConnectionDelegate, ResponseStartLine
8 from salt.ext.tornado.iostream import IOStream
9 from salt.ext.tornado.log import gen_log
10 from salt.ext.tornado.netutil import ssl_options_to_context
11 from salt.ext.tornado.simple_httpclient import SimpleAsyncHTTPClient
12 from salt.ext.tornado.testing import AsyncHTTPTestCase, AsyncHTTPSTestCase, AsyncTestCase, ExpectLog, gen_test
13 from salt.ext.tornado.test.util import unittest, skipOnTravis
14 from salt.ext.tornado.web import Application, RequestHandler, asynchronous, stream_request_body
15 from contextlib import closing
16 import datetime
17 import gzip
18 import os
19 import shutil
20 import socket
21 import ssl
22 import sys
23 import tempfile
24 from io import BytesIO
25 def read_stream_body(stream, callback):
26         read_stream_body(self.stream, self.stop)
27         headers, response = self.wait()
28         self.assertEqual(json_decode(response), {u'foo': [u'bar']})
29     def test_chunked_request_uppercase(self):
30         self.stream.write(b"""\
31 POST /echo HTTP/1.1
32 Transfer-Encoding: Chunked
33 Content-Type: application/x-www-form-urlencoded
34 4
35 foo=
36 3
37 bar
38 0
39             self.stream.read_until_close(self.stop)
40             self.wait()
41 class XHeaderTest(HandlerBaseTestCase):
42     class Handler(RequestHandler):
43         def get(self):
44             self.write(dict(remote_ip=self.request.remote_ip,
45                             remote_protocol=self.request.protocol))
46     def get_httpserver_options(self):
47         return dict(xheaders=True, trusted_downstream=['5.5.5.5'])
48     def test_ip_headers(self):
49         self.assertEqual(self.fetch_json("/")["remote_ip"], "127.0.0.1")
50         valid_ipv4 = {"X-Real-IP": "4.4.4.4"}
51         self.assertEqual(
52             self.fetch_json("/", headers=valid_ipv4)["remote_ip"],
53             "4.4.4.4")
54         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4"}
55         self.assertEqual(
56             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
57             "4.4.4.4")
58         valid_ipv6 = {"X-Real-IP": "2620:0:1cfe:face:b00c::3"}
59         self.assertEqual(
60             self.fetch_json("/", headers=valid_ipv6)["remote_ip"],
61             "2620:0:1cfe:face:b00c::3")
62         valid_ipv6_list = {"X-Forwarded-For": "::1, 2620:0:1cfe:face:b00c::3"}
63         self.assertEqual(
64             self.fetch_json("/", headers=valid_ipv6_list)["remote_ip"],
65             "2620:0:1cfe:face:b00c::3")
66         invalid_chars = {"X-Real-IP": "4.4.4.4&lt;script&gt;"}
67         self.assertEqual(
68             self.fetch_json("/", headers=invalid_chars)["remote_ip"],
69             "127.0.0.1")
70         invalid_chars_list = {"X-Forwarded-For": "4.4.4.4, 5.5.5.5&lt;script&gt;"}
71         self.assertEqual(
72             self.fetch_json("/", headers=invalid_chars_list)["remote_ip"],
73             "127.0.0.1")
74         invalid_host = {"X-Real-IP": "www.google.com"}
75         self.assertEqual(
76             self.fetch_json("/", headers=invalid_host)["remote_ip"],
77             "127.0.0.1")
78     def test_trusted_downstream(self):
79         valid_ipv4_list = {"X-Forwarded-For": "127.0.0.1, 4.4.4.4, 5.5.5.5"}
80         self.assertEqual(
81             self.fetch_json("/", headers=valid_ipv4_list)["remote_ip"],
82             "4.4.4.4")
83     def test_scheme_headers(self):
84         self.assertEqual(self.fetch_json("/")["remote_protocol"], "http")
85         https_scheme = {"X-Scheme": "https"}
86         self.assertEqual(
87             self.fetch_json("/", headers=https_scheme)["remote_protocol"],
88             "https")
89         https_forwarded = {"X-Forwarded-Proto": "https"}
90         self.assertEqual(
91             self.fetch_json("/", headers=https_forwarded)["remote_protocol"],
92             "https")
93         bad_forwarded = {"X-Forwarded-Proto": "unknown"}
94         self.assertEqual(
95             self.fetch_json("/", headers=bad_forwarded)["remote_protocol"],
96             "http")
97 class SSLXHeaderTest(AsyncHTTPSTestCase, HandlerBaseTestCase):
98     def get_app(self):
99         return Application([('/', XHeaderTest.Handler)])
100     def get_httpserver_options(self):
101         output = super(SSLXHeaderTest, self).get_httpserver_options()
102         output['xheaders'] = True
103         return output
104     def test_request_without_xprotocol(self):
105         self.assertEqual(self.fetch_json("/")["remote_protocol"], "https")
106         http_scheme = {"X-Scheme": "http"}
107         self.assertEqual(
108             self.fetch_json("/", headers=http_scheme)["remote_protocol"], "http")
109         bad_scheme = {"X-Scheme": "unknown"}
110         self.assertEqual(
111             self.fetch_json("/", headers=bad_scheme)["remote_protocol"], "https")
112 class ManualProtocolTest(HandlerBaseTestCase):
113     class Handler(RequestHandler):
114         def get(self):
115             self.write(dict(protocol=self.request.protocol))
116     def get_httpserver_options(self):
117         return dict(protocol='https')
118     def test_manual_protocol(self):
119         self.assertEqual(self.fetch_json('/')['protocol'], 'https')
120 @unittest.skipIf(not hasattr(socket, 'AF_UNIX') or sys.platform == 'cygwin',
121                  "unix sockets not supported on this platform")
122 class UnixSocketTest(AsyncTestCase):
123     def setUp(self):
124         super(UnixSocketTest, self).setUp()
125         self.tmpdir = tempfile.mkdtemp()
126         self.sockfile = os.path.join(self.tmpdir, "test.sock")
127         sock = netutil.bind_unix_socket(self.sockfile)
128         app = Application([("/hello", HelloWorldRequestHandler)])
129         self.server = HTTPServer(app, io_loop=self.io_loop)
130         self.server.add_socket(sock)
131         self.stream = IOStream(socket.socket(socket.AF_UNIX), io_loop=self.io_loop)
132         self.stream.connect(self.sockfile, self.stop)
133         self.wait()
134     def tearDown(self):
135         self.stream.close()
136         self.server.stop()
137         shutil.rmtree(self.tmpdir)
138         super(UnixSocketTest, self).tearDown()
139     def test_unix_socket(self):
140         self.stream.write(b"GET /hello HTTP/1.0\r\n\r\n")
141         self.stream.read_until(b"\r\n", self.stop)
142         response = self.wait()
143         self.assertEqual(response, b"HTTP/1.1 200 OK\r\n")
144         self.stream.read_until(b"\r\n\r\n", self.stop)
145         headers = HTTPHeaders.parse(self.wait().decode('latin1'))
146         self.stream.read_bytes(int(headers["Content-Length"]), self.stop)
147         body = self.wait()
148         self.assertEqual(body, b"Hello world")
149     def test_unix_socket_bad_request(self):
150         with ExpectLog(gen_log, "Malformed HTTP message from"):
151             self.stream.write(b"garbage\r\n\r\n")
152             self.stream.read_until_close(self.stop)
153             response = self.wait()
154         self.assertEqual(response, b"")
155 class KeepAliveTest(AsyncHTTPTestCase):
156     def get_app(self):
157         class HelloHandler(RequestHandler):
158             def get(self):
159                 self.finish('Hello world')
160             def post(self):
161                 self.finish('Hello world')
162         class LargeHandler(RequestHandler):
163             def get(self):
164                 self.write(''.join(chr(i % 256) * 1024 for i in range(512)))
165         class FinishOnCloseHandler(RequestHandler):
166             @asynchronous
167             def get(self):
168                 self.flush()
169             def on_connection_close(self):
170                 self.finish('closed')
171         return Application([('/', HelloHandler),
172                             ('/large', LargeHandler),
173                             ('/finish_on_close', FinishOnCloseHandler)])
174     def setUp(self):
175         super(KeepAliveTest, self).setUp()
176         self.http_version = b'HTTP/1.1'
177     def tearDown(self):
178         self.io_loop.add_timeout(datetime.timedelta(seconds=0.001), self.stop)
179         self.wait()
180         if hasattr(self, 'stream'):
181             self.stream.close()
182         super(KeepAliveTest, self).tearDown()
183 <a name="0"></a>
184     def connect(self):
185         self.stream = IOStream(socket<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.socket(), io_loop=self.io_loop)
186         self.stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
187         self.</b></font>wait()
188     def read_headers(self):
189         self.stream.read_until(b'\r\n', self.stop)
190         first_line = self.wait()
191         self.assertTrue(first_line.startswith(b'HTTP/1.1 200'), first_line)
192         self.stream.read_until(b'\r\n\r\n', self.stop)
193         header_bytes = self.wait()
194         headers = HTTPHeaders.parse(header_bytes.decode('latin1'))
195         return headers
196     def read_response(self):
197         self.headers = self.read_headers()
198         self.stream.read_bytes(int(self.headers['Content-Length']), self.stop)
199         body = self.wait()
200         self.assertEqual(b'Hello world', body)
201     def close(self):
202         self.stream.close()
203         del self.stream
204     def test_two_requests(self):
205         self.connect()
206         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
207         self.read_response()
208         self.stream.write(b'GET / HTTP/1.1\r\n\r\n')
209         self.read_response()
210         self.close()
211     def test_request_close(self):
212         self.connect()
213         self.stream.write(b'GET / HTTP/1.1\r\nConnection: close\r\n\r\n')
214         self.read_response()
215         self.stream.read_until_close(callback=self.stop)
216         data = self.wait()
217         self.assertTrue(not data)
218         self.close()
219     def test_http10(self):
220         self.http_version = b'HTTP/1.0'
221         self.connect()
222         self.stream.write(b'GET / HTTP/1.0\r\n\r\n')
223         self.read_response()
224         self.stream.read_until_close(callback=self.stop)
225         data = self.wait()
226         self.assertTrue(not data)
227         self.assertTrue('Connection' not in self.headers)
228         self.close()
229     def test_http10_keepalive(self):
230         self.http_version = b'HTTP/1.0'
231         self.connect()
232         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
233         self.read_response()
234         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
235         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
236         self.read_response()
237         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
238         self.close()
239     def test_http10_keepalive_extra_crlf(self):
240         self.http_version = b'HTTP/1.0'
241         self.connect()
242         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n\r\n')
243         self.read_response()
244         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
245         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
246         self.read_response()
247         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
248         self.close()
249     def test_pipelined_requests(self):
250         self.connect()
251         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
252         self.read_response()
253         self.read_response()
254         self.close()
255     def test_pipelined_cancel(self):
256         self.connect()
257         self.stream.write(b'GET / HTTP/1.1\r\n\r\nGET / HTTP/1.1\r\n\r\n')
258         self.read_response()
259         self.close()
260     def test_cancel_during_download(self):
261         self.connect()
262         self.stream.write(b'GET /large HTTP/1.1\r\n\r\n')
263         self.read_headers()
264         self.stream.read_bytes(1024, self.stop)
265         self.wait()
266         self.close()
267     def test_finish_while_closed(self):
268         self.connect()
269         self.stream.write(b'GET /finish_on_close HTTP/1.1\r\n\r\n')
270         self.read_headers()
271         self.close()
272     def test_keepalive_chunked(self):
273         self.http_version = b'HTTP/1.0'
274         self.connect()
275         self.stream.write(b'POST / HTTP/1.0\r\n'
276                           b'Connection: keep-alive\r\n'
277                           b'Transfer-Encoding: chunked\r\n'
278                           b'\r\n'
279                           b'0\r\n'
280                           b'\r\n')
281         self.read_response()
282         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
283         self.stream.write(b'GET / HTTP/1.0\r\nConnection: keep-alive\r\n\r\n')
284         self.read_response()
285         self.assertEqual(self.headers['Connection'], 'Keep-Alive')
286         self.close()
287 class GzipBaseTest(object):
288     def get_app(self):
289         return Application([('/', EchoHandler)])
290     def post_gzip(self, body):
291         bytesio = BytesIO()
292         gzip_file = gzip.GzipFile(mode='w', fileobj=bytesio)
293         gzip_file.write(utf8(body))
294         gzip_file.close()
295         compressed_body = bytesio.getvalue()
296         return self.fetch('/', method='POST', body=compressed_body,
297                           headers={'Content-Encoding': 'gzip'})
298     def test_uncompressed(self):
299         response = self.fetch('/', method='POST', body='foo=bar')
300         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
301 class GzipTest(GzipBaseTest, AsyncHTTPTestCase):
302     def get_httpserver_options(self):
303         return dict(decompress_request=True)
304     def test_gzip(self):
305         response = self.post_gzip('foo=bar')
306         self.assertEquals(json_decode(response.body), {u'foo': [u'bar']})
307 class GzipUnsupportedTest(GzipBaseTest, AsyncHTTPTestCase):
308     def test_gzip_unsupported(self):
309         with ExpectLog(gen_log, "Unsupported Content-Encoding"):
310             response = self.post_gzip('foo=bar')
311         self.assertEquals(json_decode(response.body), {})
312 class StreamingChunkSizeTest(AsyncHTTPTestCase):
313     BODY = b'01234567890123456789012345678901234567890123456789'
314     CHUNK_SIZE = 16
315     def get_http_client(self):
316         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
317     def get_httpserver_options(self):
318         return dict(chunk_size=self.CHUNK_SIZE, decompress_request=True)
319     class MessageDelegate(HTTPMessageDelegate):
320         def __init__(self, connection):
321             self.connection = connection
322         def headers_received(self, start_line, headers):
323             self.chunk_lengths = []
324         def data_received(self, chunk):
325             self.chunk_lengths.append(len(chunk))
326         def finish(self):
327             response_body = utf8(json_encode(self.chunk_lengths))
328             self.connection.write_headers(
329                 ResponseStartLine('HTTP/1.1', 200, 'OK'),
330                 HTTPHeaders({'Content-Length': str(len(response_body))}))
331             self.connection.write(response_body)
332             self.connection.finish()
333     def get_app(self):
334         class App(HTTPServerConnectionDelegate):
335             def start_request(self, server_conn, request_conn):
336                 return StreamingChunkSizeTest.MessageDelegate(request_conn)
337         return App()
338     def fetch_chunk_sizes(self, **kwargs):
339         response = self.fetch('/', method='POST', **kwargs)
340         response.rethrow()
341         chunks = json_decode(response.body)
342         self.assertEqual(len(self.BODY), sum(chunks))
343         for chunk_size in chunks:
344             self.assertLessEqual(chunk_size, self.CHUNK_SIZE,
345                                  'oversized chunk: ' + str(chunks))
346             self.assertGreater(chunk_size, 0,
347                                'empty chunk: ' + str(chunks))
348         return chunks
349     def compress(self, body):
350         bytesio = BytesIO()
351         gzfile = gzip.GzipFile(mode='w', fileobj=bytesio)
352         gzfile.write(body)
353         gzfile.close()
354         compressed = bytesio.getvalue()
355         if len(compressed) &gt;= len(body):
356             raise Exception("body did not shrink when compressed")
357         return compressed
358     def test_regular_body(self):
359         chunks = self.fetch_chunk_sizes(body=self.BODY)
360         self.assertEqual([16, 16, 16, 2], chunks)
361     def test_compressed_body(self):
362         self.fetch_chunk_sizes(body=self.compress(self.BODY),
363                                headers={'Content-Encoding': 'gzip'})
364     def test_chunked_body(self):
365         def body_producer(write):
366             write(self.BODY[:20])
367             write(self.BODY[20:])
368         chunks = self.fetch_chunk_sizes(body_producer=body_producer)
369         self.assertEqual([16, 4, 16, 14], chunks)
370     def test_chunked_compressed(self):
371         compressed = self.compress(self.BODY)
372         self.assertGreater(len(compressed), 20)
373         def body_producer(write):
374             write(compressed[:20])
375             write(compressed[20:])
376         self.fetch_chunk_sizes(body_producer=body_producer,
377                                headers={'Content-Encoding': 'gzip'})
378 class MaxHeaderSizeTest(AsyncHTTPTestCase):
379     def get_app(self):
380         return Application([('/', HelloWorldRequestHandler)])
381     def get_httpserver_options(self):
382         return dict(max_header_size=1024)
383     def test_small_headers(self):
384         response = self.fetch("/", headers={'X-Filler': 'a' * 100})
385         response.rethrow()
386         self.assertEqual(response.body, b"Hello world")
387     def test_large_headers(self):
388         with ExpectLog(gen_log, "Unsatisfiable read", required=False):
389             response = self.fetch("/", headers={'X-Filler': 'a' * 1000})
390         self.assertIn(response.code, (431, 599))
391 @skipOnTravis
392 class IdleTimeoutTest(AsyncHTTPTestCase):
393     def get_app(self):
394         return Application([('/', HelloWorldRequestHandler)])
395     def get_httpserver_options(self):
396         return dict(idle_connection_timeout=0.1)
397     def setUp(self):
398         super(IdleTimeoutTest, self).setUp()
399         self.streams = []
400     def tearDown(self):
401         super(IdleTimeoutTest, self).tearDown()
402         for stream in self.streams:
403             stream.close()
404     def connect(self):
405         stream = IOStream(socket.socket())
406         stream.connect(('127.0.0.1', self.get_http_port()), self.stop)
407         self.wait()
408         self.streams.append(stream)
409         return stream
410     def test_unused_connection(self):
411         stream = self.connect()
412         stream.set_close_callback(self.stop)
413         self.wait()
414     def test_idle_after_use(self):
415         stream = self.connect()
416         stream.set_close_callback(lambda: self.stop("closed"))
417         for i in range(2):
418             stream.write(b"GET / HTTP/1.1\r\n\r\n")
419             stream.read_until(b"\r\n\r\n", self.stop)
420             self.wait()
421             stream.read_bytes(11, self.stop)
422             data = self.wait()
423             self.assertEqual(data, b"Hello world")
424         data = self.wait()
425         self.assertEqual(data, "closed")
426 class BodyLimitsTest(AsyncHTTPTestCase):
427     def get_app(self):
428         class BufferedHandler(RequestHandler):
429             def put(self):
430                 self.write(str(len(self.request.body)))
431         @stream_request_body
432         class StreamingHandler(RequestHandler):
433             def initialize(self):
434                 self.bytes_read = 0
435             def prepare(self):
436                 if 'expected_size' in self.request.arguments:
437                     self.request.connection.set_max_body_size(
438                         int(self.get_argument('expected_size')))
439                 if 'body_timeout' in self.request.arguments:
440                     self.request.connection.set_body_timeout(
441                         float(self.get_argument('body_timeout')))
442             def data_received(self, data):
443                 self.bytes_read += len(data)
444             def put(self):
445                 self.write(str(self.bytes_read))
446         return Application([('/buffered', BufferedHandler),
447                             ('/streaming', StreamingHandler)])
448     def get_httpserver_options(self):
449         return dict(body_timeout=3600, max_body_size=4096)
450     def get_http_client(self):
451         return SimpleAsyncHTTPClient(io_loop=self.io_loop)
452     def test_small_body(self):
453         response = self.fetch('/buffered', method='PUT', body=b'a' * 4096)
454         self.assertEqual(response.body, b'4096')
455         response = self.fetch('/streaming', method='PUT', body=b'a' * 4096)
456         self.assertEqual(response.body, b'4096')
457     def test_large_body_buffered(self):
458         with ExpectLog(gen_log, '.*Content-Length too long'):
459             response = self.fetch('/buffered', method='PUT', body=b'a' * 10240)
460         self.assertEqual(response.code, 599)
461     def test_large_body_buffered_chunked(self):
462         with ExpectLog(gen_log, '.*chunked body too large'):
463             response = self.fetch('/buffered', method='PUT',
464                                   body_producer=lambda write: write(b'a' * 10240))
465         self.assertEqual(response.code, 599)
466     def test_large_body_streaming(self):
467         with ExpectLog(gen_log, '.*Content-Length too long'):
468             response = self.fetch('/streaming', method='PUT', body=b'a' * 10240)
469         self.assertEqual(response.code, 599)
470     def test_large_body_streaming_chunked(self):
471         with ExpectLog(gen_log, '.*chunked body too large'):
472             response = self.fetch('/streaming', method='PUT',
473                                   body_producer=lambda write: write(b'a' * 10240))
474         self.assertEqual(response.code, 599)
475     def test_large_body_streaming_override(self):
476         response = self.fetch('/streaming?expected_size=10240', method='PUT',
477                               body=b'a' * 10240)
478         self.assertEqual(response.body, b'10240')
479     def test_large_body_streaming_chunked_override(self):
480         response = self.fetch('/streaming?expected_size=10240', method='PUT',
481                               body_producer=lambda write: write(b'a' * 10240))
482         self.assertEqual(response.body, b'10240')
483     @gen_test
484     def test_timeout(self):
485         stream = IOStream(socket.socket())
486         try:
487             yield stream.connect(('127.0.0.1', self.get_http_port()))
488             stream.write(b'PUT /streaming?body_timeout=0.1 HTTP/1.0\r\n'
489                          b'Content-Length: 42\r\n\r\n')
490             with ExpectLog(gen_log, 'Timeout reading body'):
491                 response = yield stream.read_until_close()
492             self.assertEqual(response, b'')
493         finally:
494             stream.close()
495     @gen_test
496     def test_body_size_override_reset(self):
497         stream = IOStream(socket.socket())
498         try:
499             yield stream.connect(('127.0.0.1', self.get_http_port()))
500             stream.write(b'PUT /streaming?expected_size=10240 HTTP/1.1\r\n'
501                          b'Content-Length: 10240\r\n\r\n')
502             stream.write(b'a' * 10240)
503             headers, response = yield gen.Task(read_stream_body, stream)
504             self.assertEqual(response, b'10240')
505             stream.write(b'PUT /streaming HTTP/1.1\r\n'
506                          b'Content-Length: 10240\r\n\r\n')
507             with ExpectLog(gen_log, '.*Content-Length too long'):
508                 data = yield stream.read_until_close()
509             self.assertEqual(data, b'')
510         finally:
511             stream.close()
512 class LegacyInterfaceTest(AsyncHTTPTestCase):
513     def get_app(self):
514         def handle_request(request):
515             self.http1 = request.version.startswith("HTTP/1.")
516             if not self.http1:
517                 request.connection.write_headers(
518                     ResponseStartLine('', 200, 'OK'),
519                     HTTPHeaders())
520                 request.connection.finish()
521                 return
522             message = b"Hello world"
523             request.write(utf8("HTTP/1.1 200 OK\r\n"
524                                "Content-Length: %d\r\n\r\n" % len(message)))
525             request.write(message)
526             request.finish()
527         return handle_request
528     def test_legacy_interface(self):
529         response = self.fetch('/')
530         if not self.http1:
531             self.skipTest("requires HTTP/1.x")
532         self.assertEqual(response.body, b"Hello world")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
