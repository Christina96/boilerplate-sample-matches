
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.009575923392613%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-compute_masks.py</h3>
            <pre><code>1  import numpy as np
2  import matplotlib.pyplot as plt
3  import cv2
4  import torch
5  import torch.nn.functional as F
6  COLORS = ((255, 0, 0, 128), (0, 255, 0, 128), (0, 0, 255, 128),
7            (0, 255, 255, 128), (255, 0, 255, 128), (255, 255, 0, 128))
8  def mask_iou(mask1, mask2):
9      intersection = torch.matmul(mask1, mask2.t())
10      area1 = torch.sum(mask1, dim=1).view(1, -1)
11      area2 = torch.sum(mask2, dim=1).view(1, -1)
12      union = (area1.t() + area2) - intersection
13      return intersection / union
14  def paint_mask(img_numpy, mask, color):
15  	h, w, _ = img_numpy.shape
16  	img_numpy = img_numpy.copy()
17  	mask = np.tile(mask.reshape(h, w, 1), (1, 1, 3))
18  	color_np = np.array(color[:3]).reshape(1, 1, 3)
19  	color_np = np.tile(color_np, (h, w, 1))
20  	mask_color = mask * color_np
21  	mask_alpha = 0.3
22  	image_crop = img_numpy * mask
23  	img_numpy *= (1-mask)
24  	img_numpy += image_crop * (1-mask_alpha) + mask_color * mask_alpha
25  	return img_numpy
26  def logit(x):
27  	return np.log(x / (1-x + 0.0001) + 0.0001)
28  def sigmoid(x):
29  	return 1 / (1 + np.exp(-x))
30  img_fmt = '../data/coco/images/%012d.jpg'
31  with open('info.txt', 'r') as f:
32  	img_id = int(f.read())
33  img = plt.imread(img_fmt % img_id).astype(np.float32)
34  h, w, _ = img.shape
35  gt_masks    = np.load('gt.npy').astype(np.float32).transpose(1, 2, 0)
36  proto_masks = np.load('proto.npy').astype(np.float32)
<span onclick='openModal()' class='match'>37  proto_masks = torch.Tensor(proto_masks).permute(2, 0, 1).contiguous().unsqueeze(0)
38  proto_masks = F.interpolate(proto_masks, (h, w), mode='bilinear', align_corners=False).squeeze(0)
</span>39  proto_masks = proto_masks.permute(1, 2, 0).numpy()
40  ls_A = proto_masks.reshape(-1, proto_masks.shape[-1])
41  ls_b = gt_masks.reshape(-1, gt_masks.shape[-1])
42  x = np.linalg.lstsq(ls_A, ls_b, rcond=None)[0]
43  approximated_masks = (np.matmul(proto_masks, x) > 0.5).astype(np.float32)
44  num_gt = approximated_masks.shape[2]
45  ious = mask_iou(torch.Tensor(approximated_masks.reshape(-1, num_gt).T),
46  				torch.Tensor(gt_masks.reshape(-1, num_gt).T))
47  ious = [int(ious[i, i].item() * 100) for i in range(num_gt)]
48  ious.sort(key=lambda x: -x)
49  print(ious)
50  gt_img = img.copy()
51  for i in range(num_gt):
52  	gt_img = paint_mask(gt_img, gt_masks[:, :, i], COLORS[i % len(COLORS)])
53  plt.imshow(gt_img / 255)
54  plt.title('GT')
55  plt.show()
56  for i in range(num_gt):
57  	img = paint_mask(img, approximated_masks[:, :, i], COLORS[i % len(COLORS)])
58  plt.imshow(img / 255)
59  plt.title('Approximated')
60  plt.show()
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-haiku.py</h3>
            <pre><code>1  import collections
2  import functools
3  import itertools
4  import threading
5  import contextlib
6  from sonnet.src.functional import utils
7  import tensorflow as tf
8  Transformed = collections.namedtuple("Transformed", ("init", "apply"))
9  TransformedWithState = collections.namedtuple("TransformedWithState",
10                                                ("init", "apply"))
11  class TensorVariableCallbacks(threading.local):
12    instance = None  # Thread local singleton instance.
13    def __init__(self):
14      super().__init__()
15      self._recording = False
16      self._callbacks = []
17    def notify(self, variable):
18      if self._recording:
19        assert isinstance(variable, TensorVariable)
20        for callback in self._callbacks:
21          callback(variable)
22    @contextlib.contextmanager
23    def __call__(self, callback):
24      self._callbacks.append(callback)
25      recording = self._recording
26      try:
27        self._recording = True
28        yield
29      finally:
30        assert self._callbacks.pop() is callback
31        self._recording = recording
32  TensorVariableCallbacks.instance = TensorVariableCallbacks()
33  def notify(f):
34    @functools.wraps(f)
35    def wrapper(self, *args, **kwargs):
36      TensorVariableCallbacks.instance.notify(self)
37      return f(self, *args, **kwargs)  # pytype: disable=wrong-arg-count
38    return wrapper
39  def defer_property(name):
40    return property(fget=notify(lambda self: getattr(self.tensor_value, name)))
41  def safe_read_tensor_value(variable):
42    value = variable.tensor_value
43    if value is None:
44      raise ValueError("".join((
45          "Attempted to read a TensorVariable in a context where it has no ",
46          "value. This commonly happens for one of two reasons:",
47          "",
48          "   1) You created a model in one transformed function and directly",
49          "      accessed the model variables (e.g. via `model.variables` or"
50          "      `model.w`) inside another transformed function.",
51          "   2) You are trying to read a model variable outside of a",
52          "      transformed function.",
53          "",
54          "For (1) you can safely do this if you do not read the value of the",
55          "variable (e.g. you just use metadata like `v.shape` or `v.dtype`).",
56          "If you want to read the value of the variable then you must pass in",
57          "the value (e.g. pass the result of `f.init(..)`).",
58          "",
59          "For (2) to read variable values inspect the result of a transformed",
60          "function (e.g. look at the `params` dictionary returned from ",
61          "`f.init(..)`).")))
62    return value
63  def defer_read():
64    return property(
65        fget=notify(lambda self: (lambda: safe_read_tensor_value(self))))
66  def defer_raise_notimplemented():
67    def _raise_notimplemented():
68      raise NotImplementedError
69    return property(fget=notify(_raise_notimplemented))
70  def defer_indexed(f):
71    return property(fget=notify(lambda self, i: f(self, i.indices, i.values)))
72  def defer_assign(map_fn=None):
73    @notify
74    def wrapped(self, v):
75      if v is not None:
76        v = tf.convert_to_tensor(v, dtype=self.dtype)
77      if map_fn is not None:
78        v = map_fn(self.tensor_value, v)
79      if self.initial_tensor_value is None:
80        self.initial_tensor_value = v
81      self.tensor_value = v
82      return v
83    return wrapped
84  class TensorVariable(tf.Variable):
85    def __init__(self, value, trainable, name=None):
86      self.initial_tensor_value = value
87      self.tensor_value = value
88      self._trainable = trainable
89      self._name = name
90      self._shape = value.shape
91      self._dtype = value.dtype
92      self._device = value.device
93    shape = property(fget=lambda self: self._shape)
94    dtype = property(fget=lambda self: self._dtype)
95    trainable = property(fget=lambda self: self._trainable)
96    name = property(fget=lambda self: self._name)
97    device = property(fget=lambda self: self._device)
98    assign = defer_assign()
99    assign_add = defer_assign(tf.add)
100    assign_sub = defer_assign(tf.subtract)
101    batch_scatter_update = defer_raise_notimplemented()
102    scatter_add = defer_raise_notimplemented()
103    scatter_div = defer_raise_notimplemented()
104    scatter_max = defer_raise_notimplemented()
105    scatter_min = defer_raise_notimplemented()
106    scatter_mul = defer_raise_notimplemented()
107    scatter_sub = defer_raise_notimplemented()
108    scatter_update = defer_raise_notimplemented()
109    scatter_nd_add = defer_indexed(tf.tensor_scatter_nd_add)
110    scatter_nd_sub = defer_indexed(tf.tensor_scatter_nd_sub)
111    scatter_nd_update = defer_indexed(tf.tensor_scatter_nd_update)
112    load = defer_raise_notimplemented()
113    set_shape = defer_property("set_shape")
114    get_shape = defer_property("get_shape")
115    initialized_value = property(
116        fget=notify(lambda self: self.initial_tensor_value))
117    read_value = defer_read()
118    numpy = defer_property("numpy")
119    value = defer_read()
120    eval = defer_property("eval")
121    gather_nd = defer_indexed(tf.gather_nd)
122    sparse_read = defer_indexed(tf.gather)
123    to_proto = defer_raise_notimplemented()
124    count_up_to = defer_raise_notimplemented()
125    def __repr__(self):
126      return "TensorVariable(shape={}, dtype={}, name={!r})".format(
127          list(self.shape), self.dtype.name, self.name)
128    __str__ = __repr__
129    __add__ = defer_property("__add__")
130    __sub__ = defer_property("__sub__")
131    __mul__ = defer_property("__mul__")
132    __div__ = defer_property("__div__")
133  @functools.partial(tf.register_tensor_conversion_function, TensorVariable)
134  @notify
135  def tv_to_tensor(value, dtype=None, name=None, as_ref=None):
136    del as_ref
137    tensor_value = value.tensor_value
138    if tensor_value is None:
139      tensor_value = tf.zeros(value.shape, dtype=value.dtype)
140    if dtype is not None:
141      tensor_value = tf.cast(tensor_value, dtype=dtype, name=name)
142    return tensor_value
143  def create_tensor_variables():
144    def getter(next_getter, **kwargs):
145      del next_getter
146      initial_value = tf.convert_to_tensor(kwargs["initial_value"])
147      trainable = utils.first_non_none(kwargs["trainable"], True)
148      name = utils.first_non_none(kwargs["name"], "Variable")
149      name = utils.get_name_scope() + name + ":0"
150      return TensorVariable(initial_value, trainable=trainable, name=name)
151    return tf.variable_creator_scope(getter)
152  variables = create_tensor_variables
153  @contextlib.contextmanager
154  def track_tensor_variables():
155    tensor_variables = []
156    with TensorVariableCallbacks.instance(tensor_variables.append):  # pylint: disable=not-callable
157      yield tensor_variables
158  @contextlib.contextmanager
159  def track_new_variables():
160    new_variables = []
161    def getter(next_getter, *args, **kwargs):
162      var = next_getter(*args, **kwargs)
163      new_variables.append(var)
164      return var
165    with tf.variable_creator_scope(getter):
166      yield new_variables
167  @contextlib.contextmanager
168  def track_initial_state():
169    var_state = {}
170    def callback(v):
171      r = v.ref()
172      if r not in var_state:
173        var_state[r] = (v.initial_tensor_value, v.tensor_value)
174    with TensorVariableCallbacks.instance(callback):  # pylint: disable=not-callable
175      yield var_state
176  def initial_value_by_ref(tf_variables):
177    return {v.ref(): v.initial_tensor_value for v in tf_variables}
178  def final_value_by_ref(tf_variables):
179    return {v.ref(): v.tensor_value for v in tf_variables}
180  def transform(f) -> Transformed:
181    return without_state(transform_with_state(f))
182  def transform_with_state(f) -> TransformedWithState:
183    r
184    def init_fn(*args, **kwargs):
185      with create_tensor_variables(), \
186           track_new_variables() as new_variables, \
187           track_initial_state() as prev_var_state, \
188           track_tensor_variables() as tensor_variables:
189        f(*args, **kwargs)
190      params = initial_value_by_ref(v for v in tensor_variables if v.trainable)
191      state = initial_value_by_ref(v for v in tensor_variables if not v.trainable)
192      new_variables = {v.ref() for v in new_variables}
193      for v in tensor_variables:
194        r = v.ref()
195        if r in new_variables:
196          initial_tensor_value, tensor_value = None, None
197        else:
198          initial_tensor_value, tensor_value = prev_var_state[r]
199        v.initial_tensor_value = initial_tensor_value
200        v.tensor_value = tensor_value
201      return params, state
202    def apply_fn(params, state, *args, **kwargs):
203      initial_values = {}
<span onclick='openModal()' class='match'>204      for r, t in itertools.chain(params.items(), state.items()):
205        v = r.deref()
206        initial_values[r] = (v.tensor_value, v.initial_tensor_value)
</span>207        v.assign(t)
208      try:
209        with track_new_variables() as new_variables:
210          out = f(*args, **kwargs)
211        if new_variables:
212          raise ValueError("Apply function cannot create new variables.")
213        state = final_value_by_ref(p.deref() for p in state.keys())
214        return out, state
215      finally:
216        for r, (tensor_value, initial_tensor_value) in initial_values.items():
217          v = r.deref()
218          v.tensor_value = tensor_value
219          v.initial_tensor_value = initial_tensor_value
220    return TransformedWithState(init=init_fn, apply=apply_fn)
221  def without_state(with_state: TransformedWithState) -> Transformed:
222    def init_fn(*args, **kwargs):
223      params, state = with_state.init(*args, **kwargs)
224      if state:
225        raise ValueError("Stateful networks must use `transform_with_state(f)`")
226      return params
227    def apply_fn(params, *args, **kwargs):
228      y, state = with_state.apply(params, {}, *args, **kwargs)
229      if state:
230        raise ValueError("Stateful networks must use `transform_with_state(f)`")
231      return y
232    return Transformed(init_fn, apply_fn)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-compute_masks.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-haiku.py</div>
                </div>
                <div class="column column_space"><pre><code>37  proto_masks = torch.Tensor(proto_masks).permute(2, 0, 1).contiguous().unsqueeze(0)
38  proto_masks = F.interpolate(proto_masks, (h, w), mode='bilinear', align_corners=False).squeeze(0)
</pre></code></div>
                <div class="column column_space"><pre><code>204      for r, t in itertools.chain(params.items(), state.items()):
205        v = r.deref()
206        initial_values[r] = (v.tensor_value, v.initial_tensor_value)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    