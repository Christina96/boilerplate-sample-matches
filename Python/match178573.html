<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pillar_1.py &amp; boto_secgroup_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pillar_1.py &amp; boto_secgroup_1.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pillar_1.py (3.4482758%)<th>boto_secgroup_1.py (1.3348165%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(404-407)<td><a href="#" name="0">(144-147)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pillar_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import os
4 from collections.abc import Mapping
5 import salt.pillar
6 import salt.utils.crypt
7 import salt.utils.data
8 import salt.utils.dictupdate
9 import salt.utils.functools
10 import salt.utils.odict
11 import salt.utils.yaml
12 from salt.defaults import DEFAULT_TARGET_DELIM
13 from salt.exceptions import CommandExecutionError
14 __proxyenabled__ = ["*"]
15 log = logging.getLogger(__name__)
16 def get(
17     key,
18     default=None,
19     merge=False,
20     merge_nested_lists=None,
21     delimiter=DEFAULT_TARGET_DELIM,
22     pillarenv=None,
23     saltenv=None,
24 ):
25     if default is None:
26         default = KeyError
27     if not __opts__.get("pillar_raise_on_missing"):
28         if default is KeyError:
29             default = ""
30     opt_merge_lists = (
31         __opts__.get("pillar_merge_lists", False)
32         if merge_nested_lists is None
33         else merge_nested_lists
34     )
35     pillar_dict = (
36         __pillar__
37         if all(x is None for x in (saltenv, pillarenv))
38         else items(saltenv=saltenv, pillarenv=pillarenv)
39     )
40     if merge:
41         if isinstance(default, dict):
42             ret = salt.utils.data.traverse_dict_and_list(
43                 pillar_dict, key, {}, delimiter
44             )
45             if isinstance(ret, Mapping):
46                 default = copy.deepcopy(default)
47                 return salt.utils.dictupdate.update(
48                     default, ret, merge_lists=opt_merge_lists
49                 )
50             else:
51                 log.error(
52                     "pillar.get: Default (%s) is a dict, but the returned "
53                     "pillar value (%s) is of type '%s'. Merge will be "
54                     "skipped.",
55                     default,
56                     ret,
57                     type(ret).__name__,
58                 )
59         elif isinstance(default, list):
60             ret = salt.utils.data.traverse_dict_and_list(
61                 pillar_dict, key, [], delimiter
62             )
63             if isinstance(ret, list):
64                 default = copy.deepcopy(default)
65                 default.extend([x for x in ret if x not in default])
66                 return default
67             else:
68                 log.error(
69                     "pillar.get: Default (%s) is a list, but the returned "
70                     "pillar value (%s) is of type '%s'. Merge will be "
71                     "skipped.",
72                     default,
73                     ret,
74                     type(ret).__name__,
75                 )
76         else:
77             log.error(
78                 "pillar.get: Default (%s) is of type '%s', must be a dict "
79                 "or list to merge. Merge will be skipped.",
80                 default,
81                 type(default).__name__,
82             )
83     ret = salt.utils.data.traverse_dict_and_list(pillar_dict, key, default, delimiter)
84     if ret is KeyError:
85         raise KeyError("Pillar key not found: {}".format(key))
86     return ret
87 def items(*args, **kwargs):
88     if args:
89         return item(*args)
90     pillarenv = kwargs.get("pillarenv")
91     if pillarenv is None:
92         if __opts__.get("pillarenv_from_saltenv", False):
93             pillarenv = kwargs.get("saltenv") or __opts__["saltenv"]
94         else:
95             pillarenv = __opts__["pillarenv"]
96     pillar_override = kwargs.get("pillar")
97     pillar_enc = kwargs.get("pillar_enc")
98     if pillar_override and pillar_enc:
99         try:
100             pillar_override = salt.utils.crypt.decrypt(
101                 pillar_override,
102                 pillar_enc,
103                 translate_newlines=True,
104                 opts=__opts__,
105                 valid_rend=__opts__["decrypt_pillar_renderers"],
106             )
107         except Exception as exc:  # pylint: disable=broad-except
108             raise CommandExecutionError(
109                 "Failed to decrypt pillar override: {}".format(exc)
110             )
111     pillar = salt.pillar.get_pillar(
112         __opts__,
113         dict(__grains__),
114         __opts__["id"],
115         pillar_override=pillar_override,
116         pillarenv=pillarenv,
117     )
118     return pillar.compile_pillar()
119 data = salt.utils.functools.alias_function(items, "data")
120 def _obfuscate_inner(var):
121     if isinstance(var, (dict, salt.utils.odict.OrderedDict)):
122         return var.__class__((key, _obfuscate_inner(val)) for key, val in var.items())
123     elif isinstance(var, (list, set, tuple)):
124         return type(var)(_obfuscate_inner(v) for v in var)
125     else:
126         return "&lt;{}&gt;".format(var.__class__.__name__)
127 def obfuscate(*args):
128     return _obfuscate_inner(items(*args))
129 def ls(*args):
130     return list(items(*args))
131 def item(*args, **kwargs):
132     ret = {}
133     default <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= kwargs.get("default", "")
134     delimiter = kwargs.get("delimiter", DEFAULT_TARGET_DELIM)
135     pillarenv = kwargs.get("pillarenv", None)
136     saltenv = kwargs.get(</b></font>"saltenv", None)
137     pillar_dict = (
138         __pillar__
139         if all(x is None for x in (saltenv, pillarenv))
140         else items(saltenv=saltenv, pillarenv=pillarenv)
141     )
142     try:
143         for arg in args:
144             ret[arg] = salt.utils.data.traverse_dict_and_list(
145                 pillar_dict, arg, default, delimiter
146             )
147     except KeyError:
148         pass
149     return ret
150 def raw(key=None):
151     if key:
152         ret = __pillar__.get(key, {})
153     else:
154         ret = dict(__pillar__)
155     return ret
156 def ext(external, pillar=None):
157     if isinstance(external, str):
158         external = salt.utils.yaml.safe_load(external)
159     pillar_obj = salt.pillar.get_pillar(
160         __opts__,
161         __grains__.value(),
162         __opts__["id"],
163         __opts__["saltenv"],
164         ext=external,
165         pillar_override=pillar,
166     )
167     ret = pillar_obj.compile_pillar()
168     return ret
169 def keys(key, delimiter=DEFAULT_TARGET_DELIM):
170     ret = salt.utils.data.traverse_dict_and_list(__pillar__, key, KeyError, delimiter)
171     if ret is KeyError:
172         raise KeyError("Pillar key not found: {}".format(key))
173     if not isinstance(ret, dict):
174         raise ValueError("Pillar value in key {} is not a dict".format(key))
175     return list(ret)
176 def file_exists(path, saltenv=None):
177     pillar_roots = __opts__.get("pillar_roots")
178     if not pillar_roots:
179         raise CommandExecutionError(
180             "No pillar_roots found. Are you running this on the master?"
181         )
182     if saltenv:
183         if saltenv in pillar_roots:
184             pillar_roots = {saltenv: pillar_roots[saltenv]}
185         else:
186             return False
187     for env in pillar_roots:
188         for pillar_dir in pillar_roots[env]:
189             full_path = os.path.join(pillar_dir, path)
190             if __salt__["file.file_exists"](full_path):
191                 return True
192     return False
193 fetch = get
194 def filter_by(lookup_dict, pillar, merge=None, default="default", base=None):
195     return salt.utils.data.filter_by(
196         lookup_dict=lookup_dict,
197         lookup=pillar,
198         traverse=__pillar__,
199         merge=merge,
200         default=default,
201         base=base,
202     )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_secgroup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.odict as odict
3 import salt.utils.versions
4 from salt.exceptions import CommandExecutionError, SaltInvocationError
5 log = logging.getLogger(__name__)
6 try:
7     import boto
8     import boto.ec2
9     logging.getLogger("boto").setLevel(logging.CRITICAL)
10     HAS_BOTO = True
11 except ImportError:
12     HAS_BOTO = False
13 def __virtual__():
14     has_boto_reqs = salt.utils.versions.check_boto_reqs(
15         boto_ver="2.4.0", check_boto3=False
16     )
17     if has_boto_reqs is True:
18         __utils__["boto.assign_funcs"](__name__, "ec2", pack=__salt__)
19     return has_boto_reqs
20 def exists(
21     name=None,
22     region=None,
23     key=None,
24     keyid=None,
25     profile=None,
26     vpc_id=None,
27     vpc_name=None,
28     group_id=None,
29 ):
30     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
31     group = _get_group(
32         conn,
33         name=name,
34         vpc_id=vpc_id,
35         vpc_name=vpc_name,
36         group_id=group_id,
37         region=region,
38         key=key,
39         keyid=keyid,
40         profile=profile,
41     )
42     if group:
43         return True
44     else:
45         return False
46 def _vpc_name_to_id(
47     vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
48 ):
49     data = __salt__["boto_vpc.get_id"](
50         name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
51     )
52     return data.get("id")
53 def _split_rules(rules):
54         ip_protocol <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= rule.get("ip_protocol")
55         to_port = rule.get("to_port")
56         from_port = rule.get("from_port")
57         grants = rule.get(</b></font>"grants")
58         for grant in grants:
59             _rule = {
60                 "ip_protocol": ip_protocol,
61                 "to_port": to_port,
62                 "from_port": from_port,
63             }
64             for key, val in grant.items():
65                 _rule[key] = val
66             split.append(_rule)
67     return split
68 def _get_group(
69     conn=None,
70     name=None,
71     vpc_id=None,
72     vpc_name=None,
73     group_id=None,
74     region=None,
75     key=None,
76     keyid=None,
77     profile=None,
78 ):  # pylint: disable=W0613
79     if vpc_name and vpc_id:
80         raise SaltInvocationError(
81             "The params 'vpc_id' and 'vpc_name' are mutually exclusive."
82         )
83     if vpc_name:
84         try:
85             vpc_id = _vpc_name_to_id(
86                 vpc_id=vpc_id,
87                 vpc_name=vpc_name,
88                 region=region,
89                 key=key,
90                 keyid=keyid,
91                 profile=profile,
92             )
93         except boto.exception.BotoServerError as e:
94             log.debug(e)
95             return None
96     if name:
97         if vpc_id is None:
98             log.debug("getting group for %s", name)
99             group_filter = {"group-name": name}
100             filtered_groups = conn.get_all_security_groups(filters=group_filter)
101             for group in filtered_groups:
102                 if group.vpc_id is None:
103                     return group
104             if len(filtered_groups) &gt; 1:
105                 raise CommandExecutionError(
106                     "Security group belongs to more VPCs, specify the VPC ID!"
107                 )
108             elif len(filtered_groups) == 1:
109                 return filtered_groups[0]
110             return None
111         elif vpc_id:
112             log.debug("getting group for %s in vpc_id %s", name, vpc_id)
113             group_filter = {"group-name": name, "vpc_id": vpc_id}
114             filtered_groups = conn.get_all_security_groups(filters=group_filter)
115             if len(filtered_groups) == 1:
116                 return filtered_groups[0]
117             else:
118                 return None
119         else:
120             return None
121     elif group_id:
122         try:
123             groups = conn.get_all_security_groups(group_ids=[group_id])
124         except boto.exception.BotoServerError as e:
125             log.debug(e)
126             return None
127         if len(groups) == 1:
128             return groups[0]
129         else:
130             return None
131     else:
132         return None
133 def _parse_rules(sg, rules):
134     _rules = []
135     for rule in rules:
136         log.debug("examining rule %s for group %s", rule, sg.id)
137         attrs = ["ip_protocol", "from_port", "to_port", "grants"]
138         _rule = odict.OrderedDict()
139         for attr in attrs:
140             val = getattr(rule, attr)
141             if not val:
142                 continue
143             if attr == "grants":
144                 _grants = []
145                 for grant in val:
146                     log.debug("examining grant %s for", grant)
147                     g_attrs = {
148                         "name": "source_group_name",
149                         "owner_id": "source_group_owner_id",
150                         "group_id": "source_group_group_id",
151                         "cidr_ip": "cidr_ip",
152                     }
153                     _grant = odict.OrderedDict()
154                     for g_attr, g_attr_map in g_attrs.items():
155                         g_val = getattr(grant, g_attr)
156                         if not g_val:
157                             continue
158                         _grant[g_attr_map] = g_val
159                     _grants.append(_grant)
160                 _rule["grants"] = _grants
161             elif attr == "from_port":
162                 _rule[attr] = int(val)
163             elif attr == "to_port":
164                 _rule[attr] = int(val)
165             else:
166                 _rule[attr] = val
167         _rules.append(_rule)
168     return _rules
169 def get_all_security_groups(
170     groupnames=None,
171     group_ids=None,
172     filters=None,
173     region=None,
174     key=None,
175     keyid=None,
176     profile=None,
177 ):
178     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
179     if isinstance(groupnames, str):
180         groupnames = [groupnames]
181     if isinstance(group_ids, str):
182         groupnames = [group_ids]
183     interesting = [
184         "description",
185         "id",
186         "instances",
187         "name",
188         "owner_id",
189         "region",
190         "rules",
191         "rules_egress",
192         "tags",
193         "vpc_id",
194     ]
195     ret = []
196     try:
197         r = conn.get_all_security_groups(
198             groupnames=groupnames, group_ids=group_ids, filters=filters
199         )
200         for g in r:
201             n = {}
202             for a in interesting:
203                 v = getattr(g, a, None)
204                 if a == "region":
205                     v = v.name
206                 elif a in ("rules", "rules_egress"):
207                     v = _parse_rules(g, v)
208                 elif a == "instances":
209                     v = [i.id for i in v()]
210                 n[a] = v
211             ret += [n]
212         return ret
213     except boto.exception.BotoServerError as e:
214         log.debug(e)
215         return []
216 def get_group_id(
217     name, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
218 ):
219     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
220     if name.startswith("sg-"):
221         log.debug("group %s is a group id. get_group_id not called.", name)
222         return name
223     group = _get_group(
224         conn=conn,
225         name=name,
226         vpc_id=vpc_id,
227         vpc_name=vpc_name,
228         region=region,
229         key=key,
230         keyid=keyid,
231         profile=profile,
232     )
233     return getattr(group, "id", None)
234 def convert_to_group_ids(
235     groups, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
236 ):
237     log.debug("security group contents %s pre-conversion", groups)
238     group_ids = []
239     for group in groups:
240         group_id = get_group_id(
241             name=group,
242             vpc_id=vpc_id,
243             vpc_name=vpc_name,
244             region=region,
245             key=key,
246             keyid=keyid,
247             profile=profile,
248         )
249         if not group_id:
250             if __opts__["test"]:
251                 log.warn(
252                     "Security Group `%s` could not be resolved to an ID.  This may "
253                     "cause a failure when not running in test mode.",
254                     group,
255                 )
256                 return []
257             else:
258                 raise CommandExecutionError(
259                     "Could not resolve Security Group name {} to a Group ID".format(
260                         group
261                     )
262                 )
263         else:
264             group_ids.append(str(group_id))
265     log.debug("security group contents %s post-conversion", group_ids)
266     return group_ids
267 def get_config(
268     name=None,
269     group_id=None,
270     region=None,
271     key=None,
272     keyid=None,
273     profile=None,
274     vpc_id=None,
275     vpc_name=None,
276 ):
277     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
278     sg = _get_group(
279         conn,
280         name=name,
281         vpc_id=vpc_id,
282         vpc_name=vpc_name,
283         group_id=group_id,
284         region=region,
285         key=key,
286         keyid=keyid,
287         profile=profile,
288     )
289     if sg:
290         ret = odict.OrderedDict()
291         ret["name"] = sg.name
292         ret["group_id"] = sg.id
293         ret["owner_id"] = sg.owner_id
294         ret["description"] = sg.description
295         ret["tags"] = sg.tags
296         _rules = _parse_rules(sg, sg.rules)
297         _rules_egress = _parse_rules(sg, sg.rules_egress)
298         ret["rules"] = _split_rules(_rules)
299         ret["rules_egress"] = _split_rules(_rules_egress)
300         return ret
301     else:
302         return None
303 def create(
304     name,
305     description,
306     vpc_id=None,
307     vpc_name=None,
308     region=None,
309     key=None,
310     keyid=None,
311     profile=None,
312 ):
313     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
314     if not vpc_id and vpc_name:
315         try:
316             vpc_id = _vpc_name_to_id(
317                 vpc_id=vpc_id,
318                 vpc_name=vpc_name,
319                 region=region,
320                 key=key,
321                 keyid=keyid,
322                 profile=profile,
323             )
324         except boto.exception.BotoServerError as e:
325             log.debug(e)
326             return False
327     created = conn.create_security_group(name, description, vpc_id)
328     if created:
329         log.info("Created security group %s.", name)
330         return True
331     else:
332         msg = "Failed to create security group {}.".format(name)
333         log.error(msg)
334         return False
335 def delete(
336     name=None,
337     group_id=None,
338     region=None,
339     key=None,
340     keyid=None,
341     profile=None,
342     vpc_id=None,
343     vpc_name=None,
344 ):
345     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
346     group = _get_group(
347         conn,
348         name=name,
349         vpc_id=vpc_id,
350         vpc_name=vpc_name,
351         group_id=group_id,
352         region=region,
353         key=key,
354         keyid=keyid,
355         profile=profile,
356     )
357     if group:
358         deleted = conn.delete_security_group(group_id=group.id)
359         if deleted:
360             log.info("Deleted security group %s with id %s.", group.name, group.id)
361             return True
362         else:
363             msg = "Failed to delete security group {}.".format(name)
364             log.error(msg)
365             return False
366     else:
367         log.debug("Security group not found.")
368         return False
369 def authorize(
370     name=None,
371     source_group_name=None,
372     source_group_owner_id=None,
373     ip_protocol=None,
374     from_port=None,
375     to_port=None,
376     cidr_ip=None,
377     group_id=None,
378     source_group_group_id=None,
379     region=None,
380     key=None,
381     keyid=None,
382     profile=None,
383     vpc_id=None,
384     vpc_name=None,
385     egress=False,
386 ):
387     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
388     group = _get_group(
389         conn,
390         name=name,
391         vpc_id=vpc_id,
392         vpc_name=vpc_name,
393         group_id=group_id,
394         region=region,
395         key=key,
396         keyid=keyid,
397         profile=profile,
398     )
399     if group:
400         try:
401             added = None
402             if not egress:
403                 added = conn.authorize_security_group(
404                     src_security_group_name=source_group_name,
405                     src_security_group_owner_id=source_group_owner_id,
406                     ip_protocol=ip_protocol,
407                     from_port=from_port,
408                     to_port=to_port,
409                     cidr_ip=cidr_ip,
410                     group_id=group.id,
411                     src_security_group_group_id=source_group_group_id,
412                 )
413             else:
414                 added = conn.authorize_security_group_egress(
415                     ip_protocol=ip_protocol,
416                     from_port=from_port,
417                     to_port=to_port,
418                     cidr_ip=cidr_ip,
419                     group_id=group.id,
420                     src_group_id=source_group_group_id,
421                 )
422             if added:
423                 log.info(
424                     "Added rule to security group %s with id %s", group.name, group.id
425                 )
426                 return True
427             else:
428                 msg = "Failed to add rule to security group {} with id {}.".format(
429                     group.name, group.id
430                 )
431                 log.error(msg)
432                 return False
433         except boto.exception.EC2ResponseError as e:
434             if e.error_code == "InvalidPermission.Duplicate":
435                 return True
436             msg = "Failed to add rule to security group {} with id {}.".format(
437                 group.name, group.id
438             )
439             log.error(msg)
440             log.error(e)
441             return False
442     else:
443         log.error("Failed to add rule to security group.")
444         return False
445 def revoke(
446     name=None,
447     source_group_name=None,
448     source_group_owner_id=None,
449     ip_protocol=None,
450     from_port=None,
451     to_port=None,
452     cidr_ip=None,
453     group_id=None,
454     source_group_group_id=None,
455     region=None,
456     key=None,
457     keyid=None,
458     profile=None,
459     vpc_id=None,
460     vpc_name=None,
461     egress=False,
462 ):
463     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
464     group = _get_group(
465         conn,
466         name=name,
467         vpc_id=vpc_id,
468         vpc_name=vpc_name,
469         group_id=group_id,
470         region=region,
471         key=key,
472         keyid=keyid,
473         profile=profile,
474     )
475     if group:
476         try:
477             revoked = None
478             if not egress:
479                 revoked = conn.revoke_security_group(
480                     src_security_group_name=source_group_name,
481                     src_security_group_owner_id=source_group_owner_id,
482                     ip_protocol=ip_protocol,
483                     from_port=from_port,
484                     to_port=to_port,
485                     cidr_ip=cidr_ip,
486                     group_id=group.id,
487                     src_security_group_group_id=source_group_group_id,
488                 )
489             else:
490                 revoked = conn.revoke_security_group_egress(
491                     ip_protocol=ip_protocol,
492                     from_port=from_port,
493                     to_port=to_port,
494                     cidr_ip=cidr_ip,
495                     group_id=group.id,
496                     src_group_id=source_group_group_id,
497                 )
498             if revoked:
499                 log.info(
500                     "Removed rule from security group %s with id %s.",
501                     group.name,
502                     group.id,
503                 )
504                 return True
505             else:
506                 msg = "Failed to remove rule from security group {} with id {}.".format(
507                     group.name, group.id
508                 )
509                 log.error(msg)
510                 return False
511         except boto.exception.EC2ResponseError as e:
512             msg = "Failed to remove rule from security group {} with id {}.".format(
513                 group.name, group.id
514             )
515             log.error(msg)
516             log.error(e)
517             return False
518     else:
519         log.error("Failed to remove rule from security group.")
520         return False
521 def _find_vpcs(
522     vpc_id=None,
523     vpc_name=None,
524     cidr=None,
525     tags=None,
526     region=None,
527     key=None,
528     keyid=None,
529     profile=None,
530 ):
531     if all((vpc_id, vpc_name)):
532         raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
533     if not any((vpc_id, vpc_name, tags, cidr)):
534         raise SaltInvocationError(
535             "At least one of the following must be "
536             "provided: vpc_id, vpc_name, cidr or tags."
537         )
538     local_get_conn = __utils__["boto.get_connection_func"]("vpc")
539     conn = local_get_conn(region=region, key=key, keyid=keyid, profile=profile)
540     filter_parameters = {"filters": {}}
541     if vpc_id:
542         filter_parameters["vpc_ids"] = [vpc_id]
543     if cidr:
544         filter_parameters["filters"]["cidr"] = cidr
545     if vpc_name:
546         filter_parameters["filters"]["tag:Name"] = vpc_name
547     if tags:
548         for tag_name, tag_value in tags.items():
549             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
550     vpcs = conn.get_all_vpcs(**filter_parameters)
551     log.debug(
552         "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
553     )
554     if vpcs:
555         return [vpc.id for vpc in vpcs]
556     else:
557         return []
558 def set_tags(
559     tags,
560     name=None,
561     group_id=None,
562     vpc_name=None,
563     vpc_id=None,
564     region=None,
565     key=None,
566     keyid=None,
567     profile=None,
568 ):
569     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
570     secgrp = _get_group(
571         conn,
572         name=name,
573         vpc_id=vpc_id,
574         vpc_name=vpc_name,
575         group_id=group_id,
576         region=region,
577         key=key,
578         keyid=keyid,
579         profile=profile,
580     )
581     if secgrp:
582         if isinstance(tags, dict):
583             secgrp.add_tags(tags)
584         else:
585             msg = "Tags must be a dict of tagname:tagvalue"
586             raise SaltInvocationError(msg)
587     else:
588         msg = "The security group could not be found"
589         raise SaltInvocationError(msg)
590     return True
591 def delete_tags(
592     tags,
593     name=None,
594     group_id=None,
595     vpc_name=None,
596     vpc_id=None,
597     region=None,
598     key=None,
599     keyid=None,
600     profile=None,
601 ):
602     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
603     secgrp = _get_group(
604         conn,
605         name=name,
606         vpc_id=vpc_id,
607         vpc_name=vpc_name,
608         group_id=group_id,
609         region=region,
610         key=key,
611         keyid=keyid,
612         profile=profile,
613     )
614     if secgrp:
615         if isinstance(tags, list):
616             tags_to_remove = {}
617             for tag in tags:
618                 tags_to_remove[tag] = None
619             secgrp.remove_tags(tags_to_remove)
620         else:
621             msg = "Tags must be a list of tagnames to remove from the security group"
622             raise SaltInvocationError(msg)
623     else:
624         msg = "The security group could not be found"
625         raise SaltInvocationError(msg)
626     return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
