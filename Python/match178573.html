<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for pillar_1.py & boto_secgroup_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for pillar_1.py & boto_secgroup_1.py
      </h3>
      <h1 align="center">
        1.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>pillar_1.py (3.4482758%)<TH>boto_secgroup_1.py (1.3348165%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match178573-0.html#0',2,'match178573-1.html#0',3)" NAME="0">(404-407)<TD><A HREF="javascript:ZweiFrames('match178573-0.html#0',2,'match178573-1.html#0',3)" NAME="0">(144-147)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pillar_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Extract the pillar data for this minion
&quot;&quot;&quot;

import copy
import logging
import os
from collections.abc import Mapping

import salt.pillar
import salt.utils.crypt
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.functools
import salt.utils.odict
import salt.utils.yaml
from salt.defaults import DEFAULT_TARGET_DELIM
from salt.exceptions import CommandExecutionError

__proxyenabled__ = [&quot;*&quot;]

log = logging.getLogger(__name__)


def get(
    key,
    default=None,
    merge=False,
    merge_nested_lists=None,
    delimiter=DEFAULT_TARGET_DELIM,
    pillarenv=None,
    saltenv=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 0.14

    Attempt to retrieve the named value from :ref:`in-memory pillar data
    &lt;pillar-in-memory&gt;`. If the pillar key is not present in the in-memory
    pillar, then the value specified in the ``default`` option (described
    below) will be returned.

    If the merge parameter is set to ``True``, the default will be recursively
    merged into the returned pillar data.

    The value can also represent a value in a nested dict using a &quot;:&quot; delimiter
    for the dict. This means that if a dict in pillar looks like this::

        {'pkg': {'apache': 'httpd'}}

    To retrieve the value associated with the ``apache`` key in the ``pkg``
    dict this key can be passed as::

        pkg:apache

    key
        The pillar key to get value from

    default
        The value specified by this option will be returned if the desired
        pillar key does not exist.

        If a default value is not specified, then it will be an empty string,
        unless :conf_minion:`pillar_raise_on_missing` is set to ``True``, in
        which case an error will be raised.

    merge : ``False``
        If ``True``, the retrieved values will be merged into the passed
        default. When the default and the retrieved value are both
        dictionaries, the dictionaries will be recursively merged.

        .. versionadded:: 2014.7.0
        .. versionchanged:: 2016.3.7,2016.11.4,2017.7.0
            If the default and the retrieved value are not of the same type,
            then merging will be skipped and the retrieved value will be
            returned. Earlier releases raised an error in these cases.

    merge_nested_lists
        If set to ``False``, lists nested within the retrieved pillar
        dictionary will *overwrite* lists in ``default``. If set to ``True``,
        nested lists will be *merged* into lists in ``default``. If unspecified
        (the default), this option is inherited from the
        :conf_minion:`pillar_merge_lists` minion config option.

        .. note::
            This option is ignored when ``merge`` is set to ``False``.

        .. versionadded:: 2016.11.6

    delimiter
        Specify an alternate delimiter to use when traversing a nested dict.
        This is useful for when the desired key contains a colon. See CLI
        example below for usage.

        .. versionadded:: 2014.7.0

    pillarenv
        If specified, this function will query the master to generate fresh
        pillar data on the fly, specifically from the requested pillar
        environment. Note that this can produce different pillar data than
        executing this function without an environment, as its normal behavior
        is just to return a value from minion's pillar data in memory (which
        can be sourced from more than one pillar environment).

        Using this argument will not affect the pillar data in memory. It will
        however be slightly slower and use more resources on the master due to
        the need for the master to generate and send the minion fresh pillar
        data. This tradeoff in performance however allows for the use case
        where pillar data is desired only from a single environment.

        .. versionadded:: 2017.7.0

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

        .. versionadded:: 2017.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' pillar.get pkg:apache
        salt '*' pillar.get abc::def|ghi delimiter='|'
    &quot;&quot;&quot;
    if default is None:
        default = KeyError
    if not __opts__.get(&quot;pillar_raise_on_missing&quot;):
        if default is KeyError:
            default = &quot;&quot;
    opt_merge_lists = (
        __opts__.get(&quot;pillar_merge_lists&quot;, False)
        if merge_nested_lists is None
        else merge_nested_lists
    )
    pillar_dict = (
        __pillar__
        if all(x is None for x in (saltenv, pillarenv))
        else items(saltenv=saltenv, pillarenv=pillarenv)
    )

    if merge:
        if isinstance(default, dict):
            ret = salt.utils.data.traverse_dict_and_list(
                pillar_dict, key, {}, delimiter
            )
            if isinstance(ret, Mapping):
                default = copy.deepcopy(default)
                return salt.utils.dictupdate.update(
                    default, ret, merge_lists=opt_merge_lists
                )
            else:
                log.error(
                    &quot;pillar.get: Default (%s) is a dict, but the returned &quot;
                    &quot;pillar value (%s) is of type '%s'. Merge will be &quot;
                    &quot;skipped.&quot;,
                    default,
                    ret,
                    type(ret).__name__,
                )
        elif isinstance(default, list):
            ret = salt.utils.data.traverse_dict_and_list(
                pillar_dict, key, [], delimiter
            )
            if isinstance(ret, list):
                default = copy.deepcopy(default)
                default.extend([x for x in ret if x not in default])
                return default
            else:
                log.error(
                    &quot;pillar.get: Default (%s) is a list, but the returned &quot;
                    &quot;pillar value (%s) is of type '%s'. Merge will be &quot;
                    &quot;skipped.&quot;,
                    default,
                    ret,
                    type(ret).__name__,
                )
        else:
            log.error(
                &quot;pillar.get: Default (%s) is of type '%s', must be a dict &quot;
                &quot;or list to merge. Merge will be skipped.&quot;,
                default,
                type(default).__name__,
            )

    ret = salt.utils.data.traverse_dict_and_list(pillar_dict, key, default, delimiter)
    if ret is KeyError:
        raise KeyError(&quot;Pillar key not found: {}&quot;.format(key))

    return ret


def items(*args, **kwargs):
    &quot;&quot;&quot;
    Calls the master for a fresh pillar and generates the pillar data on the
    fly

    Contrast with :py:func:`raw` which returns the pillar data that is
    currently loaded into the minion.

    pillar
        If specified, allows for a dictionary of pillar data to be made
        available to pillar and ext_pillar rendering. these pillar variables
        will also override any variables of the same name in pillar or
        ext_pillar.

        .. versionadded:: 2015.5.0

    pillar_enc
        If specified, the data passed in the ``pillar`` argument will be passed
        through this renderer to decrypt it.

        .. note::
            This will decrypt on the minion side, so the specified renderer
            must be set up on the minion for this to work. Alternatively,
            pillar data can be decrypted master-side. For more information, see
            the :ref:`Pillar Encryption &lt;pillar-encryption&gt;` documentation.
            Pillar data that is decrypted master-side, is not decrypted until
            the end of pillar compilation though, so minion-side decryption
            will be necessary if the encrypted pillar data must be made
            available in an decrypted state pillar/ext_pillar rendering.

        .. versionadded:: 2017.7.0

    pillarenv
        Pass a specific pillar environment from which to compile pillar data.
        If not specified, then the minion's :conf_minion:`pillarenv` option is
        not used, and if that also is not specified then all configured pillar
        environments will be merged into a single pillar dictionary and
        returned.

        .. versionadded:: 2016.11.2

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

    CLI Example:

    .. code-block:: bash

        salt '*' pillar.items
    &quot;&quot;&quot;
    # Preserve backwards compatibility
    if args:
        return item(*args)

    pillarenv = kwargs.get(&quot;pillarenv&quot;)
    if pillarenv is None:
        if __opts__.get(&quot;pillarenv_from_saltenv&quot;, False):
            pillarenv = kwargs.get(&quot;saltenv&quot;) or __opts__[&quot;saltenv&quot;]
        else:
            pillarenv = __opts__[&quot;pillarenv&quot;]

    pillar_override = kwargs.get(&quot;pillar&quot;)
    pillar_enc = kwargs.get(&quot;pillar_enc&quot;)

    if pillar_override and pillar_enc:
        try:
            pillar_override = salt.utils.crypt.decrypt(
                pillar_override,
                pillar_enc,
                translate_newlines=True,
                opts=__opts__,
                valid_rend=__opts__[&quot;decrypt_pillar_renderers&quot;],
            )
        except Exception as exc:  # pylint: disable=broad-except
            raise CommandExecutionError(
                &quot;Failed to decrypt pillar override: {}&quot;.format(exc)
            )

    pillar = salt.pillar.get_pillar(
        __opts__,
        dict(__grains__),
        __opts__[&quot;id&quot;],
        pillar_override=pillar_override,
        pillarenv=pillarenv,
    )
    return pillar.compile_pillar()


# Allow pillar.data to also be used to return pillar data
data = salt.utils.functools.alias_function(items, &quot;data&quot;)


def _obfuscate_inner(var):
    &quot;&quot;&quot;
    Recursive obfuscation of collection types.

    Leaf or unknown Python types get replaced by the type name
    Known collection types trigger recursion.
    In the special case of mapping types, keys are not obfuscated
    &quot;&quot;&quot;
    if isinstance(var, (dict, salt.utils.odict.OrderedDict)):
        return var.__class__((key, _obfuscate_inner(val)) for key, val in var.items())
    elif isinstance(var, (list, set, tuple)):
        return type(var)(_obfuscate_inner(v) for v in var)
    else:
        return &quot;&lt;{}&gt;&quot;.format(var.__class__.__name__)


def obfuscate(*args):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Same as :py:func:`items`, but replace pillar values with a simple type indication.

    This is useful to avoid displaying sensitive information on console or
    flooding the console with long output, such as certificates.
    For many debug or control purposes, the stakes lie more in dispatching than in
    actual values.

    In case the value is itself a collection type, obfuscation occurs within the value.
    For mapping types, keys are not obfuscated.
    Here are some examples:

    * ``'secret password'`` becomes ``'&lt;str&gt;'``
    * ``['secret', 1]`` becomes ``['&lt;str&gt;', '&lt;int&gt;']``
    * ``{'login': 'somelogin', 'pwd': 'secret'}`` becomes
      ``{'login': '&lt;str&gt;', 'pwd': '&lt;str&gt;'}``

    CLI Examples:

    .. code-block:: bash

        salt '*' pillar.obfuscate

    &quot;&quot;&quot;
    return _obfuscate_inner(items(*args))


# naming chosen for consistency with grains.ls, although it breaks the short
# identifier rule.
def ls(*args):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Calls the master for a fresh pillar, generates the pillar data on the
    fly (same as :py:func:`items`), but only shows the available main keys.

    CLI Examples:

    .. code-block:: bash

        salt '*' pillar.ls
    &quot;&quot;&quot;

    return list(items(*args))


def item(*args, **kwargs):
    &quot;&quot;&quot;
    .. versionadded:: 0.16.2

    Return one or more pillar entries from the :ref:`in-memory pillar data
    &lt;pillar-in-memory&gt;`.

    delimiter
        Delimiter used to traverse nested dictionaries.

        .. note::
            This is different from :py:func:`pillar.get
            &lt;salt.modules.pillar.get&gt;` in that no default value can be
            specified. :py:func:`pillar.get &lt;salt.modules.pillar.get&gt;` should
            probably still be used in most cases to retrieve nested pillar
            values, as it is a bit more flexible. One reason to use this
            function instead of :py:func:`pillar.get &lt;salt.modules.pillar.get&gt;`
            however is when it is desirable to retrieve the values of more than
            one key, since :py:func:`pillar.get &lt;salt.modules.pillar.get&gt;` can
            only retrieve one key at a time.

        .. versionadded:: 2015.8.0

    pillarenv
        If specified, this function will query the master to generate fresh
        pillar data on the fly, specifically from the requested pillar
        environment. Note that this can produce different pillar data than
        executing this function without an environment, as its normal behavior
        is just to return a value from minion's pillar data in memory (which
        can be sourced from more than one pillar environment).

        Using this argument will not affect the pillar data in memory. It will
        however be slightly slower and use more resources on the master due to
        the need for the master to generate and send the minion fresh pillar
        data. This tradeoff in performance however allows for the use case
        where pillar data is desired only from a single environment.

        .. versionadded:: 2017.7.6,2018.3.1

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

        .. versionadded:: 2017.7.6,2018.3.1

    CLI Examples:

    .. code-block:: bash

        salt '*' pillar.item foo
        salt '*' pillar.item foo:bar
<A NAME="0"></A>        salt '*' pillar.item foo bar baz
    &quot;&quot;&quot;
    ret = {}
    default <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match178573-1.html#0',3,'match178573-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= kwargs.get(&quot;default&quot;, &quot;&quot;)
    delimiter = kwargs.get(&quot;delimiter&quot;, DEFAULT_TARGET_DELIM)
    pillarenv = kwargs.get(&quot;pillarenv&quot;, None)
    saltenv = kwargs.get(</B></FONT>&quot;saltenv&quot;, None)

    pillar_dict = (
        __pillar__
        if all(x is None for x in (saltenv, pillarenv))
        else items(saltenv=saltenv, pillarenv=pillarenv)
    )

    try:
        for arg in args:
            ret[arg] = salt.utils.data.traverse_dict_and_list(
                pillar_dict, arg, default, delimiter
            )
    except KeyError:
        pass

    return ret


def raw(key=None):
    &quot;&quot;&quot;
    Return the raw pillar data that is currently loaded into the minion.

    Contrast with :py:func:`items` which calls the master to fetch the most
    up-to-date Pillar.

    CLI Example:

    .. code-block:: bash

        salt '*' pillar.raw

    With the optional key argument, you can select a subtree of the
    pillar raw data.::

        salt '*' pillar.raw key='roles'
    &quot;&quot;&quot;
    if key:
        ret = __pillar__.get(key, {})
    else:
        ret = dict(__pillar__)

    return ret


def ext(external, pillar=None):
    '''
    .. versionchanged:: 2016.3.6,2016.11.3,2017.7.0
        The supported ext_pillar types are now tunable using the
        :conf_master:`on_demand_ext_pillar` config option. Earlier releases
        used a hard-coded default.

    Generate the pillar and apply an explicit external pillar


    external
        A single ext_pillar to add to the ext_pillar configuration. This must
        be passed as a single section from the ext_pillar configuration (see
        CLI examples below). For more complicated ``ext_pillar``
        configurations, it can be helpful to use the Python shell to load YAML
        configuration into a dictionary, and figure out

        .. code-block:: python

            &gt;&gt;&gt; import salt.utils.yaml
            &gt;&gt;&gt; ext_pillar = salt.utils.yaml.safe_load(&quot;&quot;&quot;
            ... ext_pillar:
            ...   - git:
            ...     - issue38440 https://github.com/terminalmage/git_pillar:
            ...       - env: base
            ... &quot;&quot;&quot;)
            &gt;&gt;&gt; ext_pillar
            {'ext_pillar': [{'git': [{'mybranch https://github.com/myuser/myrepo': [{'env': 'base'}]}]}]}
            &gt;&gt;&gt; ext_pillar['ext_pillar'][0]
            {'git': [{'mybranch https://github.com/myuser/myrepo': [{'env': 'base'}]}]}

        In the above example, the value to pass would be
        ``{'git': [{'mybranch https://github.com/myuser/myrepo': [{'env': 'base'}]}]}``.
        Note that this would need to be quoted when passing on the CLI (as in
        the CLI examples below).

    pillar : None
        If specified, allows for a dictionary of pillar data to be made
        available to pillar and ext_pillar rendering. These pillar variables
        will also override any variables of the same name in pillar or
        ext_pillar.

        .. versionadded:: 2015.5.0

    CLI Examples:

    .. code-block:: bash

        salt '*' pillar.ext '{libvirt: _}'
        salt '*' pillar.ext &quot;{'git': ['master https://github.com/myuser/myrepo']}&quot;
        salt '*' pillar.ext &quot;{'git': [{'mybranch https://github.com/myuser/myrepo': [{'env': 'base'}]}]}&quot;
    '''
    if isinstance(external, str):
        external = salt.utils.yaml.safe_load(external)
    pillar_obj = salt.pillar.get_pillar(
        __opts__,
        __grains__.value(),
        __opts__[&quot;id&quot;],
        __opts__[&quot;saltenv&quot;],
        ext=external,
        pillar_override=pillar,
    )

    ret = pillar_obj.compile_pillar()

    return ret


def keys(key, delimiter=DEFAULT_TARGET_DELIM):
    &quot;&quot;&quot;
    .. versionadded:: 2015.8.0

    Attempt to retrieve a list of keys from the named value from the pillar.

    The value can also represent a value in a nested dict using a &quot;:&quot; delimiter
    for the dict, similar to how pillar.get works.

    delimiter
        Specify an alternate delimiter to use when traversing a nested dict

    CLI Example:

    .. code-block:: bash

        salt '*' pillar.keys web:sites
    &quot;&quot;&quot;
    ret = salt.utils.data.traverse_dict_and_list(__pillar__, key, KeyError, delimiter)

    if ret is KeyError:
        raise KeyError(&quot;Pillar key not found: {}&quot;.format(key))

    if not isinstance(ret, dict):
        raise ValueError(&quot;Pillar value in key {} is not a dict&quot;.format(key))

    return list(ret)


def file_exists(path, saltenv=None):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    This is a master-only function. Calling from the minion is not supported.

    Use the given path and search relative to the pillar environments to see if
    a file exists at that path.

    If the ``saltenv`` argument is given, restrict search to that environment
    only.

    Will only work with ``pillar_roots``, not external pillars.

    Returns True if the file is found, and False otherwise.

    path
        The path to the file in question. Will be treated as a relative path

    saltenv
        Optional argument to restrict the search to a specific saltenv

    CLI Example:

    .. code-block:: bash

        salt '*' pillar.file_exists foo/bar.sls
    &quot;&quot;&quot;
    pillar_roots = __opts__.get(&quot;pillar_roots&quot;)
    if not pillar_roots:
        raise CommandExecutionError(
            &quot;No pillar_roots found. Are you running this on the master?&quot;
        )

    if saltenv:
        if saltenv in pillar_roots:
            pillar_roots = {saltenv: pillar_roots[saltenv]}
        else:
            return False

    for env in pillar_roots:
        for pillar_dir in pillar_roots[env]:
            full_path = os.path.join(pillar_dir, path)
            if __salt__[&quot;file.file_exists&quot;](full_path):
                return True

    return False


# Provide a jinja function call compatible get aliased as fetch
fetch = get


def filter_by(lookup_dict, pillar, merge=None, default=&quot;default&quot;, base=None):
    &quot;&quot;&quot;
    .. versionadded:: 2017.7.0

    Look up the given pillar in a given dictionary and return the result

    :param lookup_dict: A dictionary, keyed by a pillar, containing a value or
        values relevant to systems matching that pillar. For example, a key
        could be a pillar for a role and the value could the name of a package
        on that particular OS.

        The dictionary key can be a globbing pattern. The function will return
        the corresponding ``lookup_dict`` value where the pillar value matches
        the  pattern. For example:

        .. code-block:: bash

            # this will render 'got some salt' if ``role`` begins with 'salt'
            salt '*' pillar.filter_by '{salt*: got some salt, default: salt is not here}' role

    :param pillar: The name of a pillar to match with the system's pillar. For
        example, the value of the &quot;role&quot; pillar could be used to pull values
        from the ``lookup_dict`` dictionary.

        The pillar value can be a list. The function will return the
        ``lookup_dict`` value for a first found item in the list matching
        one of the ``lookup_dict`` keys.

    :param merge: A dictionary to merge with the results of the pillar
        selection from ``lookup_dict``. This allows another dictionary to
        override the values in the ``lookup_dict``.

    :param default: default lookup_dict's key used if the pillar does not exist
        or if the pillar value has no match on lookup_dict.  If unspecified
        the value is &quot;default&quot;.

    :param base: A lookup_dict key to use for a base dictionary.  The
        pillar-selected ``lookup_dict`` is merged over this and then finally
        the ``merge`` dictionary is merged.  This allows common values for
        each case to be collected in the base and overridden by the pillar
        selection dictionary and the merge dictionary.  Default is unset.

    CLI Example:

    .. code-block:: bash

        salt '*' pillar.filter_by '{web: Serve it up, db: I query, default: x_x}' role
    &quot;&quot;&quot;
    return salt.utils.data.filter_by(
        lookup_dict=lookup_dict,
        lookup=pillar,
        traverse=__pillar__,
        merge=merge,
        default=default,
        base=base,
    )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_secgroup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Connection module for Amazon Security Groups

.. versionadded:: 2014.7.0

:configuration: This module accepts explicit ec2 credentials but can
    also utilize IAM roles assigned to the instance through Instance Profiles.
    Dynamic credentials are then automatically obtained from AWS API and no
    further configuration is necessary. More Information available at:

    .. code-block:: text

        http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html

    If IAM roles are not used you need to specify them either in a pillar or
    in the minion's config file:

    .. code-block:: yaml

        secgroup.keyid: GKTADJGHEIQSXMKKRBJ08H
        secgroup.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    A region may also be specified in the configuration:

    .. code-block:: yaml

        secgroup.region: us-east-1

    If a region is not specified, the default is us-east-1.

    It's also possible to specify key, keyid and region via a profile, either
    as a passed in dict, or as a string to pull from pillars or minion config:

    .. code-block:: yaml

        myprofile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
            region: us-east-1

:depends: boto
&quot;&quot;&quot;
# keep lint from choking on _get_conn and _cache_id
# pylint: disable=E0602


import logging

import salt.utils.odict as odict
import salt.utils.versions
from salt.exceptions import CommandExecutionError, SaltInvocationError

log = logging.getLogger(__name__)


try:
    # pylint: disable=unused-import
    import boto
    import boto.ec2

    # pylint: enable=unused-import
    logging.getLogger(&quot;boto&quot;).setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False


def __virtual__():
    &quot;&quot;&quot;
    Only load if boto libraries exist and if boto libraries are greater than
    a given version.
    &quot;&quot;&quot;
    # Boto &lt; 2.4.0 GroupOrCIDR objects have different attributes than
    # Boto &gt;= 2.4.0 GroupOrCIDR objects
    # Differences include no group_id attribute in Boto &lt; 2.4.0 and returning
    # a groupId attribute when a GroupOrCIDR object authorizes an IP range
    # Support for Boto &lt; 2.4.0 can be added if needed
    has_boto_reqs = salt.utils.versions.check_boto_reqs(
        boto_ver=&quot;2.4.0&quot;, check_boto3=False
    )
    if has_boto_reqs is True:
        __utils__[&quot;boto.assign_funcs&quot;](__name__, &quot;ec2&quot;, pack=__salt__)
    return has_boto_reqs


def exists(
    name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
    group_id=None,
):
    &quot;&quot;&quot;
    Check to see if a security group exists.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.exists mysecgroup
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        return True
    else:
        return False


def _vpc_name_to_id(
    vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
):
    data = __salt__[&quot;boto_vpc.get_id&quot;](
        name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
    )
    return data.get(&quot;id&quot;)


def _split_rules(rules):
    &quot;&quot;&quot;
    Split rules with combined grants into individual rules.

    Amazon returns a set of rules with the same protocol, from and to ports
    together as a single rule with a set of grants. Authorizing and revoking
    rules, however, is done as a split set of rules. This function splits the
    rules up.
<A NAME="0"></A>    &quot;&quot;&quot;
    split = []
    for rule in rules:
        ip_protocol <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match178573-0.html#0',2,'match178573-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= rule.get(&quot;ip_protocol&quot;)
        to_port = rule.get(&quot;to_port&quot;)
        from_port = rule.get(&quot;from_port&quot;)
        grants = rule.get(</B></FONT>&quot;grants&quot;)
        for grant in grants:
            _rule = {
                &quot;ip_protocol&quot;: ip_protocol,
                &quot;to_port&quot;: to_port,
                &quot;from_port&quot;: from_port,
            }
            for key, val in grant.items():
                _rule[key] = val
            split.append(_rule)
    return split


def _get_group(
    conn=None,
    name=None,
    vpc_id=None,
    vpc_name=None,
    group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):  # pylint: disable=W0613
    &quot;&quot;&quot;
    Get a group object given a name, name and vpc_id/vpc_name or group_id. Return
    a boto.ec2.securitygroup.SecurityGroup object if the group is found, else
    return None.
    &quot;&quot;&quot;
    if vpc_name and vpc_id:
        raise SaltInvocationError(
            &quot;The params 'vpc_id' and 'vpc_name' are mutually exclusive.&quot;
        )
    if vpc_name:
        try:
            vpc_id = _vpc_name_to_id(
                vpc_id=vpc_id,
                vpc_name=vpc_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        except boto.exception.BotoServerError as e:
            log.debug(e)
            return None
    if name:
        if vpc_id is None:
            log.debug(&quot;getting group for %s&quot;, name)
            group_filter = {&quot;group-name&quot;: name}
            filtered_groups = conn.get_all_security_groups(filters=group_filter)
            # security groups can have the same name if groups exist in both
            # EC2-Classic and EC2-VPC
            # iterate through groups to ensure we return the EC2-Classic
            # security group
            for group in filtered_groups:
                # a group in EC2-Classic will have vpc_id set to None
                if group.vpc_id is None:
                    return group
            # If there are more security groups, and no vpc_id, we can't know which one to choose.
            if len(filtered_groups) &gt; 1:
                raise CommandExecutionError(
                    &quot;Security group belongs to more VPCs, specify the VPC ID!&quot;
                )
            elif len(filtered_groups) == 1:
                return filtered_groups[0]
            return None
        elif vpc_id:
            log.debug(&quot;getting group for %s in vpc_id %s&quot;, name, vpc_id)
            group_filter = {&quot;group-name&quot;: name, &quot;vpc_id&quot;: vpc_id}
            filtered_groups = conn.get_all_security_groups(filters=group_filter)
            if len(filtered_groups) == 1:
                return filtered_groups[0]
            else:
                return None
        else:
            return None
    elif group_id:
        try:
            groups = conn.get_all_security_groups(group_ids=[group_id])
        except boto.exception.BotoServerError as e:
            log.debug(e)
            return None
        if len(groups) == 1:
            return groups[0]
        else:
            return None
    else:
        return None


def _parse_rules(sg, rules):
    _rules = []
    for rule in rules:
        log.debug(&quot;examining rule %s for group %s&quot;, rule, sg.id)
        attrs = [&quot;ip_protocol&quot;, &quot;from_port&quot;, &quot;to_port&quot;, &quot;grants&quot;]
        _rule = odict.OrderedDict()
        for attr in attrs:
            val = getattr(rule, attr)
            if not val:
                continue
            if attr == &quot;grants&quot;:
                _grants = []
                for grant in val:
                    log.debug(&quot;examining grant %s for&quot;, grant)
                    g_attrs = {
                        &quot;name&quot;: &quot;source_group_name&quot;,
                        &quot;owner_id&quot;: &quot;source_group_owner_id&quot;,
                        &quot;group_id&quot;: &quot;source_group_group_id&quot;,
                        &quot;cidr_ip&quot;: &quot;cidr_ip&quot;,
                    }
                    _grant = odict.OrderedDict()
                    for g_attr, g_attr_map in g_attrs.items():
                        g_val = getattr(grant, g_attr)
                        if not g_val:
                            continue
                        _grant[g_attr_map] = g_val
                    _grants.append(_grant)
                _rule[&quot;grants&quot;] = _grants
            elif attr == &quot;from_port&quot;:
                _rule[attr] = int(val)
            elif attr == &quot;to_port&quot;:
                _rule[attr] = int(val)
            else:
                _rule[attr] = val
        _rules.append(_rule)
    return _rules


def get_all_security_groups(
    groupnames=None,
    group_ids=None,
    filters=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Return a list of all Security Groups matching the given criteria and
    filters.

    Note that the ``groupnames`` argument only functions correctly for EC2
    Classic and default VPC Security Groups.  To find groups by name in other
    VPCs you'll want to use the ``group-name`` filter instead.

    The valid keys for the ``filters`` argument can be found in `AWS's API
    documentation
    &lt;https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html&gt;`_.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.get_all_security_groups filters='{group-name: mygroup}'
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    if isinstance(groupnames, str):
        groupnames = [groupnames]
    if isinstance(group_ids, str):
        groupnames = [group_ids]

    interesting = [
        &quot;description&quot;,
        &quot;id&quot;,
        &quot;instances&quot;,
        &quot;name&quot;,
        &quot;owner_id&quot;,
        &quot;region&quot;,
        &quot;rules&quot;,
        &quot;rules_egress&quot;,
        &quot;tags&quot;,
        &quot;vpc_id&quot;,
    ]
    ret = []
    try:
        r = conn.get_all_security_groups(
            groupnames=groupnames, group_ids=group_ids, filters=filters
        )
        for g in r:
            n = {}
            for a in interesting:
                v = getattr(g, a, None)
                if a == &quot;region&quot;:
                    v = v.name
                elif a in (&quot;rules&quot;, &quot;rules_egress&quot;):
                    v = _parse_rules(g, v)
                elif a == &quot;instances&quot;:
                    v = [i.id for i in v()]
                n[a] = v
            ret += [n]
        return ret
    except boto.exception.BotoServerError as e:
        log.debug(e)
        return []


def get_group_id(
    name, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Get a Group ID given a Group Name or Group Name and VPC ID

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.get_group_id mysecgroup
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    if name.startswith(&quot;sg-&quot;):
        log.debug(&quot;group %s is a group id. get_group_id not called.&quot;, name)
        return name
    group = _get_group(
        conn=conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    return getattr(group, &quot;id&quot;, None)


def convert_to_group_ids(
    groups, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Given a list of security groups and a vpc_id, convert_to_group_ids will
    convert all list items in the given list to security group ids.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.convert_to_group_ids mysecgroup vpc-89yhh7h
    &quot;&quot;&quot;
    log.debug(&quot;security group contents %s pre-conversion&quot;, groups)
    group_ids = []
    for group in groups:
        group_id = get_group_id(
            name=group,
            vpc_id=vpc_id,
            vpc_name=vpc_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not group_id:
            # Security groups are a big deal - need to fail if any can't be resolved...
            # But... if we're running in test mode, it may just be that the SG is scheduled
            # to be created, and thus WOULD have been there if running &quot;for real&quot;...
            if __opts__[&quot;test&quot;]:
                log.warn(
                    &quot;Security Group `%s` could not be resolved to an ID.  This may &quot;
                    &quot;cause a failure when not running in test mode.&quot;,
                    group,
                )
                return []
            else:
                raise CommandExecutionError(
                    &quot;Could not resolve Security Group name {} to a Group ID&quot;.format(
                        group
                    )
                )
        else:
            group_ids.append(str(group_id))
    log.debug(&quot;security group contents %s post-conversion&quot;, group_ids)
    return group_ids


def get_config(
    name=None,
    group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
):
    &quot;&quot;&quot;
    Get the configuration for a security group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.get_config mysecgroup
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    sg = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if sg:
        ret = odict.OrderedDict()
        ret[&quot;name&quot;] = sg.name
        # TODO: add support for vpc_id in return
        # ret['vpc_id'] = sg.vpc_id
        ret[&quot;group_id&quot;] = sg.id
        ret[&quot;owner_id&quot;] = sg.owner_id
        ret[&quot;description&quot;] = sg.description
        ret[&quot;tags&quot;] = sg.tags
        _rules = _parse_rules(sg, sg.rules)
        _rules_egress = _parse_rules(sg, sg.rules_egress)
        ret[&quot;rules&quot;] = _split_rules(_rules)
        ret[&quot;rules_egress&quot;] = _split_rules(_rules_egress)
        return ret
    else:
        return None


def create(
    name,
    description,
    vpc_id=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Create a security group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.create mysecgroup 'My Security Group'
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    if not vpc_id and vpc_name:
        try:
            vpc_id = _vpc_name_to_id(
                vpc_id=vpc_id,
                vpc_name=vpc_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        except boto.exception.BotoServerError as e:
            log.debug(e)
            return False

    created = conn.create_security_group(name, description, vpc_id)
    if created:
        log.info(&quot;Created security group %s.&quot;, name)
        return True
    else:
        msg = &quot;Failed to create security group {}.&quot;.format(name)
        log.error(msg)
        return False


def delete(
    name=None,
    group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
):
    &quot;&quot;&quot;
    Delete a security group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.delete mysecgroup
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        deleted = conn.delete_security_group(group_id=group.id)
        if deleted:
            log.info(&quot;Deleted security group %s with id %s.&quot;, group.name, group.id)
            return True
        else:
            msg = &quot;Failed to delete security group {}.&quot;.format(name)
            log.error(msg)
            return False
    else:
        log.debug(&quot;Security group not found.&quot;)
        return False


def authorize(
    name=None,
    source_group_name=None,
    source_group_owner_id=None,
    ip_protocol=None,
    from_port=None,
    to_port=None,
    cidr_ip=None,
    group_id=None,
    source_group_group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
    egress=False,
):
    &quot;&quot;&quot;
    Add a new rule to an existing security group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.authorize mysecgroup ip_protocol=tcp from_port=80 to_port=80 cidr_ip='['10.0.0.0/8', '192.168.0.0/24']'
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        try:
            added = None
            if not egress:
                added = conn.authorize_security_group(
                    src_security_group_name=source_group_name,
                    src_security_group_owner_id=source_group_owner_id,
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_security_group_group_id=source_group_group_id,
                )
            else:
                added = conn.authorize_security_group_egress(
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_group_id=source_group_group_id,
                )
            if added:
                log.info(
                    &quot;Added rule to security group %s with id %s&quot;, group.name, group.id
                )
                return True
            else:
                msg = &quot;Failed to add rule to security group {} with id {}.&quot;.format(
                    group.name, group.id
                )
                log.error(msg)
                return False
        except boto.exception.EC2ResponseError as e:
            # if we are trying to add the same rule then we are already in the desired state, return true
            if e.error_code == &quot;InvalidPermission.Duplicate&quot;:
                return True
            msg = &quot;Failed to add rule to security group {} with id {}.&quot;.format(
                group.name, group.id
            )
            log.error(msg)
            log.error(e)
            return False
    else:
        log.error(&quot;Failed to add rule to security group.&quot;)
        return False


def revoke(
    name=None,
    source_group_name=None,
    source_group_owner_id=None,
    ip_protocol=None,
    from_port=None,
    to_port=None,
    cidr_ip=None,
    group_id=None,
    source_group_group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
    egress=False,
):
    &quot;&quot;&quot;
    Remove a rule from an existing security group.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.revoke mysecgroup ip_protocol=tcp from_port=80 to_port=80 cidr_ip='10.0.0.0/8'
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)

    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        try:
            revoked = None
            if not egress:
                revoked = conn.revoke_security_group(
                    src_security_group_name=source_group_name,
                    src_security_group_owner_id=source_group_owner_id,
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_security_group_group_id=source_group_group_id,
                )
            else:
                revoked = conn.revoke_security_group_egress(
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_group_id=source_group_group_id,
                )

            if revoked:
                log.info(
                    &quot;Removed rule from security group %s with id %s.&quot;,
                    group.name,
                    group.id,
                )
                return True
            else:
                msg = &quot;Failed to remove rule from security group {} with id {}.&quot;.format(
                    group.name, group.id
                )
                log.error(msg)
                return False
        except boto.exception.EC2ResponseError as e:
            msg = &quot;Failed to remove rule from security group {} with id {}.&quot;.format(
                group.name, group.id
            )
            log.error(msg)
            log.error(e)
            return False
    else:
        log.error(&quot;Failed to remove rule from security group.&quot;)
        return False


def _find_vpcs(
    vpc_id=None,
    vpc_name=None,
    cidr=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Given VPC properties, find and return matching VPC ids.
    Borrowed from boto_vpc; these could be refactored into a common library
    &quot;&quot;&quot;
    if all((vpc_id, vpc_name)):
        raise SaltInvocationError(&quot;Only one of vpc_name or vpc_id may be provided.&quot;)

    if not any((vpc_id, vpc_name, tags, cidr)):
        raise SaltInvocationError(
            &quot;At least one of the following must be &quot;
            &quot;provided: vpc_id, vpc_name, cidr or tags.&quot;
        )

    local_get_conn = __utils__[&quot;boto.get_connection_func&quot;](&quot;vpc&quot;)
    conn = local_get_conn(region=region, key=key, keyid=keyid, profile=profile)
    filter_parameters = {&quot;filters&quot;: {}}

    if vpc_id:
        filter_parameters[&quot;vpc_ids&quot;] = [vpc_id]

    if cidr:
        filter_parameters[&quot;filters&quot;][&quot;cidr&quot;] = cidr

    if vpc_name:
        filter_parameters[&quot;filters&quot;][&quot;tag:Name&quot;] = vpc_name

    if tags:
        for tag_name, tag_value in tags.items():
            filter_parameters[&quot;filters&quot;][&quot;tag:{}&quot;.format(tag_name)] = tag_value

    vpcs = conn.get_all_vpcs(**filter_parameters)
    log.debug(
        &quot;The filters criteria %s matched the following VPCs:%s&quot;, filter_parameters, vpcs
    )

    if vpcs:
        return [vpc.id for vpc in vpcs]
    else:
        return []


def set_tags(
    tags,
    name=None,
    group_id=None,
    vpc_name=None,
    vpc_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Sets tags on a security group.

    .. versionadded:: 2016.3.0

    tags
        a dict of key:value pair of tags to set on the security group

    name
        the name of the security group

    group_id
        the group id of the security group (in lie of a name/vpc combo)

    vpc_name
        the name of the vpc to search the named group for

    vpc_id
        the id of the vpc, in lieu of the vpc_name

    region
        the amazon region

    key
        amazon key

    keyid
        amazon keyid

    profile
        amazon profile

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.set_tags &quot;{'TAG1': 'Value1', 'TAG2': 'Value2'}&quot; security_group_name vpc_id=vpc-13435 profile=my_aws_profile
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    secgrp = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )

    if secgrp:
        if isinstance(tags, dict):
            secgrp.add_tags(tags)
        else:
            msg = &quot;Tags must be a dict of tagname:tagvalue&quot;
            raise SaltInvocationError(msg)
    else:
        msg = &quot;The security group could not be found&quot;
        raise SaltInvocationError(msg)
    return True


def delete_tags(
    tags,
    name=None,
    group_id=None,
    vpc_name=None,
    vpc_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Deletes tags from a security group.

    .. versionadded:: 2016.3.0

    tags
        a list of tags to remove

    name
        the name of the security group

    group_id
        the group id of the security group (in lie of a name/vpc combo)

    vpc_name
        the name of the vpc to search the named group for

    vpc_id
        the id of the vpc, in lieu of the vpc_name

    region
        the amazon region

    key
        amazon key

    keyid
        amazon keyid

    profile
        amazon profile

    CLI Example:

    .. code-block:: bash

        salt myminion boto_secgroup.delete_tags ['TAG_TO_DELETE1','TAG_TO_DELETE2'] security_group_name vpc_id=vpc-13435 profile=my_aws_profile
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    secgrp = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if secgrp:
        if isinstance(tags, list):
            tags_to_remove = {}
            for tag in tags:
                tags_to_remove[tag] = None
            secgrp.remove_tags(tags_to_remove)
        else:
            msg = &quot;Tags must be a list of tagnames to remove from the security group&quot;
            raise SaltInvocationError(msg)
    else:
        msg = &quot;The security group could not be found&quot;
        raise SaltInvocationError(msg)
    return True
</PRE>
</div>
  </div>
</body>
</html>
