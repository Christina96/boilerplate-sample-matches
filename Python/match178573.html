<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pillar_1.py &amp; boto_secgroup_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pillar_1.py &amp; boto_secgroup_1.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pillar_1.py (3.4482758%)<th>boto_secgroup_1.py (1.3348165%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(404-407)<td><a href="#" name="0">(144-147)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pillar_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import logging
import os
from collections.abc import Mapping
import salt.pillar
import salt.utils.crypt
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.functools
import salt.utils.odict
import salt.utils.yaml
from salt.defaults import DEFAULT_TARGET_DELIM
from salt.exceptions import CommandExecutionError
__proxyenabled__ = ["*"]
log = logging.getLogger(__name__)
def get(
    key,
    default=None,
    merge=False,
    merge_nested_lists=None,
    delimiter=DEFAULT_TARGET_DELIM,
    pillarenv=None,
    saltenv=None,
):
    if default is None:
        default = KeyError
    if not __opts__.get("pillar_raise_on_missing"):
        if default is KeyError:
            default = ""
    opt_merge_lists = (
        __opts__.get("pillar_merge_lists", False)
        if merge_nested_lists is None
        else merge_nested_lists
    )
    pillar_dict = (
        __pillar__
        if all(x is None for x in (saltenv, pillarenv))
        else items(saltenv=saltenv, pillarenv=pillarenv)
    )
    if merge:
        if isinstance(default, dict):
            ret = salt.utils.data.traverse_dict_and_list(
                pillar_dict, key, {}, delimiter
            )
            if isinstance(ret, Mapping):
                default = copy.deepcopy(default)
                return salt.utils.dictupdate.update(
                    default, ret, merge_lists=opt_merge_lists
                )
            else:
                log.error(
                    "pillar.get: Default (%s) is a dict, but the returned "
                    "pillar value (%s) is of type '%s'. Merge will be "
                    "skipped.",
                    default,
                    ret,
                    type(ret).__name__,
                )
        elif isinstance(default, list):
            ret = salt.utils.data.traverse_dict_and_list(
                pillar_dict, key, [], delimiter
            )
            if isinstance(ret, list):
                default = copy.deepcopy(default)
                default.extend([x for x in ret if x not in default])
                return default
            else:
                log.error(
                    "pillar.get: Default (%s) is a list, but the returned "
                    "pillar value (%s) is of type '%s'. Merge will be "
                    "skipped.",
                    default,
                    ret,
                    type(ret).__name__,
                )
        else:
            log.error(
                "pillar.get: Default (%s) is of type '%s', must be a dict "
                "or list to merge. Merge will be skipped.",
                default,
                type(default).__name__,
            )
    ret = salt.utils.data.traverse_dict_and_list(pillar_dict, key, default, delimiter)
    if ret is KeyError:
        raise KeyError("Pillar key not found: {}".format(key))
    return ret
def items(*args, **kwargs):
    if args:
        return item(*args)
    pillarenv = kwargs.get("pillarenv")
    if pillarenv is None:
        if __opts__.get("pillarenv_from_saltenv", False):
            pillarenv = kwargs.get("saltenv") or __opts__["saltenv"]
        else:
            pillarenv = __opts__["pillarenv"]
    pillar_override = kwargs.get("pillar")
    pillar_enc = kwargs.get("pillar_enc")
    if pillar_override and pillar_enc:
        try:
            pillar_override = salt.utils.crypt.decrypt(
                pillar_override,
                pillar_enc,
                translate_newlines=True,
                opts=__opts__,
                valid_rend=__opts__["decrypt_pillar_renderers"],
            )
        except Exception as exc:  # pylint: disable=broad-except
            raise CommandExecutionError(
                "Failed to decrypt pillar override: {}".format(exc)
            )
    pillar = salt.pillar.get_pillar(
        __opts__,
        dict(__grains__),
        __opts__["id"],
        pillar_override=pillar_override,
        pillarenv=pillarenv,
    )
    return pillar.compile_pillar()
data = salt.utils.functools.alias_function(items, "data")
def _obfuscate_inner(var):
    if isinstance(var, (dict, salt.utils.odict.OrderedDict)):
        return var.__class__((key, _obfuscate_inner(val)) for key, val in var.items())
    elif isinstance(var, (list, set, tuple)):
        return type(var)(_obfuscate_inner(v) for v in var)
    else:
        return "&lt;{}&gt;".format(var.__class__.__name__)
def obfuscate(*args):
    return _obfuscate_inner(items(*args))
def ls(*args):
    return list(items(*args))
def item(*args, **kwargs):
    ret = {}
    default <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= kwargs.get("default", "")
    delimiter = kwargs.get("delimiter", DEFAULT_TARGET_DELIM)
    pillarenv = kwargs.get("pillarenv", None)
    saltenv = kwargs.get(</b></font>"saltenv", None)
    pillar_dict = (
        __pillar__
        if all(x is None for x in (saltenv, pillarenv))
        else items(saltenv=saltenv, pillarenv=pillarenv)
    )
    try:
        for arg in args:
            ret[arg] = salt.utils.data.traverse_dict_and_list(
                pillar_dict, arg, default, delimiter
            )
    except KeyError:
        pass
    return ret
def raw(key=None):
    if key:
        ret = __pillar__.get(key, {})
    else:
        ret = dict(__pillar__)
    return ret
def ext(external, pillar=None):
    if isinstance(external, str):
        external = salt.utils.yaml.safe_load(external)
    pillar_obj = salt.pillar.get_pillar(
        __opts__,
        __grains__.value(),
        __opts__["id"],
        __opts__["saltenv"],
        ext=external,
        pillar_override=pillar,
    )
    ret = pillar_obj.compile_pillar()
    return ret
def keys(key, delimiter=DEFAULT_TARGET_DELIM):
    ret = salt.utils.data.traverse_dict_and_list(__pillar__, key, KeyError, delimiter)
    if ret is KeyError:
        raise KeyError("Pillar key not found: {}".format(key))
    if not isinstance(ret, dict):
        raise ValueError("Pillar value in key {} is not a dict".format(key))
    return list(ret)
def file_exists(path, saltenv=None):
    pillar_roots = __opts__.get("pillar_roots")
    if not pillar_roots:
        raise CommandExecutionError(
            "No pillar_roots found. Are you running this on the master?"
        )
    if saltenv:
        if saltenv in pillar_roots:
            pillar_roots = {saltenv: pillar_roots[saltenv]}
        else:
            return False
    for env in pillar_roots:
        for pillar_dir in pillar_roots[env]:
            full_path = os.path.join(pillar_dir, path)
            if __salt__["file.file_exists"](full_path):
                return True
    return False
fetch = get
def filter_by(lookup_dict, pillar, merge=None, default="default", base=None):
    return salt.utils.data.filter_by(
        lookup_dict=lookup_dict,
        lookup=pillar,
        traverse=__pillar__,
        merge=merge,
        default=default,
        base=base,
    )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_secgroup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import salt.utils.odict as odict
import salt.utils.versions
from salt.exceptions import CommandExecutionError, SaltInvocationError
log = logging.getLogger(__name__)
try:
    import boto
    import boto.ec2
    logging.getLogger("boto").setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
def __virtual__():
    has_boto_reqs = salt.utils.versions.check_boto_reqs(
        boto_ver="2.4.0", check_boto3=False
    )
    if has_boto_reqs is True:
        __utils__["boto.assign_funcs"](__name__, "ec2", pack=__salt__)
    return has_boto_reqs
def exists(
    name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
    group_id=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        return True
    else:
        return False
def _vpc_name_to_id(
    vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
):
    data = __salt__["boto_vpc.get_id"](
        name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
    )
    return data.get("id")
def _split_rules(rules):
        ip_protocol <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= rule.get("ip_protocol")
        to_port = rule.get("to_port")
        from_port = rule.get("from_port")
        grants = rule.get(</b></font>"grants")
        for grant in grants:
            _rule = {
                "ip_protocol": ip_protocol,
                "to_port": to_port,
                "from_port": from_port,
            }
            for key, val in grant.items():
                _rule[key] = val
            split.append(_rule)
    return split
def _get_group(
    conn=None,
    name=None,
    vpc_id=None,
    vpc_name=None,
    group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):  # pylint: disable=W0613
    if vpc_name and vpc_id:
        raise SaltInvocationError(
            "The params 'vpc_id' and 'vpc_name' are mutually exclusive."
        )
    if vpc_name:
        try:
            vpc_id = _vpc_name_to_id(
                vpc_id=vpc_id,
                vpc_name=vpc_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        except boto.exception.BotoServerError as e:
            log.debug(e)
            return None
    if name:
        if vpc_id is None:
            log.debug("getting group for %s", name)
            group_filter = {"group-name": name}
            filtered_groups = conn.get_all_security_groups(filters=group_filter)
            for group in filtered_groups:
                if group.vpc_id is None:
                    return group
            if len(filtered_groups) &gt; 1:
                raise CommandExecutionError(
                    "Security group belongs to more VPCs, specify the VPC ID!"
                )
            elif len(filtered_groups) == 1:
                return filtered_groups[0]
            return None
        elif vpc_id:
            log.debug("getting group for %s in vpc_id %s", name, vpc_id)
            group_filter = {"group-name": name, "vpc_id": vpc_id}
            filtered_groups = conn.get_all_security_groups(filters=group_filter)
            if len(filtered_groups) == 1:
                return filtered_groups[0]
            else:
                return None
        else:
            return None
    elif group_id:
        try:
            groups = conn.get_all_security_groups(group_ids=[group_id])
        except boto.exception.BotoServerError as e:
            log.debug(e)
            return None
        if len(groups) == 1:
            return groups[0]
        else:
            return None
    else:
        return None
def _parse_rules(sg, rules):
    _rules = []
    for rule in rules:
        log.debug("examining rule %s for group %s", rule, sg.id)
        attrs = ["ip_protocol", "from_port", "to_port", "grants"]
        _rule = odict.OrderedDict()
        for attr in attrs:
            val = getattr(rule, attr)
            if not val:
                continue
            if attr == "grants":
                _grants = []
                for grant in val:
                    log.debug("examining grant %s for", grant)
                    g_attrs = {
                        "name": "source_group_name",
                        "owner_id": "source_group_owner_id",
                        "group_id": "source_group_group_id",
                        "cidr_ip": "cidr_ip",
                    }
                    _grant = odict.OrderedDict()
                    for g_attr, g_attr_map in g_attrs.items():
                        g_val = getattr(grant, g_attr)
                        if not g_val:
                            continue
                        _grant[g_attr_map] = g_val
                    _grants.append(_grant)
                _rule["grants"] = _grants
            elif attr == "from_port":
                _rule[attr] = int(val)
            elif attr == "to_port":
                _rule[attr] = int(val)
            else:
                _rule[attr] = val
        _rules.append(_rule)
    return _rules
def get_all_security_groups(
    groupnames=None,
    group_ids=None,
    filters=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    if isinstance(groupnames, str):
        groupnames = [groupnames]
    if isinstance(group_ids, str):
        groupnames = [group_ids]
    interesting = [
        "description",
        "id",
        "instances",
        "name",
        "owner_id",
        "region",
        "rules",
        "rules_egress",
        "tags",
        "vpc_id",
    ]
    ret = []
    try:
        r = conn.get_all_security_groups(
            groupnames=groupnames, group_ids=group_ids, filters=filters
        )
        for g in r:
            n = {}
            for a in interesting:
                v = getattr(g, a, None)
                if a == "region":
                    v = v.name
                elif a in ("rules", "rules_egress"):
                    v = _parse_rules(g, v)
                elif a == "instances":
                    v = [i.id for i in v()]
                n[a] = v
            ret += [n]
        return ret
    except boto.exception.BotoServerError as e:
        log.debug(e)
        return []
def get_group_id(
    name, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    if name.startswith("sg-"):
        log.debug("group %s is a group id. get_group_id not called.", name)
        return name
    group = _get_group(
        conn=conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    return getattr(group, "id", None)
def convert_to_group_ids(
    groups, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
):
    log.debug("security group contents %s pre-conversion", groups)
    group_ids = []
    for group in groups:
        group_id = get_group_id(
            name=group,
            vpc_id=vpc_id,
            vpc_name=vpc_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not group_id:
            if __opts__["test"]:
                log.warn(
                    "Security Group `%s` could not be resolved to an ID.  This may "
                    "cause a failure when not running in test mode.",
                    group,
                )
                return []
            else:
                raise CommandExecutionError(
                    "Could not resolve Security Group name {} to a Group ID".format(
                        group
                    )
                )
        else:
            group_ids.append(str(group_id))
    log.debug("security group contents %s post-conversion", group_ids)
    return group_ids
def get_config(
    name=None,
    group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    sg = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if sg:
        ret = odict.OrderedDict()
        ret["name"] = sg.name
        ret["group_id"] = sg.id
        ret["owner_id"] = sg.owner_id
        ret["description"] = sg.description
        ret["tags"] = sg.tags
        _rules = _parse_rules(sg, sg.rules)
        _rules_egress = _parse_rules(sg, sg.rules_egress)
        ret["rules"] = _split_rules(_rules)
        ret["rules_egress"] = _split_rules(_rules_egress)
        return ret
    else:
        return None
def create(
    name,
    description,
    vpc_id=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    if not vpc_id and vpc_name:
        try:
            vpc_id = _vpc_name_to_id(
                vpc_id=vpc_id,
                vpc_name=vpc_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        except boto.exception.BotoServerError as e:
            log.debug(e)
            return False
    created = conn.create_security_group(name, description, vpc_id)
    if created:
        log.info("Created security group %s.", name)
        return True
    else:
        msg = "Failed to create security group {}.".format(name)
        log.error(msg)
        return False
def delete(
    name=None,
    group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        deleted = conn.delete_security_group(group_id=group.id)
        if deleted:
            log.info("Deleted security group %s with id %s.", group.name, group.id)
            return True
        else:
            msg = "Failed to delete security group {}.".format(name)
            log.error(msg)
            return False
    else:
        log.debug("Security group not found.")
        return False
def authorize(
    name=None,
    source_group_name=None,
    source_group_owner_id=None,
    ip_protocol=None,
    from_port=None,
    to_port=None,
    cidr_ip=None,
    group_id=None,
    source_group_group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
    egress=False,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        try:
            added = None
            if not egress:
                added = conn.authorize_security_group(
                    src_security_group_name=source_group_name,
                    src_security_group_owner_id=source_group_owner_id,
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_security_group_group_id=source_group_group_id,
                )
            else:
                added = conn.authorize_security_group_egress(
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_group_id=source_group_group_id,
                )
            if added:
                log.info(
                    "Added rule to security group %s with id %s", group.name, group.id
                )
                return True
            else:
                msg = "Failed to add rule to security group {} with id {}.".format(
                    group.name, group.id
                )
                log.error(msg)
                return False
        except boto.exception.EC2ResponseError as e:
            if e.error_code == "InvalidPermission.Duplicate":
                return True
            msg = "Failed to add rule to security group {} with id {}.".format(
                group.name, group.id
            )
            log.error(msg)
            log.error(e)
            return False
    else:
        log.error("Failed to add rule to security group.")
        return False
def revoke(
    name=None,
    source_group_name=None,
    source_group_owner_id=None,
    ip_protocol=None,
    from_port=None,
    to_port=None,
    cidr_ip=None,
    group_id=None,
    source_group_group_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_id=None,
    vpc_name=None,
    egress=False,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    group = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if group:
        try:
            revoked = None
            if not egress:
                revoked = conn.revoke_security_group(
                    src_security_group_name=source_group_name,
                    src_security_group_owner_id=source_group_owner_id,
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_security_group_group_id=source_group_group_id,
                )
            else:
                revoked = conn.revoke_security_group_egress(
                    ip_protocol=ip_protocol,
                    from_port=from_port,
                    to_port=to_port,
                    cidr_ip=cidr_ip,
                    group_id=group.id,
                    src_group_id=source_group_group_id,
                )
            if revoked:
                log.info(
                    "Removed rule from security group %s with id %s.",
                    group.name,
                    group.id,
                )
                return True
            else:
                msg = "Failed to remove rule from security group {} with id {}.".format(
                    group.name, group.id
                )
                log.error(msg)
                return False
        except boto.exception.EC2ResponseError as e:
            msg = "Failed to remove rule from security group {} with id {}.".format(
                group.name, group.id
            )
            log.error(msg)
            log.error(e)
            return False
    else:
        log.error("Failed to remove rule from security group.")
        return False
def _find_vpcs(
    vpc_id=None,
    vpc_name=None,
    cidr=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if all((vpc_id, vpc_name)):
        raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
    if not any((vpc_id, vpc_name, tags, cidr)):
        raise SaltInvocationError(
            "At least one of the following must be "
            "provided: vpc_id, vpc_name, cidr or tags."
        )
    local_get_conn = __utils__["boto.get_connection_func"]("vpc")
    conn = local_get_conn(region=region, key=key, keyid=keyid, profile=profile)
    filter_parameters = {"filters": {}}
    if vpc_id:
        filter_parameters["vpc_ids"] = [vpc_id]
    if cidr:
        filter_parameters["filters"]["cidr"] = cidr
    if vpc_name:
        filter_parameters["filters"]["tag:Name"] = vpc_name
    if tags:
        for tag_name, tag_value in tags.items():
            filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
    vpcs = conn.get_all_vpcs(**filter_parameters)
    log.debug(
        "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
    )
    if vpcs:
        return [vpc.id for vpc in vpcs]
    else:
        return []
def set_tags(
    tags,
    name=None,
    group_id=None,
    vpc_name=None,
    vpc_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    secgrp = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if secgrp:
        if isinstance(tags, dict):
            secgrp.add_tags(tags)
        else:
            msg = "Tags must be a dict of tagname:tagvalue"
            raise SaltInvocationError(msg)
    else:
        msg = "The security group could not be found"
        raise SaltInvocationError(msg)
    return True
def delete_tags(
    tags,
    name=None,
    group_id=None,
    vpc_name=None,
    vpc_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    secgrp = _get_group(
        conn,
        name=name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        group_id=group_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if secgrp:
        if isinstance(tags, list):
            tags_to_remove = {}
            for tag in tags:
                tags_to_remove[tag] = None
            secgrp.remove_tags(tags_to_remove)
        else:
            msg = "Tags must be a list of tagnames to remove from the security group"
            raise SaltInvocationError(msg)
    else:
        msg = "The security group could not be found"
        raise SaltInvocationError(msg)
    return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
