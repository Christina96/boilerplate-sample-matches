<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pillar_1.py &amp; boto_secgroup_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pillar_1.py &amp; boto_secgroup_1.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pillar_1.py (3.4482758%)<th>boto_secgroup_1.py (1.3348165%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(404-407)<td><a href="#" name="0">(144-147)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pillar_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import os
4 from collections.abc import Mapping
5 import salt.pillar
6 import salt.utils.crypt
7 import salt.utils.data
8 import salt.utils.dictupdate
9 import salt.utils.functools
10 import salt.utils.odict
11 import salt.utils.yaml
12 from salt.defaults import DEFAULT_TARGET_DELIM
13 from salt.exceptions import CommandExecutionError
14 __proxyenabled__ = ["*"]
15 log = logging.getLogger(__name__)
16 def get(
17     key,
18     default=None,
19     merge=False,
20     merge_nested_lists=None,
21     delimiter=DEFAULT_TARGET_DELIM,
22     pillarenv=None,
23     saltenv=None,
24 ):
25     if default is None:
26         default = KeyError
27     if not __opts__.get("pillar_raise_on_missing"):
28         if default is KeyError:
29             default = ""
30     opt_merge_lists = (
31         __opts__.get("pillar_merge_lists", False)
32         if merge_nested_lists is None
33         else merge_nested_lists
34     )
35     pillar_dict = (
36         __pillar__
37         if all(x is None for x in (saltenv, pillarenv))
38         else items(saltenv=saltenv, pillarenv=pillarenv)
39     )
40     if merge:
41         if isinstance(default, dict):
42             ret = salt.utils.data.traverse_dict_and_list(
43                 pillar_dict, key, {}, delimiter
44             )
45             if isinstance(ret, Mapping):
46                 default = copy.deepcopy(default)
47                 return salt.utils.dictupdate.update(
48                     default, ret, merge_lists=opt_merge_lists
49                 )
50             else:
51                 log.error(
52                     "pillar.get: Default (%s) is a dict, but the returned "
53                     "pillar value (%s) is of type '%s'. Merge will be "
54                     "skipped.",
55                     default,
56                     ret,
57                     type(ret).__name__,
58                 )
59         elif isinstance(default, list):
60             ret = salt.utils.data.traverse_dict_and_list(
61                 pillar_dict, key, [], delimiter
62             )
63             if isinstance(ret, list):
64                 default = copy.deepcopy(default)
65                 default.extend([x for x in ret if x not in default])
66                 return default
67             else:
68                 log.error(
69                     "pillar.get: Default (%s) is a list, but the returned "
70                     "pillar value (%s) is of type '%s'. Merge will be "
71                     "skipped.",
72                     default,
73                     ret,
74                     type(ret).__name__,
75                 )
76         else:
77             log.error(
78                 "pillar.get: Default (%s) is of type '%s', must be a dict "
79                 "or list to merge. Merge will be skipped.",
80                 default,
81                 type(default).__name__,
82             )
83     ret = salt.utils.data.traverse_dict_and_list(pillar_dict, key, default, delimiter)
84     if ret is KeyError:
85         raise KeyError("Pillar key not found: {}".format(key))
86     return ret
87 def items(*args, **kwargs):
88     if args:
89         return item(*args)
90     pillarenv = kwargs.get("pillarenv")
91     if pillarenv is None:
92         if __opts__.get("pillarenv_from_saltenv", False):
93             pillarenv = kwargs.get("saltenv") or __opts__["saltenv"]
94         else:
95             pillarenv = __opts__["pillarenv"]
96     pillar_override = kwargs.get("pillar")
97     pillar_enc = kwargs.get("pillar_enc")
98     if pillar_override and pillar_enc:
99         try:
100             pillar_override = salt.utils.crypt.decrypt(
101                 pillar_override,
102                 pillar_enc,
103                 translate_newlines=True,
104                 opts=__opts__,
105                 valid_rend=__opts__["decrypt_pillar_renderers"],
106             )
107         except Exception as exc:  # pylint: disable=broad-except
108             raise CommandExecutionError(
109                 "Failed to decrypt pillar override: {}".format(exc)
110             )
111     pillar = salt.pillar.get_pillar(
112         __opts__,
113         dict(__grains__),
114         __opts__["id"],
115         pillar_override=pillar_override,
116         pillarenv=pillarenv,
117     )
118     return pillar.compile_pillar()
119 data = salt.utils.functools.alias_function(items, "data")
120 def _obfuscate_inner(var):
121     if isinstance(var, (dict, salt.utils.odict.OrderedDict)):
122         return var.__class__((key, _obfuscate_inner(val)) for key, val in var.items())
123     elif isinstance(var, (list, set, tuple)):
124         return type(var)(_obfuscate_inner(v) for v in var)
125     else:
126         return "&lt;{}&gt;".format(var.__class__.__name__)
127 def obfuscate(*args):
128     return _obfuscate_inner(items(*args))
129 def ls(*args):
130     return list(items(*args))
131 def item(*args, **kwargs):
132     ret = {}
133     default <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= kwargs.get("default", "")
134     delimiter = kwargs.get("delimiter", DEFAULT_TARGET_DELIM)
135     pillarenv = kwargs.get("pillarenv", None)
136     saltenv = kwargs.get(</b></font>"saltenv", None)
137     pillar_dict = (
138         __pillar__
139         if all(x is None for x in (saltenv, pillarenv))
140         else items(saltenv=saltenv, pillarenv=pillarenv)
141     )
142     try:
143         for arg in args:
144             ret[arg] = salt.utils.data.traverse_dict_and_list(
145                 pillar_dict, arg, default, delimiter
146             )
147     except KeyError:
148         pass
149     return ret
150 def raw(key=None):
151     if key:
152         ret = __pillar__.get(key, {})
153     else:
154         ret = dict(__pillar__)
155     return ret
156 def ext(external, pillar=None):
157     if isinstance(external, str):
158         external = salt.utils.yaml.safe_load(external)
159     pillar_obj = salt.pillar.get_pillar(
160         __opts__,
161         __grains__.value(),
162         __opts__["id"],
163         __opts__["saltenv"],
164         ext=external,
165         pillar_override=pillar,
166     )
167     ret = pillar_obj.compile_pillar()
168     return ret
169 def keys(key, delimiter=DEFAULT_TARGET_DELIM):
170     ret = salt.utils.data.traverse_dict_and_list(__pillar__, key, KeyError, delimiter)
171     if ret is KeyError:
172         raise KeyError("Pillar key not found: {}".format(key))
173     if not isinstance(ret, dict):
174         raise ValueError("Pillar value in key {} is not a dict".format(key))
175     return list(ret)
176 def file_exists(path, saltenv=None):
177     pillar_roots = __opts__.get("pillar_roots")
178     if not pillar_roots:
179         raise CommandExecutionError(
180             "No pillar_roots found. Are you running this on the master?"
181         )
182     if saltenv:
183         if saltenv in pillar_roots:
184             pillar_roots = {saltenv: pillar_roots[saltenv]}
185         else:
186             return False
187     for env in pillar_roots:
188         for pillar_dir in pillar_roots[env]:
189             full_path = os.path.join(pillar_dir, path)
190             if __salt__["file.file_exists"](full_path):
191                 return True
192     return False
193 fetch = get
194 def filter_by(lookup_dict, pillar, merge=None, default="default", base=None):
195     return salt.utils.data.filter_by(
196         lookup_dict=lookup_dict,
197         lookup=pillar,
198         traverse=__pillar__,
199         merge=merge,
200         default=default,
201         base=base,
202     )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_secgroup_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.odict as odict
3 import salt.utils.versions
4 from salt.exceptions import CommandExecutionError, SaltInvocationError
5 log = logging.getLogger(__name__)
6 try:
7     import boto
8     import boto.ec2
9     logging.getLogger("boto").setLevel(logging.CRITICAL)
10     HAS_BOTO = True
11 except ImportError:
12     HAS_BOTO = False
13 def __virtual__():
14     has_boto_reqs = salt.utils.versions.check_boto_reqs(
15         boto_ver="2.4.0", check_boto3=False
16     )
17     if has_boto_reqs is True:
18         __utils__["boto.assign_funcs"](__name__, "ec2", pack=__salt__)
19     return has_boto_reqs
20 def exists(
21     name=None,
22     region=None,
23     key=None,
24     keyid=None,
25     profile=None,
26     vpc_id=None,
27     vpc_name=None,
28     group_id=None,
29 ):
30     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
31     group = _get_group(
32         conn,
33         name=name,
34         vpc_id=vpc_id,
35         vpc_name=vpc_name,
36         group_id=group_id,
37         region=region,
38         key=key,
39         keyid=keyid,
40         profile=profile,
41     )
42     if group:
43         return True
44     else:
45         return False
46 def _vpc_name_to_id(
47     vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
48 ):
49     data = __salt__["boto_vpc.get_id"](
50         name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
51     )
52     return data.get("id")
53 def _split_rules(rules):
54     """
55         ip_protocol <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= rule.get("ip_protocol")
56         to_port = rule.get("to_port")
57         from_port = rule.get("from_port")
58         grants = rule.get(</b></font>"grants")
59         for grant in grants:
60             _rule = {
61                 "ip_protocol": ip_protocol,
62                 "to_port": to_port,
63                 "from_port": from_port,
64             }
65             for key, val in grant.items():
66                 _rule[key] = val
67             split.append(_rule)
68     return split
69 def _get_group(
70     conn=None,
71     name=None,
72     vpc_id=None,
73     vpc_name=None,
74     group_id=None,
75     region=None,
76     key=None,
77     keyid=None,
78     profile=None,
79 ):  # pylint: disable=W0613
80     """
81     Get a group object given a name, name and vpc_id/vpc_name or group_id. Return
82     a boto.ec2.securitygroup.SecurityGroup object if the group is found, else
83     return None.
84     """
85     if vpc_name and vpc_id:
86         raise SaltInvocationError(
87             "The params 'vpc_id' and 'vpc_name' are mutually exclusive."
88         )
89     if vpc_name:
90         try:
91             vpc_id = _vpc_name_to_id(
92                 vpc_id=vpc_id,
93                 vpc_name=vpc_name,
94                 region=region,
95                 key=key,
96                 keyid=keyid,
97                 profile=profile,
98             )
99         except boto.exception.BotoServerError as e:
100             log.debug(e)
101             return None
102     if name:
103         if vpc_id is None:
104             log.debug("getting group for %s", name)
105             group_filter = {"group-name": name}
106             filtered_groups = conn.get_all_security_groups(filters=group_filter)
107             for group in filtered_groups:
108                 if group.vpc_id is None:
109                     return group
110             if len(filtered_groups) &gt; 1:
111                 raise CommandExecutionError(
112                     "Security group belongs to more VPCs, specify the VPC ID!"
113                 )
114             elif len(filtered_groups) == 1:
115                 return filtered_groups[0]
116             return None
117         elif vpc_id:
118             log.debug("getting group for %s in vpc_id %s", name, vpc_id)
119             group_filter = {"group-name": name, "vpc_id": vpc_id}
120             filtered_groups = conn.get_all_security_groups(filters=group_filter)
121             if len(filtered_groups) == 1:
122                 return filtered_groups[0]
123             else:
124                 return None
125         else:
126             return None
127     elif group_id:
128         try:
129             groups = conn.get_all_security_groups(group_ids=[group_id])
130         except boto.exception.BotoServerError as e:
131             log.debug(e)
132             return None
133         if len(groups) == 1:
134             return groups[0]
135         else:
136             return None
137     else:
138         return None
139 def _parse_rules(sg, rules):
140     _rules = []
141     for rule in rules:
142         log.debug("examining rule %s for group %s", rule, sg.id)
143         attrs = ["ip_protocol", "from_port", "to_port", "grants"]
144         _rule = odict.OrderedDict()
145         for attr in attrs:
146             val = getattr(rule, attr)
147             if not val:
148                 continue
149             if attr == "grants":
150                 _grants = []
151                 for grant in val:
152                     log.debug("examining grant %s for", grant)
153                     g_attrs = {
154                         "name": "source_group_name",
155                         "owner_id": "source_group_owner_id",
156                         "group_id": "source_group_group_id",
157                         "cidr_ip": "cidr_ip",
158                     }
159                     _grant = odict.OrderedDict()
160                     for g_attr, g_attr_map in g_attrs.items():
161                         g_val = getattr(grant, g_attr)
162                         if not g_val:
163                             continue
164                         _grant[g_attr_map] = g_val
165                     _grants.append(_grant)
166                 _rule["grants"] = _grants
167             elif attr == "from_port":
168                 _rule[attr] = int(val)
169             elif attr == "to_port":
170                 _rule[attr] = int(val)
171             else:
172                 _rule[attr] = val
173         _rules.append(_rule)
174     return _rules
175 def get_all_security_groups(
176     groupnames=None,
177     group_ids=None,
178     filters=None,
179     region=None,
180     key=None,
181     keyid=None,
182     profile=None,
183 ):
184     """
185     Return a list of all Security Groups matching the given criteria and
186     filters.
187     Note that the ``groupnames`` argument only functions correctly for EC2
188     Classic and default VPC Security Groups.  To find groups by name in other
189     VPCs you'll want to use the ``group-name`` filter instead.
190     The valid keys for the ``filters`` argument can be found in `AWS's API
191     documentation
192     &lt;https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeSecurityGroups.html&gt;`_.
193     CLI Example:
194     .. code-block:: bash
195         salt myminion boto_secgroup.get_all_security_groups filters='{group-name: mygroup}'
196     """
197     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
198     if isinstance(groupnames, str):
199         groupnames = [groupnames]
200     if isinstance(group_ids, str):
201         groupnames = [group_ids]
202     interesting = [
203         "description",
204         "id",
205         "instances",
206         "name",
207         "owner_id",
208         "region",
209         "rules",
210         "rules_egress",
211         "tags",
212         "vpc_id",
213     ]
214     ret = []
215     try:
216         r = conn.get_all_security_groups(
217             groupnames=groupnames, group_ids=group_ids, filters=filters
218         )
219         for g in r:
220             n = {}
221             for a in interesting:
222                 v = getattr(g, a, None)
223                 if a == "region":
224                     v = v.name
225                 elif a in ("rules", "rules_egress"):
226                     v = _parse_rules(g, v)
227                 elif a == "instances":
228                     v = [i.id for i in v()]
229                 n[a] = v
230             ret += [n]
231         return ret
232     except boto.exception.BotoServerError as e:
233         log.debug(e)
234         return []
235 def get_group_id(
236     name, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
237 ):
238     """
239     Get a Group ID given a Group Name or Group Name and VPC ID
240     CLI Example:
241     .. code-block:: bash
242         salt myminion boto_secgroup.get_group_id mysecgroup
243     """
244     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
245     if name.startswith("sg-"):
246         log.debug("group %s is a group id. get_group_id not called.", name)
247         return name
248     group = _get_group(
249         conn=conn,
250         name=name,
251         vpc_id=vpc_id,
252         vpc_name=vpc_name,
253         region=region,
254         key=key,
255         keyid=keyid,
256         profile=profile,
257     )
258     return getattr(group, "id", None)
259 def convert_to_group_ids(
260     groups, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
261 ):
262     """
263     Given a list of security groups and a vpc_id, convert_to_group_ids will
264     convert all list items in the given list to security group ids.
265     CLI Example:
266     .. code-block:: bash
267         salt myminion boto_secgroup.convert_to_group_ids mysecgroup vpc-89yhh7h
268     """
269     log.debug("security group contents %s pre-conversion", groups)
270     group_ids = []
271     for group in groups:
272         group_id = get_group_id(
273             name=group,
274             vpc_id=vpc_id,
275             vpc_name=vpc_name,
276             region=region,
277             key=key,
278             keyid=keyid,
279             profile=profile,
280         )
281         if not group_id:
282             if __opts__["test"]:
283                 log.warn(
284                     "Security Group `%s` could not be resolved to an ID.  This may "
285                     "cause a failure when not running in test mode.",
286                     group,
287                 )
288                 return []
289             else:
290                 raise CommandExecutionError(
291                     "Could not resolve Security Group name {} to a Group ID".format(
292                         group
293                     )
294                 )
295         else:
296             group_ids.append(str(group_id))
297     log.debug("security group contents %s post-conversion", group_ids)
298     return group_ids
299 def get_config(
300     name=None,
301     group_id=None,
302     region=None,
303     key=None,
304     keyid=None,
305     profile=None,
306     vpc_id=None,
307     vpc_name=None,
308 ):
309     """
310     Get the configuration for a security group.
311     CLI Example:
312     .. code-block:: bash
313         salt myminion boto_secgroup.get_config mysecgroup
314     """
315     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
316     sg = _get_group(
317         conn,
318         name=name,
319         vpc_id=vpc_id,
320         vpc_name=vpc_name,
321         group_id=group_id,
322         region=region,
323         key=key,
324         keyid=keyid,
325         profile=profile,
326     )
327     if sg:
328         ret = odict.OrderedDict()
329         ret["name"] = sg.name
330         ret["group_id"] = sg.id
331         ret["owner_id"] = sg.owner_id
332         ret["description"] = sg.description
333         ret["tags"] = sg.tags
334         _rules = _parse_rules(sg, sg.rules)
335         _rules_egress = _parse_rules(sg, sg.rules_egress)
336         ret["rules"] = _split_rules(_rules)
337         ret["rules_egress"] = _split_rules(_rules_egress)
338         return ret
339     else:
340         return None
341 def create(
342     name,
343     description,
344     vpc_id=None,
345     vpc_name=None,
346     region=None,
347     key=None,
348     keyid=None,
349     profile=None,
350 ):
351     """
352     Create a security group.
353     CLI Example:
354     .. code-block:: bash
355         salt myminion boto_secgroup.create mysecgroup 'My Security Group'
356     """
357     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
358     if not vpc_id and vpc_name:
359         try:
360             vpc_id = _vpc_name_to_id(
361                 vpc_id=vpc_id,
362                 vpc_name=vpc_name,
363                 region=region,
364                 key=key,
365                 keyid=keyid,
366                 profile=profile,
367             )
368         except boto.exception.BotoServerError as e:
369             log.debug(e)
370             return False
371     created = conn.create_security_group(name, description, vpc_id)
372     if created:
373         log.info("Created security group %s.", name)
374         return True
375     else:
376         msg = "Failed to create security group {}.".format(name)
377         log.error(msg)
378         return False
379 def delete(
380     name=None,
381     group_id=None,
382     region=None,
383     key=None,
384     keyid=None,
385     profile=None,
386     vpc_id=None,
387     vpc_name=None,
388 ):
389     """
390     Delete a security group.
391     CLI Example:
392     .. code-block:: bash
393         salt myminion boto_secgroup.delete mysecgroup
394     """
395     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
396     group = _get_group(
397         conn,
398         name=name,
399         vpc_id=vpc_id,
400         vpc_name=vpc_name,
401         group_id=group_id,
402         region=region,
403         key=key,
404         keyid=keyid,
405         profile=profile,
406     )
407     if group:
408         deleted = conn.delete_security_group(group_id=group.id)
409         if deleted:
410             log.info("Deleted security group %s with id %s.", group.name, group.id)
411             return True
412         else:
413             msg = "Failed to delete security group {}.".format(name)
414             log.error(msg)
415             return False
416     else:
417         log.debug("Security group not found.")
418         return False
419 def authorize(
420     name=None,
421     source_group_name=None,
422     source_group_owner_id=None,
423     ip_protocol=None,
424     from_port=None,
425     to_port=None,
426     cidr_ip=None,
427     group_id=None,
428     source_group_group_id=None,
429     region=None,
430     key=None,
431     keyid=None,
432     profile=None,
433     vpc_id=None,
434     vpc_name=None,
435     egress=False,
436 ):
437     """
438     Add a new rule to an existing security group.
439     CLI Example:
440     .. code-block:: bash
441         salt myminion boto_secgroup.authorize mysecgroup ip_protocol=tcp from_port=80 to_port=80 cidr_ip='['10.0.0.0/8', '192.168.0.0/24']'
442     """
443     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
444     group = _get_group(
445         conn,
446         name=name,
447         vpc_id=vpc_id,
448         vpc_name=vpc_name,
449         group_id=group_id,
450         region=region,
451         key=key,
452         keyid=keyid,
453         profile=profile,
454     )
455     if group:
456         try:
457             added = None
458             if not egress:
459                 added = conn.authorize_security_group(
460                     src_security_group_name=source_group_name,
461                     src_security_group_owner_id=source_group_owner_id,
462                     ip_protocol=ip_protocol,
463                     from_port=from_port,
464                     to_port=to_port,
465                     cidr_ip=cidr_ip,
466                     group_id=group.id,
467                     src_security_group_group_id=source_group_group_id,
468                 )
469             else:
470                 added = conn.authorize_security_group_egress(
471                     ip_protocol=ip_protocol,
472                     from_port=from_port,
473                     to_port=to_port,
474                     cidr_ip=cidr_ip,
475                     group_id=group.id,
476                     src_group_id=source_group_group_id,
477                 )
478             if added:
479                 log.info(
480                     "Added rule to security group %s with id %s", group.name, group.id
481                 )
482                 return True
483             else:
484                 msg = "Failed to add rule to security group {} with id {}.".format(
485                     group.name, group.id
486                 )
487                 log.error(msg)
488                 return False
489         except boto.exception.EC2ResponseError as e:
490             if e.error_code == "InvalidPermission.Duplicate":
491                 return True
492             msg = "Failed to add rule to security group {} with id {}.".format(
493                 group.name, group.id
494             )
495             log.error(msg)
496             log.error(e)
497             return False
498     else:
499         log.error("Failed to add rule to security group.")
500         return False
501 def revoke(
502     name=None,
503     source_group_name=None,
504     source_group_owner_id=None,
505     ip_protocol=None,
506     from_port=None,
507     to_port=None,
508     cidr_ip=None,
509     group_id=None,
510     source_group_group_id=None,
511     region=None,
512     key=None,
513     keyid=None,
514     profile=None,
515     vpc_id=None,
516     vpc_name=None,
517     egress=False,
518 ):
519     """
520     Remove a rule from an existing security group.
521     CLI Example:
522     .. code-block:: bash
523         salt myminion boto_secgroup.revoke mysecgroup ip_protocol=tcp from_port=80 to_port=80 cidr_ip='10.0.0.0/8'
524     """
525     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
526     group = _get_group(
527         conn,
528         name=name,
529         vpc_id=vpc_id,
530         vpc_name=vpc_name,
531         group_id=group_id,
532         region=region,
533         key=key,
534         keyid=keyid,
535         profile=profile,
536     )
537     if group:
538         try:
539             revoked = None
540             if not egress:
541                 revoked = conn.revoke_security_group(
542                     src_security_group_name=source_group_name,
543                     src_security_group_owner_id=source_group_owner_id,
544                     ip_protocol=ip_protocol,
545                     from_port=from_port,
546                     to_port=to_port,
547                     cidr_ip=cidr_ip,
548                     group_id=group.id,
549                     src_security_group_group_id=source_group_group_id,
550                 )
551             else:
552                 revoked = conn.revoke_security_group_egress(
553                     ip_protocol=ip_protocol,
554                     from_port=from_port,
555                     to_port=to_port,
556                     cidr_ip=cidr_ip,
557                     group_id=group.id,
558                     src_group_id=source_group_group_id,
559                 )
560             if revoked:
561                 log.info(
562                     "Removed rule from security group %s with id %s.",
563                     group.name,
564                     group.id,
565                 )
566                 return True
567             else:
568                 msg = "Failed to remove rule from security group {} with id {}.".format(
569                     group.name, group.id
570                 )
571                 log.error(msg)
572                 return False
573         except boto.exception.EC2ResponseError as e:
574             msg = "Failed to remove rule from security group {} with id {}.".format(
575                 group.name, group.id
576             )
577             log.error(msg)
578             log.error(e)
579             return False
580     else:
581         log.error("Failed to remove rule from security group.")
582         return False
583 def _find_vpcs(
584     vpc_id=None,
585     vpc_name=None,
586     cidr=None,
587     tags=None,
588     region=None,
589     key=None,
590     keyid=None,
591     profile=None,
592 ):
593     """
594     Given VPC properties, find and return matching VPC ids.
595     Borrowed from boto_vpc; these could be refactored into a common library
596     """
597     if all((vpc_id, vpc_name)):
598         raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
599     if not any((vpc_id, vpc_name, tags, cidr)):
600         raise SaltInvocationError(
601             "At least one of the following must be "
602             "provided: vpc_id, vpc_name, cidr or tags."
603         )
604     local_get_conn = __utils__["boto.get_connection_func"]("vpc")
605     conn = local_get_conn(region=region, key=key, keyid=keyid, profile=profile)
606     filter_parameters = {"filters": {}}
607     if vpc_id:
608         filter_parameters["vpc_ids"] = [vpc_id]
609     if cidr:
610         filter_parameters["filters"]["cidr"] = cidr
611     if vpc_name:
612         filter_parameters["filters"]["tag:Name"] = vpc_name
613     if tags:
614         for tag_name, tag_value in tags.items():
615             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
616     vpcs = conn.get_all_vpcs(**filter_parameters)
617     log.debug(
618         "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
619     )
620     if vpcs:
621         return [vpc.id for vpc in vpcs]
622     else:
623         return []
624 def set_tags(
625     tags,
626     name=None,
627     group_id=None,
628     vpc_name=None,
629     vpc_id=None,
630     region=None,
631     key=None,
632     keyid=None,
633     profile=None,
634 ):
635     """
636     Sets tags on a security group.
637     .. versionadded:: 2016.3.0
638     tags
639         a dict of key:value pair of tags to set on the security group
640     name
641         the name of the security group
642     group_id
643         the group id of the security group (in lie of a name/vpc combo)
644     vpc_name
645         the name of the vpc to search the named group for
646     vpc_id
647         the id of the vpc, in lieu of the vpc_name
648     region
649         the amazon region
650     key
651         amazon key
652     keyid
653         amazon keyid
654     profile
655         amazon profile
656     CLI Example:
657     .. code-block:: bash
658         salt myminion boto_secgroup.set_tags "{'TAG1': 'Value1', 'TAG2': 'Value2'}" security_group_name vpc_id=vpc-13435 profile=my_aws_profile
659     """
660     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
661     secgrp = _get_group(
662         conn,
663         name=name,
664         vpc_id=vpc_id,
665         vpc_name=vpc_name,
666         group_id=group_id,
667         region=region,
668         key=key,
669         keyid=keyid,
670         profile=profile,
671     )
672     if secgrp:
673         if isinstance(tags, dict):
674             secgrp.add_tags(tags)
675         else:
676             msg = "Tags must be a dict of tagname:tagvalue"
677             raise SaltInvocationError(msg)
678     else:
679         msg = "The security group could not be found"
680         raise SaltInvocationError(msg)
681     return True
682 def delete_tags(
683     tags,
684     name=None,
685     group_id=None,
686     vpc_name=None,
687     vpc_id=None,
688     region=None,
689     key=None,
690     keyid=None,
691     profile=None,
692 ):
693     """
694     Deletes tags from a security group.
695     .. versionadded:: 2016.3.0
696     tags
697         a list of tags to remove
698     name
699         the name of the security group
700     group_id
701         the group id of the security group (in lie of a name/vpc combo)
702     vpc_name
703         the name of the vpc to search the named group for
704     vpc_id
705         the id of the vpc, in lieu of the vpc_name
706     region
707         the amazon region
708     key
709         amazon key
710     keyid
711         amazon keyid
712     profile
713         amazon profile
714     CLI Example:
715     .. code-block:: bash
716         salt myminion boto_secgroup.delete_tags ['TAG_TO_DELETE1','TAG_TO_DELETE2'] security_group_name vpc_id=vpc-13435 profile=my_aws_profile
717     """
718     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
719     secgrp = _get_group(
720         conn,
721         name=name,
722         vpc_id=vpc_id,
723         vpc_name=vpc_name,
724         group_id=group_id,
725         region=region,
726         key=key,
727         keyid=keyid,
728         profile=profile,
729     )
730     if secgrp:
731         if isinstance(tags, list):
732             tags_to_remove = {}
733             for tag in tags:
734                 tags_to_remove[tag] = None
735             secgrp.remove_tags(tags_to_remove)
736         else:
737             msg = "Tags must be a list of tagnames to remove from the security group"
738             raise SaltInvocationError(msg)
739     else:
740         msg = "The security group could not be found"
741         raise SaltInvocationError(msg)
742     return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
