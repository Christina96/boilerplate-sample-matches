<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for boto_vpc.py &amp; boto_iam.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_vpc.py &amp; boto_iam.py
      </h3>
<h1 align="center">
        20.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_vpc.py (24.013159%)<th>boto_iam.py (18.263044%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(296-305)<td><a href="#" name="0">(1885-1895)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(980-991)<td><a href="#" name="1">(2022-2029)</a><td align="center"><font color="#f40000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(509-520)<td><a href="#" name="2">(1626-1636)</a><td align="center"><font color="#f40000">23</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(310-323)<td><a href="#" name="3">(1919-1953)</a><td align="center"><font color="#e90000">22</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1632-1644)<td><a href="#" name="4">(1826-1838)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1504-1535)<td><a href="#" name="5">(878-887)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(230-241)<td><a href="#" name="6">(1121-1131)</a><td align="center"><font color="#c90000">19</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1125-1128)<td><a href="#" name="7">(1018-1021)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1109-1112)<td><a href="#" name="8">(676-679)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(465-504)<td><a href="#" name="9">(1448-1454)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1545-1552)<td><a href="#" name="10">(428-434)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(823-830)<td><a href="#" name="11">(846-852)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(532-602)<td><a href="#" name="12">(1482-1499)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(431-440)<td><a href="#" name="13">(1971-1981)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(160-180)<td><a href="#" name="14">(153-207)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(1834-1845)<td><a href="#" name="15">(261-272)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(1093-1097)<td><a href="#" name="16">(334-338)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(1004-1080)<td><a href="#" name="17">(1040-1105)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(670-675)<td><a href="#" name="18">(555-562)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(261-288)<td><a href="#" name="19">(1406-1411)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(936-969)<td><a href="#" name="20">(841-844)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(844-856)<td><a href="#" name="21">(1734-1779)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(787-815)<td><a href="#" name="22">(1643-1691)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(1391-1405)<td><a href="#" name="23">(583-640)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(1196-1204)<td><a href="#" name="24">(1992-2019)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(1139-1150)<td><a href="#" name="25">(1857-1883)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(906-910)<td><a href="#" name="26">(651-655)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(1719-1725)<td><a href="#" name="27">(1576-1581)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(890-900)<td><a href="#" name="28">(289-297)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(739-743)<td><a href="#" name="29">(666-667)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(629-640)<td><a href="#" name="30">(536-539)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_vpc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Manage VPCs
=================

.. versionadded:: 2015.8.0

:depends:

- boto &gt;= 2.8.0
- boto3 &gt;= 1.2.6

Create and destroy VPCs. Be aware that this interacts with Amazon's services,
and so may incur charges.

This module accepts explicit vpc credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

If IAM roles are not used you need to specify them either in a pillar file or
in the minion's config file:

.. code-block:: yaml

    vpc.keyid: GKTADJGHEIQSXMKKRBJ08H
    vpc.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile,
either passed in as a dict, or as a string to pull from pillars or minion
config:

.. code-block:: yaml

    myprofile:
      keyid: GKTADJGHEIQSXMKKRBJ08H
      key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
      region: us-east-1

.. code-block:: yaml

    aws:
      region:
        us-east-1:
          profile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
            region: us-east-1

.. code-block:: jinja

    Ensure VPC exists:
      boto_vpc.present:
        - name: myvpc
        - cidr_block: 10.10.11.0/24
        - dns_hostnames: True
        - region: us-east-1
        - keyid: GKTADJGHEIQSXMKKRBJ08H
        - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    Ensure subnet exists:
      boto_vpc.subnet_present:
        - name: mysubnet
        - vpc_id: vpc-123456
        - cidr_block: 10.0.0.0/16
        - region: us-east-1
        - profile: myprofile

    {% set profile = salt['pillar.get']('aws:region:us-east-1:profile' ) %}
    Ensure internet gateway exists:
      boto_vpc.internet_gateway_present:
        - name: myigw
        - vpc_name: myvpc
        - profile: {{ profile }}

    Ensure route table exists:
      boto_vpc.route_table_present:
        - name: my_route_table
        - vpc_id: vpc-123456
        - routes:
          - destination_cidr_block: 0.0.0.0/0
            instance_id: i-123456
          - subnet_names:
            - subnet1
            - subnet2
          - region: us-east-1
          - profile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

.. versionadded:: 2016.11.0

Request, accept and delete VPC peering connections.
VPC peering connections can be named allowing the name
to be used throughout the state file. Following
example shows how to request and accept a VPC
peering connection.

.. code-block:: yaml

    accept the vpc peering connection:
      boto_vpc.accept_vpc_peering_connection:
        - conn_name: salt_vpc_peering
        - region: us-west-2
        - require:
          - boto_vpc: request a vpc peering connection

    request a vpc peering connection:
      boto_vpc.request_vpc_peering_connection:
        - requester_vpc_id: vpc-4a3d522e
        - peer_vpc_id: vpc-ae81e9ca
        - region: us-west-2
        - conn_name: salt_vpc_peering

VPC peering connections need not be named. In this case
the VPC peering connection ID should be used in the state
file.

.. code-block:: yaml

    accept the vpc peering connection:
      boto_vpc.accept_vpc_peering_connection:
        - conn_id: pcx-1873c371
        - region: us-west-2

VPC peering connections can be deleted, as shown below.

.. code-block:: yaml

    delete a named vpc peering connection:
      boto_vpc.delete_vpc_peering_connection:
        - conn_name: salt_vpc_peering

Delete also accepts a VPC peering connection id.

.. code-block:: yaml

    delete a vpc peering connection by id:
      boto_vpc.delete_vpc_peering_connection:
        - conn_id: pcx-1873c371

"""


import logging

import salt.utils.dictupdate as dictupdate

__virtualname__ = "boto_vpc"

log = logging.getLogger(__name__)


def __virtual__():
    """
    Only load if boto is available.
<a name="14"></a>    """
    boto_version = "2.8.0"
    boto3_version = "1.2.6"
    <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if "boto_vpc.exists" in __salt__:
        return __virtualname__
    else:
        return (
            False,
            "The following libraries are required to run the boto_vpc state module: "
            "boto &gt;= {} and boto3 &gt;= {}.".format(boto_version, boto3_version),
        )


def present(
    name,
    cidr_block,
    instance_tenancy=None,
    dns_support=None,
    dns_hostnames=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
):
    """
    Ensure VPC exists.

    name
        Name of the VPC.

    cidr_block
        The range of IPs in CIDR format, for example: 10.0.0.0/24. Block
        size must be between /16 and /28 netmask.

    instance_tenancy
        Instances launched in this VPC will be ingle-tenant or dedicated
        hardware.

    dns_support
        Indicates whether the DNS resolution is supported for the VPC.

    dns_hostnames
        Indicates whether the instances launched in the VPC get DNS hostnames.

    tags
        A list of tags.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.exists"](
        name=name, tags=tags, region=region, key=key, keyid=keyid, profile=profile
    )

    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to create VPC: {}.".format(r["error"]["message"])
<a name="6"></a>        return ret

    if not r.get("exists"):
        <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if __opts__["test"]:
            ret["comment"] = "VPC {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        r = __salt__["boto_vpc.create"](
            cidr_block,
            instance_tenancy=instance_tenancy,
            vpc_name=name,
            enable_dns_support=dns_support,
            enable_dns_hostnames=dns_hostnames,
            tags=tags,
            region=</b></font>region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not r.get("created"):
            ret["result"] = False
            ret["comment"] = "Error in creating VPC: {}.".format(r["error"]["message"])
            return ret
        _describe = __salt__["boto_vpc.describe"](
            vpc_id=r["id"], region=region, key=key, keyid=keyid, profile=profile
        )
        ret["changes"]["old"] = {"vpc": None}
        ret["changes"]["new"] = _describe
        ret["comment"] = "VPC {} created.".format(name)
        return ret
    ret["comment"] = "VPC present."
<a name="19"></a>    return ret


def absent(name, tags=None, region<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None):
    """
    Ensure VPC with passed properties is absent.

    name
        Name of the VPC.

    tags
        A list of tags. All tags must match.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """

    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.get_id"](
        name=name, tags=tags, region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to delete VPC: {}.".format(r["error"]["message"])
<a name="0"></a>        return ret

    _id = r.get("id")
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not _id:
        ret["comment"] = "{} VPC does not exist.".format(name)
        return ret

    if __opts__["test"]:
        ret["comment"] = "VPC {} is set to be removed.".format(name)
        ret["result"] = None
        return ret
    r = __salt__["boto_vpc.delete"](
        vpc_name=name, tags=tags, region=region, key=</b></font>key, keyid=keyid, profile=profile
    )
<a name="3"></a>    if not r["deleted"]:
        ret["result"] = False
        ret["comment"] = "Failed to delete VPC: {}.".format(r["error"]["message"])
        <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
    ret["changes"]["old"] = {"vpc": _id}
    ret["changes"]["new"] = {"vpc": None}
    ret["comment"] = "VPC {} deleted.".format(name)
    return ret


def dhcp_options_present(
    name,
    dhcp_options_id=None,
    vpc_name=None,
    vpc_id=None,
    domain_name=None,
    domain_name_servers=</b></font>None,
    ntp_servers=None,
    netbios_name_servers=None,
    netbios_node_type=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Ensure a set of DHCP options with the given settings exist.
    Note that the current implementation only SETS values during option set
    creation.  It is unable to update option sets in place, and thus merely
    verifies the set exists via the given name and/or dhcp_options_id param.

    name
        (string)
        Name of the DHCP options.

    vpc_name
        (string)
        Name of a VPC to which the options should be associated.  Either
        vpc_name or vpc_id must be provided.

    vpc_id
        (string)
        Id of a VPC to which the options should be associated.  Either
        vpc_name or vpc_id must be provided.

    domain_name
        (string)
        Domain name to be assiciated with this option set.

    domain_name_servers
        (list of strings)
        The IP address(es) of up to four domain name servers.

    ntp_servers
        (list of strings)
        The IP address(es) of up to four desired NTP servers.

    netbios_name_servers
        (list of strings)
        The IP address(es) of up to four NetBIOS name servers.

    netbios_node_type
        (string)
        The NetBIOS node type (1, 2, 4, or 8).  For more information about
        the allowed values, see RFC 2132.  The recommended is 2 at this
        time (broadcast and multicast are currently not supported).

    tags
        (dict of key:value pairs)
        A set of tags to be added.

    region
        (string)
        Region to connect to.

    key
        (string)
        Secret key to be used.

    keyid
        (string)
        Access key to be used.

    profile
        (various)
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    .. versionadded:: 2016.3.0
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    _new = {
        "domain_name": domain_name,
        "domain_name_servers": domain_name_servers,
        "ntp_servers": ntp_servers,
        "netbios_name_servers": netbios_name_servers,
        "netbios_node_type": netbios_node_type,
    }

    # boto provides no "update_dhcp_options()" functionality, and you can't delete it if
    # it's attached, and you can't detach it if it's the only one, so just check if it's
    # there or not, and make no effort to validate its actual settings... :(
    ### TODO - add support for multiple sets of DHCP options, and then for "swapping out"
    ###        sets by creating new, mapping, then deleting the old.
    r = __salt__["boto_vpc.dhcp_options_exists"](
        dhcp_options_id=dhcp_options_id,
        dhcp_options_name=name,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to validate DHCP options: {}.".format(
            r["error"]["message"]
        )
        return ret

    if r.get("exists"):
<a name="13"></a>        ret["comment"] = "DHCP options already present."
        return ret
    else:
        <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if __opts__["test"]:
            ret["comment"] = "DHCP options {} are set to be created.".format(name)
            ret["result"] = None
            return ret

        r = __salt__["boto_vpc.create_dhcp_options"](
            domain_name=domain_name,
            domain_name_servers=domain_name_servers,
            ntp_servers=ntp_servers,
            netbios_name_servers=</b></font>netbios_name_servers,
            netbios_node_type=netbios_node_type,
            dhcp_options_name=name,
            tags=tags,
            vpc_id=vpc_id,
            vpc_name=vpc_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not r.get("created"):
            ret["result"] = False
            ret["comment"] = "Failed to create DHCP options: {}".format(
                r["error"]["message"]
            )
            return ret

        ret["changes"]["old"] = {"dhcp_options": None}
        ret["changes"]["new"] = {"dhcp_options": _new}
        ret["comment"] = "DHCP options {} created.".format(name)
        return ret
<a name="9"></a>

def dhcp_options_absent(
    name=None, dhcp_options_id=None, region<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None
):
    """
    Ensure a set of DHCP options with the given settings exist.

    name
        (string)
        Name of the DHCP options set.

    dhcp_options_id
        (string)
        Id of the DHCP options set.

    region
        (string)
        Region to connect to.

    key
        (string)
        Secret key to be used.

    keyid
        (string)
        Access key to be used.

    profile
        (various)
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    .. versionadded:: 2016.3.0
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.get_resource_id"](
        "dhcp_options", name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if "error" in r:
        ret["result"] = False
        ret[</b></font>"comment"] = "Failed to delete DHCP options: {}.".format(
            r["error"]["message"]
<a name="2"></a>        )
        return ret

    _id <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= r.get("id")

    if not _id:
        ret["comment"] = "DHCP options {} do not exist.".format(name)
        return ret

    if __opts__["test"]:
        ret["comment"] = "DHCP options {} are set to be deleted.".format(name)
        ret["result"] = None
        return ret

    r = __salt__["boto_vpc.delete_dhcp_options"](</b></font>
        dhcp_options_id=r["id"], region=region, key=key, keyid=keyid, profile=profile
    )
    if not r.get("deleted"):
        ret["result"] = False
        ret["comment"] = "Failed to delete DHCP options: {}".format(
            r["error"]["message"]
        )
        return ret
<a name="12"></a>
    ret["changes"]["old"] = {"dhcp_options": _id}
    ret["changes"]["new"] = {"dhcp_options": None}
    ret["comment"] = "DHCP options {} deleted."<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(name)
    return ret


def subnet_present(
    name,
    cidr_block,
    vpc_name=None,
    vpc_id=None,
    availability_zone=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    route_table_id=None,
    route_table_name=None,
    auto_assign_public_ipv4=False,
):

    """
    Ensure a subnet exists.

    name
        Name of the subnet.

    cidr_block
        The range if IPs for the subnet, in CIDR format. For example:
        10.0.0.0/24. Block size must be between /16 and /28 netmask.

    vpc_name
        Name of the VPC in which the subnet should be placed. Either
        vpc_name or vpc_id must be provided.

    vpc_id
        Id of the VPC in which the subnet should be placed. Either vpc_name
        or vpc_id must be provided.

    availability_zone
        AZ in which the subnet should be placed.

    tags
        A list of tags.

    route_table_id
        A route table ID to explicitly associate the subnet with.  If both route_table_id
        and route_table_name are specified, route_table_id will take precedence.

        .. versionadded:: 2016.11.0

    route_table_name
        A route table name to explicitly associate the subnet with.  If both route_table_id
        and route_table_name are specified, route_table_id will take precedence.

        .. versionadded:: 2016.11.0

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """

    ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.subnet_exists"](
        subnet_name=name,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )

    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to create subnet: {}.".format(r["error"]["message"])
        return ret

    route_table_desc = None
    _describe = None
    rtid = None
    if route_table_id or route_table_name:
        rt = None
        route_table_found = False
        if route_table_id:
            rtid = route_table_id
<a name="30"></a>            rt = __salt__["boto_vpc.route_table_exists"](
                route_table_id=route_table_id,
                region=region,
                key<font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=key,
                keyid=keyid,
                profile=profile,
            )
        elif route_table_name:
            rtid = route_table_name
            rt = __salt__["boto_vpc.route_table_exists"](
                route_table_name=route_table_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=</b></font>profile,
            )
        if rt:
            if "exists" in rt:
                if rt["exists"]:
                    if route_table_id:
                        route_table_found = True
                        route_table_desc = __salt__["boto_vpc.describe_route_tables"](
                            route_table_id=route_table_id,
                            region=region,
                            key=key,
                            keyid=keyid,
                            profile=profile,
                        )
                    elif route_table_name:
                        route_table_found = True
                        route_table_desc = __salt__["boto_vpc.describe_route_tables"](
                            route_table_name=route_table_name,
                            region=region,
                            key=key,
                            keyid=keyid,
                            profile=profile,
                        )
        if not route_table_found:
            ret["result"] = False
            ret["comment"] = "The specified route table {} could not be found.".format(
                rtid
<a name="18"></a>            )
            return ret

    if not r<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("exists"):
        if __opts__["test"]:
            ret["comment"] = "Subnet {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        r = __salt__["boto_vpc.create_subnet"](</b></font>
            subnet_name=name,
            cidr_block=cidr_block,
            availability_zone=availability_zone,
            auto_assign_public_ipv4=auto_assign_public_ipv4,
            vpc_name=vpc_name,
            vpc_id=vpc_id,
            tags=tags,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not r.get("created"):
            ret["result"] = False
            ret["comment"] = "Failed to create subnet: {}".format(r["error"]["message"])
            return ret
        _describe = __salt__["boto_vpc.describe_subnet"](
            subnet_id=r["id"], region=region, key=key, keyid=keyid, profile=profile
        )
        ret["changes"]["old"] = {"subnet": None}
        ret["changes"]["new"] = _describe
        ret["comment"] = "Subnet {} created.".format(name)
    else:
        ret["comment"] = "Subnet present."

    if route_table_desc:
        if not _describe:
            _describe = __salt__["boto_vpc.describe_subnet"](
                subnet_name=name, region=region, key=key, keyid=keyid, profile=profile
            )
        if not _verify_subnet_association(route_table_desc, _describe["subnet"]["id"]):
            if __opts__["test"]:
                msg = "Subnet is set to be associated with route table {}".format(rtid)
                ret["comment"] = " ".join([ret["comment"], msg])
                ret["result"] = None
                return ret
            if "explicit_route_table_association_id" in _describe["subnet"]:
                log.debug("Need to disassociate from existing route table")
                drt_ret = __salt__["boto_vpc.disassociate_route_table"](
                    _describe["subnet"]["explicit_route_table_association_id"],
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                if not drt_ret["disassociated"]:
                    msg = "Unable to disassociate subnet {} with its current route table.".format(
                        name
                    )
                    ret["comment"] = " ".join([ret["comment"], msg])
                    ret["result"] = False
                    return ret
            if "old" not in ret["changes"]:
                ret["changes"]["old"] = _describe
            art_ret = __salt__["boto_vpc.associate_route_table"](
                route_table_id=route_table_desc["id"],
                subnet_name=name,
                region=region,
                key=key,
                keyid=keyid,
<a name="29"></a>                profile=profile,
            )
            if "error" in art_ret:
                msg <font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "Failed to associate subnet {} with route table {}: {}.".format(
                    name, rtid, art_ret["error"]["message"]
                )
                ret["comment"] = " ".join([ret["comment"], msg])
                ret[</b></font>"result"] = False
                return ret
            else:
                msg = "Subnet successfully associated with route table {}.".format(rtid)
                ret["comment"] = " ".join([ret["comment"], msg])
                if "new" not in ret["changes"]:
                    ret["changes"]["new"] = __salt__["boto_vpc.describe_subnet"](
                        subnet_name=name,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                else:
                    ret["changes"]["new"]["subnet"][
                        "explicit_route_table_association_id"
                    ] = art_ret["association_id"]
        else:
            ret["comment"] = " ".join(
                [
                    ret["comment"],
                    "Subnet is already associated with route table {}".format(rtid),
                ]
            )
    return ret


def _verify_subnet_association(route_table_desc, subnet_id):
    """
    Helper function verify a subnet's route table association

    route_table_desc
        the description of a route table, as returned from boto_vpc.describe_route_tables

    subnet_id
        the subnet id to verify

    .. versionadded:: 2016.11.0
    """
    if route_table_desc:
        if "associations" in route_table_desc:
<a name="22"></a>            for association in route_table_desc["associations"]:
                if association["subnet_id"] == subnet_id:
                    return True
    <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return False


def subnet_absent(
    name=None, subnet_id=None, region=None, key=None, keyid=None, profile=None
):
    """
    Ensure subnet with passed properties is absent.

    name
        Name of the subnet.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """

    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.get_resource_id"](</b></font>
        "subnet", name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if "error" in r:
        ret["result"] = False
<a name="11"></a>        ret["comment"] = "Failed to delete subnet: {}.".format(r["error"]["message"])
        return ret

    _id <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= r.get("id")

    if not _id:
        ret["comment"] = "{} subnet does not exist.".format(name)
        return ret

    if __opts__["test"]:
        ret["comment"] = "Subnet {} ({}) is set to be removed.".format(name, r[</b></font>"id"])
        ret["result"] = None
        return ret

    r = __salt__["boto_vpc.delete_subnet"](
        subnet_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not r.get("deleted"):
        ret["result"] = False
        ret["comment"] = "Failed to delete subnet: {}".format(r["error"]["message"])
        return ret
<a name="21"></a>
    ret["changes"]["old"] = {"subnet": _id}
    ret["changes"]["new"] = {"subnet": None}
    ret<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Subnet {} deleted.".format(name)
    return ret


def internet_gateway_present(
    name,
    vpc_name=None,
    vpc_id=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
):
    """
    Ensure an internet gateway exists.

    name
        Name of the internet gateway.

    vpc_name
        Name of the VPC to which the internet gateway should be attached.

    vpc_id
        Id of the VPC to which the internet_gateway should be attached.
        Only one of vpc_name or vpc_id may be provided.

    tags
        A list of tags.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """
<a name="28"></a>
    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r <font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= __salt__["boto_vpc.resource_exists"](
        "internet_gateway",
        name=name,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if "error" in r:
        ret["result"] = False
        ret[</b></font>"comment"] = "Failed to create internet gateway: {}.".format(
            r["error"]["message"]
        )
<a name="26"></a>        return ret

    if not r.get("exists"):
        <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if __opts__["test"]:
            ret["comment"] = "Internet gateway {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        r = __salt__["boto_vpc.create_internet_gateway"](</b></font>
            internet_gateway_name=name,
            vpc_name=vpc_name,
            vpc_id=vpc_id,
            tags=tags,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not r.get("created"):
            ret["result"] = False
            ret["comment"] = "Failed to create internet gateway: {}".format(
                r["error"]["message"]
            )
            return ret

        ret["changes"]["old"] = {"internet_gateway": None}
        ret["changes"]["new"] = {"internet_gateway": r["id"]}
        ret["comment"] = "Internet gateway {} created.".format(name)
        return ret
    ret["comment"] = "Internet gateway {} present.".format(name)
    return ret
<a name="20"></a>

def internet_gateway_absent(
    name, detach=False, region<font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None
):
    """
    Ensure the named internet gateway is absent.

    name
        Name of the internet gateway.

    detach
        First detach the internet gateway from a VPC, if attached.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """

    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.get_resource_id"](
        "internet_gateway",
        name=name,
        region=region,
        key=key,
        keyid=keyid,
        profile=</b></font>profile,
    )
    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to delete internet gateway: {}.".format(
            r["error"]["message"]
        )
        return ret
<a name="1"></a>
    igw_id = r["id"]
    if not igw_id:
        ret<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Internet gateway {} does not exist.".format(name)
        return ret

    if __opts__["test"]:
        ret["comment"] = "Internet gateway {} is set to be removed.".format(name)
        ret["result"] = None
        return ret
    r = __salt__["boto_vpc.delete_internet_gateway"](
        internet_gateway_name=name,
        detach=detach,
        region=region,
        key=</b></font>key,
        keyid=keyid,
        profile=profile,
    )
    if not r.get("deleted"):
        ret["result"] = False
        ret["comment"] = "Failed to delete internet gateway: {}.".format(
            r["error"]["message"]
        )
        return ret
<a name="17"></a>    ret["changes"]["old"] = {"internet_gateway": igw_id}
    ret["changes"]["new"] = {"internet_gateway": None}
    ret["comment"] = "Internet gateway {} deleted.".format(name)
    <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret


def route_table_present(
    name,
    vpc_name=None,
    vpc_id=None,
    routes=None,
    subnet_ids=None,
    subnet_names=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Ensure route table with routes exists and is associated to a VPC.

    This function requires boto3 to be installed if nat gatewyas are specified.

    Example:

    .. code-block:: yaml

        boto_vpc.route_table_present:
          - name: my_route_table
          - vpc_id: vpc-123456
          - routes:
            - destination_cidr_block: 0.0.0.0/0
              internet_gateway_name: InternetGateway
            - destination_cidr_block: 10.10.11.0/24
              instance_id: i-123456
            - destination_cidr_block: 10.10.12.0/24
              interface_id: eni-123456
            - destination_cidr_block: 10.10.13.0/24
              instance_name: mygatewayserver
          - subnet_names:
            - subnet1
            - subnet2

    name
        Name of the route table.

    vpc_name
        Name of the VPC with which the route table should be associated.

    vpc_id
        Id of the VPC with which the route table should be associated.
        Either vpc_name or vpc_id must be provided.

    routes
        A list of routes.  Each route has a cidr and a target.

    subnet_ids
        A list of subnet ids to associate

    subnet_names
        A list of subnet names to associate

    tags
        A list of tags.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """
    ret = {"name"</b></font>: name, "result": True, "comment": "", "changes": {}}

    _ret = _route_table_present(
        name=name,
        vpc_name=vpc_name,
        vpc_id=vpc_id,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
<a name="16"></a>        profile=profile,
    )
    ret["changes"] = _ret["changes"]
    ret<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        if ret["result"] is False:
            r</b></font>eturn ret
        if ret["result"] is None and __opts__["test"]:
            return ret
    _ret = _routes_present(
        route_table_name=name,
        routes=routes,
        tags=tags,
        region=region,
        key=key,
<a name="8"></a>        keyid=keyid,
        profile=profile,
    )
    ret<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret[</b></font>"result"]
        if ret["result"] is False:
            return ret
    _ret = _subnets_present(
        route_table_name=name,
        subnet_ids=subnet_ids,
        subnet_names=subnet_names,
        tags=tags,
        region=region,
        key=key,
<a name="7"></a>        keyid=keyid,
        profile=profile,
    )
    ret<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret[</b></font>"result"]
        if ret["result"] is False:
            return ret
    return ret


def _route_table_present(
    name,
<a name="25"></a>    vpc_name=None,
    vpc_id=None,
    tags=None,
    region<font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.get_resource_id"](
        resource="route_table",
        name=name,
        region=region,
        key=</b></font>key,
        keyid=keyid,
        profile=profile,
    )
    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to create route table: {}.".format(
            r["error"]["message"]
        )
        return ret

    _id = r.get("id")

    if not _id:
        if __opts__["test"]:
            msg = "Route table {} is set to be created.".format(name)
            ret["comment"] = msg
            ret["result"] = None
            return ret

        r = __salt__["boto_vpc.create_route_table"](
            route_table_name=name,
            vpc_name=vpc_name,
            vpc_id=vpc_id,
            tags=tags,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not r.get("created"):
            ret["result"] = False
            ret["comment"] = "Failed to create route table: {}.".format(
                r["error"]["message"]
            )
            return ret

        ret["changes"]["old"] = {"route_table": None}
        ret["changes"]["new"] = {"route_table": r["id"]}
        ret["comment"] = "Route table {} created.".format(name)
        return ret
    ret["comment"] = "Route table {} ({}) present.".format(name, _id)
    return ret
<a name="24"></a>

def _routes_present(
    route_table_name, routes, tags=None, region<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None
):
    ret = {"name": route_table_name, "result": True, "comment": "", "changes": {}}

    route_table = __salt__["boto_vpc.describe_route_tables"](
        route_table_name=route_table_name,
        tags=tags,
        region=region,
        key=</b></font>key,
        keyid=keyid,
        profile=profile,
    )
    if "error" in route_table:
        msg = "Could not retrieve configuration for route table {}: {}`.".format(
            route_table_name, route_table["error"]["message"]
        )
        ret["comment"] = msg
        ret["result"] = False
        return ret

    route_table = route_table[0]
    _routes = []
    if routes:
        route_keys = {
            "gateway_id",
            "instance_id",
            "destination_cidr_block",
            "interface_id",
            "vpc_peering_connection_id",
            "nat_gateway_id",
        }
        for i in routes:
            # _r = {k:i[k] for k in i if k in route_keys}
            _r = {}
            for k, v in i.items():
                if k in route_keys:
                    _r[k] = i[k]
            if i.get("internet_gateway_name"):
                r = __salt__["boto_vpc.get_resource_id"](
                    "internet_gateway",
                    name=i["internet_gateway_name"],
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                if "error" in r:
                    msg = "Error looking up id for internet gateway {}: {}".format(
                        i.get("internet_gateway_name"), r["error"]["message"]
                    )
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                if r["id"] is None:
                    msg = "Internet gateway {} does not exist.".format(i)
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                _r["gateway_id"] = r["id"]
            if i.get("vpc_peering_connection_name"):
                r = __salt__["boto_vpc.get_resource_id"](
                    "vpc_peering_connection",
                    name=i["vpc_peering_connection_name"],
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                if "error" in r:
                    msg = (
                        "Error looking up id for VPC peering connection {}: {}".format(
                            i.get("vpc_peering_connection_name"), r["error"]["message"]
                        )
                    )
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                if r["id"] is None:
                    msg = "VPC peering connection {} does not exist.".format(i)
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                _r["vpc_peering_connection_id"] = r["id"]
            if i.get("instance_name"):
                running_states = (
                    "pending",
                    "rebooting",
                    "running",
                    "stopping",
                    "stopped",
                )
                r = __salt__["boto_ec2.get_id"](
                    name=i["instance_name"],
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                    in_states=running_states,
                )
                if r is None:
                    msg = "Instance {} does not exist.".format(i["instance_name"])
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                _r["instance_id"] = r
            if i.get("nat_gateway_subnet_name"):
                r = __salt__["boto_vpc.describe_nat_gateways"](
                    subnet_name=i["nat_gateway_subnet_name"],
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                if not r:
                    msg = "Nat gateway does not exist."
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                _r["nat_gateway_id"] = r[0]["NatGatewayId"]
            _routes.append(_r)

    to_delete = []
    to_create = []
    for route in _routes:
        if route not in route_table["routes"]:
            to_create.append(dict(route))
    for route in route_table["routes"]:
        if route not in _routes:
            if route.get("gateway_id") != "local":
                to_delete.append(route)
    if to_create or to_delete:
        if __opts__["test"]:
            msg = "Route table {} set to have routes modified.".format(route_table_name)
            ret["comment"] = msg
            ret["result"] = None
            return ret
        if to_delete:
            for r in to_delete:
                res = __salt__["boto_vpc.delete_route"](
                    route_table_id=route_table["id"],
                    destination_cidr_block=r["destination_cidr_block"],
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                if not res["deleted"]:
                    msg = "Failed to delete route {} from route table {}: {}.".format(
                        r["destination_cidr_block"],
                        route_table_name,
                        res["error"]["message"],
                    )
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                ret["comment"] = "Deleted route {} from route table {}.".format(
                    r["destination_cidr_block"], route_table_name
                )
        if to_create:
            for r in to_create:
                res = __salt__["boto_vpc.create_route"](
                    route_table_id=route_table["id"],
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                    **r
                )
                if not res["created"]:
                    msg = "Failed to create route {} in route table {}: {}.".format(
                        r["destination_cidr_block"],
                        route_table_name,
                        res["error"]["message"],
                    )
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                ret["comment"] = "Created route {} in route table {}.".format(
                    r["destination_cidr_block"], route_table_name
                )
        ret["changes"]["old"] = {"routes": route_table["routes"]}
        route = __salt__["boto_vpc.describe_route_tables"](
            route_table_name=route_table_name,
            tags=tags,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        ret["changes"]["new"] = {"routes": route[0]["routes"]}
    return ret

<a name="23"></a>
def _subnets_present(
    route_table_name,
    subnet_ids<font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
    subnet_names=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": route_table_name, "result": True, "comment": "", "changes": {}}

    if not subnet_ids:
        subnet_ids = []

    # Look up subnet ids
    if</b></font> subnet_names:
        for i in subnet_names:
            r = __salt__["boto_vpc.get_resource_id"](
                "subnet", name=i, region=region, key=key, keyid=keyid, profile=profile
            )

            if "error" in r:
                msg = "Error looking up subnet ids: {}".format(r["error"]["message"])
                ret["comment"] = msg
                ret["result"] = False
                return ret
            if r["id"] is None:
                msg = "Subnet {} does not exist.".format(i)
                ret["comment"] = msg
                ret["result"] = False
                return ret
            subnet_ids.append(r["id"])

    # Describe routing table
    route_table = __salt__["boto_vpc.describe_route_tables"](
        route_table_name=route_table_name,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if not route_table:
        msg = "Could not retrieve configuration for route table {}.".format(
            route_table_name
        )
        ret["comment"] = msg
        ret["result"] = False
        return ret

    assoc_ids = [x["subnet_id"] for x in route_table["associations"]]

    to_create = [x for x in subnet_ids if x not in assoc_ids]
    to_delete = []
    for x in route_table["associations"]:
        # Don't remove the main route table association
        if x["subnet_id"] not in subnet_ids and x["subnet_id"] is not None:
            to_delete.append(x["id"])

    if to_create or to_delete:
        if __opts__["test"]:
            msg = "Subnet associations for route table {} set to be modified.".format(
                route_table_name
            )
            ret["comment"] = msg
            ret["result"] = None
            return ret
        if to_delete:
            for r_asc in to_delete:
                r = __salt__["boto_vpc.disassociate_route_table"](
                    r_asc, region, key, keyid, profile
                )
                if "error" in r:
                    msg = "Failed to dissociate {} from route table {}: {}.".format(
                        r_asc, route_table_name, r["error"]["message"]
                    )
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                ret["comment"] = "Dissociated subnet {} from route table {}.".format(
                    r_asc, route_table_name
                )
        if to_create:
            for sn in to_create:
                r = __salt__["boto_vpc.associate_route_table"](
                    route_table_id=route_table["id"],
                    subnet_id=sn,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                if "error" in r:
                    msg = (
                        "Failed to associate subnet {} with route table {}: {}.".format(
                            sn, route_table_name, r["error"]["message"]
                        )
                    )
                    ret["comment"] = msg
                    ret["result"] = False
                    return ret
                ret["comment"] = "Associated subnet {} with route table {}.".format(
                    sn, route_table_name
                )
        ret["changes"]["old"] = {"subnets_associations": route_table["associations"]}
        new_sub = __salt__["boto_vpc.describe_route_tables"](
            route_table_name=route_table_name,
            tags=tags,
            region=region,
            key=key,
            keyid=keyid,
<a name="5"></a>            profile=profile,
        )
        ret["changes"]["new"] = {"subnets_associations": new_sub["associations"]}
    <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret


def route_table_absent(name, region=None, key=None, keyid=None, profile=None):
    """
    Ensure the named route table is absent.

    name
        Name of the route table.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """

    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.get_resource_id"](
        "route_table", name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if "error" in r:
        ret["result"] = False
        ret[</b></font>"comment"] = r["error"]["message"]
        return ret

    rtbl_id = r["id"]

    if not rtbl_id:
        ret["comment"] = "Route table {} does not exist.".format(name)
<a name="10"></a>        return ret

    if __opts__["test"]:
        ret<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Route table {} is set to be removed.".format(name)
        ret["result"] = None
        return ret

    r = __salt__["boto_vpc.delete_route_table"](
        route_table_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if</b></font> "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to delete route table: {}".format(
            r["error"]["message"]
        )
        return ret
    ret["changes"]["old"] = {"route_table": rtbl_id}
    ret["changes"]["new"] = {"route_table": None}
    ret["comment"] = "Route table {} deleted.".format(name)
    return ret


def nat_gateway_present(
    name,
    subnet_name=None,
    subnet_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    allocation_id=None,
):
    """
    Ensure a nat gateway exists within the specified subnet

    This function requires boto3.

    .. versionadded:: 2016.11.0

    Example:

    .. code-block:: yaml

        boto_vpc.nat_gateway_present:
          - subnet_name: my-subnet

    name
        Name of the state

    subnet_name
        Name of the subnet within which the nat gateway should exist

    subnet_id
        Id of the subnet within which the nat gateway should exist.
        Either subnet_name or subnet_id must be provided.

    allocation_id
        If specified, the elastic IP address referenced by the ID is
        associated with the gateway. Otherwise, a new allocation_id is created and used.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.describe_nat_gateways"](
        subnet_name=subnet_name,
        subnet_id=subnet_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if not r:
        if __opts__["test"]:
            msg = "Nat gateway is set to be created."
            ret["comment"] = msg
<a name="4"></a>            ret["result"] = None
            return ret

        r <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= __salt__["boto_vpc.create_nat_gateway"](
            subnet_name=subnet_name,
            subnet_id=subnet_id,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
            allocation_id=allocation_id,
        )
        if not r.get("created"):
            ret["result"] = False
            ret["comment"] = "Failed to create nat gateway: {}.".format(
                r["error"][</b></font>"message"]
            )
            return ret

        ret["changes"]["old"] = {"nat_gateway": None}
        ret["changes"]["new"] = {"nat_gateway": r["id"]}
        ret["comment"] = "Nat gateway created."
        return ret

    inst = r[0]
    _id = inst.get("NatGatewayId")
    ret["comment"] = "Nat gateway {} present.".format(_id)
    return ret


def nat_gateway_absent(
    name=None,
    subnet_name=None,
    subnet_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    wait_for_delete_retries=0,
):
    """
    Ensure the nat gateway in the named subnet is absent.

    This function requires boto3.

    .. versionadded:: 2016.11.0

    name
        Name of the state.

    subnet_name
        Name of the subnet within which the nat gateway should exist

    subnet_id
        Id of the subnet within which the nat gateway should exist.
        Either subnet_name or subnet_id must be provided.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    wait_for_delete_retries
        NAT gateway may take some time to be go into deleted or failed state.
        During the deletion process, subsequent release of elastic IPs may fail;
        this state will automatically retry this number of times to ensure
        the NAT gateway is in deleted or failed state before proceeding.
        Default is set to 0 for backward compatibility.

    """

    ret = {"name": name, "result": True, "comment": "", "changes": {}}

    r = __salt__["boto_vpc.describe_nat_gateways"](
        subnet_name=subnet_name,
        subnet_id=subnet_id,
        region=region,
        key=key,
        keyid=keyid,
<a name="27"></a>        profile=profile,
    )
    if not r:
        ret<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Nat gateway does not exist."
        return ret

    if __opts__["test"]:
        ret["comment"] = "Nat gateway is set to be removed."
        ret["result"] = None
        r</b></font>eturn ret

    for gw in r:
        rtbl_id = gw.get("NatGatewayId")
        r = __salt__["boto_vpc.delete_nat_gateway"](
            nat_gateway_id=rtbl_id,
            release_eips=True,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
            wait_for_delete=True,
            wait_for_delete_retries=wait_for_delete_retries,
        )
        if "error" in r:
            ret["result"] = False
            ret["comment"] = "Failed to delete nat gateway: {}".format(
                r["error"]["message"]
            )
            return ret
        ret["comment"] = ", ".join(
            (ret["comment"], "Nat gateway {} deleted.".format(rtbl_id))
        )
    ret["changes"]["old"] = {"nat_gateway": rtbl_id}
    ret["changes"]["new"] = {"nat_gateway": None}
    return ret


# pylint: disable=too-many-arguments
def accept_vpc_peering_connection(
    name=None,
    conn_id=None,
    conn_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Accept a VPC pending requested peering connection between two VPCs.

    name
        Name of this state

    conn_id
        The connection ID to accept. Exclusive with conn_name. String type.

    conn_name
        The name of the VPC peering connection to accept. Exclusive with conn_id. String type.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    .. versionadded:: 2016.11.0

    Example:

    .. code-block:: yaml

        boto_vpc.accept_vpc_peering_connection:
          - conn_name: salt_peering_connection

        # usage with vpc peering connection id and region
        boto_vpc.accept_vpc_peering_connection:
          - conn_id: pbx-1873d472
          - region: us-west-2

    """
    log.debug("Called state to accept VPC peering connection")
    pending = __salt__["boto_vpc.is_peering_connection_pending"](
        conn_id=conn_id,
        conn_name=conn_name,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )

    ret = {
        "name": name,
        "result": True,
        "changes": {},
        "comment": "Boto VPC peering state",
    }

    if not pending:
        ret["result"] = True
        ret["changes"].update(
            {"old": "No pending VPC peering connection found. Nothing to be done."}
        )
        return ret

    if __opts__["test"]:
        ret["changes"].update(
            {"old": "Pending VPC peering connection found and can be accepted"}
        )
<a name="15"></a>        return ret
    fun = "boto_vpc.accept_vpc_peering_connection"
    log.debug("Calling `%s()` to accept this VPC peering connection", fun)
    result <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= __salt__[fun](
        conn_id=conn_id,
        name=conn_name,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )

    if "error" in result:
        ret["comment"] = "Failed to accept VPC peering: {}".format(result["error"])
        ret[</b></font>"result"] = False
        return ret

    ret["changes"].update({"old": "", "new": result["msg"]})

    return ret


# pylint: disable=too-many-arguments
def request_vpc_peering_connection(
    name,
    requester_vpc_id=None,
    requester_vpc_name=None,
    peer_vpc_id=None,
    peer_vpc_name=None,
    conn_name=None,
    peer_owner_id=None,
    peer_region=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    name
        Name of the state

    requester_vpc_id
        ID of the requesting VPC. Exclusive with requester_vpc_name. String type.

    requester_vpc_name
        Name tag of the requesting VPC.  Exclusive with requester_vpc_id.  String type.

    peer_vpc_id
        ID of the VPC tp crete VPC peering connection with.  This can be a VPC in another account. Exclusive with peer_vpc_name. String type.

    peer_vpc_name
        Name tag of the VPC tp crete VPC peering connection with.  This can only be a VPC the same account and region. Exclusive with peer_vpc_id.  String type.

    conn_name
        The (optional) name to use for this VPC peering connection. String type.

    peer_owner_id
        ID of the owner of the peer VPC. String type. If this isn't supplied AWS uses your account ID.  Required if peering to a different account.

    peer_region
        Region of peer VPC. For inter-region vpc peering connections. Not required for intra-region peering connections.

        .. versionadded:: 3005

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    .. versionadded:: 2016.11.0

    Example:

    .. code-block:: yaml

        request a vpc peering connection:
          boto_vpc.request_vpc_peering_connection:
            - requester_vpc_id: vpc-4b3522e
            - peer_vpc_id: vpc-ae83f9ca
            - conn_name: salt_peering_connection

    """
    log.debug("Called state to request VPC peering connection")
    ret = {
        "name": name,
        "result": True,
        "changes": {},
        "comment": "Boto VPC peering state",
    }
    if conn_name:
        vpc_ids = __salt__["boto_vpc.describe_vpc_peering_connection"](
            conn_name, region=region, key=key, keyid=keyid, profile=profile
        ).get("VPC-Peerings", [])
    else:
        vpc_ids = []

    if vpc_ids:
        ret["comment"] = "VPC peering connection already exists, nothing to be done."
        return ret

    if __opts__["test"]:
        if not vpc_ids:
            ret["comment"] = "VPC peering connection will be created"
        return ret

    log.debug("Called module to create VPC peering connection")

    result = __salt__["boto_vpc.request_vpc_peering_connection"](
        requester_vpc_id,
        requester_vpc_name,
        peer_vpc_id,
        peer_vpc_name,
        name=conn_name,
        peer_owner_id=peer_owner_id,
        peer_region=peer_region,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )

    if "error" in result:
        ret["comment"] = "Failed to request VPC peering: {}".format(result["error"])
        ret["result"] = False
        return ret

    ret["changes"].update({"old": "", "new": result["msg"]})
    return ret


def vpc_peering_connection_present(
    name,
    requester_vpc_id=None,
    requester_vpc_name=None,
    peer_vpc_id=None,
    peer_vpc_name=None,
    conn_name=None,
    peer_owner_id=None,
    peer_region=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    name
        Name of the state

    requester_vpc_id
        ID of the requesting VPC. Exclusive with requester_vpc_name.

    requester_vpc_name
        Name tag of the requesting VPC.  Exclusive with requester_vpc_id.

    peer_vpc_id
        ID of the VPC tp crete VPC peering connection with. This can be a VPC in
        another account. Exclusive with peer_vpc_name.

    peer_vpc_name
        Name tag of the VPC tp crete VPC peering connection with. This can only
        be a VPC in the same account, else resolving it into a vpc ID will fail.
        Exclusive with peer_vpc_id.

    conn_name
        The name to use for this VPC peering connection.

    peer_owner_id
        ID of the owner of the peer VPC. Defaults to your account ID, so a value
        is required if peering with a VPC in a different account.

    peer_region
        Region of peer VPC. For inter-region vpc peering connections. Not required
        for intra-region peering connections.

        .. versionadded:: 3005

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    .. versionadded:: 2016.11.0

    Example:

    .. code-block:: yaml

        ensure peering twixt local vpc and the other guys:
          boto_vpc.vpc_peering_connection_present:
            - requester_vpc_name: my_local_vpc
            - peer_vpc_name: some_other_guys_vpc
            - conn_name: peering_from_here_to_there
            - peer_owner_id: 012345654321


    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if __salt__["boto_vpc.is_peering_connection_pending"](
        conn_name=conn_name, region=region, key=key, keyid=keyid, profile=profile
    ):
        if __salt__["boto_vpc.peering_connection_pending_from_vpc"](
            conn_name=conn_name,
            vpc_id=requester_vpc_id,
            vpc_name=requester_vpc_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ):
            ret[
                "comment"
            ] = "VPC peering {} already requested - pending acceptance by {}".format(
                conn_name, peer_owner_id or peer_vpc_name or peer_vpc_id
            )
            log.info(ret["comment"])
            return ret
        return accept_vpc_peering_connection(
            name=name,
            conn_name=conn_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    return request_vpc_peering_connection(
        name=name,
        requester_vpc_id=requester_vpc_id,
        requester_vpc_name=requester_vpc_name,
        peer_vpc_id=peer_vpc_id,
        peer_vpc_name=peer_vpc_name,
        conn_name=conn_name,
        peer_owner_id=peer_owner_id,
        peer_region=peer_region,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )


def vpc_peering_connection_absent(
    name, conn_id=None, conn_name=None, region=None, key=None, keyid=None, profile=None
):
    return delete_vpc_peering_connection(
        name, conn_id, conn_name, region, key, keyid, profile
    )


# pylint: disable=too-many-arguments
def delete_vpc_peering_connection(
    name, conn_id=None, conn_name=None, region=None, key=None, keyid=None, profile=None
):
    """
    name
        Name of the state

    conn_id
        ID of the peering connection to delete.  Exclusive with conn_name.

    conn_name
        The name of the peering connection to delete.  Exclusive with conn_id.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    .. versionadded:: 2016.11.0

    Example:

    .. code-block:: yaml

        delete a vpc peering connection:
          boto_vpc.delete_vpc_peering_connection:
            - region: us-west-2
            - conn_id: pcx-4613b12e

    Connection name can be specified (instead of ID).
    Specifying both conn_name and conn_id will result in an
    error.

    .. code-block:: yaml

        delete a vpc peering connection:
          boto_vpc.delete_vpc_peering_connection:
            - conn_name: salt_vpc_peering

    """
    log.debug("Called state to delete VPC peering connection")
    ret = {
        "name": name,
        "result": True,
        "changes": {},
        "comment": "Boto VPC peering state",
    }
    if conn_name:
        vpc_ids = __salt__["boto_vpc.describe_vpc_peering_connection"](
            conn_name, region=region, key=key, keyid=keyid, profile=profile
        ).get("VPC-Peerings", [])
    else:
        vpc_ids = [conn_id]

    if not vpc_ids:
        ret["comment"] = "No VPC connection found, nothing to be done."
        return ret

    if __opts__["test"]:
        if vpc_ids:
            ret["comment"] = "VPC peering connection would be deleted"
        return ret

    log.debug("Called module to delete VPC peering connection")

    result = __salt__["boto_vpc.delete_vpc_peering_connection"](
        conn_id=conn_id,
        conn_name=conn_name,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )

    if "error" in result:
        ret["comment"] = "Failed to delete VPC peering: {}".format(result["error"])
        ret["result"] = False
        return ret

    ret["changes"].update({"old": "", "new": result["msg"]})
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Manage IAM objects
==================

.. versionadded:: 2015.8.0

This module uses ``boto``, which can be installed via package, or pip.

This module accepts explicit IAM credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
passed in as a dict, or as a string to pull from pillars or minion config:

.. code-block:: yaml

    delete-user:
      boto_iam.user_absent:
        - name: myuser
        - delete_keys: true


.. code-block:: yaml

    delete-keys:
      boto_iam.keys_absent:
        - access_keys:
          - 'AKIAJHTMIQ2ASDFLASDF'
          - 'PQIAJHTMIQ2ASRTLASFR'
        - user_name: myuser

.. code-block:: yaml

    create-user:
      boto_iam.user_present:
        - name: myuser
        - policies:
            mypolicy: |
                {
                    "Version": "2012-10-17",
                    "Statement": [{
                    "Effect": "Allow",
                    "Action": "*",
                    "Resource": "*"}]
                }
        - password: NewPassword$$1
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    create-group:
      boto_iam.group_present:
        - name: mygroup
        - users:
          - myuser
          - myuser1
        - policies:
            mypolicy: |
                {
                    "Version": "2012-10-17",
                    "Statement": [{
                    "Effect": "Allow",
                    "Action": "*",
                    "Resource": "*"}]
                }
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'

.. code-block:: yaml

    change-policy:
      boto_iam.account_policy:
        - change_password: True
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'

.. code-block:: yaml

    create server certificate:
      boto_iam.server_cert_present:
        - name: mycert
        - public_key: salt://base/mycert.crt
        - private_key: salt://base/mycert.key
        - cert_chain: salt://base/mycert_chain.crt
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    delete server certificate:
      boto_iam.server_cert_absent:
        - name: mycert

.. code-block:: yaml

    create keys for user:
      boto_iam.keys_present:
        - name: myusername
        - number: 2
        - save_dir: /root
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    create policy:
      boto_iam.policy_present:
        - name: myname
        - policy_document: '{"MyPolicy": "Statement": [{"Action": ["sqs:*"], "Effect": "Allow", "Resource": ["arn:aws:sqs:*:*:*"], "Sid": "MyPolicySqs1"}]}'
        - region: eu-west-1
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'fdkjsafkljsASSADFalkfjasdf'

.. code-block:: yaml

    add-saml-provider:
      boto_iam.saml_provider_present:
        - name: my_saml_provider
        - saml_metadata_document: salt://base/files/provider.xml
        - keyid: 'AKIAJHTMIQ2ASDFLASDF'
        - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
"""

import logging
import os
import xml.etree.ElementTree as ET

import salt.utils.data
import salt.utils.dictupdate as dictupdate
import salt.utils.files
import salt.utils.json
import salt.utils.odict as odict
import salt.utils.stringutils

log = logging.getLogger(__name__)

__virtualname__ = "boto_iam"


def __virtual__():
<a name="14"></a>    """
    Only load if elementtree xml library and boto are available.
    """
    <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if "boto_iam.get_user" in __salt__:
        return True
    else:
        return (
            False,
            "Cannot load {} state: boto_iam module unavailable".format(__virtualname__),
        )


def user_absent(
    name,
    delete_keys=True,
    delete_mfa_devices=True,
    delete_profile=True,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """

    .. versionadded:: 2015.8.0

    Ensure the IAM user is absent. User cannot be deleted if it has keys.

    name (string)
        The name of the new user.

    delete_keys (bool)
        Delete all keys from user.

    delete_mfa_devices (bool)
        Delete all mfa devices from user.

        .. versionadded:: 2016.3.0

    delete_profile (bool)
        Delete profile from user.

        .. versionadded:: 2016.3.0

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
        ret["result"] = True
        ret["comment"] = "IAM User {} does not exist.".format(name)
        return ret
    # delete the user's access keys
    if delete_keys:
        keys = __salt__["boto_iam.get_all_access_keys"](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        log.debug("Keys for user %s are %s.", name, keys)
        if isinstance(keys, dict):
            keys = keys["list_access_keys_response"]["list_access_keys_result"][
                "access_key_metadata"
            ]
            for k in keys:
                if __opts__["test"]:
                    ret["comment"] = " ".join(
                        [
                            ret["comment"],
                            "Key {} is set to be deleted.".format(k["access_key_id"]),
                        ]
                    )
                    ret["result"] = None
                else:
                    if _delete_key(
                        ret, k["access_key_id"], name, region, key, keyid, profile
                    ):
                        ret["comment"] = " ".join(
                            [
                                ret["comment"],
                                "Key {} has been deleted.".format(k["access_key_id"]),
                            ]
                        )
                        ret["changes"][k["access_key_id"]] = "deleted"
    # delete the user's MFA tokens
    if delete_mfa_devices:
        devices = __salt__["boto_iam.get_all_mfa_devices"](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        if devices:
            for d in devices:
                serial = d["serial_number"]
                if __opts__["test"]:
                    ret["comment"] = " ".join(
                        [
                            ret["comment"],
                            "IAM user {} MFA device {} is set to be deactivated.".format(
                                name, serial
                            ),
                        ]
<a name="15"></a>                    )
                    ret["result"] = None
                else:
                    mfa_deactivated <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.deactivate_mfa_device"](
                        user_name=name,
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deactivated:
                        ret["comment"] = " ".join(
                            [
                                ret[</b></font>"comment"],
                                "IAM user {} MFA device {} is deactivated.".format(
                                    name, serial
                                ),
                            ]
                        )
                if __opts__["test"]:
                    ret["comment"] = " ".join(
                        [
                            ret["comment"],
                            "Virtual MFA device {} is set to be deleted.".format(
                                serial
                            ),
                        ]
<a name="28"></a>                    )
                    ret["result"] = None
                else:
                    mfa_deleted <font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.delete_virtual_mfa_device"](
                        serial=serial,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if mfa_deleted:
                        ret["comment"] = " ".</b></font>join(
                            [
                                ret["comment"],
                                "Virtual MFA device {} is deleted.".format(serial),
                            ]
                        )
    # delete the user's login profile
    if delete_profile:
        if __opts__["test"]:
            ret["comment"] = " ".join(
                [
                    ret["comment"],
                    "IAM user {} login profile is set to be deleted.".format(name),
                ]
            )
            ret["result"] = None
        else:
            profile_deleted = __salt__["boto_iam.delete_login_profile"](
                name, region, key, keyid, profile
            )
            if profile_deleted:
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "IAM user {} login profile is deleted.".format(name),
                    ]
                )
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM user {} managed policies are set to be detached.".format(name),
            ]
        )
<a name="16"></a>        ret["result"] = None
    else:
        _ret = _user_policies_detached(name, region, key, keyid, profile)
        ret<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                r</b></font>eturn ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM user {} inline policies are set to be deleted.".format(name),
            ]
        )
        ret["result"] = None
    else:
        _ret = _user_policies_deleted(name, region, key, keyid, profile)
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    # finally, actually delete the user
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM user {} is set to be deleted.".format(name)]
        )
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_user"](name, region, key, keyid, profile)
    if deleted is True:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM user {} is deleted.".format(name)]
        )
        ret["result"] = True
        ret["changes"]["deleted"] = name
        return ret
    ret["comment"] = "IAM user {} could not be deleted.\n {}".format(name, deleted)
    ret["result"] = False
    return ret


def keys_present(
    name,
    number,
    save_dir,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    save_format="{2}\n{0}\n{3}\n{1}\n",
):
    """
    .. versionadded:: 2015.8.0

    Ensure the IAM access keys are present.

    name (string)
        The name of the new user.

    number (int)
        Number of keys that user should have.

    save_dir (string)
        The directory that the key/keys will be saved. Keys are saved to a file named according
        to the username privided.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.

    save_format (dict)
        Save format is repeated for each key. Default format is
        "{2}\\n{0}\\n{3}\\n{1}\\n", where {0} and {1} are placeholders for new
        key_id and key respectively, whereas {2} and {3} are "key_id-{number}"
        and 'key-{number}' strings kept for compatibility.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
        ret["result"] = False
        ret["comment"] = "IAM User {} does not exist.".format(name)
        return ret
    if not isinstance(number, int):
        ret["comment"] = "The number of keys must be an integer."
<a name="10"></a>        ret["result"] = False
        return ret
    if not os.path.isdir(save_dir):
        ret<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "The directory {} does not exist.".format(save_dir)
        ret["result"] = False
        return ret
    keys = __salt__["boto_iam.get_all_access_keys"](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if</b></font> isinstance(keys, str):
        log.debug("keys are : false %s", keys)
        error, message = _get_error(keys)
        ret["comment"] = "Could not get keys.\n{}\n{}".format(error, message)
        ret["result"] = False
        return ret
    keys = keys["list_access_keys_response"]["list_access_keys_result"][
        "access_key_metadata"
    ]
    log.debug("Keys are : %s.", keys)
    if len(keys) &gt;= number:
        ret["comment"] = "The number of keys exist for user {}".format(name)
        ret["result"] = True
        return ret
    if __opts__["test"]:
        ret["comment"] = "Access key is set to be created for {}.".format(name)
        ret["result"] = None
        return ret
    new_keys = {}
    for i in range(number - len(keys)):
        created = __salt__["boto_iam.create_access_key"](
            name, region, key, keyid, profile
        )
        if isinstance(created, str):
            error, message = _get_error(created)
            ret["comment"] = "Could not create keys.\n{}\n{}".format(error, message)
            ret["result"] = False
            return ret
        log.debug("Created is : %s", created)
        response = "create_access_key_response"
        result = "create_access_key_result"
        new_keys[str(i)] = {}
        new_keys[str(i)]["key_id"] = created[response][result]["access_key"][
            "access_key_id"
        ]
        new_keys[str(i)]["secret_key"] = created[response][result]["access_key"][
            "secret_access_key"
        ]
    try:
        with salt.utils.files.fopen("{}/{}".format(save_dir, name), "a") as _wrf:
            for key_num, key in new_keys.items():
                key_id = key["key_id"]
                secret_key = key["secret_key"]
                _wrf.write(
                    salt.utils.stringutils.to_str(
                        save_format.format(
                            key_id,
                            secret_key,
                            "key_id-{}".format(key_num),
                            "key-{}".format(key_num),
                        )
                    )
                )
        ret["comment"] = "Keys have been written to file {}/{}.".format(save_dir, name)
        ret["result"] = True
        ret["changes"] = new_keys
        return ret
    except OSError:
        ret["comment"] = "Could not write to file {}/{}.".format(save_dir, name)
        ret["result"] = False
        return ret


def keys_absent(
    access_keys, user_name, region=None, key=None, keyid=None, profile=None
):
    """

    .. versionadded:: 2015.8.0

    Ensure the IAM user access_key_id is absent.

    access_key_id (list)
        A list of access key ids

    user_name (string)
        The username of the user

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret = {"name": access_keys, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_user"](user_name, region, key, keyid, profile):
        ret["result"] = False
        ret["comment"] = "IAM User {} does not exist.".format(user_name)
        return ret
    for k in access_keys:
        ret = _delete_key(ret, k, user_name, region, key, keyid, profile)
    return ret
<a name="30"></a>

def _delete_key(
    ret, access_key_id, user_name, region<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None
):
    keys = __salt__["boto_iam.get_all_access_keys"](
        user_name=user_name, region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    log.debug("Keys for user %s are : %s.", keys, user_name)
    if isinstance(keys, str):
        log.debug("Keys %s are a string. Something went wrong.", keys)
        ret["comment"] = " ".join(
            [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
        )
        return ret
    keys = keys["list_access_keys_response"]["list_access_keys_result"][
        "access_key_metadata"
    ]
    for k in keys:
<a name="18"></a>        log.debug(
            "Key is: %s and is compared with: %s", k["access_key_id"], access_key_id
        )
        if str(k<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["access_key_id"]) == str(access_key_id):
            if __opts__["test"]:
                ret["comment"] = "Access key {} is set to be deleted.".format(
                    access_key_id
                )
                ret["result"] = None
                return ret
            deleted = __salt__["boto_iam.delete_access_key"](</b></font>
                access_key_id, user_name, region, key, keyid, profile
            )
            if deleted:
                ret["comment"] = " ".join(
                    [ret["comment"], "Key {} has been deleted.".format(access_key_id)]
                )
                ret["changes"][access_key_id] = "deleted"
                return ret
            ret["comment"] = " ".join(
                [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
            )
            return ret
        ret["comment"] = " ".join([ret["comment"], "Key {} does not exist.".format(k)])
        return ret


def user_present(
<a name="23"></a>    name,
    policies=None,
    policies_from_pillars=None,
    managed_policies<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
    password=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """

    .. versionadded:: 2015.8.0

    Ensure the IAM user is present

    name (string)
        The name of the new user.

    policies (dict)
        A dict of IAM group policy documents.

    policies_from_pillars (list)
        A list of pillars that contain role policy dicts. Policies in the
        pillars will be merged in the order defined in the list and key
        conflicts will be handled by later defined keys overriding earlier
        defined keys. The policies defined here will be merged with the
        policies defined in the policies argument. If keys conflict, the keys
        in the policies argument will override the keys defined in
        policies_from_pillars.

    managed_policies (list)
        A list of managed policy names or ARNs that should be attached to this
        user.

    password (string)
        The password for the new user. Must comply with account policy.

    path (string)
        The path of the user. Default is '/'.

        .. versionadded:: 2015.8.2

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not policies:
        policies = {}
    if</b></font> not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__["pillar.get"](policy)
        _policies.update(_policy)
<a name="26"></a>    _policies.update(policies)
    exists = __salt__["boto_iam.get_user"](name, region, key, keyid, profile)
    if not exists:
        <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if __opts__["test"]:
            ret["comment"] = "IAM user {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_user"](</b></font>
            name, path, region, key, keyid, profile
        )
        if created:
            ret["changes"]["user"] = created
            ret["comment"] = " ".join(
                [ret["comment"], "User {} has been created.".format(name)]
            )
<a name="29"></a>            if password:
                ret = _case_password(ret, name, password, region, key, keyid, profile)
            _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
            ret["changes"] <font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= dictupdate.update(ret["changes"], _ret["changes"])
            ret["comment"] = " ".join([ret["comment"], _ret[</b></font>"comment"]])
    else:
        ret["comment"] = " ".join([ret["comment"], "User {} is present.".format(name)])
        if password:
            ret = _case_password(ret, name, password, region, key, keyid, profile)
        _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
<a name="8"></a>        ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    _ret = _user_policies_attached(name, managed_policies, region, key, keyid, profile)
    ret<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret[</b></font>"result"]
        return ret
    return ret


def _user_policies_present(
    name, policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__["boto_iam.get_user_policy"](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__["boto_iam.get_all_user_policies"](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    for policy_name in _list:
        if policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on user {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"policies": _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__["boto_iam.put_user_policy"](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.get_all_user_policies"](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} for user {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__["boto_iam.delete_user_policy"](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.get_all_user_policies"](
                    user_name=name, region=region, key=key, keyid=keyid, profile=profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to user {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.get_all_user_policies"](
            user_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret["changes"]["new"] = {"policies": _list}
        ret["comment"] = "{} policies modified on user {}.".format(
            ", ".join(_list), name
        )
    return ret


def _user_policies_attached(
    name, managed_policies=None, region=None, key=None, keyid=None, profile=None
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__["boto_iam.list_entities_for_policy"](
            policy,
            entity_filter="User",
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for userdict in entities.get("policy_users", []):
            if name == userdict.get("user_name"):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__["boto_iam.list_attached_user_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    for policy_data in _list:
        if (
            policy_data.get("policy_name") not in managed_policies
            and policy_data.get("policy_arn") not in managed_policies
        ):
            policies_to_detach.append(policy_data.get("policy_arn"))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on user {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"managed_policies": oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__["boto_iam.attach_user_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.list_attached_user_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to user {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__["boto_iam.detach_user_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.list_attached_user_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to remove policy {} from user {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.list_attached_user_policies"](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get("policy_arn") for x in _list]
        log.debug(newpolicies)
        ret["changes"]["new"] = {"managed_policies": newpolicies}
        ret["comment"] = "{} policies modified on user {}.".format(
            ", ".join(newpolicies), name
        )
<a name="20"></a>    return ret


def _user_policies_detached(name, region<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
<a name="11"></a>    _list = __salt__["boto_iam.list_attached_user_policies"](
        user_name=name, region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    oldpolicies <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [x.get("policy_arn") for x in _list]
    if not _list:
        ret["comment"] = "No attached policies in user {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be detached from user {}.".format(
            ", ".</b></font>join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"managed_policies": oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__["boto_iam.detach_user_policy"](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__["boto_iam.list_attached_user_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get("policy_arn") for x in _list]
            ret["changes"]["new"] = {"managed_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from user {}".format(policy_arn, name)
            return ret
    _list = __salt__["boto_iam.list_attached_user_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get("policy_arn") for x in _list]
    ret["changes"]["new"] = {"managed_policies": newpolicies}
<a name="5"></a>    ret["comment"] = "{} policies detached from user {}.".format(
        ", ".join(oldpolicies), name
    )
    <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret


def _user_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    oldpolicies = __salt__["boto_iam.get_all_user_policies"](
        user_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret["comment"] = "No inline policies in user {}.".</b></font>format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be deleted from user {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"inline_policies": oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__["boto_iam.delete_user_policy"](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__["boto_iam.get_all_user_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret["changes"]["new"] = {"inline_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from user {}".format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__["boto_iam.get_all_user_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    ret["changes"]["new"] = {"inline_policies": newpolicies}
    ret["comment"] = "{} policies deleted from user {}.".format(
        ", ".join(oldpolicies), name
    )
    return ret


def _case_password(
    ret, name, password, region=None, key=None, keyid=None, profile=None
):
    if __opts__["test"]:
        ret["comment"] = "Login policy for {} is set to be changed.".format(name)
        ret["result"] = None
        return ret
    login = __salt__["boto_iam.create_login_profile"](
        name, password, region, key, keyid, profile
    )
    log.debug("Login is : %s.", login)
    if login:
        if "Conflict" in login:
            ret["comment"] = " ".join(
                [ret["comment"], "Login profile for user {} exists.".format(name)]
            )
        else:
            ret["comment"] = " ".join(
                [ret["comment"], "Password has been added to User {}.".format(name)]
            )
            ret["changes"]["password"] = "REDACTED"
    else:
        ret["result"] = False
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "Password for user {} could not be set.\nPlease check your password"
                " policy.".format(name),
            ]
        )
    return ret


def group_absent(name, region=None, key=None, keyid=None, profile=None):
    """

    .. versionadded:: 2015.8.0

    Ensure the IAM group is absent.

    name (string)
        The name of the group.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if not __salt__["boto_iam.get_group"](name, region, key, keyid, profile):
        ret["result"] = True
        ret["comment"] = "IAM Group {} does not exist.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM group {} managed policies are set to be detached.".format(name),
            ]
        )
        ret["result"] = None
    else:
        _ret = _group_policies_detached(name, region, key, keyid, profile)
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [
                ret["comment"],
                "IAM group {} inline policies are set to be deleted.".format(name),
            ]
        )
        ret["result"] = None
    else:
        _ret = _group_policies_deleted(name, region, key, keyid, profile)
        ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
        if not _ret["result"]:
            ret["result"] = _ret["result"]
            if ret["result"] is False:
                return ret
    ret["comment"] = " ".join(
        [ret["comment"], "IAM group {} users are set to be removed.".format(name)]
    )
    existing_users = __salt__["boto_iam.get_group_members"](
<a name="7"></a>        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    _ret = _case_group(ret, [], name, existing_users, region, key, keyid, profile)
    ret<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret[</b></font>"result"]
        return ret
    # finally, actually delete the group
    if __opts__["test"]:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM group {} is set to be deleted.".format(name)]
        )
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_group"](name, region, key, keyid, profile)
    if deleted is True:
        ret["comment"] = " ".join(
            [ret["comment"], "IAM group {} is deleted.".format(name)]
        )
        ret["result"] = True
        ret["changes"]["deleted"] = name
<a name="17"></a>        return ret
    ret["comment"] = "IAM group {} could not be deleted.\n {}".format(name, deleted)
    ret["result"] = False
    <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret


def group_present(
    name,
    policies=None,
    policies_from_pillars=None,
    managed_policies=None,
    users=None,
    path="/",
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    """

    .. versionadded:: 2015.8.0

    Ensure the IAM group is present

    name (string)
        The name of the new group.

    path (string)
        The path for the group, defaults to '/'

    policies (dict)
        A dict of IAM group policy documents.

    policies_from_pillars (list)
        A list of pillars that contain role policy dicts. Policies in the
        pillars will be merged in the order defined in the list and key
        conflicts will be handled by later defined keys overriding earlier
        defined keys. The policies defined here will be merged with the
        policies defined in the policies argument. If keys conflict, the keys
        in the policies argument will override the keys defined in
        policies_from_pillars.

    managed_policies (list)
        A list of policy names or ARNs that should be attached to this group.

    users (list)
        A list of users to be added to the group.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.

    delete_policies (boolean)
        Delete or detach existing policies that are not in the given list of policies.
        Default value is ``True``. If ``False`` is specified, existing policies
        will not be deleted or detached allowing manual modifications on the IAM group
        to be persistent.
    """
    ret = {"name"</b></font>: name, "result": True, "comment": "", "changes": {}}
    if not policies:
        policies = {}
    if not policies_from_pillars:
        policies_from_pillars = []
    if not managed_policies:
        managed_policies = []
    _policies = {}
    for policy in policies_from_pillars:
        _policy = __salt__["pillar.get"](policy)
        _policies.update(_policy)
    _policies.update(policies)
    exists = __salt__["boto_iam.get_group"](
<a name="6"></a>        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not exists:
        <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if __opts__["test"]:
            ret["comment"] = "IAM group {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_group"](
            group_name=name,
            path=path,
            region=region,
            key=key,
            keyid=keyid,
            profile=</b></font>profile,
        )
        if not created:
            ret["comment"] = "Failed to create IAM group {}.".format(name)
            ret["result"] = False
            return ret
        ret["changes"]["group"] = created
        ret["comment"] = " ".join(
            [ret["comment"], "Group {} has been created.".format(name)]
        )
    else:
        ret["comment"] = " ".join([ret["comment"], "Group {} is present.".format(name)])
    # Group exists, ensure group policies and users are set.
    _ret = _group_policies_present(
        name, _policies, region, key, keyid, profile, delete_policies
    )
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        return ret
    _ret = _group_policies_attached(
        name, managed_policies, region, key, keyid, profile, delete_policies
    )
    ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
    ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
    if not _ret["result"]:
        ret["result"] = _ret["result"]
        return ret
    if users is not None:
        log.debug("Users are : %s.", users)
        existing_users = __salt__["boto_iam.get_group_members"](
            group_name=name, region=region, key=key, keyid=keyid, profile=profile
        )
        ret = _case_group(ret, users, name, existing_users, region, key, keyid, profile)
    return ret


def _case_group(ret, users, group_name, existing_users, region, key, keyid, profile):
    _users = []
    for user in existing_users:
        _users.append(user["user_name"])
    log.debug("upstream users are %s", _users)
    for user in users:
        log.debug("users are %s", user)
        if user in _users:
            log.debug("user exists")
            ret["comment"] = " ".join(
                [
                    ret["comment"],
                    "User {} is already a member of group {}.".format(user, group_name),
                ]
            )
            continue
        else:
            log.debug("user is set to be added %s", user)
            if __opts__["test"]:
                ret["comment"] = "User {} is set to be added to group {}.".format(
                    user, group_name
                )
                ret["result"] = None
            else:
                __salt__["boto_iam.add_user_to_group"](
                    user, group_name, region, key, keyid, profile
                )
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "User {} has been added to group {}.".format(user, group_name),
                    ]
                )
                ret["changes"][user] = group_name
    for user in _users:
        if user not in users:
            if __opts__["test"]:
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "User {} is set to be removed from group {}.".format(
                            user, group_name
                        ),
                    ]
                )
                ret["result"] = None
            else:
                __salt__["boto_iam.remove_user_from_group"](
                    group_name=group_name,
                    user_name=user,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
                ret["comment"] = " ".join(
                    [
                        ret["comment"],
                        "User {} has been removed from group {}.".format(
                            user, group_name
                        ),
                    ]
                )
                ret["changes"][user] = "Removed from group {}.".format(group_name)
    return ret


def _group_policies_present(
    name,
    policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    delete_policies=True,
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_create = {}
    policies_to_delete = []
    for policy_name, policy in policies.items():
        if isinstance(policy, str):
            dict_policy = salt.utils.json.loads(
                policy, object_pairs_hook=odict.OrderedDict
            )
        else:
            dict_policy = policy
        _policy = __salt__["boto_iam.get_group_policy"](
            name, policy_name, region, key, keyid, profile
        )
        if _policy != dict_policy:
            log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
            policies_to_create[policy_name] = policy
    _list = __salt__["boto_iam.get_all_group_policies"](
        name, region, key, keyid, profile
    )
    for policy_name in _list:
        if delete_policies and policy_name not in policies:
            policies_to_delete.append(policy_name)
    if policies_to_create or policies_to_delete:
        _to_modify = list(policies_to_delete)
        _to_modify.extend(policies_to_create)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on group {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"policies": _list}
        for policy_name, policy in policies_to_create.items():
            policy_set = __salt__["boto_iam.put_group_policy"](
                name, policy_name, policy, region, key, keyid, profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.get_all_group_policies"](
                    name, region, key, keyid, profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to group {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_delete:
            policy_unset = __salt__["boto_iam.delete_group_policy"](
                name, policy_name, region, key, keyid, profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.get_all_group_policies"](
                    name, region, key, keyid, profile
                )
                ret["changes"]["new"] = {"policies": _list}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to group {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.get_all_group_policies"](
            name, region, key, keyid, profile
        )
        ret["changes"]["new"] = {"policies": _list}
        ret["comment"] = "{} policies modified on group {}.".format(
            ", ".join(_list), name
        )
    return ret


def _group_policies_attached(
    name,
    managed_policies=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    detach_policies=True,
):
    ret = {"result": True, "comment": "", "changes": {}}
    policies_to_attach = []
    policies_to_detach = []
    for policy in managed_policies or []:
        entities = __salt__["boto_iam.list_entities_for_policy"](
            policy,
            entity_filter="Group",
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        found = False
        for groupdict in entities.get("policy_groups", []):
            if name == groupdict.get("group_name"):
                found = True
                break
        if not found:
            policies_to_attach.append(policy)
    _list = __salt__["boto_iam.list_attached_group_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies = [x.get("policy_arn") for x in _list]
    for policy_data in _list:
        if (
            detach_policies
            and policy_data.get("policy_name") not in managed_policies
            and policy_data.get("policy_arn") not in managed_policies
        ):
            policies_to_detach.append(policy_data.get("policy_arn"))
    if policies_to_attach or policies_to_detach:
        _to_modify = list(policies_to_detach)
        _to_modify.extend(policies_to_attach)
        if __opts__["test"]:
            ret["comment"] = "{} policies to be modified on group {}.".format(
                ", ".join(_to_modify), name
            )
            ret["result"] = None
            return ret
        ret["changes"]["old"] = {"managed_policies": oldpolicies}
        for policy_name in policies_to_attach:
            policy_set = __salt__["boto_iam.attach_group_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_set:
                _list = __salt__["boto_iam.list_attached_group_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to add policy {} to group {}".format(
                    policy_name, name
                )
                return ret
        for policy_name in policies_to_detach:
            policy_unset = __salt__["boto_iam.detach_group_policy"](
                policy_name, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not policy_unset:
                _list = __salt__["boto_iam.list_attached_group_policies"](
                    name, region=region, key=key, keyid=keyid, profile=profile
                )
                newpolicies = [x.get("policy_arn") for x in _list]
                ret["changes"]["new"] = {"managed_policies": newpolicies}
                ret["result"] = False
                ret["comment"] = "Failed to remove policy {} from group {}".format(
                    policy_name, name
                )
                return ret
        _list = __salt__["boto_iam.list_attached_group_policies"](
            name, region=region, key=key, keyid=keyid, profile=profile
        )
        newpolicies = [x.get("policy_arn") for x in _list]
        log.debug(newpolicies)
        ret["changes"]["new"] = {"managed_policies": newpolicies}
        ret["comment"] = "{} policies modified on group {}.".format(
            ", ".join(newpolicies), name
        )
<a name="19"></a>    return ret


def _group_policies_detached(name, region<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    _list = __salt__["boto_iam.list_attached_group_policies"](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    oldpolicies =</b></font> [x.get("policy_arn") for x in _list]
    if not _list:
        ret["comment"] = "No attached policies in group {}.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be detached from group {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"managed_policies": oldpolicies}
    for policy_arn in oldpolicies:
        policy_unset = __salt__["boto_iam.detach_group_policy"](
            policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_unset:
            _list = __salt__["boto_iam.list_attached_group_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            newpolicies = [x.get("policy_arn") for x in _list]
            ret["changes"]["new"] = {"managed_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from group {}".format(
                policy_arn, name
            )
            return ret
    _list = __salt__["boto_iam.list_attached_group_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
    newpolicies = [x.get("policy_arn") for x in _list]
    ret["changes"]["new"] = {"managed_policies": newpolicies}
    ret["comment"] = "{} policies detached from group {}.".format(
        ", ".join(newpolicies), name
    )
<a name="9"></a>    return ret


def _group_policies_deleted(name, region<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
    ret = {"result": True, "comment": "", "changes": {}}
    oldpolicies = __salt__["boto_iam.get_all_group_policies"](
        group_name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if not oldpolicies:
        ret["comment"] = "No inline policies in group {}.".</b></font>format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "{} policies to be deleted from group {}.".format(
            ", ".join(oldpolicies), name
        )
        ret["result"] = None
        return ret
    ret["changes"]["old"] = {"inline_policies": oldpolicies}
    for policy_name in oldpolicies:
        policy_deleted = __salt__["boto_iam.delete_group_policy"](
            name, policy_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not policy_deleted:
            newpolicies = __salt__["boto_iam.get_all_group_policies"](
                name, region=region, key=key, keyid=keyid, profile=profile
            )
            ret["changes"]["new"] = {"inline_policies": newpolicies}
            ret["result"] = False
            ret["comment"] = "Failed to detach {} from group {}".format(
                policy_name, name
            )
            return ret
    newpolicies = __salt__["boto_iam.get_all_group_policies"](
        name, region=region, key=key, keyid=keyid, profile=profile
<a name="12"></a>    )
    ret["changes"]["new"] = {"inline_policies": newpolicies}
    ret["comment"] = "{} policies deleted from group {}.".format(
        ", "<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.join(oldpolicies), name
    )
    return ret


def account_policy(
    name=None,
    allow_users_to_change_password=None,
    hard_expiry=None,
    max_password_age=None,
    minimum_password_length=None,
    password_reuse_prevention=None,
    require_lowercase_characters=None,
    require_numbers=None,
    require_symbols=None,
    require_uppercase_characters=None,
    region=None,
    key=</b></font>None,
    keyid=None,
    profile=None,
):
    """
    Change account policy.

    .. versionadded:: 2015.8.0

    name (string)
        The name of the account policy

    allow_users_to_change_password (bool)
        Allows all IAM users in your account to
        use the AWS Management Console to change their own passwords.

    hard_expiry (bool)
        Prevents IAM users from setting a new password after their
        password has expired.

    max_password_age (int)
        The number of days that an IAM user password is valid.

    minimum_password_length (int)
        The minimum number of characters allowed in an IAM user password.

    password_reuse_prevention (int)
        Specifies the number of previous passwords
        that IAM users are prevented from reusing.

    require_lowercase_characters (bool)
        Specifies whether IAM user passwords
        must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).

    require_numbers (bool)
        Specifies whether IAM user passwords must contain at
        least one numeric character (0 to 9).

    require_symbols (bool)
        Specifies whether IAM user passwords must contain at
        least one of the following non-alphanumeric characters: ! @ # $ % ^ &amp; * ( ) _ + - = [ ] { } | '

    require_uppercase_characters (bool)
        Specifies whether IAM user passwords must
        contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
    """
    config = locals()
    ret = {"name": "Account Policy", "result": True, "comment": "", "changes": {}}
    info = __salt__["boto_iam.get_account_policy"](region, key, keyid, profile)
    if not info:
        ret["comment"] = "Account policy is not Enabled."
        ret["result"] = False
        return ret
    for key, value in config.items():
        if key in ("region", "key", "keyid", "profile", "name"):
            continue
        if value is not None and str(info[key]) != str(value).lower():
            ret["comment"] = " ".join(
                [
                    ret["comment"],
                    "Policy value {} has been set to {}.".format(value, info[key]),
                ]
<a name="27"></a>            )
            ret["changes"][key] = str(value).lower()
    if not ret["changes"]:
        ret<font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "Account policy is not changed."
        return ret
    if __opts__["test"]:
        ret["comment"] = "Account policy is set to be changed."
        ret["result"] = None
        r</b></font>eturn ret
    if __salt__["boto_iam.update_account_password_policy"](
        allow_users_to_change_password,
        hard_expiry,
        max_password_age,
        minimum_password_length,
        password_reuse_prevention,
        require_lowercase_characters,
        require_numbers,
        require_symbols,
        require_uppercase_characters,
        region,
        key,
        keyid,
        profile,
    ):
        return ret
    ret["comment"] = "Account policy is not changed."
    ret["changes"] = {}
    ret["result"] = False
    return ret


def server_cert_absent(name, region=None, key=None, keyid=None, profile=None):
    """
    Deletes a server certificate.

    .. versionadded:: 2015.8.0

    name (string)
        The name for the server certificate. Do not include the path in this value.

    region (string)
        The name of the region to connect to.

    key (string)
        The key to be used in order to connect

    keyid (string)
        The keyid to be used in order to connect

    profile (string)
<a name="2"></a>        The profile that contains a dict of region, key, keyid
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    exists <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.get_server_certificate"](
        name, region, key, keyid, profile
    )
    if not exists:
        ret["comment"] = "Certificate {} does not exist.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "Server certificate {} is set to be deleted.".format(name)
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_server_cert"](</b></font>name, region, key, keyid, profile)
    if not deleted:
        ret["result"] = False
        ret["comment"] = "Certificate {} failed to be deleted.".format(name)
<a name="22"></a>        return ret
    ret["comment"] = "Certificate {} was deleted.".format(name)
    ret["changes"] = deleted
    <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret


def server_cert_present(
    name,
    public_key,
    private_key,
    cert_chain=None,
    path=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """
    Crete server certificate.

    .. versionadded:: 2015.8.0

    name (string)
        The name for the server certificate. Do not include the path in this value.

    public_key (string)
        The contents of the public key certificate in PEM-encoded format.

    private_key (string)
        The contents of the private key in PEM-encoded format.

    cert_chain (string)
        The contents of the certificate chain. This is typically a
        concatenation of the PEM-encoded public key certificates of the chain.

    path (string)
        The path for the server certificate.

    region (string)
        The name of the region to connect to.

    key (string)
        The key to be used in order to connect

    keyid (string)
        The keyid to be used in order to connect

    profile (string)
        The profile that contains a dict of region, key, keyid
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    exists = __salt__["boto_iam.get_server_certificate"](</b></font>
        name, region, key, keyid, profile
    )
    log.debug("Variables are : %s.", locals())
    if exists:
        ret["comment"] = "Certificate {} exists.".format(name)
        return ret
    if "salt://" in public_key:
        try:
            public_key = __salt__["cp.get_file_str"](public_key)
        except OSError as e:
            log.debug(e)
            ret["comment"] = "File {} not found.".format(public_key)
            ret["result"] = False
            return ret
    if "salt://" in private_key:
        try:
            private_key = __salt__["cp.get_file_str"](private_key)
        except OSError as e:
            log.debug(e)
            ret["comment"] = "File {} not found.".format(private_key)
            ret["result"] = False
            return ret
    if cert_chain is not None and "salt://" in cert_chain:
        try:
            cert_chain = __salt__["cp.get_file_str"](cert_chain)
        except OSError as e:
            log.debug(e)
            ret["comment"] = "File {} not found.".format(cert_chain)
            ret["result"] = False
            return ret
    if __opts__["test"]:
        ret["comment"] = "Server certificate {} is set to be created.".format(name)
        ret["result"] = None
        return ret
    created = __salt__["boto_iam.upload_server_cert"](
        name, public_key, private_key, cert_chain, path, region, key, keyid, profile
    )
    if created is not False:
        ret["comment"] = "Certificate {} was created.".format(name)
<a name="21"></a>        ret["changes"] = created
        return ret
    ret["result"] = False
    ret<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "Certificate {} failed to be created.".format(name)
    return ret


def policy_present(
    name,
    policy_document,
    path=None,
    description=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    """

    .. versionadded:: 2015.8.0

    Ensure the IAM managed policy is present

    name (string)
        The name of the new policy.

    policy_document (dict)
        The document of the new policy

    path (string)
        The path in which the policy will be created. Default is '/'.

    description (string)
        Description

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
    policy = __salt__["boto_iam.get_policy"](name, region, key, keyid, profile)
    if not policy:
        if __opts__["test"]:
            ret["comment"] = "IAM policy {} is set to be created.".format(name)
            ret["result"] = None
            return ret
        created = __salt__["boto_iam.create_policy"](
            name, policy_document, path, description, region, key, keyid, profile
        )
        if created:
            ret["changes"]["policy"] = created
            ret["comment"] = " ".join(
                [ret["comment"], "Policy {} has been created.".format(name)]
            )
        else:
            ret["result"] = False
            ret["comment"] = "Failed to update policy."
            ret["changes"] = {}
            return ret
    else:
        policy = policy.get("policy", {})
        ret["comment"] = " ".join(
            [ret["comment"], "Policy {} is present.".format(name)]
        )
        _describe = __salt__["boto_iam.get_policy_version"](
            name, policy.get("default_version_id"), region, key, keyid, profile
        ).get("policy_version", {})
        if isinstance(_describe["document"], str):
            describeDict = salt.utils.json.loads(_describe["document"])
        else:
            describeDict = _describe["document"]

        if isinstance(policy_document, str):
            policy_document = salt.utils.json.loads(policy_document)

        r = salt.utils.data.compare_dicts(describeDict, policy_document)

        if bool(r):
            if __opts__["test"]:
                ret["comment"] = "Policy {} set to be modified.".format(name)
                ret["result"] = None
                return ret

<a name="4"></a>            ret["comment"] = " ".join([ret["comment"], "Policy to be modified"])
            policy_document = salt.utils.json.dumps(policy_document)

            r <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.create_policy_version"](
                policy_name=name,
                policy_document=policy_document,
                set_as_default=True,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r.get("created"):
                ret["result"] = False
                ret["comment"] = "Failed to update policy: {}.".format(
                    r["error"][</b></font>"message"]
                )
                ret["changes"] = {}
                return ret

            __salt__["boto_iam.delete_policy_version"](
                policy_name=name,
                version_id=policy["default_version_id"],
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )

            ret["changes"].setdefault("new", {})["document"] = policy_document
            ret["changes"].setdefault("old", {})["document"] = _describe["document"]
<a name="25"></a>    return ret


def policy_absent(name, region<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
    """

    .. versionadded:: 2015.8.0

    Ensure the IAM managed policy with the specified name is absent

    name (string)
        The name of the new policy.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}

<a name="0"></a>    r = __salt__["boto_iam.policy_exists"](
        name, region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if not r:
        ret["comment"] = "Policy {} does not exist.".format(name)
        return ret

    if __opts__["test"]:
        ret["comment"] = "Policy {} is set to be removed.".format(name)
        ret["result"] = None
        return ret
    # delete non-default versions
    versions = __salt__["boto_iam.list_policy_versions"](
        name, region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    if versions:
        for version in versions:
            if version.get("is_default_version", False) in ("true", True):
                continue
            r = __salt__["boto_iam.delete_policy_version"](
                name,
                version_id=version.get("version_id"),
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not r:
                ret["result"] = False
                ret["comment"] = "Failed to delete policy {}.".format(name)
                return ret
    r = __salt__["boto_iam.delete_policy"](
        name, region=region, key=key, keyid=keyid, profile=profile
    )
<a name="3"></a>    if not r:
        ret["result"] = False
        ret["comment"] = "Failed to delete policy {}.".format(name)
        <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
    ret["changes"]["old"] = {"policy": name}
    ret["changes"]["new"] = {"policy": None}
    ret["comment"] = "Policy {} deleted.".format(name)
    return ret


def saml_provider_present(
    name, saml_metadata_document, region=None, key=None, keyid=None, profile=None
):
    """
    .. versionadded:: 2016.11.0

    Ensure the SAML provider with the specified name is present.

    name (string)
        The name of the SAML provider.

    saml_metadata_document (string)
        The xml document of the SAML provider.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
    if "salt://" in saml_metadata_document:
        try:
            saml_metadata_document = __salt__["cp.get_file_str"](saml_metadata_document)
            ET.fromstring(saml_metadata_document)
        except OSError as e:
            log.debug(e)
            ret[
                "comment"
            ] = "SAML document file {} not found or could not be loaded".format(name)
            ret["result"] = False
            return ret
    for provider in __salt__["boto_iam.list_saml_providers"](
        region=region, key=key, keyid=keyid, profile=profile
    ):
<a name="13"></a>        if provider == name:
            ret["comment"] = "SAML provider {} is present.".format(name)
            return ret
    <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if __opts__["test"]:
        ret["comment"] = "SAML provider {} is set to be create.".format(name)
        ret["result"] = None
        return ret
    created = __salt__["boto_iam.create_saml_provider"](
        name,
        saml_metadata_document,
        region=region,
        key=key,
        keyid=keyid,
        profile=</b></font>profile,
    )
    if created:
        ret["comment"] = "SAML provider {} was created.".format(name)
        ret["changes"]["new"] = name
        return ret
    ret["result"] = False
    ret["comment"] = "SAML provider {} failed to be created.".format(name)
<a name="24"></a>    return ret


def saml_provider_absent(name, region<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
    """
    .. versionadded:: 2016.11.0

    Ensure the SAML provider with the specified name is absent.

    name (string)
        The name of the SAML provider.

    saml_metadata_document (string)
        The xml document of the SAML provider.

    region (string)
        Region to connect to.

    key (string)
        Secret key to be used.

    keyid (string)
        Access key to be used.

    profile (dict)
        A dict with region, key and keyid, or a pillar key (string)
        that contains a dict with region, key and keyid.
    """
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    provider = __salt__["boto_iam.list_saml_providers"](
<a name="1"></a>        region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    if len(provider) == 0:
        ret<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "SAML provider {} is absent.".format(name)
        return ret
    if __opts__["test"]:
        ret["comment"] = "SAML provider {} is set to be removed.".format(name)
        ret["result"] = None
        return ret
    deleted = __salt__["boto_iam.delete_saml_provider"](
        name, region=region, key=key, keyid=keyid, profile=</b></font>profile
    )
    if deleted is not False:
        ret["comment"] = "SAML provider {} was deleted.".format(name)
        ret["changes"]["old"] = name
        return ret
    ret["result"] = False
    ret["comment"] = "SAML provider {} failed to be deleted.".format(name)
    return ret


def _get_error(error):
    # Converts boto exception to string that can be used to output error.
    error = "\n".join(error.split("\n")[1:])
    error = ET.fromstring(error)
    code = error[0][1].text
    message = error[0][2].text
    return code, message
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
