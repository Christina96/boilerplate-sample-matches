<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto_vpc.py &amp; boto_iam.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto_vpc.py &amp; boto_iam.py
      </h3>
<h1 align="center">
        20.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto_vpc.py (24.013159%)<th>boto_iam.py (18.263044%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(296-305)<td><a href="#" name="0">(1885-1895)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(980-991)<td><a href="#" name="1">(2022-2029)</a><td align="center"><font color="#f40000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(509-520)<td><a href="#" name="2">(1626-1636)</a><td align="center"><font color="#f40000">23</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(310-323)<td><a href="#" name="3">(1919-1953)</a><td align="center"><font color="#e90000">22</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1632-1644)<td><a href="#" name="4">(1826-1838)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1504-1535)<td><a href="#" name="5">(878-887)</a><td align="center"><font color="#df0000">21</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(230-241)<td><a href="#" name="6">(1121-1131)</a><td align="center"><font color="#c90000">19</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1125-1128)<td><a href="#" name="7">(1018-1021)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(1109-1112)<td><a href="#" name="8">(676-679)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(465-504)<td><a href="#" name="9">(1448-1454)</a><td align="center"><font color="#bf0000">18</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(1545-1552)<td><a href="#" name="10">(428-434)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(823-830)<td><a href="#" name="11">(846-852)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(532-602)<td><a href="#" name="12">(1482-1499)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(431-440)<td><a href="#" name="13">(1971-1981)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(160-180)<td><a href="#" name="14">(153-207)</a><td align="center"><font color="#b40000">17</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(1834-1845)<td><a href="#" name="15">(261-272)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(1093-1097)<td><a href="#" name="16">(334-338)</a><td align="center"><font color="#aa0000">16</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(1004-1080)<td><a href="#" name="17">(1040-1105)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(670-675)<td><a href="#" name="18">(555-562)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(261-288)<td><a href="#" name="19">(1406-1411)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#4e9258")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4e9258"><font color="#4e9258">-</font><td><a href="#" name="20">(936-969)<td><a href="#" name="20">(841-844)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#947010")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#947010"><font color="#947010">-</font><td><a href="#" name="21">(844-856)<td><a href="#" name="21">(1734-1779)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#4cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#4cc417"><font color="#4cc417">-</font><td><a href="#" name="22">(787-815)<td><a href="#" name="22">(1643-1691)</a><td align="center"><font color="#940000">14</font>
<tr onclick='openModal("#f660ab")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f660ab"><font color="#f660ab">-</font><td><a href="#" name="23">(1391-1405)<td><a href="#" name="23">(583-640)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#79764d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#79764d"><font color="#79764d">-</font><td><a href="#" name="24">(1196-1204)<td><a href="#" name="24">(1992-2019)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#5eac10")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#5eac10"><font color="#5eac10">-</font><td><a href="#" name="25">(1139-1150)<td><a href="#" name="25">(1857-1883)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#68818b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#68818b"><font color="#68818b">-</font><td><a href="#" name="26">(906-910)<td><a href="#" name="26">(651-655)</a><td align="center"><font color="#8a0000">13</font>
<tr onclick='openModal("#e77471")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#e77471"><font color="#e77471">-</font><td><a href="#" name="27">(1719-1725)<td><a href="#" name="27">(1576-1581)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#717d7d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#717d7d"><font color="#717d7d">-</font><td><a href="#" name="28">(890-900)<td><a href="#" name="28">(289-297)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#af7a82")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#af7a82"><font color="#af7a82">-</font><td><a href="#" name="29">(739-743)<td><a href="#" name="29">(666-667)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#ae694a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ae694a"><font color="#ae694a">-</font><td><a href="#" name="30">(629-640)<td><a href="#" name="30">(536-539)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_vpc.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.dictupdate as dictupdate
3 __virtualname__ = "boto_vpc"
4 log = logging.getLogger(__name__)
5 def __virtual__():
6     """
7     <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if "boto_vpc.exists" in __salt__:
8         return __virtualname__
9     else:
10         return (
11             False,
12             "The following libraries are required to run the boto_vpc state module: "
13             "boto &gt;= {} and boto3 &gt;= {}.".format(boto_version, boto3_version),
14         )
15 def present(
16     name,
17     cidr_block,
18     instance_tenancy=None,
19     dns_support=None,
20     dns_hostnames=None,
21     tags=None,
22     region=None,
23     key=None,
24     keyid=None,
25     profile=</b></font>None,
26 ):
27     """
28     Ensure VPC exists.
29     name
30         Name of the VPC.
31     cidr_block
32         The range of IPs in CIDR format, for example: 10.0.0.0/24. Block
33         size must be between /16 and /28 netmask.
34     instance_tenancy
35         Instances launched in this VPC will be ingle-tenant or dedicated
36         hardware.
37     dns_support
38         Indicates whether the DNS resolution is supported for the VPC.
39     dns_hostnames
40         Indicates whether the instances launched in the VPC get DNS hostnames.
41     tags
42         A list of tags.
43     region
44         Region to connect to.
45     key
46         Secret key to be used.
47     keyid
48         Access key to be used.
49     profile
50         A dict with region, key and keyid, or a pillar key (string) that
51         contains a dict with region, key and keyid.
52     """
53     ret = {"name": name, "result": True, "comment": "", "changes": {}}
54     r = __salt__["boto_vpc.exists"](
55         name=name, tags=tags, region=region, key=key, keyid=keyid, profile=profile
56     )
57     if "error" in r:
58         ret["result"] = False
59         ret["comment"] = "Failed to create VPC: {}.".format(r["error"]["message"])
60     if not r.get("exists"):
61         <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if __opts__["test"]:
62             ret["comment"] = "VPC {} is set to be created.".format(name)
63             ret["result"] = None
64             return ret
65         r = __salt__["boto_vpc.create"](
66             cidr_block,
67             instance_tenancy=instance_tenancy,
68             vpc_name=name,
69             enable_dns_support=dns_support,
70             enable_dns_hostnames=dns_hostnames,
71             tags=tags,
72             region=</b></font>region,
73             key=key,
74             keyid=keyid,
75             profile=profile,
76         )
77         if not r.get("created"):
78             ret["result"] = False
79             ret["comment"] = "Error in creating VPC: {}.".format(r["error"]["message"])
80             return ret
81         _describe = __salt__["boto_vpc.describe"](
82             vpc_id=r["id"], region=region, key=key, keyid=keyid, profile=profile
83         )
84         ret["changes"]["old"] = {"vpc": None}
85         ret["changes"]["new"] = _describe
86         ret["comment"] = "VPC {} created.".format(name)
87         return ret
88     ret["comment"] = "VPC present."
89 def absent(name, tags=None, region<font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None):
90     """
91     Ensure VPC with passed properties is absent.
92     name
93         Name of the VPC.
94     tags
95         A list of tags. All tags must match.
96     region
97         Region to connect to.
98     key
99         Secret key to be used.
100     keyid
101         Access key to be used.
102     profile
103         A dict with region, key and keyid, or a pillar key (string) that
104         contains a dict with region, key and keyid.
105     """
106     ret = {"name": name, "result": True, "comment": "", "changes": {}}
107     r = __salt__["boto_vpc.get_id"](
108         name=name, tags=tags, region=region, key=key, keyid=keyid, profile=</b></font>profile
109     )
110     if "error" in r:
111         ret["result"] = False
112         ret["comment"] = "Failed to delete VPC: {}.".format(r["error"]["message"])
113     _id = r.get("id")
114     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not _id:
115         ret["comment"] = "{} VPC does not exist.".format(name)
116         return ret
117     if __opts__["test"]:
118         ret["comment"] = "VPC {} is set to be removed.".format(name)
119         ret["result"] = None
120         return ret
121     r = __salt__["boto_vpc.delete"](
122         vpc_name=name, tags=tags, region=region, key=</b></font>key, keyid=keyid, profile=profile
123     )
124         ret["result"] = False
125         ret["comment"] = "Failed to delete VPC: {}.".format(r["error"]["message"])
126         <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
127     ret["changes"]["old"] = {"vpc": _id}
128     ret["changes"]["new"] = {"vpc": None}
129     ret["comment"] = "VPC {} deleted.".format(name)
130     return ret
131 def dhcp_options_present(
132     name,
133     dhcp_options_id=None,
134     vpc_name=None,
135     vpc_id=None,
136     domain_name=None,
137     domain_name_servers=</b></font>None,
138     ntp_servers=None,
139     netbios_name_servers=None,
140     netbios_node_type=None,
141     tags=None,
142     region=None,
143     key=None,
144     keyid=None,
145     profile=None,
146 ):
147     """
148     Ensure a set of DHCP options with the given settings exist.
149     Note that the current implementation only SETS values during option set
150     creation.  It is unable to update option sets in place, and thus merely
151     verifies the set exists via the given name and/or dhcp_options_id param.
152     name
153         (string)
154         Name of the DHCP options.
155     vpc_name
156         (string)
157         Name of a VPC to which the options should be associated.  Either
158         vpc_name or vpc_id must be provided.
159     vpc_id
160         (string)
161         Id of a VPC to which the options should be associated.  Either
162         vpc_name or vpc_id must be provided.
163     domain_name
164         (string)
165         Domain name to be assiciated with this option set.
166     domain_name_servers
167         (list of strings)
168         The IP address(es) of up to four domain name servers.
169     ntp_servers
170         (list of strings)
171         The IP address(es) of up to four desired NTP servers.
172     netbios_name_servers
173         (list of strings)
174         The IP address(es) of up to four NetBIOS name servers.
175     netbios_node_type
176         (string)
177         The NetBIOS node type (1, 2, 4, or 8).  For more information about
178         the allowed values, see RFC 2132.  The recommended is 2 at this
179         time (broadcast and multicast are currently not supported).
180     tags
181         (dict of key:value pairs)
182         A set of tags to be added.
183     region
184         (string)
185         Region to connect to.
186     key
187         (string)
188         Secret key to be used.
189     keyid
190         (string)
191         Access key to be used.
192     profile
193         (various)
194         A dict with region, key and keyid, or a pillar key (string) that
195         contains a dict with region, key and keyid.
196     .. versionadded:: 2016.3.0
197     """
198     ret = {"name": name, "result": True, "comment": "", "changes": {}}
199     _new = {
200         "domain_name": domain_name,
201         "domain_name_servers": domain_name_servers,
202         "ntp_servers": ntp_servers,
203         "netbios_name_servers": netbios_name_servers,
204         "netbios_node_type": netbios_node_type,
205     }
206     r = __salt__["boto_vpc.dhcp_options_exists"](
207         dhcp_options_id=dhcp_options_id,
208         dhcp_options_name=name,
209         region=region,
210         key=key,
211         keyid=keyid,
212         profile=profile,
213     )
214     if "error" in r:
215         ret["result"] = False
216         ret["comment"] = "Failed to validate DHCP options: {}.".format(
217             r["error"]["message"]
218         )
219         return ret
220     if r.get("exists"):
221         return ret
222     else:
223         <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if __opts__["test"]:
224             ret["comment"] = "DHCP options {} are set to be created.".format(name)
225             ret["result"] = None
226             return ret
227         r = __salt__["boto_vpc.create_dhcp_options"](
228             domain_name=domain_name,
229             domain_name_servers=domain_name_servers,
230             ntp_servers=ntp_servers,
231             netbios_name_servers=</b></font>netbios_name_servers,
232             netbios_node_type=netbios_node_type,
233             dhcp_options_name=name,
234             tags=tags,
235             vpc_id=vpc_id,
236             vpc_name=vpc_name,
237             region=region,
238             key=key,
239             keyid=keyid,
240             profile=profile,
241         )
242         if not r.get("created"):
243             ret["result"] = False
244             ret["comment"] = "Failed to create DHCP options: {}".format(
245                 r["error"]["message"]
246             )
247             return ret
248         ret["changes"]["old"] = {"dhcp_options": None}
249         ret["changes"]["new"] = {"dhcp_options": _new}
250         ret["comment"] = "DHCP options {} created.".format(name)
251         return ret
252 def dhcp_options_absent(
253     name=None, dhcp_options_id=None, region<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None
254 ):
255     """
256     Ensure a set of DHCP options with the given settings exist.
257     name
258         (string)
259         Name of the DHCP options set.
260     dhcp_options_id
261         (string)
262         Id of the DHCP options set.
263     region
264         (string)
265         Region to connect to.
266     key
267         (string)
268         Secret key to be used.
269     keyid
270         (string)
271         Access key to be used.
272     profile
273         (various)
274         A dict with region, key and keyid, or a pillar key (string) that
275         contains a dict with region, key and keyid.
276     .. versionadded:: 2016.3.0
277     """
278     ret = {"name": name, "result": True, "comment": "", "changes": {}}
279     r = __salt__["boto_vpc.get_resource_id"](
280         "dhcp_options", name=name, region=region, key=key, keyid=keyid, profile=profile
281     )
282     if "error" in r:
283         ret["result"] = False
284         ret[</b></font>"comment"] = "Failed to delete DHCP options: {}.".format(
285             r["error"]["message"]
286         return ret
287     _id <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= r.get("id")
288     if not _id:
289         ret["comment"] = "DHCP options {} do not exist.".format(name)
290         return ret
291     if __opts__["test"]:
292         ret["comment"] = "DHCP options {} are set to be deleted.".format(name)
293         ret["result"] = None
294         return ret
295     r = __salt__["boto_vpc.delete_dhcp_options"](</b></font>
296         dhcp_options_id=r["id"], region=region, key=key, keyid=keyid, profile=profile
297     )
298     if not r.get("deleted"):
299         ret["result"] = False
300         ret["comment"] = "Failed to delete DHCP options: {}".format(
301             r["error"]["message"]
302         )
303         return ret
304     ret["changes"]["old"] = {"dhcp_options": _id}
305     ret["changes"]["new"] = {"dhcp_options": None}
306     ret["comment"] = "DHCP options {} deleted."<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.format(name)
307     return ret
308 def subnet_present(
309     name,
310     cidr_block,
311     vpc_name=None,
312     vpc_id=None,
313     availability_zone=None,
314     tags=None,
315     region=None,
316     key=None,
317     keyid=None,
318     profile=None,
319     route_table_id=None,
320     route_table_name=None,
321     auto_assign_public_ipv4=False,
322 ):
323     """
324     Ensure a subnet exists.
325     name
326         Name of the subnet.
327     cidr_block
328         The range if IPs for the subnet, in CIDR format. For example:
329         10.0.0.0/24. Block size must be between /16 and /28 netmask.
330     vpc_name
331         Name of the VPC in which the subnet should be placed. Either
332         vpc_name or vpc_id must be provided.
333     vpc_id
334         Id of the VPC in which the subnet should be placed. Either vpc_name
335         or vpc_id must be provided.
336     availability_zone
337         AZ in which the subnet should be placed.
338     tags
339         A list of tags.
340     route_table_id
341         A route table ID to explicitly associate the subnet with.  If both route_table_id
342         and route_table_name are specified, route_table_id will take precedence.
343         .. versionadded:: 2016.11.0
344     route_table_name
345         A route table name to explicitly associate the subnet with.  If both route_table_id
346         and route_table_name are specified, route_table_id will take precedence.
347         .. versionadded:: 2016.11.0
348     region
349         Region to connect to.
350     key
351         Secret key to be used.
352     keyid
353         Access key to be used.
354     profile
355         A dict with region, key and keyid, or a pillar key (string) that
356         contains a dict with region, key and keyid.
357     """
358     ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
359     r = __salt__["boto_vpc.subnet_exists"](
360         subnet_name=name,
361         tags=tags,
362         region=region,
363         key=key,
364         keyid=keyid,
365         profile=profile,
366     )
367     if "error" in r:
368         ret["result"] = False
369         ret["comment"] = "Failed to create subnet: {}.".format(r["error"]["message"])
370         return ret
371     route_table_desc = None
372     _describe = None
373     rtid = None
374     if route_table_id or route_table_name:
375         rt = None
376         route_table_found = False
377         if route_table_id:
378             rtid = route_table_id
379                 route_table_id=route_table_id,
380                 region=region,
381                 key<font color="#ae694a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=key,
382                 keyid=keyid,
383                 profile=profile,
384             )
385         elif route_table_name:
386             rtid = route_table_name
387             rt = __salt__["boto_vpc.route_table_exists"](
388                 route_table_name=route_table_name,
389                 region=region,
390                 key=key,
391                 keyid=keyid,
392                 profile=</b></font>profile,
393             )
394         if rt:
395             if "exists" in rt:
396                 if rt["exists"]:
397                     if route_table_id:
398                         route_table_found = True
399                         route_table_desc = __salt__["boto_vpc.describe_route_tables"](
400                             route_table_id=route_table_id,
401                             region=region,
402                             key=key,
403                             keyid=keyid,
404                             profile=profile,
405                         )
406                     elif route_table_name:
407                         route_table_found = True
408                         route_table_desc = __salt__["boto_vpc.describe_route_tables"](
409                             route_table_name=route_table_name,
410                             region=region,
411                             key=key,
412                             keyid=keyid,
413                             profile=profile,
414                         )
415         if not route_table_found:
416             ret["result"] = False
417             ret["comment"] = "The specified route table {} could not be found.".format(
418                 rtid
419             return ret
420     if not r<font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get("exists"):
421         if __opts__["test"]:
422             ret["comment"] = "Subnet {} is set to be created.".format(name)
423             ret["result"] = None
424             return ret
425         r = __salt__["boto_vpc.create_subnet"](</b></font>
426             subnet_name=name,
427             cidr_block=cidr_block,
428             availability_zone=availability_zone,
429             auto_assign_public_ipv4=auto_assign_public_ipv4,
430             vpc_name=vpc_name,
431             vpc_id=vpc_id,
432             tags=tags,
433             region=region,
434             key=key,
435             keyid=keyid,
436             profile=profile,
437         )
438         if not r.get("created"):
439             ret["result"] = False
440             ret["comment"] = "Failed to create subnet: {}".format(r["error"]["message"])
441             return ret
442         _describe = __salt__["boto_vpc.describe_subnet"](
443             subnet_id=r["id"], region=region, key=key, keyid=keyid, profile=profile
444         )
445         ret["changes"]["old"] = {"subnet": None}
446         ret["changes"]["new"] = _describe
447         ret["comment"] = "Subnet {} created.".format(name)
448     else:
449         ret["comment"] = "Subnet present."
450     if route_table_desc:
451         if not _describe:
452             _describe = __salt__["boto_vpc.describe_subnet"](
453                 subnet_name=name, region=region, key=key, keyid=keyid, profile=profile
454             )
455         if not _verify_subnet_association(route_table_desc, _describe["subnet"]["id"]):
456             if __opts__["test"]:
457                 msg = "Subnet is set to be associated with route table {}".format(rtid)
458                 ret["comment"] = " ".join([ret["comment"], msg])
459                 ret["result"] = None
460                 return ret
461             if "explicit_route_table_association_id" in _describe["subnet"]:
462                 log.debug("Need to disassociate from existing route table")
463                 drt_ret = __salt__["boto_vpc.disassociate_route_table"](
464                     _describe["subnet"]["explicit_route_table_association_id"],
465                     region=region,
466                     key=key,
467                     keyid=keyid,
468                     profile=profile,
469                 )
470                 if not drt_ret["disassociated"]:
471                     msg = "Unable to disassociate subnet {} with its current route table.".format(
472                         name
473                     )
474                     ret["comment"] = " ".join([ret["comment"], msg])
475                     ret["result"] = False
476                     return ret
477             if "old" not in ret["changes"]:
478                 ret["changes"]["old"] = _describe
479             art_ret = __salt__["boto_vpc.associate_route_table"](
480                 route_table_id=route_table_desc["id"],
481                 subnet_name=name,
482                 region=region,
483                 key=key,
484                 keyid=keyid,
485             )
486             if "error" in art_ret:
487                 msg <font color="#af7a82"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "Failed to associate subnet {} with route table {}: {}.".format(
488                     name, rtid, art_ret["error"]["message"]
489                 )
490                 ret["comment"] = " ".join([ret["comment"], msg])
491                 ret[</b></font>"result"] = False
492                 return ret
493             else:
494                 msg = "Subnet successfully associated with route table {}.".format(rtid)
495                 ret["comment"] = " ".join([ret["comment"], msg])
496                 if "new" not in ret["changes"]:
497                     ret["changes"]["new"] = __salt__["boto_vpc.describe_subnet"](
498                         subnet_name=name,
499                         region=region,
500                         key=key,
501                         keyid=keyid,
502                         profile=profile,
503                     )
504                 else:
505                     ret["changes"]["new"]["subnet"][
506                         "explicit_route_table_association_id"
507                     ] = art_ret["association_id"]
508         else:
509             ret["comment"] = " ".join(
510                 [
511                     ret["comment"],
512                     "Subnet is already associated with route table {}".format(rtid),
513                 ]
514             )
515     return ret
516 def _verify_subnet_association(route_table_desc, subnet_id):
517     """
518     Helper function verify a subnet's route table association
519     route_table_desc
520         the description of a route table, as returned from boto_vpc.describe_route_tables
521     subnet_id
522         the subnet id to verify
523     .. versionadded:: 2016.11.0
524     """
525     if route_table_desc:
526         if "associations" in route_table_desc:
527                 if association["subnet_id"] == subnet_id:
528                     return True
529     <font color="#4cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return False
530 def subnet_absent(
531     name=None, subnet_id=None, region=None, key=None, keyid=None, profile=None
532 ):
533     """
534     Ensure subnet with passed properties is absent.
535     name
536         Name of the subnet.
537     region
538         Region to connect to.
539     key
540         Secret key to be used.
541     keyid
542         Access key to be used.
543     profile
544         A dict with region, key and keyid, or a pillar key (string) that
545         contains a dict with region, key and keyid.
546     """
547     ret = {"name": name, "result": True, "comment": "", "changes": {}}
548     r = __salt__["boto_vpc.get_resource_id"](</b></font>
549         "subnet", name=name, region=region, key=key, keyid=keyid, profile=profile
550     )
551     if "error" in r:
552         ret["result"] = False
553         return ret
554     _id <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= r.get("id")
555     if not _id:
556         ret["comment"] = "{} subnet does not exist.".format(name)
557         return ret
558     if __opts__["test"]:
559         ret["comment"] = "Subnet {} ({}) is set to be removed.".format(name, r[</b></font>"id"])
560         ret["result"] = None
561         return ret
562     r = __salt__["boto_vpc.delete_subnet"](
563         subnet_name=name, region=region, key=key, keyid=keyid, profile=profile
564     )
565     if not r.get("deleted"):
566         ret["result"] = False
567         ret["comment"] = "Failed to delete subnet: {}".format(r["error"]["message"])
568         return ret
569     ret["changes"]["old"] = {"subnet": _id}
570     ret["changes"]["new"] = {"subnet": None}
571     ret<font color="#947010"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Subnet {} deleted.".format(name)
572     return ret
573 def internet_gateway_present(
574     name,
575     vpc_name=None,
576     vpc_id=None,
577     tags=None,
578     region=None,
579     key=None,
580     keyid=None,
581     profile=</b></font>None,
582 ):
583     """
584     Ensure an internet gateway exists.
585     name
586         Name of the internet gateway.
587     vpc_name
588         Name of the VPC to which the internet gateway should be attached.
589     vpc_id
590         Id of the VPC to which the internet_gateway should be attached.
591         Only one of vpc_name or vpc_id may be provided.
592     tags
593         A list of tags.
594     region
595         Region to connect to.
596     key
597         Secret key to be used.
598     keyid
599         Access key to be used.
600     profile
601         A dict with region, key and keyid, or a pillar key (string) that
602         contains a dict with region, key and keyid.
603     """
604     ret = {"name": name, "result": True, "comment": "", "changes": {}}
605     r <font color="#717d7d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= __salt__["boto_vpc.resource_exists"](
606         "internet_gateway",
607         name=name,
608         region=region,
609         key=key,
610         keyid=keyid,
611         profile=profile,
612     )
613     if "error" in r:
614         ret["result"] = False
615         ret[</b></font>"comment"] = "Failed to create internet gateway: {}.".format(
616             r["error"]["message"]
617         )
618     if not r.get("exists"):
619         <font color="#68818b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if __opts__["test"]:
620             ret["comment"] = "Internet gateway {} is set to be created.".format(name)
621             ret["result"] = None
622             return ret
623         r = __salt__["boto_vpc.create_internet_gateway"](</b></font>
624             internet_gateway_name=name,
625             vpc_name=vpc_name,
626             vpc_id=vpc_id,
627             tags=tags,
628             region=region,
629             key=key,
630             keyid=keyid,
631             profile=profile,
632         )
633         if not r.get("created"):
634             ret["result"] = False
635             ret["comment"] = "Failed to create internet gateway: {}".format(
636                 r["error"]["message"]
637             )
638             return ret
639         ret["changes"]["old"] = {"internet_gateway": None}
640         ret["changes"]["new"] = {"internet_gateway": r["id"]}
641         ret["comment"] = "Internet gateway {} created.".format(name)
642         return ret
643     ret["comment"] = "Internet gateway {} present.".format(name)
644     return ret
645 def internet_gateway_absent(
646     name, detach=False, region<font color="#4e9258"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None
647 ):
648     """
649     Ensure the named internet gateway is absent.
650     name
651         Name of the internet gateway.
652     detach
653         First detach the internet gateway from a VPC, if attached.
654     region
655         Region to connect to.
656     key
657         Secret key to be used.
658     keyid
659         Access key to be used.
660     profile
661         A dict with region, key and keyid, or a pillar key (string) that
662         contains a dict with region, key and keyid.
663     """
664     ret = {"name": name, "result": True, "comment": "", "changes": {}}
665     r = __salt__["boto_vpc.get_resource_id"](
666         "internet_gateway",
667         name=name,
668         region=region,
669         key=key,
670         keyid=keyid,
671         profile=</b></font>profile,
672     )
673     if "error" in r:
674         ret["result"] = False
675         ret["comment"] = "Failed to delete internet gateway: {}.".format(
676             r["error"]["message"]
677         )
678         return ret
679     igw_id = r["id"]
680     if not igw_id:
681         ret<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Internet gateway {} does not exist.".format(name)
682         return ret
683     if __opts__["test"]:
684         ret["comment"] = "Internet gateway {} is set to be removed.".format(name)
685         ret["result"] = None
686         return ret
687     r = __salt__["boto_vpc.delete_internet_gateway"](
688         internet_gateway_name=name,
689         detach=detach,
690         region=region,
691         key=</b></font>key,
692         keyid=keyid,
693         profile=profile,
694     )
695     if not r.get("deleted"):
696         ret["result"] = False
697         ret["comment"] = "Failed to delete internet gateway: {}.".format(
698             r["error"]["message"]
699         )
700         return ret
701     ret["changes"]["new"] = {"internet_gateway": None}
702     ret["comment"] = "Internet gateway {} deleted.".format(name)
703     <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
704 def route_table_present(
705     name,
706     vpc_name=None,
707     vpc_id=None,
708     routes=None,
709     subnet_ids=None,
710     subnet_names=None,
711     tags=None,
712     region=None,
713     key=None,
714     keyid=None,
715     profile=None,
716 ):
717     """
718     Ensure route table with routes exists and is associated to a VPC.
719     This function requires boto3 to be installed if nat gatewyas are specified.
720     Example:
721     .. code-block:: yaml
722         boto_vpc.route_table_present:
723           - name: my_route_table
724           - vpc_id: vpc-123456
725           - routes:
726             - destination_cidr_block: 0.0.0.0/0
727               internet_gateway_name: InternetGateway
728             - destination_cidr_block: 10.10.11.0/24
729               instance_id: i-123456
730             - destination_cidr_block: 10.10.12.0/24
731               interface_id: eni-123456
732             - destination_cidr_block: 10.10.13.0/24
733               instance_name: mygatewayserver
734           - subnet_names:
735             - subnet1
736             - subnet2
737     name
738         Name of the route table.
739     vpc_name
740         Name of the VPC with which the route table should be associated.
741     vpc_id
742         Id of the VPC with which the route table should be associated.
743         Either vpc_name or vpc_id must be provided.
744     routes
745         A list of routes.  Each route has a cidr and a target.
746     subnet_ids
747         A list of subnet ids to associate
748     subnet_names
749         A list of subnet names to associate
750     tags
751         A list of tags.
752     region
753         Region to connect to.
754     key
755         Secret key to be used.
756     keyid
757         Access key to be used.
758     profile
759         A dict with region, key and keyid, or a pillar key (string) that
760         contains a dict with region, key and keyid.
761     """
762     ret = {"name"</b></font>: name, "result": True, "comment": "", "changes": {}}
763     _ret = _route_table_present(
764         name=name,
765         vpc_name=vpc_name,
766         vpc_id=vpc_id,
767         tags=tags,
768         region=region,
769         key=key,
770         keyid=keyid,
771     )
772     ret["changes"] = _ret["changes"]
773     ret<font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = " ".join([ret["comment"], _ret["comment"]])
774     if not _ret["result"]:
775         ret["result"] = _ret["result"]
776         if ret["result"] is False:
777             r</b></font>eturn ret
778         if ret["result"] is None and __opts__["test"]:
779             return ret
780     _ret = _routes_present(
781         route_table_name=name,
782         routes=routes,
783         tags=tags,
784         region=region,
785         key=key,
786         profile=profile,
787     )
788     ret<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
789     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
790     if not _ret["result"]:
791         ret["result"] = _ret[</b></font>"result"]
792         if ret["result"] is False:
793             return ret
794     _ret = _subnets_present(
795         route_table_name=name,
796         subnet_ids=subnet_ids,
797         subnet_names=subnet_names,
798         tags=tags,
799         region=region,
800         key=key,
801         profile=profile,
802     )
803     ret<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
804     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
805     if not _ret["result"]:
806         ret["result"] = _ret[</b></font>"result"]
807         if ret["result"] is False:
808             return ret
809     return ret
810 def _route_table_present(
811     name,
812     vpc_id=None,
813     tags=None,
814     region<font color="#5eac10"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
815     key=None,
816     keyid=None,
817     profile=None,
818 ):
819     ret = {"name": name, "result": True, "comment": "", "changes": {}}
820     r = __salt__["boto_vpc.get_resource_id"](
821         resource="route_table",
822         name=name,
823         region=region,
824         key=</b></font>key,
825         keyid=keyid,
826         profile=profile,
827     )
828     if "error" in r:
829         ret["result"] = False
830         ret["comment"] = "Failed to create route table: {}.".format(
831             r["error"]["message"]
832         )
833         return ret
834     _id = r.get("id")
835     if not _id:
836         if __opts__["test"]:
837             msg = "Route table {} is set to be created.".format(name)
838             ret["comment"] = msg
839             ret["result"] = None
840             return ret
841         r = __salt__["boto_vpc.create_route_table"](
842             route_table_name=name,
843             vpc_name=vpc_name,
844             vpc_id=vpc_id,
845             tags=tags,
846             region=region,
847             key=key,
848             keyid=keyid,
849             profile=profile,
850         )
851         if not r.get("created"):
852             ret["result"] = False
853             ret["comment"] = "Failed to create route table: {}.".format(
854                 r["error"]["message"]
855             )
856             return ret
857         ret["changes"]["old"] = {"route_table": None}
858         ret["changes"]["new"] = {"route_table": r["id"]}
859         ret["comment"] = "Route table {} created.".format(name)
860         return ret
861     ret["comment"] = "Route table {} ({}) present.".format(name, _id)
862     return ret
863 def _routes_present(
864     route_table_name, routes, tags=None, region<font color="#79764d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, key=None, keyid=None, profile=None
865 ):
866     ret = {"name": route_table_name, "result": True, "comment": "", "changes": {}}
867     route_table = __salt__["boto_vpc.describe_route_tables"](
868         route_table_name=route_table_name,
869         tags=tags,
870         region=region,
871         key=</b></font>key,
872         keyid=keyid,
873         profile=profile,
874     )
875     if "error" in route_table:
876         msg = "Could not retrieve configuration for route table {}: {}`.".format(
877             route_table_name, route_table["error"]["message"]
878         )
879         ret["comment"] = msg
880         ret["result"] = False
881         return ret
882     route_table = route_table[0]
883     _routes = []
884     if routes:
885         route_keys = {
886             "gateway_id",
887             "instance_id",
888             "destination_cidr_block",
889             "interface_id",
890             "vpc_peering_connection_id",
891             "nat_gateway_id",
892         }
893         for i in routes:
894             _r = {}
895             for k, v in i.items():
896                 if k in route_keys:
897                     _r[k] = i[k]
898             if i.get("internet_gateway_name"):
899                 r = __salt__["boto_vpc.get_resource_id"](
900                     "internet_gateway",
901                     name=i["internet_gateway_name"],
902                     region=region,
903                     key=key,
904                     keyid=keyid,
905                     profile=profile,
906                 )
907                 if "error" in r:
908                     msg = "Error looking up id for internet gateway {}: {}".format(
909                         i.get("internet_gateway_name"), r["error"]["message"]
910                     )
911                     ret["comment"] = msg
912                     ret["result"] = False
913                     return ret
914                 if r["id"] is None:
915                     msg = "Internet gateway {} does not exist.".format(i)
916                     ret["comment"] = msg
917                     ret["result"] = False
918                     return ret
919                 _r["gateway_id"] = r["id"]
920             if i.get("vpc_peering_connection_name"):
921                 r = __salt__["boto_vpc.get_resource_id"](
922                     "vpc_peering_connection",
923                     name=i["vpc_peering_connection_name"],
924                     region=region,
925                     key=key,
926                     keyid=keyid,
927                     profile=profile,
928                 )
929                 if "error" in r:
930                     msg = (
931                         "Error looking up id for VPC peering connection {}: {}".format(
932                             i.get("vpc_peering_connection_name"), r["error"]["message"]
933                         )
934                     )
935                     ret["comment"] = msg
936                     ret["result"] = False
937                     return ret
938                 if r["id"] is None:
939                     msg = "VPC peering connection {} does not exist.".format(i)
940                     ret["comment"] = msg
941                     ret["result"] = False
942                     return ret
943                 _r["vpc_peering_connection_id"] = r["id"]
944             if i.get("instance_name"):
945                 running_states = (
946                     "pending",
947                     "rebooting",
948                     "running",
949                     "stopping",
950                     "stopped",
951                 )
952                 r = __salt__["boto_ec2.get_id"](
953                     name=i["instance_name"],
954                     region=region,
955                     key=key,
956                     keyid=keyid,
957                     profile=profile,
958                     in_states=running_states,
959                 )
960                 if r is None:
961                     msg = "Instance {} does not exist.".format(i["instance_name"])
962                     ret["comment"] = msg
963                     ret["result"] = False
964                     return ret
965                 _r["instance_id"] = r
966             if i.get("nat_gateway_subnet_name"):
967                 r = __salt__["boto_vpc.describe_nat_gateways"](
968                     subnet_name=i["nat_gateway_subnet_name"],
969                     region=region,
970                     key=key,
971                     keyid=keyid,
972                     profile=profile,
973                 )
974                 if not r:
975                     msg = "Nat gateway does not exist."
976                     ret["comment"] = msg
977                     ret["result"] = False
978                     return ret
979                 _r["nat_gateway_id"] = r[0]["NatGatewayId"]
980             _routes.append(_r)
981     to_delete = []
982     to_create = []
983     for route in _routes:
984         if route not in route_table["routes"]:
985             to_create.append(dict(route))
986     for route in route_table["routes"]:
987         if route not in _routes:
988             if route.get("gateway_id") != "local":
989                 to_delete.append(route)
990     if to_create or to_delete:
991         if __opts__["test"]:
992             msg = "Route table {} set to have routes modified.".format(route_table_name)
993             ret["comment"] = msg
994             ret["result"] = None
995             return ret
996         if to_delete:
997             for r in to_delete:
998                 res = __salt__["boto_vpc.delete_route"](
999                     route_table_id=route_table["id"],
1000                     destination_cidr_block=r["destination_cidr_block"],
1001                     region=region,
1002                     key=key,
1003                     keyid=keyid,
1004                     profile=profile,
1005                 )
1006                 if not res["deleted"]:
1007                     msg = "Failed to delete route {} from route table {}: {}.".format(
1008                         r["destination_cidr_block"],
1009                         route_table_name,
1010                         res["error"]["message"],
1011                     )
1012                     ret["comment"] = msg
1013                     ret["result"] = False
1014                     return ret
1015                 ret["comment"] = "Deleted route {} from route table {}.".format(
1016                     r["destination_cidr_block"], route_table_name
1017                 )
1018         if to_create:
1019             for r in to_create:
1020                 res = __salt__["boto_vpc.create_route"](
1021                     route_table_id=route_table["id"],
1022                     region=region,
1023                     key=key,
1024                     keyid=keyid,
1025                     profile=profile,
1026                     **r
1027                 )
1028                 if not res["created"]:
1029                     msg = "Failed to create route {} in route table {}: {}.".format(
1030                         r["destination_cidr_block"],
1031                         route_table_name,
1032                         res["error"]["message"],
1033                     )
1034                     ret["comment"] = msg
1035                     ret["result"] = False
1036                     return ret
1037                 ret["comment"] = "Created route {} in route table {}.".format(
1038                     r["destination_cidr_block"], route_table_name
1039                 )
1040         ret["changes"]["old"] = {"routes": route_table["routes"]}
1041         route = __salt__["boto_vpc.describe_route_tables"](
1042             route_table_name=route_table_name,
1043             tags=tags,
1044             region=region,
1045             key=key,
1046             keyid=keyid,
1047             profile=profile,
1048         )
1049         ret["changes"]["new"] = {"routes": route[0]["routes"]}
1050     return ret
1051 def _subnets_present(
1052     route_table_name,
1053     subnet_ids<font color="#f660ab"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None,
1054     subnet_names=None,
1055     tags=None,
1056     region=None,
1057     key=None,
1058     keyid=None,
1059     profile=None,
1060 ):
1061     ret = {"name": route_table_name, "result": True, "comment": "", "changes": {}}
1062     if not subnet_ids:
1063         subnet_ids = []
1064     if</b></font> subnet_names:
1065         for i in subnet_names:
1066             r = __salt__["boto_vpc.get_resource_id"](
1067                 "subnet", name=i, region=region, key=key, keyid=keyid, profile=profile
1068             )
1069             if "error" in r:
1070                 msg = "Error looking up subnet ids: {}".format(r["error"]["message"])
1071                 ret["comment"] = msg
1072                 ret["result"] = False
1073                 return ret
1074             if r["id"] is None:
1075                 msg = "Subnet {} does not exist.".format(i)
1076                 ret["comment"] = msg
1077                 ret["result"] = False
1078                 return ret
1079             subnet_ids.append(r["id"])
1080     route_table = __salt__["boto_vpc.describe_route_tables"](
1081         route_table_name=route_table_name,
1082         tags=tags,
1083         region=region,
1084         key=key,
1085         keyid=keyid,
1086         profile=profile,
1087     )
1088     if not route_table:
1089         msg = "Could not retrieve configuration for route table {}.".format(
1090             route_table_name
1091         )
1092         ret["comment"] = msg
1093         ret["result"] = False
1094         return ret
1095     assoc_ids = [x["subnet_id"] for x in route_table["associations"]]
1096     to_create = [x for x in subnet_ids if x not in assoc_ids]
1097     to_delete = []
1098     for x in route_table["associations"]:
1099         if x["subnet_id"] not in subnet_ids and x["subnet_id"] is not None:
1100             to_delete.append(x["id"])
1101     if to_create or to_delete:
1102         if __opts__["test"]:
1103             msg = "Subnet associations for route table {} set to be modified.".format(
1104                 route_table_name
1105             )
1106             ret["comment"] = msg
1107             ret["result"] = None
1108             return ret
1109         if to_delete:
1110             for r_asc in to_delete:
1111                 r = __salt__["boto_vpc.disassociate_route_table"](
1112                     r_asc, region, key, keyid, profile
1113                 )
1114                 if "error" in r:
1115                     msg = "Failed to dissociate {} from route table {}: {}.".format(
1116                         r_asc, route_table_name, r["error"]["message"]
1117                     )
1118                     ret["comment"] = msg
1119                     ret["result"] = False
1120                     return ret
1121                 ret["comment"] = "Dissociated subnet {} from route table {}.".format(
1122                     r_asc, route_table_name
1123                 )
1124         if to_create:
1125             for sn in to_create:
1126                 r = __salt__["boto_vpc.associate_route_table"](
1127                     route_table_id=route_table["id"],
1128                     subnet_id=sn,
1129                     region=region,
1130                     key=key,
1131                     keyid=keyid,
1132                     profile=profile,
1133                 )
1134                 if "error" in r:
1135                     msg = (
1136                         "Failed to associate subnet {} with route table {}: {}.".format(
1137                             sn, route_table_name, r["error"]["message"]
1138                         )
1139                     )
1140                     ret["comment"] = msg
1141                     ret["result"] = False
1142                     return ret
1143                 ret["comment"] = "Associated subnet {} with route table {}.".format(
1144                     sn, route_table_name
1145                 )
1146         ret["changes"]["old"] = {"subnets_associations": route_table["associations"]}
1147         new_sub = __salt__["boto_vpc.describe_route_tables"](
1148             route_table_name=route_table_name,
1149             tags=tags,
1150             region=region,
1151             key=key,
1152             keyid=keyid,
1153         )
1154         ret["changes"]["new"] = {"subnets_associations": new_sub["associations"]}
1155     <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
1156 def route_table_absent(name, region=None, key=None, keyid=None, profile=None):
1157     """
1158     Ensure the named route table is absent.
1159     name
1160         Name of the route table.
1161     region
1162         Region to connect to.
1163     key
1164         Secret key to be used.
1165     keyid
1166         Access key to be used.
1167     profile
1168         A dict with region, key and keyid, or a pillar key (string) that
1169         contains a dict with region, key and keyid.
1170     """
1171     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1172     r = __salt__["boto_vpc.get_resource_id"](
1173         "route_table", name=name, region=region, key=key, keyid=keyid, profile=profile
1174     )
1175     if "error" in r:
1176         ret["result"] = False
1177         ret[</b></font>"comment"] = r["error"]["message"]
1178         return ret
1179     rtbl_id = r["id"]
1180     if not rtbl_id:
1181         ret["comment"] = "Route table {} does not exist.".format(name)
1182     if __opts__["test"]:
1183         ret<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Route table {} is set to be removed.".format(name)
1184         ret["result"] = None
1185         return ret
1186     r = __salt__["boto_vpc.delete_route_table"](
1187         route_table_name=name, region=region, key=key, keyid=keyid, profile=profile
1188     )
1189     if</b></font> "error" in r:
1190         ret["result"] = False
1191         ret["comment"] = "Failed to delete route table: {}".format(
1192             r["error"]["message"]
1193         )
1194         return ret
1195     ret["changes"]["old"] = {"route_table": rtbl_id}
1196     ret["changes"]["new"] = {"route_table": None}
1197     ret["comment"] = "Route table {} deleted.".format(name)
1198     return ret
1199 def nat_gateway_present(
1200     name,
1201     subnet_name=None,
1202     subnet_id=None,
1203     region=None,
1204     key=None,
1205     keyid=None,
1206     profile=None,
1207     allocation_id=None,
1208 ):
1209     """
1210     Ensure a nat gateway exists within the specified subnet
1211     This function requires boto3.
1212     .. versionadded:: 2016.11.0
1213     Example:
1214     .. code-block:: yaml
1215         boto_vpc.nat_gateway_present:
1216           - subnet_name: my-subnet
1217     name
1218         Name of the state
1219     subnet_name
1220         Name of the subnet within which the nat gateway should exist
1221     subnet_id
1222         Id of the subnet within which the nat gateway should exist.
1223         Either subnet_name or subnet_id must be provided.
1224     allocation_id
1225         If specified, the elastic IP address referenced by the ID is
1226         associated with the gateway. Otherwise, a new allocation_id is created and used.
1227     region
1228         Region to connect to.
1229     key
1230         Secret key to be used.
1231     keyid
1232         Access key to be used.
1233     profile
1234         A dict with region, key and keyid, or a pillar key (string) that
1235         contains a dict with region, key and keyid.
1236     """
1237     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1238     r = __salt__["boto_vpc.describe_nat_gateways"](
1239         subnet_name=subnet_name,
1240         subnet_id=subnet_id,
1241         region=region,
1242         key=key,
1243         keyid=keyid,
1244         profile=profile,
1245     )
1246     if not r:
1247         if __opts__["test"]:
1248             msg = "Nat gateway is set to be created."
1249             ret["comment"] = msg
1250             return ret
1251         r <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= __salt__["boto_vpc.create_nat_gateway"](
1252             subnet_name=subnet_name,
1253             subnet_id=subnet_id,
1254             region=region,
1255             key=key,
1256             keyid=keyid,
1257             profile=profile,
1258             allocation_id=allocation_id,
1259         )
1260         if not r.get("created"):
1261             ret["result"] = False
1262             ret["comment"] = "Failed to create nat gateway: {}.".format(
1263                 r["error"][</b></font>"message"]
1264             )
1265             return ret
1266         ret["changes"]["old"] = {"nat_gateway": None}
1267         ret["changes"]["new"] = {"nat_gateway": r["id"]}
1268         ret["comment"] = "Nat gateway created."
1269         return ret
1270     inst = r[0]
1271     _id = inst.get("NatGatewayId")
1272     ret["comment"] = "Nat gateway {} present.".format(_id)
1273     return ret
1274 def nat_gateway_absent(
1275     name=None,
1276     subnet_name=None,
1277     subnet_id=None,
1278     region=None,
1279     key=None,
1280     keyid=None,
1281     profile=None,
1282     wait_for_delete_retries=0,
1283 ):
1284     """
1285     Ensure the nat gateway in the named subnet is absent.
1286     This function requires boto3.
1287     .. versionadded:: 2016.11.0
1288     name
1289         Name of the state.
1290     subnet_name
1291         Name of the subnet within which the nat gateway should exist
1292     subnet_id
1293         Id of the subnet within which the nat gateway should exist.
1294         Either subnet_name or subnet_id must be provided.
1295     region
1296         Region to connect to.
1297     key
1298         Secret key to be used.
1299     keyid
1300         Access key to be used.
1301     profile
1302         A dict with region, key and keyid, or a pillar key (string) that
1303         contains a dict with region, key and keyid.
1304     wait_for_delete_retries
1305         NAT gateway may take some time to be go into deleted or failed state.
1306         During the deletion process, subsequent release of elastic IPs may fail;
1307         this state will automatically retry this number of times to ensure
1308         the NAT gateway is in deleted or failed state before proceeding.
1309         Default is set to 0 for backward compatibility.
1310     """
1311     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1312     r = __salt__["boto_vpc.describe_nat_gateways"](
1313         subnet_name=subnet_name,
1314         subnet_id=subnet_id,
1315         region=region,
1316         key=key,
1317         keyid=keyid,
1318     )
1319     if not r:
1320         ret<font color="#e77471"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["comment"] = "Nat gateway does not exist."
1321         return ret
1322     if __opts__["test"]:
1323         ret["comment"] = "Nat gateway is set to be removed."
1324         ret["result"] = None
1325         r</b></font>eturn ret
1326     for gw in r:
1327         rtbl_id = gw.get("NatGatewayId")
1328         r = __salt__["boto_vpc.delete_nat_gateway"](
1329             nat_gateway_id=rtbl_id,
1330             release_eips=True,
1331             region=region,
1332             key=key,
1333             keyid=keyid,
1334             profile=profile,
1335             wait_for_delete=True,
1336             wait_for_delete_retries=wait_for_delete_retries,
1337         )
1338         if "error" in r:
1339             ret["result"] = False
1340             ret["comment"] = "Failed to delete nat gateway: {}".format(
1341                 r["error"]["message"]
1342             )
1343             return ret
1344         ret["comment"] = ", ".join(
1345             (ret["comment"], "Nat gateway {} deleted.".format(rtbl_id))
1346         )
1347     ret["changes"]["old"] = {"nat_gateway": rtbl_id}
1348     ret["changes"]["new"] = {"nat_gateway": None}
1349     return ret
1350 def accept_vpc_peering_connection(
1351     name=None,
1352     conn_id=None,
1353     conn_name=None,
1354     region=None,
1355     key=None,
1356     keyid=None,
1357     profile=None,
1358 ):
1359     """
1360     Accept a VPC pending requested peering connection between two VPCs.
1361     name
1362         Name of this state
1363     conn_id
1364         The connection ID to accept. Exclusive with conn_name. String type.
1365     conn_name
1366         The name of the VPC peering connection to accept. Exclusive with conn_id. String type.
1367     region
1368         Region to connect to.
1369     key
1370         Secret key to be used.
1371     keyid
1372         Access key to be used.
1373     profile
1374         A dict with region, key and keyid, or a pillar key (string) that
1375         contains a dict with region, key and keyid.
1376     .. versionadded:: 2016.11.0
1377     Example:
1378     .. code-block:: yaml
1379         boto_vpc.accept_vpc_peering_connection:
1380           - conn_name: salt_peering_connection
1381         boto_vpc.accept_vpc_peering_connection:
1382           - conn_id: pbx-1873d472
1383           - region: us-west-2
1384     """
1385     log.debug("Called state to accept VPC peering connection")
1386     pending = __salt__["boto_vpc.is_peering_connection_pending"](
1387         conn_id=conn_id,
1388         conn_name=conn_name,
1389         region=region,
1390         key=key,
1391         keyid=keyid,
1392         profile=profile,
1393     )
1394     ret = {
1395         "name": name,
1396         "result": True,
1397         "changes": {},
1398         "comment": "Boto VPC peering state",
1399     }
1400     if not pending:
1401         ret["result"] = True
1402         ret["changes"].update(
1403             {"old": "No pending VPC peering connection found. Nothing to be done."}
1404         )
1405         return ret
1406     if __opts__["test"]:
1407         ret["changes"].update(
1408             {"old": "Pending VPC peering connection found and can be accepted"}
1409         )
1410     fun = "boto_vpc.accept_vpc_peering_connection"
1411     log.debug("Calling `%s()` to accept this VPC peering connection", fun)
1412     result <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= __salt__[fun](
1413         conn_id=conn_id,
1414         name=conn_name,
1415         region=region,
1416         key=key,
1417         keyid=keyid,
1418         profile=profile,
1419     )
1420     if "error" in result:
1421         ret["comment"] = "Failed to accept VPC peering: {}".format(result["error"])
1422         ret[</b></font>"result"] = False
1423         return ret
1424     ret["changes"].update({"old": "", "new": result["msg"]})
1425     return ret
1426 def request_vpc_peering_connection(
1427     name,
1428     requester_vpc_id=None,
1429     requester_vpc_name=None,
1430     peer_vpc_id=None,
1431     peer_vpc_name=None,
1432     conn_name=None,
1433     peer_owner_id=None,
1434     peer_region=None,
1435     region=None,
1436     key=None,
1437     keyid=None,
1438     profile=None,
1439 ):
1440     """
1441     name
1442         Name of the state
1443     requester_vpc_id
1444         ID of the requesting VPC. Exclusive with requester_vpc_name. String type.
1445     requester_vpc_name
1446         Name tag of the requesting VPC.  Exclusive with requester_vpc_id.  String type.
1447     peer_vpc_id
1448         ID of the VPC tp crete VPC peering connection with.  This can be a VPC in another account. Exclusive with peer_vpc_name. String type.
1449     peer_vpc_name
1450         Name tag of the VPC tp crete VPC peering connection with.  This can only be a VPC the same account and region. Exclusive with peer_vpc_id.  String type.
1451     conn_name
1452         The (optional) name to use for this VPC peering connection. String type.
1453     peer_owner_id
1454         ID of the owner of the peer VPC. String type. If this isn't supplied AWS uses your account ID.  Required if peering to a different account.
1455     peer_region
1456         Region of peer VPC. For inter-region vpc peering connections. Not required for intra-region peering connections.
1457         .. versionadded:: 3005
1458     region
1459         Region to connect to.
1460     key
1461         Secret key to be used.
1462     keyid
1463         Access key to be used.
1464     profile
1465         A dict with region, key and keyid, or a pillar key (string) that
1466         contains a dict with region, key and keyid.
1467     .. versionadded:: 2016.11.0
1468     Example:
1469     .. code-block:: yaml
1470         request a vpc peering connection:
1471           boto_vpc.request_vpc_peering_connection:
1472             - requester_vpc_id: vpc-4b3522e
1473             - peer_vpc_id: vpc-ae83f9ca
1474             - conn_name: salt_peering_connection
1475     """
1476     log.debug("Called state to request VPC peering connection")
1477     ret = {
1478         "name": name,
1479         "result": True,
1480         "changes": {},
1481         "comment": "Boto VPC peering state",
1482     }
1483     if conn_name:
1484         vpc_ids = __salt__["boto_vpc.describe_vpc_peering_connection"](
1485             conn_name, region=region, key=key, keyid=keyid, profile=profile
1486         ).get("VPC-Peerings", [])
1487     else:
1488         vpc_ids = []
1489     if vpc_ids:
1490         ret["comment"] = "VPC peering connection already exists, nothing to be done."
1491         return ret
1492     if __opts__["test"]:
1493         if not vpc_ids:
1494             ret["comment"] = "VPC peering connection will be created"
1495         return ret
1496     log.debug("Called module to create VPC peering connection")
1497     result = __salt__["boto_vpc.request_vpc_peering_connection"](
1498         requester_vpc_id,
1499         requester_vpc_name,
1500         peer_vpc_id,
1501         peer_vpc_name,
1502         name=conn_name,
1503         peer_owner_id=peer_owner_id,
1504         peer_region=peer_region,
1505         region=region,
1506         key=key,
1507         keyid=keyid,
1508         profile=profile,
1509     )
1510     if "error" in result:
1511         ret["comment"] = "Failed to request VPC peering: {}".format(result["error"])
1512         ret["result"] = False
1513         return ret
1514     ret["changes"].update({"old": "", "new": result["msg"]})
1515     return ret
1516 def vpc_peering_connection_present(
1517     name,
1518     requester_vpc_id=None,
1519     requester_vpc_name=None,
1520     peer_vpc_id=None,
1521     peer_vpc_name=None,
1522     conn_name=None,
1523     peer_owner_id=None,
1524     peer_region=None,
1525     region=None,
1526     key=None,
1527     keyid=None,
1528     profile=None,
1529 ):
1530     """
1531     name
1532         Name of the state
1533     requester_vpc_id
1534         ID of the requesting VPC. Exclusive with requester_vpc_name.
1535     requester_vpc_name
1536         Name tag of the requesting VPC.  Exclusive with requester_vpc_id.
1537     peer_vpc_id
1538         ID of the VPC tp crete VPC peering connection with. This can be a VPC in
1539         another account. Exclusive with peer_vpc_name.
1540     peer_vpc_name
1541         Name tag of the VPC tp crete VPC peering connection with. This can only
1542         be a VPC in the same account, else resolving it into a vpc ID will fail.
1543         Exclusive with peer_vpc_id.
1544     conn_name
1545         The name to use for this VPC peering connection.
1546     peer_owner_id
1547         ID of the owner of the peer VPC. Defaults to your account ID, so a value
1548         is required if peering with a VPC in a different account.
1549     peer_region
1550         Region of peer VPC. For inter-region vpc peering connections. Not required
1551         for intra-region peering connections.
1552         .. versionadded:: 3005
1553     region
1554         Region to connect to.
1555     key
1556         Secret key to be used.
1557     keyid
1558         Access key to be used.
1559     profile
1560         A dict with region, key and keyid, or a pillar key (string) that
1561         contains a dict with region, key and keyid.
1562     .. versionadded:: 2016.11.0
1563     Example:
1564     .. code-block:: yaml
1565         ensure peering twixt local vpc and the other guys:
1566           boto_vpc.vpc_peering_connection_present:
1567             - requester_vpc_name: my_local_vpc
1568             - peer_vpc_name: some_other_guys_vpc
1569             - conn_name: peering_from_here_to_there
1570             - peer_owner_id: 012345654321
1571     """
1572     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1573     if __salt__["boto_vpc.is_peering_connection_pending"](
1574         conn_name=conn_name, region=region, key=key, keyid=keyid, profile=profile
1575     ):
1576         if __salt__["boto_vpc.peering_connection_pending_from_vpc"](
1577             conn_name=conn_name,
1578             vpc_id=requester_vpc_id,
1579             vpc_name=requester_vpc_name,
1580             region=region,
1581             key=key,
1582             keyid=keyid,
1583             profile=profile,
1584         ):
1585             ret[
1586                 "comment"
1587             ] = "VPC peering {} already requested - pending acceptance by {}".format(
1588                 conn_name, peer_owner_id or peer_vpc_name or peer_vpc_id
1589             )
1590             log.info(ret["comment"])
1591             return ret
1592         return accept_vpc_peering_connection(
1593             name=name,
1594             conn_name=conn_name,
1595             region=region,
1596             key=key,
1597             keyid=keyid,
1598             profile=profile,
1599         )
1600     return request_vpc_peering_connection(
1601         name=name,
1602         requester_vpc_id=requester_vpc_id,
1603         requester_vpc_name=requester_vpc_name,
1604         peer_vpc_id=peer_vpc_id,
1605         peer_vpc_name=peer_vpc_name,
1606         conn_name=conn_name,
1607         peer_owner_id=peer_owner_id,
1608         peer_region=peer_region,
1609         region=region,
1610         key=key,
1611         keyid=keyid,
1612         profile=profile,
1613     )
1614 def vpc_peering_connection_absent(
1615     name, conn_id=None, conn_name=None, region=None, key=None, keyid=None, profile=None
1616 ):
1617     return delete_vpc_peering_connection(
1618         name, conn_id, conn_name, region, key, keyid, profile
1619     )
1620 def delete_vpc_peering_connection(
1621     name, conn_id=None, conn_name=None, region=None, key=None, keyid=None, profile=None
1622 ):
1623     """
1624     name
1625         Name of the state
1626     conn_id
1627         ID of the peering connection to delete.  Exclusive with conn_name.
1628     conn_name
1629         The name of the peering connection to delete.  Exclusive with conn_id.
1630     region
1631         Region to connect to.
1632     key
1633         Secret key to be used.
1634     keyid
1635         Access key to be used.
1636     profile
1637         A dict with region, key and keyid, or a pillar key (string) that
1638         contains a dict with region, key and keyid.
1639     .. versionadded:: 2016.11.0
1640     Example:
1641     .. code-block:: yaml
1642         delete a vpc peering connection:
1643           boto_vpc.delete_vpc_peering_connection:
1644             - region: us-west-2
1645             - conn_id: pcx-4613b12e
1646     Connection name can be specified (instead of ID).
1647     Specifying both conn_name and conn_id will result in an
1648     error.
1649     .. code-block:: yaml
1650         delete a vpc peering connection:
1651           boto_vpc.delete_vpc_peering_connection:
1652             - conn_name: salt_vpc_peering
1653     """
1654     log.debug("Called state to delete VPC peering connection")
1655     ret = {
1656         "name": name,
1657         "result": True,
1658         "changes": {},
1659         "comment": "Boto VPC peering state",
1660     }
1661     if conn_name:
1662         vpc_ids = __salt__["boto_vpc.describe_vpc_peering_connection"](
1663             conn_name, region=region, key=key, keyid=keyid, profile=profile
1664         ).get("VPC-Peerings", [])
1665     else:
1666         vpc_ids = [conn_id]
1667     if not vpc_ids:
1668         ret["comment"] = "No VPC connection found, nothing to be done."
1669         return ret
1670     if __opts__["test"]:
1671         if vpc_ids:
1672             ret["comment"] = "VPC peering connection would be deleted"
1673         return ret
1674     log.debug("Called module to delete VPC peering connection")
1675     result = __salt__["boto_vpc.delete_vpc_peering_connection"](
1676         conn_id=conn_id,
1677         conn_name=conn_name,
1678         region=region,
1679         key=key,
1680         keyid=keyid,
1681         profile=profile,
1682     )
1683     if "error" in result:
1684         ret["comment"] = "Failed to delete VPC peering: {}".format(result["error"])
1685         ret["result"] = False
1686         return ret
1687     ret["changes"].update({"old": "", "new": result["msg"]})
1688     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_iam.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Manage IAM objects
3 ==================
4 .. versionadded:: 2015.8.0
5 This module uses ``boto``, which can be installed via package, or pip.
6 This module accepts explicit IAM credentials but can also utilize
7 IAM roles assigned to the instance through Instance Profiles. Dynamic
8 credentials are then automatically obtained from AWS API and no further
9 configuration is necessary. More information available `here
10 &lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.
11 It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile, either
12 passed in as a dict, or as a string to pull from pillars or minion config:
13 .. code-block:: yaml
14     delete-user:
15       boto_iam.user_absent:
16         - name: myuser
17         - delete_keys: true
18 .. code-block:: yaml
19     delete-keys:
20       boto_iam.keys_absent:
21         - access_keys:
22           - 'AKIAJHTMIQ2ASDFLASDF'
23           - 'PQIAJHTMIQ2ASRTLASFR'
24         - user_name: myuser
25 .. code-block:: yaml
26     create-user:
27       boto_iam.user_present:
28         - name: myuser
29         - policies:
30             mypolicy: |
31                 {
32                     "Version": "2012-10-17",
33                     "Statement": [{
34                     "Effect": "Allow",
35                     "Action": "*",
36                     "Resource": "*"}]
37                 }
38         - password: NewPassword$$1
39         - region: eu-west-1
40         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
41         - key: 'fdkjsafkljsASSADFalkfjasdf'
42 .. code-block:: yaml
43     create-group:
44       boto_iam.group_present:
45         - name: mygroup
46         - users:
47           - myuser
48           - myuser1
49         - policies:
50             mypolicy: |
51                 {
52                     "Version": "2012-10-17",
53                     "Statement": [{
54                     "Effect": "Allow",
55                     "Action": "*",
56                     "Resource": "*"}]
57                 }
58         - region: eu-west-1
59         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
60         - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
61 .. code-block:: yaml
62     change-policy:
63       boto_iam.account_policy:
64         - change_password: True
65         - region: eu-west-1
66         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
67         - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
68 .. code-block:: yaml
69     create server certificate:
70       boto_iam.server_cert_present:
71         - name: mycert
72         - public_key: salt://base/mycert.crt
73         - private_key: salt://base/mycert.key
74         - cert_chain: salt://base/mycert_chain.crt
75         - region: eu-west-1
76         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
77         - key: 'fdkjsafkljsASSADFalkfjasdf'
78 .. code-block:: yaml
79     delete server certificate:
80       boto_iam.server_cert_absent:
81         - name: mycert
82 .. code-block:: yaml
83     create keys for user:
84       boto_iam.keys_present:
85         - name: myusername
86         - number: 2
87         - save_dir: /root
88         - region: eu-west-1
89         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
90         - key: 'fdkjsafkljsASSADFalkfjasdf'
91 .. code-block:: yaml
92     create policy:
93       boto_iam.policy_present:
94         - name: myname
95         - policy_document: '{"MyPolicy": "Statement": [{"Action": ["sqs:*"], "Effect": "Allow", "Resource": ["arn:aws:sqs:*:*:*"], "Sid": "MyPolicySqs1"}]}'
96         - region: eu-west-1
97         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
98         - key: 'fdkjsafkljsASSADFalkfjasdf'
99 .. code-block:: yaml
100     add-saml-provider:
101       boto_iam.saml_provider_present:
102         - name: my_saml_provider
103         - saml_metadata_document: salt://base/files/provider.xml
104         - keyid: 'AKIAJHTMIQ2ASDFLASDF'
105         - key: 'safsdfsal;fdkjsafkljsASSADFalkfj'
106 """
107 import logging
108 import os
109 import xml.etree.ElementTree as ET
110 import salt.utils.data
111 import salt.utils.dictupdate as dictupdate
112 import salt.utils.files
113 import salt.utils.json
114 import salt.utils.odict as odict
115 import salt.utils.stringutils
116 log = logging.getLogger(__name__)
117 __virtualname__ = "boto_iam"
118 def __virtual__():
119     Only load if elementtree xml library and boto are available.
120     """
121     <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if "boto_iam.get_user" in __salt__:
122         return True
123     else:
124         return (
125             False,
126             "Cannot load {} state: boto_iam module unavailable".format(__virtualname__),
127         )
128 def user_absent(
129     name,
130     delete_keys=True,
131     delete_mfa_devices=True,
132     delete_profile=True,
133     region=None,
134     key=None,
135     keyid=None,
136     profile=None,
137 ):
138     """
139     .. versionadded:: 2015.8.0
140     Ensure the IAM user is absent. User cannot be deleted if it has keys.
141     name (string)
142         The name of the new user.
143     delete_keys (bool)
144         Delete all keys from user.
145     delete_mfa_devices (bool)
146         Delete all mfa devices from user.
147         .. versionadded:: 2016.3.0
148     delete_profile (bool)
149         Delete profile from user.
150         .. versionadded:: 2016.3.0
151     region (string)
152         Region to connect to.
153     key (string)
154         Secret key to be used.
155     keyid (string)
156         Access key to be used.
157     profile (dict)
158         A dict with region, key and keyid, or a pillar key (string)
159         that contains a dict with region, key and keyid.
160     """
161     ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
162     if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
163         ret["result"] = True
164         ret["comment"] = "IAM User {} does not exist.".format(name)
165         return ret
166     if delete_keys:
167         keys = __salt__["boto_iam.get_all_access_keys"](
168             user_name=name, region=region, key=key, keyid=keyid, profile=profile
169         )
170         log.debug("Keys for user %s are %s.", name, keys)
171         if isinstance(keys, dict):
172             keys = keys["list_access_keys_response"]["list_access_keys_result"][
173                 "access_key_metadata"
174             ]
175             for k in keys:
176                 if __opts__["test"]:
177                     ret["comment"] = " ".join(
178                         [
179                             ret["comment"],
180                             "Key {} is set to be deleted.".format(k["access_key_id"]),
181                         ]
182                     )
183                     ret["result"] = None
184                 else:
185                     if _delete_key(
186                         ret, k["access_key_id"], name, region, key, keyid, profile
187                     ):
188                         ret["comment"] = " ".join(
189                             [
190                                 ret["comment"],
191                                 "Key {} has been deleted.".format(k["access_key_id"]),
192                             ]
193                         )
194                         ret["changes"][k["access_key_id"]] = "deleted"
195     if delete_mfa_devices:
196         devices = __salt__["boto_iam.get_all_mfa_devices"](
197             user_name=name, region=region, key=key, keyid=keyid, profile=profile
198         )
199         if devices:
200             for d in devices:
201                 serial = d["serial_number"]
202                 if __opts__["test"]:
203                     ret["comment"] = " ".join(
204                         [
205                             ret["comment"],
206                             "IAM user {} MFA device {} is set to be deactivated.".format(
207                                 name, serial
208                             ),
209                         ]
210                     ret["result"] = None
211                 else:
212                     mfa_deactivated <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.deactivate_mfa_device"](
213                         user_name=name,
214                         serial=serial,
215                         region=region,
216                         key=key,
217                         keyid=keyid,
218                         profile=profile,
219                     )
220                     if mfa_deactivated:
221                         ret["comment"] = " ".join(
222                             [
223                                 ret[</b></font>"comment"],
224                                 "IAM user {} MFA device {} is deactivated.".format(
225                                     name, serial
226                                 ),
227                             ]
228                         )
229                 if __opts__["test"]:
230                     ret["comment"] = " ".join(
231                         [
232                             ret["comment"],
233                             "Virtual MFA device {} is set to be deleted.".format(
234                                 serial
235                             ),
236                         ]
237                     ret["result"] = None
238                 else:
239                     mfa_deleted <font color="#717d7d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.delete_virtual_mfa_device"](
240                         serial=serial,
241                         region=region,
242                         key=key,
243                         keyid=keyid,
244                         profile=profile,
245                     )
246                     if mfa_deleted:
247                         ret["comment"] = " ".</b></font>join(
248                             [
249                                 ret["comment"],
250                                 "Virtual MFA device {} is deleted.".format(serial),
251                             ]
252                         )
253     if delete_profile:
254         if __opts__["test"]:
255             ret["comment"] = " ".join(
256                 [
257                     ret["comment"],
258                     "IAM user {} login profile is set to be deleted.".format(name),
259                 ]
260             )
261             ret["result"] = None
262         else:
263             profile_deleted = __salt__["boto_iam.delete_login_profile"](
264                 name, region, key, keyid, profile
265             )
266             if profile_deleted:
267                 ret["comment"] = " ".join(
268                     [
269                         ret["comment"],
270                         "IAM user {} login profile is deleted.".format(name),
271                     ]
272                 )
273     if __opts__["test"]:
274         ret["comment"] = " ".join(
275             [
276                 ret["comment"],
277                 "IAM user {} managed policies are set to be detached.".format(name),
278             ]
279         )
280     else:
281         _ret = _user_policies_detached(name, region, key, keyid, profile)
282         ret<font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = " ".join([ret["comment"], _ret["comment"]])
283         if not _ret["result"]:
284             ret["result"] = _ret["result"]
285             if ret["result"] is False:
286                 r</b></font>eturn ret
287     if __opts__["test"]:
288         ret["comment"] = " ".join(
289             [
290                 ret["comment"],
291                 "IAM user {} inline policies are set to be deleted.".format(name),
292             ]
293         )
294         ret["result"] = None
295     else:
296         _ret = _user_policies_deleted(name, region, key, keyid, profile)
297         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
298         if not _ret["result"]:
299             ret["result"] = _ret["result"]
300             if ret["result"] is False:
301                 return ret
302     if __opts__["test"]:
303         ret["comment"] = " ".join(
304             [ret["comment"], "IAM user {} is set to be deleted.".format(name)]
305         )
306         ret["result"] = None
307         return ret
308     deleted = __salt__["boto_iam.delete_user"](name, region, key, keyid, profile)
309     if deleted is True:
310         ret["comment"] = " ".join(
311             [ret["comment"], "IAM user {} is deleted.".format(name)]
312         )
313         ret["result"] = True
314         ret["changes"]["deleted"] = name
315         return ret
316     ret["comment"] = "IAM user {} could not be deleted.\n {}".format(name, deleted)
317     ret["result"] = False
318     return ret
319 def keys_present(
320     name,
321     number,
322     save_dir,
323     region=None,
324     key=None,
325     keyid=None,
326     profile=None,
327     save_format="{2}\n{0}\n{3}\n{1}\n",
328 ):
329     """
330     .. versionadded:: 2015.8.0
331     Ensure the IAM access keys are present.
332     name (string)
333         The name of the new user.
334     number (int)
335         Number of keys that user should have.
336     save_dir (string)
337         The directory that the key/keys will be saved. Keys are saved to a file named according
338         to the username privided.
339     region (string)
340         Region to connect to.
341     key (string)
342         Secret key to be used.
343     keyid (string)
344         Access key to be used.
345     profile (dict)
346         A dict with region, key and keyid, or a pillar key (string)
347         that contains a dict with region, key and keyid.
348     save_format (dict)
349         Save format is repeated for each key. Default format is
350         "{2}\\n{0}\\n{3}\\n{1}\\n", where {0} and {1} are placeholders for new
351         key_id and key respectively, whereas {2} and {3} are "key_id-{number}"
352         and 'key-{number}' strings kept for compatibility.
353     """
354     ret = {"name": name, "result": True, "comment": "", "changes": {}}
355     if not __salt__["boto_iam.get_user"](name, region, key, keyid, profile):
356         ret["result"] = False
357         ret["comment"] = "IAM User {} does not exist.".format(name)
358         return ret
359     if not isinstance(number, int):
360         ret["comment"] = "The number of keys must be an integer."
361         return ret
362     if not os.path.isdir(save_dir):
363         ret<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "The directory {} does not exist.".format(save_dir)
364         ret["result"] = False
365         return ret
366     keys = __salt__["boto_iam.get_all_access_keys"](
367         user_name=name, region=region, key=key, keyid=keyid, profile=profile
368     )
369     if</b></font> isinstance(keys, str):
370         log.debug("keys are : false %s", keys)
371         error, message = _get_error(keys)
372         ret["comment"] = "Could not get keys.\n{}\n{}".format(error, message)
373         ret["result"] = False
374         return ret
375     keys = keys["list_access_keys_response"]["list_access_keys_result"][
376         "access_key_metadata"
377     ]
378     log.debug("Keys are : %s.", keys)
379     if len(keys) &gt;= number:
380         ret["comment"] = "The number of keys exist for user {}".format(name)
381         ret["result"] = True
382         return ret
383     if __opts__["test"]:
384         ret["comment"] = "Access key is set to be created for {}.".format(name)
385         ret["result"] = None
386         return ret
387     new_keys = {}
388     for i in range(number - len(keys)):
389         created = __salt__["boto_iam.create_access_key"](
390             name, region, key, keyid, profile
391         )
392         if isinstance(created, str):
393             error, message = _get_error(created)
394             ret["comment"] = "Could not create keys.\n{}\n{}".format(error, message)
395             ret["result"] = False
396             return ret
397         log.debug("Created is : %s", created)
398         response = "create_access_key_response"
399         result = "create_access_key_result"
400         new_keys[str(i)] = {}
401         new_keys[str(i)]["key_id"] = created[response][result]["access_key"][
402             "access_key_id"
403         ]
404         new_keys[str(i)]["secret_key"] = created[response][result]["access_key"][
405             "secret_access_key"
406         ]
407     try:
408         with salt.utils.files.fopen("{}/{}".format(save_dir, name), "a") as _wrf:
409             for key_num, key in new_keys.items():
410                 key_id = key["key_id"]
411                 secret_key = key["secret_key"]
412                 _wrf.write(
413                     salt.utils.stringutils.to_str(
414                         save_format.format(
415                             key_id,
416                             secret_key,
417                             "key_id-{}".format(key_num),
418                             "key-{}".format(key_num),
419                         )
420                     )
421                 )
422         ret["comment"] = "Keys have been written to file {}/{}.".format(save_dir, name)
423         ret["result"] = True
424         ret["changes"] = new_keys
425         return ret
426     except OSError:
427         ret["comment"] = "Could not write to file {}/{}.".format(save_dir, name)
428         ret["result"] = False
429         return ret
430 def keys_absent(
431     access_keys, user_name, region=None, key=None, keyid=None, profile=None
432 ):
433     """
434     .. versionadded:: 2015.8.0
435     Ensure the IAM user access_key_id is absent.
436     access_key_id (list)
437         A list of access key ids
438     user_name (string)
439         The username of the user
440     region (string)
441         Region to connect to.
442     key (string)
443         Secret key to be used.
444     keyid (string)
445         Access key to be used.
446     profile (dict)
447         A dict with region, key and keyid, or a pillar key (string)
448         that contains a dict with region, key and keyid.
449     """
450     ret = {"name": access_keys, "result": True, "comment": "", "changes": {}}
451     if not __salt__["boto_iam.get_user"](user_name, region, key, keyid, profile):
452         ret["result"] = False
453         ret["comment"] = "IAM User {} does not exist.".format(user_name)
454         return ret
455     for k in access_keys:
456         ret = _delete_key(ret, k, user_name, region, key, keyid, profile)
457     return ret
458 def _delete_key(
459     ret, access_key_id, user_name, region<font color="#ae694a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None
460 ):
461     keys = __salt__["boto_iam.get_all_access_keys"](
462         user_name=user_name, region=region, key=key, keyid=keyid, profile=</b></font>profile
463     )
464     log.debug("Keys for user %s are : %s.", keys, user_name)
465     if isinstance(keys, str):
466         log.debug("Keys %s are a string. Something went wrong.", keys)
467         ret["comment"] = " ".join(
468             [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
469         )
470         return ret
471     keys = keys["list_access_keys_response"]["list_access_keys_result"][
472         "access_key_metadata"
473     ]
474     for k in keys:
475             "Key is: %s and is compared with: %s", k["access_key_id"], access_key_id
476         )
477         if str(k<font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["access_key_id"]) == str(access_key_id):
478             if __opts__["test"]:
479                 ret["comment"] = "Access key {} is set to be deleted.".format(
480                     access_key_id
481                 )
482                 ret["result"] = None
483                 return ret
484             deleted = __salt__["boto_iam.delete_access_key"](</b></font>
485                 access_key_id, user_name, region, key, keyid, profile
486             )
487             if deleted:
488                 ret["comment"] = " ".join(
489                     [ret["comment"], "Key {} has been deleted.".format(access_key_id)]
490                 )
491                 ret["changes"][access_key_id] = "deleted"
492                 return ret
493             ret["comment"] = " ".join(
494                 [ret["comment"], "Key {} could not be deleted.".format(access_key_id)]
495             )
496             return ret
497         ret["comment"] = " ".join([ret["comment"], "Key {} does not exist.".format(k)])
498         return ret
499 def user_present(
500     policies=None,
501     policies_from_pillars=None,
502     managed_policies<font color="#f660ab"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
503     password=None,
504     path=None,
505     region=None,
506     key=None,
507     keyid=None,
508     profile=None,
509 ):
510     """
511     .. versionadded:: 2015.8.0
512     Ensure the IAM user is present
513     name (string)
514         The name of the new user.
515     policies (dict)
516         A dict of IAM group policy documents.
517     policies_from_pillars (list)
518         A list of pillars that contain role policy dicts. Policies in the
519         pillars will be merged in the order defined in the list and key
520         conflicts will be handled by later defined keys overriding earlier
521         defined keys. The policies defined here will be merged with the
522         policies defined in the policies argument. If keys conflict, the keys
523         in the policies argument will override the keys defined in
524         policies_from_pillars.
525     managed_policies (list)
526         A list of managed policy names or ARNs that should be attached to this
527         user.
528     password (string)
529         The password for the new user. Must comply with account policy.
530     path (string)
531         The path of the user. Default is '/'.
532         .. versionadded:: 2015.8.2
533     region (string)
534         Region to connect to.
535     key (string)
536         Secret key to be used.
537     keyid (string)
538         Access key to be used.
539     profile (dict)
540         A dict with region, key and keyid, or a pillar key (string)
541         that contains a dict with region, key and keyid.
542     """
543     ret = {"name": name, "result": True, "comment": "", "changes": {}}
544     if not policies:
545         policies = {}
546     if</b></font> not policies_from_pillars:
547         policies_from_pillars = []
548     if not managed_policies:
549         managed_policies = []
550     _policies = {}
551     for policy in policies_from_pillars:
552         _policy = __salt__["pillar.get"](policy)
553         _policies.update(_policy)
554     exists = __salt__["boto_iam.get_user"](name, region, key, keyid, profile)
555     if not exists:
556         <font color="#68818b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if __opts__["test"]:
557             ret["comment"] = "IAM user {} is set to be created.".format(name)
558             ret["result"] = None
559             return ret
560         created = __salt__["boto_iam.create_user"](</b></font>
561             name, path, region, key, keyid, profile
562         )
563         if created:
564             ret["changes"]["user"] = created
565             ret["comment"] = " ".join(
566                 [ret["comment"], "User {} has been created.".format(name)]
567             )
568                 ret = _case_password(ret, name, password, region, key, keyid, profile)
569             _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
570             ret["changes"] <font color="#af7a82"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= dictupdate.update(ret["changes"], _ret["changes"])
571             ret["comment"] = " ".join([ret["comment"], _ret[</b></font>"comment"]])
572     else:
573         ret["comment"] = " ".join([ret["comment"], "User {} is present.".format(name)])
574         if password:
575             ret = _case_password(ret, name, password, region, key, keyid, profile)
576         _ret = _user_policies_present(name, _policies, region, key, keyid, profile)
577         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
578     _ret = _user_policies_attached(name, managed_policies, region, key, keyid, profile)
579     ret<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
580     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
581     if not _ret["result"]:
582         ret["result"] = _ret[</b></font>"result"]
583         return ret
584     return ret
585 def _user_policies_present(
586     name, policies=None, region=None, key=None, keyid=None, profile=None
587 ):
588     ret = {"result": True, "comment": "", "changes": {}}
589     policies_to_create = {}
590     policies_to_delete = []
591     for policy_name, policy in policies.items():
592         if isinstance(policy, str):
593             dict_policy = salt.utils.json.loads(
594                 policy, object_pairs_hook=odict.OrderedDict
595             )
596         else:
597             dict_policy = policy
598         _policy = __salt__["boto_iam.get_user_policy"](
599             name, policy_name, region, key, keyid, profile
600         )
601         if _policy != dict_policy:
602             log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
603             policies_to_create[policy_name] = policy
604     _list = __salt__["boto_iam.get_all_user_policies"](
605         user_name=name, region=region, key=key, keyid=keyid, profile=profile
606     )
607     for policy_name in _list:
608         if policy_name not in policies:
609             policies_to_delete.append(policy_name)
610     if policies_to_create or policies_to_delete:
611         _to_modify = list(policies_to_delete)
612         _to_modify.extend(policies_to_create)
613         if __opts__["test"]:
614             ret["comment"] = "{} policies to be modified on user {}.".format(
615                 ", ".join(_to_modify), name
616             )
617             ret["result"] = None
618             return ret
619         ret["changes"]["old"] = {"policies": _list}
620         for policy_name, policy in policies_to_create.items():
621             policy_set = __salt__["boto_iam.put_user_policy"](
622                 name, policy_name, policy, region, key, keyid, profile
623             )
624             if not policy_set:
625                 _list = __salt__["boto_iam.get_all_user_policies"](
626                     user_name=name, region=region, key=key, keyid=keyid, profile=profile
627                 )
628                 ret["changes"]["new"] = {"policies": _list}
629                 ret["result"] = False
630                 ret["comment"] = "Failed to add policy {} for user {}".format(
631                     policy_name, name
632                 )
633                 return ret
634         for policy_name in policies_to_delete:
635             policy_unset = __salt__["boto_iam.delete_user_policy"](
636                 name, policy_name, region, key, keyid, profile
637             )
638             if not policy_unset:
639                 _list = __salt__["boto_iam.get_all_user_policies"](
640                     user_name=name, region=region, key=key, keyid=keyid, profile=profile
641                 )
642                 ret["changes"]["new"] = {"policies": _list}
643                 ret["result"] = False
644                 ret["comment"] = "Failed to add policy {} to user {}".format(
645                     policy_name, name
646                 )
647                 return ret
648         _list = __salt__["boto_iam.get_all_user_policies"](
649             user_name=name, region=region, key=key, keyid=keyid, profile=profile
650         )
651         ret["changes"]["new"] = {"policies": _list}
652         ret["comment"] = "{} policies modified on user {}.".format(
653             ", ".join(_list), name
654         )
655     return ret
656 def _user_policies_attached(
657     name, managed_policies=None, region=None, key=None, keyid=None, profile=None
658 ):
659     ret = {"result": True, "comment": "", "changes": {}}
660     policies_to_attach = []
661     policies_to_detach = []
662     for policy in managed_policies or []:
663         entities = __salt__["boto_iam.list_entities_for_policy"](
664             policy,
665             entity_filter="User",
666             region=region,
667             key=key,
668             keyid=keyid,
669             profile=profile,
670         )
671         found = False
672         for userdict in entities.get("policy_users", []):
673             if name == userdict.get("user_name"):
674                 found = True
675                 break
676         if not found:
677             policies_to_attach.append(policy)
678     _list = __salt__["boto_iam.list_attached_user_policies"](
679         name, region=region, key=key, keyid=keyid, profile=profile
680     )
681     oldpolicies = [x.get("policy_arn") for x in _list]
682     for policy_data in _list:
683         if (
684             policy_data.get("policy_name") not in managed_policies
685             and policy_data.get("policy_arn") not in managed_policies
686         ):
687             policies_to_detach.append(policy_data.get("policy_arn"))
688     if policies_to_attach or policies_to_detach:
689         _to_modify = list(policies_to_detach)
690         _to_modify.extend(policies_to_attach)
691         if __opts__["test"]:
692             ret["comment"] = "{} policies to be modified on user {}.".format(
693                 ", ".join(_to_modify), name
694             )
695             ret["result"] = None
696             return ret
697         ret["changes"]["old"] = {"managed_policies": oldpolicies}
698         for policy_name in policies_to_attach:
699             policy_set = __salt__["boto_iam.attach_user_policy"](
700                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
701             )
702             if not policy_set:
703                 _list = __salt__["boto_iam.list_attached_user_policies"](
704                     name, region=region, key=key, keyid=keyid, profile=profile
705                 )
706                 newpolicies = [x.get("policy_arn") for x in _list]
707                 ret["changes"]["new"] = {"managed_policies": newpolicies}
708                 ret["result"] = False
709                 ret["comment"] = "Failed to add policy {} to user {}".format(
710                     policy_name, name
711                 )
712                 return ret
713         for policy_name in policies_to_detach:
714             policy_unset = __salt__["boto_iam.detach_user_policy"](
715                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
716             )
717             if not policy_unset:
718                 _list = __salt__["boto_iam.list_attached_user_policies"](
719                     name, region=region, key=key, keyid=keyid, profile=profile
720                 )
721                 newpolicies = [x.get("policy_arn") for x in _list]
722                 ret["changes"]["new"] = {"managed_policies": newpolicies}
723                 ret["result"] = False
724                 ret["comment"] = "Failed to remove policy {} from user {}".format(
725                     policy_name, name
726                 )
727                 return ret
728         _list = __salt__["boto_iam.list_attached_user_policies"](
729             name, region=region, key=key, keyid=keyid, profile=profile
730         )
731         newpolicies = [x.get("policy_arn") for x in _list]
732         log.debug(newpolicies)
733         ret["changes"]["new"] = {"managed_policies": newpolicies}
734         ret["comment"] = "{} policies modified on user {}.".format(
735             ", ".join(newpolicies), name
736         )
737 def _user_policies_detached(name, region<font color="#4e9258"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
738     ret = {"result": True, "comment": "", "changes": {}}
739         user_name=name, region=region, key=key, keyid=keyid, profile=</b></font>profile
740     )
741     oldpolicies <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [x.get("policy_arn") for x in _list]
742     if not _list:
743         ret["comment"] = "No attached policies in user {}.".format(name)
744         return ret
745     if __opts__["test"]:
746         ret["comment"] = "{} policies to be detached from user {}.".format(
747             ", ".</b></font>join(oldpolicies), name
748         )
749         ret["result"] = None
750         return ret
751     ret["changes"]["old"] = {"managed_policies": oldpolicies}
752     for policy_arn in oldpolicies:
753         policy_unset = __salt__["boto_iam.detach_user_policy"](
754             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
755         )
756         if not policy_unset:
757             _list = __salt__["boto_iam.list_attached_user_policies"](
758                 name, region=region, key=key, keyid=keyid, profile=profile
759             )
760             newpolicies = [x.get("policy_arn") for x in _list]
761             ret["changes"]["new"] = {"managed_policies": newpolicies}
762             ret["result"] = False
763             ret["comment"] = "Failed to detach {} from user {}".format(policy_arn, name)
764             return ret
765     _list = __salt__["boto_iam.list_attached_user_policies"](
766         name, region=region, key=key, keyid=keyid, profile=profile
767     )
768     newpolicies = [x.get("policy_arn") for x in _list]
769     ret["changes"]["new"] = {"managed_policies": newpolicies}
770         ", ".join(oldpolicies), name
771     )
772     <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
773 def _user_policies_deleted(name, region=None, key=None, keyid=None, profile=None):
774     ret = {"result": True, "comment": "", "changes": {}}
775     oldpolicies = __salt__["boto_iam.get_all_user_policies"](
776         user_name=name, region=region, key=key, keyid=keyid, profile=profile
777     )
778     if not oldpolicies:
779         ret["comment"] = "No inline policies in user {}.".</b></font>format(name)
780         return ret
781     if __opts__["test"]:
782         ret["comment"] = "{} policies to be deleted from user {}.".format(
783             ", ".join(oldpolicies), name
784         )
785         ret["result"] = None
786         return ret
787     ret["changes"]["old"] = {"inline_policies": oldpolicies}
788     for policy_name in oldpolicies:
789         policy_deleted = __salt__["boto_iam.delete_user_policy"](
790             name, policy_name, region=region, key=key, keyid=keyid, profile=profile
791         )
792         if not policy_deleted:
793             newpolicies = __salt__["boto_iam.get_all_user_policies"](
794                 name, region=region, key=key, keyid=keyid, profile=profile
795             )
796             ret["changes"]["new"] = {"inline_policies": newpolicies}
797             ret["result"] = False
798             ret["comment"] = "Failed to detach {} from user {}".format(
799                 policy_name, name
800             )
801             return ret
802     newpolicies = __salt__["boto_iam.get_all_user_policies"](
803         name, region=region, key=key, keyid=keyid, profile=profile
804     )
805     ret["changes"]["new"] = {"inline_policies": newpolicies}
806     ret["comment"] = "{} policies deleted from user {}.".format(
807         ", ".join(oldpolicies), name
808     )
809     return ret
810 def _case_password(
811     ret, name, password, region=None, key=None, keyid=None, profile=None
812 ):
813     if __opts__["test"]:
814         ret["comment"] = "Login policy for {} is set to be changed.".format(name)
815         ret["result"] = None
816         return ret
817     login = __salt__["boto_iam.create_login_profile"](
818         name, password, region, key, keyid, profile
819     )
820     log.debug("Login is : %s.", login)
821     if login:
822         if "Conflict" in login:
823             ret["comment"] = " ".join(
824                 [ret["comment"], "Login profile for user {} exists.".format(name)]
825             )
826         else:
827             ret["comment"] = " ".join(
828                 [ret["comment"], "Password has been added to User {}.".format(name)]
829             )
830             ret["changes"]["password"] = "REDACTED"
831     else:
832         ret["result"] = False
833         ret["comment"] = " ".join(
834             [
835                 ret["comment"],
836                 "Password for user {} could not be set.\nPlease check your password"
837                 " policy.".format(name),
838             ]
839         )
840     return ret
841 def group_absent(name, region=None, key=None, keyid=None, profile=None):
842     """
843     .. versionadded:: 2015.8.0
844     Ensure the IAM group is absent.
845     name (string)
846         The name of the group.
847     region (string)
848         Region to connect to.
849     key (string)
850         Secret key to be used.
851     keyid (string)
852         Access key to be used.
853     profile (dict)
854         A dict with region, key and keyid, or a pillar key (string)
855         that contains a dict with region, key and keyid.
856     """
857     ret = {"name": name, "result": True, "comment": "", "changes": {}}
858     if not __salt__["boto_iam.get_group"](name, region, key, keyid, profile):
859         ret["result"] = True
860         ret["comment"] = "IAM Group {} does not exist.".format(name)
861         return ret
862     if __opts__["test"]:
863         ret["comment"] = " ".join(
864             [
865                 ret["comment"],
866                 "IAM group {} managed policies are set to be detached.".format(name),
867             ]
868         )
869         ret["result"] = None
870     else:
871         _ret = _group_policies_detached(name, region, key, keyid, profile)
872         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
873         if not _ret["result"]:
874             ret["result"] = _ret["result"]
875             if ret["result"] is False:
876                 return ret
877     if __opts__["test"]:
878         ret["comment"] = " ".join(
879             [
880                 ret["comment"],
881                 "IAM group {} inline policies are set to be deleted.".format(name),
882             ]
883         )
884         ret["result"] = None
885     else:
886         _ret = _group_policies_deleted(name, region, key, keyid, profile)
887         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
888         if not _ret["result"]:
889             ret["result"] = _ret["result"]
890             if ret["result"] is False:
891                 return ret
892     ret["comment"] = " ".join(
893         [ret["comment"], "IAM group {} users are set to be removed.".format(name)]
894     )
895     existing_users = __salt__["boto_iam.get_group_members"](
896     )
897     _ret = _case_group(ret, [], name, existing_users, region, key, keyid, profile)
898     ret<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
899     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
900     if not _ret["result"]:
901         ret["result"] = _ret[</b></font>"result"]
902         return ret
903     if __opts__["test"]:
904         ret["comment"] = " ".join(
905             [ret["comment"], "IAM group {} is set to be deleted.".format(name)]
906         )
907         ret["result"] = None
908         return ret
909     deleted = __salt__["boto_iam.delete_group"](name, region, key, keyid, profile)
910     if deleted is True:
911         ret["comment"] = " ".join(
912             [ret["comment"], "IAM group {} is deleted.".format(name)]
913         )
914         ret["result"] = True
915         ret["changes"]["deleted"] = name
916     ret["comment"] = "IAM group {} could not be deleted.\n {}".format(name, deleted)
917     ret["result"] = False
918     <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
919 def group_present(
920     name,
921     policies=None,
922     policies_from_pillars=None,
923     managed_policies=None,
924     users=None,
925     path="/",
926     region=None,
927     key=None,
928     keyid=None,
929     profile=None,
930     delete_policies=True,
931 ):
932     """
933     .. versionadded:: 2015.8.0
934     Ensure the IAM group is present
935     name (string)
936         The name of the new group.
937     path (string)
938         The path for the group, defaults to '/'
939     policies (dict)
940         A dict of IAM group policy documents.
941     policies_from_pillars (list)
942         A list of pillars that contain role policy dicts. Policies in the
943         pillars will be merged in the order defined in the list and key
944         conflicts will be handled by later defined keys overriding earlier
945         defined keys. The policies defined here will be merged with the
946         policies defined in the policies argument. If keys conflict, the keys
947         in the policies argument will override the keys defined in
948         policies_from_pillars.
949     managed_policies (list)
950         A list of policy names or ARNs that should be attached to this group.
951     users (list)
952         A list of users to be added to the group.
953     region (string)
954         Region to connect to.
955     key (string)
956         Secret key to be used.
957     keyid (string)
958         Access key to be used.
959     profile (dict)
960         A dict with region, key and keyid, or a pillar key (string) that
961         contains a dict with region, key and keyid.
962     delete_policies (boolean)
963         Delete or detach existing policies that are not in the given list of policies.
964         Default value is ``True``. If ``False`` is specified, existing policies
965         will not be deleted or detached allowing manual modifications on the IAM group
966         to be persistent.
967     """
968     ret = {"name"</b></font>: name, "result": True, "comment": "", "changes": {}}
969     if not policies:
970         policies = {}
971     if not policies_from_pillars:
972         policies_from_pillars = []
973     if not managed_policies:
974         managed_policies = []
975     _policies = {}
976     for policy in policies_from_pillars:
977         _policy = __salt__["pillar.get"](policy)
978         _policies.update(_policy)
979     _policies.update(policies)
980     exists = __salt__["boto_iam.get_group"](
981     )
982     if not exists:
983         <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if __opts__["test"]:
984             ret["comment"] = "IAM group {} is set to be created.".format(name)
985             ret["result"] = None
986             return ret
987         created = __salt__["boto_iam.create_group"](
988             group_name=name,
989             path=path,
990             region=region,
991             key=key,
992             keyid=keyid,
993             profile=</b></font>profile,
994         )
995         if not created:
996             ret["comment"] = "Failed to create IAM group {}.".format(name)
997             ret["result"] = False
998             return ret
999         ret["changes"]["group"] = created
1000         ret["comment"] = " ".join(
1001             [ret["comment"], "Group {} has been created.".format(name)]
1002         )
1003     else:
1004         ret["comment"] = " ".join([ret["comment"], "Group {} is present.".format(name)])
1005     _ret = _group_policies_present(
1006         name, _policies, region, key, keyid, profile, delete_policies
1007     )
1008     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
1009     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
1010     if not _ret["result"]:
1011         ret["result"] = _ret["result"]
1012         return ret
1013     _ret = _group_policies_attached(
1014         name, managed_policies, region, key, keyid, profile, delete_policies
1015     )
1016     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
1017     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
1018     if not _ret["result"]:
1019         ret["result"] = _ret["result"]
1020         return ret
1021     if users is not None:
1022         log.debug("Users are : %s.", users)
1023         existing_users = __salt__["boto_iam.get_group_members"](
1024             group_name=name, region=region, key=key, keyid=keyid, profile=profile
1025         )
1026         ret = _case_group(ret, users, name, existing_users, region, key, keyid, profile)
1027     return ret
1028 def _case_group(ret, users, group_name, existing_users, region, key, keyid, profile):
1029     _users = []
1030     for user in existing_users:
1031         _users.append(user["user_name"])
1032     log.debug("upstream users are %s", _users)
1033     for user in users:
1034         log.debug("users are %s", user)
1035         if user in _users:
1036             log.debug("user exists")
1037             ret["comment"] = " ".join(
1038                 [
1039                     ret["comment"],
1040                     "User {} is already a member of group {}.".format(user, group_name),
1041                 ]
1042             )
1043             continue
1044         else:
1045             log.debug("user is set to be added %s", user)
1046             if __opts__["test"]:
1047                 ret["comment"] = "User {} is set to be added to group {}.".format(
1048                     user, group_name
1049                 )
1050                 ret["result"] = None
1051             else:
1052                 __salt__["boto_iam.add_user_to_group"](
1053                     user, group_name, region, key, keyid, profile
1054                 )
1055                 ret["comment"] = " ".join(
1056                     [
1057                         ret["comment"],
1058                         "User {} has been added to group {}.".format(user, group_name),
1059                     ]
1060                 )
1061                 ret["changes"][user] = group_name
1062     for user in _users:
1063         if user not in users:
1064             if __opts__["test"]:
1065                 ret["comment"] = " ".join(
1066                     [
1067                         ret["comment"],
1068                         "User {} is set to be removed from group {}.".format(
1069                             user, group_name
1070                         ),
1071                     ]
1072                 )
1073                 ret["result"] = None
1074             else:
1075                 __salt__["boto_iam.remove_user_from_group"](
1076                     group_name=group_name,
1077                     user_name=user,
1078                     region=region,
1079                     key=key,
1080                     keyid=keyid,
1081                     profile=profile,
1082                 )
1083                 ret["comment"] = " ".join(
1084                     [
1085                         ret["comment"],
1086                         "User {} has been removed from group {}.".format(
1087                             user, group_name
1088                         ),
1089                     ]
1090                 )
1091                 ret["changes"][user] = "Removed from group {}.".format(group_name)
1092     return ret
1093 def _group_policies_present(
1094     name,
1095     policies=None,
1096     region=None,
1097     key=None,
1098     keyid=None,
1099     profile=None,
1100     delete_policies=True,
1101 ):
1102     ret = {"result": True, "comment": "", "changes": {}}
1103     policies_to_create = {}
1104     policies_to_delete = []
1105     for policy_name, policy in policies.items():
1106         if isinstance(policy, str):
1107             dict_policy = salt.utils.json.loads(
1108                 policy, object_pairs_hook=odict.OrderedDict
1109             )
1110         else:
1111             dict_policy = policy
1112         _policy = __salt__["boto_iam.get_group_policy"](
1113             name, policy_name, region, key, keyid, profile
1114         )
1115         if _policy != dict_policy:
1116             log.debug("Policy mismatch:\n%s\n%s", _policy, dict_policy)
1117             policies_to_create[policy_name] = policy
1118     _list = __salt__["boto_iam.get_all_group_policies"](
1119         name, region, key, keyid, profile
1120     )
1121     for policy_name in _list:
1122         if delete_policies and policy_name not in policies:
1123             policies_to_delete.append(policy_name)
1124     if policies_to_create or policies_to_delete:
1125         _to_modify = list(policies_to_delete)
1126         _to_modify.extend(policies_to_create)
1127         if __opts__["test"]:
1128             ret["comment"] = "{} policies to be modified on group {}.".format(
1129                 ", ".join(_to_modify), name
1130             )
1131             ret["result"] = None
1132             return ret
1133         ret["changes"]["old"] = {"policies": _list}
1134         for policy_name, policy in policies_to_create.items():
1135             policy_set = __salt__["boto_iam.put_group_policy"](
1136                 name, policy_name, policy, region, key, keyid, profile
1137             )
1138             if not policy_set:
1139                 _list = __salt__["boto_iam.get_all_group_policies"](
1140                     name, region, key, keyid, profile
1141                 )
1142                 ret["changes"]["new"] = {"policies": _list}
1143                 ret["result"] = False
1144                 ret["comment"] = "Failed to add policy {} to group {}".format(
1145                     policy_name, name
1146                 )
1147                 return ret
1148         for policy_name in policies_to_delete:
1149             policy_unset = __salt__["boto_iam.delete_group_policy"](
1150                 name, policy_name, region, key, keyid, profile
1151             )
1152             if not policy_unset:
1153                 _list = __salt__["boto_iam.get_all_group_policies"](
1154                     name, region, key, keyid, profile
1155                 )
1156                 ret["changes"]["new"] = {"policies": _list}
1157                 ret["result"] = False
1158                 ret["comment"] = "Failed to add policy {} to group {}".format(
1159                     policy_name, name
1160                 )
1161                 return ret
1162         _list = __salt__["boto_iam.get_all_group_policies"](
1163             name, region, key, keyid, profile
1164         )
1165         ret["changes"]["new"] = {"policies": _list}
1166         ret["comment"] = "{} policies modified on group {}.".format(
1167             ", ".join(_list), name
1168         )
1169     return ret
1170 def _group_policies_attached(
1171     name,
1172     managed_policies=None,
1173     region=None,
1174     key=None,
1175     keyid=None,
1176     profile=None,
1177     detach_policies=True,
1178 ):
1179     ret = {"result": True, "comment": "", "changes": {}}
1180     policies_to_attach = []
1181     policies_to_detach = []
1182     for policy in managed_policies or []:
1183         entities = __salt__["boto_iam.list_entities_for_policy"](
1184             policy,
1185             entity_filter="Group",
1186             region=region,
1187             key=key,
1188             keyid=keyid,
1189             profile=profile,
1190         )
1191         found = False
1192         for groupdict in entities.get("policy_groups", []):
1193             if name == groupdict.get("group_name"):
1194                 found = True
1195                 break
1196         if not found:
1197             policies_to_attach.append(policy)
1198     _list = __salt__["boto_iam.list_attached_group_policies"](
1199         name, region=region, key=key, keyid=keyid, profile=profile
1200     )
1201     oldpolicies = [x.get("policy_arn") for x in _list]
1202     for policy_data in _list:
1203         if (
1204             detach_policies
1205             and policy_data.get("policy_name") not in managed_policies
1206             and policy_data.get("policy_arn") not in managed_policies
1207         ):
1208             policies_to_detach.append(policy_data.get("policy_arn"))
1209     if policies_to_attach or policies_to_detach:
1210         _to_modify = list(policies_to_detach)
1211         _to_modify.extend(policies_to_attach)
1212         if __opts__["test"]:
1213             ret["comment"] = "{} policies to be modified on group {}.".format(
1214                 ", ".join(_to_modify), name
1215             )
1216             ret["result"] = None
1217             return ret
1218         ret["changes"]["old"] = {"managed_policies": oldpolicies}
1219         for policy_name in policies_to_attach:
1220             policy_set = __salt__["boto_iam.attach_group_policy"](
1221                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
1222             )
1223             if not policy_set:
1224                 _list = __salt__["boto_iam.list_attached_group_policies"](
1225                     name, region=region, key=key, keyid=keyid, profile=profile
1226                 )
1227                 newpolicies = [x.get("policy_arn") for x in _list]
1228                 ret["changes"]["new"] = {"managed_policies": newpolicies}
1229                 ret["result"] = False
1230                 ret["comment"] = "Failed to add policy {} to group {}".format(
1231                     policy_name, name
1232                 )
1233                 return ret
1234         for policy_name in policies_to_detach:
1235             policy_unset = __salt__["boto_iam.detach_group_policy"](
1236                 policy_name, name, region=region, key=key, keyid=keyid, profile=profile
1237             )
1238             if not policy_unset:
1239                 _list = __salt__["boto_iam.list_attached_group_policies"](
1240                     name, region=region, key=key, keyid=keyid, profile=profile
1241                 )
1242                 newpolicies = [x.get("policy_arn") for x in _list]
1243                 ret["changes"]["new"] = {"managed_policies": newpolicies}
1244                 ret["result"] = False
1245                 ret["comment"] = "Failed to remove policy {} from group {}".format(
1246                     policy_name, name
1247                 )
1248                 return ret
1249         _list = __salt__["boto_iam.list_attached_group_policies"](
1250             name, region=region, key=key, keyid=keyid, profile=profile
1251         )
1252         newpolicies = [x.get("policy_arn") for x in _list]
1253         log.debug(newpolicies)
1254         ret["changes"]["new"] = {"managed_policies": newpolicies}
1255         ret["comment"] = "{} policies modified on group {}.".format(
1256             ", ".join(newpolicies), name
1257         )
1258 def _group_policies_detached(name, region<font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
1259     ret = {"result": True, "comment": "", "changes": {}}
1260     _list = __salt__["boto_iam.list_attached_group_policies"](
1261         group_name=name, region=region, key=key, keyid=keyid, profile=profile
1262     )
1263     oldpolicies =</b></font> [x.get("policy_arn") for x in _list]
1264     if not _list:
1265         ret["comment"] = "No attached policies in group {}.".format(name)
1266         return ret
1267     if __opts__["test"]:
1268         ret["comment"] = "{} policies to be detached from group {}.".format(
1269             ", ".join(oldpolicies), name
1270         )
1271         ret["result"] = None
1272         return ret
1273     ret["changes"]["old"] = {"managed_policies": oldpolicies}
1274     for policy_arn in oldpolicies:
1275         policy_unset = __salt__["boto_iam.detach_group_policy"](
1276             policy_arn, name, region=region, key=key, keyid=keyid, profile=profile
1277         )
1278         if not policy_unset:
1279             _list = __salt__["boto_iam.list_attached_group_policies"](
1280                 name, region=region, key=key, keyid=keyid, profile=profile
1281             )
1282             newpolicies = [x.get("policy_arn") for x in _list]
1283             ret["changes"]["new"] = {"managed_policies": newpolicies}
1284             ret["result"] = False
1285             ret["comment"] = "Failed to detach {} from group {}".format(
1286                 policy_arn, name
1287             )
1288             return ret
1289     _list = __salt__["boto_iam.list_attached_group_policies"](
1290         name, region=region, key=key, keyid=keyid, profile=profile
1291     )
1292     newpolicies = [x.get("policy_arn") for x in _list]
1293     ret["changes"]["new"] = {"managed_policies": newpolicies}
1294     ret["comment"] = "{} policies detached from group {}.".format(
1295         ", ".join(newpolicies), name
1296     )
1297 def _group_policies_deleted(name, region<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
1298     ret = {"result": True, "comment": "", "changes": {}}
1299     oldpolicies = __salt__["boto_iam.get_all_group_policies"](
1300         group_name=name, region=region, key=key, keyid=keyid, profile=profile
1301     )
1302     if not oldpolicies:
1303         ret["comment"] = "No inline policies in group {}.".</b></font>format(name)
1304         return ret
1305     if __opts__["test"]:
1306         ret["comment"] = "{} policies to be deleted from group {}.".format(
1307             ", ".join(oldpolicies), name
1308         )
1309         ret["result"] = None
1310         return ret
1311     ret["changes"]["old"] = {"inline_policies": oldpolicies}
1312     for policy_name in oldpolicies:
1313         policy_deleted = __salt__["boto_iam.delete_group_policy"](
1314             name, policy_name, region=region, key=key, keyid=keyid, profile=profile
1315         )
1316         if not policy_deleted:
1317             newpolicies = __salt__["boto_iam.get_all_group_policies"](
1318                 name, region=region, key=key, keyid=keyid, profile=profile
1319             )
1320             ret["changes"]["new"] = {"inline_policies": newpolicies}
1321             ret["result"] = False
1322             ret["comment"] = "Failed to detach {} from group {}".format(
1323                 policy_name, name
1324             )
1325             return ret
1326     newpolicies = __salt__["boto_iam.get_all_group_policies"](
1327         name, region=region, key=key, keyid=keyid, profile=profile
1328     ret["changes"]["new"] = {"inline_policies": newpolicies}
1329     ret["comment"] = "{} policies deleted from group {}.".format(
1330         ", "<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.join(oldpolicies), name
1331     )
1332     return ret
1333 def account_policy(
1334     name=None,
1335     allow_users_to_change_password=None,
1336     hard_expiry=None,
1337     max_password_age=None,
1338     minimum_password_length=None,
1339     password_reuse_prevention=None,
1340     require_lowercase_characters=None,
1341     require_numbers=None,
1342     require_symbols=None,
1343     require_uppercase_characters=None,
1344     region=None,
1345     key=</b></font>None,
1346     keyid=None,
1347     profile=None,
1348 ):
1349     """
1350     Change account policy.
1351     .. versionadded:: 2015.8.0
1352     name (string)
1353         The name of the account policy
1354     allow_users_to_change_password (bool)
1355         Allows all IAM users in your account to
1356         use the AWS Management Console to change their own passwords.
1357     hard_expiry (bool)
1358         Prevents IAM users from setting a new password after their
1359         password has expired.
1360     max_password_age (int)
1361         The number of days that an IAM user password is valid.
1362     minimum_password_length (int)
1363         The minimum number of characters allowed in an IAM user password.
1364     password_reuse_prevention (int)
1365         Specifies the number of previous passwords
1366         that IAM users are prevented from reusing.
1367     require_lowercase_characters (bool)
1368         Specifies whether IAM user passwords
1369         must contain at least one lowercase character from the ISO basic Latin alphabet (a to z).
1370     require_numbers (bool)
1371         Specifies whether IAM user passwords must contain at
1372         least one numeric character (0 to 9).
1373     require_symbols (bool)
1374         Specifies whether IAM user passwords must contain at
1375         least one of the following non-alphanumeric characters: ! @ # $ % ^ &amp; * ( ) _ + - = [ ] { } | '
1376     require_uppercase_characters (bool)
1377         Specifies whether IAM user passwords must
1378         contain at least one uppercase character from the ISO basic Latin alphabet (A to Z).
1379     region (string)
1380         Region to connect to.
1381     key (string)
1382         Secret key to be used.
1383     keyid (string)
1384         Access key to be used.
1385     profile (dict)
1386         A dict with region, key and keyid, or a pillar key (string)
1387     """
1388     config = locals()
1389     ret = {"name": "Account Policy", "result": True, "comment": "", "changes": {}}
1390     info = __salt__["boto_iam.get_account_policy"](region, key, keyid, profile)
1391     if not info:
1392         ret["comment"] = "Account policy is not Enabled."
1393         ret["result"] = False
1394         return ret
1395     for key, value in config.items():
1396         if key in ("region", "key", "keyid", "profile", "name"):
1397             continue
1398         if value is not None and str(info[key]) != str(value).lower():
1399             ret["comment"] = " ".join(
1400                 [
1401                     ret["comment"],
1402                     "Policy value {} has been set to {}.".format(value, info[key]),
1403                 ]
1404             ret["changes"][key] = str(value).lower()
1405     if not ret["changes"]:
1406         ret<font color="#e77471"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "Account policy is not changed."
1407         return ret
1408     if __opts__["test"]:
1409         ret["comment"] = "Account policy is set to be changed."
1410         ret["result"] = None
1411         r</b></font>eturn ret
1412     if __salt__["boto_iam.update_account_password_policy"](
1413         allow_users_to_change_password,
1414         hard_expiry,
1415         max_password_age,
1416         minimum_password_length,
1417         password_reuse_prevention,
1418         require_lowercase_characters,
1419         require_numbers,
1420         require_symbols,
1421         require_uppercase_characters,
1422         region,
1423         key,
1424         keyid,
1425         profile,
1426     ):
1427         return ret
1428     ret["comment"] = "Account policy is not changed."
1429     ret["changes"] = {}
1430     ret["result"] = False
1431     return ret
1432 def server_cert_absent(name, region=None, key=None, keyid=None, profile=None):
1433     """
1434     Deletes a server certificate.
1435     .. versionadded:: 2015.8.0
1436     name (string)
1437         The name for the server certificate. Do not include the path in this value.
1438     region (string)
1439         The name of the region to connect to.
1440     key (string)
1441         The key to be used in order to connect
1442     keyid (string)
1443         The keyid to be used in order to connect
1444     profile (string)
1445     """
1446     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1447     exists <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.get_server_certificate"](
1448         name, region, key, keyid, profile
1449     )
1450     if not exists:
1451         ret["comment"] = "Certificate {} does not exist.".format(name)
1452         return ret
1453     if __opts__["test"]:
1454         ret["comment"] = "Server certificate {} is set to be deleted.".format(name)
1455         ret["result"] = None
1456         return ret
1457     deleted = __salt__["boto_iam.delete_server_cert"](</b></font>name, region, key, keyid, profile)
1458     if not deleted:
1459         ret["result"] = False
1460         ret["comment"] = "Certificate {} failed to be deleted.".format(name)
1461     ret["comment"] = "Certificate {} was deleted.".format(name)
1462     ret["changes"] = deleted
1463     <font color="#4cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
1464 def server_cert_present(
1465     name,
1466     public_key,
1467     private_key,
1468     cert_chain=None,
1469     path=None,
1470     region=None,
1471     key=None,
1472     keyid=None,
1473     profile=None,
1474 ):
1475     """
1476     Crete server certificate.
1477     .. versionadded:: 2015.8.0
1478     name (string)
1479         The name for the server certificate. Do not include the path in this value.
1480     public_key (string)
1481         The contents of the public key certificate in PEM-encoded format.
1482     private_key (string)
1483         The contents of the private key in PEM-encoded format.
1484     cert_chain (string)
1485         The contents of the certificate chain. This is typically a
1486         concatenation of the PEM-encoded public key certificates of the chain.
1487     path (string)
1488         The path for the server certificate.
1489     region (string)
1490         The name of the region to connect to.
1491     key (string)
1492         The key to be used in order to connect
1493     keyid (string)
1494         The keyid to be used in order to connect
1495     profile (string)
1496         The profile that contains a dict of region, key, keyid
1497     """
1498     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1499     exists = __salt__["boto_iam.get_server_certificate"](</b></font>
1500         name, region, key, keyid, profile
1501     )
1502     log.debug("Variables are : %s.", locals())
1503     if exists:
1504         ret["comment"] = "Certificate {} exists.".format(name)
1505         return ret
1506     if "salt://" in public_key:
1507         try:
1508             public_key = __salt__["cp.get_file_str"](public_key)
1509         except OSError as e:
1510             log.debug(e)
1511             ret["comment"] = "File {} not found.".format(public_key)
1512             ret["result"] = False
1513             return ret
1514     if "salt://" in private_key:
1515         try:
1516             private_key = __salt__["cp.get_file_str"](private_key)
1517         except OSError as e:
1518             log.debug(e)
1519             ret["comment"] = "File {} not found.".format(private_key)
1520             ret["result"] = False
1521             return ret
1522     if cert_chain is not None and "salt://" in cert_chain:
1523         try:
1524             cert_chain = __salt__["cp.get_file_str"](cert_chain)
1525         except OSError as e:
1526             log.debug(e)
1527             ret["comment"] = "File {} not found.".format(cert_chain)
1528             ret["result"] = False
1529             return ret
1530     if __opts__["test"]:
1531         ret["comment"] = "Server certificate {} is set to be created.".format(name)
1532         ret["result"] = None
1533         return ret
1534     created = __salt__["boto_iam.upload_server_cert"](
1535         name, public_key, private_key, cert_chain, path, region, key, keyid, profile
1536     )
1537     if created is not False:
1538         ret["comment"] = "Certificate {} was created.".format(name)
1539         return ret
1540     ret["result"] = False
1541     ret<font color="#947010"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "Certificate {} failed to be created.".format(name)
1542     return ret
1543 def policy_present(
1544     name,
1545     policy_document,
1546     path=None,
1547     description=None,
1548     region=None,
1549     key=None,
1550     keyid=None,
1551     profile=None,
1552 ):
1553     """
1554     .. versionadded:: 2015.8.0
1555     Ensure the IAM managed policy is present
1556     name (string)
1557         The name of the new policy.
1558     policy_document (dict)
1559         The document of the new policy
1560     path (string)
1561         The path in which the policy will be created. Default is '/'.
1562     description (string)
1563         Description
1564     region (string)
1565         Region to connect to.
1566     key (string)
1567         Secret key to be used.
1568     keyid (string)
1569         Access key to be used.
1570     profile (dict)
1571         A dict with region, key and keyid, or a pillar key (string)
1572         that contains a dict with region, key and keyid.
1573     """
1574     ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
1575     policy = __salt__["boto_iam.get_policy"](name, region, key, keyid, profile)
1576     if not policy:
1577         if __opts__["test"]:
1578             ret["comment"] = "IAM policy {} is set to be created.".format(name)
1579             ret["result"] = None
1580             return ret
1581         created = __salt__["boto_iam.create_policy"](
1582             name, policy_document, path, description, region, key, keyid, profile
1583         )
1584         if created:
1585             ret["changes"]["policy"] = created
1586             ret["comment"] = " ".join(
1587                 [ret["comment"], "Policy {} has been created.".format(name)]
1588             )
1589         else:
1590             ret["result"] = False
1591             ret["comment"] = "Failed to update policy."
1592             ret["changes"] = {}
1593             return ret
1594     else:
1595         policy = policy.get("policy", {})
1596         ret["comment"] = " ".join(
1597             [ret["comment"], "Policy {} is present.".format(name)]
1598         )
1599         _describe = __salt__["boto_iam.get_policy_version"](
1600             name, policy.get("default_version_id"), region, key, keyid, profile
1601         ).get("policy_version", {})
1602         if isinstance(_describe["document"], str):
1603             describeDict = salt.utils.json.loads(_describe["document"])
1604         else:
1605             describeDict = _describe["document"]
1606         if isinstance(policy_document, str):
1607             policy_document = salt.utils.json.loads(policy_document)
1608         r = salt.utils.data.compare_dicts(describeDict, policy_document)
1609         if bool(r):
1610             if __opts__["test"]:
1611                 ret["comment"] = "Policy {} set to be modified.".format(name)
1612                 ret["result"] = None
1613                 return ret
1614             policy_document = salt.utils.json.dumps(policy_document)
1615             r <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["boto_iam.create_policy_version"](
1616                 policy_name=name,
1617                 policy_document=policy_document,
1618                 set_as_default=True,
1619                 region=region,
1620                 key=key,
1621                 keyid=keyid,
1622                 profile=profile,
1623             )
1624             if not r.get("created"):
1625                 ret["result"] = False
1626                 ret["comment"] = "Failed to update policy: {}.".format(
1627                     r["error"][</b></font>"message"]
1628                 )
1629                 ret["changes"] = {}
1630                 return ret
1631             __salt__["boto_iam.delete_policy_version"](
1632                 policy_name=name,
1633                 version_id=policy["default_version_id"],
1634                 region=region,
1635                 key=key,
1636                 keyid=keyid,
1637                 profile=profile,
1638             )
1639             ret["changes"].setdefault("new", {})["document"] = policy_document
1640             ret["changes"].setdefault("old", {})["document"] = _describe["document"]
1641 def policy_absent(name, region<font color="#5eac10"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
1642     """
1643     .. versionadded:: 2015.8.0
1644     Ensure the IAM managed policy with the specified name is absent
1645     name (string)
1646         The name of the new policy.
1647     region (string)
1648         Region to connect to.
1649     key (string)
1650         Secret key to be used.
1651     keyid (string)
1652         Access key to be used.
1653     profile (dict)
1654         A dict with region, key and keyid, or a pillar key (string)
1655         that contains a dict with region, key and keyid.
1656     """
1657     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1658         name, region=region, key=key, keyid=keyid, profile=</b></font>profile
1659     )
1660     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if not r:
1661         ret["comment"] = "Policy {} does not exist.".format(name)
1662         return ret
1663     if __opts__["test"]:
1664         ret["comment"] = "Policy {} is set to be removed.".format(name)
1665         ret["result"] = None
1666         return ret
1667     versions = __salt__["boto_iam.list_policy_versions"](
1668         name, region=region, key=key, keyid=keyid, profile=</b></font>profile
1669     )
1670     if versions:
1671         for version in versions:
1672             if version.get("is_default_version", False) in ("true", True):
1673                 continue
1674             r = __salt__["boto_iam.delete_policy_version"](
1675                 name,
1676                 version_id=version.get("version_id"),
1677                 region=region,
1678                 key=key,
1679                 keyid=keyid,
1680                 profile=profile,
1681             )
1682             if not r:
1683                 ret["result"] = False
1684                 ret["comment"] = "Failed to delete policy {}.".format(name)
1685                 return ret
1686     r = __salt__["boto_iam.delete_policy"](
1687         name, region=region, key=key, keyid=keyid, profile=profile
1688     )
1689         ret["result"] = False
1690         ret["comment"] = "Failed to delete policy {}.".format(name)
1691         <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
1692     ret["changes"]["old"] = {"policy": name}
1693     ret["changes"]["new"] = {"policy": None}
1694     ret["comment"] = "Policy {} deleted.".format(name)
1695     return ret
1696 def saml_provider_present(
1697     name, saml_metadata_document, region=None, key=None, keyid=None, profile=None
1698 ):
1699     """
1700     .. versionadded:: 2016.11.0
1701     Ensure the SAML provider with the specified name is present.
1702     name (string)
1703         The name of the SAML provider.
1704     saml_metadata_document (string)
1705         The xml document of the SAML provider.
1706     region (string)
1707         Region to connect to.
1708     key (string)
1709         Secret key to be used.
1710     keyid (string)
1711         Access key to be used.
1712     profile (dict)
1713         A dict with region, key and keyid, or a pillar key (string)
1714         that contains a dict with region, key and keyid.
1715     """
1716     ret =</b></font> {"name": name, "result": True, "comment": "", "changes": {}}
1717     if "salt://" in saml_metadata_document:
1718         try:
1719             saml_metadata_document = __salt__["cp.get_file_str"](saml_metadata_document)
1720             ET.fromstring(saml_metadata_document)
1721         except OSError as e:
1722             log.debug(e)
1723             ret[
1724                 "comment"
1725             ] = "SAML document file {} not found or could not be loaded".format(name)
1726             ret["result"] = False
1727             return ret
1728     for provider in __salt__["boto_iam.list_saml_providers"](
1729         region=region, key=key, keyid=keyid, profile=profile
1730     ):
1731             ret["comment"] = "SAML provider {} is present.".format(name)
1732             return ret
1733     <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if __opts__["test"]:
1734         ret["comment"] = "SAML provider {} is set to be create.".format(name)
1735         ret["result"] = None
1736         return ret
1737     created = __salt__["boto_iam.create_saml_provider"](
1738         name,
1739         saml_metadata_document,
1740         region=region,
1741         key=key,
1742         keyid=keyid,
1743         profile=</b></font>profile,
1744     )
1745     if created:
1746         ret["comment"] = "SAML provider {} was created.".format(name)
1747         ret["changes"]["new"] = name
1748         return ret
1749     ret["result"] = False
1750     ret["comment"] = "SAML provider {} failed to be created.".format(name)
1751 def saml_provider_absent(name, region<font color="#79764d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, key=None, keyid=None, profile=None):
1752     """
1753     .. versionadded:: 2016.11.0
1754     Ensure the SAML provider with the specified name is absent.
1755     name (string)
1756         The name of the SAML provider.
1757     saml_metadata_document (string)
1758         The xml document of the SAML provider.
1759     region (string)
1760         Region to connect to.
1761     key (string)
1762         Secret key to be used.
1763     keyid (string)
1764         Access key to be used.
1765     profile (dict)
1766         A dict with region, key and keyid, or a pillar key (string)
1767         that contains a dict with region, key and keyid.
1768     """
1769     ret = {"name": name, "result": True, "comment": "", "changes": {}}
1770     provider = __salt__["boto_iam.list_saml_providers"](
1771     )
1772     if len(provider) == 0:
1773         ret<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "SAML provider {} is absent.".format(name)
1774         return ret
1775     if __opts__["test"]:
1776         ret["comment"] = "SAML provider {} is set to be removed.".format(name)
1777         ret["result"] = None
1778         return ret
1779     deleted = __salt__["boto_iam.delete_saml_provider"](
1780         name, region=region, key=key, keyid=keyid, profile=</b></font>profile
1781     )
1782     if deleted is not False:
1783         ret["comment"] = "SAML provider {} was deleted.".format(name)
1784         ret["changes"]["old"] = name
1785         return ret
1786     ret["result"] = False
1787     ret["comment"] = "SAML provider {} failed to be deleted.".format(name)
1788     return ret
1789 def _get_error(error):
1790     error = "\n".join(error.split("\n")[1:])
1791     error = ET.fromstring(error)
1792     code = error[0][1].text
1793     message = error[0][2].text
1794     return code, message
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
