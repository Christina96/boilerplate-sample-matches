<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for virtualenv_mod_1.py &amp; network_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for virtualenv_mod_1.py &amp; network_4.py
      </h3>
<h1 align="center">
        0.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>virtualenv_mod_1.py (2.9411764%)<th>network_4.py (0.44177973%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(329-350)<td><a href="#" name="0">(933-944)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>virtualenv_mod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import glob
2 import logging
3 import os
4 import re
5 import shutil
6 import sys
7 import salt.utils.files
8 import salt.utils.path
9 import salt.utils.platform
10 import salt.utils.verify
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 KNOWN_BINARY_NAMES = frozenset(
13     [
14         "virtualenv-{}.{}".format(*sys.version_info[:2]),
15         "virtualenv{}".format(sys.version_info[0]),
16         "virtualenv",
17     ]
18 )
19 log = logging.getLogger(__name__)
20 __opts__ = {"venv_bin": salt.utils.path.which_bin(KNOWN_BINARY_NAMES) or "virtualenv"}
21 __pillar__ = {}
22 __virtualname__ = "virtualenv"
23 def __virtual__():
24     return __virtualname__
25 def virtualenv_ver(venv_bin, user=None, **kwargs):
26     try:
27         import virtualenv
28         version = getattr(virtualenv, "__version__", None)
29         if not version:
30             version = virtualenv.virtualenv_version
31     except ImportError:
32         version_cmd = [venv_bin, "--version"]
33         ret = __salt__["cmd.run_all"](
34             version_cmd, runas=user, python_shell=False, redirect_stderr=True, **kwargs
35         )
36         if ret["retcode"] &gt; 0 or not ret["stdout"].strip():
37             raise CommandExecutionError(
38                 "Unable to get the virtualenv version output using '{}'. "
39                 "Returned data: {}".format(version_cmd, ret)
40             )
41         version = "".join(
42             [x for x in ret["stdout"].strip().split() if re.search(r"^\d.\d*", x)]
43         )
44     virtualenv_version_info = tuple(
45         int(i) for i in re.sub(r"(rc|\+ds).*$", "", version).split(".")
46     )
47     return virtualenv_version_info
48 def create(
49     path,
50     venv_bin=None,
51     system_site_packages=False,
52     distribute=False,
53     clear=False,
54     python=None,
55     extra_search_dir=None,
56     never_download=None,
57     prompt=None,
58     pip=False,
59     symlinks=None,
60     upgrade=None,
61     user=None,
62     use_vt=False,
63     saltenv="base",
64     **kwargs
65 ):
66     if venv_bin is None:
67         venv_bin = __opts__.get("venv_bin") or __pillar__.get("venv_bin")
68     cmd = [venv_bin]
69     if "pyvenv" not in venv_bin:
70         if upgrade is not None:
71             raise CommandExecutionError(
72                 "The `upgrade`(`--upgrade`) option is not supported by '{}'".format(
73                     venv_bin
74                 )
75             )
76         elif symlinks is not None:
77             raise CommandExecutionError(
78                 "The `symlinks`(`--symlinks`) option is not supported by '{}'".format(
79                     venv_bin
80                 )
81             )
82         virtualenv_version_info = virtualenv_ver(venv_bin, user=user, **kwargs)
83         if distribute:
84             if virtualenv_version_info &gt;= (1, 10):
85                 log.info(
86                     "The virtualenv '--distribute' option has been "
87                     "deprecated in virtualenv(&gt;=1.10), as such, the "
88                     "'distribute' option to `virtualenv.create()` has "
89                     "also been deprecated and it's not necessary anymore."
90                 )
91             else:
92                 cmd.append("--distribute")
93         if python is not None and python.strip() != "":
94             if not salt.utils.path.which(python):
95                 raise CommandExecutionError(
96                     "Cannot find requested python ({}).".format(python)
97                 )
98             cmd.append("--python={}".format(python))
99         if extra_search_dir is not None:
100             if isinstance(extra_search_dir, str) and extra_search_dir.strip() != "":
101                 extra_search_dir = [e.strip() for e in extra_search_dir.split(",")]
102             for entry in extra_search_dir:
103                 cmd.append("--extra-search-dir={}".format(entry))
104         if never_download is True:
105             if (1, 10) &lt;= virtualenv_version_info &lt; (14, 0, 0):
106                 log.info(
107                     "--never-download was deprecated in 1.10.0, but reimplemented in"
108                     " 14.0.0. If this feature is needed, please install a supported"
109                     " virtualenv version."
110                 )
111             else:
112                 cmd.append("--never-download")
113         if prompt is not None and prompt.strip() != "":
114             cmd.append("--prompt='{}'".format(prompt))
115     else:
116         if python is not None and python.strip() != "":
117             raise CommandExecutionError(
118                 "The `python`(`--python`) option is not supported by '{}'".format(
119                     venv_bin
120                 )
121             )
122         elif extra_search_dir is not None and extra_search_dir.strip() != "":
123             raise CommandExecutionError(
124                 "The `extra_search_dir`(`--extra-search-dir`) option is not "
125                 "supported by '{}'".format(venv_bin)
126             )
127         elif never_download is not None:
128             raise CommandExecutionError(
129                 "The `never_download`(`--never-download`) option is not "
130                 "supported by '{}'".format(venv_bin)
131             )
132         elif prompt is not None and prompt.strip() != "":
133             raise CommandExecutionError(
134                 "The `prompt`(`--prompt`) option is not supported by '{}'".format(
135                     venv_bin
136                 )
137             )
138         if upgrade is True:
139             cmd.append("--upgrade")
140         if symlinks is True:
141             cmd.append("--symlinks")
142     if clear is True:
143         cmd.append("--clear")
144     if system_site_packages is True:
145         cmd.append("--system-site-packages")
146     cmd.append(path)
147     ret = __salt__["cmd.run_all"](cmd, runas=user, python_shell=False, **kwargs)
148     if ret["retcode"] != 0:
149         return ret
150     if salt.utils.platform.is_windows():
151         venv_python = os.path.join(path, "Scripts", "python.exe")
152         venv_pip = os.path.join(path, "Scripts", "pip.exe")
153         venv_setuptools = os.path.join(path, "Scripts", "easy_install.exe")
154     else:
155         venv_python = os.path.join(path, "bin", "python")
156         venv_pip = os.path.join(path, "bin", "pip")
157         venv_setuptools = os.path.join(path, "bin", "easy_install")
158     if (pip or distribute) and not os.path.exists(venv_setuptools):
159         _install_script(
160             "https://bootstrap.pypa.io/ez_setup.py",
161             path,
162             venv_python,
163             user,
164             saltenv=saltenv,
165             use_vt=use_vt,
166         )
167         for fpath in glob.glob(os.path.join(path, "distribute-*.tar.gz*")):
168             os.unlink(fpath)
169     if ret["retcode"] != 0:
170         return ret
171     if pip and not os.path.exists(venv_pip):
172         _ret = _install_script(
173             "https://bootstrap.pypa.io/get-pip.py",
174             path,
175             venv_python,
176             user,
177             saltenv=saltenv,
178             use_vt=use_vt,
179         )
180 <a name="0"></a>        ret.update(
181             retcode=_ret["retcode"],
182             stdout="{}\n{}".format(ret["stdout"], _ret["stdout"]).strip(),
183             stderr="{}\n{}".format<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(ret["stderr"], _ret["stderr"]).strip(),
184         )
185     return ret
186 def get_site_packages(venv):
187     bin_path = _verify_virtualenv(venv)
188     ret = __salt__["cmd.exec_code_all"](</b></font>
189         bin_path,
190         "from distutils import sysconfig; print(sysconfig.get_python_lib())",
191     )
192     if ret["retcode"] != 0:
193         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
194     return ret["stdout"]
195 def get_distribution_path(venv, distribution):
196     _verify_safe_py_code(distribution)
197     bin_path = _verify_virtualenv(venv)
198     ret = __salt__["cmd.exec_code_all"](
199         bin_path,
200         "import pkg_resources; "
201         "print(pkg_resources.get_distribution('{}').location)".format(distribution),
202     )
203     if ret["retcode"] != 0:
204         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
205     return ret["stdout"]
206 def get_resource_path(venv, package=None, resource=None):
207     _verify_safe_py_code(package, resource)
208     bin_path = _verify_virtualenv(venv)
209     ret = __salt__["cmd.exec_code_all"](
210         bin_path,
211         "import pkg_resources; "
212         "print(pkg_resources.resource_filename('{}', '{}'))".format(package, resource),
213     )
214     if ret["retcode"] != 0:
215         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
216     return ret["stdout"]
217 def get_resource_content(venv, package=None, resource=None):
218     _verify_safe_py_code(package, resource)
219     bin_path = _verify_virtualenv(venv)
220     ret = __salt__["cmd.exec_code_all"](
221         bin_path,
222         "import pkg_resources; print(pkg_resources.resource_string('{}', '{}'))".format(
223             package, resource
224         ),
225     )
226     if ret["retcode"] != 0:
227         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
228     return ret["stdout"]
229 def _install_script(source, cwd, python, user, saltenv="base", use_vt=False):
230     if not salt.utils.platform.is_windows():
231         tmppath = salt.utils.files.mkstemp(dir=cwd)
232     else:
233         tmppath = __salt__["cp.cache_file"](source, saltenv)
234     if not salt.utils.platform.is_windows():
235         fn_ = __salt__["cp.cache_file"](source, saltenv)
236         shutil.copyfile(fn_, tmppath)
237         os.chmod(tmppath, 0o500)
238         os.chown(tmppath, __salt__["file.user_to_uid"](user), -1)
239     try:
240         return __salt__["cmd.run_all"](
241             [python, tmppath],
242             runas=user,
243             cwd=cwd,
244             env={"VIRTUAL_ENV": cwd},
245             use_vt=use_vt,
246             python_shell=False,
247         )
248     finally:
249         os.remove(tmppath)
250 def _verify_safe_py_code(*args):
251     for arg in args:
252         if not salt.utils.verify.safe_py_code(arg):
253             raise SaltInvocationError("Unsafe python code detected in '{}'".format(arg))
254 def _verify_virtualenv(venv_path):
255     bin_path = os.path.join(venv_path, "bin/python")
256     if not os.path.exists(bin_path):
257         raise CommandExecutionError(
258             "Path '{}' does not appear to be a virtualenv: bin/python not found.".format(
259                 venv_path
260             )
261         )
262     return bin_path
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>network_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import fnmatch
2 import itertools
3 import logging
4 import os
5 import platform
6 import random
7 import re
8 import socket
9 import subprocess
10 import types
11 from collections.abc import Mapping, Sequence
12 from string import ascii_letters, digits
13 import salt.utils.args
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.zeromq
19 from salt._compat import ipaddress
20 from salt.exceptions import SaltClientError, SaltSystemExit
21 from salt.utils.decorators.jinja import jinja_filter
22 from salt.utils.versions import LooseVersion
23 try:
24     import salt.utils.win_network
25     WIN_NETWORK_LOADED = True
26 except ImportError:
27     WIN_NETWORK_LOADED = False
28 log = logging.getLogger(__name__)
29 try:
30     import ctypes
31     import ctypes.util
32     LIBC = ctypes.cdll.LoadLibrary(ctypes.util.find_library("c"))
33     RES_INIT = LIBC.__res_init
34 except (ImportError, OSError, AttributeError, TypeError):
35     pass
36 class Interfaces:
37     __slots__ = ("interfaces",)
38     def __init__(self, interfaces=None):
39         if interfaces is None:
40             interfaces = {}
41         self.interfaces = interfaces
42     def __call__(self, *args, **kwargs):
43         if not self.interfaces:
44             self.interfaces = interfaces()
45         return self.interfaces
46     def clear(self):
47         self.interfaces = {}
48 _get_interfaces = Interfaces()
49 _clear_interfaces = _get_interfaces.clear
50 def sanitize_host(host):
51     RFC952_characters = ascii_letters + digits + ".-_"
52     return "".join([c for c in host[0:255] if c in RFC952_characters])
53 def isportopen(host, port):
54     if not 1 &lt;= int(port) &lt;= 65535:
55         return False
56     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
57     out = sock.connect_ex((sanitize_host(host), int(port)))
58     return out
59 def host_to_ips(host):
60     ips = []
61     try:
62         for family, socktype, proto, canonname, sockaddr in socket.getaddrinfo(
63             host, 0, socket.AF_UNSPEC, socket.SOCK_STREAM
64         ):
65             if family == socket.AF_INET:
66                 ip, port = sockaddr
67             elif family == socket.AF_INET6:
68                 ip, port, flow_info, scope_id = sockaddr
69             ips.append(ip)
70         if not ips:
71             ips = None
72     except Exception:  # pylint: disable=broad-except
73         ips = None
74     return ips
75 def _generate_minion_id():
76     class DistinctList(list):
77         localhost_matchers = [
78             r"localhost.*",
79             r"ip6-.*",
80             r"127[.]\d",
81             r"0\.0\.0\.0",
82             r"::1.*",
83             r"ipv6-.*",
84             r"fe00::.*",
85             r"fe02::.*",
86             r"1.0.0.*.ip6.arpa",
87         ]
88         def append(self, p_object):
89             if p_object and p_object not in self and not self.filter(p_object):
90                 super().append(p_object)
91             return self
92         def extend(self, iterable):
93             for obj in iterable:
94                 self.append(obj)
95             return self
96         def filter(self, element):
97             "Returns True if element needs to be filtered"
98             for rgx in self.localhost_matchers:
99                 if re.match(rgx, element):
100                     return True
101         def first(self):
102             return self and self[0] or None
103     hostname = socket.gethostname()
104     hosts = (
105         DistinctList()
106         .append(
107             salt.utils.stringutils.to_unicode(
108                 socket.getfqdn(salt.utils.stringutils.to_bytes(hostname))
109             )
110         )
111         .append(platform.node())
112         .append(hostname)
113     )
114     if not hosts:
115         try:
116             for a_nfo in socket.getaddrinfo(
117                 hosts.first() or "localhost",
118                 None,
119                 socket.AF_INET,
120                 socket.SOCK_RAW,
121                 socket.IPPROTO_IP,
122                 socket.AI_CANONNAME,
123             ):
124                 if len(a_nfo) &gt; 3:
125                     hosts.append(a_nfo[3])
126         except socket.gaierror:
127             log.warning(
128                 "Cannot resolve address %s info via socket: %s",
129                 hosts.first() or "localhost (N/A)",
130                 socket.gaierror,
131             )
132     for f_name in (
133         "/etc/hostname",
134         "/etc/nodename",
135         "/etc/hosts",
136         r"{win}\system32\drivers\etc\hosts".format(win=os.getenv("WINDIR")),
137     ):
138         try:
139             with salt.utils.files.fopen(f_name) as f_hdl:
140                 for line in f_hdl:
141                     line = salt.utils.stringutils.to_unicode(line)
142                     hst = line.strip().split("#")[0].strip().split()
143                     if hst:
144                         if hst[0][:4] in ("127.", "::1") or len(hst) == 1:
145                             hosts.extend(hst)
146         except OSError:
147             pass
148     return hosts.extend(
149         [addr for addr in ip_addrs() if not ipaddress.ip_address(addr).is_loopback]
150     )
151 def generate_minion_id():
152     try:
153         ret = salt.utils.stringutils.to_unicode(_generate_minion_id().first())
154     except TypeError:
155         ret = None
156     return ret or "localhost"
157 def get_socket(addr, type=socket.SOCK_STREAM, proto=0):
158     version = ipaddress.ip_address(addr).version
159     if version == 4:
160         family = socket.AF_INET
161     elif version == 6:
162         family = socket.AF_INET6
163     return socket.socket(family, type, proto)
164 def get_fqhostname():
165     l = [socket.getfqdn()]
166     try:
167         addrinfo = socket.getaddrinfo(
168             socket.gethostname(),
169             0,
170             socket.AF_UNSPEC,
171             socket.SOCK_STREAM,
172             socket.SOL_TCP,
173             socket.AI_CANONNAME,
174         )
175         for info in addrinfo:
176             if len(info) &gt;= 4 and info[3]:
177                 l = [info[3]]
178     except socket.gaierror:
179         pass
180     return l and l[0] or None
181 def ip_to_host(ip):
182     try:
183         hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)
184     except Exception as exc:  # pylint: disable=broad-except
185         log.debug("salt.utils.network.ip_to_host(%r) failed: %s", ip, exc)
186         hostname = None
187     return hostname
188 def is_reachable_host(entity_name):
189     try:
190         assert type(socket.getaddrinfo(entity_name, 0, 0, 0, 0)) == list
191         ret = True
192     except socket.gaierror:
193         ret = False
194     return ret
195 def is_ip(ip_addr):
196     return is_ipv4(ip_addr) or is_ipv6(ip_addr)
197 def is_ipv4(ip_addr):
198     try:
199         return ipaddress.ip_address(ip_addr).version == 4
200     except ValueError:
201         return False
202 def is_ipv6(ip_addr):
203     try:
204         return ipaddress.ip_address(ip_addr).version == 6
205     except ValueError:
206         return False
207 def is_subnet(cidr):
208     return is_ipv4_subnet(cidr) or is_ipv6_subnet(cidr)
209 def is_ipv4_subnet(cidr):
210     try:
211         return "/" in cidr and bool(ipaddress.IPv4Network(cidr))
212     except Exception:  # pylint: disable=broad-except
213         return False
214 def is_ipv6_subnet(cidr):
215     try:
216         return "/" in cidr and bool(ipaddress.IPv6Network(cidr))
217     except Exception:  # pylint: disable=broad-except
218         return False
219 @jinja_filter("is_ip")
220 def is_ip_filter(ip_addr, options=None):
221     return is_ipv4_filter(ip_addr, options=options) or is_ipv6_filter(
222         ip_addr, options=options
223     )
224 def _ip_options_global(ip_obj, version):
225     return not ip_obj.is_private
226 def _ip_options_multicast(ip_obj, version):
227     return ip_obj.is_multicast
228 def _ip_options_loopback(ip_obj, version):
229     return ip_obj.is_loopback
230 def _ip_options_link_local(ip_obj, version):
231     return ip_obj.is_link_local
232 def _ip_options_private(ip_obj, version):
233     return ip_obj.is_private
234 def _ip_options_reserved(ip_obj, version):
235     return ip_obj.is_reserved
236 def _ip_options_site_local(ip_obj, version):
237     if version == 6:
238         return ip_obj.is_site_local
239     return False
240 def _ip_options_unspecified(ip_obj, version):
241     return ip_obj.is_unspecified
242 def _ip_options(ip_obj, version, options=None):
243     options_fun_map = {
244         "global": _ip_options_global,
245         "link-local": _ip_options_link_local,
246         "linklocal": _ip_options_link_local,
247         "ll": _ip_options_link_local,
248         "link_local": _ip_options_link_local,
249         "loopback": _ip_options_loopback,
250         "lo": _ip_options_loopback,
251         "multicast": _ip_options_multicast,
252         "private": _ip_options_private,
253         "public": _ip_options_global,
254         "reserved": _ip_options_reserved,
255         "site-local": _ip_options_site_local,
256         "sl": _ip_options_site_local,
257         "site_local": _ip_options_site_local,
258         "unspecified": _ip_options_unspecified,
259     }
260     if not options:
261         return str(ip_obj)  # IP version already checked
262     options_list = [option.strip() for option in options.split(",")]
263     for option, fun in options_fun_map.items():
264         if option in options_list:
265             fun_res = fun(ip_obj, version)
266             if not fun_res:
267                 return None
268     return str(ip_obj)
269 def _is_ipv(ip_addr, version, options=None):
270     if not version:
271         version = 4
272     if version not in (4, 6):
273         return None
274     try:
275         ip_obj = ipaddress.ip_address(ip_addr)
276     except ValueError:
277         try:
278             ip_obj = ipaddress.ip_interface(ip_addr)
279         except ValueError:
280             return None
281     if not ip_obj.version == version:
282         return None
283     return _ip_options(ip_obj, version, options=options)
284 @jinja_filter("is_ipv4")
285 def is_ipv4_filter(ip_addr, options=None):
286     _is_ipv4 = _is_ipv(ip_addr, 4, options=options)
287     return isinstance(_is_ipv4, str)
288 @jinja_filter("is_ipv6")
289 def is_ipv6_filter(ip_addr, options=None):
290     _is_ipv6 = _is_ipv(ip_addr, 6, options=options)
291     return isinstance(_is_ipv6, str)
292 def _ipv_filter(value, version, options=None):
293     if version not in (4, 6):
294         return
295     if isinstance(value, (str, bytes)):
296         return _is_ipv(
297             value, version, options=options
298         )  # calls is_ipv4 or is_ipv6 for `value`
299     elif isinstance(value, (list, tuple, types.GeneratorType)):
300         return [
301             _is_ipv(addr, version, options=options)
302             for addr in value
303             if _is_ipv(addr, version, options=options) is not None
304         ]
305     return None
306 @jinja_filter("ipv4")
307 def ipv4(value, options=None):
308     return _ipv_filter(value, 4, options=options)
309 @jinja_filter("ipv6")
310 def ipv6(value, options=None):
311     return _ipv_filter(value, 6, options=options)
312 @jinja_filter("ipaddr")
313 def ipaddr(value, options=None):
314     ipv4_obj = ipv4(value, options=options)
315     ipv6_obj = ipv6(value, options=options)
316     if ipv4_obj is None or ipv6_obj is None:
317         return ipv4_obj or ipv6_obj  # one of them
318     else:
319         return ipv4_obj + ipv6_obj  # extend lists
320 def _filter_ipaddr(value, options, version=None):
321     ipaddr_filter_out = None
322     if version:
323         if version == 4:
324             ipaddr_filter_out = ipv4(value, options)
325         elif version == 6:
326             ipaddr_filter_out = ipv6(value, options)
327     else:
328         ipaddr_filter_out = ipaddr(value, options)
329     if not ipaddr_filter_out:
330         return
331     if not isinstance(ipaddr_filter_out, (list, tuple, types.GeneratorType)):
332         ipaddr_filter_out = [ipaddr_filter_out]
333     return ipaddr_filter_out
334 @jinja_filter("ip_host")
335 def ip_host(value, options=None, version=None):
336     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
337     if not ipaddr_filter_out:
338         return
339     if not isinstance(value, (list, tuple, types.GeneratorType)):
340         return str(ipaddress.ip_interface(ipaddr_filter_out[0]))
341     return [str(ipaddress.ip_interface(ip_a)) for ip_a in ipaddr_filter_out]
342 def _network_hosts(ip_addr_entry):
343     return [
344         str(host) for host in ipaddress.ip_network(ip_addr_entry, strict=False).hosts()
345     ]
346 @jinja_filter("network_hosts")
347 def network_hosts(value, options=None, version=None):
348     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
349     if not ipaddr_filter_out:
350         return
351     if not isinstance(value, (list, tuple, types.GeneratorType)):
352         return _network_hosts(ipaddr_filter_out[0])
353     return [_network_hosts(ip_a) for ip_a in ipaddr_filter_out]
354 def _network_size(ip_addr_entry):
355     return ipaddress.ip_network(ip_addr_entry, strict=False).num_addresses
356 @jinja_filter("network_size")
357 def network_size(value, options=None, version=None):
358     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
359     if not ipaddr_filter_out:
360         return
361     if not isinstance(value, (list, tuple, types.GeneratorType)):
362         return _network_size(ipaddr_filter_out[0])
363     return [_network_size(ip_a) for ip_a in ipaddr_filter_out]
364 def natural_ipv4_netmask(ip_addr, fmt="prefixlen"):
365     bits = _ipv4_to_bits(ip_addr)
366     if bits.startswith("11"):
367         mask = "24"
368     elif bits.startswith("1"):
369         mask = "16"
370     else:
371         mask = "8"
372     if fmt == "netmask":
373         return cidr_to_ipv4_netmask(mask)
374     else:
375         return "/" + mask
376 def rpad_ipv4_network(ip_addr):
377     return ".".join(itertools.islice(itertools.chain(ip_addr.split("."), "0000"), 0, 4))
378 def cidr_to_ipv4_netmask(cidr_bits):
379     try:
380         cidr_bits = int(cidr_bits)
381         if not 1 &lt;= cidr_bits &lt;= 32:
382             return ""
383     except ValueError:
384         return ""
385     netmask = ""
386     for idx in range(4):
387         if idx:
388             netmask += "."
389         if cidr_bits &gt;= 8:
390             netmask += "255"
391             cidr_bits -= 8
392         else:
393             netmask += "{:d}".format(256 - (2 ** (8 - cidr_bits)))
394             cidr_bits = 0
395     return netmask
396 def _number_of_set_bits_to_ipv4_netmask(set_bits):
397     return cidr_to_ipv4_netmask(_number_of_set_bits(set_bits))
398 def _number_of_set_bits(x):
399     x -= (x &gt;&gt; 1) &amp; 0x55555555
400     x = ((x &gt;&gt; 2) &amp; 0x33333333) + (x &amp; 0x33333333)
401     x = ((x &gt;&gt; 4) + x) &amp; 0x0F0F0F0F
402     x += x &gt;&gt; 8
403     x += x &gt;&gt; 16
404     return x &amp; 0x0000003F
405 def _interfaces_ip(out):
406     ret = dict()
407     def parse_network(value, cols):
408         brd = None
409         scope = None
410         if "/" in value:  # we have a CIDR in this address
411             ip, cidr = value.split("/")
412         else:
413             ip = value
414             cidr = 32
415         if type_ == "inet":
416             mask = cidr_to_ipv4_netmask(int(cidr))
417             if "brd" in cols:
418                 brd = cols[cols.index("brd") + 1]
419         elif type_ == "inet6":
420             mask = cidr
421             if "scope" in cols:
422                 scope = cols[cols.index("scope") + 1]
423         return (ip, mask, brd, scope)
424     groups = re.compile("\r?\n\\d").split(out)
425     for group in groups:
426         iface = None
427         data = dict()
428         for line in group.splitlines():
429             if " " not in line:
430                 continue
431             match = re.match(r"^\d*:\s+([\w.\-]+)(?:@)?([\w.\-]+)?:\s+&lt;(.+)&gt;", line)
432             if match:
433                 iface, parent, attrs = match.groups()
434                 if "UP" in attrs.split(","):
435                     data["up"] = True
436                 else:
437                     data["up"] = False
438                 if parent:
439                     data["parent"] = parent
440                 continue
441             cols = line.split()
442             if len(cols) &gt;= 2:
443                 type_, value = tuple(cols[0:2])
444                 iflabel = cols[-1:][0]
445                 if type_ in ("inet", "inet6"):
446                     ipaddr, netmask, broadcast, scope = parse_network(value, cols)
447                     addr_obj = dict()
448                     if "secondary" not in cols:
449                         if type_ == "inet":
450                             if "inet" not in data:
451                                 data["inet"] = list()
452                             addr_obj["address"] = ipaddr
453                             addr_obj["netmask"] = netmask
454                             addr_obj["broadcast"] = broadcast
455                             addr_obj["label"] = iflabel
456                             data["inet"].append(addr_obj)
457                         elif type_ == "inet6":
458                             if "inet6" not in data:
459                                 data["inet6"] = list()
460                             addr_obj["address"] = ipaddr
461                             addr_obj["prefixlen"] = netmask
462                             addr_obj["scope"] = scope
463                             data["inet6"].append(addr_obj)
464                     else:
465                         if type_ == "inet":
466                             if "secondary" not in data:
467                                 data["secondary"] = list()
468                             addr_obj["type"] = type_
469                             addr_obj["address"] = ipaddr
470                             addr_obj["netmask"] = netmask
471                             addr_obj["broadcast"] = broadcast
472                             addr_obj["label"] = iflabel
473                             data["secondary"].append(addr_obj)
474                         elif type_ == "inet6":
475                             if "secondary" not in data:
476                                 data["secondary"] = list()
477                             addr_obj["type"] = type_
478                             addr_obj["address"] = ipaddr
479                             addr_obj["prefixlen"] = netmask
480                             addr_obj["scope"] = scope
481                             data["secondary"].append(addr_obj)
482                 elif type_.startswith("link"):
483                     data["hwaddr"] = value
484         if iface:
485             ret[iface] = data
486             del iface, data
487     return ret
488 def _interfaces_ifconfig(out):
489     ret = dict()
490     piface = re.compile(r"^([^\s:]+)")
491     pmac = re.compile(".*?(?:HWaddr|ether|address:|lladdr) ([0-9a-fA-F:]+)")
492     if salt.utils.platform.is_sunos():
493         pip = re.compile(r".*?(?:inet\s+)([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(.*)")
494         pip6 = re.compile(".*?(?:inet6 )([0-9a-fA-F:]+)")
495         pmask6 = re.compile(r".*?(?:inet6 [0-9a-fA-F:]+/(\d+)).*")
496     else:
497         pip = re.compile(r".*?(?:inet addr:|inet [^\d]*)(.*?)\s")
498         pip6 = re.compile(".*?(?:inet6 addr: (.*?)/|inet6 )([0-9a-fA-F:]+)")
499         pmask6 = re.compile(
500             r".*?(?:inet6 addr: [0-9a-fA-F:]+/(\d+)|prefixlen (\d+))(?:"
501             r" Scope:([a-zA-Z]+)| scopeid (0x[0-9a-fA-F]))?"
502         )
503     pmask = re.compile(r".*?(?:Mask:|netmask )(?:((?:0x)?[0-9a-fA-F]{8})|([\d\.]+))")
504     pupdown = re.compile("UP")
505     pbcast = re.compile(r".*?(?:Bcast:|broadcast )([\d\.]+)")
506     groups = re.compile("\r?\n(?=\\S)").split(out)
507     for group in groups:
508         data = dict()
509         iface = ""
510         updown = False
511         for line in group.splitlines():
512             miface = piface.match(line)
513             mmac = pmac.match(line)
514             mip = pip.match(line)
515             mip6 = pip6.match(line)
516             mupdown = pupdown.search(line)
517             if miface:
518                 iface = miface.group(1)
519             if mmac:
520                 data["hwaddr"] = mmac.group(1)
521                 if salt.utils.platform.is_sunos():
522                     expand_mac = []
523                     for chunk in data["hwaddr"].split(":"):
524                         expand_mac.append(
525                             "0{}".format(chunk)
526                             if len(chunk) &lt; 2
527                             else "{}".format(chunk)
528                         )
529                     data["hwaddr"] = ":".join(expand_mac)
530             if mip:
531                 if "inet" not in data:
532                     data["inet"] = list()
533                 addr_obj = dict()
534                 addr_obj["address"] = mip.group(1)
535                 mmask = pmask.match(line)
536                 if mmask:
537                     if mmask.group(1):
538                         mmask = _number_of_set_bits_to_ipv4_netmask(
539                             int(mmask.group(1), 16)
540                         )
541                     else:
542                         mmask = mmask.group(2)
543                     addr_obj["netmask"] = mmask
544                 mbcast = pbcast.match(line)
545                 if mbcast:
546                     addr_obj["broadcast"] = mbcast.group(1)
547                 data["inet"].append(addr_obj)
548             if mupdown:
549                 updown = True
550             if mip6:
551                 if "inet6" not in data:
552                     data["inet6"] = list()
553                 addr_obj = dict()
554                 addr_obj["address"] = mip6.group(1) or mip6.group(2)
555                 mmask6 = pmask6.match(line)
556                 if mmask6:
557                     addr_obj["prefixlen"] = mmask6.group(1) or mmask6.group(2)
558                     if not salt.utils.platform.is_sunos():
559                         ipv6scope = mmask6.group(3) or mmask6.group(4)
560                         addr_obj["scope"] = (
561                             ipv6scope.lower() if ipv6scope is not None else ipv6scope
562                         )
563                 if (
564                     not salt.utils.platform.is_sunos()
565                     or addr_obj["address"] != "::"
566                     and addr_obj["prefixlen"] != 0
567                 ):
568                     data["inet6"].append(addr_obj)
569         data["up"] = updown
570         if iface in ret:
571             ret[iface] = dict(list(data.items()) + list(ret[iface].items()))
572             if "inet" in data:
573                 ret[iface]["inet"].extend(
574                     x for x in data["inet"] if x not in ret[iface]["inet"]
575                 )
576             if "inet6" in data:
577                 ret[iface]["inet6"].extend(
578                     x for x in data["inet6"] if x not in ret[iface]["inet6"]
579                 )
580         else:
581             ret[iface] = data
582         del data
583     return ret
584 def linux_interfaces():
585     ifaces = dict()
586     ip_path = salt.utils.path.which("ip")
587     ifconfig_path = None if ip_path else salt.utils.path.which("ifconfig")
588     if ip_path:
589         cmd1 = subprocess.Popen(
590             [ip_path, "link", "show"],
591             close_fds=True,
592             stdout=subprocess.PIPE,
593             stderr=subprocess.STDOUT,
594         ).communicate()[0]
595         cmd2 = subprocess.Popen(
596             [ip_path, "addr", "show"],
597             close_fds=True,
598             stdout=subprocess.PIPE,
599             stderr=subprocess.STDOUT,
600         ).communicate()[0]
601         ifaces = _interfaces_ip(
602             "{}\n{}".format(
603                 salt.utils.stringutils.to_str(cmd1), salt.utils.stringutils.to_str(cmd2)
604             )
605         )
606     elif ifconfig_path:
607         cmd = subprocess.Popen(
608             [ifconfig_path, "-a"],
609 <a name="0"></a>            stdout=subprocess.PIPE,
610             stderr=subprocess.STDOUT,
611         ).communicate()[0]
612         ifaces = _interfaces_ifconfig<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(salt.utils.stringutils.to_str(cmd))
613     return ifaces
614 def _netbsd_interfaces_ifconfig(out):
615     ret = dict()
616     piface = re.compile(</b></font>r"^([^\s:]+)")
617     pmac = re.compile(".*?address: ([0-9a-f:]+)")
618     pip = re.compile(r".*?inet [^\d]*(.*?)/([\d]*)\s")
619     pip6 = re.compile(r".*?inet6 ([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s")
620     pupdown = re.compile("UP")
621     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
622     groups = re.compile("\r?\n(?=\\S)").split(out)
623     for group in groups:
624         data = dict()
625         iface = ""
626         updown = False
627         for line in group.splitlines():
628             miface = piface.match(line)
629             mmac = pmac.match(line)
630             mip = pip.match(line)
631             mip6 = pip6.match(line)
632             mupdown = pupdown.search(line)
633             if miface:
634                 iface = miface.group(1)
635             if mmac:
636                 data["hwaddr"] = mmac.group(1)
637             if mip:
638                 if "inet" not in data:
639                     data["inet"] = list()
640                 addr_obj = dict()
641                 addr_obj["address"] = mip.group(1)
642                 mmask = mip.group(2)
643                 if mip.group(2):
644                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(2))
645                 mbcast = pbcast.match(line)
646                 if mbcast:
647                     addr_obj["broadcast"] = mbcast.group(1)
648                 data["inet"].append(addr_obj)
649             if mupdown:
650                 updown = True
651             if mip6:
652                 if "inet6" not in data:
653                     data["inet6"] = list()
654                 addr_obj = dict()
655                 addr_obj["address"] = mip6.group(1)
656                 mmask6 = mip6.group(3)
657                 addr_obj["scope"] = mip6.group(2)
658                 addr_obj["prefixlen"] = mip6.group(3)
659                 data["inet6"].append(addr_obj)
660         data["up"] = updown
661         ret[iface] = data
662         del data
663     return ret
664 def _junos_interfaces_ifconfig(out):
665     ret = dict()
666     piface = re.compile(r"^([^\s:]+)")
667     pmac = re.compile("curr media .*? ([0-9a-f:]+)")
668     pip = re.compile(
669         r".*?inet\s*(primary)*\s+mtu"
670         r" (\d+)\s+local=[^\d]*(.*?)\s+dest=[^\d]*(.*?)\/([\d]*)\s+bcast=((?:[0-9]{1,3}\.){3}[0-9]{1,3})"
671     )
672     pip6 = re.compile(
673         r".*?inet6 mtu [^\d]+\s+local=([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s"
674     )
675     pupdown = re.compile("UP")
676     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
677     groups = re.compile("\r?\n(?=\\S)").split(out)
678     for group in groups:
679         data = dict()
680         iface = ""
681         updown = False
682         primary = False
683         for line in group.splitlines():
684             miface = piface.match(line)
685             mmac = pmac.match(line)
686             mip = pip.match(line)
687             mip6 = pip6.match(line)
688             mupdown = pupdown.search(line)
689             if miface:
690                 iface = miface.group(1)
691             if mmac:
692                 data["hwaddr"] = mmac.group(1)
693             if mip:
694                 if "primary" in data:
695                     primary = True
696                 if "inet" not in data:
697                     data["inet"] = list()
698                 if mip.group(2):
699                     data["mtu"] = int(mip.group(2))
700                 addr_obj = dict()
701                 addr_obj["address"] = mip.group(3)
702                 mmask = mip.group(5)
703                 if mip.group(5):
704                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(5))
705                 mbcast = pbcast.match(line)
706                 if mbcast:
707                     addr_obj["broadcast"] = mbcast.group(1)
708                 data["inet"].append(addr_obj)
709             if mupdown:
710                 updown = True
711             if mip6:
712                 if "inet6" not in data:
713                     data["inet6"] = list()
714                 addr_obj = dict()
715                 addr_obj["address"] = mip6.group(1)
716                 mmask6 = mip6.group(3)
717                 addr_obj["scope"] = mip6.group(2)
718                 addr_obj["prefixlen"] = mip6.group(3)
719                 data["inet6"].append(addr_obj)
720         data["up"] = updown
721         ret[iface] = data
722         del data
723     return ret
724 def junos_interfaces():
725     ifconfig_path = salt.utils.path.which("ifconfig")
726     cmd = subprocess.Popen(
727         [ifconfig_path, "-a"],
728         stdout=subprocess.PIPE,
729         stderr=subprocess.STDOUT,
730     ).communicate()[0]
731     return _junos_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
732 def netbsd_interfaces():
733     if LooseVersion(os.uname()[2]) &lt; LooseVersion("8.0"):
734         return linux_interfaces()
735     ifconfig_path = salt.utils.path.which("ifconfig")
736     cmd = subprocess.Popen(
737         [ifconfig_path, "-a"],
738         stdout=subprocess.PIPE,
739         stderr=subprocess.STDOUT,
740     ).communicate()[0]
741     return _netbsd_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
742 def _interfaces_ipconfig(out):
743     ifaces = dict()
744     iface = None
745     addr = None
746     adapter_iface_regex = re.compile(r"adapter (\S.+):$")
747     for line in out.splitlines():
748         if not line:
749             continue
750         if line.startswith("Ethernet"):
751             iface = ifaces[adapter_iface_regex.search(line).group(1)]
752             iface["up"] = True
753             addr = {}
754             continue
755         if iface:
756             key, val = line.split(",", 1)
757             key = key.strip(" .")
758             val = val.strip()
759             if addr and key == "Subnet Mask":
760                 addr["netmask"] = val
761             elif key in ("IP Address", "IPv4 Address"):
762                 if "inet" not in iface:
763                     iface["inet"] = list()
764                 addr = {
765                     "address": val.rstrip("(Preferred)"),
766                     "netmask": None,
767                     "broadcast": None,
768                 }  # TODO find the broadcast
769                 iface["inet"].append(addr)
770             elif "IPv6 Address" in key:
771                 if "inet6" not in iface:
772                     iface["inet"] = list()
773                 addr = {"address": val.rstrip("(Preferred)"), "prefixlen": None}
774                 iface["inet6"].append(addr)
775             elif key == "Physical Address":
776                 iface["hwaddr"] = val
777             elif key == "Media State":
778                 iface["up"] = val != "Media disconnected"
779 def win_interfaces():
780     if WIN_NETWORK_LOADED is False:
781         import salt.utils.win_network as _
782     return salt.utils.win_network.get_interface_info()
783 def interfaces():
784     if salt.utils.platform.is_windows():
785         return win_interfaces()
786     elif salt.utils.platform.is_junos():
787         return junos_interfaces()
788     elif salt.utils.platform.is_netbsd():
789         return netbsd_interfaces()
790     else:
791         return linux_interfaces()
792 def get_net_start(ipaddr, netmask):
793     net = ipaddress.ip_network("{}/{}".format(ipaddr, netmask), strict=False)
794     return str(net.network_address)
795 def get_net_size(mask):
796     binary_str = ""
797     for octet in mask.split("."):
798         binary_str += bin(int(octet))[2:].zfill(8)
799     return len(binary_str.rstrip("0"))
800 def calc_net(ipaddr, netmask=None):
801     if netmask is not None:
802         ipaddr = "{}/{}".format(ipaddr, netmask)
803     return str(ipaddress.ip_network(ipaddr, strict=False))
804 def _ipv4_to_bits(ipaddr):
805     return "".join([bin(int(x))[2:].rjust(8, "0") for x in ipaddr.split(".")])
806 def _get_iface_info(iface):
807     iface_info = interfaces()
808     if iface in iface_info.keys():
809         return iface_info, False
810     else:
811         error_msg = 'Interface "{}" not in available interfaces: "{}"'.format(
812             iface, '", "'.join(iface_info.keys())
813         )
814         log.error(error_msg)
815         return None, error_msg
816 def _hw_addr_aix(iface):
817     cmd = subprocess.Popen(
818         ["grep", "Hardware Address"],
819         stdin=subprocess.Popen(
820             ["entstat", "-d", iface],
821             stdout=subprocess.PIPE,
822             stderr=subprocess.STDOUT,
823         ).stdout,
824         stdout=subprocess.PIPE,
825         stderr=subprocess.STDOUT,
826     ).communicate()[0]
827     if cmd:
828         comps = cmd.split(" ")
829         if len(comps) == 3:
830             mac_addr = comps[2].strip("'").strip()
831             return mac_addr
832     error_msg = 'Interface "{}" either not available or does not contain a hardware address'.format(
833         iface
834     )
835     log.error(error_msg)
836     return error_msg
837 def hw_addr(iface):
838     if salt.utils.platform.is_aix():
839         return _hw_addr_aix
840     iface_info, error = _get_iface_info(iface)
841     if error is False:
842         return iface_info.get(iface, {}).get("hwaddr", "")
843     else:
844         return error
845 def interface(iface):
846     iface_info, error = _get_iface_info(iface)
847     if error is False:
848         return iface_info.get(iface, {}).get("inet", "")
849     else:
850         return error
851 def interface_ip(iface):
852     iface_info, error = _get_iface_info(iface)
853     if error is False:
854         inet = iface_info.get(iface, {}).get("inet", None)
855         return inet[0].get("address", "") if inet else ""
856     else:
857         return error
858 def _subnets(proto="inet", interfaces_=None):
859     if interfaces_ is None:
860         ifaces = interfaces()
861     elif isinstance(interfaces_, list):
862         ifaces = {}
863         for key, value in interfaces().items():
864             if key in interfaces_:
865                 ifaces[key] = value
866     else:
867         ifaces = {interfaces_: interfaces().get(interfaces_, {})}
868     ret = set()
869     if proto == "inet":
870         subnet = "netmask"
871         dflt_cidr = 32
872     elif proto == "inet6":
873         subnet = "prefixlen"
874         dflt_cidr = 128
875     else:
876         log.error("Invalid proto %s calling subnets()", proto)
877         return
878     for ip_info in ifaces.values():
879         addrs = ip_info.get(proto, [])
880         addrs.extend(
881             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
882         )
883         for intf in addrs:
884             if subnet in intf:
885                 intf = ipaddress.ip_interface(
886                     "{}/{}".format(intf["address"], intf[subnet])
887                 )
888             else:
889                 intf = ipaddress.ip_interface(
890                     "{}/{}".format(intf["address"], dflt_cidr)
891                 )
892             if not intf.is_loopback:
893                 ret.add(intf.network)
894     return [str(net) for net in sorted(ret)]
895 def subnets(interfaces=None):
896     return _subnets("inet", interfaces_=interfaces)
897 def subnets6():
898     return _subnets("inet6")
899 def in_subnet(cidr, addr=None):
900     try:
901         cidr = ipaddress.ip_network(cidr)
902     except ValueError:
903         log.error("Invalid CIDR '%s'", cidr)
904         return False
905     if addr is None:
906         addr = ip_addrs()
907         addr.extend(ip_addrs6())
908     elif not isinstance(addr, (list, tuple)):
909         addr = (addr,)
910     return any(ipaddress.ip_address(item) in cidr for item in addr)
911 def _get_ips(ifaces, proto="inet"):
912     ret = []
913     for ip_info in ifaces.values():
914         ret.extend(ip_info.get(proto, []))
915         ret.extend(
916             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
917         )
918     return ret
919 def _filter_interfaces(interface=None, interface_data=None):
920     ifaces = interface_data if isinstance(interface_data, dict) else interfaces()
921     if interface is None:
922         ret = ifaces
923     else:
924         interface = salt.utils.args.split_input(interface)
925         ret = {
926             k: v
927             for k, v in ifaces.items()
928             if any(fnmatch.fnmatch(k, pat) for pat in interface)
929         }
930     return ret
931 def _ip_addrs(
932     interface=None, include_loopback=False, interface_data=None, proto="inet"
933 ):
934     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
935     ret = set()
936     for addr in addrs:
937         addr = ipaddress.ip_address(addr.get("address"))
938         if not addr.is_loopback or include_loopback:
939             ret.add(addr)
940     return [str(addr) for addr in sorted(ret)]
941 def ip_addrs(interface=None, include_loopback=False, interface_data=None):
942     return _ip_addrs(interface, include_loopback, interface_data, "inet")
943 def ip_addrs6(interface=None, include_loopback=False, interface_data=None):
944     return _ip_addrs(interface, include_loopback, interface_data, "inet6")
945 def _ip_networks(
946     interface=None,
947     include_loopback=False,
948     verbose=False,
949     interface_data=None,
950     proto="inet",
951 ):
952     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
953     ret = set()
954     for addr in addrs:
955         _ip = addr.get("address")
956         _net = addr.get("netmask" if proto == "inet" else "prefixlen")
957         if _ip and _net:
958             try:
959                 ip_net = ipaddress.ip_network("{}/{}".format(_ip, _net), strict=False)
960             except Exception:  # pylint: disable=broad-except
961                 continue
962             if not ip_net.is_loopback or include_loopback:
963                 ret.add(ip_net)
964     if not verbose:
965         return [str(addr) for addr in sorted(ret)]
966     verbose_ret = {
967         str(x): {
968             "address": str(x.network_address),
969             "netmask": str(x.netmask),
970             "num_addresses": x.num_addresses,
971             "prefixlen": x.prefixlen,
972         }
973         for x in ret
974     }
975     return verbose_ret
976 def ip_networks(
977     interface=None, include_loopback=False, verbose=False, interface_data=None
978 ):
979     return _ip_networks(
980         interface=interface,
981         include_loopback=include_loopback,
982         verbose=verbose,
983         interface_data=interface_data,
984         proto="inet",
985     )
986 def ip_networks6(
987     interface=None, include_loopback=False, verbose=False, interface_data=None
988 ):
989     return _ip_networks(
990         interface=interface,
991         include_loopback=include_loopback,
992         verbose=verbose,
993         interface_data=interface_data,
994         proto="inet6",
995     )
996 def hex2ip(hex_ip, invert=False):
997     if len(hex_ip) == 32:  # ipv6
998         ip_addr = []
999         for i in range(0, 32, 8):
1000             ip_part = hex_ip[i : i + 8]
1001             ip_part = [ip_part[x : x + 2] for x in range(0, 8, 2)]
1002             if invert:
1003                 ip_addr.append("{0[3]}{0[2]}:{0[1]}{0[0]}".format(ip_part))
1004             else:
1005                 ip_addr.append("{0[0]}{0[1]}:{0[2]}{0[3]}".format(ip_part))
1006         try:
1007             address = ipaddress.IPv6Address(":".join(ip_addr))
1008             if address.ipv4_mapped:
1009                 return str(address.ipv4_mapped)
1010             else:
1011                 return address.compressed
1012         except ipaddress.AddressValueError as ex:
1013             log.error("hex2ip - ipv6 address error: %s", ex)
1014             return hex_ip
1015     try:
1016         hip = int(hex_ip, 16)
1017     except ValueError:
1018         return hex_ip
1019     if invert:
1020         return "{3}.{2}.{1}.{0}".format(
1021             hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1022         )
1023     return "{}.{}.{}.{}".format(
1024         hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1025     )
1026 def mac2eui64(mac, prefix=None):
1027     eui64 = re.sub(r"[.:-]", "", mac).lower()
1028     eui64 = eui64[0:6] + "fffe" + eui64[6:]
1029     eui64 = hex(int(eui64[0:2], 16) | 2)[2:].zfill(2) + eui64[2:]
1030     if prefix is None:
1031         return ":".join(re.findall(r".{4}", eui64))
1032     else:
1033         try:
1034             net = ipaddress.ip_network(prefix, strict=False)
1035             euil = int("0x{}".format(eui64), 16)
1036             return "{}/{}".format(net[euil], net.prefixlen)
1037         except Exception:  # pylint: disable=broad-except
1038             return
1039 def active_tcp():
1040     ret = {}
1041     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1042         if not os.path.isfile(statf):
1043             continue
1044         with salt.utils.files.fopen(statf, "rb") as fp_:
1045             for line in fp_:
1046                 line = salt.utils.stringutils.to_unicode(line)
1047                 if line.strip().startswith("sl"):
1048                     continue
1049                 iret = _parse_tcp_line(line)
1050                 slot = next(iter(iret))
1051                 if iret[slot]["state"] == 1:  # 1 is ESTABLISHED
1052                     del iret[slot]["state"]
1053                     ret[len(ret)] = iret[slot]
1054     return ret
1055 def local_port_tcp(port):
1056     ret = _remotes_on(port, "local_port")
1057     return ret
1058 def remote_port_tcp(port):
1059     ret = _remotes_on(port, "remote_port")
1060     return ret
1061 def _remotes_on(port, which_end):
1062     port = int(port)
1063     ret = _netlink_tool_remote_on(port, which_end)
1064     if ret is not None:
1065         return ret
1066     ret = set()
1067     proc_available = False
1068     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1069         if not os.path.isfile(statf):
1070             continue
1071         proc_available = True
1072         with salt.utils.files.fopen(statf, "r") as fp_:
1073             for line in fp_:
1074                 line = salt.utils.stringutils.to_unicode(line)
1075                 if line.strip().startswith("sl"):
1076                     continue
1077                 iret = _parse_tcp_line(line)
1078                 slot = next(iter(iret))
1079                 if (
1080                     iret[slot][which_end] == port and iret[slot]["state"] == 1
1081                 ):  # 1 is ESTABLISHED
1082                     ret.add(iret[slot]["remote_addr"])
1083     if not proc_available:  # Fallback to use OS specific tools
1084         if salt.utils.platform.is_sunos():
1085             return _sunos_remotes_on(port, which_end)
1086         if salt.utils.platform.is_freebsd():
1087             return _freebsd_remotes_on(port, which_end)
1088         if salt.utils.platform.is_netbsd():
1089             return _netbsd_remotes_on(port, which_end)
1090         if salt.utils.platform.is_openbsd():
1091             return _openbsd_remotes_on(port, which_end)
1092         if salt.utils.platform.is_windows():
1093             return _windows_remotes_on(port, which_end)
1094         if salt.utils.platform.is_aix():
1095             return _aix_remotes_on(port, which_end)
1096         return _linux_remotes_on(port, which_end)
1097     return ret
1098 def _parse_tcp_line(line):
1099     ret = {}
1100     comps = line.strip().split()
1101     slot = comps[0].rstrip(":")
1102     ret[slot] = {}
1103     l_addr, l_port = comps[1].split(":")
1104     r_addr, r_port = comps[2].split(":")
1105     ret[slot]["local_addr"] = hex2ip(l_addr, True)
1106     ret[slot]["local_port"] = int(l_port, 16)
1107     ret[slot]["remote_addr"] = hex2ip(r_addr, True)
1108     ret[slot]["remote_port"] = int(r_port, 16)
1109     ret[slot]["state"] = int(comps[3], 16)
1110     return ret
1111 def _netlink_tool_remote_on(port, which_end):
1112     remotes = set()
1113     valid = False
1114     tcp_end = "dst" if which_end == "remote_port" else "src"
1115     try:
1116         data = subprocess.check_output(
1117             ["ss", "-ant", tcp_end, ":{}".format(port)]
1118         )  # pylint: disable=minimum-python-version
1119     except subprocess.CalledProcessError:
1120         log.error("Failed ss")
1121         raise
1122     except OSError:  # not command "No such file or directory"
1123         return None
1124     lines = salt.utils.stringutils.to_str(data).split("\n")
1125     for line in lines:
1126         if "Address:Port" in line:  # ss tools may not be valid
1127             valid = True
1128             continue
1129         elif "ESTAB" not in line:
1130             continue
1131         chunks = line.split()
1132         remote_host, remote_port = chunks[4].rsplit(":", 1)
1133         remotes.add(remote_host.strip("[]"))
1134     if valid is False:
1135         remotes = None
1136     return remotes
1137 def _sunos_remotes_on(port, which_end):
1138     remotes = set()
1139     try:
1140         data = subprocess.check_output(
1141             ["netstat", "-f", "inet", "-n"]
1142         )  # pylint: disable=minimum-python-version
1143     except subprocess.CalledProcessError:
1144         log.error("Failed netstat")
1145         raise
1146     lines = salt.utils.stringutils.to_str(data).split("\n")
1147     for line in lines:
1148         if "ESTABLISHED" not in line:
1149             continue
1150         chunks = line.split()
1151         local_host, local_port = chunks[0].rsplit(".", 1)
1152         remote_host, remote_port = chunks[1].rsplit(".", 1)
1153         if which_end == "remote_port" and int(remote_port) != port:
1154             continue
1155         if which_end == "local_port" and int(local_port) != port:
1156             continue
1157         remotes.add(remote_host)
1158     return remotes
1159 def _freebsd_remotes_on(port, which_end):
1160     port = int(port)
1161     remotes = set()
1162     try:
1163         cmd = salt.utils.args.shlex_split("sockstat -4 -c -p {}".format(port))
1164         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1165     except subprocess.CalledProcessError as ex:
1166         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1167         raise
1168     lines = salt.utils.stringutils.to_str(data).split("\n")
1169     for line in lines:
1170         chunks = line.split()
1171         if not chunks:
1172             continue
1173         if "COMMAND" in chunks[1]:
1174             continue  # ignore header
1175         if len(chunks) &lt; 2:
1176             continue
1177         local = chunks[-2]
1178         remote = chunks[-1]
1179         lhost, lport = local.split(":")
1180         rhost, rport = remote.split(":")
1181         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1182             continue
1183         if (
1184             which_end == "remote" and int(rport) != port
1185         ):  # ignore if remote port not port
1186             continue
1187         remotes.add(rhost)
1188     return remotes
1189 def _netbsd_remotes_on(port, which_end):
1190     port = int(port)
1191     remotes = set()
1192     try:
1193         cmd = salt.utils.args.shlex_split("sockstat -4 -c -n -p {}".format(port))
1194         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1195     except subprocess.CalledProcessError as ex:
1196         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1197         raise
1198     lines = salt.utils.stringutils.to_str(data).split("\n")
1199     for line in lines:
1200         chunks = line.split()
1201         if not chunks:
1202             continue
1203         if "COMMAND" in chunks[1]:
1204             continue  # ignore header
1205         if len(chunks) &lt; 2:
1206             continue
1207         local = chunks[5].split(".")
1208         lport = local.pop()
1209         lhost = ".".join(local)
1210         remote = chunks[6].split(".")
1211         rport = remote.pop()
1212         rhost = ".".join(remote)
1213         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1214             continue
1215         if (
1216             which_end == "remote" and int(rport) != port
1217         ):  # ignore if remote port not port
1218             continue
1219         remotes.add(rhost)
1220     return remotes
1221 def _openbsd_remotes_on(port, which_end):
1222     remotes = set()
1223     try:
1224         data = subprocess.check_output(
1225             ["netstat", "-nf", "inet"]
1226         )  # pylint: disable=minimum-python-version
1227     except subprocess.CalledProcessError:
1228         log.error("Failed netstat")
1229         raise
1230     lines = data.split("\n")
1231     for line in lines:
1232         if "ESTABLISHED" not in line:
1233             continue
1234         chunks = line.split()
1235         local_host, local_port = chunks[3].rsplit(".", 1)
1236         remote_host, remote_port = chunks[4].rsplit(".", 1)
1237         if which_end == "remote_port" and int(remote_port) != port:
1238             continue
1239         if which_end == "local_port" and int(local_port) != port:
1240             continue
1241         remotes.add(remote_host)
1242     return remotes
1243 def _windows_remotes_on(port, which_end):
1244     r"""
1245     Windows specific helper function.
1246     Returns set of ipv4 host addresses of remote established connections
1247     on local or remote tcp port.
1248     Parses output of shell 'netstat' to get connections
1249     C:\&gt;netstat -n
1250     Active Connections
1251        Proto  Local Address          Foreign Address        State
1252        TCP    10.2.33.17:3007        130.164.12.233:10123   ESTABLISHED
1253        TCP    10.2.33.17:3389        130.164.30.5:10378     ESTABLISHED
1254     Linux specific helper function.
1255     Returns set of ip host addresses of remote established connections
1256     on local tcp port port.
1257     Parses output of shell 'lsof'
1258     to get connections
1259     $ sudo lsof -iTCP:4505 -n
1260     COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
1261     Python   9971 root   35u  IPv4 0x18a8464a29ca329d      0t0  TCP *:4505 (LISTEN)
1262     Python   9971 root   37u  IPv4 0x18a8464a29b2b29d      0t0  TCP 127.0.0.1:4505-&gt;127.0.0.1:55703 (ESTABLISHED)
1263     Python  10152 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP 127.0.0.1:55703-&gt;127.0.0.1:4505 (ESTABLISHED)
1264     Python  10153 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP [fe80::249a]:4505-&gt;[fe80::150]:59367 (ESTABLISHED)
1265     """
1266     remotes = set()
1267     try:
1268         data = subprocess.check_output(
1269             [
1270                 "lsof",
1271                 "-iTCP:{:d}".format(port),
1272                 "-n",
1273                 "-P",
1274             ]  # pylint: disable=minimum-python-version
1275         )
1276     except subprocess.CalledProcessError as ex:
1277         if ex.returncode == 1:
1278             log.warning('"lsof" returncode = 1, likely no active TCP sessions.')
1279             return remotes
1280         log.error('Failed "lsof" with returncode = %s', ex.returncode)
1281         raise
1282     lines = salt.utils.stringutils.to_str(data).split("\n")
1283     for line in lines:
1284         chunks = line.split()
1285         if not chunks:
1286             continue
1287         if "COMMAND" in chunks[0]:
1288             continue  # ignore header
1289         if "ESTABLISHED" not in chunks[-1]:
1290             continue  # ignore if not ESTABLISHED
1291         local, remote = chunks[8].split("-&gt;")
1292         _, lport = local.rsplit(":", 1)
1293         rhost, rport = remote.rsplit(":", 1)
1294         if which_end == "remote_port" and int(rport) != port:
1295             continue
1296         if which_end == "local_port" and int(lport) != port:
1297             continue
1298         remotes.add(rhost.strip("[]"))
1299     return remotes
1300 def _aix_remotes_on(port, which_end):
1301     remotes = set()
1302     try:
1303         data = subprocess.check_output(
1304             ["netstat", "-f", "inet", "-n"]
1305         )  # pylint: disable=minimum-python-version
1306     except subprocess.CalledProcessError:
1307         log.error("Failed netstat")
1308         raise
1309     lines = salt.utils.stringutils.to_str(data).split("\n")
1310     for line in lines:
1311         if "ESTABLISHED" not in line:
1312             continue
1313         chunks = line.split()
1314         local_host, local_port = chunks[3].rsplit(".", 1)
1315         remote_host, remote_port = chunks[4].rsplit(".", 1)
1316         if which_end == "remote_port" and int(remote_port) != port:
1317             continue
1318         if which_end == "local_port" and int(local_port) != port:
1319             continue
1320         remotes.add(remote_host)
1321     return remotes
1322 @jinja_filter("gen_mac")
1323 def gen_mac(prefix="AC:DE:48"):
1324     return "{}:{:02X}:{:02X}:{:02X}".format(
1325         prefix,
1326         random.randint(0, 0xFF),
1327         random.randint(0, 0xFF),
1328         random.randint(0, 0xFF),
1329     )
1330 @jinja_filter("mac_str_to_bytes")
1331 def mac_str_to_bytes(mac_str):
1332     if len(mac_str) == 12:
1333         pass
1334     elif len(mac_str) == 17:
1335         sep = mac_str[2]
1336         mac_str = mac_str.replace(sep, "")
1337     else:
1338         raise ValueError("Invalid MAC address")
1339     chars = (int(mac_str[s : s + 2], 16) for s in range(0, 12, 2))
1340     return bytes(chars)
1341 def refresh_dns():
1342     try:
1343         RES_INIT()
1344     except NameError:
1345         pass
1346 @jinja_filter("dns_check")
1347 def dns_check(addr, port, safe=False, ipv6=None):
1348     ip_addrs = []
1349     family = (
1350         socket.AF_INET6
1351         if ipv6
1352         else socket.AF_INET
1353         if ipv6 is False
1354         else socket.AF_UNSPEC
1355     )
1356     socket_error = False
1357     try:
1358         refresh_dns()
1359         addrinfo = socket.getaddrinfo(addr, port, family, socket.SOCK_STREAM)
1360         ip_addrs = _test_addrs(addrinfo, port)
1361     except TypeError:
1362         raise SaltSystemExit(
1363             code=42,
1364             msg=(
1365                 "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1366                 " address".format(addr)
1367             ),
1368         )
1369     except OSError:
1370         socket_error = True
1371     if socket_error and ipv6:
1372         try:
1373             refresh_dns()
1374             addrinfo = socket.getaddrinfo(
1375                 addr, port, socket.AF_INET, socket.SOCK_STREAM
1376             )
1377             ip_addrs = _test_addrs(addrinfo, port)
1378         except TypeError:
1379             raise SaltSystemExit(
1380                 code=42,
1381                 msg=(
1382                     "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1383                     " address".format(addr)
1384                 ),
1385             )
1386         except OSError:
1387             error = True
1388     if not ip_addrs:
1389         err = "DNS lookup or connection check of '{}' failed.".format(addr)
1390         if safe:
1391             if salt.log.is_console_configured():
1392                 log.error(err)
1393             raise SaltClientError()
1394         raise SaltSystemExit(code=42, msg=err)
1395     return salt.utils.zeromq.ip_bracket(ip_addrs[0])
1396 def _test_addrs(addrinfo, port):
1397     ip_addrs = []
1398     for a in addrinfo:
1399         ip_family = a[0]
1400         ip_addr = a[4][0]
1401         if ip_addr in ip_addrs:
1402             continue
1403         ip_addrs.append(ip_addr)
1404         try:
1405             s = socket.socket(ip_family, socket.SOCK_STREAM)
1406             s.settimeout(2)
1407             s.connect((ip_addr, port))
1408             s.close()
1409             ip_addrs = [ip_addr]
1410             break
1411         except OSError:
1412             pass
1413     return ip_addrs
1414 def parse_host_port(host_port):
1415     host, port = None, None  # default
1416     _s_ = host_port[:]
1417     if _s_[0] == "[":
1418         if "]" in host_port:
1419             host, _s_ = _s_.lstrip("[").rsplit("]", 1)
1420             host = ipaddress.IPv6Address(host).compressed
1421             if _s_[0] == ":":
1422                 port = int(_s_.lstrip(":"))
1423             else:
1424                 if len(_s_) &gt; 1:
1425                     raise ValueError(
1426                         'found ambiguous "{}" port in "{}"'.format(_s_, host_port)
1427                     )
1428     else:
1429         if _s_.count(":") == 1:
1430             host, _hostport_separator_, port = _s_.partition(":")
1431             try:
1432                 port = int(port)
1433             except ValueError as _e_:
1434                 errmsg = 'host_port "{}" port value "{}" is not an integer.'.format(
1435                     host_port, port
1436                 )
1437                 log.error(errmsg)
1438                 raise ValueError(errmsg)
1439         else:
1440             host = _s_
1441     try:
1442         if not isinstance(host, ipaddress._BaseAddress):
1443             host_ip = ipaddress.ip_address(host).compressed
1444             host = host_ip
1445     except ValueError:
1446         log.debug('"%s" Not an IP address? Assuming it is a hostname.', host)
1447         if host != sanitize_host(host):
1448             log.error('bad hostname: "%s"', host)
1449             raise ValueError('bad hostname: "{}"'.format(host))
1450     return host, port
1451 @jinja_filter("filter_by_networks")
1452 def filter_by_networks(values, networks):
1453     _filter = lambda ips, networks: [
1454         ip for ip in ips for net in networks if ipaddress.ip_address(ip) in net
1455     ]
1456     if networks is not None:
1457         networks = [ipaddress.ip_network(network) for network in networks]
1458         if isinstance(values, Mapping):
1459             return {
1460                 interface: _filter(values[interface], networks) for interface in values
1461             }
1462         elif isinstance(values, Sequence):
1463             return _filter(values, networks)
1464         else:
1465             raise ValueError("Do not know how to filter a {}".format(type(values)))
1466     else:
1467         return values
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
