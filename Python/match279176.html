<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for virtualenv_mod_1.py &amp; network_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for virtualenv_mod_1.py &amp; network_4.py
      </h3>
<h1 align="center">
        0.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>virtualenv_mod_1.py (2.9411764%)<th>network_4.py (0.44177973%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(329-350)<td><a href="#" name="0">(933-944)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>virtualenv_mod_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import glob
2 import logging
3 import os
4 import re
5 import shutil
6 import sys
7 import salt.utils.files
8 import salt.utils.path
9 import salt.utils.platform
10 import salt.utils.verify
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 KNOWN_BINARY_NAMES = frozenset(
13     [
14         "virtualenv-{}.{}".format(*sys.version_info[:2]),
15         "virtualenv{}".format(sys.version_info[0]),
16         "virtualenv",
17     ]
18 )
19 log = logging.getLogger(__name__)
20 __opts__ = {"venv_bin": salt.utils.path.which_bin(KNOWN_BINARY_NAMES) or "virtualenv"}
21 __pillar__ = {}
22 __virtualname__ = "virtualenv"
23 def __virtual__():
24     return __virtualname__
25 def virtualenv_ver(venv_bin, user=None, **kwargs):
26     try:
27         import virtualenv
28         version = getattr(virtualenv, "__version__", None)
29         if not version:
30             version = virtualenv.virtualenv_version
31     except ImportError:
32         version_cmd = [venv_bin, "--version"]
33         ret = __salt__["cmd.run_all"](
34             version_cmd, runas=user, python_shell=False, redirect_stderr=True, **kwargs
35         )
36         if ret["retcode"] &gt; 0 or not ret["stdout"].strip():
37             raise CommandExecutionError(
38                 "Unable to get the virtualenv version output using '{}'. "
39                 "Returned data: {}".format(version_cmd, ret)
40             )
41         version = "".join(
42             [x for x in ret["stdout"].strip().split() if re.search(r"^\d.\d*", x)]
43         )
44     virtualenv_version_info = tuple(
45         int(i) for i in re.sub(r"(rc|\+ds).*$", "", version).split(".")
46     )
47     return virtualenv_version_info
48 def create(
49     path,
50     venv_bin=None,
51     system_site_packages=False,
52     distribute=False,
53     clear=False,
54     python=None,
55     extra_search_dir=None,
56     never_download=None,
57     prompt=None,
58     pip=False,
59     symlinks=None,
60     upgrade=None,
61     user=None,
62     use_vt=False,
63     saltenv="base",
64     **kwargs
65 ):
66     if venv_bin is None:
67         venv_bin = __opts__.get("venv_bin") or __pillar__.get("venv_bin")
68     cmd = [venv_bin]
69     if "pyvenv" not in venv_bin:
70         if upgrade is not None:
71             raise CommandExecutionError(
72                 "The `upgrade`(`--upgrade`) option is not supported by '{}'".format(
73                     venv_bin
74                 )
75             )
76         elif symlinks is not None:
77             raise CommandExecutionError(
78                 "The `symlinks`(`--symlinks`) option is not supported by '{}'".format(
79                     venv_bin
80                 )
81             )
82         virtualenv_version_info = virtualenv_ver(venv_bin, user=user, **kwargs)
83         if distribute:
84             if virtualenv_version_info &gt;= (1, 10):
85                 log.info(
86                     "The virtualenv '--distribute' option has been "
87                     "deprecated in virtualenv(&gt;=1.10), as such, the "
88                     "'distribute' option to `virtualenv.create()` has "
89                     "also been deprecated and it's not necessary anymore."
90                 )
91             else:
92                 cmd.append("--distribute")
93         if python is not None and python.strip() != "":
94             if not salt.utils.path.which(python):
95                 raise CommandExecutionError(
96                     "Cannot find requested python ({}).".format(python)
97                 )
98             cmd.append("--python={}".format(python))
99         if extra_search_dir is not None:
100             if isinstance(extra_search_dir, str) and extra_search_dir.strip() != "":
101                 extra_search_dir = [e.strip() for e in extra_search_dir.split(",")]
102             for entry in extra_search_dir:
103                 cmd.append("--extra-search-dir={}".format(entry))
104         if never_download is True:
105             if (1, 10) &lt;= virtualenv_version_info &lt; (14, 0, 0):
106                 log.info(
107                     "--never-download was deprecated in 1.10.0, but reimplemented in"
108                     " 14.0.0. If this feature is needed, please install a supported"
109                     " virtualenv version."
110                 )
111             else:
112                 cmd.append("--never-download")
113         if prompt is not None and prompt.strip() != "":
114             cmd.append("--prompt='{}'".format(prompt))
115     else:
116         if python is not None and python.strip() != "":
117             raise CommandExecutionError(
118                 "The `python`(`--python`) option is not supported by '{}'".format(
119                     venv_bin
120                 )
121             )
122         elif extra_search_dir is not None and extra_search_dir.strip() != "":
123             raise CommandExecutionError(
124                 "The `extra_search_dir`(`--extra-search-dir`) option is not "
125                 "supported by '{}'".format(venv_bin)
126             )
127         elif never_download is not None:
128             raise CommandExecutionError(
129                 "The `never_download`(`--never-download`) option is not "
130                 "supported by '{}'".format(venv_bin)
131             )
132         elif prompt is not None and prompt.strip() != "":
133             raise CommandExecutionError(
134                 "The `prompt`(`--prompt`) option is not supported by '{}'".format(
135                     venv_bin
136                 )
137             )
138         if upgrade is True:
139             cmd.append("--upgrade")
140         if symlinks is True:
141             cmd.append("--symlinks")
142     if clear is True:
143         cmd.append("--clear")
144     if system_site_packages is True:
145         cmd.append("--system-site-packages")
146     cmd.append(path)
147     ret = __salt__["cmd.run_all"](cmd, runas=user, python_shell=False, **kwargs)
148     if ret["retcode"] != 0:
149         return ret
150     if salt.utils.platform.is_windows():
151         venv_python = os.path.join(path, "Scripts", "python.exe")
152         venv_pip = os.path.join(path, "Scripts", "pip.exe")
153         venv_setuptools = os.path.join(path, "Scripts", "easy_install.exe")
154     else:
155         venv_python = os.path.join(path, "bin", "python")
156         venv_pip = os.path.join(path, "bin", "pip")
157         venv_setuptools = os.path.join(path, "bin", "easy_install")
158     if (pip or distribute) and not os.path.exists(venv_setuptools):
159         _install_script(
160             "https://bootstrap.pypa.io/ez_setup.py",
161             path,
162             venv_python,
163             user,
164             saltenv=saltenv,
165             use_vt=use_vt,
166         )
167         for fpath in glob.glob(os.path.join(path, "distribute-*.tar.gz*")):
168             os.unlink(fpath)
169     if ret["retcode"] != 0:
170         return ret
171     if pip and not os.path.exists(venv_pip):
172         _ret = _install_script(
173             "https://bootstrap.pypa.io/get-pip.py",
174             path,
175             venv_python,
176             user,
177             saltenv=saltenv,
178             use_vt=use_vt,
179         )
180             retcode=_ret["retcode"],
181             stdout="{}\n{}".format(ret["stdout"], _ret["stdout"]).strip(),
182             stderr="{}\n{}".format<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(ret["stderr"], _ret["stderr"]).strip(),
183         )
184     return ret
185 def get_site_packages(venv):
186     bin_path = _verify_virtualenv(venv)
187     ret = __salt__["cmd.exec_code_all"](</b></font>
188         bin_path,
189         "from distutils import sysconfig; print(sysconfig.get_python_lib())",
190     )
191     if ret["retcode"] != 0:
192         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
193     return ret["stdout"]
194 def get_distribution_path(venv, distribution):
195     _verify_safe_py_code(distribution)
196     bin_path = _verify_virtualenv(venv)
197     ret = __salt__["cmd.exec_code_all"](
198         bin_path,
199         "import pkg_resources; "
200         "print(pkg_resources.get_distribution('{}').location)".format(distribution),
201     )
202     if ret["retcode"] != 0:
203         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
204     return ret["stdout"]
205 def get_resource_path(venv, package=None, resource=None):
206     _verify_safe_py_code(package, resource)
207     bin_path = _verify_virtualenv(venv)
208     ret = __salt__["cmd.exec_code_all"](
209         bin_path,
210         "import pkg_resources; "
211         "print(pkg_resources.resource_filename('{}', '{}'))".format(package, resource),
212     )
213     if ret["retcode"] != 0:
214         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
215     return ret["stdout"]
216 def get_resource_content(venv, package=None, resource=None):
217     _verify_safe_py_code(package, resource)
218     bin_path = _verify_virtualenv(venv)
219     ret = __salt__["cmd.exec_code_all"](
220         bin_path,
221         "import pkg_resources; print(pkg_resources.resource_string('{}', '{}'))".format(
222             package, resource
223         ),
224     )
225     if ret["retcode"] != 0:
226         raise CommandExecutionError("{stdout}\n{stderr}".format(**ret))
227     return ret["stdout"]
228 def _install_script(source, cwd, python, user, saltenv="base", use_vt=False):
229     if not salt.utils.platform.is_windows():
230         tmppath = salt.utils.files.mkstemp(dir=cwd)
231     else:
232         tmppath = __salt__["cp.cache_file"](source, saltenv)
233     if not salt.utils.platform.is_windows():
234         fn_ = __salt__["cp.cache_file"](source, saltenv)
235         shutil.copyfile(fn_, tmppath)
236         os.chmod(tmppath, 0o500)
237         os.chown(tmppath, __salt__["file.user_to_uid"](user), -1)
238     try:
239         return __salt__["cmd.run_all"](
240             [python, tmppath],
241             runas=user,
242             cwd=cwd,
243             env={"VIRTUAL_ENV": cwd},
244             use_vt=use_vt,
245             python_shell=False,
246         )
247     finally:
248         os.remove(tmppath)
249 def _verify_safe_py_code(*args):
250     for arg in args:
251         if not salt.utils.verify.safe_py_code(arg):
252             raise SaltInvocationError("Unsafe python code detected in '{}'".format(arg))
253 def _verify_virtualenv(venv_path):
254     bin_path = os.path.join(venv_path, "bin/python")
255     if not os.path.exists(bin_path):
256         raise CommandExecutionError(
257             "Path '{}' does not appear to be a virtualenv: bin/python not found.".format(
258                 venv_path
259             )
260         )
261     return bin_path
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>network_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import fnmatch
2 import itertools
3 import logging
4 import os
5 import platform
6 import random
7 import re
8 import socket
9 import subprocess
10 import types
11 from collections.abc import Mapping, Sequence
12 from string import ascii_letters, digits
13 import salt.utils.args
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.zeromq
19 from salt._compat import ipaddress
20 from salt.exceptions import SaltClientError, SaltSystemExit
21 from salt.utils.decorators.jinja import jinja_filter
22 from salt.utils.versions import LooseVersion
23 try:
24     import salt.utils.win_network
25     WIN_NETWORK_LOADED = True
26 except ImportError:
27     WIN_NETWORK_LOADED = False
28 log = logging.getLogger(__name__)
29 try:
30     import ctypes
31     import ctypes.util
32     LIBC = ctypes.cdll.LoadLibrary(ctypes.util.find_library("c"))
33     RES_INIT = LIBC.__res_init
34 except (ImportError, OSError, AttributeError, TypeError):
35     pass
36 class Interfaces:
37     __slots__ = ("interfaces",)
38     def __init__(self, interfaces=None):
39         if interfaces is None:
40             interfaces = {}
41         self.interfaces = interfaces
42     def __call__(self, *args, **kwargs):
43         if not self.interfaces:
44             self.interfaces = interfaces()
45         return self.interfaces
46     def clear(self):
47         self.interfaces = {}
48 _get_interfaces = Interfaces()
49 _clear_interfaces = _get_interfaces.clear
50 def sanitize_host(host):
51     RFC952_characters = ascii_letters + digits + ".-_"
52     return "".join([c for c in host[0:255] if c in RFC952_characters])
53 def isportopen(host, port):
54     if not 1 &lt;= int(port) &lt;= 65535:
55         return False
56     sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
57     out = sock.connect_ex((sanitize_host(host), int(port)))
58     return out
59 def host_to_ips(host):
60     ips = []
61     try:
62         for family, socktype, proto, canonname, sockaddr in socket.getaddrinfo(
63             host, 0, socket.AF_UNSPEC, socket.SOCK_STREAM
64         ):
65             if family == socket.AF_INET:
66                 ip, port = sockaddr
67             elif family == socket.AF_INET6:
68                 ip, port, flow_info, scope_id = sockaddr
69             ips.append(ip)
70         if not ips:
71             ips = None
72     except Exception:  # pylint: disable=broad-except
73         ips = None
74     return ips
75 def _generate_minion_id():
76     class DistinctList(list):
77         localhost_matchers = [
78             r"localhost.*",
79             r"ip6-.*",
80             r"127[.]\d",
81             r"0\.0\.0\.0",
82             r"::1.*",
83             r"ipv6-.*",
84             r"fe00::.*",
85             r"fe02::.*",
86             r"1.0.0.*.ip6.arpa",
87         ]
88         def append(self, p_object):
89             if p_object and p_object not in self and not self.filter(p_object):
90                 super().append(p_object)
91             return self
92         def extend(self, iterable):
93             for obj in iterable:
94                 self.append(obj)
95             return self
96         def filter(self, element):
97             "Returns True if element needs to be filtered"
98             for rgx in self.localhost_matchers:
99                 if re.match(rgx, element):
100                     return True
101         def first(self):
102             return self and self[0] or None
103     hostname = socket.gethostname()
104     hosts = (
105         DistinctList()
106         .append(
107             salt.utils.stringutils.to_unicode(
108                 socket.getfqdn(salt.utils.stringutils.to_bytes(hostname))
109             )
110         )
111         .append(platform.node())
112         .append(hostname)
113     )
114     if not hosts:
115         try:
116             for a_nfo in socket.getaddrinfo(
117                 hosts.first() or "localhost",
118                 None,
119                 socket.AF_INET,
120                 socket.SOCK_RAW,
121                 socket.IPPROTO_IP,
122                 socket.AI_CANONNAME,
123             ):
124                 if len(a_nfo) &gt; 3:
125                     hosts.append(a_nfo[3])
126         except socket.gaierror:
127             log.warning(
128                 "Cannot resolve address %s info via socket: %s",
129                 hosts.first() or "localhost (N/A)",
130                 socket.gaierror,
131             )
132     for f_name in (
133         "/etc/hostname",
134         "/etc/nodename",
135         "/etc/hosts",
136         r"{win}\system32\drivers\etc\hosts".format(win=os.getenv("WINDIR")),
137     ):
138         try:
139             with salt.utils.files.fopen(f_name) as f_hdl:
140                 for line in f_hdl:
141                     line = salt.utils.stringutils.to_unicode(line)
142                     hst = line.strip().split("#")[0].strip().split()
143                     if hst:
144                         if hst[0][:4] in ("127.", "::1") or len(hst) == 1:
145                             hosts.extend(hst)
146         except OSError:
147             pass
148     return hosts.extend(
149         [addr for addr in ip_addrs() if not ipaddress.ip_address(addr).is_loopback]
150     )
151 def generate_minion_id():
152     try:
153         ret = salt.utils.stringutils.to_unicode(_generate_minion_id().first())
154     except TypeError:
155         ret = None
156     return ret or "localhost"
157 def get_socket(addr, type=socket.SOCK_STREAM, proto=0):
158     version = ipaddress.ip_address(addr).version
159     if version == 4:
160         family = socket.AF_INET
161     elif version == 6:
162         family = socket.AF_INET6
163     return socket.socket(family, type, proto)
164 def get_fqhostname():
165     l = [socket.getfqdn()]
166     try:
167         addrinfo = socket.getaddrinfo(
168             socket.gethostname(),
169             0,
170             socket.AF_UNSPEC,
171             socket.SOCK_STREAM,
172             socket.SOL_TCP,
173             socket.AI_CANONNAME,
174         )
175         for info in addrinfo:
176             if len(info) &gt;= 4 and info[3]:
177                 l = [info[3]]
178     except socket.gaierror:
179         pass
180     return l and l[0] or None
181 def ip_to_host(ip):
182     try:
183         hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)
184     except Exception as exc:  # pylint: disable=broad-except
185         log.debug("salt.utils.network.ip_to_host(%r) failed: %s", ip, exc)
186         hostname = None
187     return hostname
188 def is_reachable_host(entity_name):
189     try:
190         assert type(socket.getaddrinfo(entity_name, 0, 0, 0, 0)) == list
191         ret = True
192     except socket.gaierror:
193         ret = False
194     return ret
195 def is_ip(ip_addr):
196     return is_ipv4(ip_addr) or is_ipv6(ip_addr)
197 def is_ipv4(ip_addr):
198     try:
199         return ipaddress.ip_address(ip_addr).version == 4
200     except ValueError:
201         return False
202 def is_ipv6(ip_addr):
203     try:
204         return ipaddress.ip_address(ip_addr).version == 6
205     except ValueError:
206         return False
207 def is_subnet(cidr):
208     return is_ipv4_subnet(cidr) or is_ipv6_subnet(cidr)
209 def is_ipv4_subnet(cidr):
210     try:
211         return "/" in cidr and bool(ipaddress.IPv4Network(cidr))
212     except Exception:  # pylint: disable=broad-except
213         return False
214 def is_ipv6_subnet(cidr):
215     try:
216         return "/" in cidr and bool(ipaddress.IPv6Network(cidr))
217     except Exception:  # pylint: disable=broad-except
218         return False
219 @jinja_filter("is_ip")
220 def is_ip_filter(ip_addr, options=None):
221     return is_ipv4_filter(ip_addr, options=options) or is_ipv6_filter(
222         ip_addr, options=options
223     )
224 def _ip_options_global(ip_obj, version):
225     return not ip_obj.is_private
226 def _ip_options_multicast(ip_obj, version):
227     return ip_obj.is_multicast
228 def _ip_options_loopback(ip_obj, version):
229     return ip_obj.is_loopback
230 def _ip_options_link_local(ip_obj, version):
231     return ip_obj.is_link_local
232 def _ip_options_private(ip_obj, version):
233     return ip_obj.is_private
234 def _ip_options_reserved(ip_obj, version):
235     return ip_obj.is_reserved
236 def _ip_options_site_local(ip_obj, version):
237     if version == 6:
238         return ip_obj.is_site_local
239     return False
240 def _ip_options_unspecified(ip_obj, version):
241     return ip_obj.is_unspecified
242 def _ip_options(ip_obj, version, options=None):
243     options_fun_map = {
244         "global": _ip_options_global,
245         "link-local": _ip_options_link_local,
246         "linklocal": _ip_options_link_local,
247         "ll": _ip_options_link_local,
248         "link_local": _ip_options_link_local,
249         "loopback": _ip_options_loopback,
250         "lo": _ip_options_loopback,
251         "multicast": _ip_options_multicast,
252         "private": _ip_options_private,
253         "public": _ip_options_global,
254         "reserved": _ip_options_reserved,
255         "site-local": _ip_options_site_local,
256         "sl": _ip_options_site_local,
257         "site_local": _ip_options_site_local,
258         "unspecified": _ip_options_unspecified,
259     }
260     if not options:
261         return str(ip_obj)  # IP version already checked
262     options_list = [option.strip() for option in options.split(",")]
263     for option, fun in options_fun_map.items():
264         if option in options_list:
265             fun_res = fun(ip_obj, version)
266             if not fun_res:
267                 return None
268     return str(ip_obj)
269 def _is_ipv(ip_addr, version, options=None):
270     if not version:
271         version = 4
272     if version not in (4, 6):
273         return None
274     try:
275         ip_obj = ipaddress.ip_address(ip_addr)
276     except ValueError:
277         try:
278             ip_obj = ipaddress.ip_interface(ip_addr)
279         except ValueError:
280             return None
281     if not ip_obj.version == version:
282         return None
283     return _ip_options(ip_obj, version, options=options)
284 @jinja_filter("is_ipv4")
285 def is_ipv4_filter(ip_addr, options=None):
286     _is_ipv4 = _is_ipv(ip_addr, 4, options=options)
287     return isinstance(_is_ipv4, str)
288 @jinja_filter("is_ipv6")
289 def is_ipv6_filter(ip_addr, options=None):
290     _is_ipv6 = _is_ipv(ip_addr, 6, options=options)
291     return isinstance(_is_ipv6, str)
292 def _ipv_filter(value, version, options=None):
293     if version not in (4, 6):
294         return
295     if isinstance(value, (str, bytes)):
296         return _is_ipv(
297             value, version, options=options
298         )  # calls is_ipv4 or is_ipv6 for `value`
299     elif isinstance(value, (list, tuple, types.GeneratorType)):
300         return [
301             _is_ipv(addr, version, options=options)
302             for addr in value
303             if _is_ipv(addr, version, options=options) is not None
304         ]
305     return None
306 @jinja_filter("ipv4")
307 def ipv4(value, options=None):
308     return _ipv_filter(value, 4, options=options)
309 @jinja_filter("ipv6")
310 def ipv6(value, options=None):
311     return _ipv_filter(value, 6, options=options)
312 @jinja_filter("ipaddr")
313 def ipaddr(value, options=None):
314     ipv4_obj = ipv4(value, options=options)
315     ipv6_obj = ipv6(value, options=options)
316     if ipv4_obj is None or ipv6_obj is None:
317         return ipv4_obj or ipv6_obj  # one of them
318     else:
319         return ipv4_obj + ipv6_obj  # extend lists
320 def _filter_ipaddr(value, options, version=None):
321     ipaddr_filter_out = None
322     if version:
323         if version == 4:
324             ipaddr_filter_out = ipv4(value, options)
325         elif version == 6:
326             ipaddr_filter_out = ipv6(value, options)
327     else:
328         ipaddr_filter_out = ipaddr(value, options)
329     if not ipaddr_filter_out:
330         return
331     if not isinstance(ipaddr_filter_out, (list, tuple, types.GeneratorType)):
332         ipaddr_filter_out = [ipaddr_filter_out]
333     return ipaddr_filter_out
334 @jinja_filter("ip_host")
335 def ip_host(value, options=None, version=None):
336     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
337     if not ipaddr_filter_out:
338         return
339     if not isinstance(value, (list, tuple, types.GeneratorType)):
340         return str(ipaddress.ip_interface(ipaddr_filter_out[0]))
341     return [str(ipaddress.ip_interface(ip_a)) for ip_a in ipaddr_filter_out]
342 def _network_hosts(ip_addr_entry):
343     return [
344         str(host) for host in ipaddress.ip_network(ip_addr_entry, strict=False).hosts()
345     ]
346 @jinja_filter("network_hosts")
347 def network_hosts(value, options=None, version=None):
348     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
349     if not ipaddr_filter_out:
350         return
351     if not isinstance(value, (list, tuple, types.GeneratorType)):
352         return _network_hosts(ipaddr_filter_out[0])
353     return [_network_hosts(ip_a) for ip_a in ipaddr_filter_out]
354 def _network_size(ip_addr_entry):
355     return ipaddress.ip_network(ip_addr_entry, strict=False).num_addresses
356 @jinja_filter("network_size")
357 def network_size(value, options=None, version=None):
358     ipaddr_filter_out = _filter_ipaddr(value, options=options, version=version)
359     if not ipaddr_filter_out:
360         return
361     if not isinstance(value, (list, tuple, types.GeneratorType)):
362         return _network_size(ipaddr_filter_out[0])
363     return [_network_size(ip_a) for ip_a in ipaddr_filter_out]
364 def natural_ipv4_netmask(ip_addr, fmt="prefixlen"):
365     bits = _ipv4_to_bits(ip_addr)
366     if bits.startswith("11"):
367         mask = "24"
368     elif bits.startswith("1"):
369         mask = "16"
370     else:
371         mask = "8"
372     if fmt == "netmask":
373         return cidr_to_ipv4_netmask(mask)
374     else:
375         return "/" + mask
376 def rpad_ipv4_network(ip_addr):
377     return ".".join(itertools.islice(itertools.chain(ip_addr.split("."), "0000"), 0, 4))
378 def cidr_to_ipv4_netmask(cidr_bits):
379     try:
380         cidr_bits = int(cidr_bits)
381         if not 1 &lt;= cidr_bits &lt;= 32:
382             return ""
383     except ValueError:
384         return ""
385     netmask = ""
386     for idx in range(4):
387         if idx:
388             netmask += "."
389         if cidr_bits &gt;= 8:
390             netmask += "255"
391             cidr_bits -= 8
392         else:
393             netmask += "{:d}".format(256 - (2 ** (8 - cidr_bits)))
394             cidr_bits = 0
395     return netmask
396 def _number_of_set_bits_to_ipv4_netmask(set_bits):
397     return cidr_to_ipv4_netmask(_number_of_set_bits(set_bits))
398 def _number_of_set_bits(x):
399     x -= (x &gt;&gt; 1) &amp; 0x55555555
400     x = ((x &gt;&gt; 2) &amp; 0x33333333) + (x &amp; 0x33333333)
401     x = ((x &gt;&gt; 4) + x) &amp; 0x0F0F0F0F
402     x += x &gt;&gt; 8
403     x += x &gt;&gt; 16
404     return x &amp; 0x0000003F
405 def _interfaces_ip(out):
406     ret = dict()
407     def parse_network(value, cols):
408         brd = None
409         scope = None
410         if "/" in value:  # we have a CIDR in this address
411             ip, cidr = value.split("/")
412         else:
413             ip = value
414             cidr = 32
415         if type_ == "inet":
416             mask = cidr_to_ipv4_netmask(int(cidr))
417             if "brd" in cols:
418                 brd = cols[cols.index("brd") + 1]
419         elif type_ == "inet6":
420             mask = cidr
421             if "scope" in cols:
422                 scope = cols[cols.index("scope") + 1]
423         return (ip, mask, brd, scope)
424     groups = re.compile("\r?\n\\d").split(out)
425     for group in groups:
426         iface = None
427         data = dict()
428         for line in group.splitlines():
429             if " " not in line:
430                 continue
431             match = re.match(r"^\d*:\s+([\w.\-]+)(?:@)?([\w.\-]+)?:\s+&lt;(.+)&gt;", line)
432             if match:
433                 iface, parent, attrs = match.groups()
434                 if "UP" in attrs.split(","):
435                     data["up"] = True
436                 else:
437                     data["up"] = False
438                 if parent:
439                     data["parent"] = parent
440                 continue
441             cols = line.split()
442             if len(cols) &gt;= 2:
443                 type_, value = tuple(cols[0:2])
444                 iflabel = cols[-1:][0]
445                 if type_ in ("inet", "inet6"):
446                     ipaddr, netmask, broadcast, scope = parse_network(value, cols)
447                     addr_obj = dict()
448                     if "secondary" not in cols:
449                         if type_ == "inet":
450                             if "inet" not in data:
451                                 data["inet"] = list()
452                             addr_obj["address"] = ipaddr
453                             addr_obj["netmask"] = netmask
454                             addr_obj["broadcast"] = broadcast
455                             addr_obj["label"] = iflabel
456                             data["inet"].append(addr_obj)
457                         elif type_ == "inet6":
458                             if "inet6" not in data:
459                                 data["inet6"] = list()
460                             addr_obj["address"] = ipaddr
461                             addr_obj["prefixlen"] = netmask
462                             addr_obj["scope"] = scope
463                             data["inet6"].append(addr_obj)
464                     else:
465                         if type_ == "inet":
466                             if "secondary" not in data:
467                                 data["secondary"] = list()
468                             addr_obj["type"] = type_
469                             addr_obj["address"] = ipaddr
470                             addr_obj["netmask"] = netmask
471                             addr_obj["broadcast"] = broadcast
472                             addr_obj["label"] = iflabel
473                             data["secondary"].append(addr_obj)
474                         elif type_ == "inet6":
475                             if "secondary" not in data:
476                                 data["secondary"] = list()
477                             addr_obj["type"] = type_
478                             addr_obj["address"] = ipaddr
479                             addr_obj["prefixlen"] = netmask
480                             addr_obj["scope"] = scope
481                             data["secondary"].append(addr_obj)
482                 elif type_.startswith("link"):
483                     data["hwaddr"] = value
484         if iface:
485             ret[iface] = data
486             del iface, data
487     return ret
488 def _interfaces_ifconfig(out):
489     ret = dict()
490     piface = re.compile(r"^([^\s:]+)")
491     pmac = re.compile(".*?(?:HWaddr|ether|address:|lladdr) ([0-9a-fA-F:]+)")
492     if salt.utils.platform.is_sunos():
493         pip = re.compile(r".*?(?:inet\s+)([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(.*)")
494         pip6 = re.compile(".*?(?:inet6 )([0-9a-fA-F:]+)")
495         pmask6 = re.compile(r".*?(?:inet6 [0-9a-fA-F:]+/(\d+)).*")
496     else:
497         pip = re.compile(r".*?(?:inet addr:|inet [^\d]*)(.*?)\s")
498         pip6 = re.compile(".*?(?:inet6 addr: (.*?)/|inet6 )([0-9a-fA-F:]+)")
499         pmask6 = re.compile(
500             r".*?(?:inet6 addr: [0-9a-fA-F:]+/(\d+)|prefixlen (\d+))(?:"
501             r" Scope:([a-zA-Z]+)| scopeid (0x[0-9a-fA-F]))?"
502         )
503     pmask = re.compile(r".*?(?:Mask:|netmask )(?:((?:0x)?[0-9a-fA-F]{8})|([\d\.]+))")
504     pupdown = re.compile("UP")
505     pbcast = re.compile(r".*?(?:Bcast:|broadcast )([\d\.]+)")
506     groups = re.compile("\r?\n(?=\\S)").split(out)
507     for group in groups:
508         data = dict()
509         iface = ""
510         updown = False
511         for line in group.splitlines():
512             miface = piface.match(line)
513             mmac = pmac.match(line)
514             mip = pip.match(line)
515             mip6 = pip6.match(line)
516             mupdown = pupdown.search(line)
517             if miface:
518                 iface = miface.group(1)
519             if mmac:
520                 data["hwaddr"] = mmac.group(1)
521                 if salt.utils.platform.is_sunos():
522                     expand_mac = []
523                     for chunk in data["hwaddr"].split(":"):
524                         expand_mac.append(
525                             "0{}".format(chunk)
526                             if len(chunk) &lt; 2
527                             else "{}".format(chunk)
528                         )
529                     data["hwaddr"] = ":".join(expand_mac)
530             if mip:
531                 if "inet" not in data:
532                     data["inet"] = list()
533                 addr_obj = dict()
534                 addr_obj["address"] = mip.group(1)
535                 mmask = pmask.match(line)
536                 if mmask:
537                     if mmask.group(1):
538                         mmask = _number_of_set_bits_to_ipv4_netmask(
539                             int(mmask.group(1), 16)
540                         )
541                     else:
542                         mmask = mmask.group(2)
543                     addr_obj["netmask"] = mmask
544                 mbcast = pbcast.match(line)
545                 if mbcast:
546                     addr_obj["broadcast"] = mbcast.group(1)
547                 data["inet"].append(addr_obj)
548             if mupdown:
549                 updown = True
550             if mip6:
551                 if "inet6" not in data:
552                     data["inet6"] = list()
553                 addr_obj = dict()
554                 addr_obj["address"] = mip6.group(1) or mip6.group(2)
555                 mmask6 = pmask6.match(line)
556                 if mmask6:
557                     addr_obj["prefixlen"] = mmask6.group(1) or mmask6.group(2)
558                     if not salt.utils.platform.is_sunos():
559                         ipv6scope = mmask6.group(3) or mmask6.group(4)
560                         addr_obj["scope"] = (
561                             ipv6scope.lower() if ipv6scope is not None else ipv6scope
562                         )
563                 if (
564                     not salt.utils.platform.is_sunos()
565                     or addr_obj["address"] != "::"
566                     and addr_obj["prefixlen"] != 0
567                 ):
568                     data["inet6"].append(addr_obj)
569         data["up"] = updown
570         if iface in ret:
571             ret[iface] = dict(list(data.items()) + list(ret[iface].items()))
572             if "inet" in data:
573                 ret[iface]["inet"].extend(
574                     x for x in data["inet"] if x not in ret[iface]["inet"]
575                 )
576             if "inet6" in data:
577                 ret[iface]["inet6"].extend(
578                     x for x in data["inet6"] if x not in ret[iface]["inet6"]
579                 )
580         else:
581             ret[iface] = data
582         del data
583     return ret
584 def linux_interfaces():
585     ifaces = dict()
586     ip_path = salt.utils.path.which("ip")
587     ifconfig_path = None if ip_path else salt.utils.path.which("ifconfig")
588     if ip_path:
589         cmd1 = subprocess.Popen(
590             [ip_path, "link", "show"],
591             close_fds=True,
592             stdout=subprocess.PIPE,
593             stderr=subprocess.STDOUT,
594         ).communicate()[0]
595         cmd2 = subprocess.Popen(
596             [ip_path, "addr", "show"],
597             close_fds=True,
598             stdout=subprocess.PIPE,
599             stderr=subprocess.STDOUT,
600         ).communicate()[0]
601         ifaces = _interfaces_ip(
602             "{}\n{}".format(
603                 salt.utils.stringutils.to_str(cmd1), salt.utils.stringutils.to_str(cmd2)
604             )
605         )
606     elif ifconfig_path:
607         cmd = subprocess.Popen(
608             [ifconfig_path, "-a"],
609             stderr=subprocess.STDOUT,
610         ).communicate()[0]
611         ifaces = _interfaces_ifconfig<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(salt.utils.stringutils.to_str(cmd))
612     return ifaces
613 def _netbsd_interfaces_ifconfig(out):
614     ret = dict()
615     piface = re.compile(</b></font>r"^([^\s:]+)")
616     pmac = re.compile(".*?address: ([0-9a-f:]+)")
617     pip = re.compile(r".*?inet [^\d]*(.*?)/([\d]*)\s")
618     pip6 = re.compile(r".*?inet6 ([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s")
619     pupdown = re.compile("UP")
620     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
621     groups = re.compile("\r?\n(?=\\S)").split(out)
622     for group in groups:
623         data = dict()
624         iface = ""
625         updown = False
626         for line in group.splitlines():
627             miface = piface.match(line)
628             mmac = pmac.match(line)
629             mip = pip.match(line)
630             mip6 = pip6.match(line)
631             mupdown = pupdown.search(line)
632             if miface:
633                 iface = miface.group(1)
634             if mmac:
635                 data["hwaddr"] = mmac.group(1)
636             if mip:
637                 if "inet" not in data:
638                     data["inet"] = list()
639                 addr_obj = dict()
640                 addr_obj["address"] = mip.group(1)
641                 mmask = mip.group(2)
642                 if mip.group(2):
643                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(2))
644                 mbcast = pbcast.match(line)
645                 if mbcast:
646                     addr_obj["broadcast"] = mbcast.group(1)
647                 data["inet"].append(addr_obj)
648             if mupdown:
649                 updown = True
650             if mip6:
651                 if "inet6" not in data:
652                     data["inet6"] = list()
653                 addr_obj = dict()
654                 addr_obj["address"] = mip6.group(1)
655                 mmask6 = mip6.group(3)
656                 addr_obj["scope"] = mip6.group(2)
657                 addr_obj["prefixlen"] = mip6.group(3)
658                 data["inet6"].append(addr_obj)
659         data["up"] = updown
660         ret[iface] = data
661         del data
662     return ret
663 def _junos_interfaces_ifconfig(out):
664     ret = dict()
665     piface = re.compile(r"^([^\s:]+)")
666     pmac = re.compile("curr media .*? ([0-9a-f:]+)")
667     pip = re.compile(
668         r".*?inet\s*(primary)*\s+mtu"
669         r" (\d+)\s+local=[^\d]*(.*?)\s+dest=[^\d]*(.*?)\/([\d]*)\s+bcast=((?:[0-9]{1,3}\.){3}[0-9]{1,3})"
670     )
671     pip6 = re.compile(
672         r".*?inet6 mtu [^\d]+\s+local=([0-9a-f:]+)%([a-zA-Z0-9]*)/([\d]*)\s"
673     )
674     pupdown = re.compile("UP")
675     pbcast = re.compile(r".*?broadcast ([\d\.]+)")
676     groups = re.compile("\r?\n(?=\\S)").split(out)
677     for group in groups:
678         data = dict()
679         iface = ""
680         updown = False
681         primary = False
682         for line in group.splitlines():
683             miface = piface.match(line)
684             mmac = pmac.match(line)
685             mip = pip.match(line)
686             mip6 = pip6.match(line)
687             mupdown = pupdown.search(line)
688             if miface:
689                 iface = miface.group(1)
690             if mmac:
691                 data["hwaddr"] = mmac.group(1)
692             if mip:
693                 if "primary" in data:
694                     primary = True
695                 if "inet" not in data:
696                     data["inet"] = list()
697                 if mip.group(2):
698                     data["mtu"] = int(mip.group(2))
699                 addr_obj = dict()
700                 addr_obj["address"] = mip.group(3)
701                 mmask = mip.group(5)
702                 if mip.group(5):
703                     addr_obj["netmask"] = cidr_to_ipv4_netmask(mip.group(5))
704                 mbcast = pbcast.match(line)
705                 if mbcast:
706                     addr_obj["broadcast"] = mbcast.group(1)
707                 data["inet"].append(addr_obj)
708             if mupdown:
709                 updown = True
710             if mip6:
711                 if "inet6" not in data:
712                     data["inet6"] = list()
713                 addr_obj = dict()
714                 addr_obj["address"] = mip6.group(1)
715                 mmask6 = mip6.group(3)
716                 addr_obj["scope"] = mip6.group(2)
717                 addr_obj["prefixlen"] = mip6.group(3)
718                 data["inet6"].append(addr_obj)
719         data["up"] = updown
720         ret[iface] = data
721         del data
722     return ret
723 def junos_interfaces():
724     ifconfig_path = salt.utils.path.which("ifconfig")
725     cmd = subprocess.Popen(
726         [ifconfig_path, "-a"],
727         stdout=subprocess.PIPE,
728         stderr=subprocess.STDOUT,
729     ).communicate()[0]
730     return _junos_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
731 def netbsd_interfaces():
732     if LooseVersion(os.uname()[2]) &lt; LooseVersion("8.0"):
733         return linux_interfaces()
734     ifconfig_path = salt.utils.path.which("ifconfig")
735     cmd = subprocess.Popen(
736         [ifconfig_path, "-a"],
737         stdout=subprocess.PIPE,
738         stderr=subprocess.STDOUT,
739     ).communicate()[0]
740     return _netbsd_interfaces_ifconfig(salt.utils.stringutils.to_str(cmd))
741 def _interfaces_ipconfig(out):
742     ifaces = dict()
743     iface = None
744     addr = None
745     adapter_iface_regex = re.compile(r"adapter (\S.+):$")
746     for line in out.splitlines():
747         if not line:
748             continue
749         if line.startswith("Ethernet"):
750             iface = ifaces[adapter_iface_regex.search(line).group(1)]
751             iface["up"] = True
752             addr = {}
753             continue
754         if iface:
755             key, val = line.split(",", 1)
756             key = key.strip(" .")
757             val = val.strip()
758             if addr and key == "Subnet Mask":
759                 addr["netmask"] = val
760             elif key in ("IP Address", "IPv4 Address"):
761                 if "inet" not in iface:
762                     iface["inet"] = list()
763                 addr = {
764                     "address": val.rstrip("(Preferred)"),
765                     "netmask": None,
766                     "broadcast": None,
767                 }  # TODO find the broadcast
768                 iface["inet"].append(addr)
769             elif "IPv6 Address" in key:
770                 if "inet6" not in iface:
771                     iface["inet"] = list()
772                 addr = {"address": val.rstrip("(Preferred)"), "prefixlen": None}
773                 iface["inet6"].append(addr)
774             elif key == "Physical Address":
775                 iface["hwaddr"] = val
776             elif key == "Media State":
777                 iface["up"] = val != "Media disconnected"
778 def win_interfaces():
779     if WIN_NETWORK_LOADED is False:
780         import salt.utils.win_network as _
781     return salt.utils.win_network.get_interface_info()
782 def interfaces():
783     if salt.utils.platform.is_windows():
784         return win_interfaces()
785     elif salt.utils.platform.is_junos():
786         return junos_interfaces()
787     elif salt.utils.platform.is_netbsd():
788         return netbsd_interfaces()
789     else:
790         return linux_interfaces()
791 def get_net_start(ipaddr, netmask):
792     net = ipaddress.ip_network("{}/{}".format(ipaddr, netmask), strict=False)
793     return str(net.network_address)
794 def get_net_size(mask):
795     binary_str = ""
796     for octet in mask.split("."):
797         binary_str += bin(int(octet))[2:].zfill(8)
798     return len(binary_str.rstrip("0"))
799 def calc_net(ipaddr, netmask=None):
800     if netmask is not None:
801         ipaddr = "{}/{}".format(ipaddr, netmask)
802     return str(ipaddress.ip_network(ipaddr, strict=False))
803 def _ipv4_to_bits(ipaddr):
804     return "".join([bin(int(x))[2:].rjust(8, "0") for x in ipaddr.split(".")])
805 def _get_iface_info(iface):
806     iface_info = interfaces()
807     if iface in iface_info.keys():
808         return iface_info, False
809     else:
810         error_msg = 'Interface "{}" not in available interfaces: "{}"'.format(
811             iface, '", "'.join(iface_info.keys())
812         )
813         log.error(error_msg)
814         return None, error_msg
815 def _hw_addr_aix(iface):
816     cmd = subprocess.Popen(
817         ["grep", "Hardware Address"],
818         stdin=subprocess.Popen(
819             ["entstat", "-d", iface],
820             stdout=subprocess.PIPE,
821             stderr=subprocess.STDOUT,
822         ).stdout,
823         stdout=subprocess.PIPE,
824         stderr=subprocess.STDOUT,
825     ).communicate()[0]
826     if cmd:
827         comps = cmd.split(" ")
828         if len(comps) == 3:
829             mac_addr = comps[2].strip("'").strip()
830             return mac_addr
831     error_msg = 'Interface "{}" either not available or does not contain a hardware address'.format(
832         iface
833     )
834     log.error(error_msg)
835     return error_msg
836 def hw_addr(iface):
837     if salt.utils.platform.is_aix():
838         return _hw_addr_aix
839     iface_info, error = _get_iface_info(iface)
840     if error is False:
841         return iface_info.get(iface, {}).get("hwaddr", "")
842     else:
843         return error
844 def interface(iface):
845     iface_info, error = _get_iface_info(iface)
846     if error is False:
847         return iface_info.get(iface, {}).get("inet", "")
848     else:
849         return error
850 def interface_ip(iface):
851     iface_info, error = _get_iface_info(iface)
852     if error is False:
853         inet = iface_info.get(iface, {}).get("inet", None)
854         return inet[0].get("address", "") if inet else ""
855     else:
856         return error
857 def _subnets(proto="inet", interfaces_=None):
858     if interfaces_ is None:
859         ifaces = interfaces()
860     elif isinstance(interfaces_, list):
861         ifaces = {}
862         for key, value in interfaces().items():
863             if key in interfaces_:
864                 ifaces[key] = value
865     else:
866         ifaces = {interfaces_: interfaces().get(interfaces_, {})}
867     ret = set()
868     if proto == "inet":
869         subnet = "netmask"
870         dflt_cidr = 32
871     elif proto == "inet6":
872         subnet = "prefixlen"
873         dflt_cidr = 128
874     else:
875         log.error("Invalid proto %s calling subnets()", proto)
876         return
877     for ip_info in ifaces.values():
878         addrs = ip_info.get(proto, [])
879         addrs.extend(
880             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
881         )
882         for intf in addrs:
883             if subnet in intf:
884                 intf = ipaddress.ip_interface(
885                     "{}/{}".format(intf["address"], intf[subnet])
886                 )
887             else:
888                 intf = ipaddress.ip_interface(
889                     "{}/{}".format(intf["address"], dflt_cidr)
890                 )
891             if not intf.is_loopback:
892                 ret.add(intf.network)
893     return [str(net) for net in sorted(ret)]
894 def subnets(interfaces=None):
895     return _subnets("inet", interfaces_=interfaces)
896 def subnets6():
897     return _subnets("inet6")
898 def in_subnet(cidr, addr=None):
899     try:
900         cidr = ipaddress.ip_network(cidr)
901     except ValueError:
902         log.error("Invalid CIDR '%s'", cidr)
903         return False
904     if addr is None:
905         addr = ip_addrs()
906         addr.extend(ip_addrs6())
907     elif not isinstance(addr, (list, tuple)):
908         addr = (addr,)
909     return any(ipaddress.ip_address(item) in cidr for item in addr)
910 def _get_ips(ifaces, proto="inet"):
911     ret = []
912     for ip_info in ifaces.values():
913         ret.extend(ip_info.get(proto, []))
914         ret.extend(
915             [addr for addr in ip_info.get("secondary", []) if addr.get("type") == proto]
916         )
917     return ret
918 def _filter_interfaces(interface=None, interface_data=None):
919     ifaces = interface_data if isinstance(interface_data, dict) else interfaces()
920     if interface is None:
921         ret = ifaces
922     else:
923         interface = salt.utils.args.split_input(interface)
924         ret = {
925             k: v
926             for k, v in ifaces.items()
927             if any(fnmatch.fnmatch(k, pat) for pat in interface)
928         }
929     return ret
930 def _ip_addrs(
931     interface=None, include_loopback=False, interface_data=None, proto="inet"
932 ):
933     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
934     ret = set()
935     for addr in addrs:
936         addr = ipaddress.ip_address(addr.get("address"))
937         if not addr.is_loopback or include_loopback:
938             ret.add(addr)
939     return [str(addr) for addr in sorted(ret)]
940 def ip_addrs(interface=None, include_loopback=False, interface_data=None):
941     return _ip_addrs(interface, include_loopback, interface_data, "inet")
942 def ip_addrs6(interface=None, include_loopback=False, interface_data=None):
943     return _ip_addrs(interface, include_loopback, interface_data, "inet6")
944 def _ip_networks(
945     interface=None,
946     include_loopback=False,
947     verbose=False,
948     interface_data=None,
949     proto="inet",
950 ):
951     addrs = _get_ips(_filter_interfaces(interface, interface_data), proto=proto)
952     ret = set()
953     for addr in addrs:
954         _ip = addr.get("address")
955         _net = addr.get("netmask" if proto == "inet" else "prefixlen")
956         if _ip and _net:
957             try:
958                 ip_net = ipaddress.ip_network("{}/{}".format(_ip, _net), strict=False)
959             except Exception:  # pylint: disable=broad-except
960                 continue
961             if not ip_net.is_loopback or include_loopback:
962                 ret.add(ip_net)
963     if not verbose:
964         return [str(addr) for addr in sorted(ret)]
965     verbose_ret = {
966         str(x): {
967             "address": str(x.network_address),
968             "netmask": str(x.netmask),
969             "num_addresses": x.num_addresses,
970             "prefixlen": x.prefixlen,
971         }
972         for x in ret
973     }
974     return verbose_ret
975 def ip_networks(
976     interface=None, include_loopback=False, verbose=False, interface_data=None
977 ):
978     return _ip_networks(
979         interface=interface,
980         include_loopback=include_loopback,
981         verbose=verbose,
982         interface_data=interface_data,
983         proto="inet",
984     )
985 def ip_networks6(
986     interface=None, include_loopback=False, verbose=False, interface_data=None
987 ):
988     return _ip_networks(
989         interface=interface,
990         include_loopback=include_loopback,
991         verbose=verbose,
992         interface_data=interface_data,
993         proto="inet6",
994     )
995 def hex2ip(hex_ip, invert=False):
996     if len(hex_ip) == 32:  # ipv6
997         ip_addr = []
998         for i in range(0, 32, 8):
999             ip_part = hex_ip[i : i + 8]
1000             ip_part = [ip_part[x : x + 2] for x in range(0, 8, 2)]
1001             if invert:
1002                 ip_addr.append("{0[3]}{0[2]}:{0[1]}{0[0]}".format(ip_part))
1003             else:
1004                 ip_addr.append("{0[0]}{0[1]}:{0[2]}{0[3]}".format(ip_part))
1005         try:
1006             address = ipaddress.IPv6Address(":".join(ip_addr))
1007             if address.ipv4_mapped:
1008                 return str(address.ipv4_mapped)
1009             else:
1010                 return address.compressed
1011         except ipaddress.AddressValueError as ex:
1012             log.error("hex2ip - ipv6 address error: %s", ex)
1013             return hex_ip
1014     try:
1015         hip = int(hex_ip, 16)
1016     except ValueError:
1017         return hex_ip
1018     if invert:
1019         return "{3}.{2}.{1}.{0}".format(
1020             hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1021         )
1022     return "{}.{}.{}.{}".format(
1023         hip &gt;&gt; 24 &amp; 255, hip &gt;&gt; 16 &amp; 255, hip &gt;&gt; 8 &amp; 255, hip &amp; 255
1024     )
1025 def mac2eui64(mac, prefix=None):
1026     eui64 = re.sub(r"[.:-]", "", mac).lower()
1027     eui64 = eui64[0:6] + "fffe" + eui64[6:]
1028     eui64 = hex(int(eui64[0:2], 16) | 2)[2:].zfill(2) + eui64[2:]
1029     if prefix is None:
1030         return ":".join(re.findall(r".{4}", eui64))
1031     else:
1032         try:
1033             net = ipaddress.ip_network(prefix, strict=False)
1034             euil = int("0x{}".format(eui64), 16)
1035             return "{}/{}".format(net[euil], net.prefixlen)
1036         except Exception:  # pylint: disable=broad-except
1037             return
1038 def active_tcp():
1039     ret = {}
1040     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1041         if not os.path.isfile(statf):
1042             continue
1043         with salt.utils.files.fopen(statf, "rb") as fp_:
1044             for line in fp_:
1045                 line = salt.utils.stringutils.to_unicode(line)
1046                 if line.strip().startswith("sl"):
1047                     continue
1048                 iret = _parse_tcp_line(line)
1049                 slot = next(iter(iret))
1050                 if iret[slot]["state"] == 1:  # 1 is ESTABLISHED
1051                     del iret[slot]["state"]
1052                     ret[len(ret)] = iret[slot]
1053     return ret
1054 def local_port_tcp(port):
1055     ret = _remotes_on(port, "local_port")
1056     return ret
1057 def remote_port_tcp(port):
1058     ret = _remotes_on(port, "remote_port")
1059     return ret
1060 def _remotes_on(port, which_end):
1061     port = int(port)
1062     ret = _netlink_tool_remote_on(port, which_end)
1063     if ret is not None:
1064         return ret
1065     ret = set()
1066     proc_available = False
1067     for statf in ["/proc/net/tcp", "/proc/net/tcp6"]:
1068         if not os.path.isfile(statf):
1069             continue
1070         proc_available = True
1071         with salt.utils.files.fopen(statf, "r") as fp_:
1072             for line in fp_:
1073                 line = salt.utils.stringutils.to_unicode(line)
1074                 if line.strip().startswith("sl"):
1075                     continue
1076                 iret = _parse_tcp_line(line)
1077                 slot = next(iter(iret))
1078                 if (
1079                     iret[slot][which_end] == port and iret[slot]["state"] == 1
1080                 ):  # 1 is ESTABLISHED
1081                     ret.add(iret[slot]["remote_addr"])
1082     if not proc_available:  # Fallback to use OS specific tools
1083         if salt.utils.platform.is_sunos():
1084             return _sunos_remotes_on(port, which_end)
1085         if salt.utils.platform.is_freebsd():
1086             return _freebsd_remotes_on(port, which_end)
1087         if salt.utils.platform.is_netbsd():
1088             return _netbsd_remotes_on(port, which_end)
1089         if salt.utils.platform.is_openbsd():
1090             return _openbsd_remotes_on(port, which_end)
1091         if salt.utils.platform.is_windows():
1092             return _windows_remotes_on(port, which_end)
1093         if salt.utils.platform.is_aix():
1094             return _aix_remotes_on(port, which_end)
1095         return _linux_remotes_on(port, which_end)
1096     return ret
1097 def _parse_tcp_line(line):
1098     ret = {}
1099     comps = line.strip().split()
1100     slot = comps[0].rstrip(":")
1101     ret[slot] = {}
1102     l_addr, l_port = comps[1].split(":")
1103     r_addr, r_port = comps[2].split(":")
1104     ret[slot]["local_addr"] = hex2ip(l_addr, True)
1105     ret[slot]["local_port"] = int(l_port, 16)
1106     ret[slot]["remote_addr"] = hex2ip(r_addr, True)
1107     ret[slot]["remote_port"] = int(r_port, 16)
1108     ret[slot]["state"] = int(comps[3], 16)
1109     return ret
1110 def _netlink_tool_remote_on(port, which_end):
1111     remotes = set()
1112     valid = False
1113     tcp_end = "dst" if which_end == "remote_port" else "src"
1114     try:
1115         data = subprocess.check_output(
1116             ["ss", "-ant", tcp_end, ":{}".format(port)]
1117         )  # pylint: disable=minimum-python-version
1118     except subprocess.CalledProcessError:
1119         log.error("Failed ss")
1120         raise
1121     except OSError:  # not command "No such file or directory"
1122         return None
1123     lines = salt.utils.stringutils.to_str(data).split("\n")
1124     for line in lines:
1125         if "Address:Port" in line:  # ss tools may not be valid
1126             valid = True
1127             continue
1128         elif "ESTAB" not in line:
1129             continue
1130         chunks = line.split()
1131         remote_host, remote_port = chunks[4].rsplit(":", 1)
1132         remotes.add(remote_host.strip("[]"))
1133     if valid is False:
1134         remotes = None
1135     return remotes
1136 def _sunos_remotes_on(port, which_end):
1137     remotes = set()
1138     try:
1139         data = subprocess.check_output(
1140             ["netstat", "-f", "inet", "-n"]
1141         )  # pylint: disable=minimum-python-version
1142     except subprocess.CalledProcessError:
1143         log.error("Failed netstat")
1144         raise
1145     lines = salt.utils.stringutils.to_str(data).split("\n")
1146     for line in lines:
1147         if "ESTABLISHED" not in line:
1148             continue
1149         chunks = line.split()
1150         local_host, local_port = chunks[0].rsplit(".", 1)
1151         remote_host, remote_port = chunks[1].rsplit(".", 1)
1152         if which_end == "remote_port" and int(remote_port) != port:
1153             continue
1154         if which_end == "local_port" and int(local_port) != port:
1155             continue
1156         remotes.add(remote_host)
1157     return remotes
1158 def _freebsd_remotes_on(port, which_end):
1159     port = int(port)
1160     remotes = set()
1161     try:
1162         cmd = salt.utils.args.shlex_split("sockstat -4 -c -p {}".format(port))
1163         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1164     except subprocess.CalledProcessError as ex:
1165         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1166         raise
1167     lines = salt.utils.stringutils.to_str(data).split("\n")
1168     for line in lines:
1169         chunks = line.split()
1170         if not chunks:
1171             continue
1172         if "COMMAND" in chunks[1]:
1173             continue  # ignore header
1174         if len(chunks) &lt; 2:
1175             continue
1176         local = chunks[-2]
1177         remote = chunks[-1]
1178         lhost, lport = local.split(":")
1179         rhost, rport = remote.split(":")
1180         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1181             continue
1182         if (
1183             which_end == "remote" and int(rport) != port
1184         ):  # ignore if remote port not port
1185             continue
1186         remotes.add(rhost)
1187     return remotes
1188 def _netbsd_remotes_on(port, which_end):
1189     port = int(port)
1190     remotes = set()
1191     try:
1192         cmd = salt.utils.args.shlex_split("sockstat -4 -c -n -p {}".format(port))
1193         data = subprocess.check_output(cmd)  # pylint: disable=minimum-python-version
1194     except subprocess.CalledProcessError as ex:
1195         log.error('Failed "sockstat" with returncode = %s', ex.returncode)
1196         raise
1197     lines = salt.utils.stringutils.to_str(data).split("\n")
1198     for line in lines:
1199         chunks = line.split()
1200         if not chunks:
1201             continue
1202         if "COMMAND" in chunks[1]:
1203             continue  # ignore header
1204         if len(chunks) &lt; 2:
1205             continue
1206         local = chunks[5].split(".")
1207         lport = local.pop()
1208         lhost = ".".join(local)
1209         remote = chunks[6].split(".")
1210         rport = remote.pop()
1211         rhost = ".".join(remote)
1212         if which_end == "local" and int(lport) != port:  # ignore if local port not port
1213             continue
1214         if (
1215             which_end == "remote" and int(rport) != port
1216         ):  # ignore if remote port not port
1217             continue
1218         remotes.add(rhost)
1219     return remotes
1220 def _openbsd_remotes_on(port, which_end):
1221     remotes = set()
1222     try:
1223         data = subprocess.check_output(
1224             ["netstat", "-nf", "inet"]
1225         )  # pylint: disable=minimum-python-version
1226     except subprocess.CalledProcessError:
1227         log.error("Failed netstat")
1228         raise
1229     lines = data.split("\n")
1230     for line in lines:
1231         if "ESTABLISHED" not in line:
1232             continue
1233         chunks = line.split()
1234         local_host, local_port = chunks[3].rsplit(".", 1)
1235         remote_host, remote_port = chunks[4].rsplit(".", 1)
1236         if which_end == "remote_port" and int(remote_port) != port:
1237             continue
1238         if which_end == "local_port" and int(local_port) != port:
1239             continue
1240         remotes.add(remote_host)
1241     return remotes
1242 def _windows_remotes_on(port, which_end):
1243     r"""
1244     Windows specific helper function.
1245     Returns set of ipv4 host addresses of remote established connections
1246     on local or remote tcp port.
1247     Parses output of shell 'netstat' to get connections
1248     C:\&gt;netstat -n
1249     Active Connections
1250        Proto  Local Address          Foreign Address        State
1251        TCP    10.2.33.17:3007        130.164.12.233:10123   ESTABLISHED
1252        TCP    10.2.33.17:3389        130.164.30.5:10378     ESTABLISHED
1253     Linux specific helper function.
1254     Returns set of ip host addresses of remote established connections
1255     on local tcp port port.
1256     Parses output of shell 'lsof'
1257     to get connections
1258     $ sudo lsof -iTCP:4505 -n
1259     COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
1260     Python   9971 root   35u  IPv4 0x18a8464a29ca329d      0t0  TCP *:4505 (LISTEN)
1261     Python   9971 root   37u  IPv4 0x18a8464a29b2b29d      0t0  TCP 127.0.0.1:4505-&gt;127.0.0.1:55703 (ESTABLISHED)
1262     Python  10152 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP 127.0.0.1:55703-&gt;127.0.0.1:4505 (ESTABLISHED)
1263     Python  10153 root   22u  IPv4 0x18a8464a29c8cab5      0t0  TCP [fe80::249a]:4505-&gt;[fe80::150]:59367 (ESTABLISHED)
1264     """
1265     remotes = set()
1266     try:
1267         data = subprocess.check_output(
1268             [
1269                 "lsof",
1270                 "-iTCP:{:d}".format(port),
1271                 "-n",
1272                 "-P",
1273             ]  # pylint: disable=minimum-python-version
1274         )
1275     except subprocess.CalledProcessError as ex:
1276         if ex.returncode == 1:
1277             log.warning('"lsof" returncode = 1, likely no active TCP sessions.')
1278             return remotes
1279         log.error('Failed "lsof" with returncode = %s', ex.returncode)
1280         raise
1281     lines = salt.utils.stringutils.to_str(data).split("\n")
1282     for line in lines:
1283         chunks = line.split()
1284         if not chunks:
1285             continue
1286         if "COMMAND" in chunks[0]:
1287             continue  # ignore header
1288         if "ESTABLISHED" not in chunks[-1]:
1289             continue  # ignore if not ESTABLISHED
1290         local, remote = chunks[8].split("-&gt;")
1291         _, lport = local.rsplit(":", 1)
1292         rhost, rport = remote.rsplit(":", 1)
1293         if which_end == "remote_port" and int(rport) != port:
1294             continue
1295         if which_end == "local_port" and int(lport) != port:
1296             continue
1297         remotes.add(rhost.strip("[]"))
1298     return remotes
1299 def _aix_remotes_on(port, which_end):
1300     remotes = set()
1301     try:
1302         data = subprocess.check_output(
1303             ["netstat", "-f", "inet", "-n"]
1304         )  # pylint: disable=minimum-python-version
1305     except subprocess.CalledProcessError:
1306         log.error("Failed netstat")
1307         raise
1308     lines = salt.utils.stringutils.to_str(data).split("\n")
1309     for line in lines:
1310         if "ESTABLISHED" not in line:
1311             continue
1312         chunks = line.split()
1313         local_host, local_port = chunks[3].rsplit(".", 1)
1314         remote_host, remote_port = chunks[4].rsplit(".", 1)
1315         if which_end == "remote_port" and int(remote_port) != port:
1316             continue
1317         if which_end == "local_port" and int(local_port) != port:
1318             continue
1319         remotes.add(remote_host)
1320     return remotes
1321 @jinja_filter("gen_mac")
1322 def gen_mac(prefix="AC:DE:48"):
1323     return "{}:{:02X}:{:02X}:{:02X}".format(
1324         prefix,
1325         random.randint(0, 0xFF),
1326         random.randint(0, 0xFF),
1327         random.randint(0, 0xFF),
1328     )
1329 @jinja_filter("mac_str_to_bytes")
1330 def mac_str_to_bytes(mac_str):
1331     if len(mac_str) == 12:
1332         pass
1333     elif len(mac_str) == 17:
1334         sep = mac_str[2]
1335         mac_str = mac_str.replace(sep, "")
1336     else:
1337         raise ValueError("Invalid MAC address")
1338     chars = (int(mac_str[s : s + 2], 16) for s in range(0, 12, 2))
1339     return bytes(chars)
1340 def refresh_dns():
1341     try:
1342         RES_INIT()
1343     except NameError:
1344         pass
1345 @jinja_filter("dns_check")
1346 def dns_check(addr, port, safe=False, ipv6=None):
1347     ip_addrs = []
1348     family = (
1349         socket.AF_INET6
1350         if ipv6
1351         else socket.AF_INET
1352         if ipv6 is False
1353         else socket.AF_UNSPEC
1354     )
1355     socket_error = False
1356     try:
1357         refresh_dns()
1358         addrinfo = socket.getaddrinfo(addr, port, family, socket.SOCK_STREAM)
1359         ip_addrs = _test_addrs(addrinfo, port)
1360     except TypeError:
1361         raise SaltSystemExit(
1362             code=42,
1363             msg=(
1364                 "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1365                 " address".format(addr)
1366             ),
1367         )
1368     except OSError:
1369         socket_error = True
1370     if socket_error and ipv6:
1371         try:
1372             refresh_dns()
1373             addrinfo = socket.getaddrinfo(
1374                 addr, port, socket.AF_INET, socket.SOCK_STREAM
1375             )
1376             ip_addrs = _test_addrs(addrinfo, port)
1377         except TypeError:
1378             raise SaltSystemExit(
1379                 code=42,
1380                 msg=(
1381                     "Attempt to resolve address '{}' failed. Invalid or unresolveable"
1382                     " address".format(addr)
1383                 ),
1384             )
1385         except OSError:
1386             error = True
1387     if not ip_addrs:
1388         err = "DNS lookup or connection check of '{}' failed.".format(addr)
1389         if safe:
1390             if salt.log.is_console_configured():
1391                 log.error(err)
1392             raise SaltClientError()
1393         raise SaltSystemExit(code=42, msg=err)
1394     return salt.utils.zeromq.ip_bracket(ip_addrs[0])
1395 def _test_addrs(addrinfo, port):
1396     ip_addrs = []
1397     for a in addrinfo:
1398         ip_family = a[0]
1399         ip_addr = a[4][0]
1400         if ip_addr in ip_addrs:
1401             continue
1402         ip_addrs.append(ip_addr)
1403         try:
1404             s = socket.socket(ip_family, socket.SOCK_STREAM)
1405             s.settimeout(2)
1406             s.connect((ip_addr, port))
1407             s.close()
1408             ip_addrs = [ip_addr]
1409             break
1410         except OSError:
1411             pass
1412     return ip_addrs
1413 def parse_host_port(host_port):
1414     host, port = None, None  # default
1415     _s_ = host_port[:]
1416     if _s_[0] == "[":
1417         if "]" in host_port:
1418             host, _s_ = _s_.lstrip("[").rsplit("]", 1)
1419             host = ipaddress.IPv6Address(host).compressed
1420             if _s_[0] == ":":
1421                 port = int(_s_.lstrip(":"))
1422             else:
1423                 if len(_s_) &gt; 1:
1424                     raise ValueError(
1425                         'found ambiguous "{}" port in "{}"'.format(_s_, host_port)
1426                     )
1427     else:
1428         if _s_.count(":") == 1:
1429             host, _hostport_separator_, port = _s_.partition(":")
1430             try:
1431                 port = int(port)
1432             except ValueError as _e_:
1433                 errmsg = 'host_port "{}" port value "{}" is not an integer.'.format(
1434                     host_port, port
1435                 )
1436                 log.error(errmsg)
1437                 raise ValueError(errmsg)
1438         else:
1439             host = _s_
1440     try:
1441         if not isinstance(host, ipaddress._BaseAddress):
1442             host_ip = ipaddress.ip_address(host).compressed
1443             host = host_ip
1444     except ValueError:
1445         log.debug('"%s" Not an IP address? Assuming it is a hostname.', host)
1446         if host != sanitize_host(host):
1447             log.error('bad hostname: "%s"', host)
1448             raise ValueError('bad hostname: "{}"'.format(host))
1449     return host, port
1450 @jinja_filter("filter_by_networks")
1451 def filter_by_networks(values, networks):
1452     _filter = lambda ips, networks: [
1453         ip for ip in ips for net in networks if ipaddress.ip_address(ip) in net
1454     ]
1455     if networks is not None:
1456         networks = [ipaddress.ip_network(network) for network in networks]
1457         if isinstance(values, Mapping):
1458             return {
1459                 interface: _filter(values[interface], networks) for interface in values
1460             }
1461         elif isinstance(values, Sequence):
1462             return _filter(values, networks)
1463         else:
1464             raise ValueError("Do not know how to filter a {}".format(type(values)))
1465     else:
1466         return values
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
