<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for nxos_api_2.py & splunk_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for nxos_api_2.py & splunk_1.py
      </h3>
      <h1 align="center">
        10.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>nxos_api_2.py (18.181818%)<TH>splunk_1.py (6.965174%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match20638-0.html#0',2,'match20638-1.html#0',3)" NAME="0">(102-150)<TD><A HREF="javascript:ZweiFrames('match20638-0.html#0',2,'match20638-1.html#0',3)" NAME="0">(23-53)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nxos_api_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Proxy Minion to manage Cisco Nexus Switches (NX-OS) over the NX-API

.. versionadded:: 2019.2.0

Proxy module for managing Cisco Nexus switches via the NX-API.

:codeauthor: Mircea Ulinic &lt;ping@mirceaulinic.net&gt;
:maturity:   new
:platform:   any

Usage
=====

.. note::

    To be able to use this module you need to enable to NX-API on your switch,
    by executing ``feature nxapi`` in configuration mode.

    Configuration example:

    .. code-block:: bash

        switch# conf t
        switch(config)# feature nxapi

    To check that NX-API is properly enabled, execute ``show nxapi``.

    Output example:

    .. code-block:: bash

        switch# show nxapi
        nxapi enabled
        HTTPS Listen on port 443

.. note::

    NX-API requires modern NXOS distributions, typically at least 7.0 depending
    on the hardware. Due to reliability reasons it is recommended to run the
    most recent version.

    Check https://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus7000/sw/programmability/guide/b_Cisco_Nexus_7000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_7000_Series_NX-OS_Programmability_Guide_chapter_0101.html
    for more details.

Pillar
------

The ``nxos_api`` proxy configuration requires the following parameters in order
to connect to the network switch:

transport: ``https``
    Specifies the type of connection transport to use. Valid values for the
    connection are ``http``, and  ``https``.

host: ``localhost``
    The IP address or DNS host name of the connection device.

username: ``admin``
    The username to pass to the device to authenticate the NX-API connection.

password
    The password to pass to the device to authenticate the NX-API connection.

port
    The TCP port of the endpoint for the NX-API connection. If this keyword is
    not specified, the default value is automatically determined by the
    transport type (``80`` for ``http``, or ``443`` for ``https``).

timeout: ``60``
    Time in seconds to wait for the device to respond. Default: 60 seconds.

verify: ``True``
    Either a boolean, in which case it controls whether we verify the NX-API
    TLS certificate, or a string, in which case it must be a path to a CA bundle
    to use. Defaults to ``True``.

    When there is no certificate configuration on the device and this option is
    set as ``True`` (default), the commands will fail with the following error:
    ``SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:581)``.
    In this case, you either need to configure a proper certificate on the
    device (*recommended*), or bypass the checks setting this argument as ``False``
    with all the security risks considered.

    Check https://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus3000/sw/programmability/6_x/b_Cisco_Nexus_3000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_3000_Series_NX-OS_Programmability_Guide_chapter_01.html
    to see how to properly configure the certificate.

All the arguments may be optional, depending on your setup.

Proxy Pillar Example
--------------------

.. code-block:: yaml

    proxy:
      proxytype: nxos_api
      host: switch1.example.com
      username: example
<A NAME="0"></A>      password: example
&quot;&quot;&quot;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match20638-1.html#0',3,'match20638-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import copy
import logging

# Import Salt modules
from salt.exceptions import SaltException

# -----------------------------------------------------------------------------
# proxy properties
# -----------------------------------------------------------------------------

__proxyenabled__ = [&quot;nxos_api&quot;]
# proxy name

# -----------------------------------------------------------------------------
# globals
# -----------------------------------------------------------------------------

__virtualname__ = &quot;nxos_api&quot;
log = logging.getLogger(__name__)
nxos_device = {}

# -----------------------------------------------------------------------------
# property functions
# -----------------------------------------------------------------------------


def __virtual__():
    &quot;&quot;&quot;
    This Proxy Module is widely available as there are no external dependencies.
    &quot;&quot;&quot;
    return __virtualname__


# -----------------------------------------------------------------------------
# proxy functions
# -----------------------------------------------------------------------------


def init(opts):
    &quot;&quot;&quot;
    Open the connection to the Nexsu switch over the NX-API.

    As the communication is HTTP based, there is no connection to maintain,
    however, in order to test the connectivity and make sure we are able to
    bring up this Minion, we are executing a very simple command (``show clock``)
    which doesn't come with much overhead and it's sufficient to confirm we are
    indeed able to connect to the NX-API endpoint as configured.
    &quot;&quot;&quot;
    proxy_dict =</B></FONT> opts.get(&quot;proxy&quot;, {})
    conn_args = copy.deepcopy(proxy_dict)
    conn_args.pop(&quot;proxytype&quot;, None)
    opts[&quot;multiprocessing&quot;] = conn_args.pop(&quot;multiprocessing&quot;, True)
    # This is not a SSH-based proxy, so it should be safe to enable
    # multiprocessing.
    try:
        rpc_reply = __utils__[&quot;nxos_api.rpc&quot;](&quot;show clock&quot;, **conn_args)
        # Execute a very simple command to confirm we are able to connect properly
        nxos_device[&quot;conn_args&quot;] = conn_args
        nxos_device[&quot;initialized&quot;] = True
        nxos_device[&quot;up&quot;] = True
    except SaltException:
        log.error(&quot;Unable to connect to %s&quot;, conn_args[&quot;host&quot;], exc_info=True)
        raise
    return True


def ping():
    &quot;&quot;&quot;
    Connection open successfully?
    &quot;&quot;&quot;
    return nxos_device.get(&quot;up&quot;, False)


def initialized():
    &quot;&quot;&quot;
    Connection finished initializing?
    &quot;&quot;&quot;
    return nxos_device.get(&quot;initialized&quot;, False)


def shutdown(opts):
    &quot;&quot;&quot;
    Closes connection with the device.
    &quot;&quot;&quot;
    log.debug(&quot;Shutting down the nxos_api Proxy Minion %s&quot;, opts[&quot;id&quot;])


# -----------------------------------------------------------------------------
# callable functions
# -----------------------------------------------------------------------------


def get_conn_args():
    &quot;&quot;&quot;
    Returns the connection arguments of the Proxy Minion.
    &quot;&quot;&quot;
    conn_args = copy.deepcopy(nxos_device[&quot;conn_args&quot;])
    return conn_args


def rpc(commands, method=&quot;cli&quot;, **kwargs):
    &quot;&quot;&quot;
    Executes an RPC request over the NX-API.
    &quot;&quot;&quot;
    conn_args = nxos_device[&quot;conn_args&quot;]
    conn_args.update(kwargs)
    return __utils__[&quot;nxos_api.rpc&quot;](commands, method=method, **conn_args)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>splunk_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;

Send json response data to Splunk via the HTTP Event Collector
Requires the following config values to be specified in config or pillar:

.. code-block:: yaml

    splunk_http_forwarder:
      token: &lt;splunk_http_forwarder_token&gt;
      indexer: &lt;hostname/IP of Splunk indexer&gt;
      sourcetype: &lt;Destination sourcetype for data&gt;
      index: &lt;Destination index for data&gt;
      verify_ssl: true

Run a test by using ``salt-call test.ping --return splunk``

Written by Scott Pack (github.com/scottjpack)

&quot;&quot;&quot;
<A NAME="0"></A>
import logging
import socket
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match20638-0.html#0',2,'match20638-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import time

import requests
import salt.utils.json

_max_content_bytes = 100000
http_event_collector_debug = False

log = logging.getLogger(__name__)

__virtualname__ = &quot;splunk&quot;


def __virtual__():
    &quot;&quot;&quot;
    Return virtual name of the module.
    :return: The virtual name of the module.
    &quot;&quot;&quot;
    return __virtualname__


def returner(ret):
    &quot;&quot;&quot;
    Send a message to Splunk via the HTTP Event Collector.
    Requires the Splunk HTTP Event Collector running on port 8088.
    This is available on Splunk Enterprise version 6.3 or higher.

    &quot;&quot;&quot;

    # Get Splunk Options
    opts =</B></FONT> _get_options()
    log.info(
        &quot;Options: %s&quot;,
        salt.utils.json.dumps(opts),
    )

    http_collector = _create_http_event_collector(opts)
    payload = _prepare_splunk_payload(ret, opts)
    http_collector.sendEvent(payload)
    return True


def event_return(events):
    &quot;&quot;&quot;
    Return events to Splunk via the HTTP Event Collector.
    Requires the Splunk HTTP Event Collector running on port 8088.
    This is available on Splunk Enterprise version 6.3 or higher.
    &quot;&quot;&quot;

    # Get Splunk Options
    opts = _get_options()
    log.info(
        &quot;Options: %s&quot;,
        salt.utils.json.dumps(opts),
    )

    http_collector = _create_http_event_collector(opts)

    for event in events:
        payload = _prepare_splunk_payload(event, opts)
        http_collector.sendEvent(payload)
    return True


def _get_options():
    try:
        token = __salt__[&quot;config.get&quot;](&quot;splunk_http_forwarder:token&quot;)
        indexer = __salt__[&quot;config.get&quot;](&quot;splunk_http_forwarder:indexer&quot;)
        sourcetype = __salt__[&quot;config.get&quot;](&quot;splunk_http_forwarder:sourcetype&quot;)
        index = __salt__[&quot;config.get&quot;](&quot;splunk_http_forwarder:index&quot;)
        verify_ssl = __salt__[&quot;config.get&quot;](
            &quot;splunk_http_forwarder:verify_ssl&quot;, default=True
        )
    except Exception:  # pylint: disable=broad-except
        log.error(&quot;Splunk HTTP Forwarder parameters not present in config.&quot;)
        return None
    splunk_opts = {
        &quot;token&quot;: token,
        &quot;indexer&quot;: indexer,
        &quot;sourcetype&quot;: sourcetype,
        &quot;index&quot;: index,
        &quot;verify_ssl&quot;: verify_ssl,
    }
    return splunk_opts


def _create_http_event_collector(opts):
    &quot;&quot;&quot;
    Prepare a connection to the Splunk HTTP event collector.

    &quot;&quot;&quot;

    http_event_collector_key = opts[&quot;token&quot;]
    http_event_collector_host = opts[&quot;indexer&quot;]
    http_event_collector_verify_ssl = opts[&quot;verify_ssl&quot;]
    # Return the collector
    return http_event_collector(
        http_event_collector_key,
        http_event_collector_host,
        verify_ssl=http_event_collector_verify_ssl,
    )


def _prepare_splunk_payload(event, opts):
    &quot;&quot;&quot;
    Prepare a payload for submission to the Splunk HTTP event collector.

    &quot;&quot;&quot;
    # Get Splunk Options
    opts = _get_options()
    # init the payload
    payload = {}

    # Set up the event metadata
    payload.update({&quot;index&quot;: opts[&quot;index&quot;]})
    payload.update({&quot;sourcetype&quot;: opts[&quot;sourcetype&quot;]})

    # Add the event
    payload.update({&quot;event&quot;: event})
    log.info(
        &quot;Payload: %s&quot;,
        salt.utils.json.dumps(payload),
    )
    return payload


# Thanks to George Starcher for the http_event_collector class (https://github.com/georgestarcher/)
class http_event_collector:
    def __init__(
        self,
        token,
        http_event_server,
        host=&quot;&quot;,
        http_event_port=&quot;8088&quot;,
        http_event_server_ssl=True,
        max_bytes=_max_content_bytes,
        verify_ssl=True,
    ):
        self.token = token
        self.batchEvents = []
        self.maxByteLength = max_bytes
        self.currentByteLength = 0
        self.verify_ssl = verify_ssl

        # Set host to specified value or default to localhostname if no value provided
        if host:
            self.host = host
        else:
            self.host = socket.gethostname()

        # Build and set server_uri for http event collector
        # Defaults to SSL if flag not passed
        # Defaults to port 8088 if port not passed

        if http_event_server_ssl:
            buildURI = [&quot;https://&quot;]
        else:
            buildURI = [&quot;http://&quot;]
        for i in [http_event_server, &quot;:&quot;, http_event_port, &quot;/services/collector/event&quot;]:
            buildURI.append(i)
        self.server_uri = &quot;&quot;.join(buildURI)

        if http_event_collector_debug:
            log.debug(self.token)
            log.debug(self.server_uri)

    def sendEvent(self, payload, eventtime=&quot;&quot;):
        # Method to immediately send an event to the http event collector

        headers = {&quot;Authorization&quot;: &quot;Splunk &quot; + self.token}

        # If eventtime in epoch not passed as optional argument use current system time in epoch
        if not eventtime:
            eventtime = str(int(time.time()))

        # Fill in local hostname if not manually populated
        if &quot;host&quot; not in payload:
            payload.update({&quot;host&quot;: self.host})

        # Update time value on payload if need to use system time
        data = {&quot;time&quot;: eventtime}
        data.update(payload)

        # send event to http event collector
        r = requests.post(
            self.server_uri,
            data=salt.utils.json.dumps(data),
            headers=headers,
            verify=self.verify_ssl,
        )

        # Print debug info if flag set
        if http_event_collector_debug:
            log.debug(r.text)
            log.debug(data)
</PRE>
</div>
  </div>
</body>
</html>
