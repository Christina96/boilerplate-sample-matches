
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</h3>
            <pre><code>1  from genericpath import exists
2  import re
3  import json
4  import urllib
5  from typing import MutableMapping
6  from sphinx.util import logging
7  from docutils import nodes
8  SCHEMA_PATH = "../esphome-vscode/server/src/schema/"
9  CONFIGURATION_VARIABLES = "Configuration variables:"
10  CONFIGURATION_OPTIONS = "Configuration options:"
11  PIN_CONFIGURATION_VARIABLES = "Pin configuration variables:"
12  COMPONENT_HUB = "Component/Hub"
13  JSON_DUMP_PRETTY = True
14  class Statistics:
15      props_documented = 0
16      enums_good = 0
17      enums_bad = 0
18  statistics = Statistics()
19  logger = logging.getLogger(__name__)
20  def setup(app):
21      import os
22      if not os.path.isfile(SCHEMA_PATH + "esphome.json"):
23          logger.info(f"{SCHEMA_PATH} not found. Not documenting schema.")
24          return
25      app.connect("doctree-resolved", doctree_resolved)
26      app.connect("build-finished", build_finished)
27      app.files = {}
28      return {"version": "1.0.0", "parallel_read_safe": True, "parallel_write_safe": True}
29  def find_platform_component(app, platform, component):
30      file_data = get_component_file(app, component)
31      return file_data[f"{component}.{platform}"]["schemas"]["CONFIG_SCHEMA"]
32  def doctree_resolved(app, doctree, docname):
33      if docname == "components/index":
34          return
35      handle_component(app, doctree, docname)
36  PLATFORMS_TITLES = {
37      "Sensor": "sensor",
38      "Binary Sensor": "binary_sensor",
39      "Text Sensor": "text_sensor",
40      "Output": "output",
41      "Cover": "cover",
42      "Button": "button",
43      "Select": "select",
44      "Fan": "fan",
45      "Lock": "lock",
46      "Number": "number",
47      "Climate": "climate",
48      "CAN Bus": "canbus",
49      "Stepper": "stepper",
50      "Switch": "switch",
51      "I²C": "i2c",
52      "Media Player": "media_player",
53      "Microphone": "microphone",
54      "Speaker": "speaker",
55      "Alarm Control Panel": "alarm_control_panel",
56  }
57  CUSTOM_DOCS = {
58      "guides/automations": {
59          "Global Variables": "globals.schemas.CONFIG_SCHEMA",
60      },
61      "guides/configuration-types": {
62          "Pin Schema": [
63              "esp32.pin.schema",
64              "esp8266.pin.schema",
65          ],
66      },
67      "components/binary_sensor/index": {
68          "Binary Sensor Filters": "binary_sensor.registry.filter",
69      },
70      "components/canbus": {
71          "_LoadSchema": False,
72          "Base CAN Bus Configuration": "canbus.schemas.CANBUS_SCHEMA",
73      },
74      "components/climate/climate_ir": {"_LoadSchema": False, "IR Remote Climate": []},
75      "components/display/index": {
76          "Images": "image.schemas.CONFIG_SCHEMA",
77          "Fonts": "font.schemas.CONFIG_SCHEMA",
78          "Color": "color.schemas.CONFIG_SCHEMA",
79          "Animation": "animation.schemas.CONFIG_SCHEMA",
80      },
81      "components/light/index": {
82          "Base Light Configuration": [
83              "light.schemas.ADDRESSABLE_LIGHT_SCHEMA",
84              "light.schemas.BINARY_LIGHT_SCHEMA",
85              "light.schemas.BRIGHTNESS_ONLY_LIGHT_SCHEMA",
86              "light.schemas.LIGHT_SCHEMA",
87          ],
88          "Light Effects": "light.registry.effects",
89      },
90      "components/light/fastled": {
91          "_LoadSchema": False,
92          "Clockless": "fastled_clockless.platform.light.schemas.CONFIG_SCHEMA",
93          "SPI": "fastled_spi.platform.light.schemas.CONFIG_SCHEMA",
94      },
95      "components/binary_sensor/ttp229": {
96          "_LoadSchema": False,
97      },
98      "components/mcp230xx": {
99          "_LoadSchema": False,
100          PIN_CONFIGURATION_VARIABLES: "mcp23xxx.pin",
101      },
102      "components/mqtt": {
103          "MQTT Component Base Configuration": "core.schemas.MQTT_COMMAND_COMPONENT_SCHEMA",
104          "MQTTMessage": "mqtt.schemas.MQTT_MESSAGE_BASE",
105      },
106      "components/output/index": {
107          "Base Output Configuration": "output.schemas.FLOAT_OUTPUT_SCHEMA",
108      },
109      "components/remote_transmitter": {
110          "Remote Transmitter Actions": "remote_base.schemas.BASE_REMOTE_TRANSMITTER_SCHEMA",
111      },
112      "components/sensor/index": {
113          "Sensor Filters": "sensor.registry.filter",
114      },
115      "components/time": {
116          "_LoadSchema": False,
117          "Base Time Configuration": "time.schemas.TIME_SCHEMA",
118          "on_time Trigger": "time.schemas.TIME_SCHEMA.schema.config_vars.on_time.schema",
119          "Home Assistant Time Source": "homeassistant.platform.time.schemas.CONFIG_SCHEMA",
120          "SNTP Time Source": "sntp.platform.time.schemas.CONFIG_SCHEMA",
121          "GPS Time Source": "gps.platform.time.schemas.CONFIG_SCHEMA",
122          "DS1307 Time Source": "ds1307.platform.time.schemas.CONFIG_SCHEMA",
123      },
124      "components/wifi": {
125          "Connecting to Multiple Networks": "wifi.schemas.CONFIG_SCHEMA.schema.config_vars.networks.schema",
126          "Enterprise Authentication": "wifi.schemas.EAP_AUTH_SCHEMA",
127      },
128      "custom/custom_component": {
129          "Generic Custom Component": "custom_component.schemas.CONFIG_SCHEMA"
130      },
131      "components/esp32": {
132          "Arduino framework": "esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.arduino",
133          "ESP-IDF framework": "esp32.schemas.CONFIG_SCHEMA.schema.config_vars.framework.types.esp-idf",
134      },
135      "components/sensor/airthings_ble": {
136          "_LoadSchema": False,
137      },
138      "components/sensor/radon_eye_ble": {
139          "_LoadSchema": False,
140      },
141      "components/sensor/xiaomi_ble": {
142          "_LoadSchema": False,
143      },
144      "components/sensor/xiaomi_miscale2": {
145          "_LoadSchema": False,
146      },
147      "components/mcp23Sxx": {
148          "_LoadSchema": False,
149      },
150      "components/display/lcd_display": {"_LoadSchema": False},
151      "components/display/ssd1306": {"_LoadSchema": False},
152      "components/display/ssd1322": {"_LoadSchema": False},
153      "components/display/ssd1325": {"_LoadSchema": False},
154      "components/display/ssd1327": {"_LoadSchema": False},
155      "components/display/ssd1351": {"_LoadSchema": False},
156      "components/copy": {"_LoadSchema": False},
157      "components/display_menu/index": {
158          "Display Menu": "display_menu_base.schemas.DISPLAY_MENU_BASE_SCHEMA",
159          "Select": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.select",
160          "Menu": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.menu",
161          "Number": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.number",
162          "Switch": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.switch",
163          "Custom": "display_menu_base.schemas.MENU_TYPES.schema.config_vars.items.types.custom",
164      },
165      "components/display_menu/lcd_menu": {
166          "LCD Menu": "lcd_menu.schemas.CONFIG_SCHEMA",
167      },
168      "components/alarm_control_panel/index": {
169          "Base Alarm Control Panel Configuration": "template.alarm_control_panel.schemas.CONFIG_SCHEMA",
170      },
171  }
172  REQUIRED_OPTIONAL_TYPE_REGEX = r"(\(((\*\*Required\*\*)|(\*Optional\*))(,\s(.*))*)\):\s"
173  def get_node_title(node):
174      return list(node.traverse(nodes.title))[0].astext()
175  def read_file(fileName):
176      f = open(SCHEMA_PATH + fileName + ".json", "r", encoding="utf-8-sig")
177      str = f.read()
178      return json.loads(str)
179  def is_config_vars_title(title_text):
180      return title_text == CONFIGURATION_VARIABLES or title_text == CONFIGURATION_OPTIONS
181  class SchemaGeneratorVisitor(nodes.NodeVisitor):
182      def __init__(self, app, doctree, docname):
183          nodes.NodeVisitor.__init__(self, doctree)
184          self.app = app
185          self.doctree = doctree
186          self.docname = docname
187          self.path = docname.split("/")
188          self.json_component = None
189          self.props = None
190          self.platform = None
191          self.json_platform_component = None
192          self.title_id = None
193          self.props_section_title = None
194          self.find_registry = None
195          self.component = None
196          self.section_level = 0
197          self.file_schema = None
198          self.custom_doc = CUSTOM_DOCS.get(docname)
199          if self.path[0] == "components":
200              if len(self.path) == 2:  # root component, e.g. dfplayer, logger
201                  self.component = docname[11:]
202                  if not self.custom_doc or self.custom_doc.get("_LoadSchema", True):
203                      self.file_schema = get_component_file(app, self.component)
204                      self.json_component = self.file_schema[self.component]["schemas"][
205                          "CONFIG_SCHEMA"
206                      ]
207              elif self.path[1] == "display_menu":  # weird folder naming
208                  if self.path[2] == "index":
209                      self.component = "display_menu_base"
210                  else:
211                      self.component = self.path[2]
212                      self.file_schema = get_component_file(app, self.component)
213                      self.json_component = self.file_schema[self.component]["schemas"][
214                          "CONFIG_SCHEMA"
215                      ]
216              else:  # sub component, e.g. output/esp8266_pwm
217                  self.platform = self.path[1]
218                  self.component = self.path[2]
219                  if self.component == "ssd1331":
220                      self.component = "ssd1331_spi"
221                  if not self.custom_doc or self.custom_doc.get("_LoadSchema", True):
222                      if self.component == "index":
223                          self.component = self.platform.replace(" ", "_").lower()
224                          self.file_schema = get_component_file(app, self.component)
225                          self.json_component = self.file_schema[self.component][
226                              "schemas"
227                          ].get(self.component.upper() + "_SCHEMA")
228                          pass
229                      else:
230                          self.json_component = get_component_file(app, self.component)
231                          self.json_platform_component = find_platform_component(
232                              app, self.platform, self.component
233                          )
234          self.previous_title_text = "No title"
235          self.is_component_hub = False
236          self.multi_component = None
237          self.prop_stack = []
238          self.current_prop = None
239          self.filled_props = False
240          self.accept_props = False
241          self.bullet_list_level = 0
242      def set_component_description(self, description, componentName, platformName=None):
243          if platformName is not None:
244              platform = get_component_file(self.app, platformName)
245              platform[platformName]["components"][componentName.lower()][
246                  "docs"
247              ] = description
248          else:
249              core = get_component_file(self.app, "esphome")["core"]
250              if componentName in core["components"]:
251                  core["components"][componentName]["docs"] = description
252              elif componentName in core["platforms"]:
253                  core["platforms"][componentName]["docs"] = description
254              else:
255                  if componentName != "display_menu_base":
256                      raise ValueError(
257                          "Cannot set description for component " + componentName
258                      )
259      def visit_document(self, node):
260          if self.docname in ["components/sensor/binary_sensor_map"]:
261              raise nodes.SkipChildren
262          if self.docname in ["components/climate/climate_ir"]:
263              return
264          if len(list(node.traverse(nodes.paragraph))) == 0:
265              raise nodes.SkipChildren
266          self.props_section_title = get_node_title(node)
267          description = self.getMarkdownParagraph(node)
268          if self.json_platform_component:
269              self.set_component_description(description, self.component, self.platform)
270          elif self.json_component:
271              self.set_component_description(description, self.component)
272          if self.json_component or self.json_platform_component:
273              if is_component_file(
274                  self.app,
275                  self.component,
276              ):
277                  self.props = self.find_props(
278                      self.json_platform_component
279                      if self.json_platform_component
280                      else self.json_component,
281                      True,
282                  )
283      def visit_table(self, node):
284          if (
285              self.docname == "components/climate/climate_ir"
286              and len(CUSTOM_DOCS["components/climate/climate_ir"]["IR Remote Climate"])
287              == 0
288          ):
289              table_rows = node[0][4]
290              for row in table_rows:
291                  components_paths = [
292                      components + ".platform.climate.schemas.CONFIG_SCHEMA"
293                      for components in row[1].astext().split("\n")
294                  ]
295                  CUSTOM_DOCS["components/climate/climate_ir"][
296                      "IR Remote Climate"
297                  ] += components_paths
298      def depart_document(self, node):
299          pass
300      def visit_section(self, node):
301          self.section_level += 1
302          section_title = get_node_title(node)
303          if self.custom_doc and section_title in self.custom_doc:
304              r = self.custom_doc[section_title]
305              if ".registry." in r:
306                  self.find_registry = r
307      def depart_section(self, node):
308          self.section_level -= 1
309          if self.section_level == 1:
310              self.find_registry = None
311      def unknown_visit(self, node):
312          pass
313      def unknown_departure(self, node):
314          pass
315      def visit_title(self, node):
316          title_text = node.astext()
317          if self.custom_doc is not None and title_text in self.custom_doc:
318              if isinstance(self.custom_doc[title_text], list):
319                  self.multi_component = self.custom_doc[title_text]
320                  self.filled_props = False
321                  self.props = None
<span onclick='openModal()' class='match'>322                  desc = self.getMarkdownParagraph(node.parent)
323                  for c in self.multi_component:
324                      if len(c.split(".")) == 2:
</span>325                          self.set_component_description(desc, c.split(".")[0])
326                  return
327              json_component = self.find_component(self.custom_doc[title_text])
328              if not json_component:
329                  return
330              if self.json_component is None:
331                  self.json_component = json_component
332              parts = self.custom_doc[title_text].split(".")
333              if parts[0] not in ["core", "remote_base"] and parts[-1] != "pin":
334                  if parts[1] == "platform":
335                      self.set_component_description(
336                          self.getMarkdownParagraph(node.parent), parts[0], parts[2]
337                      )
338                  else:
339                      self.set_component_description(
340                          self.getMarkdownParagraph(node.parent),
341                          parts[0],
342                      )
343              self.props_section_title = title_text
344              self.props = self.find_props(json_component)
345              return
346          elif title_text == COMPONENT_HUB:
347              self.props_section_title = f"{self.path[-1]} {title_text}"
348              json_component = self.get_component_schema(
349                  self.path[-1] + ".CONFIG_SCHEMA"
350              ).get("schema", {})
351              if json_component:
352                  self.props = self.find_props(json_component)
353                  self.set_component_description(
354                      self.getMarkdownParagraph(node.parent), self.path[-1]
355                  )
356              self.is_component_hub = True
357          elif is_config_vars_title(title_text):
358              if not self.props and self.multi_component is None:
359                  raise ValueError(
360                      f'Found a "{title_text}": title after {self.previous_title_text}. Unknown object.'
361                  )
362          elif title_text == "Over SPI" or title_text == "Over I²C":
363              suffix = "_spi" if "SPI" in title_text else "_i2c"
364              component = self.path[-1] + suffix
365              self.props_section_title = self.path[-1] + " " + title_text
366              if self.platform is not None and not self.is_component_hub:
367                  json_platform_component = find_platform_component(
368                      self.app, self.platform, component
369                  )
370                  if not json_platform_component:
371                      raise ValueError(
372                          f"Cannot find platform {self.platform} component '{component}' after found title: '{title_text}'."
373                      )
374                  self.props = self.find_props(json_platform_component)
375                  json_platform_component["docs"] = self.getMarkdownParagraph(node.parent)
376              else:
377                  json_component = self.get_component_schema(
378                      component + ".CONFIG_SCHEMA"
379                  ).get("schema", {})
380                  if not json_component:
381                      raise ValueError(
382                          f"Cannot find component '{component}' after found title: '{title_text}'."
383                      )
384                  self.props = self.find_props(json_component)
385                  self.set_component_description(
386                      self.getMarkdownParagraph(node.parent), component
387                  )
388          elif (
389              len(
390                  list(
391                      filter(
392                          lambda x: title_text.endswith(x), list(PLATFORMS_TITLES.keys())
393                      )
394                  )
395              )
396              > 0
397          ):
398              if title_text in PLATFORMS_TITLES:
399                  platform_name = PLATFORMS_TITLES[title_text]
400                  if self.path[-1] == "index":
401                      component_name = self.path[-2]
402                  else:
403                      component_name = self.path[-1]
404                  self.props_section_title = component_name + " " + title_text
405              else:
406                  for t in PLATFORMS_TITLES:
407                      if title_text.endswith(t):
408                          component_name = title_text[
409                              0 : len(title_text) - len(t) - 1
410                          ].replace(" ", "_")
411                          platform_name = PLATFORMS_TITLES[t]
412                  if not platform_name:
413                      return
414                  self.props_section_title = title_text
415                  if not is_component_file(self.app, component_name):
416                      return
417              c = find_platform_component(self.app, platform_name, component_name.lower())
418              if c:
419                  self.json_platform_component = c
420                  self.set_component_description(
421                      self.getMarkdownParagraph(node.parent),
422                      component_name,
423                      platform_name,
424                  )
425              try:
426                  self.props = self.find_props(self.json_platform_component)
427              except KeyError:
428                  raise ValueError("Cannot find platform props")
429          elif title_text.endswith("Component") or title_text.endswith("Bus"):
430              split_text = title_text.split(" ")
431              self.props_section_title = title_text
432              component_name = (
433                  "_".join(split_text[:-1]).lower().replace(".", "").replace("i²c", "i2c")
434              )
435              if component_name != self.platform and is_component_file(
436                  self.app, component_name
437              ):
438                  f = get_component_file(self.app, component_name)
439                  description = self.getMarkdownParagraph(node.parent)
440                  if component_name in f:
441                      self.set_component_description(description, component_name)
442                      c = f[component_name]
443                      if c:
444                          self.json_component = c["schemas"]["CONFIG_SCHEMA"]
445                          try:
446                              self.props = self.find_props(self.json_component)
447                              self.multi_component = None
448                          except KeyError:
449                              raise ValueError(
450                                  "Cannot find props for component " + component_name
451                              )
452                          return
453                  elif f"{component_name}.{self.path[1]}" in f:
454                      self.set_component_description(
455                          description, component_name, self.path[1]
456                      )
457                      self.json_platform_component = f[
458                          f"{component_name}.{self.path[1]}"
459                      ]["schemas"]["CONFIG_SCHEMA"]
460                      try:
461                          self.props = self.find_props(self.json_platform_component)
462                      except KeyError:
463                          raise ValueError(
464                              f"Cannot find props for platform {self.path[1]} component {self.component_name}"
465                          )
466                      return
467          elif title_text.endswith("Trigger"):
468              description = self.getMarkdownParagraph(node.parent)
469              split_text = title_text.split(" ")
470              if len(split_text) != 2:
471                  return
472              key = split_text[0]
473              if (
474                  not self.props or not self.props.typed
475              ):  # props are right for typed components so far
476                  c = self.json_component
477                  if c:
478                      if self.component in c:
479                          c = c[self.component]["schemas"][
480                              self.component.upper() + "_SCHEMA"
481                          ]
482                      trigger_schema = self.find_props(c).get(key)
483                      if trigger_schema is not None:
484                          self.props = self.find_props(trigger_schema)
485              self.props_section_title = title_text
486          elif title_text == PIN_CONFIGURATION_VARIABLES:
487              self.component = self.find_component(self.path[-1] + ".pin")
488              self.props = self.find_props(self.component)
489              self.accept_props = True
490              if not self.component:
491                  raise ValueError(
492                      f'Found a "{PIN_CONFIGURATION_VARIABLES}" entry but could not find pin schema'
493                  )
494          elif title_text.endswith("Action") or title_text.endswith("Condition"):
495              description = self.getMarkdownParagraph(node.parent)
496              split_text = title_text.split(" ")
497              if len(split_text) != 2:
498                  return
499              key = split_text[0]
500              component_parts = split_text[0].split(".")
501              if len(component_parts) == 3:
502                  try:
503                      cv = get_component_file(self.app, component_parts[1])[
504                          component_parts[1] + "." + component_parts[0]
505                      ][split_text[1].lower()][component_parts[2]]
506                  except KeyError:
507                      logger.warn(
508                          f"In {self.docname} cannot found schema of {title_text}"
509                      )
510                      cv = None
511                  if cv is not None:
512                      cv["docs"] = description
513                      self.props = self.find_props(cv.get("schema", {}))
514              elif len(component_parts) == 2:
515                  registry_name = ".".join(
516                      [component_parts[0], "registry", split_text[1].lower()]
517                  )
518                  key = component_parts[1]
519                  self.find_registry_prop(registry_name, key, description)
520              else:
521                  registry_name = f"core.registry.{split_text[1].lower()}"
522                  self.find_registry_prop(registry_name, key, description)
523          if self.section_level == 3 and self.find_registry:
524              name = title_text
525              if name.endswith(" Effect"):
526                  name = title_text[: -len(" Effect")]
527              if name.endswith(" Light"):
528                  name = name[: -len(" Light")]
529              key = name.replace(" ", "_").replace(".", "").lower()
530              description = self.getMarkdownParagraph(node.parent)
531              self.find_registry_prop(self.find_registry, key, description)
532              self.props_section_title = title_text
533      def get_component_schema(self, name):
534          parts = name.split(".")
535          schema_file = get_component_file(self.app, parts[0])
536          if parts[1] == "registry":
537              schema = schema_file.get(parts[0], {}).get(parts[2], {})
538          elif len(parts) == 3:
539              schema = (
540                  schema_file.get(f"{parts[0]}.{parts[1]}")
541                  .get("schemas", {})
542                  .get(parts[2], {})
543              )
544          else:
545              schema = schema_file.get(parts[0], {}).get("schemas", {}).get(parts[1], {})
546          return schema
547      def get_component_config_var(self, name, key):
548          c = self.get_component_schema(name)
549          if key in c:
550              return c[key]
551          if "config_vars" not in c:
552              return c
553          if key in c["config_vars"]:
554              return c["config_vars"][c]
555      def find_registry_prop(self, registry_name, key, description):
556          c = self.get_component_schema(registry_name)
557          if key in c:
558              cv = c[key]
559              if cv is not None:
560                  cv["docs"] = description
561                  self.props = self.find_props(cv.get("schema", {}))
562      def depart_title(self, node):
563          if self.filled_props:
564              self.filled_props = False
565              self.props = None
566              self.current_prop = None
567              self.accept_props = False
568              self.multi_component = None
569          self.previous_title_text = node.astext()
570          self.title_id = node.parent["ids"][0]
571      def find_props_previous_title(self):
572          comp = self.json_component or self.json_platform_component
573          if comp:
574              props = self.find_props(comp)
575              if self.previous_title_text in props:
576                  prop = props[self.previous_title_text]
577                  if prop:
578                      self.props = self.find_props(prop)
579                  else:
580                      self.props = {"__": "none"}
581      def visit_Text(self, node):
582          if self.multi_component:
583              return
584          if is_config_vars_title(node.astext()):
585              if not self.props:
586                  self.find_props_previous_title()
587              if not self.props:
588                  raise ValueError(
589                      f'Found a "{node.astext()}" entry for unknown object after {self.previous_title_text}'
590                  )
591              self.accept_props = True
592          raise nodes.SkipChildren
593      def depart_Text(self, node):
594          pass
595      def visit_paragraph(self, node):
596          if is_config_vars_title(node.astext()):
597              if not self.props and not self.multi_component:
598                  self.find_props_previous_title()
599              if not self.props and not self.multi_component:
600                  logger.info(
601                      f"In {self.docname} / {self.previous_title_text} found a {node.astext()} title and there are no props."
602                  )
603              self.accept_props = True
604          raise nodes.SkipChildren
605      def depart_paragraph(self, node):
606          pass
607      def visit_bullet_list(self, node):
608          self.bullet_list_level = self.bullet_list_level + 1
609          if (
610              self.current_prop
611              and (self.props or self.multi_component)
612              and self.bullet_list_level > 1
613          ):
614              self.prop_stack.append((self.current_prop, node))
615              self.accept_props = True
616              return
617          if not self.props and self.multi_component is None:
618              raise nodes.SkipChildren
619      def depart_bullet_list(self, node):
620          self.bullet_list_level = self.bullet_list_level - 1
621          if len(self.prop_stack) > 0:
622              stack_prop, stack_node = self.prop_stack[-1]
623              if stack_node == node:
624                  self.prop_stack.pop()
625                  self.filled_props = True
626                  self.current_prop = stack_prop
627      def visit_list_item(self, node):
628          if self.accept_props and self.props:
629              self.filled_props = True
630              self.current_prop, found = self.update_prop(node, self.props)
631              if self.current_prop and not found:
632                  logger.info(
633                      f"In '{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}"
634                  )
635          elif self.multi_component:
636              found_any = False
637              self.current_prop = None
638              for c in self.multi_component:
639                  props = self.find_props(self.find_component(c))
640                  self.current_prop, found = self.update_prop(node, props)
641                  if self.current_prop and found:
642                      found_any = True
643              if self.current_prop and not found_any:
644                  logger.info(
645                      f"In '{self.docname} {self.previous_title_text} Cannot find property {self.current_prop}"
646                  )
647              self.filled_props = True
648      def depart_list_item(self, node):
649          pass
650      def visit_literal(self, node):
651          raise nodes.SkipChildren
652      def depart_literal(self, node):
653          pass
654      def getMarkdown(self, node):
655          from markdown import Translator
656          t = Translator(
657              urllib.parse.urljoin(self.app.config.html_baseurl, self.docname + ".html"),
658              self.doctree,
659          )
660          node.walkabout(t)
661          return t.output.strip("\n")
662      def getMarkdownParagraph(self, node):
663          paragraph = list(node.traverse(nodes.paragraph))[0]
664          markdown = self.getMarkdown(paragraph)
665          param_type = None
666          try:
667              name_type = markdown[: markdown.index(": ") + 2]
668              ntr = re.search(
669                  REQUIRED_OPTIONAL_TYPE_REGEX,
670                  name_type,
671                  re.IGNORECASE,
672              )
673              if ntr:
674                  param_type = ntr.group(6)
675                  if param_type:
676                      markdown = (
677                          f"**{param_type}**: {markdown[markdown.index(': ') + 2 :]}"
678                      )
679          except ValueError:
680              pass
681          title = list(node.traverse(nodes.title))[0]
682          if len(title) > 0:
683              url = urllib.parse.urljoin(
684                  self.app.config.html_baseurl,
685                  self.docname + ".html#" + title.parent["ids"][0],
686              )
687              if (
688                  self.props_section_title is not None
689                  and self.props_section_title.endswith(title.astext())
690              ):
691                  markdown += f"\n\n*See also: [{self.props_section_title}]({url})*"
692              else:
693                  markdown += f"\n\n*See also: [{self.getMarkdown(title)}]({url})*"
694          return markdown
695      def update_prop(self, node, props):
696          prop_name = None
697          for s_prop, n in self.prop_stack:
698              inner = props.get(s_prop)
699              if inner is not None and "schema" in inner:
700                  props = self.Props(self, inner["schema"])
701              elif inner is not None and inner.get("type") == "typed":
702                  props = self.Props(self, inner)
703              elif inner is not None and inner.get("type") == "enum":
704                  enum_raw = self.getMarkdown(node)
705                  enum_match = re.search(
706                      r"\* `([^`]*)`((:| -) (.*))*", enum_raw, re.IGNORECASE
707                  )
708                  if enum_match:
709                      enum_value = enum_match.group(1)
710                      enum_docs = enum_match.group(4)
711                      found = False
712                      for name in inner["values"]:
713                          if enum_value.upper().replace(" ", "_") == str(name).upper():
714                              found = True
715                              if enum_docs:
716                                  enum_docs = enum_docs.strip()
717                                  if inner["values"][name] is None:
718                                      inner["values"][name] = {"docs": enum_docs}
719                                  else:
720                                      inner["values"][name]["docs"] = enum_docs
721                                  statistics.props_documented += 1
722                                  statistics.enums_good += 1
723                      if not found:
724                          logger.info(
725                              f"In '{self.docname} {self.previous_title_text} Property {s_prop} cannot find enum value {enum_value}"
726                          )
727                  else:
728                      statistics.enums_bad += 1
729                      logger.info(
730                          f"In '{self.docname} {self.previous_title_text} Property {s_prop} unexpected enum member description format"
731                      )
732              else:
733                  return prop_name, False
734          raw = node.rawsource  # this has the full raw rst code for this property
735          if not raw.startswith("**"):
736              return prop_name, False
737          markdown = self.getMarkdown(node)
738          markdown += f"\n\n*See also: [{self.props_section_title}]({urllib.parse.urljoin(self.app.config.html_baseurl, self.docname +'.html#'+self.title_id)})*"
739          try:
740              name_type = markdown[: markdown.index(": ") + 2]
741          except ValueError:
742              logger.info(
743                  f"In '{self.docname} {self.previous_title_text} Property format error. Missing ': ' in {raw}'"
744              )
745              return prop_name, False
746          PROP_NAME_REGEX = r"\*\*(\w*(?:/\w*)*)\*\*"
747          FULL_ITEM_PROP_NAME_TYPE_REGEX = (
748              r"\* " + PROP_NAME_REGEX + r"\s" + REQUIRED_OPTIONAL_TYPE_REGEX
749          )
750          ntr = re.search(
751              FULL_ITEM_PROP_NAME_TYPE_REGEX,
752              name_type,
753              re.IGNORECASE,
754          )
755          if ntr:
756              prop_name = ntr.group(1)
757              param_type = ntr.group(7)
758          else:
759              s2 = re.search(
760                  FULL_ITEM_PROP_NAME_TYPE_REGEX,
761                  markdown,
762                  re.IGNORECASE,
763              )
764              if s2:
765                  s3 = re.search(r"\* " + PROP_NAME_REGEX + r"*:\s", name_type)
766                  if s3 is not None:
767                      prop_name = s3.group(1)
768                  else:
769                      logger.info(
770                          f"In '{self.docname} {self.previous_title_text} Invalid list format: {node.rawsource}"
771                      )
772                  param_type = None
773              else:
774                  logger.info(
775                      f"In '{self.docname} {self.previous_title_text} Invalid property format: {node.rawsource}"
776                  )
777                  return prop_name, False
778          prop_names = str(prop_name)
779          for k in prop_names.split("/"):
780              config_var = props.get(k)
781              if not config_var:
782                  if k in [
783                      "id",
784                      "name",
785                      "internal",
786                      "address",
787                      "i2c_id",
788                      "update_interval",
789                      "uart_id",
790                      "effects",
791                      "gamma_correct",
792                      "default_transition_length",
793                      "flash_transition_length",
794                      "color_correct",
795                      "lambda",
796                      "pages",
797                      "rotation",
798                      "spi_id",
799                      "cs_pin",
800                      "inverted",
801                      "power_supply",
802                      "receiver_id",
803                  ]:
804                      config_var = props[k] = {}
805                  else:
806                      if self.path[1] == "esphome" and k in [
807                          "platform",
808                          "board",
809                          "arduino_version",
810                          "esp8266_restore_from_flash",
811                      ]:
812                          return prop_name, True
813                      return prop_name, False
814              desc = markdown[markdown.index(": ") + 2 :].strip()
815              if param_type:
816                  desc = "**" + param_type + "**: " + desc
817              config_var["docs"] = desc
818          statistics.props_documented += 1
819          return prop_name, True
820      def find_component(self, component_path):
821          path = component_path.split(".")
822          file_content = get_component_file(self.app, path[0])
823          if path[1] == "platform":
824              path[2] = f"{path[0]}.{path[2]}"
825              path = path[2:]
826          component = file_content
827          for p in path:
828              component = component.get(p, {})
829          return component
830      class Props(MutableMapping):
831          def __init__(self, visitor, component, fail_silently=False):
832              self.visitor = visitor
833              self.component = component
834              self.store = self._get_props(component, fail_silently)
835              self.parent = None
836              self.typed = self.component.get("type") == "typed"
837          def _get_props(self, component, fail_silently):
838              if not (
839                  "config_vars" in component
840                  or "extends" in component
841                  or len(component) == 0
842                  or component.get("type") == "typed"
843              ):
844                  if fail_silently:
845                      return None
846                  raise ValueError("Unexpected component data to get props")
847              props = component.get("config_vars")
848              return props
849          def _find_extended(self, component, key):
850              for extended in component.get("extends", []):
851                  c = self.visitor.get_component_schema(extended)
852                  if c.get("type") == "typed":
853                      p = self.visitor.Props(self.visitor, c)
854                      return p[key]
855                  schema = c.get("schema", {})
856                  for k, cv in schema.get("config_vars", {}).items():
857                      if k == key:
858                          return SetObservable(
859                              cv,
860                              setitem_callback=self._set_extended,
861                              inner_key=key,
862                              original_dict=schema.get("config_vars"),
863                          )
864                  ex1 = self._find_extended(schema, key)
865                  if ex1:
866                      return ex1
867          def _set_extended(self, inner_key, original_dict, key, value):
868              original_dict[inner_key][key] = value
869          def _iter_extended(self, component):
870              for extended in component.get("extends", []):
871                  schema = self.visitor.get_component_schema(extended).get("schema", {})
872                  for s in self._iter_extended(schema):
873                      yield s
874                  yield schema
875          def __getitem__(self, key):
876              if self.store and key in self.store:
877                  return self.store[key]
878              extended = self._find_extended(self.component, key)
879              if extended is not None:
880                  return extended
881              if self.component.get("type") == "typed":
882                  return SetObservable(
883                      {key: {"type": "string"}},
884                      setitem_callback=self._set_typed,
885                      inner_key=key,
886                      original_dict={},
887                  )
888          def _set_typed(self, inner_key, original_dict, key, value):
889              if inner_key == self.component.get("typed_key", "type"):
890                  self.component[key] = value
891              else:
892                  for tk, tv in self.component["types"].items():
893                      for cv_k, cv_v in tv["config_vars"].items():
894                          if cv_k == inner_key:
895                              cv_v[key] = value
896          def __setitem__(self, key, value):
897              self.store[key] = value
898          def __delitem__(self, key):
899              self.store.pop(key)
900          def __iter__(self):
901              return iter(self.store)
902          def __len__(self):
903              len_extended = 0
904              if self.component.get("type"):
905                  types = self.component.get("types")
906                  for t, tv in types.items():
907                      for s in self._iter_extended(types.get(t, {})):
908                          len_extended += len(s.get("config_vars", {}))
909                      len_extended += len(tv.get("config_vars", {}))
910                  return len_extended
911              for s in self._iter_extended(self.component):
912                  len_extended += len(s.get("config_vars", {}))
913              return len_extended + (len(self.store) if self.store else 0)
914      def find_props(self, component, fail_silently=False):
915          if component.get("type") in ["trigger", "schema"]:
916              if "schema" not in component:
917                  return None
918              component = component.get("schema")
919          props = self.Props(self, component, fail_silently)
920          if props:
921              self.filled_props = False
922              self.accept_props = False
923              self.current_prop = None
924          return props
925  def handle_component(app, doctree, docname):
926      path = docname.split("/")
927      if path[0] == "components":
928          pass
929      elif docname not in CUSTOM_DOCS:
930          return
931      try:
932          v = SchemaGeneratorVisitor(app, doctree, docname)
933          doctree.walkabout(v)
934      except Exception as e:
935          err_str = f"In {docname}.rst: {str(e)}"
936          logger.warning(err_str)
937  def build_finished(app, exception):
938      for fname, contents in app.files.items():
939          f = open(SCHEMA_PATH + fname + ".json", "w", newline="\n")
940          if JSON_DUMP_PRETTY:
941              f.write(json.dumps(contents, indent=2))
942          else:
943              f.write(json.dumps(contents, separators=(",", ":")))
944      str = f"Documented: {statistics.props_documented} Enums: {statistics.enums_good}/{statistics.enums_bad}"
945      logger.info(str)
946  class SetObservable(dict):
947      def __init__(
948          self,
949          value,
950          setitem_callback=None,
951          inner_key=None,
952          original_dict=None,
953          *args,
954          **kwargs,
955      ):
956          super(SetObservable, self).__init__(value, *args, **kwargs)
957          self._setitem_callback = setitem_callback
958          self.inner_key = inner_key
959          self.original_dict = original_dict
960      def __setitem__(self, key, value):
961          if self._setitem_callback:
962              self._setitem_callback(self.inner_key, self.original_dict, key, value)
963          super(SetObservable, self).__setitem__(key, value)
964  def is_component_file(app: SchemaGeneratorVisitor, component):
965      if component == "core" or component == "automation":
966          component = "esphome"
967      return exists(SCHEMA_PATH + component + ".json")
968  def get_component_file(app: SchemaGeneratorVisitor, component):
969      if component == "core" or component == "automation":
970          component = "esphome"
971      if component not in app.files:
972          app.files[component] = read_file(component)
973      return app.files[component]
</code></pre>
        </div>
        <div class="column">
            <h3>google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-discovery.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  __author__ = "jcgregorio@google.com (Joe Gregorio)"
3  __all__ = ["build", "build_from_document", "fix_method_name", "key2param"]
4  from collections import OrderedDict
5  import collections.abc
6  import copy
7  from email.generator import BytesGenerator
8  from email.mime.multipart import MIMEMultipart
9  from email.mime.nonmultipart import MIMENonMultipart
10  import http.client as http_client
11  import io
12  import json
13  import keyword
14  import logging
15  import mimetypes
16  import os
17  import re
18  import urllib
19  import google.api_core.client_options
20  from google.auth.exceptions import MutualTLSChannelError
21  from google.auth.transport import mtls
22  from google.oauth2 import service_account
23  import httplib2
24  import uritemplate
25  try:
26      import google_auth_httplib2
27  except ImportError:  # pragma: NO COVER
28      google_auth_httplib2 = None
29  from googleapiclient import _auth, mimeparse
30  from googleapiclient._helpers import _add_query_parameter, positional
31  from googleapiclient.errors import (
32      HttpError,
33      InvalidJsonError,
34      MediaUploadSizeError,
35      UnacceptableMimeTypeError,
36      UnknownApiNameOrVersion,
37      UnknownFileType,
38  )
39  from googleapiclient.http import (
40      BatchHttpRequest,
41      HttpMock,
42      HttpMockSequence,
43      HttpRequest,
44      MediaFileUpload,
45      MediaUpload,
46      build_http,
47  )
48  from googleapiclient.model import JsonModel, MediaModel, RawModel
49  from googleapiclient.schema import Schemas
50  httplib2.RETRIES = 1
51  logger = logging.getLogger(__name__)
52  URITEMPLATE = re.compile("{[^}]*}")
53  VARNAME = re.compile("[a-zA-Z0-9_-]+")
54  DISCOVERY_URI = (
55      "https://www.googleapis.com/discovery/v1/apis/" "{api}/{apiVersion}/rest"
56  )
57  V1_DISCOVERY_URI = DISCOVERY_URI
58  V2_DISCOVERY_URI = (
59      "https://{api}.googleapis.com/$discovery/rest?" "version={apiVersion}"
60  )
61  DEFAULT_METHOD_DOC = "A description of how to use this function"
62  HTTP_PAYLOAD_METHODS = frozenset(["PUT", "POST", "PATCH"])
63  _MEDIA_SIZE_BIT_SHIFTS = {"KB": 10, "MB": 20, "GB": 30, "TB": 40}
64  BODY_PARAMETER_DEFAULT_VALUE = {"description": "The request body.", "type": "object"}
65  MEDIA_BODY_PARAMETER_DEFAULT_VALUE = {
66      "description": (
67          "The filename of the media request body, or an instance "
68          "of a MediaUpload object."
69      ),
70      "type": "string",
71      "required": False,
72  }
73  MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE = {
74      "description": (
75          "The MIME type of the media request body, or an instance "
76          "of a MediaUpload object."
77      ),
78      "type": "string",
79      "required": False,
80  }
81  _PAGE_TOKEN_NAMES = ("pageToken", "nextPageToken")
82  GOOGLE_API_USE_CLIENT_CERTIFICATE = "GOOGLE_API_USE_CLIENT_CERTIFICATE"
83  GOOGLE_API_USE_MTLS_ENDPOINT = "GOOGLE_API_USE_MTLS_ENDPOINT"
84  STACK_QUERY_PARAMETERS = frozenset(["trace", "pp", "userip", "strict"])
85  STACK_QUERY_PARAMETER_DEFAULT_VALUE = {"type": "string", "location": "query"}
86  RESERVED_WORDS = frozenset(["body"])
87  class _BytesGenerator(BytesGenerator):
88      _write_lines = BytesGenerator.write
89  def fix_method_name(name):
90      name = name.replace("$", "_").replace("-", "_")
91      if keyword.iskeyword(name) or name in RESERVED_WORDS:
92          return name + "_"
93      else:
94          return name
95  def key2param(key):
96      result = []
97      key = list(key)
98      if not key[0].isalpha():
99          result.append("x")
100      for c in key:
101          if c.isalnum():
102              result.append(c)
103          else:
104              result.append("_")
105      return "".join(result)
106  @positional(2)
107  def build(
108      serviceName,
109      version,
110      http=None,
111      discoveryServiceUrl=None,
112      developerKey=None,
113      model=None,
114      requestBuilder=HttpRequest,
115      credentials=None,
116      cache_discovery=True,
117      cache=None,
118      client_options=None,
119      adc_cert_path=None,
120      adc_key_path=None,
121      num_retries=1,
122      static_discovery=None,
123      always_use_jwt_access=False,
124  ):
125      params = {"api": serviceName, "apiVersion": version}
126      if static_discovery is None:
127          if discoveryServiceUrl is None:
128              static_discovery = True
129          else:
130              static_discovery = False
131      if http is None:
132          discovery_http = build_http()
133      else:
134          discovery_http = http
135      service = None
136      for discovery_url in _discovery_service_uri_options(discoveryServiceUrl, version):
137          requested_url = uritemplate.expand(discovery_url, params)
138          try:
139              content = _retrieve_discovery_doc(
140                  requested_url,
141                  discovery_http,
142                  cache_discovery,
143                  serviceName,
144                  version,
145                  cache,
146                  developerKey,
147                  num_retries=num_retries,
148                  static_discovery=static_discovery,
149              )
150              service = build_from_document(
151                  content,
152                  base=discovery_url,
153                  http=http,
154                  developerKey=developerKey,
155                  model=model,
156                  requestBuilder=requestBuilder,
157                  credentials=credentials,
158                  client_options=client_options,
159                  adc_cert_path=adc_cert_path,
160                  adc_key_path=adc_key_path,
161                  always_use_jwt_access=always_use_jwt_access,
162              )
163              break  # exit if a service was created
164          except HttpError as e:
165              if e.resp.status == http_client.NOT_FOUND:
166                  continue
167              else:
168                  raise e
169      if http is None:
170          discovery_http.close()
171      if service is None:
172          raise UnknownApiNameOrVersion("name: %s  version: %s" % (serviceName, version))
173      else:
174          return service
175  def _discovery_service_uri_options(discoveryServiceUrl, version):
176      if discoveryServiceUrl is not None:
177          return [discoveryServiceUrl]
178      if version is None:
179          logger.warning(
180              "Discovery V1 does not support empty versions. Defaulting to V2..."
181          )
182          return [V2_DISCOVERY_URI]
183      else:
184          return [DISCOVERY_URI, V2_DISCOVERY_URI]
185  def _retrieve_discovery_doc(
186      url,
187      http,
188      cache_discovery,
189      serviceName,
190      version,
191      cache=None,
192      developerKey=None,
193      num_retries=1,
194      static_discovery=True,
195  ):
196      from . import discovery_cache
197      if cache_discovery:
198          if cache is None:
199              cache = discovery_cache.autodetect()
200          if cache:
201              content = cache.get(url)
202              if content:
203                  return content
204      if static_discovery:
205          content = discovery_cache.get_static_doc(serviceName, version)
206          if content:
207              return content
208          else:
209              raise UnknownApiNameOrVersion(
210                  "name: %s  version: %s" % (serviceName, version)
211              )
212      actual_url = url
213      if "REMOTE_ADDR" in os.environ:
214          actual_url = _add_query_parameter(url, "userIp", os.environ["REMOTE_ADDR"])
215      if developerKey:
216          actual_url = _add_query_parameter(url, "key", developerKey)
217      logger.debug("URL being requested: GET %s", actual_url)
218      req = HttpRequest(http, HttpRequest.null_postproc, actual_url)
219      resp, content = req.execute(num_retries=num_retries)
220      try:
221          content = content.decode("utf-8")
222      except AttributeError:
223          pass
224      try:
225          service = json.loads(content)
226      except ValueError as e:
227          logger.error("Failed to parse as JSON: " + content)
228          raise InvalidJsonError()
229      if cache_discovery and cache:
230          cache.set(url, content)
231      return content
232  @positional(1)
233  def build_from_document(
234      service,
235      base=None,
236      future=None,
237      http=None,
238      developerKey=None,
239      model=None,
240      requestBuilder=HttpRequest,
241      credentials=None,
242      client_options=None,
243      adc_cert_path=None,
244      adc_key_path=None,
245      always_use_jwt_access=False,
246  ):
247      if client_options is None:
248          client_options = google.api_core.client_options.ClientOptions()
249      if isinstance(client_options, collections.abc.Mapping):
250          client_options = google.api_core.client_options.from_dict(client_options)
251      if http is not None:
252          banned_options = [
253              (credentials, "credentials"),
254              (client_options.credentials_file, "client_options.credentials_file"),
255          ]
256          for option, name in banned_options:
257              if option is not None:
258                  raise ValueError(
259                      "Arguments http and {} are mutually exclusive".format(name)
260                  )
261      if isinstance(service, str):
262          service = json.loads(service)
263      elif isinstance(service, bytes):
264          service = json.loads(service.decode("utf-8"))
265      if "rootUrl" not in service and isinstance(http, (HttpMock, HttpMockSequence)):
266          logger.error(
267              "You are using HttpMock or HttpMockSequence without"
268              + "having the service discovery doc in cache. Try calling "
269              + "build() without mocking once first to populate the "
270              + "cache."
271          )
272          raise InvalidJsonError()
273      base = urllib.parse.urljoin(service["rootUrl"], service["servicePath"])
274      audience_for_self_signed_jwt = base
275      if client_options.api_endpoint:
276          base = client_options.api_endpoint
277      schema = Schemas(service)
278      if http is None:
279          scopes = list(
280              service.get("auth", {}).get("oauth2", {}).get("scopes", {}).keys()
281          )
282          if scopes and not developerKey:
283              if client_options.credentials_file and credentials:
284                  raise google.api_core.exceptions.DuplicateCredentialArgs(
285                      "client_options.credentials_file and credentials are mutually exclusive."
286                  )
287              if client_options.credentials_file:
288                  credentials = _auth.credentials_from_file(
289                      client_options.credentials_file,
290                      scopes=client_options.scopes,
291                      quota_project_id=client_options.quota_project_id,
292                  )
293              if credentials is None:
294                  credentials = _auth.default_credentials(
295                      scopes=client_options.scopes,
296                      quota_project_id=client_options.quota_project_id,
297                  )
298              if not client_options.scopes:
299                  credentials = _auth.with_scopes(credentials, scopes)
300          if (
301              credentials
302              and isinstance(credentials, service_account.Credentials)
303              and always_use_jwt_access
304              and hasattr(service_account.Credentials, "with_always_use_jwt_access")
305          ):
306              credentials = credentials.with_always_use_jwt_access(always_use_jwt_access)
307              credentials._create_self_signed_jwt(audience_for_self_signed_jwt)
308          if credentials:
309              http = _auth.authorized_http(credentials)
310          else:
311              http = build_http()
312          client_cert_to_use = None
313          use_client_cert = os.getenv(GOOGLE_API_USE_CLIENT_CERTIFICATE, "false")
314          if not use_client_cert in ("true", "false"):
315              raise MutualTLSChannelError(
316                  "Unsupported GOOGLE_API_USE_CLIENT_CERTIFICATE value. Accepted values: true, false"
317              )
318          if client_options and client_options.client_cert_source:
319              raise MutualTLSChannelError(
320                  "ClientOptions.client_cert_source is not supported, please use ClientOptions.client_encrypted_cert_source."
321              )
322          if use_client_cert == "true":
323              if (
324                  client_options
325                  and hasattr(client_options, "client_encrypted_cert_source")
326                  and client_options.client_encrypted_cert_source
327              ):
328                  client_cert_to_use = client_options.client_encrypted_cert_source
329              elif (
330                  adc_cert_path and adc_key_path and mtls.has_default_client_cert_source()
331              ):
332                  client_cert_to_use = mtls.default_client_encrypted_cert_source(
333                      adc_cert_path, adc_key_path
334                  )
335          if client_cert_to_use:
336              cert_path, key_path, passphrase = client_cert_to_use()
337              http_channel = (
338                  http.http
339                  if google_auth_httplib2
340                  and isinstance(http, google_auth_httplib2.AuthorizedHttp)
341                  else http
342              )
343              http_channel.add_certificate(key_path, cert_path, "", passphrase)
344          if "mtlsRootUrl" in service and (
345              not client_options or not client_options.api_endpoint
346          ):
347              mtls_endpoint = urllib.parse.urljoin(
348                  service["mtlsRootUrl"], service["servicePath"]
349              )
350              use_mtls_endpoint = os.getenv(GOOGLE_API_USE_MTLS_ENDPOINT, "auto")
351              if not use_mtls_endpoint in ("never", "auto", "always"):
352                  raise MutualTLSChannelError(
353                      "Unsupported GOOGLE_API_USE_MTLS_ENDPOINT value. Accepted values: never, auto, always"
354                  )
355              if use_mtls_endpoint == "always" or (
356                  use_mtls_endpoint == "auto" and client_cert_to_use
357              ):
358                  base = mtls_endpoint
359      if model is None:
360          features = service.get("features", [])
361          model = JsonModel("dataWrapper" in features)
362      return Resource(
363          http=http,
364          baseUrl=base,
365          model=model,
366          developerKey=developerKey,
367          requestBuilder=requestBuilder,
368          resourceDesc=service,
369          rootDesc=service,
370          schema=schema,
371      )
372  def _cast(value, schema_type):
373      if schema_type == "string":
374          if type(value) == type("") or type(value) == type(""):
375              return value
376          else:
377              return str(value)
378      elif schema_type == "integer":
379          return str(int(value))
380      elif schema_type == "number":
381          return str(float(value))
382      elif schema_type == "boolean":
383          return str(bool(value)).lower()
384      else:
385          if type(value) == type("") or type(value) == type(""):
386              return value
387          else:
388              return str(value)
389  def _media_size_to_long(maxSize):
390      if len(maxSize) < 2:
391          return 0
392      units = maxSize[-2:].upper()
393      bit_shift = _MEDIA_SIZE_BIT_SHIFTS.get(units)
394      if bit_shift is not None:
395          return int(maxSize[:-2]) << bit_shift
396      else:
397          return int(maxSize)
398  def _media_path_url_from_info(root_desc, path_url):
399      return "%(root)supload/%(service_path)s%(path)s" % {
400          "root": root_desc["rootUrl"],
401          "service_path": root_desc["servicePath"],
402          "path": path_url,
403      }
404  def _fix_up_parameters(method_desc, root_desc, http_method, schema):
405      parameters = method_desc.setdefault("parameters", {})
406      for name, description in root_desc.get("parameters", {}).items():
407          parameters[name] = description
408      for name in STACK_QUERY_PARAMETERS:
409          parameters[name] = STACK_QUERY_PARAMETER_DEFAULT_VALUE.copy()
410      if http_method in HTTP_PAYLOAD_METHODS and "request" in method_desc:
411          body = BODY_PARAMETER_DEFAULT_VALUE.copy()
412          body.update(method_desc["request"])
413          parameters["body"] = body
414      return parameters
415  def _fix_up_media_upload(method_desc, root_desc, path_url, parameters):
416      media_upload = method_desc.get("mediaUpload", {})
417      accept = media_upload.get("accept", [])
418      max_size = _media_size_to_long(media_upload.get("maxSize", ""))
419      media_path_url = None
420      if media_upload:
421          media_path_url = _media_path_url_from_info(root_desc, path_url)
422          parameters["media_body"] = MEDIA_BODY_PARAMETER_DEFAULT_VALUE.copy()
423          parameters["media_mime_type"] = MEDIA_MIME_TYPE_PARAMETER_DEFAULT_VALUE.copy()
424      return accept, max_size, media_path_url
425  def _fix_up_method_description(method_desc, root_desc, schema):
426      path_url = method_desc["path"]
427      http_method = method_desc["httpMethod"]
428      method_id = method_desc["id"]
429      parameters = _fix_up_parameters(method_desc, root_desc, http_method, schema)
430      accept, max_size, media_path_url = _fix_up_media_upload(
431          method_desc, root_desc, path_url, parameters
432      )
433      return path_url, http_method, method_id, accept, max_size, media_path_url
434  def _fix_up_media_path_base_url(media_path_url, base_url):
435      parsed_media_url = urllib.parse.urlparse(media_path_url)
436      parsed_base_url = urllib.parse.urlparse(base_url)
437      if parsed_media_url.netloc == parsed_base_url.netloc:
438          return media_path_url
439      return urllib.parse.urlunparse(
440          parsed_media_url._replace(netloc=parsed_base_url.netloc)
441      )
442  def _urljoin(base, url):
443      if url.startswith("http://") or url.startswith("https://"):
444          return urllib.parse.urljoin(base, url)
445      new_base = base if base.endswith("/") else base + "/"
446      new_url = url[1:] if url.startswith("/") else url
447      return new_base + new_url
448  class ResourceMethodParameters(object):
449      def __init__(self, method_desc):
450          self.argmap = {}
451          self.required_params = []
452          self.repeated_params = []
453          self.pattern_params = {}
454          self.query_params = []
455          self.path_params = set()
456          self.param_types = {}
457          self.enum_params = {}
458          self.set_parameters(method_desc)
459      def set_parameters(self, method_desc):
460          parameters = method_desc.get("parameters", {})
461          sorted_parameters = OrderedDict(sorted(parameters.items()))
462          for arg, desc in sorted_parameters.items():
463              param = key2param(arg)
464              self.argmap[param] = arg
465              if desc.get("pattern"):
466                  self.pattern_params[param] = desc["pattern"]
467              if desc.get("enum"):
468                  self.enum_params[param] = desc["enum"]
469              if desc.get("required"):
470                  self.required_params.append(param)
471              if desc.get("repeated"):
472                  self.repeated_params.append(param)
473              if desc.get("location") == "query":
474                  self.query_params.append(param)
475              if desc.get("location") == "path":
476                  self.path_params.add(param)
477              self.param_types[param] = desc.get("type", "string")
478          for match in URITEMPLATE.finditer(method_desc["path"]):
479              for namematch in VARNAME.finditer(match.group(0)):
480                  name = key2param(namematch.group(0))
481                  self.path_params.add(name)
482                  if name in self.query_params:
483                      self.query_params.remove(name)
484  def createMethod(methodName, methodDesc, rootDesc, schema):
485      methodName = fix_method_name(methodName)
486      (
487          pathUrl,
488          httpMethod,
489          methodId,
490          accept,
491          maxSize,
492          mediaPathUrl,
493      ) = _fix_up_method_description(methodDesc, rootDesc, schema)
494      parameters = ResourceMethodParameters(methodDesc)
495      def method(self, **kwargs):
496          for name in kwargs:
497              if name not in parameters.argmap:
498                  raise TypeError("Got an unexpected keyword argument {}".format(name))
499          keys = list(kwargs.keys())
500          for name in keys:
501              if kwargs[name] is None:
502                  del kwargs[name]
503          for name in parameters.required_params:
504              if name not in kwargs:
505                  if name not in _PAGE_TOKEN_NAMES or _findPageTokenName(
506                      _methodProperties(methodDesc, schema, "response")
507                  ):
508                      raise TypeError('Missing required parameter "%s"' % name)
509          for name, regex in parameters.pattern_params.items():
510              if name in kwargs:
511                  if isinstance(kwargs[name], str):
512                      pvalues = [kwargs[name]]
513                  else:
514                      pvalues = kwargs[name]
515                  for pvalue in pvalues:
516                      if re.match(regex, pvalue) is None:
517                          raise TypeError(
518                              'Parameter "%s" value "%s" does not match the pattern "%s"'
519                              % (name, pvalue, regex)
520                          )
521          for name, enums in parameters.enum_params.items():
522              if name in kwargs:
523                  if name in parameters.repeated_params and not isinstance(
524                      kwargs[name], str
525                  ):
526                      values = kwargs[name]
527                  else:
528                      values = [kwargs[name]]
529                  for value in values:
530                      if value not in enums:
531                          raise TypeError(
532                              'Parameter "%s" value "%s" is not an allowed value in "%s"'
533                              % (name, value, str(enums))
534                          )
535          actual_query_params = {}
536          actual_path_params = {}
537          for key, value in kwargs.items():
538              to_type = parameters.param_types.get(key, "string")
539              if key in parameters.repeated_params and type(value) == type([]):
540                  cast_value = [_cast(x, to_type) for x in value]
541              else:
542                  cast_value = _cast(value, to_type)
543              if key in parameters.query_params:
544                  actual_query_params[parameters.argmap[key]] = cast_value
545              if key in parameters.path_params:
546                  actual_path_params[parameters.argmap[key]] = cast_value
547          body_value = kwargs.get("body", None)
548          media_filename = kwargs.get("media_body", None)
549          media_mime_type = kwargs.get("media_mime_type", None)
550          if self._developerKey:
551              actual_query_params["key"] = self._developerKey
552          model = self._model
553          if methodName.endswith("_media"):
554              model = MediaModel()
555          elif "response" not in methodDesc:
556              model = RawModel()
557          headers = {}
558          headers, params, query, body = model.request(
559              headers, actual_path_params, actual_query_params, body_value
560          )
561          expanded_url = uritemplate.expand(pathUrl, params)
562          url = _urljoin(self._baseUrl, expanded_url + query)
563          resumable = None
564          multipart_boundary = ""
565          if media_filename:
566              if isinstance(media_filename, str):
567                  if media_mime_type is None:
568                      logger.warning(
569                          "media_mime_type argument not specified: trying to auto-detect for %s",
570                          media_filename,
571                      )
572                      media_mime_type, _ = mimetypes.guess_type(media_filename)
573                  if media_mime_type is None:
574                      raise UnknownFileType(media_filename)
575                  if not mimeparse.best_match([media_mime_type], ",".join(accept)):
576                      raise UnacceptableMimeTypeError(media_mime_type)
577                  media_upload = MediaFileUpload(media_filename, mimetype=media_mime_type)
578              elif isinstance(media_filename, MediaUpload):
579                  media_upload = media_filename
580              else:
581                  raise TypeError("media_filename must be str or MediaUpload.")
582              if media_upload.size() is not None and media_upload.size() > maxSize > 0:
583                  raise MediaUploadSizeError("Media larger than: %s" % maxSize)
584              expanded_url = uritemplate.expand(mediaPathUrl, params)
585              url = _urljoin(self._baseUrl, expanded_url + query)
586              url = _fix_up_media_path_base_url(url, self._baseUrl)
587              if media_upload.resumable():
588                  url = _add_query_parameter(url, "uploadType", "resumable")
589              if media_upload.resumable():
590                  resumable = media_upload
591              else:
592                  if body is None:
593                      headers["content-type"] = media_upload.mimetype()
594                      body = media_upload.getbytes(0, media_upload.size())
595                      url = _add_query_parameter(url, "uploadType", "media")
596                  else:
597                      msgRoot = MIMEMultipart("related")
598                      setattr(msgRoot, "_write_headers", lambda self: None)
599                      msg = MIMENonMultipart(*headers["content-type"].split("/"))
600                      msg.set_payload(body)
601                      msgRoot.attach(msg)
602                      msg = MIMENonMultipart(*media_upload.mimetype().split("/"))
603                      msg["Content-Transfer-Encoding"] = "binary"
604                      payload = media_upload.getbytes(0, media_upload.size())
605                      msg.set_payload(payload)
606                      msgRoot.attach(msg)
607                      fp = io.BytesIO()
608                      g = _BytesGenerator(fp, mangle_from_=False)
609                      g.flatten(msgRoot, unixfrom=False)
610                      body = fp.getvalue()
611                      multipart_boundary = msgRoot.get_boundary()
612                      headers["content-type"] = (
613                          "multipart/related; " 'boundary="%s"'
614                      ) % multipart_boundary
615                      url = _add_query_parameter(url, "uploadType", "multipart")
616          logger.debug("URL being requested: %s %s" % (httpMethod, url))
617          return self._requestBuilder(
618              self._http,
619              model.response,
620              url,
621              method=httpMethod,
622              body=body,
623              headers=headers,
624              methodId=methodId,
625              resumable=resumable,
626          )
627      docs = [methodDesc.get("description", DEFAULT_METHOD_DOC), "\n\n"]
628      if len(parameters.argmap) > 0:
629          docs.append("Args:\n")
630      skip_parameters = list(rootDesc.get("parameters", {}).keys())
631      skip_parameters.extend(STACK_QUERY_PARAMETERS)
632      all_args = list(parameters.argmap.keys())
633      args_ordered = [key2param(s) for s in methodDesc.get("parameterOrder", [])]
634      if "body" in all_args:
635          args_ordered.append("body")
636      for name in sorted(all_args):
637          if name not in args_ordered:
638              args_ordered.append(name)
639      for arg in args_ordered:
640          if arg in skip_parameters:
641              continue
642          repeated = ""
643          if arg in parameters.repeated_params:
644              repeated = " (repeated)"
645          required = ""
646          if arg in parameters.required_params:
647              required = " (required)"
648          paramdesc = methodDesc["parameters"][parameters.argmap[arg]]
649          paramdoc = paramdesc.get("description", "A parameter")
650          if "$ref" in paramdesc:
651              docs.append(
652                  ("  %s: object, %s%s%s\n    The object takes the form of:\n\n%s\n\n")
653                  % (
654                      arg,
655                      paramdoc,
656                      required,
657                      repeated,
658                      schema.prettyPrintByName(paramdesc["$ref"]),
659                  )
660              )
661          else:
662              paramtype = paramdesc.get("type", "string")
663              docs.append(
664                  "  %s: %s, %s%s%s\n" % (arg, paramtype, paramdoc, required, repeated)
665              )
666          enum = paramdesc.get("enum", [])
667          enumDesc = paramdesc.get("enumDescriptions", [])
668          if enum and enumDesc:
669              docs.append("    Allowed values\n")
670              for (name, desc) in zip(enum, enumDesc):
671                  docs.append("      %s - %s\n" % (name, desc))
672      if "response" in methodDesc:
673          if methodName.endswith("_media"):
674              docs.append("\nReturns:\n  The media object as a string.\n\n    ")
675          else:
676              docs.append("\nReturns:\n  An object of the form:\n\n    ")
677              docs.append(schema.prettyPrintSchema(methodDesc["response"]))
678      setattr(method, "__doc__", "".join(docs))
679      return (methodName, method)
680  def createNextMethod(
681      methodName,
682      pageTokenName="pageToken",
683      nextPageTokenName="nextPageToken",
684      isPageTokenParameter=True,
685  ):
686      methodName = fix_method_name(methodName)
687      def methodNext(self, previous_request, previous_response):
688          nextPageToken = previous_response.get(nextPageTokenName, None)
689          if not nextPageToken:
690              return None
691          request = copy.copy(previous_request)
692          if isPageTokenParameter:
693              request.uri = _add_query_parameter(
694                  request.uri, pageTokenName, nextPageToken
695              )
696              logger.debug("Next page request URL: %s %s" % (methodName, request.uri))
697          else:
698              model = self._model
699              body = model.deserialize(request.body)
700              body[pageTokenName] = nextPageToken
701              request.body = model.serialize(body)
702              request.body_size = len(request.body)
703              if "content-length" in request.headers:
704                  del request.headers["content-length"]
705              logger.debug("Next page request body: %s %s" % (methodName, body))
706          return request
707      return (methodName, methodNext)
708  class Resource(object):
709      def __init__(
710          self,
711          http,
712          baseUrl,
713          model,
714          requestBuilder,
715          developerKey,
716          resourceDesc,
717          rootDesc,
718          schema,
719      ):
720          self._dynamic_attrs = []
721          self._http = http
722          self._baseUrl = baseUrl
723          self._model = model
724          self._developerKey = developerKey
725          self._requestBuilder = requestBuilder
726          self._resourceDesc = resourceDesc
727          self._rootDesc = rootDesc
728          self._schema = schema
729          self._set_service_methods()
730      def _set_dynamic_attr(self, attr_name, value):
731          self._dynamic_attrs.append(attr_name)
732          self.__dict__[attr_name] = value
733      def __getstate__(self):
<span onclick='openModal()' class='match'>734          state_dict = copy.copy(self.__dict__)
735          for dynamic_attr in self._dynamic_attrs:
736              del state_dict[dynamic_attr]
</span>737          del state_dict["_dynamic_attrs"]
738          return state_dict
739      def __setstate__(self, state):
740          self.__dict__.update(state)
741          self._dynamic_attrs = []
742          self._set_service_methods()
743      def __enter__(self):
744          return self
745      def __exit__(self, exc_type, exc, exc_tb):
746          self.close()
747      def close(self):
748          self._http.close()
749      def _set_service_methods(self):
750          self._add_basic_methods(self._resourceDesc, self._rootDesc, self._schema)
751          self._add_nested_resources(self._resourceDesc, self._rootDesc, self._schema)
752          self._add_next_methods(self._resourceDesc, self._schema)
753      def _add_basic_methods(self, resourceDesc, rootDesc, schema):
754          if resourceDesc == rootDesc:
755              batch_uri = "%s%s" % (
756                  rootDesc["rootUrl"],
757                  rootDesc.get("batchPath", "batch"),
758              )
759              def new_batch_http_request(callback=None):
760                  return BatchHttpRequest(callback=callback, batch_uri=batch_uri)
761              self._set_dynamic_attr("new_batch_http_request", new_batch_http_request)
762          if "methods" in resourceDesc:
763              for methodName, methodDesc in resourceDesc["methods"].items():
764                  fixedMethodName, method = createMethod(
765                      methodName, methodDesc, rootDesc, schema
766                  )
767                  self._set_dynamic_attr(
768                      fixedMethodName, method.__get__(self, self.__class__)
769                  )
770                  if methodDesc.get("supportsMediaDownload", False):
771                      fixedMethodName, method = createMethod(
772                          methodName + "_media", methodDesc, rootDesc, schema
773                      )
774                      self._set_dynamic_attr(
775                          fixedMethodName, method.__get__(self, self.__class__)
776                      )
777      def _add_nested_resources(self, resourceDesc, rootDesc, schema):
778          if "resources" in resourceDesc:
779              def createResourceMethod(methodName, methodDesc):
780                  methodName = fix_method_name(methodName)
781                  def methodResource(self):
782                      return Resource(
783                          http=self._http,
784                          baseUrl=self._baseUrl,
785                          model=self._model,
786                          developerKey=self._developerKey,
787                          requestBuilder=self._requestBuilder,
788                          resourceDesc=methodDesc,
789                          rootDesc=rootDesc,
790                          schema=schema,
791                      )
792                  setattr(methodResource, "__doc__", "A collection resource.")
793                  setattr(methodResource, "__is_resource__", True)
794                  return (methodName, methodResource)
795              for methodName, methodDesc in resourceDesc["resources"].items():
796                  fixedMethodName, method = createResourceMethod(methodName, methodDesc)
797                  self._set_dynamic_attr(
798                      fixedMethodName, method.__get__(self, self.__class__)
799                  )
800      def _add_next_methods(self, resourceDesc, schema):
801          if "methods" not in resourceDesc:
802              return
803          for methodName, methodDesc in resourceDesc["methods"].items():
804              nextPageTokenName = _findPageTokenName(
805                  _methodProperties(methodDesc, schema, "response")
806              )
807              if not nextPageTokenName:
808                  continue
809              isPageTokenParameter = True
810              pageTokenName = _findPageTokenName(methodDesc.get("parameters", {}))
811              if not pageTokenName:
812                  isPageTokenParameter = False
813                  pageTokenName = _findPageTokenName(
814                      _methodProperties(methodDesc, schema, "request")
815                  )
816              if not pageTokenName:
817                  continue
818              fixedMethodName, method = createNextMethod(
819                  methodName + "_next",
820                  pageTokenName,
821                  nextPageTokenName,
822                  isPageTokenParameter,
823              )
824              self._set_dynamic_attr(
825                  fixedMethodName, method.__get__(self, self.__class__)
826              )
827  def _findPageTokenName(fields):
828      return next(
829          (tokenName for tokenName in _PAGE_TOKEN_NAMES if tokenName in fields), None
830      )
831  def _methodProperties(methodDesc, schema, name):
832      desc = methodDesc.get(name, {})
833      if "$ref" in desc:
834          desc = schema.get(desc["$ref"], {})
835      return desc.get("properties", {})
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esphome-docs-MDEwOlJlcG9zaXRvcnkxMzMyMjM0NjE=-flat-schema_doc.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from google-api-python-client-MDEwOlJlcG9zaXRvcnkxNTc0OTI2OQ==-flat-discovery.py</div>
                </div>
                <div class="column column_space"><pre><code>322                  desc = self.getMarkdownParagraph(node.parent)
323                  for c in self.multi_component:
324                      if len(c.split(".")) == 2:
</pre></code></div>
                <div class="column column_space"><pre><code>734          state_dict = copy.copy(self.__dict__)
735          for dynamic_attr in self._dynamic_attrs:
736              del state_dict[dynamic_attr]
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    