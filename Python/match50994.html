<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pillar_1.py &amp; test_file_selinux.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pillar_1.py &amp; test_file_selinux.py
      </h3>
<h1 align="center">
        5.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pillar_1.py (4.0229883%)<th>test_file_selinux.py (9.722222%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(5-20)<td><a href="#" name="0">(1-16)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pillar_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
import logging
import os
from collections.abc import Mapping
import salt.pillar
import salt.utils.crypt
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.functools
import salt.utils.odict
import salt.utils.yaml
from salt.defaults import DEFAULT_TARGET_DELIM
from salt.exceptions import CommandExecutionError
__proxyenabled__ =</b></font> ["*"]
log = logging.getLogger(__name__)
def get(
    key,
    default=None,
    merge=False,
    merge_nested_lists=None,
    delimiter=DEFAULT_TARGET_DELIM,
    pillarenv=None,
    saltenv=None,
):
    if default is None:
        default = KeyError
    if not __opts__.get("pillar_raise_on_missing"):
        if default is KeyError:
            default = ""
    opt_merge_lists = (
        __opts__.get("pillar_merge_lists", False)
        if merge_nested_lists is None
        else merge_nested_lists
    )
    pillar_dict = (
        __pillar__
        if all(x is None for x in (saltenv, pillarenv))
        else items(saltenv=saltenv, pillarenv=pillarenv)
    )
    if merge:
        if isinstance(default, dict):
            ret = salt.utils.data.traverse_dict_and_list(
                pillar_dict, key, {}, delimiter
            )
            if isinstance(ret, Mapping):
                default = copy.deepcopy(default)
                return salt.utils.dictupdate.update(
                    default, ret, merge_lists=opt_merge_lists
                )
            else:
                log.error(
                    "pillar.get: Default (%s) is a dict, but the returned "
                    "pillar value (%s) is of type '%s'. Merge will be "
                    "skipped.",
                    default,
                    ret,
                    type(ret).__name__,
                )
        elif isinstance(default, list):
            ret = salt.utils.data.traverse_dict_and_list(
                pillar_dict, key, [], delimiter
            )
            if isinstance(ret, list):
                default = copy.deepcopy(default)
                default.extend([x for x in ret if x not in default])
                return default
            else:
                log.error(
                    "pillar.get: Default (%s) is a list, but the returned "
                    "pillar value (%s) is of type '%s'. Merge will be "
                    "skipped.",
                    default,
                    ret,
                    type(ret).__name__,
                )
        else:
            log.error(
                "pillar.get: Default (%s) is of type '%s', must be a dict "
                "or list to merge. Merge will be skipped.",
                default,
                type(default).__name__,
            )
    ret = salt.utils.data.traverse_dict_and_list(pillar_dict, key, default, delimiter)
    if ret is KeyError:
        raise KeyError("Pillar key not found: {}".format(key))
    return ret
def items(*args, **kwargs):
    if args:
        return item(*args)
    pillarenv = kwargs.get("pillarenv")
    if pillarenv is None:
        if __opts__.get("pillarenv_from_saltenv", False):
            pillarenv = kwargs.get("saltenv") or __opts__["saltenv"]
        else:
            pillarenv = __opts__["pillarenv"]
    pillar_override = kwargs.get("pillar")
    pillar_enc = kwargs.get("pillar_enc")
    if pillar_override and pillar_enc:
        try:
            pillar_override = salt.utils.crypt.decrypt(
                pillar_override,
                pillar_enc,
                translate_newlines=True,
                opts=__opts__,
                valid_rend=__opts__["decrypt_pillar_renderers"],
            )
        except Exception as exc:  # pylint: disable=broad-except
            raise CommandExecutionError(
                "Failed to decrypt pillar override: {}".format(exc)
            )
    pillar = salt.pillar.get_pillar(
        __opts__,
        dict(__grains__),
        __opts__["id"],
        pillar_override=pillar_override,
        pillarenv=pillarenv,
    )
    return pillar.compile_pillar()
data = salt.utils.functools.alias_function(items, "data")
def _obfuscate_inner(var):
    if isinstance(var, (dict, salt.utils.odict.OrderedDict)):
        return var.__class__((key, _obfuscate_inner(val)) for key, val in var.items())
    elif isinstance(var, (list, set, tuple)):
        return type(var)(_obfuscate_inner(v) for v in var)
    else:
        return "&lt;{}&gt;".format(var.__class__.__name__)
def obfuscate(*args):
    return _obfuscate_inner(items(*args))
def ls(*args):
    return list(items(*args))
def item(*args, **kwargs):
    ret = {}
    default = kwargs.get("default", "")
    delimiter = kwargs.get("delimiter", DEFAULT_TARGET_DELIM)
    pillarenv = kwargs.get("pillarenv", None)
    saltenv = kwargs.get("saltenv", None)
    pillar_dict = (
        __pillar__
        if all(x is None for x in (saltenv, pillarenv))
        else items(saltenv=saltenv, pillarenv=pillarenv)
    )
    try:
        for arg in args:
            ret[arg] = salt.utils.data.traverse_dict_and_list(
                pillar_dict, arg, default, delimiter
            )
    except KeyError:
        pass
    return ret
def raw(key=None):
    if key:
        ret = __pillar__.get(key, {})
    else:
        ret = dict(__pillar__)
    return ret
def ext(external, pillar=None):
    if isinstance(external, str):
        external = salt.utils.yaml.safe_load(external)
    pillar_obj = salt.pillar.get_pillar(
        __opts__,
        __grains__.value(),
        __opts__["id"],
        __opts__["saltenv"],
        ext=external,
        pillar_override=pillar,
    )
    ret = pillar_obj.compile_pillar()
    return ret
def keys(key, delimiter=DEFAULT_TARGET_DELIM):
    ret = salt.utils.data.traverse_dict_and_list(__pillar__, key, KeyError, delimiter)
    if ret is KeyError:
        raise KeyError("Pillar key not found: {}".format(key))
    if not isinstance(ret, dict):
        raise ValueError("Pillar value in key {} is not a dict".format(key))
    return list(ret)
def file_exists(path, saltenv=None):
    pillar_roots = __opts__.get("pillar_roots")
    if not pillar_roots:
        raise CommandExecutionError(
            "No pillar_roots found. Are you running this on the master?"
        )
    if saltenv:
        if saltenv in pillar_roots:
            pillar_roots = {saltenv: pillar_roots[saltenv]}
        else:
            return False
    for env in pillar_roots:
        for pillar_dir in pillar_roots[env]:
            full_path = os.path.join(pillar_dir, path)
            if __salt__["file.file_exists"](full_path):
                return True
    return False
fetch = get
def filter_by(lookup_dict, pillar, merge=None, default="default", base=None):
    return salt.utils.data.filter_by(
        lookup_dict=lookup_dict,
        lookup=pillar,
        traverse=__pillar__,
        merge=merge,
        default=default,
        base=base,
    )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_selinux.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
import os
import shutil
import pytest
import salt.config
import salt.loader
import salt.modules.cmdmod as cmdmod
import salt.modules.file as filemod
import salt.utils.data
import salt.utils.files
import salt.utils.platform
import salt.utils.stringutils
from tests.support.mock import MagicMock, patch
log =</b></font> logging.getLogger(__name__)
pytestmark = pytest.mark.skipif(
    salt.modules.selinux.getenforce() != "Enforcing",
    reason="Skip if selinux not enabled",
)
@pytest.fixture
def configure_loader_modules():
    return {
        filemod: {
            "__salt__": {
                "cmd.run": cmdmod.run,
                "cmd.run_all": cmdmod.run_all,
                "cmd.retcode": cmdmod.retcode,
                "selinux.fcontext_add_policy": MagicMock(
                    return_value={"retcode": 0, "stdout": ""}
                ),
            },
            "__opts__": {"test": False},
        }
    }
@pytest.fixture
def subdir(tmp_path):
    subdir = tmp_path / "file-selinux-test-dir"
    subdir.mkdir()
    yield subdir
    shutil.rmtree(str(subdir))
@pytest.fixture
def tfile1(subdir):
    filename = str(subdir / "tfile1")
    with salt.utils.files.fopen(filename, "w+"):
        pass
    yield filename
    os.remove(filename)
@pytest.fixture
def tfile2(subdir):
    filename = str(subdir / "tfile2")
    with salt.utils.files.fopen(filename, "w+"):
        pass
    yield filename
    os.remove(filename)
@pytest.fixture
def tfile3(subdir):
    filename = str(subdir / "tfile3")
    with salt.utils.files.fopen(filename, "w+"):
        pass
    yield filename
    os.remove(filename)
def test_selinux_getcontext(tfile1):
    result = filemod.get_selinux_context(tfile1)
    assert result == "unconfined_u:object_r:user_tmp_t:s0"
def test_selinux_setcontext(tfile2):
    result = filemod.set_selinux_context(tfile2, user="system_u")
    assert result == "system_u:object_r:user_tmp_t:s0"
def test_selinux_setcontext_persist(tfile2):
    result = filemod.set_selinux_context(tfile2, user="system_u", persist=True)
    assert result == "system_u:object_r:user_tmp_t:s0"
def test_file_check_perms(tfile3):
    expected_result = (
        {
            "comment": "The file {} is set to be changed".format(tfile3),
            "changes": {
                "selinux": {"New": "Type: lost_found_t", "Old": "Type: user_tmp_t"},
                "mode": "0664",
            },
            "name": tfile3,
            "result": True,
        },
        {"luser": "root", "lmode": "0644", "lgroup": "root"},
    )
    with patch("salt.utils.path.which") as m_which:
        m_which.return_value = None
        result = filemod.check_perms(
            tfile3,
            {},
            "root",
            "root",
            664,
            seuser=None,
            serole=None,
            setype="lost_found_t",
            serange=None,
        )
        assert result == expected_result
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
