<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_deb_apache.py &amp; test_iptables_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_deb_apache.py &amp; test_iptables_1.py
      </h3>
<h1 align="center">
        15.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_deb_apache.py (20.46332%)<th>test_iptables_1.py (12.83293%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(285-289)<td><a href="#" name="0">(681-685)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(41-52)<td><a href="#" name="1">(21-31)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(372-376)<td><a href="#" name="2">(634-638)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(356-360)<td><a href="#" name="3">(546-559)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(340-344)<td><a href="#" name="4">(523-536)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(317-321)<td><a href="#" name="5">(506-513)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(301-305)<td><a href="#" name="6">(385-393)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(64-67)<td><a href="#" name="7">(662-665)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_deb_apache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.modules.deb_apache as deb_apache
2 from tests.support.mixins import LoaderModuleMockMixin
3 from tests.support.mock import MagicMock, patch
4 from tests.support.unit import TestCase
5 class DebApacheTestCase(TestCase, LoaderModuleMockMixin):
6     def setup_loader_modules(self):
7         return {deb_apache: {}}
8     def test_check_site_enabled(self):
9         with patch("os.path.islink", MagicMock(return_value=True)):
10             self.assertTrue(deb_apache.check_site_enabled("saltstack.com"))
11     def test_check_site_enabled_default(self):
12         with patch("os.path.islink", MagicMock(side_effect=[False, True])):
13             self.assertTrue(deb_apache.check_site_enabled("default"))
14     def test_check_site_enabled_false(self):
15         with patch("os.path.islink", MagicMock(return_value=False)):
16             self.assertFalse(deb_apache.check_site_enabled("<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>saltstack.com"))
17     def test_a2ensite_notfound(self):
18         mock = MagicMock(return_value=1)
19         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
20             self.assertEqual(
21                 deb_apache.a2ensite(</b></font>"saltstack.com"),
22                 {
23                     "Name": "Apache2 Enable Site",
24                     "Site": "saltstack.com",
25                     "Status": "Site saltstack.com Not found",
26                 },
27             )
28     def test_a2ensite_enabled(self):
29         Test if it runs a2ensite for the given site.
30         """
31         mock <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=0)
32         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
33             self.assertEqual(
34                 deb_apache.a2ensite(</b></font>"saltstack.com"),
35                 {
36                     "Name": "Apache2 Enable Site",
37                     "Site": "saltstack.com",
38                     "Status": "Site saltstack.com enabled",
39                 },
40             )
41     def test_a2ensite(self):
42         """
43         Test if it runs a2ensite for the given site.
44         """
45         mock = MagicMock(return_value=2)
46         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
47             self.assertEqual(
48                 deb_apache.a2ensite("saltstack.com"),
49                 {"Name": "Apache2 Enable Site", "Site": "saltstack.com", "Status": 2},
50             )
51     def test_a2ensite_exception(self):
52         """
53         Test if it runs a2ensite for the given site.
54         """
55         mock = MagicMock(side_effect=Exception("error"))
56         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
57             self.assertEqual(str(deb_apache.a2ensite("saltstack.com")), "error")
58     def test_a2dissite_notfound(self):
59         """
60         Test if it runs a2dissite for the given site.
61         """
62         mock = MagicMock(return_value=256)
63         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
64             self.assertEqual(
65                 deb_apache.a2dissite("saltstack.com"),
66                 {
67                     "Name": "Apache2 Disable Site",
68                     "Site": "saltstack.com",
69                     "Status": "Site saltstack.com Not found",
70                 },
71             )
72     def test_a2dissite_disabled(self):
73         """
74         Test if it runs a2dissite for the given site.
75         """
76         mock = MagicMock(return_value=0)
77         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
78             self.assertEqual(
79                 deb_apache.a2dissite("saltstack.com"),
80                 {
81                     "Name": "Apache2 Disable Site",
82                     "Site": "saltstack.com",
83                     "Status": "Site saltstack.com disabled",
84                 },
85             )
86     def test_a2dissite(self):
87         """
88         Test if it runs a2dissite for the given site.
89         """
90         mock = MagicMock(return_value=2)
91         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
92             self.assertEqual(
93                 deb_apache.a2dissite("saltstack.com"),
94                 {"Name": "Apache2 Disable Site", "Site": "saltstack.com", "Status": 2},
95             )
96     def test_a2dissite_exception(self):
97         """
98         Test if it runs a2dissite for the given site.
99         """
100         mock = MagicMock(side_effect=Exception("error"))
101         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
102             self.assertEqual(str(deb_apache.a2dissite("saltstack.com")), "error")
103     def test_check_mod_enabled(self):
104         """
105         Test if the specific mod symlink is enabled.
106         """
107         with patch("os.path.islink", MagicMock(return_value=True)):
108             self.assertTrue(deb_apache.check_mod_enabled("status.conf"))
109     def test_check_mod_enabled_false(self):
110         """
111         Test if the specific mod symlink is enabled.
112         """
113         with patch("os.path.islink", MagicMock(return_value=False)):
114             self.assertFalse(deb_apache.check_mod_enabled("status.conf"))
115     def test_a2enmod_notfound(self):
116         """
117         Test if it runs a2enmod for the given module.
118         """
119         mock = MagicMock(return_value=1)
120         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
121             self.assertEqual(
122                 deb_apache.a2enmod("vhost_alias"),
123                 {
124                     "Name": "Apache2 Enable Mod",
125                     "Mod": "vhost_alias",
126                     "Status": "Mod vhost_alias Not found",
127                 },
128             )
129     def test_a2enmod_enabled(self):
130         """
131         Test if it runs a2enmod for the given module.
132         """
133         mock = MagicMock(return_value=0)
134         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
135             self.assertEqual(
136                 deb_apache.a2enmod("vhost_alias"),
137                 {
138                     "Name": "Apache2 Enable Mod",
139                     "Mod": "vhost_alias",
140                     "Status": "Mod vhost_alias enabled",
141                 },
142             )
143     def test_a2enmod(self):
144         """
145         Test if it runs a2enmod for the given module.
146         """
147         mock = MagicMock(return_value=2)
148         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
149             self.assertEqual(
150                 deb_apache.a2enmod("vhost_alias"),
151                 {"Name": "Apache2 Enable Mod", "Mod": "vhost_alias", "Status": 2},
152             )
153     def test_a2enmod_exception(self):
154         """
155         Test if it runs a2enmod for the given module.
156         """
157         mock = MagicMock(side_effect=Exception("error"))
158         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
159             self.assertEqual(str(deb_apache.a2enmod("vhost_alias")), "error")
160     def test_a2dismod_notfound(self):
161         """
162         Test if it runs a2dismod for the given module.
163         """
164         mock = MagicMock(return_value=256)
165         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
166             self.assertEqual(
167                 deb_apache.a2dismod("vhost_alias"),
168                 {
169                     "Name": "Apache2 Disable Mod",
170                     "Mod": "vhost_alias",
171                     "Status": "Mod vhost_alias Not found",
172                 },
173             )
174     def test_a2dismod_disabled(self):
175         """
176         Test if it runs a2dismod for the given module.
177         """
178         mock = MagicMock(return_value=0)
179         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
180             self.assertEqual(
181                 deb_apache.a2dismod("vhost_alias"),
182                 {
183                     "Name": "Apache2 Disable Mod",
184                     "Mod": "vhost_alias",
185                     "Status": "Mod vhost_alias disabled",
186                 },
187             )
188     def test_a2dismod(self):
189         """
190         Test if it runs a2dismod for the given module.
191         """
192         mock = MagicMock(return_value=2)
193         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
194             self.assertEqual(
195                 deb_apache.a2dismod("vhost_alias"),
196                 {"Name": "Apache2 Disable Mod", "Mod": "vhost_alias", "Status": 2},
197             )
198     def test_a2dismod_exception(self):
199         """
200         Test if it runs a2dismod for the given module.
201         """
202         mock = MagicMock(side_effect=Exception("error"))
203         with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
204             self.assertEqual(str(deb_apache.a2dismod("vhost_alias")), "error")
205     def test_check_conf_enabled(self):
206         """
207         Test if the specific conf symlink is enabled.
208         """
209         with patch("os.path.islink", MagicMock(return_value=True)):
210             self.assertTrue(deb_apache.check_conf_enabled("security.conf"))
211     def test_check_conf_enabled_false(self):
212         """
213         Test if the specific conf symlink is enabled.
214         """
215         with patch("os.path.islink", MagicMock(return_value=False)):
216             self.assertFalse(deb_apache.check_conf_enabled("security.conf"))
217     def test_a2enconf_notfound(self):
218         Test if it runs a2enconf for the given conf.
219         """
220         with patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("salt.utils.path.which", MagicMock(return_value="a2enconf")):
221             mock = MagicMock(return_value=1)
222             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
223                 self.assertEqual(
224                     deb_apache.a2enconf(</b></font>"security"),
225                     {
226                         "Name": "Apache2 Enable Conf",
227                         "Conf": "security",
228                         "Status": "Conf security Not found",
229                     },
230                 )
231     def test_a2enconf_enabled(self):
232         Test if it runs a2enconf for the given conf.
233         """
234         with patch("salt.utils.path.which", MagicMock(return_value<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2enconf")):
235             mock = MagicMock(return_value=0)
236             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
237                 self.assertEqual(
238                     deb_apache.a2enconf(</b></font>"security"),
239                     {
240                         "Name": "Apache2 Enable Conf",
241                         "Conf": "security",
242                         "Status": "Conf security enabled",
243                     },
244                 )
245     def test_a2enconf(self):
246         Test if it runs a2enconf for the given conf.
247         """
248         with patch("salt.utils.path.which", MagicMock(return_value<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2enconf")):
249             mock = MagicMock(return_value=2)
250             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
251                 self.assertEqual(
252                     deb_apache.a2enconf(</b></font>"security"),
253                     {"Name": "Apache2 Enable Conf", "Conf": "security", "Status": 2},
254                 )
255     def test_a2enconf_exception(self):
256         """
257         Test if it runs a2enconf for the given conf.
258         """
259         with patch("salt.utils.path.which", MagicMock(return_value="a2enconf")):
260             mock = MagicMock(side_effect=Exception("error"))
261             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
262                 self.assertEqual(str(deb_apache.a2enconf("security")), "error")
263     def test_a2disconf_notfound(self):
264         Test if it runs a2disconf for the given conf.
265         """
266         with patch("salt.utils.path.which", MagicMock(return_value<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2disconf")):
267             mock = MagicMock(return_value=256)
268             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
269                 self.assertEqual(
270                     deb_apache.a2disconf(</b></font>"security"),
271                     {
272                         "Name": "Apache2 Disable Conf",
273                         "Conf": "security",
274                         "Status": "Conf security Not found",
275                     },
276                 )
277     def test_a2disconf_disabled(self):
278         Test if it runs a2disconf for the given conf.
279         """
280         with patch("salt.utils.path.which", MagicMock(return_value<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2disconf")):
281             mock = MagicMock(return_value=0)
282             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
283                 self.assertEqual(
284                     deb_apache.a2disconf(</b></font>"security"),
285                     {
286                         "Name": "Apache2 Disable Conf",
287                         "Conf": "security",
288                         "Status": "Conf security disabled",
289                     },
290                 )
291     def test_a2disconf(self):
292         Test if it runs a2disconf for the given conf.
293         """
294         with patch("salt.utils.path.which", MagicMock(return_value<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2disconf")):
295             mock = MagicMock(return_value=2)
296             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
297                 self.assertEqual(
298                     deb_apache.a2disconf(</b></font>"security"),
299                     {"Name": "Apache2 Disable Conf", "Conf": "security", "Status": 2},
300                 )
301     def test_a2disconf_exception(self):
302         """
303         Test if it runs a2disconf for the given conf.
304         """
305         with patch("salt.utils.path.which", MagicMock(return_value="a2disconf")):
306             mock = MagicMock(side_effect=Exception("error"))
307             with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
308                 self.assertEqual(str(deb_apache.a2disconf("security")), "error")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_iptables_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2     :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
3 """
4 import textwrap
5 import uuid
6 import salt.modules.iptables as iptables
7 from tests.support.mixins import LoaderModuleMockMixin
8 from tests.support.mock import MagicMock, mock_open, patch
9 from tests.support.unit import TestCase
10 class IptablesTestCase(TestCase, LoaderModuleMockMixin):
11     """
12     Test cases for salt.modules.iptables
13     def setup_loader_modules(self):
14         return {i<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ptables: {}}
15     def test_version(self):
16         """
17         Test if it return version from iptables --version
18         """
19         mock = MagicMock(return_value="iptables v1.4.21")
20         with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock}):
21             self.assertEqual(iptables.version(</b></font>), "v1.4.21")
22     def test_build_rule(self):
23         """
24         Test if it build a well-formatted iptables rule based on kwargs.
25         """
26         with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
27             self.assertEqual(iptables.build_rule(), "")
28             self.assertEqual(
29                 iptables.build_rule(name="ignored", state="ignored"),
30                 "",
31                 "build_rule should ignore name and state",
32             )
33             self.assertEqual(iptables.build_rule(**{"if": "!eth0"}), "! -i eth0")
34             self.assertEqual(iptables.build_rule(**{"if": "not eth0"}), "! -i eth0")
35             self.assertEqual(
36                 iptables.build_rule(**{"protocol": "tcp", "syn": "!"}), "-p tcp ! --syn"
37             )
38             self.assertEqual(
39                 iptables.build_rule(dports=[80, 443], protocol="tcp"),
40                 "-p tcp -m multiport --dports 80,443",
41             )
42             self.assertEqual(
43                 iptables.build_rule(dports="80,443", protocol="tcp"),
44                 "-p tcp -m multiport --dports 80,443",
45             )
46             self.assertEqual(
47                 iptables.build_rule(dports=["!80", 443], protocol="tcp"),
48                 "-p tcp -m multiport ! --dports 80,443",
49             )
50             self.assertEqual(
51                 iptables.build_rule(dports="!80,443", protocol="tcp"),
52                 "-p tcp -m multiport ! --dports 80,443",
53             )
54             self.assertEqual(
55                 iptables.build_rule(sports=[80, 443], protocol="tcp"),
56                 "-p tcp -m multiport --sports 80,443",
57             )
58             self.assertEqual(
59                 iptables.build_rule(sports="80,443", protocol="tcp"),
60                 "-p tcp -m multiport --sports 80,443",
61             )
62             self.assertEqual(
63                 iptables.build_rule(
64                     "filter",
65                     "INPUT",
66                     command="I",
67                     position="3",
68                     full=True,
69                     dports="protocol",
70                     jump="ACCEPT",
71                 ),
72                 "Error: protocol must be specified",
73             )
74             self.assertEqual(
75                 iptables.build_rule(
76                     "filter",
77                     "INPUT",
78                     command="I",
79                     position="3",
80                     full=True,
81                     sports="protocol",
82                     jump="ACCEPT",
83                 ),
84                 "Error: protocol must be specified",
85             )
86             self.assertEqual(
87                 iptables.build_rule(
88                     "",
89                     "INPUT",
90                     command="I",
91                     position="3",
92                     full="True",
93                     match="state",
94                     jump="ACCEPT",
95                 ),
96                 "Error: Table needs to be specified",
97             )
98             self.assertEqual(
99                 iptables.build_rule(
100                     "filter",
101                     "",
102                     command="I",
103                     position="3",
104                     full="True",
105                     match="state",
106                     jump="ACCEPT",
107                 ),
108                 "Error: Chain needs to be specified",
109             )
110             self.assertEqual(
111                 iptables.build_rule(
112                     "filter",
113                     "INPUT",
114                     command="",
115                     position="3",
116                     full="True",
117                     match="state",
118                     jump="ACCEPT",
119                 ),
120                 "Error: Command needs to be specified",
121             )
122             self.assertEqual(
123                 iptables.build_rule(jump="REDIRECT", **{"to-port": 8080}),
124                 "--jump REDIRECT --to-port 8080",
125             )
126             self.assertEqual(
127                 iptables.build_rule(jump="LOG", **{"log-prefix": "long prefix"}),
128                 '--jump LOG --log-prefix "long prefix"',
129             )
130             self.assertEqual(
131                 iptables.build_rule(jump="LOG", **{"log-prefix": "spam: "}),
132                 '--jump LOG --log-prefix "spam: "',
133             )
134             self.assertEqual(
135                 iptables.build_rule(jump="CLUSTERIP", **{"new": ""}),
136                 "--jump CLUSTERIP --new",
137             )
138             self.assertEqual(
139                 iptables.build_rule(jump="CT", **{"notrack": None}),
140                 "--jump CT --notrack",
141             )
142             self.assertEqual(
143                 iptables.build_rule(**{"match-set": "src flag1,flag2"}),
144                 "-m set --match-set src flag1,flag2",
145             )
146             match_sets = [
147                 "src1 flag1",
148                 "src2 flag2,flag3",
149             ]
150             self.assertEqual(
151                 iptables.build_rule(**{"match-set": match_sets}),
152                 "-m set --match-set src1 flag1 -m set --match-set src2 flag2,flag3",
153             )
154             self.assertEqual(
155                 iptables.build_rule(**{"match-set": "!src flag"}),
156                 "-m set ! --match-set src flag",
157             )
158             match_sets = ["src1 flag", "not src2 flag2"]
159             self.assertEqual(
160                 iptables.build_rule(**{"match-set": match_sets}),
161                 "-m set --match-set src1 flag -m set ! --match-set src2 flag2",
162             )
163             self.assertEqual(
164                 iptables.build_rule(**{"match": "recent", "name_": "SSH"}),
165                 "-m recent --name SSH",
166             )
167             self.assertEqual(
168                 iptables.build_rule(**{"match": "recent", "update": None}),
169                 "-m recent --update",
170             )
171             ret = "/sbin/iptables --wait -t salt -I INPUT 3 -m state --jump ACCEPT"
172             with patch.object(
173                 iptables, "_iptables_cmd", MagicMock(return_value="/sbin/iptables")
174             ):
175                 self.assertEqual(
176                     iptables.build_rule(
177                         "salt",
178                         "INPUT",
179                         command="I",
180                         position="3",
181                         full="True",
182                         match="state",
183                         jump="ACCEPT",
184                     ),
185                     ret,
186                 )
187     def test_get_saved_rules(self):
188         """
189         Test if it return a data structure of the rules in the conf file
190         """
191         mock = MagicMock(return_value=False)
192         with patch.object(iptables, "_parse_conf", mock):
193             self.assertFalse(iptables.get_saved_rules())
194             mock.assert_called_with(conf_file=None, family="ipv4")
195     def test_get_saved_rules_nilinuxrt(self):
196         """
197         Test get rules on NILinuxRT system
198         """
199         data = {
200             "/etc/natinst/share/iptables.conf": textwrap.dedent(
201                 """\
202                 *filter
203                 :INPUT ACCEPT [2958:584773]
204                 :FORWARD ACCEPT [0:0]
205                 :OUTPUT ACCEPT [92:23648]
206                 -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
207                 COMMIT
208                 """
209             )
210         }
211         expected_input_rules = [
212             {
213                 "protocol": ["tcp"],
214                 "jump": ["ACCEPT"],
215                 "match": ["tcp"],
216                 "destination_port": ["80"],
217             }
218         ]
219         file_mock = mock_open(read_data=data)
220         with patch.dict(
221             iptables.__grains__, {"os_family": "NILinuxRT", "os": "NILinuxRT"}
222         ):
223             with patch.object(iptables.salt.utils.files, "fopen", file_mock):
224                 rules = iptables.get_saved_rules()
225                 self.assertEqual(
226                     expected_input_rules, rules["filter"]["INPUT"]["rules"]
227                 )
228     def test_get_rules(self):
229         """
230         Test if it return a data structure of the current, in-memory rules
231         """
232         mock = MagicMock(return_value=False)
233         with patch.object(iptables, "_parse_conf", mock):
234             self.assertFalse(iptables.get_rules())
235             mock.assert_called_with(in_mem=True, family="ipv4")
236     def test_get_saved_policy(self):
237         """
238         Test if it return the current policy for the specified table/chain
239         """
240         self.assertEqual(
241             iptables.get_saved_policy(
242                 table="filter", chain=None, conf_file=None, family="ipv4"
243             ),
244             "Error: Chain needs to be specified",
245         )
246         with patch.object(
247             iptables,
248             "_parse_conf",
249             MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
250         ):
251             self.assertTrue(
252                 iptables.get_saved_policy(
253                     table="filter", chain="INPUT", conf_file=None, family="ipv4"
254                 )
255             )
256         with patch.object(
257             iptables,
258             "_parse_conf",
259             MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
260         ):
261             self.assertIsNone(
262                 iptables.get_saved_policy(
263                     table="filter", chain="INPUT", conf_file=None, family="ipv4"
264                 )
265             )
266     def test_get_policy(self):
267         """
268         Test if it return the current policy for the specified table/chain
269         """
270         self.assertEqual(
271             iptables.get_policy(table="filter", chain=None, family="ipv4"),
272             "Error: Chain needs to be specified",
273         )
274         with patch.object(
275             iptables,
276             "_parse_conf",
277             MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
278         ):
279             self.assertTrue(
280                 iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
281             )
282         with patch.object(
283             iptables,
284             "_parse_conf",
285             MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
286         ):
287             self.assertIsNone(
288                 iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
289             )
290     def test_set_policy(self):
291         """
292         Test if it set the current policy for the specified table/chain
293         """
294         with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
295             self.assertEqual(
296                 iptables.set_policy(
297                     table="filter", chain=None, policy=None, family="ipv4"
298                 ),
299                 "Error: Chain needs to be specified",
300             )
301             self.assertEqual(
302                 iptables.set_policy(
303                     table="filter", chain="INPUT", policy=None, family<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"
304                 ),
305                 "Error: Policy needs to be specified",
306             )
307             mock = MagicMock(return_value=True)
308             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
309                 self.assertTrue(
310                     iptables.set_policy(</b></font>
311                         table="filter", chain="INPUT", policy="ACCEPT", family="ipv4"
312                     )
313                 )
314     def test_save(self):
315         """
316         Test if it save the current in-memory rules to disk
317         """
318         with patch("salt.modules.iptables._conf", MagicMock(return_value=False)), patch(
319             "os.path.isdir", MagicMock(return_value=True)
320         ):
321             mock = MagicMock(return_value=True)
322             with patch.dict(
323                 iptables.__salt__,
324                 {
325                     "cmd.run_stdout": mock,
326                     "file.write": mock,
327                     "config.option": MagicMock(return_value=[]),
328                 },
329             ):
330                 self.assertTrue(iptables.save(filename="/xyz", family="ipv4"))
331     def test_check(self):
332         """
333         Test if it check for the existence of a rule in the table and chain
334         """
335         self.assertEqual(
336             iptables.check(table="filter", chain=None, rule=None, family="ipv4"),
337             "Error: Chain needs to be specified",
338         )
339         self.assertEqual(
340             iptables.check(table="filter", chain="INPUT", rule=None, family="ipv4"),
341             "Error: Rule needs to be specified",
342         )
343         mock_rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
344         mock_chain = "INPUT"
345         mock_uuid = 31337
346         mock_cmd_rule = MagicMock(
347             return_value="-A {}\n-A {}".format(mock_chain, hex(mock_uuid))
348         )
349         mock_cmd_nooutput = MagicMock(return_value="")
350         mock_has = MagicMock(return_value=True)
351         mock_not = MagicMock(return_value=False)
352         with patch.object(iptables, "_has_option", mock_not):
353             with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
354                 with patch.dict(
355                     iptables.__salt__,
356                     {"cmd.run_stdout": mock_cmd_rule, "cmd.run": mock_cmd_nooutput},
357                 ):
358                     self.assertTrue(
359                         iptables.check(
360                             table="filter",
361                             chain=mock_chain,
362                             rule=mock_rule,
363                             family="ipv4",
364                         )
365                     )
366         mock_cmd = MagicMock(return_value="")
367         with patch.object(iptables, "_has_option", mock_not):
368             with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
369                 with patch.dict(
370                     iptables.__salt__,
371                     {
372                         "cmd.run_stdout": mock_cmd_nooutput,
373                         "cmd.run": mock_cmd_nooutput,
374                     },
375                 ):
376                     self.assertFalse(
377                         iptables.check(
378                             table="filter",
379                             chain=mock_chain,
380                             rule=mock_rule,
381                             family="ipv4",
382                         )
383                     )
384         with patch.object(iptables, "_has_option", mock_has):
385             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
386                 self.assertTrue(
387                     iptables.check(
388                         table="filter", chain="INPUT", rule=mock_rule, family="ipv4"
389                     )
390                 )
391         mock_cmd = MagicMock(return_value="-A 0x4d2")
392         mock_uuid = MagicMock(return_value=1234)
393         with patch.object(iptables, "_has_option", mock_has):
394             with patch.object(uuid, "getnode", mock_uuid):
395                 with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
396                     self.assertTrue(
397                         iptables.check(
398                             table="filter", chain="0x4d2", rule=mock_rule, family="ipv4"
399                         )
400                     )
401     def test_check_chain(self):
402         """
403         """
404         self.assertEqual(
405             iptables.check_chain(table="filter", chain=None, family<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"),
406             "Error: Chain needs to be specified",
407         )
408         mock_cmd = MagicMock(return_value="")
409         with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock_cmd}):
410             self.assertFalse(
411                 iptables.check_chain(</b></font>table="filter", chain="INPUT", family="ipv4")
412             )
413     def test_new_chain(self):
414         """
415         """
416         self.assertEqual(
417             iptables.new_chain(table="filter", chain=None, family<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"),
418             "Error: Chain needs to be specified",
419         )
420         mock_cmd = MagicMock(return_value="")
421         with patch.dict(
422             iptables.__salt__,
423             {
424                 "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
425                 "cmd.run_stderr": mock_cmd,
426             },
427         ):
428             self.assertTrue(
429                 iptables.new_chain(</b></font>table="filter", chain="INPUT", family="ipv4")
430             )
431     def test_delete_chain(self):
432         """
433         """
434         self.assertEqual(
435             iptables.delete_chain(table="filter", chain=None, family<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"),
436             "Error: Chain needs to be specified",
437         )
438         mock_cmd = MagicMock(return_value="")
439         with patch.dict(
440             iptables.__salt__,
441             {
442                 "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
443                 "cmd.run_stderr": mock_cmd,
444             },
445         ):
446             self.assertTrue(
447                 iptables.delete_chain(</b></font>table="filter", chain="INPUT", family="ipv4")
448             )
449     def test_append(self):
450         """
451         Test if it append a rule to the specified table/chain.
452         """
453         with patch.object(
454             iptables, "_has_option", MagicMock(return_value=True)
455         ), patch.object(iptables, "check", MagicMock(return_value=False)):
456             self.assertEqual(
457                 iptables.append(table="filter", chain=None, rule=None, family="ipv4"),
458                 "Error: Chain needs to be specified",
459             )
460             self.assertEqual(
461                 iptables.append(
462                     table="filter", chain="INPUT", rule=None, family="ipv4"
463                 ),
464                 "Error: Rule needs to be specified",
465             )
466             _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
467             mock = MagicMock(side_effect=["", "SALT"])
468             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
469                 self.assertTrue(
470                     iptables.append(
471                         table="filter", chain="INPUT", rule=_rule, family="ipv4"
472                     )
473                 )
474                 self.assertFalse(
475                     iptables.append(
476                         table="filter", chain="INPUT", rule=_rule, family="ipv4"
477                     )
478                 )
479     def test_insert(self):
480         """
481         Test if it insert a rule into the specified table/chain,
482         at the specified position.
483         """
484         with patch.object(
485             iptables, "_has_option", MagicMock(return_value=True)
486         ), patch.object(iptables, "check", MagicMock(return_value=False)):
487             self.assertEqual(
488                 iptables.insert(
489                     table="filter", chain=None, position=None, rule=None, family="ipv4"
490                 ),
491                 "Error: Chain needs to be specified",
492             )
493             pos_err = "Error: Position needs to be specified or use append (-A)"
494             self.assertEqual(
495                 iptables.insert(
496                     table="filter",
497                     chain="INPUT",
498                     position=None,
499                     rule=None,
500                     family="ipv4",
501                 ),
502                 pos_err,
503             )
504             self.assertEqual(
505                 iptables.insert(
506                     table="filter", chain="INPUT", position=3, rule=None, family="ipv4"
507                 ),
508             )
509             _rule <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "m state --state RELATED,ESTABLISHED -j ACCEPT"
510             mock = MagicMock(return_value=True)
511             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
512                 self.assertTrue(
513                     iptables.insert(</b></font>
514                         table="filter",
515                         chain="INPUT",
516                         position=3,
517                         rule=_rule,
518                         family="ipv4",
519                     )
520                 )
521     def test_delete(self):
522         """
523         Test if it delete a rule from the specified table/chain
524         """
525         with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
526             _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
527             self.assertEqual(
528                 iptables.delete(
529                     table="filter", chain=None, position=3, rule=_rule, family="ipv4"
530                 ),
531             )
532             mock <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value=True)
533             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
534                 self.assertTrue(
535                     iptables.delete(</b></font>
536                         table="filter",
537                         chain="INPUT",
538                         position=3,
539                         rule="",
540                         family="ipv4",
541                     )
542                 )
543     def test_flush(self):
544         """
545         flush all chains in the specified table if not specified chain.
546         """
547         with patch.object<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(iptables, "_has_option", MagicMock(return_value=True)):
548             mock_cmd = MagicMock(return_value=True)
549             with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
550                 self.assertTrue(
551                     iptables.flush(</b></font>table="filter", chain="INPUT", family="ipv4")
552                 )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
