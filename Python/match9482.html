<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_deb_apache.py &amp; test_iptables_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_deb_apache.py &amp; test_iptables_1.py
      </h3>
<h1 align="center">
        15.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_deb_apache.py (20.46332%)<th>test_iptables_1.py (12.83293%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(285-289)<td><a href="#" name="0">(681-685)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(41-52)<td><a href="#" name="1">(21-31)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(372-376)<td><a href="#" name="2">(634-638)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(356-360)<td><a href="#" name="3">(546-559)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(340-344)<td><a href="#" name="4">(523-536)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(317-321)<td><a href="#" name="5">(506-513)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(301-305)<td><a href="#" name="6">(385-393)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(64-67)<td><a href="#" name="7">(662-665)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_deb_apache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
"""
import salt.modules.deb_apache as deb_apache
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase
class DebApacheTestCase(TestCase, LoaderModuleMockMixin):
    """
    Test cases for salt.modules.deb_apache
    """
    def setup_loader_modules(self):
        return {deb_apache: {}}
    def test_check_site_enabled(self):
        """
        Test if the specific Site symlink is enabled.
        """
        with patch("os.path.islink", MagicMock(return_value=True)):
            self.assertTrue(deb_apache.check_site_enabled("saltstack.com"))
    def test_check_site_enabled_default(self):
        """
        Test if the specific Site symlink is enabled.
        """
        with patch("os.path.islink", MagicMock(side_effect=[False, True])):
            self.assertTrue(deb_apache.check_site_enabled("default"))
    def test_check_site_enabled_false(self):
        """
        """
        with patch("os.path.islink", MagicMock(return_value=False)):
            self.assertFalse(deb_apache.check_site_enabled("<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>saltstack.com"))
    def test_a2ensite_notfound(self):
        """
        Test if it runs a2ensite for the given site.
        """
        mock = MagicMock(return_value=1)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2ensite(</b></font>"saltstack.com"),
                {
                    "Name": "Apache2 Enable Site",
                    "Site": "saltstack.com",
                    "Status": "Site saltstack.com Not found",
                },
            )
    def test_a2ensite_enabled(self):
        Test if it runs a2ensite for the given site.
        """
        mock <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= MagicMock(return_value=0)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2ensite(</b></font>"saltstack.com"),
                {
                    "Name": "Apache2 Enable Site",
                    "Site": "saltstack.com",
                    "Status": "Site saltstack.com enabled",
                },
            )
    def test_a2ensite(self):
        """
        Test if it runs a2ensite for the given site.
        """
        mock = MagicMock(return_value=2)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2ensite("saltstack.com"),
                {"Name": "Apache2 Enable Site", "Site": "saltstack.com", "Status": 2},
            )
    def test_a2ensite_exception(self):
        """
        Test if it runs a2ensite for the given site.
        """
        mock = MagicMock(side_effect=Exception("error"))
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(str(deb_apache.a2ensite("saltstack.com")), "error")
    def test_a2dissite_notfound(self):
        """
        Test if it runs a2dissite for the given site.
        """
        mock = MagicMock(return_value=256)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2dissite("saltstack.com"),
                {
                    "Name": "Apache2 Disable Site",
                    "Site": "saltstack.com",
                    "Status": "Site saltstack.com Not found",
                },
            )
    def test_a2dissite_disabled(self):
        """
        Test if it runs a2dissite for the given site.
        """
        mock = MagicMock(return_value=0)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2dissite("saltstack.com"),
                {
                    "Name": "Apache2 Disable Site",
                    "Site": "saltstack.com",
                    "Status": "Site saltstack.com disabled",
                },
            )
    def test_a2dissite(self):
        """
        Test if it runs a2dissite for the given site.
        """
        mock = MagicMock(return_value=2)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2dissite("saltstack.com"),
                {"Name": "Apache2 Disable Site", "Site": "saltstack.com", "Status": 2},
            )
    def test_a2dissite_exception(self):
        """
        Test if it runs a2dissite for the given site.
        """
        mock = MagicMock(side_effect=Exception("error"))
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(str(deb_apache.a2dissite("saltstack.com")), "error")
    def test_check_mod_enabled(self):
        """
        Test if the specific mod symlink is enabled.
        """
        with patch("os.path.islink", MagicMock(return_value=True)):
            self.assertTrue(deb_apache.check_mod_enabled("status.conf"))
    def test_check_mod_enabled_false(self):
        """
        Test if the specific mod symlink is enabled.
        """
        with patch("os.path.islink", MagicMock(return_value=False)):
            self.assertFalse(deb_apache.check_mod_enabled("status.conf"))
    def test_a2enmod_notfound(self):
        """
        Test if it runs a2enmod for the given module.
        """
        mock = MagicMock(return_value=1)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2enmod("vhost_alias"),
                {
                    "Name": "Apache2 Enable Mod",
                    "Mod": "vhost_alias",
                    "Status": "Mod vhost_alias Not found",
                },
            )
    def test_a2enmod_enabled(self):
        """
        Test if it runs a2enmod for the given module.
        """
        mock = MagicMock(return_value=0)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2enmod("vhost_alias"),
                {
                    "Name": "Apache2 Enable Mod",
                    "Mod": "vhost_alias",
                    "Status": "Mod vhost_alias enabled",
                },
            )
    def test_a2enmod(self):
        """
        Test if it runs a2enmod for the given module.
        """
        mock = MagicMock(return_value=2)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2enmod("vhost_alias"),
                {"Name": "Apache2 Enable Mod", "Mod": "vhost_alias", "Status": 2},
            )
    def test_a2enmod_exception(self):
        """
        Test if it runs a2enmod for the given module.
        """
        mock = MagicMock(side_effect=Exception("error"))
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(str(deb_apache.a2enmod("vhost_alias")), "error")
    def test_a2dismod_notfound(self):
        """
        Test if it runs a2dismod for the given module.
        """
        mock = MagicMock(return_value=256)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2dismod("vhost_alias"),
                {
                    "Name": "Apache2 Disable Mod",
                    "Mod": "vhost_alias",
                    "Status": "Mod vhost_alias Not found",
                },
            )
    def test_a2dismod_disabled(self):
        """
        Test if it runs a2dismod for the given module.
        """
        mock = MagicMock(return_value=0)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2dismod("vhost_alias"),
                {
                    "Name": "Apache2 Disable Mod",
                    "Mod": "vhost_alias",
                    "Status": "Mod vhost_alias disabled",
                },
            )
    def test_a2dismod(self):
        """
        Test if it runs a2dismod for the given module.
        """
        mock = MagicMock(return_value=2)
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(
                deb_apache.a2dismod("vhost_alias"),
                {"Name": "Apache2 Disable Mod", "Mod": "vhost_alias", "Status": 2},
            )
    def test_a2dismod_exception(self):
        """
        Test if it runs a2dismod for the given module.
        """
        mock = MagicMock(side_effect=Exception("error"))
        with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
            self.assertEqual(str(deb_apache.a2dismod("vhost_alias")), "error")
    def test_check_conf_enabled(self):
        """
        Test if the specific conf symlink is enabled.
        """
        with patch("os.path.islink", MagicMock(return_value=True)):
            self.assertTrue(deb_apache.check_conf_enabled("security.conf"))
    def test_check_conf_enabled_false(self):
        """
        Test if the specific conf symlink is enabled.
        """
        with patch("os.path.islink", MagicMock(return_value=False)):
            self.assertFalse(deb_apache.check_conf_enabled("security.conf"))
    def test_a2enconf_notfound(self):
        Test if it runs a2enconf for the given conf.
        """
        with patch<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>("salt.utils.path.which", MagicMock(return_value="a2enconf")):
            mock = MagicMock(return_value=1)
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(
                    deb_apache.a2enconf(</b></font>"security"),
                    {
                        "Name": "Apache2 Enable Conf",
                        "Conf": "security",
                        "Status": "Conf security Not found",
                    },
                )
    def test_a2enconf_enabled(self):
        Test if it runs a2enconf for the given conf.
        """
        with patch("salt.utils.path.which", MagicMock(return_value<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2enconf")):
            mock = MagicMock(return_value=0)
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(
                    deb_apache.a2enconf(</b></font>"security"),
                    {
                        "Name": "Apache2 Enable Conf",
                        "Conf": "security",
                        "Status": "Conf security enabled",
                    },
                )
    def test_a2enconf(self):
        Test if it runs a2enconf for the given conf.
        """
        with patch("salt.utils.path.which", MagicMock(return_value<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2enconf")):
            mock = MagicMock(return_value=2)
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(
                    deb_apache.a2enconf(</b></font>"security"),
                    {"Name": "Apache2 Enable Conf", "Conf": "security", "Status": 2},
                )
    def test_a2enconf_exception(self):
        """
        Test if it runs a2enconf for the given conf.
        """
        with patch("salt.utils.path.which", MagicMock(return_value="a2enconf")):
            mock = MagicMock(side_effect=Exception("error"))
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(str(deb_apache.a2enconf("security")), "error")
    def test_a2disconf_notfound(self):
        Test if it runs a2disconf for the given conf.
        """
        with patch("salt.utils.path.which", MagicMock(return_value<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2disconf")):
            mock = MagicMock(return_value=256)
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(
                    deb_apache.a2disconf(</b></font>"security"),
                    {
                        "Name": "Apache2 Disable Conf",
                        "Conf": "security",
                        "Status": "Conf security Not found",
                    },
                )
    def test_a2disconf_disabled(self):
        Test if it runs a2disconf for the given conf.
        """
        with patch("salt.utils.path.which", MagicMock(return_value<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2disconf")):
            mock = MagicMock(return_value=0)
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(
                    deb_apache.a2disconf(</b></font>"security"),
                    {
                        "Name": "Apache2 Disable Conf",
                        "Conf": "security",
                        "Status": "Conf security disabled",
                    },
                )
    def test_a2disconf(self):
        Test if it runs a2disconf for the given conf.
        """
        with patch("salt.utils.path.which", MagicMock(return_value<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="a2disconf")):
            mock = MagicMock(return_value=2)
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(
                    deb_apache.a2disconf(</b></font>"security"),
                    {"Name": "Apache2 Disable Conf", "Conf": "security", "Status": 2},
                )
    def test_a2disconf_exception(self):
        """
        Test if it runs a2disconf for the given conf.
        """
        with patch("salt.utils.path.which", MagicMock(return_value="a2disconf")):
            mock = MagicMock(side_effect=Exception("error"))
            with patch.dict(deb_apache.__salt__, {"cmd.retcode": mock}):
                self.assertEqual(str(deb_apache.a2disconf("security")), "error")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_iptables_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
"""
import textwrap
import uuid
import salt.modules.iptables as iptables
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, mock_open, patch
from tests.support.unit import TestCase
class IptablesTestCase(TestCase, LoaderModuleMockMixin):
    """
    Test cases for salt.modules.iptables
    def setup_loader_modules(self):
        return {i<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>ptables: {}}
    def test_version(self):
        """
        Test if it return version from iptables --version
        """
        mock = MagicMock(return_value="iptables v1.4.21")
        with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock}):
            self.assertEqual(iptables.version(</b></font>), "v1.4.21")
    def test_build_rule(self):
        """
        Test if it build a well-formatted iptables rule based on kwargs.
        """
        with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
            self.assertEqual(iptables.build_rule(), "")
            self.assertEqual(
                iptables.build_rule(name="ignored", state="ignored"),
                "",
                "build_rule should ignore name and state",
            )
            self.assertEqual(iptables.build_rule(**{"if": "!eth0"}), "! -i eth0")
            self.assertEqual(iptables.build_rule(**{"if": "not eth0"}), "! -i eth0")
            self.assertEqual(
                iptables.build_rule(**{"protocol": "tcp", "syn": "!"}), "-p tcp ! --syn"
            )
            self.assertEqual(
                iptables.build_rule(dports=[80, 443], protocol="tcp"),
                "-p tcp -m multiport --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(dports="80,443", protocol="tcp"),
                "-p tcp -m multiport --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(dports=["!80", 443], protocol="tcp"),
                "-p tcp -m multiport ! --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(dports="!80,443", protocol="tcp"),
                "-p tcp -m multiport ! --dports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(sports=[80, 443], protocol="tcp"),
                "-p tcp -m multiport --sports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(sports="80,443", protocol="tcp"),
                "-p tcp -m multiport --sports 80,443",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "INPUT",
                    command="I",
                    position="3",
                    full=True,
                    dports="protocol",
                    jump="ACCEPT",
                ),
                "Error: protocol must be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "INPUT",
                    command="I",
                    position="3",
                    full=True,
                    sports="protocol",
                    jump="ACCEPT",
                ),
                "Error: protocol must be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "",
                    "INPUT",
                    command="I",
                    position="3",
                    full="True",
                    match="state",
                    jump="ACCEPT",
                ),
                "Error: Table needs to be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "",
                    command="I",
                    position="3",
                    full="True",
                    match="state",
                    jump="ACCEPT",
                ),
                "Error: Chain needs to be specified",
            )
            self.assertEqual(
                iptables.build_rule(
                    "filter",
                    "INPUT",
                    command="",
                    position="3",
                    full="True",
                    match="state",
                    jump="ACCEPT",
                ),
                "Error: Command needs to be specified",
            )
            self.assertEqual(
                iptables.build_rule(jump="REDIRECT", **{"to-port": 8080}),
                "--jump REDIRECT --to-port 8080",
            )
            self.assertEqual(
                iptables.build_rule(jump="LOG", **{"log-prefix": "long prefix"}),
                '--jump LOG --log-prefix "long prefix"',
            )
            self.assertEqual(
                iptables.build_rule(jump="LOG", **{"log-prefix": "spam: "}),
                '--jump LOG --log-prefix "spam: "',
            )
            self.assertEqual(
                iptables.build_rule(jump="CLUSTERIP", **{"new": ""}),
                "--jump CLUSTERIP --new",
            )
            self.assertEqual(
                iptables.build_rule(jump="CT", **{"notrack": None}),
                "--jump CT --notrack",
            )
            self.assertEqual(
                iptables.build_rule(**{"match-set": "src flag1,flag2"}),
                "-m set --match-set src flag1,flag2",
            )
            match_sets = [
                "src1 flag1",
                "src2 flag2,flag3",
            ]
            self.assertEqual(
                iptables.build_rule(**{"match-set": match_sets}),
                "-m set --match-set src1 flag1 -m set --match-set src2 flag2,flag3",
            )
            self.assertEqual(
                iptables.build_rule(**{"match-set": "!src flag"}),
                "-m set ! --match-set src flag",
            )
            match_sets = ["src1 flag", "not src2 flag2"]
            self.assertEqual(
                iptables.build_rule(**{"match-set": match_sets}),
                "-m set --match-set src1 flag -m set ! --match-set src2 flag2",
            )
            self.assertEqual(
                iptables.build_rule(**{"match": "recent", "name_": "SSH"}),
                "-m recent --name SSH",
            )
            self.assertEqual(
                iptables.build_rule(**{"match": "recent", "update": None}),
                "-m recent --update",
            )
            ret = "/sbin/iptables --wait -t salt -I INPUT 3 -m state --jump ACCEPT"
            with patch.object(
                iptables, "_iptables_cmd", MagicMock(return_value="/sbin/iptables")
            ):
                self.assertEqual(
                    iptables.build_rule(
                        "salt",
                        "INPUT",
                        command="I",
                        position="3",
                        full="True",
                        match="state",
                        jump="ACCEPT",
                    ),
                    ret,
                )
    def test_get_saved_rules(self):
        """
        Test if it return a data structure of the rules in the conf file
        """
        mock = MagicMock(return_value=False)
        with patch.object(iptables, "_parse_conf", mock):
            self.assertFalse(iptables.get_saved_rules())
            mock.assert_called_with(conf_file=None, family="ipv4")
    def test_get_saved_rules_nilinuxrt(self):
        """
        Test get rules on NILinuxRT system
        """
        data = {
            "/etc/natinst/share/iptables.conf": textwrap.dedent(
                """\
                *filter
                :INPUT ACCEPT [2958:584773]
                :FORWARD ACCEPT [0:0]
                :OUTPUT ACCEPT [92:23648]
                -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
                COMMIT
                """
            )
        }
        expected_input_rules = [
            {
                "protocol": ["tcp"],
                "jump": ["ACCEPT"],
                "match": ["tcp"],
                "destination_port": ["80"],
            }
        ]
        file_mock = mock_open(read_data=data)
        with patch.dict(
            iptables.__grains__, {"os_family": "NILinuxRT", "os": "NILinuxRT"}
        ):
            with patch.object(iptables.salt.utils.files, "fopen", file_mock):
                rules = iptables.get_saved_rules()
                self.assertEqual(
                    expected_input_rules, rules["filter"]["INPUT"]["rules"]
                )
    def test_get_rules(self):
        """
        Test if it return a data structure of the current, in-memory rules
        """
        mock = MagicMock(return_value=False)
        with patch.object(iptables, "_parse_conf", mock):
            self.assertFalse(iptables.get_rules())
            mock.assert_called_with(in_mem=True, family="ipv4")
    def test_get_saved_policy(self):
        """
        Test if it return the current policy for the specified table/chain
        """
        self.assertEqual(
            iptables.get_saved_policy(
                table="filter", chain=None, conf_file=None, family="ipv4"
            ),
            "Error: Chain needs to be specified",
        )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
        ):
            self.assertTrue(
                iptables.get_saved_policy(
                    table="filter", chain="INPUT", conf_file=None, family="ipv4"
                )
            )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
        ):
            self.assertIsNone(
                iptables.get_saved_policy(
                    table="filter", chain="INPUT", conf_file=None, family="ipv4"
                )
            )
    def test_get_policy(self):
        """
        Test if it return the current policy for the specified table/chain
        """
        self.assertEqual(
            iptables.get_policy(table="filter", chain=None, family="ipv4"),
            "Error: Chain needs to be specified",
        )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy": True}}}),
        ):
            self.assertTrue(
                iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
            )
        with patch.object(
            iptables,
            "_parse_conf",
            MagicMock(return_value={"filter": {"INPUT": {"policy1": True}}}),
        ):
            self.assertIsNone(
                iptables.get_policy(table="filter", chain="INPUT", family="ipv4")
            )
    def test_set_policy(self):
        """
        Test if it set the current policy for the specified table/chain
        """
        with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
            self.assertEqual(
                iptables.set_policy(
                    table="filter", chain=None, policy=None, family="ipv4"
                ),
                "Error: Chain needs to be specified",
            )
            self.assertEqual(
                iptables.set_policy(
                    table="filter", chain="INPUT", policy=None, family<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"
                ),
                "Error: Policy needs to be specified",
            )
            mock = MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.set_policy(</b></font>
                        table="filter", chain="INPUT", policy="ACCEPT", family="ipv4"
                    )
                )
    def test_save(self):
        """
        Test if it save the current in-memory rules to disk
        """
        with patch("salt.modules.iptables._conf", MagicMock(return_value=False)), patch(
            "os.path.isdir", MagicMock(return_value=True)
        ):
            mock = MagicMock(return_value=True)
            with patch.dict(
                iptables.__salt__,
                {
                    "cmd.run_stdout": mock,
                    "file.write": mock,
                    "config.option": MagicMock(return_value=[]),
                },
            ):
                self.assertTrue(iptables.save(filename="/xyz", family="ipv4"))
    def test_check(self):
        """
        Test if it check for the existence of a rule in the table and chain
        """
        self.assertEqual(
            iptables.check(table="filter", chain=None, rule=None, family="ipv4"),
            "Error: Chain needs to be specified",
        )
        self.assertEqual(
            iptables.check(table="filter", chain="INPUT", rule=None, family="ipv4"),
            "Error: Rule needs to be specified",
        )
        mock_rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
        mock_chain = "INPUT"
        mock_uuid = 31337
        mock_cmd_rule = MagicMock(
            return_value="-A {}\n-A {}".format(mock_chain, hex(mock_uuid))
        )
        mock_cmd_nooutput = MagicMock(return_value="")
        mock_has = MagicMock(return_value=True)
        mock_not = MagicMock(return_value=False)
        with patch.object(iptables, "_has_option", mock_not):
            with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
                with patch.dict(
                    iptables.__salt__,
                    {"cmd.run_stdout": mock_cmd_rule, "cmd.run": mock_cmd_nooutput},
                ):
                    self.assertTrue(
                        iptables.check(
                            table="filter",
                            chain=mock_chain,
                            rule=mock_rule,
                            family="ipv4",
                        )
                    )
        mock_cmd = MagicMock(return_value="")
        with patch.object(iptables, "_has_option", mock_not):
            with patch.object(uuid, "getnode", MagicMock(return_value=mock_uuid)):
                with patch.dict(
                    iptables.__salt__,
                    {
                        "cmd.run_stdout": mock_cmd_nooutput,
                        "cmd.run": mock_cmd_nooutput,
                    },
                ):
                    self.assertFalse(
                        iptables.check(
                            table="filter",
                            chain=mock_chain,
                            rule=mock_rule,
                            family="ipv4",
                        )
                    )
        with patch.object(iptables, "_has_option", mock_has):
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
                self.assertTrue(
                    iptables.check(
                        table="filter", chain="INPUT", rule=mock_rule, family="ipv4"
                    )
                )
        mock_cmd = MagicMock(return_value="-A 0x4d2")
        mock_uuid = MagicMock(return_value=1234)
        with patch.object(iptables, "_has_option", mock_has):
            with patch.object(uuid, "getnode", mock_uuid):
                with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
                    self.assertTrue(
                        iptables.check(
                            table="filter", chain="0x4d2", rule=mock_rule, family="ipv4"
                        )
                    )
    def test_check_chain(self):
        """
        """
        self.assertEqual(
            iptables.check_chain(table="filter", chain=None, family<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"),
            "Error: Chain needs to be specified",
        )
        mock_cmd = MagicMock(return_value="")
        with patch.dict(iptables.__salt__, {"cmd.run_stdout": mock_cmd}):
            self.assertFalse(
                iptables.check_chain(</b></font>table="filter", chain="INPUT", family="ipv4")
            )
    def test_new_chain(self):
        """
        """
        self.assertEqual(
            iptables.new_chain(table="filter", chain=None, family<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"),
            "Error: Chain needs to be specified",
        )
        mock_cmd = MagicMock(return_value="")
        with patch.dict(
            iptables.__salt__,
            {
                "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
                "cmd.run_stderr": mock_cmd,
            },
        ):
            self.assertTrue(
                iptables.new_chain(</b></font>table="filter", chain="INPUT", family="ipv4")
            )
    def test_delete_chain(self):
        """
        """
        self.assertEqual(
            iptables.delete_chain(table="filter", chain=None, family<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>="ipv4"),
            "Error: Chain needs to be specified",
        )
        mock_cmd = MagicMock(return_value="")
        with patch.dict(
            iptables.__salt__,
            {
                "cmd.run_stdout": mock_cmd,  # called by iptables._has_option
                "cmd.run_stderr": mock_cmd,
            },
        ):
            self.assertTrue(
                iptables.delete_chain(</b></font>table="filter", chain="INPUT", family="ipv4")
            )
    def test_append(self):
        """
        Test if it append a rule to the specified table/chain.
        """
        with patch.object(
            iptables, "_has_option", MagicMock(return_value=True)
        ), patch.object(iptables, "check", MagicMock(return_value=False)):
            self.assertEqual(
                iptables.append(table="filter", chain=None, rule=None, family="ipv4"),
                "Error: Chain needs to be specified",
            )
            self.assertEqual(
                iptables.append(
                    table="filter", chain="INPUT", rule=None, family="ipv4"
                ),
                "Error: Rule needs to be specified",
            )
            _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
            mock = MagicMock(side_effect=["", "SALT"])
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.append(
                        table="filter", chain="INPUT", rule=_rule, family="ipv4"
                    )
                )
                self.assertFalse(
                    iptables.append(
                        table="filter", chain="INPUT", rule=_rule, family="ipv4"
                    )
                )
    def test_insert(self):
        """
        Test if it insert a rule into the specified table/chain,
        at the specified position.
        """
        with patch.object(
            iptables, "_has_option", MagicMock(return_value=True)
        ), patch.object(iptables, "check", MagicMock(return_value=False)):
            self.assertEqual(
                iptables.insert(
                    table="filter", chain=None, position=None, rule=None, family="ipv4"
                ),
                "Error: Chain needs to be specified",
            )
            pos_err = "Error: Position needs to be specified or use append (-A)"
            self.assertEqual(
                iptables.insert(
                    table="filter",
                    chain="INPUT",
                    position=None,
                    rule=None,
                    family="ipv4",
                ),
                pos_err,
            )
            self.assertEqual(
                iptables.insert(
                    table="filter", chain="INPUT", position=3, rule=None, family="ipv4"
                ),
            )
            _rule <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "m state --state RELATED,ESTABLISHED -j ACCEPT"
            mock = MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.insert(</b></font>
                        table="filter",
                        chain="INPUT",
                        position=3,
                        rule=_rule,
                        family="ipv4",
                    )
                )
    def test_delete(self):
        """
        Test if it delete a rule from the specified table/chain
        """
        with patch.object(iptables, "_has_option", MagicMock(return_value=True)):
            _rule = "m state --state RELATED,ESTABLISHED -j ACCEPT"
            self.assertEqual(
                iptables.delete(
                    table="filter", chain=None, position=3, rule=_rule, family="ipv4"
                ),
            )
            mock <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock}):
                self.assertTrue(
                    iptables.delete(</b></font>
                        table="filter",
                        chain="INPUT",
                        position=3,
                        rule="",
                        family="ipv4",
                    )
                )
    def test_flush(self):
        """
        flush all chains in the specified table if not specified chain.
        """
        with patch.object<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(iptables, "_has_option", MagicMock(return_value=True)):
            mock_cmd = MagicMock(return_value=True)
            with patch.dict(iptables.__salt__, {"cmd.run_stderr": mock_cmd}):
                self.assertTrue(
                    iptables.flush(</b></font>table="filter", chain="INPUT", family="ipv4")
                )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
