<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for heat.py &amp; mysql_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for heat.py &amp; mysql_2.py
      </h3>
<h1 align="center">
        1.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>heat.py (6.5789475%)<th>mysql_2.py (0.8389262%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(97-146)<td><a href="#" name="0">(1431-1464)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(212-213)<td><a href="#" name="1">(861-862)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>heat.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.exceptions
3 import salt.utils.files
4 import salt.utils.json
5 import salt.utils.stringutils
6 import salt.utils.versions
7 import salt.utils.yaml
8 HAS_OSLO = False
9 try:
10     from oslo_serialization import jsonutils
11     HAS_OSLO = True
12 except ImportError:
13     pass
14 logging.basicConfig(level=logging.DEBUG)
15 log = logging.getLogger(__name__)
16 def __virtual__():
17     if HAS_OSLO:
18         return "heat"
19     return (
20         False,
21         "The heat state module cannot be loaded: "
22         "the oslo_serialization python library is not available.",
23     )
24 def _parse_template(tmpl_str):
25     tmpl_str = tmpl_str.strip()
26     if tmpl_str.startswith("{"):
27         tpl = salt.utils.json.loads(tmpl_str)
28     else:
29         try:
30             tpl = salt.utils.yaml.safe_load(tmpl_str)
31         except salt.utils.yaml.YAMLError as exc:
32             raise ValueError(str(exc))
33         else:
34             if tpl is None:
35                 tpl = {}
36     if not (
37         "HeatTemplateFormatVersion" in tpl
38 <a name="0"></a>        or "heat_template_version" in tpl
39         or "AWSTemplateFormatVersion" in tpl
40     ):
41         raise ValueError(<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"Template format version not found.")
42     return tpl
43 def deployed(
44     name,
45     template=None,
46     environment=None,
47     params=None,
48     poll=5,
49     rollback=False,
50     timeout=60,
51     update=False,
52     profile=None,
53     **connection_args
54 ):
55     log.</b></font>debug(
56         "Deployed with(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)",
57         name,
58         template,
59         environment,
60         params,
61         poll,
62         rollback,
63         timeout,
64         update,
65         profile,
66         connection_args,
67     )
68     ret = {"name": None, "comment": "", "changes": {}, "result": True}
69     if not name:
70         ret["result"] = False
71         ret["comment"] = "Name ist not valid"
72         return ret
73     ret["name"] = (name,)
74     existing_stack = __salt__["heat.show_stack"](name, profile=profile)
75     if existing_stack["result"] and not update:
76         ret["comment"] = "Stack {} is deployed".format(name)
77         return ret
78     if existing_stack["result"] and update:
79         if template:
80             template_tmp_file = salt.utils.files.mkstemp()
81             tsfn, source_sum, comment_ = __salt__["file.get_managed"](
82                 name=template_tmp_file,
83                 template=None,
84                 source=template,
85                 source_hash=None,
86                 user=None,
87                 group=None,
88                 mode=None,
89                 saltenv="base",
90                 context=None,
91                 defaults=None,
92                 skip_verify=False,
93                 kwargs=None,
94             )
95             template_manage_result = __salt__["file.manage_file"](
96                 name=template_tmp_file,
97                 sfn=tsfn,
98                 ret=None,
99                 source=template,
100                 source_sum=source_sum,
101                 user=None,
102                 group=None,
103                 mode=None,
104                 saltenv="base",
105                 backup=None,
106                 makedirs=True,
107                 template=None,
108                 show_changes=False,
109                 contents=None,
110                 dir_mode=None,
111             )
112 <a name="1"></a>            if (template_manage_result["result"]) or (
113                 (__opts__["test"]) and (template_manage_result["result"] is not False)
114             ):
115                 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(template_tmp_file, "r") as tfp_:
116                     tpl = salt.utils.stringutils.to_unicode(tfp_.read(</b></font>))
117                     salt.utils.files.safe_rm(template_tmp_file)
118                     try:
119                         template_parse = _parse_template(tpl)
120                         if "heat_template_version" in template_parse:
121                             template_new = salt.utils.yaml.safe_dump(template_parse)
122                         else:
123                             template_new = jsonutils.dumps(
124                                 template_parse, indent=2, ensure_ascii=False
125                             )
126                         salt.utils.files.safe_rm(template_tmp_file)
127                     except ValueError as ex:
128                         ret["result"] = False
129                         ret["comment"] = "Error parsing template {}".format(ex)
130             else:
131                 ret["result"] = False
132                 ret["comment"] = "Can not open template: {} {}".format(
133                     template, comment_
134                 )
135         else:
136             ret["result"] = False
137             ret["comment"] = "Can not open template"
138         if ret["result"] is True:
139             template_stack = __salt__["heat.template_stack"](name=name, profile=profile)
140             if not template_stack["result"]:
141                 ret["result"] = False
142                 ret["comment"] = template_stack["comment"]
143         if ret["result"] is False:
144             return ret
145         try:
146             checksum_template = __salt__["hashutil.digest"](template_new)
147             checksum_stack = __salt__["hashutil.digest"](template_stack["template"])
148         except salt.exceptions.CommandExecutionError as cmdexc:
149             ret["result"] = False
150             ret["comment"] = "{}".format(cmdexc)
151         if ret["result"] is True:
152             if checksum_template == checksum_stack:
153                 if __opts__["test"]:
154                     ret["result"] = True
155                     ret["comment"] = "Stack {} is deployed".format(name)
156                     return ret
157                 else:
158                     ret["result"] = False
159                     ret["comment"] = "Templates have same checksum: {} {}".format(
160                         checksum_template, checksum_stack
161                     )
162         if ret["result"] is False:
163             return ret
164         if __opts__["test"]:
165             stack = {
166                 "result": None,
167                 "comment": "Stack {} is set to be updated".format(name),
168             }
169         else:
170             stack = __salt__["heat.update_stack"](
171                 name=name,
172                 template_file=template,
173                 environment=environment,
174                 parameters=params,
175                 poll=poll,
176                 rollback=rollback,
177                 timeout=timeout,
178                 profile=profile,
179             )
180             ret["changes"]["stack_name"] = name
181             ret["changes"]["comment"] = "Update stack"
182     else:
183         if __opts__["test"]:
184             stack = {
185                 "result": None,
186                 "comment": "Stack {} is set to be created".format(name),
187             }
188         else:
189             stack = __salt__["heat.create_stack"](
190                 name=name,
191                 template_file=template,
192                 environment=environment,
193                 parameters=params,
194                 poll=poll,
195                 rollback=rollback,
196                 timeout=timeout,
197                 profile=profile,
198             )
199             ret["changes"]["stack_name"] = name
200             ret["changes"]["comment"] = "Create stack"
201     ret["result"] = stack["result"]
202     ret["comment"] = stack["comment"]
203     return ret
204 def absent(name, poll=5, timeout=60, profile=None):
205     log.debug("Absent with(%s, %s %s)", name, poll, profile)
206     ret = {"name": None, "comment": "", "changes": {}, "result": True}
207     if not name:
208         ret["result"] = False
209         ret["comment"] = "Name ist not valid"
210         return ret
211     ret["name"] = (name,)
212     existing_stack = __salt__["heat.show_stack"](name, profile=profile)
213     if not existing_stack["result"]:
214         ret["result"] = True
215         ret["comment"] = "Stack not exist"
216         return ret
217     if __opts__["test"]:
218         ret["result"] = None
219         ret["comment"] = "Stack {} is set to be removed".format(name)
220         return ret
221     stack = __salt__["heat.delete_stack"](
222         name=name, poll=poll, timeout=timeout, profile=profile
223     )
224     ret["result"] = stack["result"]
225     ret["comment"] = stack["comment"]
226     ret["changes"]["stack_name"] = name
227     ret["changes"]["comment"] = "Delete stack"
228     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mysql_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import hashlib
3 import logging
4 import os
5 import re
6 import shlex
7 import sys
8 import time
9 import salt.utils.data
10 import salt.utils.files
11 import salt.utils.stringutils
12 try:
13     import MySQLdb
14     import MySQLdb.cursors
15     import MySQLdb.converters
16     from MySQLdb.constants import FIELD_TYPE, FLAG, CLIENT
17     from MySQLdb import OperationalError
18 except ImportError:
19     try:
20         import pymysql
21         pymysql.install_as_MySQLdb()
22         import MySQLdb
23         import MySQLdb.cursors
24         import MySQLdb.converters
25         from MySQLdb.constants import FIELD_TYPE, FLAG, CLIENT
26         from MySQLdb import OperationalError
27     except ImportError:
28         MySQLdb = None
29 try:
30     import sqlparse
31     HAS_SQLPARSE = True
32 except ImportError:
33     HAS_SQLPARSE = False
34 log = logging.getLogger(__name__)
35 __opts__ = {}
36 __grants__ = [
37     "ALL PRIVILEGES",
38     "ALTER",
39     "ALTER ROUTINE",
40     "BACKUP_ADMIN",
41     "BINLOG_ADMIN",
42     "CONNECTION_ADMIN",
43     "CREATE",
44     "CREATE ROLE",
45     "CREATE ROUTINE",
46     "CREATE TABLESPACE",
47     "CREATE TEMPORARY TABLES",
48     "CREATE USER",
49     "CREATE VIEW",
50     "DELETE",
51     "DROP",
52     "DROP ROLE",
53     "ENCRYPTION_KEY_ADMIN",
54     "EVENT",
55     "EXECUTE",
56     "FILE",
57     "GRANT OPTION",
58     "GROUP_REPLICATION_ADMIN",
59     "INDEX",
60     "INSERT",
61     "LOCK TABLES",
62     "PERSIST_RO_VARIABLES_ADMIN",
63     "PROCESS",
64     "REFERENCES",
65     "RELOAD",
66     "REPLICATION CLIENT",
67     "REPLICATION SLAVE",
68     "REPLICATION_SLAVE_ADMIN",
69     "RESOURCE_GROUP_ADMIN",
70     "RESOURCE_GROUP_USER",
71     "ROLE_ADMIN",
72     "SELECT",
73     "SET_USER_ID",
74     "SHOW DATABASES",
75     "SHOW VIEW",
76     "SHUTDOWN",
77     "SLAVE MONITOR",
78     "SUPER",
79     "SYSTEM_VARIABLES_ADMIN",
80     "TRIGGER",
81     "UPDATE",
82     "USAGE",
83     "XA_RECOVER_ADMIN",
84 ]
85 __ssl_options_parameterized__ = ["CIPHER", "ISSUER", "SUBJECT"]
86 __ssl_options__ = __ssl_options_parameterized__ + ["SSL", "X509"]
87 __all_privileges__ = [
88     "ALTER",
89     "ALTER ROUTINE",
90     "BACKUP_ADMIN",
91     "BINLOG_ADMIN",
92     "CONNECTION_ADMIN",
93     "CREATE",
94     "CREATE ROLE",
95     "CREATE ROUTINE",
96     "CREATE TABLESPACE",
97     "CREATE TEMPORARY TABLES",
98     "CREATE USER",
99     "CREATE VIEW",
100     "DELETE",
101     "DROP",
102     "DROP ROLE",
103     "ENCRYPTION_KEY_ADMIN",
104     "EVENT",
105     "EXECUTE",
106     "FILE",
107     "GROUP_REPLICATION_ADMIN",
108     "INDEX",
109     "INSERT",
110     "LOCK TABLES",
111     "PERSIST_RO_VARIABLES_ADMIN",
112     "PROCESS",
113     "REFERENCES",
114     "RELOAD",
115     "REPLICATION CLIENT",
116     "REPLICATION SLAVE",
117     "REPLICATION_SLAVE_ADMIN",
118     "RESOURCE_GROUP_ADMIN",
119     "RESOURCE_GROUP_USER",
120     "ROLE_ADMIN",
121     "SELECT",
122     "SET_USER_ID",
123     "SHOW DATABASES",
124     "SHOW VIEW",
125     "SHUTDOWN",
126     "SUPER",
127     "SYSTEM_VARIABLES_ADMIN",
128     "TRIGGER",
129     "UPDATE",
130     "XA_RECOVER_ADMIN",
131 ]
132 r'''
133 DEVELOPER NOTE: ABOUT arguments management, escapes, formats, arguments and
134 security of SQL.
135 A general rule of SQL security is to use queries with _execute call in this
136 code using args parameter to let MySQLdb manage the arguments proper escaping.
137 Another way of escaping values arguments could be '{0!r}'.format(), using
138 __repr__ to ensure things get properly used as strings. But this could lead
139 to three problems:
140  * In ANSI mode, which is available on MySQL, but not by default, double
141 quotes " should not be used as a string delimiters, in ANSI mode this is an
142 identifier delimiter (like `).
143  * Some rare exploits with bad multibytes management, either on python or
144 MySQL could defeat this barrier, bindings internal escape functions
145 should manage theses cases.
146  * Unicode strings in Python 2 will include the 'u' before the repr'ed string,
147    like so:
148     Python 2.7.10 (default, May 26 2015, 04:16:29)
149     [GCC 5.1.0] on linux2
150     Type "help", "copyright", "credits" or "license" for more information.
151     &gt;&gt;&gt; u'something something {0!r}'.format(u'foo')
152     u"something something u'foo'"
153 So query with arguments should use a paramstyle defined in PEP249:
154 http://www.python.org/dev/peps/pep-0249/#paramstyle
155 We use pyformat, which means 'SELECT * FROM foo WHERE bar=%(myval)s'
156 used with {'myval': 'some user input'}
157 So far so good. But this cannot be used for identifier escapes. Identifiers
158 are database names, table names and column names. Theses names are not values
159 and do not follow the same escape rules (see quote_identifier function for
160 details on `_ and % escape policies on identifiers). Using value escaping on
161 identifier could fool the SQL engine (badly escaping quotes and not doubling
162 ` characters. So for identifiers a call to quote_identifier should be done and
163 theses identifiers should then be added in strings with format, but without
164 __repr__ filter.
165 Note also that when using query with arguments in _execute all '%' characters
166 used in the query should get escaped to '%%' fo MySQLdb, but should not be
167 escaped if the query runs without arguments. This is managed by _execute() and
168 quote_identifier. This is not the same as escaping '%' to '\%' or '_' to '\%'
169 when using a LIKE query (example in db_exists), as this escape is there to
170 avoid having _ or % characters interpreted in LIKE queries. The string parted
171 of the first query could become (still used with args dictionary for myval):
172 'SELECT * FROM {0} WHERE bar=%(myval)s'.format(quote_identifier('user input'))
173 Check integration tests if you find a hole in theses strings and escapes rules
174 Finally some examples to sum up.
175 Given a name f_o%o`b'a"r, in python that would be """f_o%o`b'a"r""". I'll
176 avoid python syntax for clarity:
177 The MySQL way of writing this name is:
178 value                         : 'f_o%o`b\'a"r' (managed by MySQLdb)
179 identifier                    : `f_o%o``b'a"r`
180 db identifier in general GRANT: `f\_o\%o``b'a"r`
181 db identifier in table GRANT  : `f_o%o``b'a"r`
182 in mySQLdb, query with args   : `f_o%%o``b'a"r` (as identifier)
183 in mySQLdb, query without args: `f_o%o``b'a"r` (as identifier)
184 value in a LIKE query         : 'f\_o\%o`b\'a"r' (quotes managed by MySQLdb)
185 And theses could be mixed, in a like query value with args: 'f\_o\%%o`b\'a"r'
186         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(file_name, "r") as ifile:
187             contents = salt.utils.stringutils.to_unicode(ifile.read(</b></font>))
188     else:
189         log.error('File "%s" does not exist', file_name)
190         return False
191     query_string = ""
192     ret = {
193         "rows returned": 0,
194         "columns": [],
195         "results": [],
196         "rows affected": 0,
197         "query time": {"raw": 0},
198     }
199     contents = _sanitize_comments(contents)
200     for line in contents.splitlines():
201         if not re.search(r"[^-;]+;", line):  # keep appending lines that don't end in ;
202             query_string = query_string + line
203         else:
204             query_string = (
205                 query_string + line
206             )  # append lines that end with ; and run query
207             query_result = query(database, query_string, **connection_args)
208             query_string = ""
209             if query_result is False:
210                 return False
211             if "query time" in query_result:
212                 ret["query time"]["raw"] += float(query_result["query time"]["raw"])
213             if "rows returned" in query_result:
214                 ret["rows returned"] += query_result["rows returned"]
215             if "columns" in query_result:
216                 ret["columns"].append(query_result["columns"])
217             if "results" in query_result:
218                 ret["results"].append(query_result["results"])
219             if "rows affected" in query_result:
220                 ret["rows affected"] += query_result["rows affected"]
221     ret["query time"]["human"] = str(round(float(ret["query time"]["raw"]), 2)) + "s"
222     ret["query time"]["raw"] = round(float(ret["query time"]["raw"]), 5)
223     ret = {k: v for k, v in ret.items() if v}
224     return ret
225 def status(**connection_args):
226     dbc = _connect(**connection_args)
227     if dbc is None:
228         return {}
229     cur = dbc.cursor()
230     qry = "SHOW STATUS"
231     try:
232         _execute(cur, qry)
233     except OperationalError as exc:
234         err = "MySQL Error {}: {}".format(*exc.args)
235         __context__["mysql.error"] = err
236         log.error(err)
237         return {}
238     ret = {}
239     for _ in range(cur.rowcount):
240         row = cur.fetchone()
241         ret[row[0]] = row[1]
242     return ret
243 def version(**connection_args):
244     if "mysql.version" in __context__:
245         return __context__["mysql.version"]
246     dbc = _connect(**connection_args)
247     if dbc is None:
248         return ""
249     cur = dbc.cursor()
250     qry = "SELECT VERSION()"
251     try:
252         _execute(cur, qry)
253     except MySQLdb.OperationalError as exc:
254         err = "MySQL Error {}: {}".format(*exc.args)
255         __context__["mysql.error"] = err
256         log.error(err)
257         return ""
258     try:
259         __context__["mysql.version"] = salt.utils.data.decode(cur.fetchone()[0])
260         return __context__["mysql.version"]
261     except IndexError:
262         return ""
263 def slave_lag(**connection_args):
264     dbc = _connect(**connection_args)
265     if dbc is None:
266         return -3
267     cur = dbc.cursor(MySQLdb.cursors.DictCursor)
268     qry = "show slave status"
269     try:
270         _execute(cur, qry)
271     except MySQLdb.OperationalError as exc:
272         err = "MySQL Error {}: {}".format(*exc.args)
273         __context__["mysql.error"] = err
274         log.error(err)
275         return -3
276     results = cur.fetchone()
277     if cur.rowcount == 0:
278         return -1
279     else:
280         if results["Slave_IO_Running"] == "Yes":
281             return results["Seconds_Behind_Master"]
282         else:
283             return -2
284 def free_slave(**connection_args):
285     slave_db = _connect(**connection_args)
286     if slave_db is None:
287         return ""
288     slave_cur = slave_db.cursor(MySQLdb.cursors.DictCursor)
289     slave_cur.execute("show slave status")
290     slave_status = slave_cur.fetchone()
291     master = {"host": slave_status["Master_Host"]}
292     try:
293         master_db = _connect(**master)
294         if master_db is None:
295             return ""
296         master_cur = master_db.cursor()
297         master_cur.execute("flush logs")
298         master_db.close()
299     except MySQLdb.OperationalError:
300         pass
301     slave_cur.execute("stop slave")
302     slave_cur.execute("reset master")
303     slave_cur.execute("change master to MASTER_HOST=")
304     slave_cur.execute("show slave status")
305     results = slave_cur.fetchone()
306     if results is None:
307         return "promoted"
308     else:
309         return "failed"
310 def db_list(**connection_args):
311     dbc = _connect(**connection_args)
312     if dbc is None:
313         return []
314     cur = dbc.cursor()
315     qry = "SHOW DATABASES"
316     try:
317         _execute(cur, qry)
318     except MySQLdb.OperationalError as exc:
319         err = "MySQL Error {}: {}".format(*exc.args)
320         __context__["mysql.error"] = err
321         log.error(err)
322         return []
323     ret = []
324     results = cur.fetchall()
325     for dbs in results:
326         ret.append(dbs[0])
327     log.debug(ret)
328     return ret
329 def alter_db(name, character_set=None, collate=None, **connection_args):
330     dbc = _connect(**connection_args)
331     if dbc is None:
332         return []
333     cur = dbc.cursor()
334     existing = db_get(name, **connection_args)
335     qry = "ALTER DATABASE `{}` CHARACTER SET {} COLLATE {};".format(
336         name,
337         character_set or existing.get("character_set"),
338         collate or existing.get("collate"),
339     )
340     args = {}
341     try:
342         if _execute(cur, qry, args):
343             log.info("DB '%s' altered", name)
344             return True
345     except MySQLdb.OperationalError as exc:
346         err = "MySQL Error {}: {}".format(*exc.args)
347         __context__["mysql.error"] = err
348         log.error(err)
349     return False
350 def db_get(name, **connection_args):
351     dbc = _connect(**connection_args)
352     if dbc is None:
353         return []
354     cur = dbc.cursor()
355     qry = (
356         "SELECT DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME FROM "
357         "INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME=%(dbname)s;"
358     )
359     args = {"dbname": name}
360     try:
361         _execute(cur, qry, args)
362     except MySQLdb.OperationalError as exc:
363         err = "MySQL Error {}: {}".format(*exc.args)
364         __context__["mysql.error"] = err
365         log.error(err)
366         return []
367     if cur.rowcount:
368         rows = cur.fetchall()
369         return {"character_set": rows[0][0], "collate": rows[0][1]}
370     return {}
371 def db_tables(name, **connection_args):
372     if not db_exists(name, **connection_args):
373         log.info("Database '%s' does not exist", name)
374         return False
375     dbc = _connect(**connection_args)
376     if dbc is None:
377         return []
378     cur = dbc.cursor()
379     s_name = quote_identifier(name)
380     qry = "SHOW TABLES IN {}".format(s_name)
381     try:
382         _execute(cur, qry)
383     except MySQLdb.OperationalError as exc:
384         err = "MySQL Error {}: {}".format(*exc.args)
385         __context__["mysql.error"] = err
386         log.error(err)
387         return []
388     ret = []
389     results = cur.fetchall()
390     for table in results:
391         ret.append(table[0])
392     log.debug(ret)
393     return ret
394 def db_exists(name, **connection_args):
395     dbc = _connect(**connection_args)
396     if dbc is None:
397         return False
398     cur = dbc.cursor()
399     args = {"dbname": name}
400     qry = "SHOW DATABASES LIKE %(dbname)s;"
401     try:
402         _execute(cur, qry, args)
403     except MySQLdb.OperationalError as exc:
404         err = "MySQL Error {}: {}".format(*exc.args)
405         __context__["mysql.error"] = err
406         log.error(err)
407         return False
408     cur.fetchall()
409     return cur.rowcount == 1
410 def db_create(name, character_set=None, collate=None, **connection_args):
411     if db_exists(name, **connection_args):
412         log.info("DB '%s' already exists", name)
413         return False
414     dbc = _connect(**connection_args)
415     if dbc is None:
416         return False
417     cur = dbc.cursor()
418     s_name = quote_identifier(name)
419     qry = "CREATE DATABASE IF NOT EXISTS {}".format(s_name)
420     args = {}
421     if character_set is not None:
422         qry += " CHARACTER SET %(character_set)s"
423         args["character_set"] = character_set
424     if collate is not None:
425         qry += " COLLATE %(collate)s"
426         args["collate"] = collate
427     qry += ";"
428     try:
429         if _execute(cur, qry, args):
430             log.info("DB '%s' created", name)
431             return True
432     except MySQLdb.OperationalError as exc:
433         err = "MySQL Error {}: {}".format(*exc.args)
434         __context__["mysql.error"] = err
435         log.error(err)
436     return False
437 def db_remove(name, **connection_args):
438     if not db_exists(name, **connection_args):
439         log.info("DB '%s' does not exist", name)
440         return False
441     if name in ("mysql", "information_scheme"):
442         log.info("DB '%s' may not be removed", name)
443         return False
444     dbc = _connect(**connection_args)
445     if dbc is None:
446         return False
447     cur = dbc.cursor()
448     s_name = quote_identifier(name)
449     qry = "DROP DATABASE {};".format(s_name)
450     try:
451         _execute(cur, qry)
452     except MySQLdb.OperationalError as exc:
453         err = "MySQL Error {}: {}".format(*exc.args)
454         __context__["mysql.error"] = err
455         log.error(err)
456         return False
457     if not db_exists(name, **connection_args):
458         log.info("Database '%s' has been removed", name)
459         return True
460     log.info("Database '%s' has not been removed", name)
461     return False
462 def user_list(**connection_args):
463     dbc = _connect(**connection_args)
464     if dbc is None:
465         return []
466     cur = dbc.cursor(MySQLdb.cursors.DictCursor)
467     try:
468         qry = "SELECT User,Host FROM mysql.user"
469         _execute(cur, qry)
470     except MySQLdb.OperationalError as exc:
471         err = "MySQL Error {}: {}".format(*exc.args)
472         __context__["mysql.error"] = err
473         log.error(err)
474         return []
475     results = cur.fetchall()
476     log.debug(results)
477     return results
478 def _mysql_user_exists(
479     user,
480     host="localhost",
481     password=None,
482     password_hash=None,
483     passwordless=False,
484     unix_socket=False,
485     password_column=None,
486     auth_plugin="mysql_native_password",
487     **connection_args
488 ):
489     server_version = salt.utils.data.decode(version(**connection_args))
490     compare_version = "8.0.11"
491     qry = "SELECT User,Host FROM mysql.user WHERE User = %(user)s AND Host = %(host)s"
492     args = {}
493     args["user"] = user
494     args["host"] = host
495     if salt.utils.data.is_true(passwordless):
496         if salt.utils.data.is_true(unix_socket):
497             qry += " AND plugin=%(unix_socket)s"
498             args["unix_socket"] = "auth_socket"
499         else:
500             qry += " AND " + password_column + " = ''"
501     elif password:
502         if salt.utils.versions.version_cmp(server_version, compare_version) &gt;= 0:
503             if auth_plugin == "mysql_native_password":
504                 _password = __mysql_hash_password(str(password))
505                 qry += " AND " + password_column + " = %(password)s"
506                 args["password"] = str(_password)
507             else:
508                 err = "Unable to verify password."
509                 log.error(err)
510                 __context__["mysql.error"] = err
511         else:
512             qry += " AND " + password_column + " = PASSWORD(%(password)s)"
513             args["password"] = str(password)
514     elif password_hash:
515         qry += " AND " + password_column + " = %(password)s"
516         args["password"] = password_hash
517     return qry, args
518 def _mariadb_user_exists(
519     user,
520     host="localhost",
521     password=None,
522     password_hash=None,
523     passwordless=False,
524     unix_socket=False,
525     password_column=None,
526     auth_plugin="mysql_native_password",
527     **connection_args
528 ):
529     qry = "SELECT User,Host FROM mysql.user WHERE User = %(user)s AND Host = %(host)s"
530     args = {}
531     args["user"] = user
532     args["host"] = host
533     if salt.utils.data.is_true(passwordless):
534         if salt.utils.data.is_true(unix_socket):
535             qry += " AND plugin=%(unix_socket)s"
536             args["unix_socket"] = "unix_socket"
537         else:
538             qry += " AND " + password_column + " = ''"
539     elif password:
540         qry += " AND " + password_column + " = PASSWORD(%(password)s)"
541 <a name="0"></a>        args["password"] = str(password)
542     elif password_hash:
543         qry += " AND " + password_column + " = %(password)s"
544         args["password"] =<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b> password_hash
545     return qry, args
546 def user_exists(
547     user,
548     host="localhost",
549     password=None,
550     password_hash=None,
551     passwordless=False,
552     unix_socket=False,
553     password_column=None,
554     **connection_args
555 ):
556     run_verify = False
557     server_version = salt.</b></font>utils.data.decode(version(**connection_args))
558     if not server_version and password:
559         __context__["mysql.error"] = None
560         connection_args["connection_pass"] = password
561         server_version = salt.utils.data.decode(version(**connection_args))
562         if not server_version:
563             last_err = __context__["mysql.error"]
564             err = (
565                 "MySQL Error: Unable to fetch current server version. Last error was:"
566                 ' "{}"'.format(last_err)
567             )
568             log.error(err)
569             return False
570     dbc = _connect(**connection_args)
571     if (
572         dbc is None
573         and __context__["mysql.error"].startswith(
574             "MySQL Error 1045: Access denied for user '{}'@".format(user)
575         )
576         and password
577     ):
578         __context__["mysql.error"] = None
579         connection_args["connection_pass"] = password
580         dbc = _connect(**connection_args)
581     if dbc is None:
582         return False
583     if not password_column:
584         password_column = __password_column(**connection_args)
585     auth_plugin = __get_auth_plugin(user, host, **connection_args)
586     cur = dbc.cursor()
587     if "MariaDB" in server_version:
588         qry, args = _mariadb_user_exists(
589             user,
590             host,
591             password,
592             password_hash,
593             passwordless,
594             unix_socket,
595             password_column=password_column,
596             auth_plugin=auth_plugin,
597             **connection_args
598         )
599     else:
600         qry, args = _mysql_user_exists(
601             user,
602             host,
603             password,
604             password_hash,
605             passwordless,
606             unix_socket,
607             password_column=password_column,
608             auth_plugin=auth_plugin,
609             **connection_args
610         )
611     try:
612         _execute(cur, qry, args)
613     except MySQLdb.OperationalError as exc:
614         err = "MySQL Error {}: {}".format(*exc.args)
615         __context__["mysql.error"] = err
616         log.error(err)
617         return False
618     return cur.rowcount == 1
619 def user_info(user, host="localhost", **connection_args):
620     dbc = _connect(**connection_args)
621     if dbc is None:
622         return False
623     cur = dbc.cursor(MySQLdb.cursors.DictCursor)
624     qry = "SELECT * FROM mysql.user WHERE User = %(user)s AND Host = %(host)s"
625     args = {}
626     args["user"] = user
627     args["host"] = host
628     try:
629         _execute(cur, qry, args)
630     except MySQLdb.OperationalError as exc:
631         err = "MySQL Error {}: {}".format(*exc.args)
632         __context__["mysql.error"] = err
633         log.error(err)
634         return False
635     result = cur.fetchone()
636     log.debug(result)
637     return result
638 def _mysql_user_create(
639     user,
640     host="localhost",
641     password=None,
642     password_hash=None,
643     allow_passwordless=False,
644     unix_socket=False,
645     password_column=None,
646     auth_plugin="mysql_native_password",
647     **connection_args
648 ):
649     server_version = salt.utils.data.decode(version(**connection_args))
650     compare_version = "8.0.11"
651     qry = "CREATE USER %(user)s@%(host)s"
652     args = {}
653     args["user"] = user
654     args["host"] = host
655     if unix_socket:
656         if not plugin_status("auth_socket", **connection_args):
657             err = "The auth_socket plugin is not enabled."
658             log.error(err)
659             __context__["mysql.error"] = err
660             qry = False
661         else:
662             if host == "localhost":
663                 qry += " IDENTIFIED WITH auth_socket"
664             else:
665                 log.error("Auth via unix_socket can be set only for host=localhost")
666                 __context__["mysql.error"] = err
667                 qry = False
668     else:
669         if not salt.utils.data.is_true(allow_passwordless):
670             if password is not None:
671                 if (
672                     salt.utils.versions.version_cmp(server_version, compare_version)
673                     &gt;= 0
674                 ):
675                     args["auth_plugin"] = auth_plugin
676                     qry += " IDENTIFIED WITH %(auth_plugin)s BY %(password)s"
677                 else:
678                     qry += " IDENTIFIED BY %(password)s"
679                 args["password"] = str(password)
680             elif password_hash is not None:
681                 if (
682                     salt.utils.versions.version_cmp(server_version, compare_version)
683                     &gt;= 0
684                 ):
685                     args["auth_plugin"] = auth_plugin
686                     qry += " IDENTIFIED WITH %(auth_plugin)s AS %(password)s"
687                 else:
688                     qry += " IDENTIFIED BY PASSWORD %(password)s"
689                 args["password"] = password_hash
690             else:
691                 log.error(
692                     "password or password_hash must be specified, unless "
693                     "allow_passwordless=True"
694                 )
695                 qry = False
696     return qry, args
697 def _mariadb_user_create(
698     user,
699     host="localhost",
700     password=None,
701     password_hash=None,
702     allow_passwordless=False,
703     unix_socket=False,
704     password_column=None,
705     auth_plugin="mysql_native_password",
706     **connection_args
707 ):
708     qry = "CREATE USER %(user)s@%(host)s"
709     args = {}
710     args["user"] = user
711     args["host"] = host
712     if unix_socket:
713         if not plugin_status("unix_socket", **connection_args):
714             err = "The unix_socket plugin is not enabled."
715             log.error(err)
716             __context__["mysql.error"] = err
717             qry = False
718         else:
719             if host == "localhost":
720                 qry += " IDENTIFIED VIA unix_socket"
721             else:
722                 log.error("Auth via unix_socket can be set only for host=localhost")
723                 __context__["mysql.error"] = err
724                 qry = False
725     else:
726         if not salt.utils.data.is_true(allow_passwordless):
727             if password is not None:
728                 qry += " IDENTIFIED BY %(password)s"
729                 args["password"] = str(password)
730             elif password_hash is not None:
731                 qry += " IDENTIFIED BY PASSWORD %(password)s"
732                 args["password"] = password_hash
733             else:
734                 log.error(
735                     "password or password_hash must be specified, unless "
736                     "allow_passwordless=True"
737                 )
738                 qry = False
739     return qry, args
740 def user_create(
741     user,
742     host="localhost",
743     password=None,
744     password_hash=None,
745     allow_passwordless=False,
746     unix_socket=False,
747     password_column=None,
748     auth_plugin="mysql_native_password",
749     **connection_args
750 ):
751     server_version = salt.utils.data.decode(version(**connection_args))
752     if not server_version and password:
753         __context__["mysql.error"] = None
754         connection_args["connection_pass"] = password
755         server_version = salt.utils.data.decode(version(**connection_args))
756         if not server_version:
757             last_err = __context__["mysql.error"]
758             err = (
759                 "MySQL Error: Unable to fetch current server version. Last error was:"
760                 ' "{}"'.format(last_err)
761             )
762             log.error(err)
763             return False
764     if user_exists(user, host, **connection_args):
765         log.info("User '%s'@'%s' already exists", user, host)
766         return False
767     dbc = _connect(**connection_args)
768     if dbc is None:
769         return False
770     if not password_column:
771         password_column = __password_column(**connection_args)
772     cur = dbc.cursor()
773     if "MariaDB" in server_version:
774         qry, args = _mariadb_user_create(
775             user,
776             host,
777             password,
778             password_hash,
779             allow_passwordless,
780             unix_socket,
781             password_column=password_column,
782             auth_plugin=auth_plugin,
783             **connection_args
784         )
785     else:
786         qry, args = _mysql_user_create(
787             user,
788             host,
789             password,
790             password_hash,
791             allow_passwordless,
792             unix_socket,
793             password_column=password_column,
794             auth_plugin=auth_plugin,
795             **connection_args
796         )
797     if isinstance(qry, bool):
798         return qry
799     try:
800         _execute(cur, qry, args)
801     except MySQLdb.OperationalError as exc:
802         err = "MySQL Error {}: {}".format(*exc.args)
803         __context__["mysql.error"] = err
804         log.error(err)
805         return False
806     if user_exists(
807         user,
808         host,
809         password,
810         password_hash,
811         password_column=password_column,
812         **connection_args
813     ):
814         msg = "User '{}'@'{}' has been created".format(user, host)
815         if not any((password, password_hash)):
816             msg += " with passwordless login"
817         log.info(msg)
818         return True
819     log.info("User '%s'@'%s' was not created", user, host)
820     return False
821 def _mysql_user_chpass(
822     user,
823     host="localhost",
824     password=None,
825     password_hash=None,
826     allow_passwordless=False,
827     unix_socket=None,
828     password_column=None,
829     auth_plugin="mysql_native_password",
830     **connection_args
831 ):
832     server_version = salt.utils.data.decode(version(**connection_args))
833     compare_version = "8.0.11"
834     args = {}
835     if password is not None:
836         if salt.utils.versions.version_cmp(server_version, compare_version) &gt;= 0:
837             password_sql = "%(password)s"
838         else:
839             password_sql = "PASSWORD(%(password)s)"
840         args["password"] = password
841     elif password_hash is not None:
842         password_sql = "%(password)s"
843         args["password"] = password_hash
844     elif not salt.utils.data.is_true(allow_passwordless):
845         log.error(
846             "password or password_hash must be specified, unless "
847             "allow_passwordless=True"
848         )
849         return False
850     else:
851         password_sql = "''"
852     args["user"] = user
853     args["host"] = host
854     if salt.utils.versions.version_cmp(server_version, compare_version) &gt;= 0:
855         args["auth_plugin"] = auth_plugin
856         qry = "ALTER USER %(user)s@%(host)s IDENTIFIED WITH %(auth_plugin)s "
857         if password is not None:
858             qry += "BY %(password)s;"
859         elif password_hash is not None:
860             qry += "AS %(password)s;"
861     else:
862         qry = (
863             "UPDATE mysql.user SET "
864             + password_column
865             + "="
866             + password_sql
867             + " WHERE User=%(user)s AND Host = %(host)s;"
868         )
869     if salt.utils.data.is_true(allow_passwordless) and salt.utils.data.is_true(
870         unix_socket
871     ):
872         if host == "localhost":
873             if not plugin_status("auth_socket", **connection_args):
874                 err = "The auth_socket plugin is not enabled."
875                 log.error(err)
876                 __context__["mysql.error"] = err
877                 qry = False
878             else:
879                 args["unix_socket"] = "auth_socket"
880                 if (
881                     salt.utils.versions.version_cmp(server_version, compare_version)
882                     &gt;= 0
883                 ):
884                     qry = (
885                         "ALTER USER %(user)s@%(host)s IDENTIFIED WITH %(unix_socket)s"
886                         " AS %(user)s;"
887                     )
888                 else:
889                     qry = (
890                         "UPDATE mysql.user SET "
891                         + password_column
892                         + "="
893                         + password_sql
894                         + ", plugin=%(unix_socket)s"
895                         + " WHERE User=%(user)s AND Host = %(host)s;"
896                     )
897         else:
898             log.error("Auth via unix_socket can be set only for host=localhost")
899     return qry, args
900 def _mariadb_user_chpass(
901     user,
902     host="localhost",
903     password=None,
904     password_hash=None,
905     allow_passwordless=False,
906     unix_socket=None,
907     password_column=None,
908     auth_plugin="mysql_native_password",
909     **connection_args
910 ):
911     server_version = salt.utils.data.decode(version(**connection_args))
912     compare_version = "10.4"
913     args = {}
914     if password is not None:
915         password_sql = "PASSWORD(%(password)s)"
916         args["password"] = password
917     elif password_hash is not None:
918         password_sql = "%(password)s"
919         args["password"] = password_hash
920     elif not salt.utils.data.is_true(allow_passwordless):
921         log.error(
922             "password or password_hash must be specified, unless "
923             "allow_passwordless=True"
924         )
925         return False
926     else:
927         password_sql = "''"
928     args["user"] = user
929     args["host"] = host
930     if salt.utils.versions.version_cmp(server_version, compare_version) &gt;= 0:
931         args["auth_plugin"] = auth_plugin
932         qry = "ALTER USER %(user)s@%(host)s IDENTIFIED VIA %(auth_plugin)s USING "
933         qry += password_sql
934     else:
935         qry = (
936             "UPDATE mysql.user SET "
937             + password_column
938             + "="
939             + password_sql
940             + " WHERE User=%(user)s AND Host = %(host)s;"
941         )
942     if salt.utils.data.is_true(allow_passwordless) and salt.utils.data.is_true(
943         unix_socket
944     ):
945         if host == "localhost":
946             if not plugin_status("unix_socket", **connection_args):
947                 err = "The unix_socket plugin is not enabled."
948                 log.error(err)
949                 __context__["mysql.error"] = err
950                 qry = False
951             else:
952                 args["unix_socket"] = "unix_socket"
953                 qry = (
954                     "UPDATE mysql.user SET "
955                     + password_column
956                     + "="
957                     + password_sql
958                     + ", plugin=%(unix_socket)s"
959                     + " WHERE User=%(user)s AND Host = %(host)s;"
960                 )
961         else:
962             log.error("Auth via unix_socket can be set only for host=localhost")
963     return qry, args
964 def user_chpass(
965     user,
966     host="localhost",
967     password=None,
968     password_hash=None,
969     allow_passwordless=False,
970     unix_socket=None,
971     password_column=None,
972     **connection_args
973 ):
974     server_version = salt.utils.data.decode(version(**connection_args))
975     if not server_version and password:
976         __context__["mysql.error"] = None
977         connection_args["connection_pass"] = password
978         server_version = salt.utils.data.decode(version(**connection_args))
979         if not server_version:
980             last_err = __context__["mysql.error"]
981             err = (
982                 "MySQL Error: Unable to fetch current server version. Last error was:"
983                 ' "{}"'.format(last_err)
984             )
985             log.error(err)
986             return False
987     if not user_exists(user, host, **connection_args):
988         log.info("User '%s'@'%s' does not exists", user, host)
989         return False
990     dbc = _connect(**connection_args)
991     if dbc is None:
992         return False
993     if not password_column:
994         password_column = __password_column(**connection_args)
995     auth_plugin = __get_auth_plugin(user, host, **connection_args)
996     cur = dbc.cursor()
997     if "MariaDB" in server_version:
998         qry, args = _mariadb_user_chpass(
999             user,
1000             host,
1001             password,
1002             password_hash,
1003             allow_passwordless,
1004             unix_socket,
1005             password_column=password_column,
1006             auth_plugin=auth_plugin,
1007             **connection_args
1008         )
1009     else:
1010         qry, args = _mysql_user_chpass(
1011             user,
1012             host,
1013             password,
1014             password_hash,
1015             allow_passwordless,
1016             unix_socket,
1017             password_column=password_column,
1018             auth_plugin=auth_plugin,
1019             **connection_args
1020         )
1021     try:
1022         result = _execute(cur, qry, args)
1023     except MySQLdb.OperationalError as exc:
1024         err = "MySQL Error {}: {}".format(*exc.args)
1025         __context__["mysql.error"] = err
1026         log.error(err)
1027         return False
1028     compare_version = "10.4.0" if "MariaDB" in server_version else "8.0.11"
1029     res = False
1030     if salt.utils.versions.version_cmp(server_version, compare_version) &gt;= 0:
1031         _execute(cur, "FLUSH PRIVILEGES;")
1032         res = True
1033     else:
1034         if result:
1035             _execute(cur, "FLUSH PRIVILEGES;")
1036             res = True
1037     if res:
1038         log.info(
1039             "Password for user '%s'@'%s' has been %s",
1040             user,
1041             host,
1042             "changed" if any((password, password_hash)) else "cleared",
1043         )
1044         return True
1045     else:
1046         log.info(
1047             "Password for user '%s'@'%s' was not %s",
1048             user,
1049             host,
1050             "changed" if any((password, password_hash)) else "cleared",
1051         )
1052         return False
1053 def user_remove(user, host="localhost", **connection_args):
1054     if not user_exists(user, host, **connection_args):
1055         err = "User '%s'@'%s' does not exists", user, host
1056         __context__["mysql.error"] = err
1057         log.info(err)
1058         return False
1059     dbc = _connect(**connection_args)
1060     if dbc is None:
1061         return False
1062     cur = dbc.cursor()
1063     qry = "DROP USER %(user)s@%(host)s"
1064     args = {}
1065     args["user"] = user
1066     args["host"] = host
1067     try:
1068         _execute(cur, qry, args)
1069     except MySQLdb.OperationalError as exc:
1070         err = "MySQL Error {}: {}".format(*exc.args)
1071         __context__["mysql.error"] = err
1072         log.error(err)
1073         return False
1074     if not user_exists(user, host, **connection_args):
1075         log.info("User '%s'@'%s' has been removed", user, host)
1076         return True
1077     log.info("User '%s'@'%s' has NOT been removed", user, host)
1078     return False
1079 def tokenize_grant(grant):
1080     return _grant_to_tokens(grant)
1081 def db_check(name, table=None, **connection_args):
1082     ret = []
1083     if table is None:
1084         tables = db_tables(name, **connection_args)
1085         for table in tables:
1086             log.info("Checking table '%s' in db '%s'..", name, table)
1087             ret.append(__check_table(name, table, **connection_args))
1088     else:
1089         log.info("Checking table '%s' in db '%s'..", name, table)
1090         ret = __check_table(name, table, **connection_args)
1091     return ret
1092 def db_repair(name, table=None, **connection_args):
1093     ret = []
1094     if table is None:
1095         tables = db_tables(name, **connection_args)
1096         for table in tables:
1097             log.info("Repairing table '%s' in db '%s'..", name, table)
1098             ret.append(__repair_table(name, table, **connection_args))
1099     else:
1100         log.info("Repairing table '%s' in db '%s'..", name, table)
1101         ret = __repair_table(name, table, **connection_args)
1102     return ret
1103 def db_optimize(name, table=None, **connection_args):
1104     ret = []
1105     if table is None:
1106         tables = db_tables(name, **connection_args)
1107         for table in tables:
1108             log.info("Optimizing table '%s' in db '%s'..", name, table)
1109             ret.append(__optimize_table(name, table, **connection_args))
1110     else:
1111         log.info("Optimizing table '%s' in db '%s'..", name, table)
1112         ret = __optimize_table(name, table, **connection_args)
1113     return ret
1114 def __grant_normalize(grant):
1115     if grant.strip().upper() == "ALL":
1116         grant = "ALL PRIVILEGES"
1117     exploded_grants = __grant_split(grant)
1118     for chkgrant, _ in exploded_grants:
1119         if chkgrant.strip().upper() not in __grants__:
1120             raise Exception("Invalid grant : '{}'".format(chkgrant))
1121     return grant
1122 def __grant_split(grant):
1123     pattern = re.compile(r"([\w\s]+)(\([^)(]*\))?\s*,?")
1124     return pattern.findall(grant)
1125 def __ssl_option_sanitize(ssl_option):
1126     new_ssl_option = []
1127     for opt in ssl_option:
1128         key = next(iter(opt.keys()))
1129         normal_key = key.strip().upper()
1130         if normal_key not in __ssl_options__:
1131             raise Exception("Invalid SSL option : '{}'".format(key))
1132         if normal_key in __ssl_options_parameterized__:
1133             new_ssl_option.append(
1134                 "{} '{}'".format(normal_key, opt[key].replace("'", ""))
1135             )
1136         elif opt[key]:
1137             new_ssl_option.append(normal_key)
1138     return " REQUIRE " + " AND ".join(new_ssl_option)
1139 def __grant_generate(
1140     grant,
1141     database,
1142     user,
1143     host="localhost",
1144     grant_option=False,
1145     escape=True,
1146     ssl_option=False,
1147 ):
1148     grant = re.sub(r"\s*,\s*", ", ", grant).upper()
1149     grant = __grant_normalize(grant)
1150     db_part = database.rpartition(".")
1151     dbc = db_part[0]
1152     table = db_part[2]
1153     if escape:
1154         if dbc != "*":
1155             dbc = quote_identifier(dbc, for_grants=(table == "*"))
1156         if table != "*":
1157             table = quote_identifier(table)
1158     qry = "GRANT {} ON {}.{} TO %(user)s@%(host)s".format(grant, dbc, table)
1159     args = {}
1160     args["user"] = user
1161     args["host"] = host
1162     if ssl_option and isinstance(ssl_option, list):
1163         qry += __ssl_option_sanitize(ssl_option)
1164     if salt.utils.data.is_true(grant_option):
1165         qry += " WITH GRANT OPTION"
1166     log.debug("Grant Query generated: %s args %s", qry, repr(args))
1167     return {"qry": qry, "args": args}
1168 def user_grants(user, host="localhost", **connection_args):
1169     if not user_exists(user, host, **connection_args):
1170         log.info("User '%s'@'%s' does not exist", user, host)
1171         return False
1172     dbc = _connect(**connection_args)
1173     if dbc is None:
1174         return False
1175     cur = dbc.cursor()
1176     qry = "SHOW GRANTS FOR %(user)s@%(host)s"
1177     args = {}
1178     args["user"] = user
1179     args["host"] = host
1180     try:
1181         _execute(cur, qry, args)
1182     except MySQLdb.OperationalError as exc:
1183         err = "MySQL Error {}: {}".format(*exc.args)
1184         __context__["mysql.error"] = err
1185         log.error(err)
1186         return False
1187     ret = []
1188     results = salt.utils.data.decode(cur.fetchall())
1189     for grant in results:
1190         tmp = grant[0].split(" IDENTIFIED BY")[0]
1191         if "WITH GRANT OPTION" in grant[0] and "WITH GRANT OPTION" not in tmp:
1192             tmp = "{} WITH GRANT OPTION".format(tmp)
1193         ret.append(tmp)
1194     log.debug(ret)
1195     return ret
1196 def grant_exists(
1197     grant,
1198     database,
1199     user,
1200     host="localhost",
1201     grant_option=False,
1202     escape=True,
1203     **connection_args
1204 ):
1205     server_version = salt.utils.data.decode(version(**connection_args))
1206     if not server_version:
1207         last_err = __context__["mysql.error"]
1208         err = 'MySQL Error: Unable to fetch current server version. Last error was: "{}"'.format(
1209             last_err
1210         )
1211         log.error(err)
1212         return False
1213     if "ALL" in grant.upper():
1214         if (
1215             salt.utils.versions.version_cmp(server_version, "8.0") &gt;= 0
1216             and "MariaDB" not in server_version
1217             and database == "*.*"
1218         ):
1219             grant = ",".join([i for i in __all_privileges__])
1220         else:
1221             grant = "ALL PRIVILEGES"
1222     try:
1223         target = __grant_generate(grant, database, user, host, grant_option, escape)
1224     except Exception:  # pylint: disable=broad-except
1225         log.error("Error during grant generation.")
1226         return False
1227     grants = user_grants(user, host, **connection_args)
1228     if grants is False:
1229         log.error(
1230             "Grant does not exist or may not be ordered properly. In some cases, "
1231             "this could also indicate a connection error. Check your configuration."
1232         )
1233         return False
1234     _grants = {}
1235     for grant in grants:
1236         grant_token = _grant_to_tokens(grant)
1237         if grant_token["database"] not in _grants:
1238             _grants[grant_token["database"]] = {
1239                 "user": grant_token["user"],
1240                 "database": grant_token["database"],
1241                 "host": grant_token["host"],
1242                 "grant": grant_token["grant"],
1243             }
1244         else:
1245             _grants[grant_token["database"]]["grant"].extend(grant_token["grant"])
1246     target_tokens = _grant_to_tokens(target)
1247     for database, grant_tokens in _grants.items():
1248         try:
1249             _grant_tokens = {}
1250             _target_tokens = {}
1251             _grant_matches = [
1252                 True if i in grant_tokens["grant"] else False
1253                 for i in target_tokens["grant"]
1254             ]
1255             for item in ["user", "database", "host"]:
1256                 _grant_tokens[item] = (
1257                     grant_tokens[item]
1258                     .replace('"', "")
1259                     .replace("\\", "")
1260                     .replace("`", "")
1261                 )
1262                 _target_tokens[item] = (
1263                     target_tokens[item]
1264                     .replace('"', "")
1265                     .replace("\\", "")
1266                     .replace("`", "")
1267                 )
1268             if (
1269                 _grant_tokens["user"] == _target_tokens["user"]
1270                 and _grant_tokens["database"] == _target_tokens["database"]
1271                 and _grant_tokens["host"] == _target_tokens["host"]
1272                 and all(_grant_matches)
1273             ):
1274                 return True
1275             else:
1276                 log.debug("grants mismatch '%s'&lt;&gt;'%s'", grant_tokens, target_tokens)
1277         except Exception as exc:  # pylint: disable=broad-except
1278             log.exception(exc)
1279             if grants is not False and target in grants:
1280                 log.debug("Grant exists.")
1281                 return True
1282     log.debug("Grant does not exist, or is perhaps not ordered properly?")
1283     return False
1284 def grant_add(
1285     grant,
1286     database,
1287     user,
1288     host="localhost",
1289     grant_option=False,
1290     escape=True,
1291     ssl_option=False,
1292     **connection_args
1293 ):
1294     dbc = _connect(**connection_args)
1295     if dbc is None:
1296         return False
1297     cur = dbc.cursor()
1298     grant = grant.strip()
1299     try:
1300         qry = __grant_generate(
1301             grant, database, user, host, grant_option, escape, ssl_option
1302         )
1303     except Exception:  # pylint: disable=broad-except
1304         log.error("Error during grant generation")
1305         return False
1306     try:
1307         _execute(cur, qry["qry"], qry["args"])
1308     except (MySQLdb.OperationalError, MySQLdb.ProgrammingError) as exc:
1309         err = "MySQL Error {}: {}".format(*exc.args)
1310         __context__["mysql.error"] = err
1311         log.error(err)
1312         return False
1313     if grant_exists(
1314         grant, database, user, host, grant_option, escape, **connection_args
1315     ):
1316         log.info(
1317             "Grant '%s' on '%s' for user '%s' has been added", grant, database, user
1318         )
1319         return True
1320     log.info(
1321         "Grant '%s' on '%s' for user '%s' has NOT been added", grant, database, user
1322     )
1323     return False
1324 def grant_revoke(
1325     grant,
1326     database,
1327     user,
1328     host="localhost",
1329     grant_option=False,
1330     escape=True,
1331     **connection_args
1332 ):
1333     dbc = _connect(**connection_args)
1334     if dbc is None:
1335         return False
1336     cur = dbc.cursor()
1337     grant = __grant_normalize(grant)
1338     if salt.utils.data.is_true(grant_option):
1339         grant += ", GRANT OPTION"
1340     db_part = database.rpartition(".")
1341     dbc = db_part[0]
1342     table = db_part[2]
1343     if dbc != "*":
1344         s_database = quote_identifier(dbc, for_grants=(table == "*"))
1345     if dbc == "*":
1346         s_database = dbc
1347     if table != "*":
1348         table = quote_identifier(table)
1349     qry = "REVOKE {} ON {}.{} FROM %(user)s@%(host)s;".format(grant, s_database, table)
1350     args = {}
1351     args["user"] = user
1352     args["host"] = host
1353     try:
1354         _execute(cur, qry, args)
1355     except MySQLdb.OperationalError as exc:
1356         err = "MySQL Error {}: {}".format(*exc.args)
1357         __context__["mysql.error"] = err
1358         log.error(err)
1359         return False
1360     if not grant_exists(
1361         grant, database, user, host, grant_option, escape, **connection_args
1362     ):
1363         log.info(
1364             "Grant '%s' on '%s' for user '%s' has been revoked",
1365             grant,
1366             database,
1367             user,
1368         )
1369         return True
1370     log.info(
1371         "Grant '%s' on '%s' for user '%s' has NOT been revoked",
1372         grant,
1373         database,
1374         user,
1375     )
1376     return False
1377 def processlist(**connection_args):
1378     ret = []
1379     dbc = _connect(**connection_args)
1380     if dbc is None:
1381         return []
1382     cur = dbc.cursor()
1383     _execute(cur, "SHOW FULL PROCESSLIST")
1384     hdr = [c[0] for c in cur.description]
1385     for _ in range(cur.rowcount):
1386         row = cur.fetchone()
1387         idx_r = {}
1388         for idx_j, value_j in enumerate(hdr):
1389             idx_r[hdr[idx_j]] = row[idx_j]
1390         ret.append(idx_r)
1391     cur.close()
1392     return ret
1393 def __do_query_into_hash(conn, sql_str):
1394     mod = sys._getframe().f_code.co_name
1395     log.debug("%s&lt;--(%s)", mod, sql_str)
1396     rtn_results = []
1397     try:
1398         cursor = conn.cursor()
1399     except MySQLdb.MySQLError:
1400         log.error("%s: Can't get cursor for SQL-&gt;%s", mod, sql_str)
1401         cursor.close()
1402         log.debug("%s--&gt;", mod)
1403         return rtn_results
1404     try:
1405         _execute(cursor, sql_str)
1406     except MySQLdb.MySQLError:
1407         log.error("%s: try to execute : SQL-&gt;%s", mod, sql_str)
1408         cursor.close()
1409         log.debug("%s--&gt;", mod)
1410         return rtn_results
1411     qrs = cursor.fetchall()
1412     for row_data in qrs:
1413         col_cnt = 0
1414         row = {}
1415         for col_data in cursor.description:
1416             col_name = col_data[0]
1417             row[col_name] = row_data[col_cnt]
1418             col_cnt += 1
1419         rtn_results.append(row)
1420     cursor.close()
1421     log.debug("%s--&gt;", mod)
1422     return rtn_results
1423 def get_master_status(**connection_args):
1424     mod = sys._getframe().f_code.co_name
1425     log.debug("%s&lt;--", mod)
1426     conn = _connect(**connection_args)
1427     if conn is None:
1428         return []
1429     rtnv = __do_query_into_hash(conn, "SHOW MASTER STATUS")
1430     conn.close()
1431     if not rtnv:
1432         rtnv.append([])
1433     log.debug("%s--&gt;%s", mod, len(rtnv[0]))
1434     return rtnv[0]
1435 def get_slave_status(**connection_args):
1436     mod = sys._getframe().f_code.co_name
1437     log.debug("%s&lt;--", mod)
1438     conn = _connect(**connection_args)
1439     if conn is None:
1440         return []
1441     rtnv = __do_query_into_hash(conn, "SHOW SLAVE STATUS")
1442     conn.close()
1443     if not rtnv:
1444         rtnv.append([])
1445     log.debug("%s--&gt;%s", mod, len(rtnv[0]))
1446     return rtnv[0]
1447 def showvariables(**connection_args):
1448     mod = sys._getframe().f_code.co_name
1449     log.debug("%s&lt;--", mod)
1450     conn = _connect(**connection_args)
1451     if conn is None:
1452         return []
1453     rtnv = __do_query_into_hash(conn, "SHOW VARIABLES")
1454     conn.close()
1455     if not rtnv:
1456         rtnv.append([])
1457     log.debug("%s--&gt;%s", mod, len(rtnv[0]))
1458     return rtnv
1459 def showglobal(**connection_args):
1460     mod = sys._getframe().f_code.co_name
1461     log.debug("%s&lt;--", mod)
1462     conn = _connect(**connection_args)
1463     if conn is None:
1464         return []
1465     rtnv = __do_query_into_hash(conn, "SHOW GLOBAL VARIABLES")
1466     conn.close()
1467     if not rtnv:
1468         rtnv.append([])
1469     log.debug("%s--&gt;%s", mod, len(rtnv[0]))
1470     return rtnv
1471 def verify_login(user, password=None, **connection_args):
1472     connection_args["connection_user"] = user
1473     connection_args["connection_pass"] = password
1474     dbc = _connect(**connection_args)
1475     if dbc is None:
1476         if "mysql.error" in __context__:
1477             del __context__["mysql.error"]
1478         return False
1479     return True
1480 def plugins_list(**connection_args):
1481     dbc = _connect(**connection_args)
1482     if dbc is None:
1483         return []
1484     cur = dbc.cursor()
1485     qry = "SHOW PLUGINS"
1486     try:
1487         _execute(cur, qry)
1488     except MySQLdb.OperationalError as exc:
1489         err = "MySQL Error {}: {}".format(*exc.args)
1490         __context__["mysql.error"] = err
1491         log.error(err)
1492         return []
1493     ret = []
1494     results = cur.fetchall()
1495     for dbs in results:
1496         ret.append({"name": dbs[0], "status": dbs[1]})
1497     log.debug(ret)
1498     return ret
1499 def plugin_add(name, soname=None, **connection_args):
1500     if not name:
1501         log.error("Plugin name is required.")
1502         return False
1503     if plugin_status(name, **connection_args):
1504         log.error("Plugin %s is already installed.", name)
1505         return True
1506     dbc = _connect(**connection_args)
1507     if dbc is None:
1508         return False
1509     cur = dbc.cursor()
1510     qry = "INSTALL PLUGIN {}".format(name)
1511     if soname:
1512         qry += ' SONAME "{}"'.format(soname)
1513     else:
1514         qry += ' SONAME "{}.so"'.format(name)
1515     try:
1516         _execute(cur, qry)
1517     except MySQLdb.OperationalError as exc:
1518         err = "MySQL Error {}: {}".format(*exc.args)
1519         __context__["mysql.error"] = err
1520         log.error(err)
1521         return False
1522     return True
1523 def plugin_remove(name, **connection_args):
1524     if not name:
1525         log.error("Plugin name is required.")
1526         return False
1527     if not plugin_status(name, **connection_args):
1528         log.error("Plugin %s is not installed.", name)
1529         return True
1530     dbc = _connect(**connection_args)
1531     if dbc is None:
1532         return False
1533     cur = dbc.cursor()
1534     qry = "UNINSTALL PLUGIN {}".format(name)
1535     args = {}
1536     args["name"] = name
1537     try:
1538         _execute(cur, qry)
1539     except MySQLdb.OperationalError as exc:
1540         err = "MySQL Error {}: {}".format(*exc.args)
1541         __context__["mysql.error"] = err
1542         log.error(err)
1543         return False
1544     return True
1545 def plugin_status(name, **connection_args):
1546     if not name:
1547         log.error("Plugin name is required.")
1548         return False
1549     dbc = _connect(**connection_args)
1550     if dbc is None:
1551         return ""
1552     cur = dbc.cursor()
1553     qry = (
1554         "SELECT PLUGIN_STATUS FROM INFORMATION_SCHEMA.PLUGINS WHERE PLUGIN_NAME ="
1555         " %(name)s"
1556     )
1557     args = {}
1558     args["name"] = name
1559     try:
1560         _execute(cur, qry, args)
1561     except MySQLdb.OperationalError as exc:
1562         err = "MySQL Error {}: {}".format(*exc.args)
1563         __context__["mysql.error"] = err
1564         log.error(err)
1565         return ""
1566     try:
1567         status = cur.fetchone()
1568         if status is None:
1569             return ""
1570         else:
1571             return status[0]
1572     except IndexError:
1573         return ""
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
