<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_glusterfs.py & test_hgfs.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_glusterfs.py & test_hgfs.py
      </h3>
      <h1 align="center">
        1.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_glusterfs.py (1.589404%)<TH>test_hgfs.py (1.4251782%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match213953-0.html#0',2,'match213953-1.html#0',3)" NAME="0">(277-282)<TD><A HREF="javascript:ZweiFrames('match213953-0.html#0',2,'match213953-1.html#0',3)" NAME="0">(319-327)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_glusterfs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;

import salt.modules.glusterfs as mod_glusterfs
import salt.states.glusterfs as glusterfs
import salt.utils.cloud
import salt.utils.network
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase


class GlusterfsTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.states.glusterfs
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        return {glusterfs: {&quot;__salt__&quot;: {&quot;glusterfs.peer&quot;: mod_glusterfs.peer}}}

    # 'peered' function tests: 1

    def test_peered(self):
        &quot;&quot;&quot;
        Test to verify if node is peered.
        &quot;&quot;&quot;
        name = &quot;server1&quot;

        ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

        mock_ip = MagicMock(return_value=[&quot;1.2.3.4&quot;, &quot;1.2.3.5&quot;])
        mock_ip6 = MagicMock(return_value=[&quot;2001:db8::1&quot;])
        mock_host_ips = MagicMock(return_value=[&quot;1.2.3.5&quot;])
        mock_peer = MagicMock(return_value=True)
        mock_status = MagicMock(return_value={&quot;uuid1&quot;: {&quot;hostnames&quot;: [name]}})

        with patch.dict(
            glusterfs.__salt__,
            {&quot;glusterfs.peer_status&quot;: mock_status, &quot;glusterfs.peer&quot;: mock_peer},
        ):
            with patch.object(salt.utils.network, &quot;ip_addrs&quot;, mock_ip), patch.object(
                salt.utils.network, &quot;ip_addrs6&quot;, mock_ip6
            ), patch.object(salt.utils.network, &quot;host_to_ips&quot;, mock_host_ips):
                comt = &quot;Peering with localhost is not needed&quot;
                ret.update({&quot;comment&quot;: comt})
                self.assertDictEqual(glusterfs.peered(name), ret)

                mock_host_ips.return_value = [&quot;2001:db8::1&quot;]
                self.assertDictEqual(glusterfs.peered(name), ret)

                mock_host_ips.return_value = [&quot;1.2.3.42&quot;]
                comt = &quot;Host {} already peered&quot;.format(name)
                ret.update({&quot;comment&quot;: comt})
                self.assertDictEqual(glusterfs.peered(name), ret)

                with patch.dict(glusterfs.__opts__, {&quot;test&quot;: False}):
                    old = {&quot;uuid1&quot;: {&quot;hostnames&quot;: [&quot;other1&quot;]}}
                    new = {
                        &quot;uuid1&quot;: {&quot;hostnames&quot;: [&quot;other1&quot;]},
                        &quot;uuid2&quot;: {&quot;hostnames&quot;: [&quot;someAlias&quot;, name]},
                    }
                    mock_status.side_effect = [old, new]
                    comt = &quot;Host {} successfully peered&quot;.format(name)
                    ret.update({&quot;comment&quot;: comt, &quot;changes&quot;: {&quot;old&quot;: old, &quot;new&quot;: new}})
                    self.assertDictEqual(glusterfs.peered(name), ret)
                    mock_status.side_effect = None

                    mock_status.return_value = {&quot;uuid1&quot;: {&quot;hostnames&quot;: [&quot;other&quot;]}}
                    mock_peer.return_value = False

                    ret.update({&quot;result&quot;: False})

                    comt = (
                        &quot;Failed to peer with {0},&quot; + &quot; please check logs for errors&quot;
                    ).format(name)
                    ret.update({&quot;comment&quot;: comt, &quot;changes&quot;: {}})
                    self.assertDictEqual(glusterfs.peered(name), ret)

                    comt = &quot;Invalid characters in peer name.&quot;
                    ret.update({&quot;comment&quot;: comt, &quot;name&quot;: &quot;:/&quot;})
                    self.assertDictEqual(glusterfs.peered(&quot;:/&quot;), ret)
                    ret.update({&quot;name&quot;: name})

                with patch.dict(glusterfs.__opts__, {&quot;test&quot;: True}):
                    comt = &quot;Peer {} will be added.&quot;.format(name)
                    ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
                    self.assertDictEqual(glusterfs.peered(name), ret)

    # 'volume_present' function tests: 1

    def test_volume_present(self):
        &quot;&quot;&quot;
        Test to ensure that a volume exists
        &quot;&quot;&quot;
        name = &quot;salt&quot;
        bricks = [&quot;host1:/brick1&quot;]
        ret = {&quot;name&quot;: name, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

        started_info = {name: {&quot;status&quot;: &quot;1&quot;}}
        stopped_info = {name: {&quot;status&quot;: &quot;0&quot;}}

        mock_info = MagicMock()
        mock_list = MagicMock()
        mock_create = MagicMock()
        mock_start = MagicMock(return_value=True)

        with patch.dict(
            glusterfs.__salt__,
            {
                &quot;glusterfs.info&quot;: mock_info,
                &quot;glusterfs.list_volumes&quot;: mock_list,
                &quot;glusterfs.create_volume&quot;: mock_create,
                &quot;glusterfs.start_volume&quot;: mock_start,
            },
        ):
            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: False}):
                mock_list.return_value = [name]
                mock_info.return_value = started_info
                comt = &quot;Volume {} already exists and is started&quot;.format(name)
                ret.update({&quot;comment&quot;: comt})
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=True), ret
                )

                mock_info.return_value = stopped_info
                comt = &quot;Volume {} already exists and is now started&quot;.format(name)
                ret.update(
                    {&quot;comment&quot;: comt, &quot;changes&quot;: {&quot;old&quot;: &quot;stopped&quot;, &quot;new&quot;: &quot;started&quot;}}
                )
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=True), ret
                )

                comt = &quot;Volume {} already exists&quot;.format(name)
                ret.update({&quot;comment&quot;: comt, &quot;changes&quot;: {}})
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=False), ret
                )
            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: True}):
                comt = &quot;Volume {} already exists&quot;.format(name)
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=False), ret
                )

                comt = (&quot;Volume {0} already exists&quot; + &quot; and will be started&quot;).format(
                    name
                )
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=True), ret
                )

                mock_list.return_value = []
                comt = &quot;Volume {} will be created&quot;.format(name)
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=False), ret
                )

                comt = (&quot;Volume {0} will be created&quot; + &quot; and started&quot;).format(name)
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=True), ret
                )

            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: False}):
                mock_list.side_effect = [[], [name]]
                comt = &quot;Volume {} is created&quot;.format(name)
                ret.update(
                    {
                        &quot;comment&quot;: comt,
                        &quot;result&quot;: True,
                        &quot;changes&quot;: {&quot;old&quot;: [], &quot;new&quot;: [name]},
                    }
                )
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=False), ret
                )

                mock_list.side_effect = [[], [name]]
                comt = &quot;Volume {} is created and is now started&quot;.format(name)
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: True})
                self.assertDictEqual(
                    glusterfs.volume_present(name, bricks, start=True), ret
                )

                mock_list.side_effect = None
                mock_list.return_value = []
                mock_create.return_value = False
                comt = &quot;Creation of volume {} failed&quot;.format(name)
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: False, &quot;changes&quot;: {}})
                self.assertDictEqual(glusterfs.volume_present(name, bricks), ret)

            with patch.object(
                salt.utils.cloud, &quot;check_name&quot;, MagicMock(return_value=True)
            ):
                comt = &quot;Invalid characters in volume name.&quot;
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: False})
                self.assertDictEqual(glusterfs.volume_present(name, bricks), ret)

    # 'started' function tests: 1

    def test_started(self):
        &quot;&quot;&quot;
        Test to check if volume has been started
        &quot;&quot;&quot;
        name = &quot;salt&quot;

        ret = {&quot;name&quot;: name, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

        started_info = {name: {&quot;status&quot;: &quot;1&quot;}}
        stopped_info = {name: {&quot;status&quot;: &quot;0&quot;}}
        mock_info = MagicMock(return_value={})
        mock_start = MagicMock(return_value=True)

        with patch.dict(
            glusterfs.__salt__,
            {&quot;glusterfs.info&quot;: mock_info, &quot;glusterfs.start_volume&quot;: mock_start},
        ):
            comt = &quot;Volume {} does not exist&quot;.format(name)
            ret.update({&quot;comment&quot;: comt})
            self.assertDictEqual(glusterfs.started(name), ret)

            mock_info.return_value = started_info
            comt = &quot;Volume {} is already started&quot;.format(name)
            ret.update({&quot;comment&quot;: comt, &quot;result&quot;: True})
            self.assertDictEqual(glusterfs.started(name), ret)

            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: True}):
                mock_info.return_value = stopped_info
                comt = &quot;Volume {} will be started&quot;.format(name)
                ret.update({&quot;comment&quot;: comt, &quot;result&quot;: None})
                self.assertDictEqual(glusterfs.started(name), ret)

            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: False}):
                comt = &quot;Volume {} is started&quot;.format(name)
                ret.update(
                    {
                        &quot;comment&quot;: comt,
                        &quot;result&quot;: True,
                        &quot;change&quot;: {&quot;new&quot;: &quot;started&quot;, &quot;old&quot;: &quot;stopped&quot;},
                    }
                )
                self.assertDictEqual(glusterfs.started(name), ret)

    # 'add_volume_bricks' function tests: 1

    def test_add_volume_bricks(self):
        &quot;&quot;&quot;
        Test to add brick(s) to an existing volume
        &quot;&quot;&quot;
        name = &quot;salt&quot;
        bricks = [&quot;host1:/drive1&quot;]
        old_bricks = [&quot;host1:/drive2&quot;]

        ret = {&quot;name&quot;: name, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

        stopped_volinfo = {&quot;salt&quot;: {&quot;status&quot;: &quot;0&quot;}}
        volinfo = {
            &quot;salt&quot;: {&quot;status&quot;: &quot;1&quot;, &quot;bricks&quot;: {&quot;brick1&quot;: {&quot;path&quot;: old_bricks[0]}}}
        }
        new_volinfo = {
            &quot;salt&quot;: {
                &quot;status&quot;: &quot;1&quot;,
                &quot;bricks&quot;: {
                    &quot;brick1&quot;: {&quot;path&quot;: old_bricks[0]},
                    &quot;brick2&quot;: {&quot;path&quot;: bricks[0]},
                },
            }
        }

<A NAME="0"></A>        mock_info = MagicMock(return_value={})
        mock_add = MagicMock(side_effect=[False, True])

        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match213953-1.html#0',3,'match213953-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>with patch.dict(
            glusterfs.__salt__,
            {&quot;glusterfs.info&quot;: mock_info, &quot;glusterfs.add_volume_bricks&quot;: mock_add},
        ):
            ret.update({&quot;comment&quot;: &quot;Volume salt does not exist&quot;})
            self.assertDictEqual(glusterfs.add_volume_bricks(</B></FONT>name, bricks), ret)

            mock_info.return_value = stopped_volinfo
            ret.update({&quot;comment&quot;: &quot;Volume salt is not started&quot;})
            self.assertDictEqual(glusterfs.add_volume_bricks(name, bricks), ret)

            mock_info.return_value = volinfo
            ret.update({&quot;comment&quot;: &quot;Adding bricks to volume salt failed&quot;})
            self.assertDictEqual(glusterfs.add_volume_bricks(name, bricks), ret)

            ret.update({&quot;result&quot;: True})
            ret.update({&quot;comment&quot;: &quot;Bricks already added in volume salt&quot;})
            self.assertDictEqual(glusterfs.add_volume_bricks(name, old_bricks), ret)

            mock_info.side_effect = [volinfo, new_volinfo]
            ret.update(
                {
                    &quot;comment&quot;: &quot;Bricks successfully added to volume salt&quot;,
                    &quot;changes&quot;: {&quot;new&quot;: bricks + old_bricks, &quot;old&quot;: old_bricks},
                }
            )
            # Let's sort ourselves because the test under python 3 sometimes fails
            # just because of the new changes list order
            result = glusterfs.add_volume_bricks(name, bricks)
            ret[&quot;changes&quot;][&quot;new&quot;] = sorted(ret[&quot;changes&quot;][&quot;new&quot;])
            result[&quot;changes&quot;][&quot;new&quot;] = sorted(result[&quot;changes&quot;][&quot;new&quot;])
            self.assertDictEqual(result, ret)

    # 'op_version' function tests: 1

    def test_op_version(self):
        &quot;&quot;&quot;
        Test setting the Glusterfs op-version
        &quot;&quot;&quot;
        name = &quot;salt&quot;
        current = 30707
        new = 31200

        ret = {&quot;name&quot;: name, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

        mock_get_version = MagicMock(return_value={})
        mock_set_version = MagicMock(return_value={})

        with patch.dict(
            glusterfs.__salt__,
            {
                &quot;glusterfs.get_op_version&quot;: mock_get_version,
                &quot;glusterfs.set_op_version&quot;: mock_set_version,
            },
        ):
            mock_get_version.return_value = [False, &quot;some error message&quot;]
            ret.update({&quot;result&quot;: False})
            ret.update({&quot;comment&quot;: &quot;some error message&quot;})
            self.assertDictEqual(glusterfs.op_version(name, current), ret)

            mock_get_version.return_value = current
            ret.update({&quot;result&quot;: True})
            ret.update(
                {
                    &quot;comment&quot;: (
                        &quot;Glusterfs cluster.op-version for {} already set to {}&quot;.format(
                            name, current
                        )
                    )
                }
            )
            self.assertDictEqual(glusterfs.op_version(name, current), ret)

            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: True}):
                mock_set_version.return_value = [False, &quot;Failed to set version&quot;]
                ret.update({&quot;result&quot;: None})
                ret.update(
                    {
                        &quot;comment&quot;: (
                            &quot;An attempt would be made to set the cluster.op-version for&quot;
                            &quot; {} to {}.&quot;.format(name, new)
                        )
                    }
                )
                self.assertDictEqual(glusterfs.op_version(name, new), ret)

            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: False}):
                mock_set_version.return_value = [False, &quot;Failed to set version&quot;]
                ret.update({&quot;result&quot;: False})
                ret.update({&quot;comment&quot;: &quot;Failed to set version&quot;})
                self.assertDictEqual(glusterfs.op_version(name, new), ret)

                mock_set_version.return_value = &quot;some success message&quot;
                ret.update({&quot;comment&quot;: &quot;some success message&quot;})
                ret.update({&quot;changes&quot;: {&quot;old&quot;: current, &quot;new&quot;: new}})
                ret.update({&quot;result&quot;: True})
                self.assertDictEqual(glusterfs.op_version(name, new), ret)

    # 'max_op_version' function tests: 1

    def test_max_op_version(self):
        &quot;&quot;&quot;
        Test setting the Glusterfs to its self reported max-op-version
        &quot;&quot;&quot;
        name = &quot;salt&quot;
        current = 30707
        new = 31200

        ret = {&quot;name&quot;: name, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

        mock_get_version = MagicMock(return_value={})
        mock_get_max_op_version = MagicMock(return_value={})
        mock_set_version = MagicMock(return_value={})

        with patch.dict(
            glusterfs.__salt__,
            {
                &quot;glusterfs.get_op_version&quot;: mock_get_version,
                &quot;glusterfs.set_op_version&quot;: mock_set_version,
                &quot;glusterfs.get_max_op_version&quot;: mock_get_max_op_version,
            },
        ):
            mock_get_version.return_value = [False, &quot;some error message&quot;]
            ret.update({&quot;result&quot;: False})
            ret.update({&quot;comment&quot;: &quot;some error message&quot;})
            self.assertDictEqual(glusterfs.max_op_version(name), ret)

            mock_get_version.return_value = current
            mock_get_max_op_version.return_value = [False, &quot;some error message&quot;]
            ret.update({&quot;result&quot;: False})
            ret.update({&quot;comment&quot;: &quot;some error message&quot;})
            self.assertDictEqual(glusterfs.max_op_version(name), ret)

            mock_get_version.return_value = current
            mock_get_max_op_version.return_value = current
            ret.update({&quot;result&quot;: True})
            ret.update(
                {
                    &quot;comment&quot;: (
                        &quot;The cluster.op-version is already set to the&quot;
                        &quot; cluster.max-op-version of {}&quot;.format(current)
                    )
                }
            )
            self.assertDictEqual(glusterfs.max_op_version(name), ret)

            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: True}):
                mock_get_max_op_version.return_value = new
                ret.update({&quot;result&quot;: None})
                ret.update(
                    {
                        &quot;comment&quot;: (
                            &quot;An attempt would be made to set the cluster.op-version&quot;
                            &quot; to {}.&quot;.format(new)
                        )
                    }
                )
                self.assertDictEqual(glusterfs.max_op_version(name), ret)

            with patch.dict(glusterfs.__opts__, {&quot;test&quot;: False}):
                mock_set_version.return_value = [False, &quot;Failed to set version&quot;]
                ret.update({&quot;result&quot;: False})
                ret.update({&quot;comment&quot;: &quot;Failed to set version&quot;})
                self.assertDictEqual(glusterfs.max_op_version(name), ret)

                mock_set_version.return_value = &quot;some success message&quot;
                ret.update({&quot;comment&quot;: &quot;some success message&quot;})
                ret.update({&quot;changes&quot;: {&quot;old&quot;: current, &quot;new&quot;: new}})
                ret.update({&quot;result&quot;: True})
                self.assertDictEqual(glusterfs.max_op_version(name), ret)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_hgfs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import shutil
import tempfile
from pathlib import Path

import psutil  # pylint: disable=3rd-party-module-not-gated
import pytest
import salt.config
import salt.fileserver.hgfs as hgfs
from saltfactories.utils.processes import terminate_process
from tests.support.mock import patch

try:
    import hglib

    HAS_HG = True
except ImportError:
    HAS_HG = False


@pytest.fixture(scope=&quot;module&quot;)
def configure_loader_modules():
    opts = salt.config.DEFAULT_MASTER_OPTS.copy()
    cache = tempfile.TemporaryDirectory(dir=&quot;/tmp&quot;)
    opts[&quot;cachedir&quot;] = cache.name
    opts[&quot;fileserver_backend&quot;] = [&quot;hgfs&quot;]
    yield {hgfs: {&quot;__opts__&quot;: opts}}
    cache.cleanup()


@pytest.fixture
def hgfs_setup_and_teardown():
    &quot;&quot;&quot;
    build up and tear down hg repos to test with.
    &quot;&quot;&quot;
    initial_child_processes = psutil.Process().children()
    source_dir = Path(__file__).resolve().parent.joinpath(&quot;files&quot;)
    tempdir = tempfile.TemporaryDirectory()
    tempsubdir = tempdir.name / Path(&quot;subdir/&quot;)
    tempsubdir.mkdir()
    tempdirPath = Path(tempdir.name)
    for file in source_dir.iterdir():
        to_file = tempdirPath / file.name
        to_file2 = tempsubdir / file.name
        shutil.copy(file.as_posix(), to_file.as_posix())
        shutil.copy(file.as_posix(), to_file2.as_posix())

    client = hglib.init(bytes(tempdirPath.as_posix(), encoding=&quot;utf8&quot;))
    client.close()
    with hglib.open(bytes(tempdirPath.as_posix(), encoding=&quot;utf8&quot;)) as repo:
        repo.add(bytes(tempdirPath.as_posix(), encoding=&quot;utf8&quot;))
        repo.commit(b&quot;init commit&quot;, user=&quot;test&quot;)
        repo.tag(b&quot;test&quot;, user=&quot;test&quot;)
        repo.branch(b&quot;test&quot;)
        repo.commit(b&quot;create test branch&quot;, user=&quot;test&quot;)
        repo.bookmark(b&quot;bookmark_test&quot;)
    try:
        yield tempdirPath.as_uri()
    finally:
        tempdir.cleanup()
        for child in psutil.Process().children():
            if child not in initial_child_processes:
                terminate_process(process=child, kill_children=True)


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_fix_58852(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repo = hgfs.init()
        assert isinstance(repo, list)
        if isinstance(repo, list):
            for value in repo:
                assert isinstance(value, dict)
                for key, value in value.items():
                    if key != &quot;repo&quot;:
                        assert isinstance(value, str)


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_all_branches(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repos = hgfs.init()
        hgfs.update()
        for repo in repos:
            repo[&quot;repo&quot;].open()
            branches = hgfs._all_branches(repo[&quot;repo&quot;])
            assert isinstance(branches, list)
            if isinstance(branches, list):
                for value in branches:
                    assert isinstance(value, tuple)
                    assert len(value) == 3
                    assert value[0] in [&quot;default&quot;, &quot;test&quot;]
                    assert isinstance(value[1], int)
                    assert isinstance(value[2], str)


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_get_branch(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repo = hgfs.init()
        hgfs.update()
        repo[0][&quot;repo&quot;].open()
        branch = hgfs._get_branch(repo[0][&quot;repo&quot;], &quot;test&quot;)
        assert isinstance(branch, tuple)
        assert len(branch) == 3
        assert branch[0] in &quot;test&quot;
        assert branch[1] == 2
        assert isinstance(branch[2], str)

        # Fail test
        branch = hgfs._get_branch(repo[0][&quot;repo&quot;], &quot;fake&quot;)
        assert branch is False


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_all_bookmarks(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repos = hgfs.init()
        hgfs.update()
        for repo in repos:
            repo[&quot;repo&quot;].open()
            bookmarks = hgfs._all_bookmarks(repo[&quot;repo&quot;])
            assert isinstance(bookmarks, list)
            if isinstance(bookmarks, list):
                for value in bookmarks:
                    assert isinstance(value, tuple)
                    assert len(value) == 3
                    assert value[0] in [&quot;bookmark_test&quot;]
                    assert value[1] == 2
                    assert isinstance(value[2], str)


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_get_bookmark(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repo = hgfs.init()
        hgfs.update()
        repo[0][&quot;repo&quot;].open()
        bookmark = hgfs._get_bookmark(repo[0][&quot;repo&quot;], &quot;bookmark_test&quot;)
        assert isinstance(bookmark, tuple)
        assert len(bookmark) == 3
        assert bookmark[0] in &quot;bookmark_test&quot;
        assert bookmark[1] == 2
        assert isinstance(bookmark[2], str)

        # Fail test
        bookmark = hgfs._get_bookmark(repo[0][&quot;repo&quot;], &quot;fake&quot;)
        assert bookmark is False


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_all_tags(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repos = hgfs.init()
        hgfs.update()
        for repo in repos:
            repo[&quot;repo&quot;].open()
            tags = hgfs._all_tags(repo[&quot;repo&quot;])
            assert isinstance(tags, list)
            if isinstance(tags, list):
                for value in tags:
                    assert isinstance(value, tuple)
                    assert len(value) == 4
                    assert value[0] in [&quot;test&quot;]
                    assert value[0] not in [&quot;tip&quot;]
                    assert value[1] == 0
                    assert isinstance(value[2], str)
                    assert value[3] is False


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_get_tag(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repo = hgfs.init()
        hgfs.update()
        repo[0][&quot;repo&quot;].open()
        tag = hgfs._get_tag(repo[0][&quot;repo&quot;], &quot;test&quot;)
        assert isinstance(tag, tuple)
        assert len(tag) == 4
        assert tag[0] in &quot;test&quot;
        assert tag[1] == 0
        assert isinstance(tag[2], str)

        # Fail test
        tag = hgfs._get_tag(repo[0][&quot;repo&quot;], &quot;fake&quot;)
        assert tag is False

        # real tag that should fail
        tag = hgfs._get_tag(repo[0][&quot;repo&quot;], &quot;tip&quot;)
        assert tag is False


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_get_ref(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repo = hgfs.init()[0]
        hgfs.update()
        repo[&quot;repo&quot;].open()
        ref = hgfs._get_ref(repo, &quot;base&quot;)
        assert isinstance(ref, tuple)
        assert len(ref) == 3
        assert ref[0] == &quot;default&quot;
        assert ref[1] == 1
        assert isinstance(ref[2], str)

    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [
                {str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;bookmark_test&quot;}]}
            ],
            &quot;hgfs_branch_method&quot;: &quot;bookmarks&quot;,
        },
    ):
        repo = hgfs.init()[0]
        hgfs.update()
        repo[&quot;repo&quot;].open()
        ref = hgfs._get_ref(repo, &quot;base&quot;)
        assert isinstance(ref, tuple)
        assert len(ref) == 3
        assert ref[0] in &quot;bookmark_test&quot;
        assert ref[1] == 2
        assert isinstance(ref[2], str)

    # Fail test
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repo = hgfs.init()[0]
        hgfs.update()
        repo[&quot;repo&quot;].open()
        ref = hgfs._get_ref(repo, &quot;fake&quot;)
        assert ref is False


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_get_manifest(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        repo = hgfs.init()[0]
        hgfs.update()
        repo[&quot;repo&quot;].open()
        ref = hgfs._get_ref(repo, &quot;base&quot;)
        manifest = hgfs._get_manifest(repo[&quot;repo&quot;], ref=ref)
        assert isinstance(manifest, list)
        for value in manifest:
            assert len(value) == 5
            assert isinstance(value[0], str)
            assert value[1] == &quot;644&quot;
            assert value[2] is False
            assert value[3] is False
            assert value[4] in [
                &quot;test.sls&quot;,
                &quot;test2.sls&quot;,
                &quot;.hgtags&quot;,
                &quot;subdir/test.sls&quot;,
                &quot;subdir/test2.sls&quot;,
            ]


<A NAME="0"></A>@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_envs(hgfs_setup_and_teardown):
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match213953-0.html#0',2,'match213953-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
            &quot;hgfs_branch_method&quot;: &quot;branches&quot;,
        },
    ):
        hgfs.init()
        hgfs.update(</B></FONT>)
        envs = hgfs.envs(ignore_cache=True)
        assert isinstance(envs, list)
        assert envs == [&quot;base&quot;, &quot;test&quot;]
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [
                {str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;bookmark_test&quot;}]}
            ],
            &quot;hgfs_branch_method&quot;: &quot;bookmarks&quot;,
        },
    ):
        hgfs.init()
        hgfs.update()
        envs = hgfs.envs(ignore_cache=True)
        assert isinstance(envs, list)

        # apperently test is coming from the tags which will always be included in the envs unless blacklisted.
        # Do we really want that behavior?
        assert envs == [&quot;base&quot;, &quot;test&quot;]


@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_env_is_exposed_blacklist():
    with patch.dict(
        hgfs.__opts__,
        {&quot;hgfs_saltenv_whitelist&quot;: &quot;&quot;, &quot;hgfs_saltenv_blacklist&quot;: &quot;test&quot;},
    ):
        hgfs.init()
        hgfs.update()
        assert hgfs._env_is_exposed(&quot;base&quot;) is True
        assert hgfs._env_is_exposed(&quot;test&quot;) is False
        assert hgfs._env_is_exposed(&quot;unset&quot;) is True


@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_env_is_exposed_whitelist():
    with patch.dict(
        hgfs.__opts__,
        {&quot;hgfs_saltenv_whitelist&quot;: &quot;base&quot;, &quot;hgfs_saltenv_blacklist&quot;: &quot;&quot;},
    ):
        hgfs.init()
        hgfs.update()
        assert hgfs._env_is_exposed(&quot;base&quot;) is True
        assert hgfs._env_is_exposed(&quot;test&quot;) is False
        assert hgfs._env_is_exposed(&quot;unset&quot;) is False


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_find_file(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        hgfs.init()
        hgfs.update()
        file = hgfs.find_file(path=&quot;test.sls&quot;, tgt_env=&quot;base&quot;)
        assert file[&quot;path&quot;] == hgfs.__opts__[&quot;cachedir&quot;] + &quot;/hgfs/refs/base/test.sls&quot;
        assert file[&quot;rel&quot;] == &quot;test.sls&quot;
        assert isinstance(file[&quot;stat&quot;], list)
        for i in file[&quot;stat&quot;]:
            assert isinstance(i, int)


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_serve_file(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        hgfs.init()
        hgfs.update()
        file = hgfs.find_file(path=&quot;test.sls&quot;, tgt_env=&quot;base&quot;)
        load = {&quot;saltenv&quot;: &quot;base&quot;, &quot;loc&quot;: 0, &quot;path&quot;: &quot;test.sls&quot;}
        data = hgfs.serve_file(load, file)
        assert data == {
            &quot;data&quot;: &quot;always-passes:\n  test.succeed_without_changes:\n    - name: foo\n&quot;,
            &quot;dest&quot;: &quot;test.sls&quot;,
        }


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_file_hash(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        hgfs.init()
        hgfs.update()
        file = hgfs.find_file(path=&quot;test.sls&quot;, tgt_env=&quot;base&quot;)
        load = {&quot;saltenv&quot;: &quot;base&quot;, &quot;loc&quot;: 0, &quot;path&quot;: &quot;test.sls&quot;}
        data = hgfs.file_hash(load, file)
        assert data == {
            &quot;hash_type&quot;: &quot;sha256&quot;,
            &quot;hsum&quot;: &quot;a6a48d90dce9c9b580efb2ed308af100a8328913dcf9441705125866551c7d8d&quot;,
        }


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_file_list(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        hgfs.init()
        hgfs.update()
        load = {&quot;saltenv&quot;: &quot;base&quot;, &quot;loc&quot;: 0, &quot;path&quot;: &quot;test.sls&quot;}
        data = hgfs.file_list(load)
        assert data == [
            &quot;.hgtags&quot;,
            &quot;subdir/test.sls&quot;,
            &quot;subdir/test2.sls&quot;,
            &quot;test.sls&quot;,
            &quot;test2.sls&quot;,
        ]


@pytest.mark.slow_test
@pytest.mark.skip_on_windows(reason=&quot;testing break in windows&quot;)
def test_dir_list(hgfs_setup_and_teardown):
    with patch.dict(
        hgfs.__opts__,
        {
            &quot;hgfs_remotes&quot;: [{str(hgfs_setup_and_teardown): [{&quot;base&quot;: &quot;default&quot;}]}],
        },
    ):
        hgfs.init()
        hgfs.update()
        load = {&quot;saltenv&quot;: &quot;base&quot;, &quot;loc&quot;: 0, &quot;path&quot;: &quot;test.sls&quot;}
        data = hgfs.dir_list(load)
        assert data == [&quot;subdir&quot;]
</PRE>
</div>
  </div>
</body>
</html>
