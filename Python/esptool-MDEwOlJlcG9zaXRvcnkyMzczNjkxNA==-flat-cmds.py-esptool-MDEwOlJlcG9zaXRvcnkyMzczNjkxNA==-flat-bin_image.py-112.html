
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-cmds.py</h3>
            <pre><code>1  import hashlib
2  import io
3  import os
4  import struct
5  import sys
6  import time
7  import zlib
8  from .bin_image import ELFFile, ImageSegment, LoadFirmwareImage
9  from .bin_image import (
10      ESP8266ROMFirmwareImage,
11      ESP8266V2FirmwareImage,
12      ESP8266V3FirmwareImage,
13  )
14  from .loader import (
15      DEFAULT_CONNECT_ATTEMPTS,
16      DEFAULT_TIMEOUT,
17      ERASE_WRITE_TIMEOUT_PER_MB,
18      ESPLoader,
19      timeout_per_mb,
20  )
21  from .targets import CHIP_DEFS, CHIP_LIST, ROM_LIST
22  from .util import (
23      FatalError,
24      NotImplementedInROMError,
25      NotSupportedError,
26      UnsupportedCommandError,
27  )
28  from .util import (
29      div_roundup,
30      flash_size_bytes,
31      get_file_size,
32      hexify,
33      pad_to,
34      print_overwrite,
35  )
36  DETECTED_FLASH_SIZES = {
37      0x12: &quot;256KB&quot;,
38      0x13: &quot;512KB&quot;,
39      0x14: &quot;1MB&quot;,
40      0x15: &quot;2MB&quot;,
41      0x16: &quot;4MB&quot;,
42      0x17: &quot;8MB&quot;,
43      0x18: &quot;16MB&quot;,
44      0x19: &quot;32MB&quot;,
45      0x1A: &quot;64MB&quot;,
46      0x1B: &quot;128MB&quot;,
47      0x1C: &quot;256MB&quot;,
48      0x20: &quot;64MB&quot;,
49      0x21: &quot;128MB&quot;,
50      0x22: &quot;256MB&quot;,
51      0x32: &quot;256KB&quot;,
52      0x33: &quot;512KB&quot;,
53      0x34: &quot;1MB&quot;,
54      0x35: &quot;2MB&quot;,
55      0x36: &quot;4MB&quot;,
56      0x37: &quot;8MB&quot;,
57      0x38: &quot;16MB&quot;,
58      0x39: &quot;32MB&quot;,
59      0x3A: &quot;64MB&quot;,
60  }
61  FLASH_MODES = {&quot;qio&quot;: 0, &quot;qout&quot;: 1, &quot;dio&quot;: 2, &quot;dout&quot;: 3}
62  def detect_chip(
63      port=ESPLoader.DEFAULT_PORT,
64      baud=ESPLoader.ESP_ROM_BAUD,
65      connect_mode=&quot;default_reset&quot;,
66      trace_enabled=False,
67      connect_attempts=DEFAULT_CONNECT_ATTEMPTS,
68  ):
69      inst = None
70      detect_port = ESPLoader(port, baud, trace_enabled=trace_enabled)
71      if detect_port.serial_port.startswith(&quot;rfc2217:&quot;):
72          detect_port.USES_RFC2217 = True
73      detect_port.connect(connect_mode, connect_attempts, detecting=True)
74      try:
75          print(&quot;Detecting chip type...&quot;, end=&quot;&quot;)
76          chip_id = detect_port.get_chip_id()
77          for cls in [
78              n for n in ROM_LIST if n.CHIP_NAME not in (&quot;ESP8266&quot;, &quot;ESP32&quot;, &quot;ESP32S2&quot;)
79          ]:
80              if chip_id == cls.IMAGE_CHIP_ID:
81                  inst = cls(detect_port._port, baud, trace_enabled=trace_enabled)
82                  try:
83                      inst.read_reg(
84                          ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR
85                      )  # Dummy read to check Secure Download mode
86                  except UnsupportedCommandError:
87                      inst.secure_download_mode = True
88                  inst._post_connect()
89                  break
90          else:
91              err_msg = f&quot;Unexpected chip ID value {chip_id}.&quot;
92      except (UnsupportedCommandError, struct.error, FatalError) as e:
93          print(&quot; Unsupported detection protocol, switching and trying again...&quot;)
94          try:
95              if not isinstance(e, struct.error):
96                  detect_port.connect(
97                      connect_mode, connect_attempts, detecting=True, warnings=False
98                  )
99              print(&quot;Detecting chip type...&quot;, end=&quot;&quot;)
100              sys.stdout.flush()
101              chip_magic_value = detect_port.read_reg(
102                  ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR
103              )
104              for cls in ROM_LIST:
105                  if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
106                      inst = cls(detect_port._port, baud, trace_enabled=trace_enabled)
107                      inst._post_connect()
108                      inst.check_chip_id()
109                      break
110              else:
111                  err_msg = f&quot;Unexpected chip magic value {chip_magic_value:#010x}.&quot;
112          except UnsupportedCommandError:
113              raise FatalError(
114                  &quot;Unsupported Command Error received. &quot;
115                  &quot;Probably this means Secure Download Mode is enabled, &quot;
116                  &quot;autodetection will not work. Need to manually specify the chip.&quot;
117              )
118      finally:
119          if inst is not None:
120              print(&quot; %s&quot; % inst.CHIP_NAME, end=&quot;&quot;)
121              if detect_port.sync_stub_detected:
122                  inst = inst.STUB_CLASS(inst)
123                  inst.sync_stub_detected = True
124              print(&quot;&quot;)  # end line
125              return inst
126      raise FatalError(
127          f&quot;{err_msg} Failed to autodetect chip type.&quot;
128          &quot;\nProbably it is unsupported by this version of esptool.&quot;
129      )
130  def load_ram(esp, args):
131      image = LoadFirmwareImage(esp.CHIP_NAME, args.filename)
132      print(&quot;RAM boot...&quot;)
133      for seg in image.segments:
134          size = len(seg.data)
135          print(&quot;Downloading %d bytes at %08x...&quot; % (size, seg.addr), end=&quot; &quot;)
136          sys.stdout.flush()
137          esp.mem_begin(
138              size, div_roundup(size, esp.ESP_RAM_BLOCK), esp.ESP_RAM_BLOCK, seg.addr
139          )
140          seq = 0
141          while len(seg.data) &gt; 0:
142              esp.mem_block(seg.data[0 : esp.ESP_RAM_BLOCK], seq)
143              seg.data = seg.data[esp.ESP_RAM_BLOCK :]
144              seq += 1
145          print(&quot;done!&quot;)
146      print(&quot;All segments done, executing at %08x&quot; % image.entrypoint)
147      esp.mem_finish(image.entrypoint)
148  def read_mem(esp, args):
149      print(&quot;0x%08x = 0x%08x&quot; % (args.address, esp.read_reg(args.address)))
150  def write_mem(esp, args):
151      esp.write_reg(args.address, args.value, args.mask, 0)
152      print(&quot;Wrote %08x, mask %08x to %08x&quot; % (args.value, args.mask, args.address))
153  def dump_mem(esp, args):
154      with open(args.filename, &quot;wb&quot;) as f:
155          for i in range(args.size // 4):
156              d = esp.read_reg(args.address + (i * 4))
157              f.write(struct.pack(b&quot;&lt;I&quot;, d))
158              if f.tell() % 1024 == 0:
159                  print_overwrite(
160                      &quot;%d bytes read... (%d %%)&quot; % (f.tell(), f.tell() * 100 // args.size)
161                  )
162              sys.stdout.flush()
163          print_overwrite(&quot;Read %d bytes&quot; % f.tell(), last_line=True)
164      print(&quot;Done!&quot;)
165  def detect_flash_size(esp, args=None):
166      if esp.secure_download_mode:
167          if args is not None and args.flash_size == &quot;detect&quot;:
168              raise FatalError(
169                  &quot;Detecting flash size is not supported in secure download mode. &quot;
170                  &quot;Need to manually specify flash size.&quot;
171              )
172          else:
173              return None
174      flash_id = esp.flash_id()
175      size_id = flash_id &gt;&gt; 16
176      flash_size = DETECTED_FLASH_SIZES.get(size_id)
177      if args is not None and args.flash_size == &quot;detect&quot;:
178          if flash_size is None:
179              flash_size = &quot;4MB&quot;
180              print(
181                  &quot;Warning: Could not auto-detect Flash size &quot;
182                  f&quot;(FlashID={flash_id:#x}, SizeID={size_id:#x}), defaulting to 4MB&quot;
183              )
184          else:
185              print(&quot;Auto-detected Flash size:&quot;, flash_size)
186          args.flash_size = flash_size
187      return flash_size
188  def _update_image_flash_params(esp, address, args, image):
189      if len(image) &lt; 8:
190          return image  # not long enough to be a bootloader image
191      magic, _, flash_mode, flash_size_freq = struct.unpack(&quot;BBBB&quot;, image[:4])
192      if address != esp.BOOTLOADER_FLASH_OFFSET:
193          return image  # not flashing bootloader offset, so don&#x27;t modify this
194      if (args.flash_mode, args.flash_freq, args.flash_size) == (&quot;keep&quot;,) * 3:
195          return image  # all settings are &#x27;keep&#x27;, not modifying anything
196      if magic != esp.ESP_IMAGE_MAGIC:
197          print(
198              &quot;Warning: Image file at 0x%x doesn&#x27;t look like an image file, &quot;
199              &quot;so not changing any flash settings.&quot; % address
200          )
201          return image
202      try:
203          test_image = esp.BOOTLOADER_IMAGE(io.BytesIO(image))
204          test_image.verify()
205      except Exception:
206          print(
207              &quot;Warning: Image file at 0x%x is not a valid %s image, &quot;
208              &quot;so not changing any flash settings.&quot; % (address, esp.CHIP_NAME)
209          )
210          return image
211      sha_implies_keep = args.chip != &quot;esp8266&quot; and image[8 + 15] == 1
212      def print_keep_warning(arg_to_keep, arg_used):
213          print(
214              &quot;Warning: Image file at {addr} is protected with a hash checksum, &quot;
215              &quot;so not changing the flash {arg} setting. &quot;
216              &quot;Use the --flash_{arg}=keep option instead of --flash_{arg}={arg_orig} &quot;
217              &quot;in order to remove this warning, or use the --dont-append-digest option &quot;
218              &quot;for the elf2image command in order to generate an image file &quot;
219              &quot;without a hash checksum&quot;.format(
220                  addr=hex(address), arg=arg_to_keep, arg_orig=arg_used
221              )
222          )
223      if args.flash_mode != &quot;keep&quot;:
224          new_flash_mode = FLASH_MODES[args.flash_mode]
225          if flash_mode != new_flash_mode and sha_implies_keep:
226              print_keep_warning(&quot;mode&quot;, args.flash_mode)
227          else:
228              flash_mode = new_flash_mode
229      flash_freq = flash_size_freq &amp; 0x0F
230      if args.flash_freq != &quot;keep&quot;:
231          new_flash_freq = esp.parse_flash_freq_arg(args.flash_freq)
232          if flash_freq != new_flash_freq and sha_implies_keep:
233              print_keep_warning(&quot;frequency&quot;, args.flash_freq)
234          else:
235              flash_freq = new_flash_freq
236      flash_size = flash_size_freq &amp; 0xF0
237      if args.flash_size != &quot;keep&quot;:
238          new_flash_size = esp.parse_flash_size_arg(args.flash_size)
239          if flash_size != new_flash_size and sha_implies_keep:
240              print_keep_warning(&quot;size&quot;, args.flash_size)
241          else:
242              flash_size = new_flash_size
243      flash_params = struct.pack(b&quot;BB&quot;, flash_mode, flash_size + flash_freq)
244      if flash_params != image[2:4]:
245          print(&quot;Flash params set to 0x%04x&quot; % struct.unpack(&quot;&gt;H&quot;, flash_params))
246          image = image[0:2] + flash_params + image[4:]
247      return image
248  def write_flash(esp, args):
249      if args.compress is None and not args.no_compress:
250          args.compress = not args.no_stub
251      if not args.force and esp.CHIP_NAME != &quot;ESP8266&quot; and not esp.secure_download_mode:
252          if esp.get_secure_boot_enabled():
253              for address, _ in args.addr_filename:
254                  if address &lt; 0x8000:
255                      raise FatalError(
256                          &quot;Secure Boot detected, writing to flash regions &lt; 0x8000 &quot;
257                          &quot;is disabled to protect the bootloader. &quot;
258                          &quot;Use --force to override, &quot;
259                          &quot;please use with caution, otherwise it may brick your device!&quot;
260                      )
261          for _, argfile in args.addr_filename:
262              try:
263                  image = LoadFirmwareImage(esp.CHIP_NAME, argfile)
264              except (FatalError, struct.error, RuntimeError):
265                  continue
266              finally:
267                  argfile.seek(0)  # LoadFirmwareImage changes the file handle position
268              if image.chip_id != esp.IMAGE_CHIP_ID:
269                  raise FatalError(
270                      f&quot;{argfile.name} is not an {esp.CHIP_NAME} image. &quot;
271                      &quot;Use --force to flash anyway.&quot;
272                  )
273              if image.max_rev_full == 0:  # image does not have max/min_rev_full fields
274                  use_rev_full_fields = False
275              elif image.max_rev_full == 65535:  # image has default value of max_rev_full
276                  use_rev_full_fields = True
277                  if (
278                      image.min_rev_full == 0 and image.min_rev != 0
279                  ):  # min_rev_full is not set, min_rev is used
280                      use_rev_full_fields = False
281              else:  # max_rev_full set to a version
282                  use_rev_full_fields = True
283              if use_rev_full_fields:
284                  rev = esp.get_chip_revision()
285                  if rev &lt; image.min_rev_full or rev &gt; image.max_rev_full:
286                      error_str = f&quot;{argfile.name} requires chip revision in range &quot;
287                      error_str += (
288                          f&quot;[v{image.min_rev_full // 100}.{image.min_rev_full % 100} - &quot;
289                      )
290                      if image.max_rev_full == 65535:
291                          error_str += &quot;max rev not set] &quot;
292                      else:
293                          error_str += (
294                              f&quot;v{image.max_rev_full // 100}.{image.max_rev_full % 100}] &quot;
295                          )
296                      error_str += f&quot;(this chip is revision v{rev // 100}.{rev % 100})&quot;
297                      raise FatalError(f&quot;{error_str}. Use --force to flash anyway.&quot;)
298              else:
299                  if esp.CHIP_NAME == &quot;ESP32-C3&quot;:
300                      rev = esp.get_minor_chip_version()
301                  else:
302                      rev = esp.get_major_chip_version()
303                  if rev &lt; image.min_rev:
304                      raise FatalError(
305                          f&quot;{argfile.name} requires chip revision &quot;
306                          f&quot;{image.min_rev} or higher (this chip is revision {rev}). &quot;
307                          &quot;Use --force to flash anyway.&quot;
308                      )
309      if args.encrypt or args.encrypt_files is not None:
310          do_write = True
311          if not esp.secure_download_mode:
312              if esp.get_encrypted_download_disabled():
313                  raise FatalError(
314                      &quot;This chip has encrypt functionality &quot;
315                      &quot;in UART download mode disabled. &quot;
316                      &quot;This is the Flash Encryption configuration for Production mode &quot;
317                      &quot;instead of Development mode.&quot;
318                  )
319              crypt_cfg_efuse = esp.get_flash_crypt_config()
320              if crypt_cfg_efuse is not None and crypt_cfg_efuse != 0xF:
321                  print(&quot;Unexpected FLASH_CRYPT_CONFIG value: 0x%x&quot; % (crypt_cfg_efuse))
322                  do_write = False
323              enc_key_valid = esp.is_flash_encryption_key_valid()
324              if not enc_key_valid:
325                  print(&quot;Flash encryption key is not programmed&quot;)
326                  do_write = False
327          files_to_encrypt = args.addr_filename if args.encrypt else args.encrypt_files
328          for address, argfile in files_to_encrypt:
329              if address % esp.FLASH_ENCRYPTED_WRITE_ALIGN:
330                  print(
331                      &quot;File %s address 0x%x is not %d byte aligned, can&#x27;t flash encrypted&quot;
332                      % (argfile.name, address, esp.FLASH_ENCRYPTED_WRITE_ALIGN)
333                  )
334                  do_write = False
335          if not do_write and not args.ignore_flash_encryption_efuse_setting:
336              raise FatalError(
337                  &quot;Can&#x27;t perform encrypted flash write, &quot;
338                  &quot;consult Flash Encryption documentation for more information&quot;
339              )
340      else:
341          if not args.force and esp.CHIP_NAME != &quot;ESP8266&quot;:
342              if (
343                  esp.CHIP_NAME != &quot;ESP32&quot;
344                  and esp.secure_download_mode
345                  and bin(esp.get_security_info()[&quot;flash_crypt_cnt&quot;]).count(&quot;1&quot;) &amp; 1 != 0
346              ):
347                  raise FatalError(
348                      &quot;WARNING: Detected flash encryption and &quot;
349                      &quot;secure download mode enabled.\n&quot;
350                      &quot;Flashing plaintext binary may brick your device! &quot;
351                      &quot;Use --force to override the warning.&quot;
352                  )
353              if (
354                  not esp.secure_download_mode
355                  and esp.get_encrypted_download_disabled()
356                  and esp.get_flash_encryption_enabled()
357              ):
358                  raise FatalError(
359                      &quot;WARNING: Detected flash encryption enabled and &quot;
360                      &quot;download manual encrypt disabled.\n&quot;
361                      &quot;Flashing plaintext binary may brick your device! &quot;
362                      &quot;Use --force to override the warning.&quot;
363                  )
364      flash_end = flash_size_bytes(
365          detect_flash_size(esp) if args.flash_size == &quot;keep&quot; else args.flash_size
366      )
367      if flash_end is not None:  # Secure download mode
368          for address, argfile in args.addr_filename:
369              argfile.seek(0, os.SEEK_END)
370              if address + argfile.tell() &gt; flash_end:
371                  raise FatalError(
372                      &quot;File %s (length %d) at offset %d &quot;
373                      &quot;will not fit in %d bytes of flash. &quot;
374                      &quot;Use --flash_size argument, or change flashing address.&quot;
375                      % (argfile.name, argfile.tell(), address, flash_end)
376                  )
377              argfile.seek(0)
378      if args.erase_all:
379          erase_flash(esp, args)
380      else:
381          for address, argfile in args.addr_filename:
382              argfile.seek(0, os.SEEK_END)
383              write_end = address + argfile.tell()
384              argfile.seek(0)
385              bytes_over = address % esp.FLASH_SECTOR_SIZE
386              if bytes_over != 0:
387                  print(
388                      &quot;WARNING: Flash address {:#010x} is not aligned &quot;
389                      &quot;to a {:#x} byte flash sector. &quot;
390                      &quot;{:#x} bytes before this address will be erased.&quot;.format(
391                          address, esp.FLASH_SECTOR_SIZE, bytes_over
392                      )
393                  )
394              print(
395                  &quot;Flash will be erased from {:#010x} to {:#010x}...&quot;.format(
396                      address - bytes_over,
397                      div_roundup(write_end, esp.FLASH_SECTOR_SIZE)
398                      * esp.FLASH_SECTOR_SIZE
399                      - 1,
400                  )
401              )
402      all_files = [
403          (offs, filename, args.encrypt) for (offs, filename) in args.addr_filename
404      ]
405      if args.encrypt_files is not None:
406          encrypted_files_flag = [
407              (offs, filename, True) for (offs, filename) in args.encrypt_files
408          ]
409          all_files = sorted(all_files + encrypted_files_flag, key=lambda x: x[0])
410      for address, argfile, encrypted in all_files:
411          compress = args.compress
412          if compress and encrypted:
413              print(&quot;\nWARNING: - compress and encrypt options are mutually exclusive &quot;)
414              print(&quot;Will flash %s uncompressed&quot; % argfile.name)
415              compress = False
416          if args.no_stub:
417              print(&quot;Erasing flash...&quot;)
418          image = pad_to(
419              argfile.read(), esp.FLASH_ENCRYPTED_WRITE_ALIGN if encrypted else 4
420          )
421          if len(image) == 0:
422              print(&quot;WARNING: File %s is empty&quot; % argfile.name)
423              continue
424          image = _update_image_flash_params(esp, address, args, image)
425          calcmd5 = hashlib.md5(image).hexdigest()
426          uncsize = len(image)
427          if compress:
428              uncimage = image
429              image = zlib.compress(uncimage, 9)
430              decompress = zlib.decompressobj()
431              blocks = esp.flash_defl_begin(uncsize, len(image), address)
432          else:
433              blocks = esp.flash_begin(uncsize, address, begin_rom_encrypted=encrypted)
434          argfile.seek(0)  # in case we need it again
435          seq = 0
436          bytes_sent = 0  # bytes sent on wire
437          bytes_written = 0  # bytes written to flash
438          t = time.time()
439          timeout = DEFAULT_TIMEOUT
440          while len(image) &gt; 0:
441              print_overwrite(
442                  &quot;Writing at 0x%08x... (%d %%)&quot;
443                  % (address + bytes_written, 100 * (seq + 1) // blocks)
444              )
445              sys.stdout.flush()
446              block = image[0 : esp.FLASH_WRITE_SIZE]
447              if compress:
448                  block_uncompressed = len(decompress.decompress(block))
449                  bytes_written += block_uncompressed
450                  block_timeout = max(
451                      DEFAULT_TIMEOUT,
452                      timeout_per_mb(ERASE_WRITE_TIMEOUT_PER_MB, block_uncompressed),
453                  )
454                  if not esp.IS_STUB:
455                      timeout = (
456                          block_timeout  # ROM code writes block to flash before ACKing
457                      )
458                  esp.flash_defl_block(block, seq, timeout=timeout)
459                  if esp.IS_STUB:
460                      timeout = block_timeout
461              else:
462                  block = block + b&quot;\xff&quot; * (esp.FLASH_WRITE_SIZE - len(block))
463                  if encrypted:
464                      esp.flash_encrypt_block(block, seq)
465                  else:
466                      esp.flash_block(block, seq)
467                  bytes_written += len(block)
468              bytes_sent += len(block)
469              image = image[esp.FLASH_WRITE_SIZE :]
470              seq += 1
471          if esp.IS_STUB:
472              esp.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR, timeout=timeout)
473          t = time.time() - t
474          speed_msg = &quot;&quot;
475          if compress:
476              if t &gt; 0.0:
477                  speed_msg = &quot; (effective %.1f kbit/s)&quot; % (uncsize / t * 8 / 1000)
478              print_overwrite(
479                  &quot;Wrote %d bytes (%d compressed) at 0x%08x in %.1f seconds%s...&quot;
480                  % (uncsize, bytes_sent, address, t, speed_msg),
481                  last_line=True,
482              )
483          else:
484              if t &gt; 0.0:
485                  speed_msg = &quot; (%.1f kbit/s)&quot; % (bytes_written / t * 8 / 1000)
486              print_overwrite(
487                  &quot;Wrote %d bytes at 0x%08x in %.1f seconds%s...&quot;
488                  % (bytes_written, address, t, speed_msg),
489                  last_line=True,
490              )
491          if not encrypted and not esp.secure_download_mode:
492              try:
493                  res = esp.flash_md5sum(address, uncsize)
494                  if res != calcmd5:
495                      print(&quot;File  md5: %s&quot; % calcmd5)
496                      print(&quot;Flash md5: %s&quot; % res)
497                      print(
498                          &quot;MD5 of 0xFF is %s&quot;
499                          % (hashlib.md5(b&quot;\xFF&quot; * uncsize).hexdigest())
500                      )
501                      raise FatalError(&quot;MD5 of file does not match data in flash!&quot;)
502                  else:
503                      print(&quot;Hash of data verified.&quot;)
504              except NotImplementedInROMError:
505                  pass
506      print(&quot;\nLeaving...&quot;)
507      if esp.IS_STUB:
508          esp.flash_begin(0, 0)
509          last_file_encrypted = all_files[-1][2]
510          if args.compress and not last_file_encrypted:
511              esp.flash_defl_finish(False)
512          else:
513              esp.flash_finish(False)
514      if args.verify:
515          print(&quot;Verifying just-written flash...&quot;)
516          print(
517              &quot;(This option is deprecated, &quot;
518              &quot;flash contents are now always read back after flashing.)&quot;
519          )
520          if args.encrypt or args.encrypt_files is not None:
521              print(&quot;WARNING: - cannot verify encrypted files, they will be ignored&quot;)
522          if not args.encrypt:
523              verify_flash(esp, args)
524  def image_info(args):
525      def v2():
526          def get_key_from_value(dict, val):
527              for key, value in dict.items():
528                  if value == val:
529                      return key
530              return None
531          print()
532          title = &quot;{} image header&quot;.format(args.chip.upper())
533          print(title)
534          print(&quot;=&quot; * len(title))
535          print(&quot;Image version: {}&quot;.format(image.version))
536          print(
537              &quot;Entry point: {:#8x}&quot;.format(image.entrypoint)
538              if image.entrypoint != 0
539              else &quot;Entry point not set&quot;
540          )
541          print(&quot;Segments: {}&quot;.format(len(image.segments)))
542          flash_s_bits = image.flash_size_freq &amp; 0xF0  # high four bits
543          flash_s = get_key_from_value(image.ROM_LOADER.FLASH_SIZES, flash_s_bits)
544          print(
545              &quot;Flash size: {}&quot;.format(flash_s)
546              if flash_s is not None
547              else &quot;WARNING: Invalid flash size ({:#02x})&quot;.format(flash_s_bits)
548          )
549          flash_fr_bits = image.flash_size_freq &amp; 0x0F  # low four bits
550          flash_fr = get_key_from_value(image.ROM_LOADER.FLASH_FREQUENCY, flash_fr_bits)
551          print(
552              &quot;Flash freq: {}&quot;.format(flash_fr)
553              if flash_fr is not None
554              else &quot;WARNING: Invalid flash frequency ({:#02x})&quot;.format(flash_fr_bits)
555          )
556          flash_mode = get_key_from_value(FLASH_MODES, image.flash_mode)
557          print(
558              &quot;Flash mode: {}&quot;.format(flash_mode.upper())
559              if flash_mode is not None
560              else &quot;WARNING: Invalid flash mode ({})&quot;.format(image.flash_mode)
561          )
562          if args.chip != &quot;esp8266&quot;:
563              print()
564              title = &quot;{} extended image header&quot;.format(args.chip.upper())
565              print(title)
566              print(&quot;=&quot; * len(title))
567              print(
568                  f&quot;WP pin: {image.wp_pin:#02x}&quot;,
569                  *[&quot;(disabled)&quot;] if image.wp_pin == image.WP_PIN_DISABLED else [],
570              )
571              print(
572                  &quot;Flash pins drive settings: &quot;
573                  &quot;clk_drv: {:#02x}, q_drv: {:#02x}, d_drv: {:#02x}, &quot;
574                  &quot;cs0_drv: {:#02x}, hd_drv: {:#02x}, wp_drv: {:#02x}&quot;.format(
575                      image.clk_drv,
576                      image.q_drv,
577                      image.d_drv,
578                      image.cs_drv,
579                      image.hd_drv,
580                      image.wp_drv,
581                  )
582              )
583              try:
584                  chip = next(
585                      chip
586                      for chip in CHIP_DEFS.values()
587                      if getattr(chip, &quot;IMAGE_CHIP_ID&quot;, None) == image.chip_id
588                  )
589                  print(f&quot;Chip ID: {image.chip_id} ({chip.CHIP_NAME})&quot;)
590              except StopIteration:
591                  print(f&quot;Chip ID: {image.chip_id} (Unknown ID)&quot;)
592              print(
593                  &quot;Minimal chip revision: &quot;
594                  f&quot;v{image.min_rev_full // 100}.{image.min_rev_full % 100}, &quot;
595                  f&quot;(legacy min_rev = {image.min_rev})&quot;
596              )
597              print(
598                  &quot;Maximal chip revision: &quot;
599                  f&quot;v{image.max_rev_full // 100}.{image.max_rev_full % 100}&quot;
600              )
601          print()
602          title = &quot;Segments information&quot;
603          print(title)
604          print(&quot;=&quot; * len(title))
605          headers_str = &quot;{:&gt;7}  {:&gt;7}  {:&gt;10}  {:&gt;10}  {:10}&quot;
606          print(
607              headers_str.format(
608                  &quot;Segment&quot;, &quot;Length&quot;, &quot;Load addr&quot;, &quot;File offs&quot;, &quot;Memory types&quot;
609              )
610          )
611          print(
612              &quot;{}  {}  {}  {}  {}&quot;.format(&quot;-&quot; * 7, &quot;-&quot; * 7, &quot;-&quot; * 10, &quot;-&quot; * 10, &quot;-&quot; * 12)
613          )
614          format_str = &quot;{:7}  {:#07x}  {:#010x}  {:#010x}  {}&quot;
615          app_desc = None
616          bootloader_desc = None
617          for idx, seg in enumerate(image.segments, start=1):
618              segs = seg.get_memory_type(image)
619              seg_name = &quot;, &quot;.join(segs)
620              if &quot;DROM&quot; in segs:  # The DROM segment starts with the esp_app_desc_t struct
621                  app_desc = seg.data[:256]
622              elif &quot;DRAM&quot; in segs:
623                  if len(seg.data) &gt;= 80:
624                      bootloader_desc = seg.data[:80]
625              print(
626                  format_str.format(idx, len(seg.data), seg.addr, seg.file_offs, seg_name)
627              )
628          print()
629          title = f&quot;{args.chip.upper()} image footer&quot;
630          print(title)
631          print(&quot;=&quot; * len(title))
632          calc_checksum = image.calculate_checksum()
633          print(
634              &quot;Checksum: {:#02x} ({})&quot;.format(
635                  image.checksum,
636                  &quot;valid&quot;
637                  if image.checksum == calc_checksum
638                  else &quot;invalid - calculated {:02x}&quot;.format(calc_checksum),
639              )
640          )
641          try:
642              digest_msg = &quot;Not appended&quot;
643              if image.append_digest:
644                  is_valid = image.stored_digest == image.calc_digest
645                  digest_msg = &quot;{} ({})&quot;.format(
646                      hexify(image.calc_digest, uppercase=False),
647                      &quot;valid&quot; if is_valid else &quot;invalid&quot;,
648                  )
649                  print(&quot;Validation hash: {}&quot;.format(digest_msg))
650          except AttributeError:
651              pass  # ESP8266 image has no append_digest field
652          if app_desc:
653              APP_DESC_STRUCT_FMT = &quot;&lt;II&quot; + &quot;8s&quot; + &quot;32s32s16s16s32s32s&quot; + &quot;80s&quot;
654              (
655                  magic_word,
656                  secure_version,
657                  reserv1,
658                  version,
659                  project_name,
660                  time,
661                  date,
662                  idf_ver,
663                  app_elf_sha256,
664                  reserv2,
665              ) = struct.unpack(APP_DESC_STRUCT_FMT, app_desc)
666              if magic_word == 0xABCD5432:
667                  print()
668                  title = &quot;Application information&quot;
669                  print(title)
670                  print(&quot;=&quot; * len(title))
671                  print(f&#x27;Project name: {project_name.decode(&quot;utf-8&quot;)}&#x27;)
672                  print(f&#x27;App version: {version.decode(&quot;utf-8&quot;)}&#x27;)
673                  print(f&#x27;Compile time: {date.decode(&quot;utf-8&quot;)} {time.decode(&quot;utf-8&quot;)}&#x27;)
674                  print(f&quot;ELF file SHA256: {hexify(app_elf_sha256, uppercase=False)}&quot;)
675                  print(f&#x27;ESP-IDF: {idf_ver.decode(&quot;utf-8&quot;)}&#x27;)
676                  print(f&quot;Secure version: {secure_version}&quot;)
677          elif bootloader_desc:
678              BOOTLOADER_DESC_STRUCT_FMT = &quot;&lt;B&quot; + &quot;3s&quot; + &quot;I32s24s&quot; + &quot;16s&quot;
679              (
680                  magic_byte,
681                  reserved,
682                  version,
683                  idf_ver,
684                  date_time,
685                  reserved2,
686              ) = struct.unpack(BOOTLOADER_DESC_STRUCT_FMT, bootloader_desc)
687              if magic_byte == 80:
688                  print()
689                  title = &quot;Bootloader information&quot;
690                  print(title)
691                  print(&quot;=&quot; * len(title))
692                  print(f&quot;Bootloader version: {version}&quot;)
693                  print(f&#x27;ESP-IDF: {idf_ver.decode(&quot;utf-8&quot;)}&#x27;)
694                  print(f&#x27;Compile time: {date_time.decode(&quot;utf-8&quot;)}&#x27;)
695      print(f&quot;File size: {get_file_size(args.filename)} (bytes)&quot;)
696      with open(args.filename, &quot;rb&quot;) as f:
697          try:
698              common_header = f.read(8)
699              magic = common_header[0]
700          except IndexError:
701              raise FatalError(&quot;File is empty&quot;)
702          if magic not in [
703              ESPLoader.ESP_IMAGE_MAGIC,
704              ESP8266V2FirmwareImage.IMAGE_V2_MAGIC,
705          ]:
706              raise FatalError(
707                  &quot;This is not a valid image &quot;
708                  &quot;(invalid magic number: {:#x})&quot;.format(magic)
709              )
710          if args.chip == &quot;auto&quot;:
711              try:
712                  extended_header = f.read(16)
713                  if extended_header[-1] not in [0, 1]:
714                      raise FatalError(&quot;Append digest field not 0 or 1&quot;)
715                  chip_id = int.from_bytes(extended_header[4:5], &quot;little&quot;)
716                  for rom in [n for n in ROM_LIST if n.CHIP_NAME != &quot;ESP8266&quot;]:
717                      if chip_id == rom.IMAGE_CHIP_ID:
718                          args.chip = rom.CHIP_NAME
719                          break
720                  else:
721                      raise FatalError(f&quot;Unknown image chip ID ({chip_id})&quot;)
722              except FatalError:
723                  args.chip = &quot;esp8266&quot;
724              print(f&quot;Detected image type: {args.chip.upper()}&quot;)
725      image = LoadFirmwareImage(args.chip, args.filename)
726      if args.version == &quot;2&quot;:
727          v2()
728          return
729      print(&quot;Image version: {}&quot;.format(image.version))
730      print(
731          &quot;Entry point: {:8x}&quot;.format(image.entrypoint)
732          if image.entrypoint != 0
733          else &quot;Entry point not set&quot;
734      )
735      print(&quot;{} segments&quot;.format(len(image.segments)))
736      print()
737      idx = 0
738      for seg in image.segments:
739          idx += 1
740          segs = seg.get_memory_type(image)
741          seg_name = &quot;,&quot;.join(segs)
742          print(&quot;Segment {}: {} [{}]&quot;.format(idx, seg, seg_name))
743      calc_checksum = image.calculate_checksum()
744      print(
745          &quot;Checksum: {:02x} ({})&quot;.format(
746              image.checksum,
747              &quot;valid&quot;
748              if image.checksum == calc_checksum
749              else &quot;invalid - calculated {:02x}&quot;.format(calc_checksum),
750          )
751      )
752      try:
753          digest_msg = &quot;Not appended&quot;
754          if image.append_digest:
755              is_valid = image.stored_digest == image.calc_digest
756              digest_msg = &quot;{} ({})&quot;.format(
757                  hexify(image.calc_digest, uppercase=False),
758                  &quot;valid&quot; if is_valid else &quot;invalid&quot;,
759              )
760              print(&quot;Validation Hash: {}&quot;.format(digest_msg))
761      except AttributeError:
762          pass  # ESP8266 image has no append_digest field
763  def make_image(args):
764      print(&quot;Creating {} image...&quot;.format(args.chip))
765      image = ESP8266ROMFirmwareImage()
766      if len(args.segfile) == 0:
767          raise FatalError(&quot;No segments specified&quot;)
768      if len(args.segfile) != len(args.segaddr):
769          raise FatalError(
770              &quot;Number of specified files does not match number of specified addresses&quot;
771          )
772      for seg, addr in zip(args.segfile, args.segaddr):
773          with open(seg, &quot;rb&quot;) as f:
774              data = f.read()
775              image.segments.append(ImageSegment(addr, data))
776      image.entrypoint = args.entrypoint
777      image.save(args.output)
778      print(&quot;Successfully created {} image.&quot;.format(args.chip))
779  def elf2image(args):
780      e = ELFFile(args.input)
781      if args.chip == &quot;auto&quot;:  # Default to ESP8266 for backwards compatibility
782          args.chip = &quot;esp8266&quot;
783      print(&quot;Creating {} image...&quot;.format(args.chip))
784      if args.chip != &quot;esp8266&quot;:
785          image = CHIP_DEFS[args.chip].BOOTLOADER_IMAGE()
786          if args.chip == &quot;esp32&quot; and args.secure_pad:
787              image.secure_pad = &quot;1&quot;
788          if args.secure_pad_v2:
789              image.secure_pad = &quot;2&quot;
790          image.min_rev = args.min_rev
791          image.min_rev_full = args.min_rev_full
792          image.max_rev_full = args.max_rev_full
793          image.append_digest = args.append_digest
794      elif args.version == &quot;1&quot;:  # ESP8266
795          image = ESP8266ROMFirmwareImage()
796      elif args.version == &quot;2&quot;:
797          image = ESP8266V2FirmwareImage()
798      else:
799          image = ESP8266V3FirmwareImage()
800      image.entrypoint = e.entrypoint
801      image.flash_mode = FLASH_MODES[args.flash_mode]
802      if args.flash_mmu_page_size:
803          image.set_mmu_page_size(flash_size_bytes(args.flash_mmu_page_size))
804      image.segments = e.segments if args.use_segments else e.sections
805      if args.pad_to_size:
806          image.pad_to_size = flash_size_bytes(args.pad_to_size)
807      image.flash_size_freq = image.ROM_LOADER.parse_flash_size_arg(args.flash_size)
808      image.flash_size_freq += image.ROM_LOADER.parse_flash_freq_arg(args.flash_freq)
809      if args.elf_sha256_offset:
810          image.elf_sha256 = e.sha256()
811          image.elf_sha256_offset = args.elf_sha256_offset
812      before = len(image.segments)
813      image.merge_adjacent_segments()
814      if len(image.segments) != before:
815          delta = before - len(image.segments)
816          print(&quot;Merged %d ELF section%s&quot; % (delta, &quot;s&quot; if delta &gt; 1 else &quot;&quot;))
817      image.verify()
818      if args.output is None:
819          args.output = image.default_output_name(args.input)
820      image.save(args.output)
821      print(&quot;Successfully created {} image.&quot;.format(args.chip))
822  def read_mac(esp, args):
823      def print_mac(label, mac):
824          print(&quot;%s: %s&quot; % (label, &quot;:&quot;.join(map(lambda x: &quot;%02x&quot; % x, mac))))
825      eui64 = esp.read_mac(&quot;EUI64&quot;)
826      if eui64:
827          print_mac(&quot;MAC&quot;, eui64)
828          print_mac(&quot;BASE MAC&quot;, esp.read_mac(&quot;BASE_MAC&quot;))
829          print_mac(&quot;MAC_EXT&quot;, esp.read_mac(&quot;MAC_EXT&quot;))
830      else:
831          print_mac(&quot;MAC&quot;, esp.read_mac(&quot;BASE_MAC&quot;))
832  def chip_id(esp, args):
833      try:
834          chipid = esp.chip_id()
835          print(&quot;Chip ID: 0x%08x&quot; % chipid)
836      except NotSupportedError:
837          print(&quot;Warning: %s has no Chip ID. Reading MAC instead.&quot; % esp.CHIP_NAME)
838          read_mac(esp, args)
839  def erase_flash(esp, args):
840      if not args.force and esp.CHIP_NAME != &quot;ESP8266&quot; and not esp.secure_download_mode:
841          if esp.get_flash_encryption_enabled() or esp.get_secure_boot_enabled():
842              raise FatalError(
843                  &quot;Active security features detected, &quot;
844                  &quot;erasing flash is disabled as a safety measure. &quot;
845                  &quot;Use --force to override, &quot;
846                  &quot;please use with caution, otherwise it may brick your device!&quot;
847              )
848      print(&quot;Erasing flash (this may take a while)...&quot;)
849      t = time.time()
850      esp.erase_flash()
851      print(&quot;Chip erase completed successfully in %.1fs&quot; % (time.time() - t))
852  def erase_region(esp, args):
853      if not args.force and esp.CHIP_NAME != &quot;ESP8266&quot; and not esp.secure_download_mode:
854          if esp.get_flash_encryption_enabled() or esp.get_secure_boot_enabled():
855              raise FatalError(
856                  &quot;Active security features detected, &quot;
857                  &quot;erasing flash is disabled as a safety measure. &quot;
858                  &quot;Use --force to override, &quot;
859                  &quot;please use with caution, otherwise it may brick your device!&quot;
860              )
861      print(&quot;Erasing region (may be slow depending on size)...&quot;)
862      t = time.time()
863      esp.erase_region(args.address, args.size)
864      print(&quot;Erase completed successfully in %.1f seconds.&quot; % (time.time() - t))
865  def run(esp, args):
866      esp.run()
867  def flash_id(esp, args):
868      flash_id = esp.flash_id()
869      print(&quot;Manufacturer: %02x&quot; % (flash_id &amp; 0xFF))
870      flid_lowbyte = (flash_id &gt;&gt; 16) &amp; 0xFF
871      print(&quot;Device: %02x%02x&quot; % ((flash_id &gt;&gt; 8) &amp; 0xFF, flid_lowbyte))
872      print(
873          &quot;Detected flash size: %s&quot; % (DETECTED_FLASH_SIZES.get(flid_lowbyte, &quot;Unknown&quot;))
874      )
875      flash_type = esp.flash_type()
876      flash_type_dict = {0: &quot;quad (4 data lines)&quot;, 1: &quot;octal (8 data lines)&quot;}
877      flash_type_str = flash_type_dict.get(flash_type)
878      if flash_type_str:
879          print(f&quot;Flash type set in eFuse: {flash_type_str}&quot;)
880  def read_flash(esp, args):
881      if args.no_progress:
882          flash_progress = None
883      else:
884          def flash_progress(progress, length):
885              msg = &quot;%d (%d %%)&quot; % (progress, progress * 100.0 / length)
886              padding = &quot;\b&quot; * len(msg)
887              if progress == length:
888                  padding = &quot;\n&quot;
889              sys.stdout.write(msg + padding)
890              sys.stdout.flush()
891      t = time.time()
892      data = esp.read_flash(args.address, args.size, flash_progress)
893      t = time.time() - t
894      speed_msg = &quot; ({:.1f} kbit/s)&quot;.format(len(data) / t * 8 / 1000) if t &gt; 0.0 else &quot;&quot;
895      print_overwrite(
896          &quot;Read {:d} bytes at {:#010x} in {:.1f} seconds{}...&quot;.format(
897              len(data), args.address, t, speed_msg
898          ),
899          last_line=True,
900      )
901      with open(args.filename, &quot;wb&quot;) as f:
902          f.write(data)
903  def verify_flash(esp, args):
904      differences = False
905      for address, argfile in args.addr_filename:
906          image = pad_to(argfile.read(), 4)
907          argfile.seek(0)  # rewind in case we need it again
908          image = _update_image_flash_params(esp, address, args, image)
909          image_size = len(image)
910          print(
911              &quot;Verifying 0x%x (%d) bytes @ 0x%08x in flash against %s...&quot;
912              % (image_size, image_size, address, argfile.name)
913          )
914          digest = esp.flash_md5sum(address, image_size)
915          expected_digest = hashlib.md5(image).hexdigest()
916          if digest == expected_digest:
917              print(&quot;-- verify OK (digest matched)&quot;)
918              continue
919          else:
920              differences = True
921              if getattr(args, &quot;diff&quot;, &quot;no&quot;) != &quot;yes&quot;:
922                  print(&quot;-- verify FAILED (digest mismatch)&quot;)
923                  continue
924          flash = esp.read_flash(address, image_size)
925          assert flash != image
926          diff = [i for i in range(image_size) if flash[i] != image[i]]
927          print(
928              &quot;-- verify FAILED: %d differences, first @ 0x%08x&quot;
929              % (len(diff), address + diff[0])
930          )
931          for d in diff:
932              flash_byte = flash[d]
933              image_byte = image[d]
934              print(&quot;   %08x %02x %02x&quot; % (address + d, flash_byte, image_byte))
935      if differences:
936          raise FatalError(&quot;Verify failed.&quot;)
937  def read_flash_status(esp, args):
938      print(&quot;Status value: 0x%04x&quot; % esp.read_status(args.bytes))
939  def write_flash_status(esp, args):
940      fmt = &quot;0x%%0%dx&quot; % (args.bytes * 2)
941      args.value = args.value &amp; ((1 &lt;&lt; (args.bytes * 8)) - 1)
942      print((&quot;Initial flash status: &quot; + fmt) % esp.read_status(args.bytes))
943      print((&quot;Setting flash status: &quot; + fmt) % args.value)
944      esp.write_status(args.value, args.bytes, args.non_volatile)
945      print((&quot;After flash status:   &quot; + fmt) % esp.read_status(args.bytes))
946  def get_security_info(esp, args):
947      si = esp.get_security_info()
948      print(&quot;Flags: {:#010x} ({})&quot;.format(si[&quot;flags&quot;], bin(si[&quot;flags&quot;])))
949      print(&quot;Flash_Crypt_Cnt: {:#x}&quot;.format(si[&quot;flash_crypt_cnt&quot;]))
950      print(&quot;Key_Purposes: {}&quot;.format(si[&quot;key_purposes&quot;]))
951      if si[&quot;chip_id&quot;] is not None and si[&quot;api_version&quot;] is not None:
952          print(&quot;Chip_ID: {}&quot;.format(si[&quot;chip_id&quot;]))
953          print(&quot;Api_Version: {}&quot;.format(si[&quot;api_version&quot;]))
954  def merge_bin(args):
955      try:
956          chip_class = CHIP_DEFS[args.chip]
957      except KeyError:
958          msg = (
959              &quot;Please specify the chip argument&quot;
960              if args.chip == &quot;auto&quot;
961              else &quot;Invalid chip choice: &#x27;{}&#x27;&quot;.format(args.chip)
962          )
963          msg = msg + &quot; (choose from {})&quot;.format(&quot;, &quot;.join(CHIP_LIST))
964          raise FatalError(msg)
965      input_files = sorted(args.addr_filename, key=lambda x: x[0])
966      if not input_files:
967          raise FatalError(&quot;No input files specified&quot;)
968      first_addr = input_files[0][0]
969      if first_addr &lt; args.target_offset:
<span onclick='openModal()' class='match'>970          raise FatalError(
971              &quot;Output file target offset is 0x%x. Input file offset 0x%x is before this.&quot;
972              % (args.target_offset, first_addr)
973          )
974      if args.format != &quot;raw&quot;:
</span>975          raise FatalError(
976              &quot;This version of esptool only supports the &#x27;raw&#x27; output format&quot;
977          )
978      with open(args.output, &quot;wb&quot;) as of:
979          def pad_to(flash_offs):
980              of.write(b&quot;\xFF&quot; * (flash_offs - args.target_offset - of.tell()))
981          for addr, argfile in input_files:
982              pad_to(addr)
983              image = argfile.read()
984              image = _update_image_flash_params(chip_class, addr, args, image)
985              of.write(image)
986          if args.fill_flash_size:
987              pad_to(flash_size_bytes(args.fill_flash_size))
988          print(
989              &quot;Wrote 0x%x bytes to file %s, ready to flash to offset 0x%x&quot;
990              % (of.tell(), args.output, args.target_offset)
991          )
992  def version(args):
993      from . import __version__
994      print(__version__)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-bin_image.py</h3>
            <pre><code>1  import binascii
2  import copy
3  import hashlib
4  import io
5  import os
6  import re
7  import struct
8  from .loader import ESPLoader
9  from .targets import (
10      ESP32C2ROM,
11      ESP32C3ROM,
12      ESP32C6BETAROM,
13      ESP32C6ROM,
14      ESP32H2BETA1ROM,
15      ESP32H2BETA2ROM,
16      ESP32H2ROM,
17      ESP32ROM,
18      ESP32S2ROM,
19      ESP32S3BETA2ROM,
20      ESP32S3ROM,
21      ESP8266ROM,
22  )
23  from .util import FatalError, byte, pad_to
24  def align_file_position(f, size):
25      align = (size - 1) - (f.tell() % size)
26      f.seek(align, 1)
27  def LoadFirmwareImage(chip, image_file):
28      def select_image_class(f, chip):
29          chip = re.sub(r&quot;[-()]&quot;, &quot;&quot;, chip.lower())
30          if chip != &quot;esp8266&quot;:
31              return {
32                  &quot;esp32&quot;: ESP32FirmwareImage,
33                  &quot;esp32s2&quot;: ESP32S2FirmwareImage,
34                  &quot;esp32s3beta2&quot;: ESP32S3BETA2FirmwareImage,
35                  &quot;esp32s3&quot;: ESP32S3FirmwareImage,
36                  &quot;esp32c3&quot;: ESP32C3FirmwareImage,
37                  &quot;esp32c6beta&quot;: ESP32C6BETAFirmwareImage,
38                  &quot;esp32h2beta1&quot;: ESP32H2BETA1FirmwareImage,
39                  &quot;esp32h2beta2&quot;: ESP32H2BETA2FirmwareImage,
40                  &quot;esp32c2&quot;: ESP32C2FirmwareImage,
41                  &quot;esp32c6&quot;: ESP32C6FirmwareImage,
42                  &quot;esp32h2&quot;: ESP32H2FirmwareImage,
43              }[chip](f)
44          else:  # Otherwise, ESP8266 so look at magic to determine the image type
45              magic = ord(f.read(1))
46              f.seek(0)
47              if magic == ESPLoader.ESP_IMAGE_MAGIC:
48                  return ESP8266ROMFirmwareImage(f)
49              elif magic == ESP8266V2FirmwareImage.IMAGE_V2_MAGIC:
50                  return ESP8266V2FirmwareImage(f)
51              else:
52                  raise FatalError(&quot;Invalid image magic number: %d&quot; % magic)
53      if isinstance(image_file, str):
54          with open(image_file, &quot;rb&quot;) as f:
55              return select_image_class(f, chip)
56      return select_image_class(image_file, chip)
57  class ImageSegment(object):
58      def __init__(self, addr, data, file_offs=None):
59          self.addr = addr
60          self.data = data
61          self.file_offs = file_offs
62          self.include_in_checksum = True
63          if self.addr != 0:
64              self.pad_to_alignment(
65                  4
66              )  # pad all &quot;real&quot; ImageSegments 4 byte aligned length
67      def copy_with_new_addr(self, new_addr):
68          return ImageSegment(new_addr, self.data, 0)
69      def split_image(self, split_len):
70          result = copy.copy(self)
71          result.data = self.data[:split_len]
72          self.data = self.data[split_len:]
73          self.addr += split_len
74          self.file_offs = None
75          result.file_offs = None
76          return result
77      def __repr__(self):
78          r = &quot;len 0x%05x load 0x%08x&quot; % (len(self.data), self.addr)
79          if self.file_offs is not None:
80              r += &quot; file_offs 0x%08x&quot; % (self.file_offs)
81          return r
82      def get_memory_type(self, image):
83          return [
84              map_range[2]
85              for map_range in image.ROM_LOADER.MEMORY_MAP
86              if map_range[0] &lt;= self.addr &lt; map_range[1]
87          ]
88      def pad_to_alignment(self, alignment):
89          self.data = pad_to(self.data, alignment, b&quot;\x00&quot;)
90  class ELFSection(ImageSegment):
91      def __init__(self, name, addr, data):
92          super(ELFSection, self).__init__(addr, data)
93          self.name = name.decode(&quot;utf-8&quot;)
94      def __repr__(self):
95          return &quot;%s %s&quot; % (self.name, super(ELFSection, self).__repr__())
96  class BaseFirmwareImage(object):
97      SEG_HEADER_LEN = 8
98      SHA256_DIGEST_LEN = 32
99      def __init__(self):
100          self.segments = []
101          self.entrypoint = 0
102          self.elf_sha256 = None
103          self.elf_sha256_offset = 0
104          self.pad_to_size = 0
105      def load_common_header(self, load_file, expected_magic):
106          (
107              magic,
108              segments,
109              self.flash_mode,
110              self.flash_size_freq,
111              self.entrypoint,
112          ) = struct.unpack(&quot;&lt;BBBBI&quot;, load_file.read(8))
113          if magic != expected_magic:
114              raise FatalError(&quot;Invalid firmware image magic=0x%x&quot; % (magic))
115          return segments
116      def verify(self):
117          if len(self.segments) &gt; 16:
118              raise FatalError(
119                  &quot;Invalid segment count %d (max 16). &quot;
120                  &quot;Usually this indicates a linker script problem.&quot; % len(self.segments)
121              )
122      def load_segment(self, f, is_irom_segment=False):
123          file_offs = f.tell()
124          (offset, size) = struct.unpack(&quot;&lt;II&quot;, f.read(8))
125          self.warn_if_unusual_segment(offset, size, is_irom_segment)
126          segment_data = f.read(size)
127          if len(segment_data) &lt; size:
128              raise FatalError(
129                  &quot;End of file reading segment 0x%x, length %d (actual length %d)&quot;
130                  % (offset, size, len(segment_data))
131              )
132          segment = ImageSegment(offset, segment_data, file_offs)
133          self.segments.append(segment)
134          return segment
135      def warn_if_unusual_segment(self, offset, size, is_irom_segment):
136          if not is_irom_segment:
137              if offset &gt; 0x40200000 or offset &lt; 0x3FFE0000 or size &gt; 65536:
138                  print(&quot;WARNING: Suspicious segment 0x%x, length %d&quot; % (offset, size))
139      def maybe_patch_segment_data(self, f, segment_data):
140          segment_len = len(segment_data)
141          file_pos = f.tell()  # file_pos is position in the .bin file
142          if (
143              self.elf_sha256_offset &gt;= file_pos
144              and self.elf_sha256_offset &lt; file_pos + segment_len
145          ):
146              patch_offset = self.elf_sha256_offset - file_pos
147              if (
148                  patch_offset &lt; self.SEG_HEADER_LEN
149                  or patch_offset + self.SHA256_DIGEST_LEN &gt; segment_len
150              ):
151                  raise FatalError(
152                      &quot;Cannot place SHA256 digest on segment boundary&quot;
153                      &quot;(elf_sha256_offset=%d, file_pos=%d, segment_size=%d)&quot;
154                      % (self.elf_sha256_offset, file_pos, segment_len)
155                  )
156              patch_offset -= self.SEG_HEADER_LEN
157              if (
158                  segment_data[patch_offset : patch_offset + self.SHA256_DIGEST_LEN]
159                  != b&quot;\x00&quot; * self.SHA256_DIGEST_LEN
160              ):
161                  raise FatalError(
162                      &quot;Contents of segment at SHA256 digest offset 0x%x are not all zero.&quot;
163                      &quot; Refusing to overwrite.&quot; % self.elf_sha256_offset
164                  )
165              assert len(self.elf_sha256) == self.SHA256_DIGEST_LEN
166              segment_data = (
167                  segment_data[0:patch_offset]
168                  + self.elf_sha256
169                  + segment_data[patch_offset + self.SHA256_DIGEST_LEN :]
170              )
171          return segment_data
172      def save_segment(self, f, segment, checksum=None):
173          segment_data = self.maybe_patch_segment_data(f, segment.data)
174          f.write(struct.pack(&quot;&lt;II&quot;, segment.addr, len(segment_data)))
175          f.write(segment_data)
176          if checksum is not None:
177              return ESPLoader.checksum(segment_data, checksum)
178      def read_checksum(self, f):
179          align_file_position(f, 16)
180          return ord(f.read(1))
181      def calculate_checksum(self):
182          checksum = ESPLoader.ESP_CHECKSUM_MAGIC
183          for seg in self.segments:
184              if seg.include_in_checksum:
185                  checksum = ESPLoader.checksum(seg.data, checksum)
186          return checksum
187      def append_checksum(self, f, checksum):
188          align_file_position(f, 16)
189          f.write(struct.pack(b&quot;B&quot;, checksum))
190      def write_common_header(self, f, segments):
191          f.write(
192              struct.pack(
193                  &quot;&lt;BBBBI&quot;,
194                  ESPLoader.ESP_IMAGE_MAGIC,
195                  len(segments),
196                  self.flash_mode,
197                  self.flash_size_freq,
198                  self.entrypoint,
199              )
200          )
201      def is_irom_addr(self, addr):
202          return ESP8266ROM.IROM_MAP_START &lt;= addr &lt; ESP8266ROM.IROM_MAP_END
203      def get_irom_segment(self):
204          irom_segments = [s for s in self.segments if self.is_irom_addr(s.addr)]
205          if len(irom_segments) &gt; 0:
206              if len(irom_segments) != 1:
207                  raise FatalError(
208                      &quot;Found %d segments that could be irom0. Bad ELF file?&quot;
209                      % len(irom_segments)
210                  )
211              return irom_segments[0]
212          return None
213      def get_non_irom_segments(self):
214          irom_segment = self.get_irom_segment()
215          return [s for s in self.segments if s != irom_segment]
216      def merge_adjacent_segments(self):
217          if not self.segments:
218              return  # nothing to merge
219          segments = []
220          for i in range(len(self.segments) - 1, 0, -1):
221              elem = self.segments[i - 1]
222              next_elem = self.segments[i]
223              if all(
224                  (
225                      elem.get_memory_type(self) == next_elem.get_memory_type(self),
226                      elem.include_in_checksum == next_elem.include_in_checksum,
227                      next_elem.addr == elem.addr + len(elem.data),
228                  )
229              ):
230                  elem.data += next_elem.data
231              else:
232                  segments.insert(0, next_elem)
233          segments.insert(0, self.segments[0])
234          self.segments = segments
235      def set_mmu_page_size(self, size):
236          print(
237              &quot;WARNING: Changing MMU page size is not supported on {}! &quot;
238              &quot;Defaulting to 64KB.&quot;.format(self.ROM_LOADER.CHIP_NAME)
239          )
240  class ESP8266ROMFirmwareImage(BaseFirmwareImage):
241      ROM_LOADER = ESP8266ROM
242      def __init__(self, load_file=None):
243          super(ESP8266ROMFirmwareImage, self).__init__()
244          self.flash_mode = 0
245          self.flash_size_freq = 0
246          self.version = 1
247          if load_file is not None:
248              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
249              for _ in range(segments):
250                  self.load_segment(load_file)
251              self.checksum = self.read_checksum(load_file)
252              self.verify()
253      def default_output_name(self, input_file):
254          return input_file + &quot;-&quot;
255      def save(self, basename):
256          irom_segment = self.get_irom_segment()
257          if irom_segment is not None:
258              with open(
259                  &quot;%s0x%05x.bin&quot;
260                  % (basename, irom_segment.addr - ESP8266ROM.IROM_MAP_START),
261                  &quot;wb&quot;,
262              ) as f:
263                  f.write(irom_segment.data)
264          normal_segments = self.get_non_irom_segments()
265          with open(&quot;%s0x00000.bin&quot; % basename, &quot;wb&quot;) as f:
266              self.write_common_header(f, normal_segments)
267              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
268              for segment in normal_segments:
269                  checksum = self.save_segment(f, segment, checksum)
270              self.append_checksum(f, checksum)
271  ESP8266ROM.BOOTLOADER_IMAGE = ESP8266ROMFirmwareImage
272  class ESP8266V2FirmwareImage(BaseFirmwareImage):
273      ROM_LOADER = ESP8266ROM
274      IMAGE_V2_MAGIC = 0xEA
275      IMAGE_V2_SEGMENT = 4
276      def __init__(self, load_file=None):
277          super(ESP8266V2FirmwareImage, self).__init__()
278          self.version = 2
279          if load_file is not None:
280              segments = self.load_common_header(load_file, self.IMAGE_V2_MAGIC)
281              if segments != self.IMAGE_V2_SEGMENT:
282                  print(
283                      &#x27;Warning: V2 header has unexpected &quot;segment&quot; count %d (usually 4)&#x27;
284                      % segments
285                  )
286              irom_segment = self.load_segment(load_file, True)
287              irom_segment.addr = 0
288              irom_segment.include_in_checksum = False
289              first_flash_mode = self.flash_mode
290              first_flash_size_freq = self.flash_size_freq
291              first_entrypoint = self.entrypoint
292              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
293              if first_flash_mode != self.flash_mode:
294                  print(
295                      &quot;WARNING: Flash mode value in first header (0x%02x) disagrees &quot;
296                      &quot;with second (0x%02x). Using second value.&quot;
297                      % (first_flash_mode, self.flash_mode)
298                  )
299              if first_flash_size_freq != self.flash_size_freq:
300                  print(
301                      &quot;WARNING: Flash size/freq value in first header (0x%02x) disagrees &quot;
302                      &quot;with second (0x%02x). Using second value.&quot;
303                      % (first_flash_size_freq, self.flash_size_freq)
304                  )
305              if first_entrypoint != self.entrypoint:
306                  print(
307                      &quot;WARNING: Entrypoint address in first header (0x%08x) disagrees &quot;
308                      &quot;with second header (0x%08x). Using second value.&quot;
309                      % (first_entrypoint, self.entrypoint)
310                  )
311              for _ in range(segments):
312                  self.load_segment(load_file)
313              self.checksum = self.read_checksum(load_file)
314              self.verify()
315      def default_output_name(self, input_file):
316          irom_segment = self.get_irom_segment()
317          if irom_segment is not None:
318              irom_offs = irom_segment.addr - ESP8266ROM.IROM_MAP_START
319          else:
320              irom_offs = 0
321          return &quot;%s-0x%05x.bin&quot; % (
322              os.path.splitext(input_file)[0],
323              irom_offs &amp; ~(ESPLoader.FLASH_SECTOR_SIZE - 1),
324          )
325      def save(self, filename):
326          with open(filename, &quot;wb&quot;) as f:
327              f.write(
328                  struct.pack(
329                      b&quot;&lt;BBBBI&quot;,
330                      self.IMAGE_V2_MAGIC,
331                      self.IMAGE_V2_SEGMENT,
332                      self.flash_mode,
333                      self.flash_size_freq,
334                      self.entrypoint,
335                  )
336              )
337              irom_segment = self.get_irom_segment()
338              if irom_segment is not None:
339                  irom_segment = irom_segment.copy_with_new_addr(0)
340                  irom_segment.pad_to_alignment(
341                      16
342                  )  # irom_segment must end on a 16 byte boundary
343                  self.save_segment(f, irom_segment)
344              normal_segments = self.get_non_irom_segments()
345              self.write_common_header(f, normal_segments)
346              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
347              for segment in normal_segments:
348                  checksum = self.save_segment(f, segment, checksum)
349              self.append_checksum(f, checksum)
350          with open(filename, &quot;rb&quot;) as f:
351              crc = esp8266_crc32(f.read())
352          with open(filename, &quot;ab&quot;) as f:
353              f.write(struct.pack(b&quot;&lt;I&quot;, crc))
354  def esp8266_crc32(data):
355      crc = binascii.crc32(data, 0) &amp; 0xFFFFFFFF
356      if crc &amp; 0x80000000:
357          return crc ^ 0xFFFFFFFF
358      else:
359          return crc + 1
360  class ESP32FirmwareImage(BaseFirmwareImage):
361      ROM_LOADER = ESP32ROM
362      WP_PIN_DISABLED = 0xEE
363      EXTENDED_HEADER_STRUCT_FMT = &quot;&lt;BBBBHBHH&quot; + (&quot;B&quot; * 4) + &quot;B&quot;
364      IROM_ALIGN = 65536
365      def __init__(self, load_file=None, append_digest=True):
366          super(ESP32FirmwareImage, self).__init__()
367          self.secure_pad = None
368          self.flash_mode = 0
369          self.flash_size_freq = 0
370          self.version = 1
371          self.wp_pin = self.WP_PIN_DISABLED
372          self.clk_drv = 0
373          self.q_drv = 0
374          self.d_drv = 0
375          self.cs_drv = 0
376          self.hd_drv = 0
377          self.wp_drv = 0
378          self.chip_id = 0
379          self.min_rev = 0
380          self.min_rev_full = 0
381          self.max_rev_full = 0
382          self.append_digest = append_digest
383          if load_file is not None:
384              start = load_file.tell()
385              segments = self.load_common_header(load_file, ESPLoader.ESP_IMAGE_MAGIC)
386              self.load_extended_header(load_file)
387              for _ in range(segments):
388                  self.load_segment(load_file)
389              self.checksum = self.read_checksum(load_file)
390              if self.append_digest:
391                  end = load_file.tell()
392                  self.stored_digest = load_file.read(32)
393                  load_file.seek(start)
394                  calc_digest = hashlib.sha256()
395                  calc_digest.update(load_file.read(end - start))
396                  self.calc_digest = calc_digest.digest()  # TODO: decide what to do here?
397              self.verify()
398      def is_flash_addr(self, addr):
399          return (
400              self.ROM_LOADER.IROM_MAP_START &lt;= addr &lt; self.ROM_LOADER.IROM_MAP_END
401          ) or (self.ROM_LOADER.DROM_MAP_START &lt;= addr &lt; self.ROM_LOADER.DROM_MAP_END)
402      def default_output_name(self, input_file):
403          return &quot;%s.bin&quot; % (os.path.splitext(input_file)[0])
404      def warn_if_unusual_segment(self, offset, size, is_irom_segment):
405          pass  # TODO: add warnings for wrong ESP32 segment offset/size combinations
406      def save(self, filename):
407          total_segments = 0
408          with io.BytesIO() as f:  # write file to memory first
409              self.write_common_header(f, self.segments)
410              self.save_extended_header(f)
411              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
412              flash_segments = [
413                  copy.deepcopy(s)
414                  for s in sorted(self.segments, key=lambda s: s.addr)
415                  if self.is_flash_addr(s.addr)
416              ]
417              ram_segments = [
418                  copy.deepcopy(s)
419                  for s in sorted(self.segments, key=lambda s: s.addr)
420                  if not self.is_flash_addr(s.addr)
421              ]
422              for segment in flash_segments:
423                  if segment.name == &quot;.flash.appdesc&quot;:
424                      flash_segments.remove(segment)
425                      flash_segments.insert(0, segment)
426                      break
427              for segment in ram_segments:
428                  if segment.name == &quot;.dram0.bootdesc&quot;:
429                      ram_segments.remove(segment)
430                      ram_segments.insert(0, segment)
431                      break
432              if len(flash_segments) &gt; 0:
433                  last_addr = flash_segments[0].addr
434                  for segment in flash_segments[1:]:
435                      if segment.addr // self.IROM_ALIGN == last_addr // self.IROM_ALIGN:
436                          raise FatalError(
437                              &quot;Segment loaded at 0x%08x lands in same 64KB flash mapping &quot;
438                              &quot;as segment loaded at 0x%08x. Can&#x27;t generate binary. &quot;
439                              &quot;Suggest changing linker script or ELF to merge sections.&quot;
440                              % (segment.addr, last_addr)
441                          )
442                      last_addr = segment.addr
443              def get_alignment_data_needed(segment):
444                  align_past = (segment.addr % self.IROM_ALIGN) - self.SEG_HEADER_LEN
445                  pad_len = (self.IROM_ALIGN - (f.tell() % self.IROM_ALIGN)) + align_past
446                  if pad_len == 0 or pad_len == self.IROM_ALIGN:
447                      return 0  # already aligned
448                  pad_len -= self.SEG_HEADER_LEN
449                  if pad_len &lt; 0:
450                      pad_len += self.IROM_ALIGN
451                  return pad_len
452              while len(flash_segments) &gt; 0:
453                  segment = flash_segments[0]
454                  pad_len = get_alignment_data_needed(segment)
455                  if pad_len &gt; 0:  # need to pad
456                      if len(ram_segments) &gt; 0 and pad_len &gt; self.SEG_HEADER_LEN:
457                          pad_segment = ram_segments[0].split_image(pad_len)
458                          if len(ram_segments[0].data) == 0:
459                              ram_segments.pop(0)
460                      else:
461                          pad_segment = ImageSegment(0, b&quot;\x00&quot; * pad_len, f.tell())
462                      checksum = self.save_segment(f, pad_segment, checksum)
463                      total_segments += 1
464                  else:
465                      assert (
466                          f.tell() + 8
467                      ) % self.IROM_ALIGN == segment.addr % self.IROM_ALIGN
468                      checksum = self.save_flash_segment(f, segment, checksum)
469                      flash_segments.pop(0)
470                      total_segments += 1
471              for segment in ram_segments:
472                  checksum = self.save_segment(f, segment, checksum)
473                  total_segments += 1
474              if self.secure_pad:
475                  if not self.append_digest:
476                      raise FatalError(
477                          &quot;secure_pad only applies if a SHA-256 digest &quot;
478                          &quot;is also appended to the image&quot;
479                      )
480                  align_past = (f.tell() + self.SEG_HEADER_LEN) % self.IROM_ALIGN
481                  checksum_space = 16
482                  if self.secure_pad == &quot;1&quot;:
483                      space_after_checksum = 32 + 4 + 64 + 12
484                  elif self.secure_pad == &quot;2&quot;:  # Secure Boot V2
485                      space_after_checksum = 32
486                  pad_len = (
487                      self.IROM_ALIGN - align_past - checksum_space - space_after_checksum
488                  ) % self.IROM_ALIGN
489                  pad_segment = ImageSegment(0, b&quot;\x00&quot; * pad_len, f.tell())
490                  checksum = self.save_segment(f, pad_segment, checksum)
491                  total_segments += 1
492              self.append_checksum(f, checksum)
493              image_length = f.tell()
494              if self.secure_pad:
495                  assert ((image_length + space_after_checksum) % self.IROM_ALIGN) == 0
496              f.seek(1)
497              f.write(bytes([total_segments]))
498              if self.append_digest:
499                  f.seek(0)
500                  digest = hashlib.sha256()
501                  digest.update(f.read(image_length))
502                  f.write(digest.digest())
503              if self.pad_to_size:
504                  image_length = f.tell()
505                  if image_length % self.pad_to_size != 0:
506                      pad_by = self.pad_to_size - (image_length % self.pad_to_size)
507                      f.write(b&quot;\xff&quot; * pad_by)
508              with open(filename, &quot;wb&quot;) as real_file:
509                  real_file.write(f.getvalue())
510      def save_flash_segment(self, f, segment, checksum=None):
511          segment_end_pos = f.tell() + len(segment.data) + self.SEG_HEADER_LEN
512          segment_len_remainder = segment_end_pos % self.IROM_ALIGN
513          if segment_len_remainder &lt; 0x24:
514              segment.data += b&quot;\x00&quot; * (0x24 - segment_len_remainder)
515          return self.save_segment(f, segment, checksum)
516      def load_extended_header(self, load_file):
517          def split_byte(n):
518              return (n &amp; 0x0F, (n &gt;&gt; 4) &amp; 0x0F)
519          fields = list(
520              struct.unpack(self.EXTENDED_HEADER_STRUCT_FMT, load_file.read(16))
521          )
522          self.wp_pin = fields[0]
523          self.clk_drv, self.q_drv = split_byte(fields[1])
524          self.d_drv, self.cs_drv = split_byte(fields[2])
525          self.hd_drv, self.wp_drv = split_byte(fields[3])
526          self.chip_id = fields[4]
527          if self.chip_id != self.ROM_LOADER.IMAGE_CHIP_ID:
528              print(
529                  (
530                      &quot;Unexpected chip id in image. Expected %d but value was %d. &quot;
531                      &quot;Is this image for a different chip model?&quot;
532                  )
533                  % (self.ROM_LOADER.IMAGE_CHIP_ID, self.chip_id)
534              )
535          self.min_rev = fields[5]
536          self.min_rev_full = fields[6]
537          self.max_rev_full = fields[7]
538          append_digest = fields[-1]  # last byte is append_digest
539          if append_digest in [0, 1]:
540              self.append_digest = append_digest == 1
541          else:
542              raise RuntimeError(
543                  &quot;Invalid value for append_digest field (0x%02x). Should be 0 or 1.&quot;,
544                  append_digest,
545              )
546      def save_extended_header(self, save_file):
547          def join_byte(ln, hn):
548              return (ln &amp; 0x0F) + ((hn &amp; 0x0F) &lt;&lt; 4)
549          append_digest = 1 if self.append_digest else 0
550          fields = [
551              self.wp_pin,
552              join_byte(self.clk_drv, self.q_drv),
553              join_byte(self.d_drv, self.cs_drv),
554              join_byte(self.hd_drv, self.wp_drv),
555              self.ROM_LOADER.IMAGE_CHIP_ID,
556              self.min_rev,
557              self.min_rev_full,
558              self.max_rev_full,
559          ]
560          fields += [0] * 4  # padding
561          fields += [append_digest]
562          packed = struct.pack(self.EXTENDED_HEADER_STRUCT_FMT, *fields)
563          save_file.write(packed)
564  class ESP8266V3FirmwareImage(ESP32FirmwareImage):
565      EXTENDED_HEADER_STRUCT_FMT = &quot;B&quot; * 16
566      def is_flash_addr(self, addr):
567          return addr &gt; ESP8266ROM.IROM_MAP_START
568      def save(self, filename):
569          total_segments = 0
570          with io.BytesIO() as f:  # write file to memory first
571              self.write_common_header(f, self.segments)
572              checksum = ESPLoader.ESP_CHECKSUM_MAGIC
573              flash_segments = [
574                  copy.deepcopy(s)
575                  for s in sorted(self.segments, key=lambda s: s.addr)
576                  if self.is_flash_addr(s.addr) and len(s.data)
577              ]
578              ram_segments = [
579                  copy.deepcopy(s)
580                  for s in sorted(self.segments, key=lambda s: s.addr)
581                  if not self.is_flash_addr(s.addr) and len(s.data)
582              ]
583              if len(flash_segments) &gt; 0:
584                  last_addr = flash_segments[0].addr
585                  for segment in flash_segments[1:]:
586                      if segment.addr // self.IROM_ALIGN == last_addr // self.IROM_ALIGN:
587                          raise FatalError(
588                              &quot;Segment loaded at 0x%08x lands in same 64KB flash mapping &quot;
589                              &quot;as segment loaded at 0x%08x. Can&#x27;t generate binary. &quot;
590                              &quot;Suggest changing linker script or ELF to merge sections.&quot;
591                              % (segment.addr, last_addr)
592                          )
593                      last_addr = segment.addr
594              while len(flash_segments) &gt; 0:
595                  segment = flash_segments[0]
596                  if segment.name == &quot;.flash.rodata&quot;:
597                      segment.data = segment.data[8:]
598                  checksum = self.save_segment(f, segment, checksum)
599                  flash_segments.pop(0)
600                  total_segments += 1
601              for segment in ram_segments:
602                  checksum = self.save_segment(f, segment, checksum)
603                  total_segments += 1
604              self.append_checksum(f, checksum)
605              image_length = f.tell()
606              f.seek(1)
607              f.write(bytes([total_segments]))
608              if self.append_digest:
609                  f.seek(0)
610                  digest = hashlib.sha256()
611                  digest.update(f.read(image_length))
612                  f.write(digest.digest())
613              with open(filename, &quot;wb&quot;) as real_file:
614                  real_file.write(f.getvalue())
615      def load_extended_header(self, load_file):
616          def split_byte(n):
617              return (n &amp; 0x0F, (n &gt;&gt; 4) &amp; 0x0F)
618          fields = list(
619              struct.unpack(self.EXTENDED_HEADER_STRUCT_FMT, load_file.read(16))
620          )
621          self.wp_pin = fields[0]
622          self.clk_drv, self.q_drv = split_byte(fields[1])
623          self.d_drv, self.cs_drv = split_byte(fields[2])
624          self.hd_drv, self.wp_drv = split_byte(fields[3])
625          if fields[15] in [0, 1]:
626              self.append_digest = fields[15] == 1
627          else:
628              raise RuntimeError(
629                  &quot;Invalid value for append_digest field (0x%02x). Should be 0 or 1.&quot;,
630                  fields[15],
631              )
632          if any(f for f in fields[4:15] if f != 0):
633              print(
634                  &quot;Warning: some reserved header fields have non-zero values. &quot;
635                  &quot;This image may be from a newer esptool.py?&quot;
636              )
637  ESP32ROM.BOOTLOADER_IMAGE = ESP32FirmwareImage
638  class ESP32S2FirmwareImage(ESP32FirmwareImage):
639      ROM_LOADER = ESP32S2ROM
640  ESP32S2ROM.BOOTLOADER_IMAGE = ESP32S2FirmwareImage
641  class ESP32S3BETA2FirmwareImage(ESP32FirmwareImage):
642      ROM_LOADER = ESP32S3BETA2ROM
643  ESP32S3BETA2ROM.BOOTLOADER_IMAGE = ESP32S3BETA2FirmwareImage
644  class ESP32S3FirmwareImage(ESP32FirmwareImage):
645      ROM_LOADER = ESP32S3ROM
646  ESP32S3ROM.BOOTLOADER_IMAGE = ESP32S3FirmwareImage
647  class ESP32C3FirmwareImage(ESP32FirmwareImage):
648      ROM_LOADER = ESP32C3ROM
649  ESP32C3ROM.BOOTLOADER_IMAGE = ESP32C3FirmwareImage
650  class ESP32C6BETAFirmwareImage(ESP32FirmwareImage):
651      ROM_LOADER = ESP32C6BETAROM
652  ESP32C6BETAROM.BOOTLOADER_IMAGE = ESP32C6BETAFirmwareImage
653  class ESP32H2BETA1FirmwareImage(ESP32FirmwareImage):
654      ROM_LOADER = ESP32H2BETA1ROM
655  ESP32H2BETA1ROM.BOOTLOADER_IMAGE = ESP32H2BETA1FirmwareImage
656  class ESP32H2BETA2FirmwareImage(ESP32FirmwareImage):
657      ROM_LOADER = ESP32H2BETA2ROM
658  ESP32H2BETA2ROM.BOOTLOADER_IMAGE = ESP32H2BETA2FirmwareImage
659  class ESP32C2FirmwareImage(ESP32FirmwareImage):
660      ROM_LOADER = ESP32C2ROM
661      def set_mmu_page_size(self, size):
662          if size not in [16384, 32768, 65536]:
663              raise FatalError(
664                  &quot;{} bytes is not a valid ESP32-C2 page size, &quot;
665                  &quot;select from 64KB, 32KB, 16KB.&quot;.format(size)
666              )
667          self.IROM_ALIGN = size
668  ESP32C2ROM.BOOTLOADER_IMAGE = ESP32C2FirmwareImage
669  class ESP32C6FirmwareImage(ESP32FirmwareImage):
670      ROM_LOADER = ESP32C6ROM
671      def set_mmu_page_size(self, size):
672          if size not in [8192, 16384, 32768, 65536]:
673              raise FatalError(
674                  &quot;{} bytes is not a valid ESP32-C6 page size, &quot;
675                  &quot;select from 64KB, 32KB, 16KB, 8KB.&quot;.format(size)
676              )
677          self.IROM_ALIGN = size
678  ESP32C6ROM.BOOTLOADER_IMAGE = ESP32C6FirmwareImage
679  class ESP32H2FirmwareImage(ESP32C6FirmwareImage):
680      ROM_LOADER = ESP32H2ROM
681  ESP32H2ROM.BOOTLOADER_IMAGE = ESP32H2FirmwareImage
682  class ELFFile(object):
683      SEC_TYPE_PROGBITS = 0x01
684      SEC_TYPE_STRTAB = 0x03
685      SEC_TYPE_INITARRAY = 0x0E
686      SEC_TYPE_FINIARRAY = 0x0F
687      PROG_SEC_TYPES = (SEC_TYPE_PROGBITS, SEC_TYPE_INITARRAY, SEC_TYPE_FINIARRAY)
688      LEN_SEC_HEADER = 0x28
689      SEG_TYPE_LOAD = 0x01
690      LEN_SEG_HEADER = 0x20
691      def __init__(self, name):
692          self.name = name
693          with open(self.name, &quot;rb&quot;) as f:
694              self._read_elf_file(f)
695      def get_section(self, section_name):
696          for s in self.sections:
697              if s.name == section_name:
698                  return s
699          raise ValueError(&quot;No section %s in ELF file&quot; % section_name)
700      def _read_elf_file(self, f):
701          LEN_FILE_HEADER = 0x34
702          try:
703              (
704                  ident,
705                  _type,
706                  machine,
707                  _version,
708                  self.entrypoint,
709                  _phoff,
710                  shoff,
711                  _flags,
712                  _ehsize,
713                  _phentsize,
714                  _phnum,
715                  shentsize,
716                  shnum,
717                  shstrndx,
718              ) = struct.unpack(&quot;&lt;16sHHLLLLLHHHHHH&quot;, f.read(LEN_FILE_HEADER))
719          except struct.error as e:
<span onclick='openModal()' class='match'>720              raise FatalError(
721                  &quot;Failed to read a valid ELF header from %s: %s&quot; % (self.name, e)
722              )
723          if byte(ident, 0) != 0x7F or ident[1:4] != b&quot;ELF&quot;:
</span>724              raise FatalError(&quot;%s has invalid ELF magic header&quot; % self.name)
725          if machine not in [0x5E, 0xF3]:
726              raise FatalError(
727                  &quot;%s does not appear to be an Xtensa or an RISCV ELF file. &quot;
728                  &quot;e_machine=%04x&quot; % (self.name, machine)
729              )
730          if shentsize != self.LEN_SEC_HEADER:
731              raise FatalError(
732                  &quot;%s has unexpected section header entry size 0x%x (not 0x%x)&quot;
733                  % (self.name, shentsize, self.LEN_SEC_HEADER)
734              )
735          if shnum == 0:
736              raise FatalError(&quot;%s has 0 section headers&quot; % (self.name))
737          self._read_sections(f, shoff, shnum, shstrndx)
738          self._read_segments(f, _phoff, _phnum, shstrndx)
739      def _read_sections(self, f, section_header_offs, section_header_count, shstrndx):
740          f.seek(section_header_offs)
741          len_bytes = section_header_count * self.LEN_SEC_HEADER
742          section_header = f.read(len_bytes)
743          if len(section_header) == 0:
744              raise FatalError(
745                  &quot;No section header found at offset %04x in ELF file.&quot;
746                  % section_header_offs
747              )
748          if len(section_header) != (len_bytes):
749              raise FatalError(
750                  &quot;Only read 0x%x bytes from section header (expected 0x%x.) &quot;
751                  &quot;Truncated ELF file?&quot; % (len(section_header), len_bytes)
752              )
753          section_header_offsets = range(0, len(section_header), self.LEN_SEC_HEADER)
754          def read_section_header(offs):
755              name_offs, sec_type, _flags, lma, sec_offs, size = struct.unpack_from(
756                  &quot;&lt;LLLLLL&quot;, section_header[offs:]
757              )
758              return (name_offs, sec_type, lma, size, sec_offs)
759          all_sections = [read_section_header(offs) for offs in section_header_offsets]
760          prog_sections = [s for s in all_sections if s[1] in ELFFile.PROG_SEC_TYPES]
761          if not (shstrndx * self.LEN_SEC_HEADER) in section_header_offsets:
762              raise FatalError(&quot;ELF file has no STRTAB section at shstrndx %d&quot; % shstrndx)
763          _, sec_type, _, sec_size, sec_offs = read_section_header(
764              shstrndx * self.LEN_SEC_HEADER
765          )
766          if sec_type != ELFFile.SEC_TYPE_STRTAB:
767              print(
768                  &quot;WARNING: ELF file has incorrect STRTAB section type 0x%02x&quot; % sec_type
769              )
770          f.seek(sec_offs)
771          string_table = f.read(sec_size)
772          def lookup_string(offs):
773              raw = string_table[offs:]
774              return raw[: raw.index(b&quot;\x00&quot;)]
775          def read_data(offs, size):
776              f.seek(offs)
777              return f.read(size)
778          prog_sections = [
779              ELFSection(lookup_string(n_offs), lma, read_data(offs, size))
780              for (n_offs, _type, lma, size, offs) in prog_sections
781              if lma != 0 and size &gt; 0
782          ]
783          self.sections = prog_sections
784      def _read_segments(self, f, segment_header_offs, segment_header_count, shstrndx):
785          f.seek(segment_header_offs)
786          len_bytes = segment_header_count * self.LEN_SEG_HEADER
787          segment_header = f.read(len_bytes)
788          if len(segment_header) == 0:
789              raise FatalError(
790                  &quot;No segment header found at offset %04x in ELF file.&quot;
791                  % segment_header_offs
792              )
793          if len(segment_header) != (len_bytes):
794              raise FatalError(
795                  &quot;Only read 0x%x bytes from segment header (expected 0x%x.) &quot;
796                  &quot;Truncated ELF file?&quot; % (len(segment_header), len_bytes)
797              )
798          segment_header_offsets = range(0, len(segment_header), self.LEN_SEG_HEADER)
799          def read_segment_header(offs):
800              (
801                  seg_type,
802                  seg_offs,
803                  _vaddr,
804                  lma,
805                  size,
806                  _memsize,
807                  _flags,
808                  _align,
809              ) = struct.unpack_from(&quot;&lt;LLLLLLLL&quot;, segment_header[offs:])
810              return (seg_type, lma, size, seg_offs)
811          all_segments = [read_segment_header(offs) for offs in segment_header_offsets]
812          prog_segments = [s for s in all_segments if s[0] == ELFFile.SEG_TYPE_LOAD]
813          def read_data(offs, size):
814              f.seek(offs)
815              return f.read(size)
816          prog_segments = [
817              ELFSection(b&quot;PHDR&quot;, lma, read_data(offs, size))
818              for (_type, lma, size, offs) in prog_segments
819              if lma != 0 and size &gt; 0
820          ]
821          self.segments = prog_segments
822      def sha256(self):
823          sha256 = hashlib.sha256()
824          with open(self.name, &quot;rb&quot;) as f:
825              sha256.update(f.read())
826          return sha256.digest()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-cmds.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-bin_image.py</div>
                </div>
                <div class="column column_space"><pre><code>970          raise FatalError(
971              &quot;Output file target offset is 0x%x. Input file offset 0x%x is before this.&quot;
972              % (args.target_offset, first_addr)
973          )
974      if args.format != &quot;raw&quot;:
</pre></code></div>
                <div class="column column_space"><pre><code>720              raise FatalError(
721                  &quot;Failed to read a valid ELF header from %s: %s&quot; % (self.name, e)
722              )
723          if byte(ident, 0) != 0x7F or ident[1:4] != b&quot;ELF&quot;:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    