<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for label-and-assign.py &amp; selinux_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for label-and-assign.py &amp; selinux_1.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>label-and-assign.py (5.633803%)<th>selinux_1.py (1.5189873%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(84-86)<td><a href="#" name="0">(136-144)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>label-and-assign.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import argparse
2 import datetime
3 import json
4 import operator
5 import os
6 import pathlib
7 import random
8 import sys
9 import github
10 from github.GithubException import GithubException
11 CACHE_FILENAME = pathlib.Path(".cache", "last-user-assigned")
12 def get_last_account_assigned():
13     if not CACHE_FILENAME.exists():
14         return
15     try:
16         data = json.loads(CACHE_FILENAME.read_text())
17         return data["username"]
18     except (ValueError, KeyError):
19         return
20 def get_team_members(options):
21     g = github.Github(os.environ["READ_ORG_TOKEN"])
22     org = g.get_organization(options.org)
23     team = org.get_team_by_slug(options.team)
24     return sorted(list(team.get_members()), key=operator.attrgetter("login"))
25 def get_triage_next_account(options):
26     team_members = get_team_members(options)
27     last_account_assigned = get_last_account_assigned()
28     if last_account_assigned is None:
29         return random.choice(team_members)
30     previous_account = None
31     for member in team_members:
32         if previous_account and previous_account.login == last_account_assigned:
33             return member
34         previous_account = member
35     else:
36         return random.choice(team_members)
37 def label_and_assign_issue(options):
38     g = github.Github(os.environ["GITHUB_TOKEN"])
39     org = g.get_organization(options.org)
40     print(f"Loaded Organization: {org.login}", file=sys.stderr, flush=True)
41     repo = org.get_repo(options.repo)
42     print(f"Loaded Repository: {repo.full_name}", file=sys.stderr, flush=True)
43     issue = repo.get_issue(options.issue)
44     print(f"Loaded Issue: {issue}", file=sys.stderr, flush=True)
45     next_triage_account = get_triage_next_account(options)
46     print(
47         f"Next account up for triage: {next_triage_account.login}",
48         file=sys.stderr,
49         flush=True,
50     )
51     print(f"Adding label {options.label} to {issue}", file=sys.stderr, flush=True)
52     issue.add_to_labels(options.label)
53     print(
54         f"Assigning {issue} to {next_triage_account.login}", file=sys.stderr, flush=True
55     )
56     issue.add_to_assignees(next_triage_account)
57     CACHE_FILENAME.write_text(
58         json.dumps(
59             {
60                 "username": next_triage_account.login,
61                 "when": str(datetime.datetime.utcnow()),
62             }
63         )
64     )
65     print("Done!", file=sys.stderr, flush=True)
66 def main():
67     parser = argparse.ArgumentParser()
68     parser<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_argument("--org", required=True, help="The Github Organization")
69     parser.add_argument("--team", required=True, help="The Organization Team Slug")
70     parser.add_argument("--repo", required=True, help=</b></font>"The Organization Repository")
71     parser.add_argument("--issue", required=True, type=int, help="The issue number")
72     parser.add_argument("--label", required=True, help="The issue label to assign")
73     if not os.environ.get("GITHUB_TOKEN"):
74         parser.exit(status=1, message="GITHUB_TOKEN environment variable not set")
75     if not os.environ.get("READ_ORG_TOKEN"):
76         parser.exit(status=1, message="READ_ORG_TOKEN environment variable not set")
77     options = parser.parse_args()
78     print(
79         f"Last assignment cache file path: {CACHE_FILENAME}",
80         file=sys.stderr,
81         flush=True,
82     )
83     if CACHE_FILENAME.parent.is_dir() is False:
84         CACHE_FILENAME.parent.mkdir()
85     try:
86         label_and_assign_issue(options)
87         parser.exit(0)
88     except GithubException as exc:
89         parser.exit(1, message=str(exc))
90 if __name__ == "__main__":
91     main()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>selinux_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import re
3 import salt.utils.decorators as decorators
4 import salt.utils.files
5 import salt.utils.path
6 import salt.utils.stringutils
7 import salt.utils.versions
8 from salt.exceptions import CommandExecutionError, SaltInvocationError
9 _SELINUX_FILETYPES = {
10     "a": "all files",
11     "f": "regular file",
12     "d": "directory",
13     "c": "character device",
14     "b": "block device",
15     "s": "socket",
16     "l": "symbolic link",
17     "p": "named pipe",
18 }
19 def __virtual__():
20     required_cmds = ("semanage", "setsebool", "semodule")
21     for cmd in required_cmds:
22         if not salt.utils.path.which(cmd):
23             return (False, cmd + " is not in the path")
24     if __grains__["kernel"] == "Linux":
25         return "selinux"
26     return (False, "Module only works on Linux with selinux installed")
27 @decorators.memoize
28 def selinux_fs_path():
29     try:
30         for directory in ("/sys/fs/selinux", "/selinux"):
31             if os.path.isdir(directory):
32                 if os.path.isfile(os.path.join(directory, "enforce")):
33                     return directory
34         return None
35     except AttributeError:
36         return None
37 def getenforce():
38     _selinux_fs_path = selinux_fs_path()
39     if _selinux_fs_path is None:
40         return "Disabled"
41     try:
42         enforce = os.path.join(_selinux_fs_path, "enforce")
43         with salt.utils.files.fopen(enforce, "r") as _fp:
44             if salt.utils.stringutils.to_unicode(_fp.readline()).strip() == "0":
45                 return "Permissive"
46             else:
47                 return "Enforcing"
48     except (OSError, AttributeError):
49         return "Disabled"
50 def getconfig():
51     try:
52         config = "/etc/selinux/config"
53         with salt.utils.files.fopen(config, "r") as _fp:
54             for line in _fp:
55                 line = salt.utils.stringutils.to_unicode(line)
56                 if line.strip().startswith("SELINUX="):
57                     return line.split("=")[1].capitalize().strip()
58     except (OSError, AttributeError):
59         return None
60     return None
61 def setenforce(mode):
62     if isinstance(mode, str):
63         if mode<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.lower() == "enforcing":
64             mode = "1"
65             modestring = "Enforcing"
66         elif mode.lower() == "permissive":
67             mode = "0"
68             modestring = "Permissive"
69         elif mode.lower() == "disabled":
70             mode = "0"
71             modestring =</b></font> "Disabled"
72         else:
73             return "Invalid mode {}".format(mode)
74     elif isinstance(mode, int):
75         if mode:
76             mode = "1"
77         else:
78             mode = "0"
79     else:
80         return "Invalid mode {}".format(mode)
81     if getenforce() != "Disabled":
82         enforce = os.path.join(selinux_fs_path(), "enforce")
83         try:
84             with salt.utils.files.fopen(enforce, "w") as _fp:
85                 _fp.write(salt.utils.stringutils.to_str(mode))
86         except OSError as exc:
87             msg = "Could not write SELinux enforce file: {0}"
88             raise CommandExecutionError(msg.format(exc))
89     config = "/etc/selinux/config"
90     try:
91         with salt.utils.files.fopen(config, "r") as _cf:
92             conf = _cf.read()
93         try:
94             with salt.utils.files.fopen(config, "w") as _cf:
95                 conf = re.sub(r"\nSELINUX=.*\n", "\nSELINUX=" + modestring + "\n", conf)
96                 _cf.write(salt.utils.stringutils.to_str(conf))
97         except OSError as exc:
98             msg = "Could not write SELinux config file: {0}"
99             raise CommandExecutionError(msg.format(exc))
100     except OSError as exc:
101         msg = "Could not read SELinux config file: {0}"
102         raise CommandExecutionError(msg.format(exc))
103     return getenforce()
104 def getsebool(boolean):
105     return list_sebool().get(boolean, {})
106 def setsebool(boolean, value, persist=False):
107     if persist:
108         cmd = "setsebool -P {} {}".format(boolean, value)
109     else:
110         cmd = "setsebool {} {}".format(boolean, value)
111     return not __salt__["cmd.retcode"](cmd, python_shell=False)
112 def setsebools(pairs, persist=False):
113     if not isinstance(pairs, dict):
114         return {}
115     if persist:
116         cmd = "setsebool -P "
117     else:
118         cmd = "setsebool "
119     for boolean, value in pairs.items():
120         cmd = "{} {}={}".format(cmd, boolean, value)
121     return not __salt__["cmd.retcode"](cmd, python_shell=False)
122 def list_sebool():
123     bdata = __salt__["cmd.run"]("semanage boolean -l").splitlines()
124     ret = {}
125     for line in bdata[1:]:
126         if not line.strip():
127             continue
128         comps = line.split()
129         ret[comps[0]] = {
130             "State": comps[1][1:],
131             "Default": comps[3][:-1],
132             "Description": " ".join(comps[4:]),
133         }
134     return ret
135 def getsemod(module):
136     return list_semod().get(module, {})
137 def setsemod(module, state):
138     if state.lower() == "enabled":
139         cmd = "semodule -e {}".format(module)
140     elif state.lower() == "disabled":
141         cmd = "semodule -d {}".format(module)
142     return not __salt__["cmd.retcode"](cmd)
143 def install_semod(module_path):
144     if module_path.find("salt://") == 0:
145         module_path = __salt__["cp.cache_file"](module_path)
146     cmd = "semodule -i {}".format(module_path)
147     return not __salt__["cmd.retcode"](cmd)
148 def remove_semod(module):
149     cmd = "semodule -r {}".format(module)
150     return not __salt__["cmd.retcode"](cmd)
151 def list_semod():
152     helptext = __salt__["cmd.run"]("semodule -h").splitlines()
153     semodule_version = ""
154     for line in helptext:
155         if line.strip().startswith("full"):
156             semodule_version = "new"
157     if semodule_version == "new":
158         mdata = __salt__["cmd.run"]("semodule -lfull").splitlines()
159         ret = {}
160         for line in mdata:
161             if not line.strip():
162                 continue
163             comps = line.split()
164             if len(comps) == 4:
165                 ret[comps[1]] = {"Enabled": False, "Version": None}
166             else:
167                 ret[comps[1]] = {"Enabled": True, "Version": None}
168     else:
169         mdata = __salt__["cmd.run"]("semodule -l").splitlines()
170         ret = {}
171         for line in mdata:
172             if not line.strip():
173                 continue
174             comps = line.split()
175             if len(comps) == 3:
176                 ret[comps[0]] = {"Enabled": False, "Version": comps[1]}
177             else:
178                 ret[comps[0]] = {"Enabled": True, "Version": comps[1]}
179     return ret
180 def _validate_filetype(filetype):
181     if filetype not in _SELINUX_FILETYPES.keys():
182         raise SaltInvocationError("Invalid filetype given: {}".format(filetype))
183     return True
184 def _parse_protocol_port(name, protocol, port):
185     protocol_port_pattern = r"^(tcp|udp)\/(([\d]+)\-?[\d]+)$"
186     name_parts = re.match(protocol_port_pattern, name)
187     if not name_parts:
188         name_parts = re.match(protocol_port_pattern, "{}/{}".format(protocol, port))
189     if not name_parts:
190         raise SaltInvocationError(
191             'Invalid name "{}" format and protocol and port not provided or invalid:'
192             ' "{}" "{}".'.format(name, protocol, port)
193         )
194     return name_parts.group(1), name_parts.group(2)
195 def _context_dict_to_string(context):
196     return "{sel_user}:{sel_role}:{sel_type}:{sel_level}".format(**context)
197 def _context_string_to_dict(context):
198     if not re.match("[^:]+:[^:]+:[^:]+:[^:]+$", context):
199         raise SaltInvocationError(
200             "Invalid SELinux context string: {0}. "
201             + 'Expected "sel_user:sel_role:sel_type:sel_level"'
202         )
203     context_list = context.split(":", 3)
204     ret = {}
205     for index, value in enumerate(["sel_user", "sel_role", "sel_type", "sel_level"]):
206         ret[value] = context_list[index]
207     return ret
208 def filetype_id_to_string(filetype="a"):
209     _validate_filetype(filetype)
210     return _SELINUX_FILETYPES.get(filetype, "error")
211 def fcontext_get_policy(
212     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
213 ):
214     if filetype:
215         _validate_filetype(filetype)
216     re_spacer = "[ ]+"
217     cmd_kwargs = {
218         "spacer": re_spacer,
219         "filespec": re.escape(name),
220         "sel_user": sel_user or "[^:]+",
221         "sel_role": "[^:]+",  # se_role for file context is always object_r
222         "sel_type": sel_type or "[^:]+",
223         "sel_level": sel_level or "[^:]+",
224     }
225     cmd_kwargs["filetype"] = (
226         "[[:alpha:] ]+" if filetype is None else filetype_id_to_string(filetype)
227     )
228     cmd = (
229         "semanage fcontext -l | egrep "
230         + "'^{filespec}{spacer}{filetype}{spacer}{sel_user}:{sel_role}:{sel_type}:{sel_level}$'".format(
231             **cmd_kwargs
232         )
233     )
234     current_entry_text = __salt__["cmd.shell"](cmd, ignore_retcode=True)
235     if current_entry_text == "":
236         return None
237     parts = re.match(
238         r"^({filespec}) +([a-z ]+) (.*)$".format(**{"filespec": re.escape(name)}),
239         current_entry_text,
240     )
241     ret = {
242         "filespec": parts.group(1).strip(),
243         "filetype": parts.group(2).strip(),
244     }
245     ret.update(_context_string_to_dict(parts.group(3).strip()))
246     return ret
247 def fcontext_add_policy(
248     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
249 ):
250     return _fcontext_add_or_delete_policy(
251         "add", name, filetype, sel_type, sel_user, sel_level
252     )
253 def fcontext_delete_policy(
254     name, filetype=None, sel_type=None, sel_user=None, sel_level=None
255 ):
256     return _fcontext_add_or_delete_policy(
257         "delete", name, filetype, sel_type, sel_user, sel_level
258     )
259 def _fcontext_add_or_delete_policy(
260     action, name, filetype=None, sel_type=None, sel_user=None, sel_level=None
261 ):
262     if action not in ["add", "delete"]:
263         raise SaltInvocationError(
264             'Actions supported are "add" and "delete", not "{}".'.format(action)
265         )
266     cmd = "semanage fcontext --{}".format(action)
267     if filetype is not None and filetype != "a":
268         _validate_filetype(filetype)
269         cmd += " --ftype {}".format(filetype)
270     if sel_type is not None:
271         cmd += " --type {}".format(sel_type)
272     if sel_user is not None:
273         cmd += " --seuser {}".format(sel_user)
274     if sel_level is not None:
275         cmd += " --range {}".format(sel_level)
276     cmd += " " + re.escape(name)
277     return __salt__["cmd.run_all"](cmd)
278 def fcontext_policy_is_applied(name, recursive=False):
279     cmd = "restorecon -n -v "
280     if recursive:
281         cmd += "-R "
282     cmd += re.escape(name)
283     return __salt__["cmd.run_all"](cmd).get("stdout")
284 def fcontext_apply_policy(name, recursive=False):
285     ret = {}
286     changes_text = fcontext_policy_is_applied(name, recursive)
287     cmd = "restorecon -v -F "
288     if recursive:
289         cmd += "-R "
290     cmd += re.escape(name)
291     apply_ret = __salt__["cmd.run_all"](cmd)
292     ret.update(apply_ret)
293     if apply_ret["retcode"] == 0:
294         changes_list = []
295         if changes_text.startswith("Would relabel"):
296             changes_list = re.findall(
297                 "Would relabel (.*) from (.*) to (.*)$", changes_text, re.M
298             )
299         elif changes_text.startswith("restorecon reset"):
300             changes_list = re.findall(
301                 "restorecon reset (.*) context (.*)-&gt;(.*)$", changes_text, re.M
302             )
303         else:
304             ret["retcode"] = 1
305             ret["error"] = "Unrecognized response from restorecon command."
306             return ret
307         if changes_list:
308             ret.update({"changes": {}})
309         for item in changes_list:
310             filespec = item[0]
311             old = _context_string_to_dict(item[1])
312             new = _context_string_to_dict(item[2])
313             intersect = {}
314             for key, value in old.items():
315                 if new.get(key) == value:
316                     intersect.update({key: value})
317             for key in intersect:
318                 del old[key]
319                 del new[key]
320             ret["changes"].update({filespec: {"old": old, "new": new}})
321     return ret
322 def port_get_policy(name, sel_type=None, protocol=None, port=None):
323     (protocol, port) = _parse_protocol_port(name, protocol, port)
324     re_spacer = "[ ]+"
325     re_sel_type = sel_type if sel_type else r"\w+"
326     cmd_kwargs = {
327         "spacer": re_spacer,
328         "sel_type": re_sel_type,
329         "protocol": protocol,
330         "port": port,
331     }
332     cmd = (
333         "semanage port -l | egrep "
334         + "'^{sel_type}{spacer}{protocol}{spacer}((.*)*)[ ]{port}($|,)'".format(
335             **cmd_kwargs
336         )
337     )
338     port_policy = __salt__["cmd.shell"](cmd, ignore_retcode=True)
339     if port_policy == "":
340         return None
341     parts = re.match(r"^(\w+)[ ]+(\w+)[ ]+([\d\-, ]+)", port_policy)
342     return {
343         "sel_type": parts.group(1).strip(),
344         "protocol": parts.group(2).strip(),
345         "port": parts.group(3).strip(),
346     }
347 def port_add_policy(name, sel_type=None, protocol=None, port=None, sel_range=None):
348     return _port_add_or_delete_policy("add", name, sel_type, protocol, port, sel_range)
349 def port_delete_policy(name, protocol=None, port=None):
350     return _port_add_or_delete_policy("delete", name, None, protocol, port, None)
351 def _port_add_or_delete_policy(
352     action, name, sel_type=None, protocol=None, port=None, sel_range=None
353 ):
354     if action not in ["add", "delete"]:
355         raise SaltInvocationError(
356             'Actions supported are "add" and "delete", not "{}".'.format(action)
357         )
358     if action == "add" and not sel_type:
359         raise SaltInvocationError("SELinux Type is required to add a policy")
360     (protocol, port) = _parse_protocol_port(name, protocol, port)
361     cmd = "semanage port --{} --proto {}".format(action, protocol)
362     if sel_type:
363         cmd += " --type {}".format(sel_type)
364     if sel_range:
365         cmd += " --range {}".format(sel_range)
366     cmd += " {}".format(port)
367     return __salt__["cmd.run_all"](cmd)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
