<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for wordpress.py & boto_cognitoidentity.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for wordpress.py & boto_cognitoidentity.py
      </h3>
      <h1 align="center">
        3.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>wordpress.py (7.3170733%)<TH>boto_cognitoidentity.py (2.7088037%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match83846-0.html#0',2,'match83846-1.html#0',3)" NAME="0">(61-68)<TD><A HREF="javascript:ZweiFrames('match83846-0.html#0',2,'match83846-1.html#0',3)" NAME="0">(370-376)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>wordpress.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
This state module is used to manage Wordpress installations

:depends: wp binary from http://wp-cli.org/
&quot;&quot;&quot;


def __virtual__():
    if &quot;wordpress.show_plugin&quot; in __salt__:
        return True
    return (False, &quot;wordpress module could not be loaded&quot;)


def installed(name, user, admin_user, admin_password, admin_email, title, url):
    &quot;&quot;&quot;
    Run the initial setup of wordpress

    name
        path to the wordpress installation

    user
        user that owns the files for the wordpress installation

    admin_user
        username for wordpress website administrator user

    admin_password
        password for wordpress website administrator user

    admin_email
        email for wordpress website administrator user

    title
        title for the wordpress website

    url
        url for the wordpress website

    .. code-block:: yaml

        /var/www/html:
          wordpress.installed:
            - title: Daniel's Awesome Blog
            - user: apache
            - admin_user: dwallace
            - admin_email: dwallace@example.com
            - admin_password: password123
            - url: https://blog.dwallace.com
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;comment&quot;: &quot;&quot;, &quot;result&quot;: False}

    check = __salt__[&quot;wordpress.is_installed&quot;](name, user)

    if check:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Wordpress is already installed: {}&quot;.format(name)
        return ret
<A NAME="0"></A>    elif __opts__[&quot;test&quot;]:
        ret[&quot;result&quot;] = None
        ret[&quot;comment&quot;] = &quot;Wordpress will be installed: {}&quot;.format(name)
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match83846-1.html#0',3,'match83846-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return ret

    resp = __salt__[&quot;wordpress.install&quot;](
        name, user, admin_user, admin_password, admin_email, title, url
    )
    if resp:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Wordpress Installed: {}&quot;.format(</B></FONT>name)
        ret[&quot;changes&quot;] = {&quot;new&quot;: resp}
    else:
        ret[&quot;comment&quot;] = &quot;Failed to install wordpress: {}&quot;.format(name)

    return ret


def activated(name, path, user):
    &quot;&quot;&quot;
    Activate wordpress plugins

    name
        name of plugin to activate

    path
        path to wordpress installation

    user
        user who should own the files in the wordpress installation

    .. code-block:: yaml

        HyperDB:
          wordpress.activated:
            - path: /var/www/html
            - user: apache
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;comment&quot;: &quot;&quot;, &quot;result&quot;: False}

    check = __salt__[&quot;wordpress.show_plugin&quot;](name, path, user)

    if check[&quot;status&quot;] == &quot;active&quot;:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Plugin already activated: {}&quot;.format(name)
        return ret
    elif __opts__[&quot;test&quot;]:
        ret[&quot;result&quot;] = None
        ret[&quot;comment&quot;] = &quot;Plugin will be activated: {}&quot;.format(name)
        return ret

    resp = __salt__[&quot;wordpress.activate&quot;](name, path, user)
    if resp is True:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Plugin activated: {}&quot;.format(name)
        ret[&quot;changes&quot;] = {
            &quot;old&quot;: check,
            &quot;new&quot;: __salt__[&quot;wordpress.show_plugin&quot;](name, path, user),
        }
    elif resp is None:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Plugin already activated: {}&quot;.format(name)
        ret[&quot;changes&quot;] = {
            &quot;old&quot;: check,
            &quot;new&quot;: __salt__[&quot;wordpress.show_plugin&quot;](name, path, user),
        }
    else:
        ret[&quot;comment&quot;] = &quot;Plugin failed to activate: {}&quot;.format(name)

    return ret


def deactivated(name, path, user):
    &quot;&quot;&quot;
    Deactivate wordpress plugins

    name
        name of plugin to deactivate

    path
        path to wordpress installation

    user
        user who should own the files in the wordpress installation

    .. code-block:: yaml

        HyperDB:
          wordpress.deactivated:
            - path: /var/www/html
            - user: apache
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;comment&quot;: &quot;&quot;, &quot;result&quot;: False}

    check = __salt__[&quot;wordpress.show_plugin&quot;](name, path, user)

    if check[&quot;status&quot;] == &quot;inactive&quot;:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Plugin already deactivated: {}&quot;.format(name)
        return ret
    elif __opts__[&quot;test&quot;]:
        ret[&quot;result&quot;] = None
        ret[&quot;comment&quot;] = &quot;Plugin will be deactivated: {}&quot;.format(name)
        return ret

    resp = __salt__[&quot;wordpress.deactivate&quot;](name, path, user)
    if resp is True:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Plugin deactivated: {}&quot;.format(name)
        ret[&quot;changes&quot;] = {
            &quot;old&quot;: check,
            &quot;new&quot;: __salt__[&quot;wordpress.show_plugin&quot;](name, path, user),
        }
    elif resp is None:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;Plugin already deactivated: {}&quot;.format(name)
        ret[&quot;changes&quot;] = {
            &quot;old&quot;: check,
            &quot;new&quot;: __salt__[&quot;wordpress.show_plugin&quot;](name, path, user),
        }
    else:
        ret[&quot;comment&quot;] = &quot;Plugin failed to deactivate: {}&quot;.format(name)

    return ret
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_cognitoidentity.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage CognitoIdentity Functions
================================

.. versionadded:: 2016.11.0

Create and destroy CognitoIdentity identity pools. Be aware that this interacts with
Amazon's services, and so may incur charges.

This module uses ``boto3``, which can be installed via package, or pip.

This module accepts explicit vpc credentials but can also utilize
IAM roles assigned to the instance through Instance Profiles. Dynamic
credentials are then automatically obtained from AWS API and no further
configuration is necessary. More information available `here
&lt;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html&gt;`_.

If IAM roles are not used you need to specify them either in a pillar file or
in the minion's config file:

.. code-block:: yaml

    vpc.keyid: GKTADJGHEIQSXMKKRBJ08H
    vpc.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

It's also possible to specify ``key``, ``keyid`` and ``region`` via a profile,
either passed in as a dict, or as a string to pull from pillars or minion
config:

.. code-block:: yaml

    myprofile:
        keyid: GKTADJGHEIQSXMKKRBJ08H
        key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
            region: us-east-1

.. code-block:: yaml

    Ensure function exists:
        boto_cognitoidentity.pool_present:
            - PoolName: my_identity_pool
            - region: us-east-1
            - keyid: GKTADJGHEIQSXMKKRBJ08H
            - key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

&quot;&quot;&quot;


import logging

log = logging.getLogger(__name__)


def __virtual__():
    &quot;&quot;&quot;
    Only load if boto is available.
    &quot;&quot;&quot;
    if &quot;boto_cognitoidentity.describe_identity_pools&quot; in __salt__:
        return &quot;boto_cognitoidentity&quot;
    return (False, &quot;boto_cognitoidentity module could not be loaded&quot;)


def _get_object(objname, objtype):
    &quot;&quot;&quot;
    Helper function to retrieve objtype from pillars if objname
    is str, used for SupportedLoginProviders and
    OpenIdConnectProviderARNs.
    &quot;&quot;&quot;
    ret = None
    if objname is None:
        return ret

    if isinstance(objname, str):
        if objname in __opts__:
            ret = __opts__[objname]
        master_opts = __pillar__.get(&quot;master&quot;, {})
        if objname in master_opts:
            ret = master_opts[objname]
        if objname in __pillar__:
            ret = __pillar__[objname]
    elif isinstance(objname, objtype):
        ret = objname

    if not isinstance(ret, objtype):
        ret = None

    return ret


def _role_present(
    ret, IdentityPoolId, AuthenticatedRole, UnauthenticatedRole, conn_params
):
    &quot;&quot;&quot;
    Helper function to set the Roles to the identity pool
    &quot;&quot;&quot;
    r = __salt__[&quot;boto_cognitoidentity.get_identity_pool_roles&quot;](
        IdentityPoolName=&quot;&quot;, IdentityPoolId=IdentityPoolId, **conn_params
    )
    if r.get(&quot;error&quot;):
        ret[&quot;result&quot;] = False
        failure_comment = &quot;Failed to get existing identity pool roles: {}&quot;.format(
            r[&quot;error&quot;].get(&quot;message&quot;, r[&quot;error&quot;])
        )
        ret[&quot;comment&quot;] = &quot;{}\n{}&quot;.format(ret[&quot;comment&quot;], failure_comment)
        return

    existing_identity_pool_role = r.get(&quot;identity_pool_roles&quot;)[0].get(&quot;Roles&quot;, {})
    r = __salt__[&quot;boto_cognitoidentity.set_identity_pool_roles&quot;](
        IdentityPoolId=IdentityPoolId,
        AuthenticatedRole=AuthenticatedRole,
        UnauthenticatedRole=UnauthenticatedRole,
        **conn_params
    )
    if not r.get(&quot;set&quot;):
        ret[&quot;result&quot;] = False
        failure_comment = &quot;Failed to set roles: {}&quot;.format(
            r[&quot;error&quot;].get(&quot;message&quot;, r[&quot;error&quot;])
        )
        ret[&quot;comment&quot;] = &quot;{}\n{}&quot;.format(ret[&quot;comment&quot;], failure_comment)
        return

    updated_identity_pool_role = r.get(&quot;roles&quot;)

    if existing_identity_pool_role != updated_identity_pool_role:
        if not ret[&quot;changes&quot;]:
            ret[&quot;changes&quot;][&quot;old&quot;] = dict()
            ret[&quot;changes&quot;][&quot;new&quot;] = dict()
        ret[&quot;changes&quot;][&quot;old&quot;][&quot;Roles&quot;] = existing_identity_pool_role
        ret[&quot;changes&quot;][&quot;new&quot;][&quot;Roles&quot;] = r.get(&quot;roles&quot;)
        ret[&quot;comment&quot;] = &quot;{}\n{}&quot;.format(ret[&quot;comment&quot;], &quot;identity pool roles updated.&quot;)
    else:
        ret[&quot;comment&quot;] = &quot;{}\n{}&quot;.format(
            ret[&quot;comment&quot;], &quot;identity pool roles is already current.&quot;
        )

    return


def pool_present(
    name,
    IdentityPoolName,
    AuthenticatedRole,
    AllowUnauthenticatedIdentities=False,
    UnauthenticatedRole=None,
    SupportedLoginProviders=None,
    DeveloperProviderName=None,
    OpenIdConnectProviderARNs=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure Cognito Identity Pool exists.

    name
        The name of the state definition

    IdentityPoolName
        Name of the Cognito Identity Pool

    AuthenticatedRole
        An IAM role name or ARN that will be associated with temporary AWS
        credentials for an authenticated cognito identity.

    AllowUnauthenticatedIdentities
        Whether to allow anonymous user identities

    UnauthenticatedRole
        An IAM role name or ARN that will be associated with anonymous
        user identities

    SupportedLoginProviders
        A dictionary or pillar that contains key:value pairs mapping provider
        names to provider app IDs.

    DeveloperProviderName
        A string which is the domain by which Cognito will refer to your users.
        This name acts as a placeholder that allows your backend and the Cognito
        service to communicate about the developer provider.  Once you have set a
        developer provider name, you cannot change it.  Please take care in setting
        this parameter.

    OpenIdConnectProviderARNs
        A list or pillar name that contains a list of OpenID Connect provider ARNs.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    &quot;&quot;&quot;
    ret = {&quot;name&quot;: IdentityPoolName, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    conn_params = dict(region=region, key=key, keyid=keyid, profile=profile)

    r = __salt__[&quot;boto_cognitoidentity.describe_identity_pools&quot;](
        IdentityPoolName=IdentityPoolName, **conn_params
    )

    if r.get(&quot;error&quot;):
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = &quot;Failed to describe identity pools {}&quot;.format(
            r[&quot;error&quot;][&quot;message&quot;]
        )
        return ret

    identity_pools = r.get(&quot;identity_pools&quot;)
    if identity_pools and len(identity_pools) &gt; 1:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = (
            &quot;More than one identity pool for the given name matched &quot;
            &quot;Cannot execute pool_present function.\n&quot;
            &quot;Matched Identity Pools:\n{}&quot;.format(identity_pools)
        )
        return ret
    existing_identity_pool = None if identity_pools is None else identity_pools[0]
    IdentityPoolId = (
        None
        if existing_identity_pool is None
        else existing_identity_pool.get(&quot;IdentityPoolId&quot;)
    )

    if __opts__[&quot;test&quot;]:
        if identity_pools is None:
            ret[&quot;comment&quot;] = &quot;A new identity pool named {} will be created.&quot;.format(
                IdentityPoolName
            )
        else:
            ret[
                &quot;comment&quot;
            ] = &quot;An existing identity pool named {} with id {} will be updated.&quot;.format(
                IdentityPoolName, IdentityPoolId
            )
        ret[&quot;result&quot;] = None
        return ret

    SupportedLoginProviders = _get_object(SupportedLoginProviders, dict)
    OpenIdConnectProviderARNs = _get_object(OpenIdConnectProviderARNs, list)

    request_params = dict(
        IdentityPoolName=IdentityPoolName,
        AllowUnauthenticatedIdentities=AllowUnauthenticatedIdentities,
        SupportedLoginProviders=SupportedLoginProviders,
        DeveloperProviderName=DeveloperProviderName,
        OpenIdConnectProviderARNs=OpenIdConnectProviderARNs,
    )
    request_params.update(conn_params)

    updated_identity_pool = None
    if IdentityPoolId is None:
        r = __salt__[&quot;boto_cognitoidentity.create_identity_pool&quot;](**request_params)

        if r.get(&quot;created&quot;):
            updated_identity_pool = r.get(&quot;identity_pool&quot;)
            IdentityPoolId = updated_identity_pool.get(&quot;IdentityPoolId&quot;)
            ret[
                &quot;comment&quot;
            ] = &quot;A new identity pool with name {}, id {} is created.&quot;.format(
                IdentityPoolName, IdentityPoolId
            )
        else:
            ret[&quot;result&quot;] = False
            ret[&quot;comment&quot;] = &quot;Failed to add a new identity pool: {}&quot;.format(
                r[&quot;error&quot;].get(&quot;message&quot;, r[&quot;error&quot;])
            )
            return ret
    else:  # Update an existing pool
        request_params[&quot;IdentityPoolId&quot;] = IdentityPoolId
        # we will never change the IdentityPoolName from the state module
        request_params.pop(&quot;IdentityPoolName&quot;, None)
        r = __salt__[&quot;boto_cognitoidentity.update_identity_pool&quot;](**request_params)

        if r.get(&quot;updated&quot;):
            updated_identity_pool = r.get(&quot;identity_pool&quot;)
            ret[
                &quot;comment&quot;
            ] = &quot;Existing identity pool with name {}, id {} is updated.&quot;.format(
                IdentityPoolName, IdentityPoolId
            )
        else:
            ret[&quot;result&quot;] = False
            ret[
                &quot;comment&quot;
            ] = &quot;Failed to update an existing identity pool {} {}: {}&quot;.format(
                IdentityPoolName,
                IdentityPoolId,
                r[&quot;error&quot;].get(&quot;message&quot;, r[&quot;error&quot;]),
            )
            return ret

    if existing_identity_pool != updated_identity_pool:
        ret[&quot;changes&quot;][&quot;old&quot;] = dict()
        ret[&quot;changes&quot;][&quot;new&quot;] = dict()
        change_key = &quot;Identity Pool Name {}&quot;.format(IdentityPoolName)
        ret[&quot;changes&quot;][&quot;old&quot;][change_key] = existing_identity_pool
        ret[&quot;changes&quot;][&quot;new&quot;][change_key] = updated_identity_pool
    else:
        ret[&quot;comment&quot;] = &quot;Identity Pool state is current, no changes.&quot;

    # Now update the Auth/Unauth Roles
    _role_present(
        ret, IdentityPoolId, AuthenticatedRole, UnauthenticatedRole, conn_params
    )

    return ret


def pool_absent(
    name,
    IdentityPoolName,
    RemoveAllMatched=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Ensure cognito identity pool with passed properties is absent.

    name
        The name of the state definition.

    IdentityPoolName
        Name of the Cognito Identity Pool.  Please note that this may
        match multiple pools with the same given name, in which case,
        all will be removed.

    RemoveAllMatched
        If True, all identity pools with the matching IdentityPoolName
        will be removed.  If False and there are more than one identity pool
        with the matching IdentityPoolName, no action will be taken.  If False
        and there is only one identity pool with the matching IdentityPoolName,
        the identity pool will be removed.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        A dict with region, key and keyid, or a pillar key (string) that
        contains a dict with region, key and keyid.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: IdentityPoolName, &quot;result&quot;: True, &quot;comment&quot;: &quot;&quot;, &quot;changes&quot;: {}}

    conn_params = dict(region=region, key=key, keyid=keyid, profile=profile)

    r = __salt__[&quot;boto_cognitoidentity.describe_identity_pools&quot;](
        IdentityPoolName=IdentityPoolName, **conn_params
    )

    if r.get(&quot;error&quot;):
        ret[&quot;result&quot;] = False
<A NAME="0"></A>        ret[&quot;comment&quot;] = &quot;Failed to describe identity pools {}&quot;.format(
            r[&quot;error&quot;][&quot;message&quot;]
        )
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match83846-0.html#0',2,'match83846-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>return ret

    identity_pools = r.get(&quot;identity_pools&quot;)

    if identity_pools is None:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;No matching identity pool for the given name {}&quot;.format(</B></FONT>
            IdentityPoolName
        )
        return ret

    if not RemoveAllMatched and len(identity_pools) &gt; 1:
        ret[&quot;result&quot;] = False
        ret[&quot;comment&quot;] = (
            &quot;More than one identity pool for the given name matched &quot;
            &quot;and RemoveAllMatched flag is False.\n&quot;
            &quot;Matched Identity Pools:\n{}&quot;.format(identity_pools)
        )
        return ret

    if __opts__[&quot;test&quot;]:
        ret[
            &quot;comment&quot;
        ] = &quot;The following matched identity pools will be deleted.\n{}&quot;.format(
            identity_pools
        )
        ret[&quot;result&quot;] = None
        return ret

    for identity_pool in identity_pools:
        IdentityPoolId = identity_pool.get(&quot;IdentityPoolId&quot;)
        r = __salt__[&quot;boto_cognitoidentity.delete_identity_pools&quot;](
            IdentityPoolName=&quot;&quot;, IdentityPoolId=IdentityPoolId, **conn_params
        )
        if r.get(&quot;error&quot;):
            ret[&quot;result&quot;] = False
            failure_comment = &quot;Failed to delete identity pool {}: {}&quot;.format(
                IdentityPoolId, r[&quot;error&quot;].get(&quot;message&quot;, r[&quot;error&quot;])
            )
            ret[&quot;comment&quot;] = &quot;{}\n{}&quot;.format(ret[&quot;comment&quot;], failure_comment)
            return ret

        if r.get(&quot;deleted&quot;):
            if not ret[&quot;changes&quot;]:
                ret[&quot;changes&quot;][&quot;old&quot;] = dict()
                ret[&quot;changes&quot;][&quot;new&quot;] = dict()
            change_key = &quot;Identity Pool Id {}&quot;.format(IdentityPoolId)
            ret[&quot;changes&quot;][&quot;old&quot;][change_key] = IdentityPoolName
            ret[&quot;changes&quot;][&quot;new&quot;][change_key] = None
            ret[&quot;comment&quot;] = &quot;{}\n{}&quot;.format(
                ret[&quot;comment&quot;], &quot;{} deleted&quot;.format(change_key)
            )
        else:
            ret[&quot;result&quot;] = False
            failure_comment = (
                &quot;Identity Pool Id {} not deleted, returned count 0&quot;.format(
                    IdentityPoolId
                )
            )
            ret[&quot;comment&quot;] = &quot;{}\n{}&quot;.format(ret[&quot;comment&quot;], failure_comment)
            return ret

    return ret
</PRE>
</div>
  </div>
</body>
</html>
