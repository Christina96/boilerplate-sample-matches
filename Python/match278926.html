<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_elasticsearch_domain_1.py &amp; junos_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_elasticsearch_domain_1.py &amp; junos_1.py
      </h3>
<h1 align="center">
        0.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_elasticsearch_domain_1.py (2.5974026%)<th>junos_1.py (0.45300114%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-15)<td><a href="#" name="0">(19-32)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_elasticsearch_domain_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
import logging
import random
import string
import salt.loader
import salt.modules.boto_elasticsearch_domain as boto_elasticsearch_domain
from salt.utils.versions import LooseVersion
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase, skipIf
try:
    import</b></font> boto3
    from botocore.exceptions import ClientError
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
required_boto3_version = "1.2.1"
def _has_required_boto():
    if not HAS_BOTO:
        return False
    elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
        return False
    else:
        return True
if _has_required_boto():
    region = "us-east-1"
    access_key = "GKTADJGHEIQSXMKKRBJ08H"
    secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
    conn_parameters = {
        "region": region,
        "key": access_key,
        "keyid": secret_key,
        "profile": {},
    }
    error_message = (
        "An error occurred (101) when calling the {0} operation: Test-defined error"
    )
    error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
    not_found_error = ClientError(
        {
            "Error": {
                "Code": "ResourceNotFoundException",
                "Message": "Test-defined error",
            }
        },
        "msg",
    )
    domain_ret = dict(
        DomainName="testdomain",
        ElasticsearchClusterConfig={},
        EBSOptions={},
        AccessPolicies={},
        SnapshotOptions={},
        AdvancedOptions={},
    )
log = logging.getLogger(__name__)
class BotoElasticsearchDomainTestCaseBase(TestCase, LoaderModuleMockMixin):
    conn = None
    def setup_loader_modules(self):
        self.opts = salt.config.DEFAULT_MINION_OPTS.copy()
        utils = salt.loader.utils(
            self.opts,
            whitelist=["boto3", "args", "systemd", "path", "platform"],
            context={},
        )
        return {boto_elasticsearch_domain: {"__utils__": utils}}
    def setUp(self):
        super().setUp()
        boto_elasticsearch_domain.__init__(self.opts)
        del self.opts
        conn_parameters["key"] = "".join(
            random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
        )
        self.patcher = patch("boto3.session.Session")
        self.addCleanup(self.patcher.stop)
        self.addCleanup(delattr, self, "patcher")
        mock_session = self.patcher.start()
        session_instance = mock_session.return_value
        self.conn = MagicMock()
        self.addCleanup(delattr, self, "conn")
        session_instance.client.return_value = self.conn
class BotoElasticsearchDomainTestCaseMixin:
    pass
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(
    _has_required_boto() is False,
    "The boto3 module must be greater than or equal to version {}".format(
        required_boto3_version
    ),
)
class BotoElasticsearchDomainTestCase(
    BotoElasticsearchDomainTestCaseBase, BotoElasticsearchDomainTestCaseMixin
):
    def test_that_when_checking_if_a_domain_exists_and_a_domain_exists_the_domain_exists_method_returns_true(
        self,
    ):
        result = boto_elasticsearch_domain.exists(
            DomainName="testdomain", **conn_parameters
        )
        self.assertTrue(result["exists"])
    def test_that_when_checking_if_a_domain_exists_and_a_domain_does_not_exist_the_domain_exists_method_returns_false(
        self,
    ):
        self.conn.describe_elasticsearch_domain.side_effect = not_found_error
        result = boto_elasticsearch_domain.exists(
            DomainName="mydomain", **conn_parameters
        )
        self.assertFalse(result["exists"])
    def test_that_when_checking_if_a_domain_exists_and_boto3_returns_an_error_the_domain_exists_method_returns_error(
        self,
    ):
        self.conn.describe_elasticsearch_domain.side_effect = ClientError(
            error_content, "list_domains"
        )
        result = boto_elasticsearch_domain.exists(
            DomainName="mydomain", **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"), error_message.format("list_domains")
        )
    def test_that_when_checking_domain_status_and_a_domain_exists_the_domain_status_method_returns_info(
        self,
    ):
        self.conn.describe_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        result = boto_elasticsearch_domain.status(
            DomainName="testdomain", **conn_parameters
        )
        self.assertTrue(result["domain"])
    def test_that_when_checking_domain_status_and_boto3_returns_an_error_the_domain_status_method_returns_error(
        self,
    ):
        self.conn.describe_elasticsearch_domain.side_effect = ClientError(
            error_content, "list_domains"
        )
        result = boto_elasticsearch_domain.status(
            DomainName="mydomain", **conn_parameters
        )
        self.assertEqual(
            result.get("error", {}).get("message"), error_message.format("list_domains")
        )
    def test_that_when_describing_domain_it_returns_the_dict_of_properties_returns_true(
        self,
    ):
        domainconfig = {}
        for k, v in domain_ret.items():
            if k == "DomainName":
                continue
            domainconfig[k] = {"Options": v}
        self.conn.describe_elasticsearch_domain_config.return_value = {
            "DomainConfig": domainconfig
        }
        result = boto_elasticsearch_domain.describe(
            DomainName=domain_ret["DomainName"], **conn_parameters
        )
        log.warning(result)
        desired_ret = copy.copy(domain_ret)
        desired_ret.pop("DomainName")
        self.assertEqual(result, {"domain": desired_ret})
    def test_that_when_describing_domain_on_client_error_it_returns_error(self):
        self.conn.describe_elasticsearch_domain_config.side_effect = ClientError(
            error_content, "list_domains"
        )
        result = boto_elasticsearch_domain.describe(
            DomainName="testdomain", **conn_parameters
        )
        self.assertTrue("error" in result)
    def test_that_when_creating_a_domain_succeeds_the_create_domain_method_returns_true(
        self,
    ):
        self.conn.create_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        args = copy.copy(domain_ret)
        args.update(conn_parameters)
        result = boto_elasticsearch_domain.create(**args)
        self.assertTrue(result["created"])
    def test_that_when_creating_a_domain_fails_the_create_domain_method_returns_error(
        self,
    ):
        self.conn.create_elasticsearch_domain.side_effect = ClientError(
            error_content, "create_domain"
        )
        args = copy.copy(domain_ret)
        args.update(conn_parameters)
        result = boto_elasticsearch_domain.create(**args)
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("create_domain"),
        )
    def test_that_when_deleting_a_domain_succeeds_the_delete_domain_method_returns_true(
        self,
    ):
        result = boto_elasticsearch_domain.delete(
            DomainName="testdomain", **conn_parameters
        )
        self.assertTrue(result["deleted"])
    def test_that_when_deleting_a_domain_fails_the_delete_domain_method_returns_false(
        self,
    ):
        self.conn.delete_elasticsearch_domain.side_effect = ClientError(
            error_content, "delete_domain"
        )
        result = boto_elasticsearch_domain.delete(
            DomainName="testdomain", **conn_parameters
        )
        self.assertFalse(result["deleted"])
    def test_that_when_updating_a_domain_succeeds_the_update_domain_method_returns_true(
        self,
    ):
        self.conn.update_elasticsearch_domain_config.return_value = {
            "DomainConfig": domain_ret
        }
        args = copy.copy(domain_ret)
        args.update(conn_parameters)
        result = boto_elasticsearch_domain.update(**args)
        self.assertTrue(result["updated"])
    def test_that_when_updating_a_domain_fails_the_update_domain_method_returns_error(
        self,
    ):
        self.conn.update_elasticsearch_domain_config.side_effect = ClientError(
            error_content, "update_domain"
        )
        args = copy.copy(domain_ret)
        args.update(conn_parameters)
        result = boto_elasticsearch_domain.update(**args)
        self.assertEqual(
            result.get("error", {}).get("message"),
            error_message.format("update_domain"),
        )
    def test_that_when_adding_tags_succeeds_the_add_tags_method_returns_true(self):
        self.conn.describe_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        result = boto_elasticsearch_domain.add_tags(
            DomainName="testdomain", a="b", **conn_parameters
        )
        self.assertTrue(result["tagged"])
    def test_that_when_adding_tags_fails_the_add_tags_method_returns_false(self):
        self.conn.add_tags.side_effect = ClientError(error_content, "add_tags")
        self.conn.describe_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        result = boto_elasticsearch_domain.add_tags(
            DomainName=domain_ret["DomainName"], a="b", **conn_parameters
        )
        self.assertFalse(result["tagged"])
    def test_that_when_removing_tags_succeeds_the_remove_tags_method_returns_true(self):
        self.conn.describe_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        result = boto_elasticsearch_domain.remove_tags(
            DomainName=domain_ret["DomainName"], TagKeys=["a"], **conn_parameters
        )
        self.assertTrue(result["tagged"])
    def test_that_when_removing_tags_fails_the_remove_tags_method_returns_false(self):
        self.conn.remove_tags.side_effect = ClientError(error_content, "remove_tags")
        self.conn.describe_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        result = boto_elasticsearch_domain.remove_tags(
            DomainName=domain_ret["DomainName"], TagKeys=["b"], **conn_parameters
        )
        self.assertFalse(result["tagged"])
    def test_that_when_listing_tags_succeeds_the_list_tags_method_returns_true(self):
        self.conn.describe_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        result = boto_elasticsearch_domain.list_tags(
            DomainName=domain_ret["DomainName"], **conn_parameters
        )
        self.assertEqual(result["tags"], {})
    def test_that_when_listing_tags_fails_the_list_tags_method_returns_false(self):
        self.conn.list_tags.side_effect = ClientError(error_content, "list_tags")
        self.conn.describe_elasticsearch_domain.return_value = {
            "DomainStatus": domain_ret
        }
        result = boto_elasticsearch_domain.list_tags(
            DomainName=domain_ret["DomainName"], **conn_parameters
        )
        self.assertTrue(result["error"])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>junos_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>import copy
import json
import logging
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import os
import re
from functools import wraps
import salt.utils.args
import salt.utils.files
import salt.utils.json
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import yaml
try:
    from</b></font> lxml import etree
except ImportError:
    import xml.etree.ElementTree as etree
try:
    import jnpr.junos.cfg
    import jnpr.junos.op as tables_dir
    import jnpr.junos.utils
    import jxmlease
    import yamlordereddictloader
    from jnpr.junos import Device
    from jnpr.junos.exception import (
        ConnectClosedError,
        LockError,
        RpcTimeoutError,
        UnlockError,
    )
    from jnpr.junos.factory.cfgtable import CfgTable
    from jnpr.junos.factory.factory_loader import FactoryLoader
    from jnpr.junos.factory.optable import OpTable
    from jnpr.junos.utils.config import Config
    from jnpr.junos.utils.scp import SCP
    from jnpr.junos.utils.sw import SW
    HAS_JUNOS = True
except ImportError:
    HAS_JUNOS = False
log = logging.getLogger(__name__)
__virtualname__ = "junos"
__proxyenabled__ = ["junos"]
def __virtual__():
    if HAS_JUNOS and "proxy" in __opts__:
        return __virtualname__
    else:
        return (
            False,
            "The junos or dependent module could not be loaded: "
            "junos-eznc or jxmlease or yamlordereddictloader or "
            "proxy could not be loaded.",
        )
class HandleFileCopy:
    def __init__(self, path, **kwargs):
        self._file_path = path
        self._cached_folder = None
        self._cached_file = None
        self._kwargs = kwargs
    def __enter__(self):
        if self._file_path.startswith("salt://"):
            local_cache_path = __salt__["cp.is_cached"](self._file_path)
            if local_cache_path:
                master_hash = __salt__["cp.hash_file"](self._file_path)
                proxy_hash = __salt__["file.get_hash"](local_cache_path)
                if master_hash.get("hsum") == proxy_hash:
                    self._cached_file = salt.utils.files.mkstemp()
                    with salt.utils.files.fopen(self._cached_file, "w") as fp:
                        template_string = __salt__["slsutil.renderer"](
                            path=local_cache_path,
                            default_renderer="jinja",
                            **self._kwargs,
                        )
                        fp.write(template_string)
                    return self._cached_file
            self._cached_file = salt.utils.files.mkstemp()
            __salt__["cp.get_template"](
                self._file_path, self._cached_file, **self._kwargs
            )
            if self._cached_file != "":
                return self._cached_file
        else:
            if __salt__["file.file_exists"](self._file_path):
                self._cached_file = salt.utils.files.mkstemp()
                with salt.utils.files.fopen(self._cached_file, "w") as fp:
                    template_string = __salt__["slsutil.renderer"](
                        path=self._file_path, default_renderer="jinja", **self._kwargs
                    )
                    fp.write(template_string)
                return self._cached_file
    def __exit__(self, exc_type, exc_value, exc_traceback):
        if self._cached_file is not None:
            salt.utils.files.safe_rm(self._cached_file)
            log.debug("Deleted cached file: %s", self._cached_file)
        if self._cached_folder is not None:
            __salt__["file.rmdir"](self._cached_folder)
            log.debug("Deleted cached folder: %s", self._cached_folder)
def _timeout_decorator(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        if "dev_timeout" in kwargs or "timeout" in kwargs:
            ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
            conn = __proxy__["junos.conn"]()
            restore_timeout = conn.timeout
            conn.timeout = ldev_timeout
            try:
                result = function(*args, **kwargs)
                conn.timeout = restore_timeout
                return result
            except Exception:  # pylint: disable=broad-except
                conn.timeout = restore_timeout
                raise
        else:
            return function(*args, **kwargs)
    return wrapper
def _timeout_decorator_cleankwargs(function):
    @wraps(function)
    def wrapper(*args, **kwargs):
        if "dev_timeout" in kwargs or "timeout" in kwargs:
            ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
            conn = __proxy__["junos.conn"]()
            restore_timeout = conn.timeout
            conn.timeout = ldev_timeout
            try:
                restore_kwargs = False
                del_list = []
                op = {}
                op.update(kwargs)
                for keychk in kwargs:
                    if keychk.startswith("__pub"):
                        del_list.append(keychk)
                if del_list:
                    restore_kwargs = True
                    for delkey in del_list:
                        kwargs.pop(delkey)
                result = function(*args, **kwargs)
                if restore_kwargs:
                    kwargs.update(op)
                conn.timeout = restore_timeout
                return result
            except Exception:  # pylint: disable=broad-except
                conn.timeout = restore_timeout
                raise
        else:
            restore_kwargs = False
            del_list = []
            op = {}
            op.update(kwargs)
            for keychk in kwargs:
                if keychk.startswith("__pub"):
                    del_list.append(keychk)
            if del_list:
                restore_kwargs = True
                for delkey in del_list:
                    kwargs.pop(delkey)
            ret = function(*args, **kwargs)
            if restore_kwargs:
                kwargs.update(op)
            return ret
    return wrapper
def _restart_connection():
    minion_id = __opts__.get("proxyid", "") or __opts__.get("id", "")
    log.info(
        "Junos exception occurred %s (junos proxy) is down. Restarting.", minion_id
    )
    __salt__["event.fire_master"](
        {}, "junos/proxy/{}/stop".format(__opts__["proxy"]["host"])
    )
    __proxy__["junos.shutdown"](__opts__)  # safely close connection
    __proxy__["junos.init"](__opts__)  # reopen connection
    log.debug("Junos exception occurred, restarted %s (junos proxy)!", minion_id)
@_timeout_decorator_cleankwargs
def facts_refresh():
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    try:
        conn.facts_refresh()
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Execution failed due to "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
        return ret
    ret["facts"] = __proxy__["junos.get_serialized_facts"]()
    try:
        __salt__["saltutil.sync_grains"]()
    except Exception as exception:  # pylint: disable=broad-except
        log.error('Grains could not be updated due to "%s"', exception)
    return ret
def facts():
    ret = {}
    try:
        ret["facts"] = __proxy__["junos.get_serialized_facts"]()
        ret["out"] = True
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not display facts due to "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
    return ret
@_timeout_decorator
def rpc(cmd=None, dest=None, **kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    op = dict()
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    elif "__pub_schedule" in kwargs:
        for key, value in kwargs.items():
            if not key.startswith("__pub_"):
                op[key] = value
    else:
        op.update(kwargs)
    if cmd is None:
        ret["message"] = "Please provide the rpc to execute."
        ret["out"] = False
        return ret
    format_ = op.pop("format", "xml")
    op.pop("dest", dest)
    if cmd in ["get-config", "get_config"]:
        filter_reply = None
        if "filter" in op:
            try:
                filter_reply = etree.XML(op["filter"])
            except etree.XMLSyntaxError as ex:
                ret["message"] = "Invalid filter: {}".format(str(ex))
                ret["out"] = False
                return ret
            del op["filter"]
        op.update({"format": format_})
        try:
            reply = getattr(conn.rpc, cmd.replace("-", "_"))(filter_reply, options=op)
        except Exception as exception:  # pylint: disable=broad-except
            ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
            ret["out"] = False
            _restart_connection()
            return ret
    else:
        if "filter" in op:
            log.warning('Filter ignored as it is only used with "get-config" rpc')
        if "dest" in op:
            log.warning("dest in op, rpc may reject this for cmd '%s'", cmd)
        try:
            reply = getattr(conn.rpc, cmd.replace("-", "_"))({"format": format_}, **op)
        except Exception as exception:  # pylint: disable=broad-except
            ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
            ret["out"] = False
            _restart_connection()
            return ret
    if format_ == "text":
        ret["rpc_reply"] = reply.text
    elif format_ == "json":
        ret["rpc_reply"] = reply
    else:
        ret["rpc_reply"] = jxmlease.parse(etree.tostring(reply))
    if dest:
        if format_ == "text":
            write_response = reply.text
        elif format_ == "json":
            write_response = salt.utils.json.dumps(reply, indent=1)
        else:
            write_response = etree.tostring(reply)
        with salt.utils.files.fopen(dest, "w") as fp:
            fp.write(salt.utils.stringutils.to_str(write_response))
    return ret
@_timeout_decorator
def set_hostname(hostname=None, **kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    if hostname is None:
        ret["message"] = "Please provide the hostname."
        ret["out"] = False
        return ret
    op = dict()
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    set_string = "set system host-name {}".format(hostname)
    try:
        conn.cu.load(set_string, format="set")
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not load configuration due to error "{}"'.format(
            exception
        )
        ret["out"] = False
        _restart_connection()
        return ret
    try:
        commit_ok = conn.cu.commit_check()
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not commit check due to error "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
        return ret
    if commit_ok:
        try:
            conn.cu.commit(**op)
            ret["message"] = "Successfully changed hostname."
            ret["out"] = True
        except Exception as exception:  # pylint: disable=broad-except
            ret["out"] = False
            ret[
                "message"
            ] = 'Successfully loaded host-name but commit failed with "{}"'.format(
                exception
            )
            _restart_connection()
            return ret
    else:
        ret["out"] = False
        ret["message"] = "Successfully loaded host-name but pre-commit check failed."
        try:
            conn.cu.rollback()
        except Exception as exception:  # pylint: disable=broad-except
            ret["out"] = False
            ret[
                "message"
            ] = 'Successfully loaded host-name but rollback before exit failed "{}"'.format(
                exception
            )
            _restart_connection()
    return ret
@_timeout_decorator
def commit(**kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    op = dict()
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    op["detail"] = op.get("detail", False)
    try:
        commit_ok = conn.cu.commit_check()
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not perform commit check due to "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
        return ret
    if commit_ok:
        try:
            commit = conn.cu.commit(**op)
            ret["out"] = True
            if commit:
                if op["detail"]:
                    ret["message"] = jxmlease.parse(etree.tostring(commit))
                else:
                    ret["message"] = "Commit Successful."
            else:
                ret["message"] = "Commit failed."
                ret["out"] = False
        except Exception as exception:  # pylint: disable=broad-except
            ret["out"] = False
            ret[
                "message"
            ] = 'Commit check succeeded but actual commit failed with "{}"'.format(
                exception
            )
            _restart_connection()
    else:
        ret["out"] = False
        ret["message"] = "Pre-commit check failed."
        try:
            conn.cu.rollback()
        except Exception as exception:  # pylint: disable=broad-except
            ret["out"] = False
            ret[
                "message"
            ] = 'Pre-commit check failed, and exception during rollback "{}"'.format(
                exception
            )
            _restart_connection()
    return ret
@_timeout_decorator
def rollback(**kwargs):
    ids_passed = 0
    id_ = 0
    if "d_id" in kwargs:
        id_ = kwargs.pop("d_id")
        ids_passed = ids_passed + 1
    if "id" in kwargs:
        id_ = kwargs.pop("id", 0)
        ids_passed = ids_passed + 1
    if ids_passed &gt; 1:
        log.warning(
            "junos.rollback called with more than one possible ID. "
            "Use only one of the positional argument, `id`, or `d_id` kwargs"
        )
    ret = {}
    conn = __proxy__["junos.conn"]()
    op = dict()
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    try:
        ret["out"] = conn.cu.rollback(id_)
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Rollback failed due to "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
        return ret
    if ret["out"]:
        ret["message"] = "Rollback successful"
    else:
        ret["message"] = "Rollback failed"
        return ret
    if "diffs_file" in op and op["diffs_file"] is not None:
        diff = conn.cu.diff()
        if diff is not None:
            with salt.utils.files.fopen(op["diffs_file"], "w") as fp:
                fp.write(salt.utils.stringutils.to_str(diff))
        else:
            log.info(
                "No diff between current configuration and "
                "rollbacked configuration, so no diff file created"
            )
    try:
        commit_ok = conn.cu.commit_check()
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not commit check due to "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
        return ret
    if commit_ok:
        try:
            conn.cu.commit(**op)
            ret["out"] = True
        except Exception as exception:  # pylint: disable=broad-except
            ret["out"] = False
            ret[
                "message"
            ] = 'Rollback successful but commit failed with error "{}"'.format(
                exception
            )
            _restart_connection()
            return ret
    else:
        ret["message"] = "Rollback successful but pre-commit check failed."
        ret["out"] = False
    return ret
@_timeout_decorator
def diff(**kwargs):
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    ids_passed = 0
    id_ = 0
    if "d_id" in kwargs:
        id_ = kwargs.pop("d_id")
        ids_passed = ids_passed + 1
    if "id" in kwargs:
        id_ = kwargs.pop("id", 0)
        ids_passed = ids_passed + 1
    if ids_passed &gt; 1:
        log.warning(
            "junos.rollback called with more than one possible ID. "
            "Use only one of the positional argument, `id`, or `d_id` kwargs"
        )
    if kwargs:
        salt.utils.args.invalid_kwargs(kwargs)
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    try:
        ret["message"] = conn.cu.diff(rb_id=id_)
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not get diff with error "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
    return ret
@_timeout_decorator
def ping(dest_ip=None, **kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    if dest_ip is None:
        ret["message"] = "Please specify the destination ip to ping."
        ret["out"] = False
        return ret
    op = {"host": dest_ip}
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    op["count"] = str(op.pop("count", 5))
    if "ttl" in op:
        op["ttl"] = str(op["ttl"])
    ret["out"] = True
    try:
        ret["message"] = jxmlease.parse(etree.tostring(conn.rpc.ping(**op)))
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Execution failed due to "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
    return ret
@_timeout_decorator
def cli(command=None, **kwargs):
    conn = __proxy__["junos.conn"]()
    format_ = kwargs.pop("format", "text")
    if not format_:
        format_ = "text"
    ret = {}
    if command is None:
        ret["message"] = "Please provide the CLI command to be executed."
        ret["out"] = False
        return ret
    op = dict()
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    try:
        result = conn.cli(command, format_, warning=False)
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Execution failed due to "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
        return ret
    if format_ == "text":
        ret["message"] = result
    else:
        result = etree.tostring(result)
        ret["message"] = jxmlease.parse(result)
    if "dest" in op and op["dest"] is not None:
        try:
            with salt.utils.files.fopen(op["dest"], "w") as fp:
                fp.write(salt.utils.stringutils.to_str(result))
        except OSError:
            ret["message"] = 'Unable to open "{}" to write'.format(op["dest"])
            ret["out"] = False
            return ret
    ret["out"] = True
    return ret
@_timeout_decorator
def shutdown(**kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    sw = SW(conn)
    op = {}
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    if "shutdown" not in op and "reboot" not in op:
        ret["message"] = "Provide either one of the arguments: shutdown or reboot."
        ret["out"] = False
        return ret
    try:
        if "reboot" in op and op["reboot"]:
            shut = sw.reboot
        elif "shutdown" in op and op["shutdown"]:
            shut = sw.poweroff
        else:
            ret["message"] = "Nothing to be done."
            ret["out"] = False
            return ret
        if "in_min" in op:
            shut(in_min=op["in_min"])
        elif "at" in op:
            shut(at=op["at"])
        else:
            shut()
        ret["message"] = "Successfully powered off/rebooted."
        ret["out"] = True
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not poweroff/reboot because "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
    return ret
@_timeout_decorator
def install_config(path=None, **kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    if path is None:
        ret[
            "message"
        ] = "Please provide the salt path where the configuration is present"
        ret["out"] = False
        return ret
    op = {}
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    test = op.pop("test", False)
    kwargs = {}
    if "template_vars" in op:
        kwargs.update({"template_vars": op["template_vars"]})
    with HandleFileCopy(path, **kwargs) as template_cached_path:
        if template_cached_path is None:
            ret["message"] = "Invalid file path."
            ret["out"] = False
            return ret
        if os.path.getsize(template_cached_path) == 0:
            ret["message"] = "Template failed to render"
            ret["out"] = False
            return ret
        write_diff = ""
        if "diffs_file" in op and op["diffs_file"] is not None:
            write_diff = op["diffs_file"]
            del op["diffs_file"]
        op["path"] = template_cached_path
        if "format" not in op:
            if path.endswith("set"):
                template_format = "set"
            elif path.endswith("xml"):
                template_format = "xml"
            elif path.endswith("json"):
                template_format = "json"
            else:
                template_format = "text"
            op["format"] = template_format
        if "replace" in op and op["replace"]:
            op["merge"] = False
            del op["replace"]
        elif "overwrite" in op and op["overwrite"]:
            op["overwrite"] = True
        elif "overwrite" in op and not op["overwrite"]:
            op["merge"] = True
            del op["overwrite"]
        db_mode = op.pop("mode", "exclusive")
        if write_diff and db_mode in ["dynamic", "ephemeral"]:
            ret[
                "message"
            ] = "Write diff is not supported with dynamic/ephemeral configuration mode"
            ret["out"] = False
            return ret
        config_params = {}
        if "ephemeral_instance" in op:
            config_params["ephemeral_instance"] = op.pop("ephemeral_instance")
        try:
            with Config(conn, mode=db_mode, **config_params) as cu:
                try:
                    cu.load(**op)
                except Exception as exception:  # pylint: disable=broad-except
                    ret[
                        "message"
                    ] = 'Could not load configuration due to : "{}"'.format(exception)
                    ret["format"] = op["format"]
                    ret["out"] = False
                    _restart_connection()
                    return ret
                config_diff = None
                if db_mode in ["dynamic", "ephemeral"]:
                    log.warning("diff is not supported for dynamic and ephemeral")
                else:
                    config_diff = cu.diff()
                    if config_diff is None:
                        ret["message"] = "Configuration already applied!"
                        ret["out"] = True
                        return ret
                commit_params = {}
                if "confirm" in op:
                    commit_params["confirm"] = op["confirm"]
                if "comment" in op:
                    commit_params["comment"] = op["comment"]
                check = True
                if db_mode in ["dynamic", "ephemeral"]:
                    log.warning("commit check not supported for dynamic and ephemeral")
                else:
                    try:
                        check = cu.commit_check()
                    except Exception as exception:  # pylint: disable=broad-except
                        ret[
                            "message"
                        ] = 'Commit check threw the following exception: "{}"'.format(
                            exception
                        )
                        ret["out"] = False
                        _restart_connection()
                        return ret
                if check and not test:
                    try:
                        cu.commit(**commit_params)
                        ret["message"] = "Successfully loaded and committed!"
                    except Exception as exception:  # pylint: disable=broad-except
                        ret[
                            "message"
                        ] = 'Commit check successful but commit failed with "{}"'.format(
                            exception
                        )
                        ret["out"] = False
                        _restart_connection()
                        return ret
                elif not check:
                    try:
                        cu.rollback()
                        ret["message"] = (
                            "Loaded configuration but commit check failed, hence"
                            " rolling back configuration."
                        )
                    except Exception as exception:  # pylint: disable=broad-except
                        ret["message"] = (
                            "Loaded configuration but commit check failed, and"
                            ' exception occurred during rolling back configuration "{}"'.format(
                                exception
                            )
                        )
                        _restart_connection()
                    ret["out"] = False
                else:
                    try:
                        cu.rollback()
                        ret["message"] = (
                            "Commit check passed, but skipping commit for dry-run and"
                            " rolling back configuration."
                        )
                        ret["out"] = True
                    except Exception as exception:  # pylint: disable=broad-except
                        ret["message"] = (
                            "Commit check passed, but skipping commit for dry-run and"
                            ' while rolling back configuration exception occurred "{}"'.format(
                                exception
                            )
                        )
                        ret["out"] = False
                        _restart_connection()
                try:
                    if write_diff and config_diff is not None:
                        with salt.utils.files.fopen(write_diff, "w") as fp:
                            fp.write(salt.utils.stringutils.to_str(config_diff))
                except Exception as exception:  # pylint: disable=broad-except
                    ret[
                        "message"
                    ] = "Could not write into diffs_file due to: '{}'".format(exception)
                    ret["out"] = False
        except ValueError as ex:
            message = "install_config failed due to: {}".format(str(ex))
            log.error(message)
            ret["message"] = message
            ret["out"] = False
        except LockError as ex:
            log.error("Configuration database is locked")
            ret["message"] = ex.message
            ret["out"] = False
        except RpcTimeoutError as ex:
            message = "install_config failed due to timeout error : {}".format(str(ex))
            log.error(message)
            ret["message"] = message
            ret["out"] = False
        except Exception as exc:  # pylint: disable=broad-except
            ret["message"] = "install_config failed due to exception: '{}'".format(exc)
            ret["out"] = False
        return ret
@_timeout_decorator_cleankwargs
def zeroize():
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    try:
        conn.cli("request system zeroize")
        ret["message"] = "Completed zeroize and rebooted"
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = 'Could not zeroize due to : "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
    return ret
@_timeout_decorator
def install_os(path=None, **kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    op = {}
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    dev_timeout = max(op.pop("dev_timeout", 0), op.pop("timeout", 0))
    timeout = max(1800, conn.timeout, dev_timeout)
    reboot = op.pop("reboot", False)
    no_copy_ = op.get("no_copy", False)
    if path is None:
        ret[
            "message"
        ] = "Please provide the salt path where the junos image is present."
        ret["out"] = False
        return ret
    if reboot:
        __proxy__["junos.reboot_active"]()
    install_status = False
    if not no_copy_:
        with HandleFileCopy(path) as image_path:
            if image_path is None:
                ret["message"] = "Invalid path. Please provide a valid image path"
                ret["out"] = False
                __proxy__["junos.reboot_clear"]()
                return ret
            if salt.utils.platform.is_junos():
                tmp_absfile = image_path
                op["no_copy"] = True
                op["remote_path"] = os.path.dirname(tmp_absfile)
                image_path = os.path.basename(tmp_absfile)
            try:
                install_status, install_message = conn.sw.install(
                    image_path, progress=True, timeout=timeout, **op
                )
            except Exception as exception:  # pylint: disable=broad-except
                ret["message"] = 'Installation failed due to: "{}"'.format(exception)
                ret["out"] = False
                __proxy__["junos.reboot_clear"]()
                _restart_connection()
                return ret
    else:
        try:
            install_status, install_message = conn.sw.install(
                path, progress=True, timeout=timeout, **op
            )
        except Exception as exception:  # pylint: disable=broad-except
            ret["message"] = 'Installation failed due to: "{}"'.format(exception)
            ret["out"] = False
            __proxy__["junos.reboot_clear"]()
            _restart_connection()
            return ret
    if install_status is True:
        ret["out"] = True
        ret["message"] = "Installed the os."
    else:
        ret["message"] = "Installation failed. Reason: {}".format(install_message)
        ret["out"] = False
        __proxy__["junos.reboot_clear"]()
        return ret
    if reboot is True:
        reboot_kwargs = {}
        if "vmhost" in op and op.get("vmhost") is True:
            reboot_kwargs["vmhost"] = True
        if "all_re" in op:
            reboot_kwargs["all_re"] = op.get("all_re")
        try:
            __proxy__["junos.reboot_active"]()
            conn.sw.reboot(**reboot_kwargs)
        except Exception as exception:  # pylint: disable=broad-except
            __proxy__["junos.reboot_clear"]()
            ret[
                "message"
            ] = 'Installation successful but reboot failed due to : "{}"'.format(
                exception
            )
            ret["out"] = False
            _restart_connection()
            return ret
        __proxy__["junos.reboot_clear"]()
        ret["out"] = True
        ret["message"] = "Successfully installed and rebooted!"
    return ret
@_timeout_decorator_cleankwargs
def file_copy(src, dest):
    if salt.utils.platform.is_junos():
        return {
            "success": False,
            "message": "This method is unsupported on the current operating system!",
        }
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    with HandleFileCopy(src) as fp:
        if fp is None:
            ret["message"] = "Invalid source file path {}".format(src)
            ret["out"] = False
            return ret
        try:
            with SCP(conn, progress=True) as scp:
                scp.put(fp, dest)
            ret["message"] = "Successfully copied file from {} to {}".format(src, dest)
        except Exception as exception:  # pylint: disable=broad-except
            ret["message"] = 'Could not copy file : "{}"'.format(exception)
            ret["out"] = False
        return ret
@_timeout_decorator_cleankwargs
def lock():
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    try:
        conn.cu.lock()
        ret["message"] = "Successfully locked the configuration."
    except RpcTimeoutError as exception:
        ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
        ret["out"] = False
        _restart_connection()
    except LockError as exception:
        ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
        ret["out"] = False
    return ret
@_timeout_decorator_cleankwargs
def unlock():
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    try:
        conn.cu.unlock()
        ret["message"] = "Successfully unlocked the configuration."
    except RpcTimeoutError as exception:
        ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
            exception
        )
        ret["out"] = False
        _restart_connection()
    except UnlockError as exception:
        ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
            exception
        )
        ret["out"] = False
    return ret
@_timeout_decorator
def load(path=None, **kwargs):
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    if path is None:
        ret[
            "message"
        ] = "Please provide the salt path where the configuration is present"
        ret["out"] = False
        return ret
    op = {}
    if "__pub_arg" in kwargs:
        if kwargs["__pub_arg"]:
            if isinstance(kwargs["__pub_arg"][-1], dict):
                op.update(kwargs["__pub_arg"][-1])
    else:
        op.update(kwargs)
    kwargs = {}
    if "template_vars" in op:
        kwargs.update({"template_vars": op["template_vars"]})
    with HandleFileCopy(path, **kwargs) as template_cached_path:
        if template_cached_path is None:
            ret["message"] = "Invalid file path."
            ret["out"] = False
            return ret
        if os.path.getsize(template_cached_path) == 0:
            ret["message"] = "Template failed to render"
            ret["out"] = False
            return ret
        op["path"] = template_cached_path
        if "format" not in op:
            if path.endswith("set"):
                template_format = "set"
            elif path.endswith("xml"):
                template_format = "xml"
            elif path.endswith("json"):
                template_format = "json"
            else:
                template_format = "text"
            op["format"] = template_format
        actions = [
            item
            for item in ("overwrite", "replace", "update", "merge")
            if op.get(item, False)
        ]
        if len(list(actions)) &gt; 1:
            ret["message"] = "Only one config_action is allowed. Provided: {}".format(
                actions
            )
            ret["out"] = False
            return ret
        if "replace" in op and op["replace"]:
            op["merge"] = False
            del op["replace"]
        elif "overwrite" in op and op["overwrite"]:
            op["overwrite"] = True
        elif "merge" in op and op["merge"]:
            op["merge"] = True
        elif "overwrite" in op and not op["overwrite"]:
            op["merge"] = True
            del op["overwrite"]
        try:
            conn.cu.load(**op)
            ret["message"] = "Successfully loaded the configuration."
        except Exception as exception:  # pylint: disable=broad-except
            ret["message"] = 'Could not load configuration due to : "{}"'.format(
                exception
            )
            ret["format"] = op["format"]
            ret["out"] = False
            _restart_connection()
            return ret
        return ret
@_timeout_decorator_cleankwargs
def commit_check():
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    try:
        conn.cu.commit_check()
        ret["message"] = "Commit check succeeded."
    except Exception as exception:  # pylint: disable=broad-except
        ret["message"] = "Commit check failed with {}".format(exception)
        ret["out"] = False
        _restart_connection()
    return ret
@_timeout_decorator_cleankwargs
def get_table(
    table,
    table_file,
    path=None,
    target=None,
    key=None,
    key_items=None,
    filters=None,
    table_args=None,
):
    conn = __proxy__["junos.conn"]()
    ret = {}
    ret["out"] = True
    ret["hostname"] = conn._hostname
    ret["tablename"] = table
    get_kvargs = {}
    if target is not None:
        get_kvargs["target"] = target
    if key is not None:
        get_kvargs["key"] = key
    if key_items is not None:
        get_kvargs["key_items"] = key_items
    if filters is not None:
        get_kvargs["filters"] = filters
    if table_args is not None and isinstance(table_args, dict):
        get_kvargs["args"] = table_args
    pyez_tables_path = os.path.dirname(os.path.abspath(tables_dir.__file__))
    try:
        if path is not None:
            file_path = os.path.join(path, "{}".format(table_file))
        else:
            file_path = os.path.join(pyez_tables_path, "{}".format(table_file))
        with HandleFileCopy(file_path) as file_loc:
            if file_loc is None:
                ret["message"] = "Given table file {} cannot be located".format(
                    table_file
                )
                ret["out"] = False
                return ret
            try:
                with salt.utils.files.fopen(file_loc) as fp:
                    ret["table"] = yaml.load(
                        fp.read(), Loader=yamlordereddictloader.Loader
                    )
                    globals().update(FactoryLoader().load(ret["table"]))
            except OSError as err:
                ret[
                    "message"
                ] = "Uncaught exception during YAML Load - please report: {}".format(
                    str(err)
                )
                ret["out"] = False
                return ret
            try:
                data = globals()[table](conn)
                data.get(**get_kvargs)
            except KeyError as err:
                ret[
                    "message"
                ] = "Uncaught exception during get API call - please report: {}".format(
                    str(err)
                )
                ret["out"] = False
                return ret
            except ConnectClosedError:
                ret[
                    "message"
                ] = "Got ConnectClosedError exception. Connection lost with {}".format(
                    conn
                )
                ret["out"] = False
                _restart_connection()
                return ret
            ret["reply"] = json.loads(data.to_json())
            if data.__class__.__bases__[0] in [OpTable, CfgTable]:
                if ret["table"][table].get("key") is None:
                    ret["table"][table]["key"] = data.ITEM_NAME_XPATH
                if key is not None:
                    ret["table"][table]["key"] = data.KEY
                if table_args is not None:
                    args = copy.copy(data.GET_ARGS)
                    args.update(table_args)
                    ret["table"][table]["args"] = args
            else:
                if target is not None:
                    ret["table"][table]["target"] = data.TARGET
                if key is not None:
                    ret["table"][table]["key"] = data.KEY
                if key_items is not None:
                    ret["table"][table]["key_items"] = data.KEY_ITEMS
                if table_args is not None:
                    args = copy.copy(data.CMD_ARGS)
                    args.update(table_args)
                    ret["table"][table]["args"] = args
                    ret["table"][table]["command"] = data.GET_CMD
    except ConnectClosedError:
        ret[
            "message"
        ] = "Got ConnectClosedError exception. Connection lost with {}".format(
            str(conn)
        )
        ret["out"] = False
        _restart_connection()
        return ret
    except Exception as err:  # pylint: disable=broad-except
        ret["message"] = "Uncaught exception - please report: {}".format(str(err))
        ret["out"] = False
        _restart_connection()
        return ret
    return ret
def _recursive_dict(node):
    result = {}
    for element in node.iterchildren():
        key = element.tag.split("}")[1] if "}" in element.tag else element.tag
        if element.text and element.text.strip():
            value = element.text
        else:
            value = _recursive_dict(element)
        if key in result:
            if type(result[key]) is list:
                result[key].append(value)
            else:
                tempvalue = result[key].copy()
                result[key] = [tempvalue, value]
        else:
            result[key] = value
    return result
@_timeout_decorator
def rpc_file_list(path, **kwargs):
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    conn = __proxy__["junos.conn"]()
    if conn._conn is None:
        return False
    results = conn.rpc.file_list(path=path)
    ret = {}
    ret["files"] = _recursive_dict(results)
    ret["success"] = True
    return ret
def _strip_newlines(str):
    stripped = str.replace("\n", "")
    return stripped
def _make_source_list(dir):
    dir_list = []
    if not dir:
        return
    base = rpc_file_list(dir)["files"]["directory"]
    if "file-information" not in base:
        if "directory_name" not in base:
            return None
        return [os.path.join(_strip_newlines(base.get("directory-name", None))) + "/"]
    if isinstance(base["file-information"], dict):
        dirname = os.path.join(
            dir, _strip_newlines(base["file-information"]["file-name"])
        )
        if "file-directory" in base["file-information"]:
            new_list = _make_source_list(os.path.join(dir, dirname))
            return new_list
        else:
            return [dirname]
    for entry in base["file-information"]:
        if "file-directory" in entry:
            new_list = _make_source_list(
                os.path.join(dir, _strip_newlines(entry["file-name"]))
            )
            if new_list:
                dir_list.extend(new_list)
        else:
            dir_list.append(os.path.join(dir, _strip_newlines(entry["file-name"])))
    return dir_list
@_timeout_decorator
def file_compare(file1, file2, **kwargs):
    if not salt.utils.platform.is_junos():
        return {
            "success": False,
            "message": "This method is unsupported on the current operating system!",
        }
    ret = {"message": "", "identical": False, "success": True}
    junos_cli = salt.utils.path.which("cli")
    if not junos_cli:
        return {"success": False, "message": "Cannot find Junos cli command"}
    cliret = __salt__["cmd.run"](
        "{} file compare files {} {} ".format(junos_cli, file1, file2)
    )
    clilines = cliret.splitlines()
    for r in clilines:
        if r.strip() != "":
            if "No such file" in r:
                ret["identical"] = False
                ret["success"] = False
                return ret
            ret["identical"] = False
            ret["success"] = True
            return ret
    ret["identical"] = True
    ret["success"] = True
    return ret
@_timeout_decorator
def fsentry_exists(dir, **kwargs):
    if not salt.utils.platform.is_junos():
        return {
            "success": False,
            "message": "This method is unsupported on the current operating system!",
        }
    junos_cli = salt.utils.path.which("cli")
    if not junos_cli:
        return {"success": False, "message": "Cannot find Junos cli command"}
    ret = __salt__["cmd.run"]("{} file show {}".format(junos_cli, dir))
    retlines = ret.splitlines()
    exists = True
    is_dir = False
    status = {"is_dir": False, "exists": True}
    for r in retlines:
        if "could not resolve" in r or "error: Could not connect" in r:
            status["is_dir"] = False
            status["exists"] = False
        if "is not a regular file" in r:
            status["is_dir"] = True
            status["exists"] = True
    return status
def _find_routing_engines():
    junos_cli = salt.utils.path.which("cli")
    if not junos_cli:
        return {"success": False, "message": "Cannot find Junos cli command"}
    re_check = __salt__["cmd.run"]("{} show chassis routing-engine".format(junos_cli))
    engine_present = True
    engine = {}
    current_engine = None
    status = None
    for l in re_check.splitlines():
        if "Slot" in l:
            mat = re.search(".*(\\d+):.*", l)
            if mat:
                current_engine = "re" + str(mat.group(1)) + ":"
        if "Current state" in l:
            if "Master" in l:
                status = "Master"
            if "Disabled" in l:
                status = "Disabled"
            if "Backup" in l:
                status = "Backup"
        if current_engine and status:
            engine[current_engine] = status
            current_engine = None
            status = None
    if not engine:
        return {
            "success": False,
            "message": "Junos cli command returned no information",
        }
    engine["success"] = True
    return engine
@_timeout_decorator
def routing_engine(**kwargs):
    engine_status = _find_routing_engines()
    if not engine_status["success"]:
        return {"success": False}
    master = None
    backup = []
    for k, v in engine_status.items():
        if v == "Master":
            master = k
        if v == "Backup" or v == "Disabled":
            backup.append(k)
    if master:
        ret = {"master": master, "backup": backup, "success": True}
    else:
        ret = {"master": master, "backup": backup, "success": False}
    log.debug(ret)
    return ret
@_timeout_decorator
def dir_copy(source, dest, force=False, **kwargs):
    if not salt.utils.platform.is_junos():
        return {
            "success": False,
            "message": "This method is unsupported on the current operating system!",
        }
    junos_cli = salt.utils.path.which("cli")
    if not junos_cli:
        return {"success": False, "message": "Cannot find Junos cli command"}
    ret = {}
    ret_messages = ""
    if not source.startswith("/"):
        ret["message"] = "Source directory must be a fully qualified path."
        ret["success"] = False
        return ret
    if not (dest.endswith(":") or dest.startswith("/")):
        ret["message"] = (
            "Destination must be a routing engine reference (e.g. re1:) or a fully"
            " qualified path."
        )
        ret["success"] = False
        return ret
    check_source = fsentry_exists(source)
    if not check_source["exists"]:
        ret["message"] = "Source does not exist"
        ret["success"] = False
        return ret
    if not check_source["is_dir"]:
        ret["message"] = "Source is not a directory."
        ret["success"] = False
        return ret
    filelist = _make_source_list(source)
    dirops = []
    for f in filelist:
        splitpath = os.path.split(f)[0]
        fullpath = "/"
        for component in splitpath.split("/"):
            fullpath = os.path.join(fullpath, component)
            if fullpath not in dirops:
                dirops.append(fullpath)
    for d in dirops:
        target = dest + d
        status = fsentry_exists(target)
        if not status["exists"]:
            ret = __salt__["cmd.run"](
                "{} file make-directory {}".format(junos_cli, target)
            )
            ret = ret_messages + ret
        else:
            ret_messages = ret_messages + "Directory " + target + " already exists.\n"
    for f in filelist:
        if not f.endswith("/"):
            target = dest + f
            comp_result = file_compare(f, target)
            if not comp_result["identical"] or force:
                ret = __salt__["cmd.run"](
                    "{} file copy {} {}".format(junos_cli, f, target)
                )
                ret = ret_messages + ret
            else:
                ret_messages = (
                    ret_messages
                    + "Files {} and {} are identical, not copying.\n".format(f, target)
                )
    return ret_messages
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
