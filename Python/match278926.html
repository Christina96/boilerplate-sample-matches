<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_elasticsearch_domain_1.py &amp; junos_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_elasticsearch_domain_1.py &amp; junos_1.py
      </h3>
<h1 align="center">
        0.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_elasticsearch_domain_1.py (2.5974026%)<th>junos_1.py (0.45300114%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-15)<td><a href="#" name="0">(19-32)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_elasticsearch_domain_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import random
3 import string
4 import salt.loader
5 import salt.modules.boto_elasticsearch_domain as boto_elasticsearch_domain
6 from salt.utils.versions import LooseVersion
7 from tests.support.mixins import LoaderModuleMockMixin
8 from tests.support.mock import MagicMock, patch
9 from tests.support.unit import TestCase, skipIf
10 try:
11     import</b></font> boto3
12     from botocore.exceptions import ClientError
13     HAS_BOTO = True
14 except ImportError:
15     HAS_BOTO = False
16 required_boto3_version = "1.2.1"
17 def _has_required_boto():
18     if not HAS_BOTO:
19         return False
20     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
21         return False
22     else:
23         return True
24 if _has_required_boto():
25     region = "us-east-1"
26     access_key = "GKTADJGHEIQSXMKKRBJ08H"
27     secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
28     conn_parameters = {
29         "region": region,
30         "key": access_key,
31         "keyid": secret_key,
32         "profile": {},
33     }
34     error_message = (
35         "An error occurred (101) when calling the {0} operation: Test-defined error"
36     )
37     error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
38     not_found_error = ClientError(
39         {
40             "Error": {
41                 "Code": "ResourceNotFoundException",
42                 "Message": "Test-defined error",
43             }
44         },
45         "msg",
46     )
47     domain_ret = dict(
48         DomainName="testdomain",
49         ElasticsearchClusterConfig={},
50         EBSOptions={},
51         AccessPolicies={},
52         SnapshotOptions={},
53         AdvancedOptions={},
54     )
55 log = logging.getLogger(__name__)
56 class BotoElasticsearchDomainTestCaseBase(TestCase, LoaderModuleMockMixin):
57     conn = None
58     def setup_loader_modules(self):
59         self.opts = salt.config.DEFAULT_MINION_OPTS.copy()
60         utils = salt.loader.utils(
61             self.opts,
62             whitelist=["boto3", "args", "systemd", "path", "platform"],
63             context={},
64         )
65         return {boto_elasticsearch_domain: {"__utils__": utils}}
66     def setUp(self):
67         super().setUp()
68         boto_elasticsearch_domain.__init__(self.opts)
69         del self.opts
70         conn_parameters["key"] = "".join(
71             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
72         )
73         self.patcher = patch("boto3.session.Session")
74         self.addCleanup(self.patcher.stop)
75         self.addCleanup(delattr, self, "patcher")
76         mock_session = self.patcher.start()
77         session_instance = mock_session.return_value
78         self.conn = MagicMock()
79         self.addCleanup(delattr, self, "conn")
80         session_instance.client.return_value = self.conn
81 class BotoElasticsearchDomainTestCaseMixin:
82     pass
83 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
84 @skipIf(
85     _has_required_boto() is False,
86     "The boto3 module must be greater than or equal to version {}".format(
87         required_boto3_version
88     ),
89 )
90 class BotoElasticsearchDomainTestCase(
91     BotoElasticsearchDomainTestCaseBase, BotoElasticsearchDomainTestCaseMixin
92 ):
93     def test_that_when_checking_if_a_domain_exists_and_a_domain_exists_the_domain_exists_method_returns_true(
94         self,
95     ):
96         result = boto_elasticsearch_domain.exists(
97             DomainName="testdomain", **conn_parameters
98         )
99         self.assertTrue(result["exists"])
100     def test_that_when_checking_if_a_domain_exists_and_a_domain_does_not_exist_the_domain_exists_method_returns_false(
101         self,
102     ):
103         self.conn.describe_elasticsearch_domain.side_effect = not_found_error
104         result = boto_elasticsearch_domain.exists(
105             DomainName="mydomain", **conn_parameters
106         )
107         self.assertFalse(result["exists"])
108     def test_that_when_checking_if_a_domain_exists_and_boto3_returns_an_error_the_domain_exists_method_returns_error(
109         self,
110     ):
111         self.conn.describe_elasticsearch_domain.side_effect = ClientError(
112             error_content, "list_domains"
113         )
114         result = boto_elasticsearch_domain.exists(
115             DomainName="mydomain", **conn_parameters
116         )
117         self.assertEqual(
118             result.get("error", {}).get("message"), error_message.format("list_domains")
119         )
120     def test_that_when_checking_domain_status_and_a_domain_exists_the_domain_status_method_returns_info(
121         self,
122     ):
123         self.conn.describe_elasticsearch_domain.return_value = {
124             "DomainStatus": domain_ret
125         }
126         result = boto_elasticsearch_domain.status(
127             DomainName="testdomain", **conn_parameters
128         )
129         self.assertTrue(result["domain"])
130     def test_that_when_checking_domain_status_and_boto3_returns_an_error_the_domain_status_method_returns_error(
131         self,
132     ):
133         self.conn.describe_elasticsearch_domain.side_effect = ClientError(
134             error_content, "list_domains"
135         )
136         result = boto_elasticsearch_domain.status(
137             DomainName="mydomain", **conn_parameters
138         )
139         self.assertEqual(
140             result.get("error", {}).get("message"), error_message.format("list_domains")
141         )
142     def test_that_when_describing_domain_it_returns_the_dict_of_properties_returns_true(
143         self,
144     ):
145         domainconfig = {}
146         for k, v in domain_ret.items():
147             if k == "DomainName":
148                 continue
149             domainconfig[k] = {"Options": v}
150         self.conn.describe_elasticsearch_domain_config.return_value = {
151             "DomainConfig": domainconfig
152         }
153         result = boto_elasticsearch_domain.describe(
154             DomainName=domain_ret["DomainName"], **conn_parameters
155         )
156         log.warning(result)
157         desired_ret = copy.copy(domain_ret)
158         desired_ret.pop("DomainName")
159         self.assertEqual(result, {"domain": desired_ret})
160     def test_that_when_describing_domain_on_client_error_it_returns_error(self):
161         self.conn.describe_elasticsearch_domain_config.side_effect = ClientError(
162             error_content, "list_domains"
163         )
164         result = boto_elasticsearch_domain.describe(
165             DomainName="testdomain", **conn_parameters
166         )
167         self.assertTrue("error" in result)
168     def test_that_when_creating_a_domain_succeeds_the_create_domain_method_returns_true(
169         self,
170     ):
171         self.conn.create_elasticsearch_domain.return_value = {
172             "DomainStatus": domain_ret
173         }
174         args = copy.copy(domain_ret)
175         args.update(conn_parameters)
176         result = boto_elasticsearch_domain.create(**args)
177         self.assertTrue(result["created"])
178     def test_that_when_creating_a_domain_fails_the_create_domain_method_returns_error(
179         self,
180     ):
181         self.conn.create_elasticsearch_domain.side_effect = ClientError(
182             error_content, "create_domain"
183         )
184         args = copy.copy(domain_ret)
185         args.update(conn_parameters)
186         result = boto_elasticsearch_domain.create(**args)
187         self.assertEqual(
188             result.get("error", {}).get("message"),
189             error_message.format("create_domain"),
190         )
191     def test_that_when_deleting_a_domain_succeeds_the_delete_domain_method_returns_true(
192         self,
193     ):
194         result = boto_elasticsearch_domain.delete(
195             DomainName="testdomain", **conn_parameters
196         )
197         self.assertTrue(result["deleted"])
198     def test_that_when_deleting_a_domain_fails_the_delete_domain_method_returns_false(
199         self,
200     ):
201         self.conn.delete_elasticsearch_domain.side_effect = ClientError(
202             error_content, "delete_domain"
203         )
204         result = boto_elasticsearch_domain.delete(
205             DomainName="testdomain", **conn_parameters
206         )
207         self.assertFalse(result["deleted"])
208     def test_that_when_updating_a_domain_succeeds_the_update_domain_method_returns_true(
209         self,
210     ):
211         self.conn.update_elasticsearch_domain_config.return_value = {
212             "DomainConfig": domain_ret
213         }
214         args = copy.copy(domain_ret)
215         args.update(conn_parameters)
216         result = boto_elasticsearch_domain.update(**args)
217         self.assertTrue(result["updated"])
218     def test_that_when_updating_a_domain_fails_the_update_domain_method_returns_error(
219         self,
220     ):
221         self.conn.update_elasticsearch_domain_config.side_effect = ClientError(
222             error_content, "update_domain"
223         )
224         args = copy.copy(domain_ret)
225         args.update(conn_parameters)
226         result = boto_elasticsearch_domain.update(**args)
227         self.assertEqual(
228             result.get("error", {}).get("message"),
229             error_message.format("update_domain"),
230         )
231     def test_that_when_adding_tags_succeeds_the_add_tags_method_returns_true(self):
232         self.conn.describe_elasticsearch_domain.return_value = {
233             "DomainStatus": domain_ret
234         }
235         result = boto_elasticsearch_domain.add_tags(
236             DomainName="testdomain", a="b", **conn_parameters
237         )
238         self.assertTrue(result["tagged"])
239     def test_that_when_adding_tags_fails_the_add_tags_method_returns_false(self):
240         self.conn.add_tags.side_effect = ClientError(error_content, "add_tags")
241         self.conn.describe_elasticsearch_domain.return_value = {
242             "DomainStatus": domain_ret
243         }
244         result = boto_elasticsearch_domain.add_tags(
245             DomainName=domain_ret["DomainName"], a="b", **conn_parameters
246         )
247         self.assertFalse(result["tagged"])
248     def test_that_when_removing_tags_succeeds_the_remove_tags_method_returns_true(self):
249         self.conn.describe_elasticsearch_domain.return_value = {
250             "DomainStatus": domain_ret
251         }
252         result = boto_elasticsearch_domain.remove_tags(
253             DomainName=domain_ret["DomainName"], TagKeys=["a"], **conn_parameters
254         )
255         self.assertTrue(result["tagged"])
256     def test_that_when_removing_tags_fails_the_remove_tags_method_returns_false(self):
257         self.conn.remove_tags.side_effect = ClientError(error_content, "remove_tags")
258         self.conn.describe_elasticsearch_domain.return_value = {
259             "DomainStatus": domain_ret
260         }
261         result = boto_elasticsearch_domain.remove_tags(
262             DomainName=domain_ret["DomainName"], TagKeys=["b"], **conn_parameters
263         )
264         self.assertFalse(result["tagged"])
265     def test_that_when_listing_tags_succeeds_the_list_tags_method_returns_true(self):
266         self.conn.describe_elasticsearch_domain.return_value = {
267             "DomainStatus": domain_ret
268         }
269         result = boto_elasticsearch_domain.list_tags(
270             DomainName=domain_ret["DomainName"], **conn_parameters
271         )
272         self.assertEqual(result["tags"], {})
273     def test_that_when_listing_tags_fails_the_list_tags_method_returns_false(self):
274         self.conn.list_tags.side_effect = ClientError(error_content, "list_tags")
275         self.conn.describe_elasticsearch_domain.return_value = {
276             "DomainStatus": domain_ret
277         }
278         result = boto_elasticsearch_domain.list_tags(
279             DomainName=domain_ret["DomainName"], **conn_parameters
280         )
281         self.assertTrue(result["error"])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>junos_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import json
2 import logging
3 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import os
4 import re
5 from functools import wraps
6 import salt.utils.args
7 import salt.utils.files
8 import salt.utils.json
9 import salt.utils.path
10 import salt.utils.platform
11 import salt.utils.stringutils
12 import yaml
13 try:
14     from</b></font> lxml import etree
15 except ImportError:
16     import xml.etree.ElementTree as etree
17 try:
18     import jnpr.junos.cfg
19     import jnpr.junos.op as tables_dir
20     import jnpr.junos.utils
21     import jxmlease
22     import yamlordereddictloader
23     from jnpr.junos import Device
24     from jnpr.junos.exception import (
25         ConnectClosedError,
26         LockError,
27         RpcTimeoutError,
28         UnlockError,
29     )
30     from jnpr.junos.factory.cfgtable import CfgTable
31     from jnpr.junos.factory.factory_loader import FactoryLoader
32     from jnpr.junos.factory.optable import OpTable
33     from jnpr.junos.utils.config import Config
34     from jnpr.junos.utils.scp import SCP
35     from jnpr.junos.utils.sw import SW
36     HAS_JUNOS = True
37 except ImportError:
38     HAS_JUNOS = False
39 log = logging.getLogger(__name__)
40 __virtualname__ = "junos"
41 __proxyenabled__ = ["junos"]
42 def __virtual__():
43     if HAS_JUNOS and "proxy" in __opts__:
44         return __virtualname__
45     else:
46         return (
47             False,
48             "The junos or dependent module could not be loaded: "
49             "junos-eznc or jxmlease or yamlordereddictloader or "
50             "proxy could not be loaded.",
51         )
52 class HandleFileCopy:
53     def __init__(self, path, **kwargs):
54         self._file_path = path
55         self._cached_folder = None
56         self._cached_file = None
57         self._kwargs = kwargs
58     def __enter__(self):
59         if self._file_path.startswith("salt://"):
60             local_cache_path = __salt__["cp.is_cached"](self._file_path)
61             if local_cache_path:
62                 master_hash = __salt__["cp.hash_file"](self._file_path)
63                 proxy_hash = __salt__["file.get_hash"](local_cache_path)
64                 if master_hash.get("hsum") == proxy_hash:
65                     self._cached_file = salt.utils.files.mkstemp()
66                     with salt.utils.files.fopen(self._cached_file, "w") as fp:
67                         template_string = __salt__["slsutil.renderer"](
68                             path=local_cache_path,
69                             default_renderer="jinja",
70                             **self._kwargs,
71                         )
72                         fp.write(template_string)
73                     return self._cached_file
74             self._cached_file = salt.utils.files.mkstemp()
75             __salt__["cp.get_template"](
76                 self._file_path, self._cached_file, **self._kwargs
77             )
78             if self._cached_file != "":
79                 return self._cached_file
80         else:
81             if __salt__["file.file_exists"](self._file_path):
82                 self._cached_file = salt.utils.files.mkstemp()
83                 with salt.utils.files.fopen(self._cached_file, "w") as fp:
84                     template_string = __salt__["slsutil.renderer"](
85                         path=self._file_path, default_renderer="jinja", **self._kwargs
86                     )
87                     fp.write(template_string)
88                 return self._cached_file
89     def __exit__(self, exc_type, exc_value, exc_traceback):
90         if self._cached_file is not None:
91             salt.utils.files.safe_rm(self._cached_file)
92             log.debug("Deleted cached file: %s", self._cached_file)
93         if self._cached_folder is not None:
94             __salt__["file.rmdir"](self._cached_folder)
95             log.debug("Deleted cached folder: %s", self._cached_folder)
96 def _timeout_decorator(function):
97     @wraps(function)
98     def wrapper(*args, **kwargs):
99         if "dev_timeout" in kwargs or "timeout" in kwargs:
100             ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
101             conn = __proxy__["junos.conn"]()
102             restore_timeout = conn.timeout
103             conn.timeout = ldev_timeout
104             try:
105                 result = function(*args, **kwargs)
106                 conn.timeout = restore_timeout
107                 return result
108             except Exception:  # pylint: disable=broad-except
109                 conn.timeout = restore_timeout
110                 raise
111         else:
112             return function(*args, **kwargs)
113     return wrapper
114 def _timeout_decorator_cleankwargs(function):
115     @wraps(function)
116     def wrapper(*args, **kwargs):
117         if "dev_timeout" in kwargs or "timeout" in kwargs:
118             ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
119             conn = __proxy__["junos.conn"]()
120             restore_timeout = conn.timeout
121             conn.timeout = ldev_timeout
122             try:
123                 restore_kwargs = False
124                 del_list = []
125                 op = {}
126                 op.update(kwargs)
127                 for keychk in kwargs:
128                     if keychk.startswith("__pub"):
129                         del_list.append(keychk)
130                 if del_list:
131                     restore_kwargs = True
132                     for delkey in del_list:
133                         kwargs.pop(delkey)
134                 result = function(*args, **kwargs)
135                 if restore_kwargs:
136                     kwargs.update(op)
137                 conn.timeout = restore_timeout
138                 return result
139             except Exception:  # pylint: disable=broad-except
140                 conn.timeout = restore_timeout
141                 raise
142         else:
143             restore_kwargs = False
144             del_list = []
145             op = {}
146             op.update(kwargs)
147             for keychk in kwargs:
148                 if keychk.startswith("__pub"):
149                     del_list.append(keychk)
150             if del_list:
151                 restore_kwargs = True
152                 for delkey in del_list:
153                     kwargs.pop(delkey)
154             ret = function(*args, **kwargs)
155             if restore_kwargs:
156                 kwargs.update(op)
157             return ret
158     return wrapper
159 def _restart_connection():
160     minion_id = __opts__.get("proxyid", "") or __opts__.get("id", "")
161     log.info(
162         "Junos exception occurred %s (junos proxy) is down. Restarting.", minion_id
163     )
164     __salt__["event.fire_master"](
165         {}, "junos/proxy/{}/stop".format(__opts__["proxy"]["host"])
166     )
167     __proxy__["junos.shutdown"](__opts__)  # safely close connection
168     __proxy__["junos.init"](__opts__)  # reopen connection
169     log.debug("Junos exception occurred, restarted %s (junos proxy)!", minion_id)
170 @_timeout_decorator_cleankwargs
171 def facts_refresh():
172     conn = __proxy__["junos.conn"]()
173     ret = {}
174     ret["out"] = True
175     try:
176         conn.facts_refresh()
177     except Exception as exception:  # pylint: disable=broad-except
178         ret["message"] = 'Execution failed due to "{}"'.format(exception)
179         ret["out"] = False
180         _restart_connection()
181         return ret
182     ret["facts"] = __proxy__["junos.get_serialized_facts"]()
183     try:
184         __salt__["saltutil.sync_grains"]()
185     except Exception as exception:  # pylint: disable=broad-except
186         log.error('Grains could not be updated due to "%s"', exception)
187     return ret
188 def facts():
189     ret = {}
190     try:
191         ret["facts"] = __proxy__["junos.get_serialized_facts"]()
192         ret["out"] = True
193     except Exception as exception:  # pylint: disable=broad-except
194         ret["message"] = 'Could not display facts due to "{}"'.format(exception)
195         ret["out"] = False
196         _restart_connection()
197     return ret
198 @_timeout_decorator
199 def rpc(cmd=None, dest=None, **kwargs):
200     conn = __proxy__["junos.conn"]()
201     ret = {}
202     ret["out"] = True
203     op = dict()
204     if "__pub_arg" in kwargs:
205         if kwargs["__pub_arg"]:
206             if isinstance(kwargs["__pub_arg"][-1], dict):
207                 op.update(kwargs["__pub_arg"][-1])
208     elif "__pub_schedule" in kwargs:
209         for key, value in kwargs.items():
210             if not key.startswith("__pub_"):
211                 op[key] = value
212     else:
213         op.update(kwargs)
214     if cmd is None:
215         ret["message"] = "Please provide the rpc to execute."
216         ret["out"] = False
217         return ret
218     format_ = op.pop("format", "xml")
219     op.pop("dest", dest)
220     if cmd in ["get-config", "get_config"]:
221         filter_reply = None
222         if "filter" in op:
223             try:
224                 filter_reply = etree.XML(op["filter"])
225             except etree.XMLSyntaxError as ex:
226                 ret["message"] = "Invalid filter: {}".format(str(ex))
227                 ret["out"] = False
228                 return ret
229             del op["filter"]
230         op.update({"format": format_})
231         try:
232             reply = getattr(conn.rpc, cmd.replace("-", "_"))(filter_reply, options=op)
233         except Exception as exception:  # pylint: disable=broad-except
234             ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
235             ret["out"] = False
236             _restart_connection()
237             return ret
238     else:
239         if "filter" in op:
240             log.warning('Filter ignored as it is only used with "get-config" rpc')
241         if "dest" in op:
242             log.warning("dest in op, rpc may reject this for cmd '%s'", cmd)
243         try:
244             reply = getattr(conn.rpc, cmd.replace("-", "_"))({"format": format_}, **op)
245         except Exception as exception:  # pylint: disable=broad-except
246             ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
247             ret["out"] = False
248             _restart_connection()
249             return ret
250     if format_ == "text":
251         ret["rpc_reply"] = reply.text
252     elif format_ == "json":
253         ret["rpc_reply"] = reply
254     else:
255         ret["rpc_reply"] = jxmlease.parse(etree.tostring(reply))
256     if dest:
257         if format_ == "text":
258             write_response = reply.text
259         elif format_ == "json":
260             write_response = salt.utils.json.dumps(reply, indent=1)
261         else:
262             write_response = etree.tostring(reply)
263         with salt.utils.files.fopen(dest, "w") as fp:
264             fp.write(salt.utils.stringutils.to_str(write_response))
265     return ret
266 @_timeout_decorator
267 def set_hostname(hostname=None, **kwargs):
268     conn = __proxy__["junos.conn"]()
269     ret = {}
270     if hostname is None:
271         ret["message"] = "Please provide the hostname."
272         ret["out"] = False
273         return ret
274     op = dict()
275     if "__pub_arg" in kwargs:
276         if kwargs["__pub_arg"]:
277             if isinstance(kwargs["__pub_arg"][-1], dict):
278                 op.update(kwargs["__pub_arg"][-1])
279     else:
280         op.update(kwargs)
281     set_string = "set system host-name {}".format(hostname)
282     try:
283         conn.cu.load(set_string, format="set")
284     except Exception as exception:  # pylint: disable=broad-except
285         ret["message"] = 'Could not load configuration due to error "{}"'.format(
286             exception
287         )
288         ret["out"] = False
289         _restart_connection()
290         return ret
291     try:
292         commit_ok = conn.cu.commit_check()
293     except Exception as exception:  # pylint: disable=broad-except
294         ret["message"] = 'Could not commit check due to error "{}"'.format(exception)
295         ret["out"] = False
296         _restart_connection()
297         return ret
298     if commit_ok:
299         try:
300             conn.cu.commit(**op)
301             ret["message"] = "Successfully changed hostname."
302             ret["out"] = True
303         except Exception as exception:  # pylint: disable=broad-except
304             ret["out"] = False
305             ret[
306                 "message"
307             ] = 'Successfully loaded host-name but commit failed with "{}"'.format(
308                 exception
309             )
310             _restart_connection()
311             return ret
312     else:
313         ret["out"] = False
314         ret["message"] = "Successfully loaded host-name but pre-commit check failed."
315         try:
316             conn.cu.rollback()
317         except Exception as exception:  # pylint: disable=broad-except
318             ret["out"] = False
319             ret[
320                 "message"
321             ] = 'Successfully loaded host-name but rollback before exit failed "{}"'.format(
322                 exception
323             )
324             _restart_connection()
325     return ret
326 @_timeout_decorator
327 def commit(**kwargs):
328     conn = __proxy__["junos.conn"]()
329     ret = {}
330     op = dict()
331     if "__pub_arg" in kwargs:
332         if kwargs["__pub_arg"]:
333             if isinstance(kwargs["__pub_arg"][-1], dict):
334                 op.update(kwargs["__pub_arg"][-1])
335     else:
336         op.update(kwargs)
337     op["detail"] = op.get("detail", False)
338     try:
339         commit_ok = conn.cu.commit_check()
340     except Exception as exception:  # pylint: disable=broad-except
341         ret["message"] = 'Could not perform commit check due to "{}"'.format(exception)
342         ret["out"] = False
343         _restart_connection()
344         return ret
345     if commit_ok:
346         try:
347             commit = conn.cu.commit(**op)
348             ret["out"] = True
349             if commit:
350                 if op["detail"]:
351                     ret["message"] = jxmlease.parse(etree.tostring(commit))
352                 else:
353                     ret["message"] = "Commit Successful."
354             else:
355                 ret["message"] = "Commit failed."
356                 ret["out"] = False
357         except Exception as exception:  # pylint: disable=broad-except
358             ret["out"] = False
359             ret[
360                 "message"
361             ] = 'Commit check succeeded but actual commit failed with "{}"'.format(
362                 exception
363             )
364             _restart_connection()
365     else:
366         ret["out"] = False
367         ret["message"] = "Pre-commit check failed."
368         try:
369             conn.cu.rollback()
370         except Exception as exception:  # pylint: disable=broad-except
371             ret["out"] = False
372             ret[
373                 "message"
374             ] = 'Pre-commit check failed, and exception during rollback "{}"'.format(
375                 exception
376             )
377             _restart_connection()
378     return ret
379 @_timeout_decorator
380 def rollback(**kwargs):
381     ids_passed = 0
382     id_ = 0
383     if "d_id" in kwargs:
384         id_ = kwargs.pop("d_id")
385         ids_passed = ids_passed + 1
386     if "id" in kwargs:
387         id_ = kwargs.pop("id", 0)
388         ids_passed = ids_passed + 1
389     if ids_passed &gt; 1:
390         log.warning(
391             "junos.rollback called with more than one possible ID. "
392             "Use only one of the positional argument, `id`, or `d_id` kwargs"
393         )
394     ret = {}
395     conn = __proxy__["junos.conn"]()
396     op = dict()
397     if "__pub_arg" in kwargs:
398         if kwargs["__pub_arg"]:
399             if isinstance(kwargs["__pub_arg"][-1], dict):
400                 op.update(kwargs["__pub_arg"][-1])
401     else:
402         op.update(kwargs)
403     try:
404         ret["out"] = conn.cu.rollback(id_)
405     except Exception as exception:  # pylint: disable=broad-except
406         ret["message"] = 'Rollback failed due to "{}"'.format(exception)
407         ret["out"] = False
408         _restart_connection()
409         return ret
410     if ret["out"]:
411         ret["message"] = "Rollback successful"
412     else:
413         ret["message"] = "Rollback failed"
414         return ret
415     if "diffs_file" in op and op["diffs_file"] is not None:
416         diff = conn.cu.diff()
417         if diff is not None:
418             with salt.utils.files.fopen(op["diffs_file"], "w") as fp:
419                 fp.write(salt.utils.stringutils.to_str(diff))
420         else:
421             log.info(
422                 "No diff between current configuration and "
423                 "rollbacked configuration, so no diff file created"
424             )
425     try:
426         commit_ok = conn.cu.commit_check()
427     except Exception as exception:  # pylint: disable=broad-except
428         ret["message"] = 'Could not commit check due to "{}"'.format(exception)
429         ret["out"] = False
430         _restart_connection()
431         return ret
432     if commit_ok:
433         try:
434             conn.cu.commit(**op)
435             ret["out"] = True
436         except Exception as exception:  # pylint: disable=broad-except
437             ret["out"] = False
438             ret[
439                 "message"
440             ] = 'Rollback successful but commit failed with error "{}"'.format(
441                 exception
442             )
443             _restart_connection()
444             return ret
445     else:
446         ret["message"] = "Rollback successful but pre-commit check failed."
447         ret["out"] = False
448     return ret
449 @_timeout_decorator
450 def diff(**kwargs):
451     kwargs = salt.utils.args.clean_kwargs(**kwargs)
452     ids_passed = 0
453     id_ = 0
454     if "d_id" in kwargs:
455         id_ = kwargs.pop("d_id")
456         ids_passed = ids_passed + 1
457     if "id" in kwargs:
458         id_ = kwargs.pop("id", 0)
459         ids_passed = ids_passed + 1
460     if ids_passed &gt; 1:
461         log.warning(
462             "junos.rollback called with more than one possible ID. "
463             "Use only one of the positional argument, `id`, or `d_id` kwargs"
464         )
465     if kwargs:
466         salt.utils.args.invalid_kwargs(kwargs)
467     conn = __proxy__["junos.conn"]()
468     ret = {}
469     ret["out"] = True
470     try:
471         ret["message"] = conn.cu.diff(rb_id=id_)
472     except Exception as exception:  # pylint: disable=broad-except
473         ret["message"] = 'Could not get diff with error "{}"'.format(exception)
474         ret["out"] = False
475         _restart_connection()
476     return ret
477 @_timeout_decorator
478 def ping(dest_ip=None, **kwargs):
479     conn = __proxy__["junos.conn"]()
480     ret = {}
481     if dest_ip is None:
482         ret["message"] = "Please specify the destination ip to ping."
483         ret["out"] = False
484         return ret
485     op = {"host": dest_ip}
486     if "__pub_arg" in kwargs:
487         if kwargs["__pub_arg"]:
488             if isinstance(kwargs["__pub_arg"][-1], dict):
489                 op.update(kwargs["__pub_arg"][-1])
490     else:
491         op.update(kwargs)
492     op["count"] = str(op.pop("count", 5))
493     if "ttl" in op:
494         op["ttl"] = str(op["ttl"])
495     ret["out"] = True
496     try:
497         ret["message"] = jxmlease.parse(etree.tostring(conn.rpc.ping(**op)))
498     except Exception as exception:  # pylint: disable=broad-except
499         ret["message"] = 'Execution failed due to "{}"'.format(exception)
500         ret["out"] = False
501         _restart_connection()
502     return ret
503 @_timeout_decorator
504 def cli(command=None, **kwargs):
505     conn = __proxy__["junos.conn"]()
506     format_ = kwargs.pop("format", "text")
507     if not format_:
508         format_ = "text"
509     ret = {}
510     if command is None:
511         ret["message"] = "Please provide the CLI command to be executed."
512         ret["out"] = False
513         return ret
514     op = dict()
515     if "__pub_arg" in kwargs:
516         if kwargs["__pub_arg"]:
517             if isinstance(kwargs["__pub_arg"][-1], dict):
518                 op.update(kwargs["__pub_arg"][-1])
519     else:
520         op.update(kwargs)
521     try:
522         result = conn.cli(command, format_, warning=False)
523     except Exception as exception:  # pylint: disable=broad-except
524         ret["message"] = 'Execution failed due to "{}"'.format(exception)
525         ret["out"] = False
526         _restart_connection()
527         return ret
528     if format_ == "text":
529         ret["message"] = result
530     else:
531         result = etree.tostring(result)
532         ret["message"] = jxmlease.parse(result)
533     if "dest" in op and op["dest"] is not None:
534         try:
535             with salt.utils.files.fopen(op["dest"], "w") as fp:
536                 fp.write(salt.utils.stringutils.to_str(result))
537         except OSError:
538             ret["message"] = 'Unable to open "{}" to write'.format(op["dest"])
539             ret["out"] = False
540             return ret
541     ret["out"] = True
542     return ret
543 @_timeout_decorator
544 def shutdown(**kwargs):
545     conn = __proxy__["junos.conn"]()
546     ret = {}
547     sw = SW(conn)
548     op = {}
549     if "__pub_arg" in kwargs:
550         if kwargs["__pub_arg"]:
551             if isinstance(kwargs["__pub_arg"][-1], dict):
552                 op.update(kwargs["__pub_arg"][-1])
553     else:
554         op.update(kwargs)
555     if "shutdown" not in op and "reboot" not in op:
556         ret["message"] = "Provide either one of the arguments: shutdown or reboot."
557         ret["out"] = False
558         return ret
559     try:
560         if "reboot" in op and op["reboot"]:
561             shut = sw.reboot
562         elif "shutdown" in op and op["shutdown"]:
563             shut = sw.poweroff
564         else:
565             ret["message"] = "Nothing to be done."
566             ret["out"] = False
567             return ret
568         if "in_min" in op:
569             shut(in_min=op["in_min"])
570         elif "at" in op:
571             shut(at=op["at"])
572         else:
573             shut()
574         ret["message"] = "Successfully powered off/rebooted."
575         ret["out"] = True
576     except Exception as exception:  # pylint: disable=broad-except
577         ret["message"] = 'Could not poweroff/reboot because "{}"'.format(exception)
578         ret["out"] = False
579         _restart_connection()
580     return ret
581 @_timeout_decorator
582 def install_config(path=None, **kwargs):
583     conn = __proxy__["junos.conn"]()
584     ret = {}
585     ret["out"] = True
586     if path is None:
587         ret[
588             "message"
589         ] = "Please provide the salt path where the configuration is present"
590         ret["out"] = False
591         return ret
592     op = {}
593     if "__pub_arg" in kwargs:
594         if kwargs["__pub_arg"]:
595             if isinstance(kwargs["__pub_arg"][-1], dict):
596                 op.update(kwargs["__pub_arg"][-1])
597     else:
598         op.update(kwargs)
599     test = op.pop("test", False)
600     kwargs = {}
601     if "template_vars" in op:
602         kwargs.update({"template_vars": op["template_vars"]})
603     with HandleFileCopy(path, **kwargs) as template_cached_path:
604         if template_cached_path is None:
605             ret["message"] = "Invalid file path."
606             ret["out"] = False
607             return ret
608         if os.path.getsize(template_cached_path) == 0:
609             ret["message"] = "Template failed to render"
610             ret["out"] = False
611             return ret
612         write_diff = ""
613         if "diffs_file" in op and op["diffs_file"] is not None:
614             write_diff = op["diffs_file"]
615             del op["diffs_file"]
616         op["path"] = template_cached_path
617         if "format" not in op:
618             if path.endswith("set"):
619                 template_format = "set"
620             elif path.endswith("xml"):
621                 template_format = "xml"
622             elif path.endswith("json"):
623                 template_format = "json"
624             else:
625                 template_format = "text"
626             op["format"] = template_format
627         if "replace" in op and op["replace"]:
628             op["merge"] = False
629             del op["replace"]
630         elif "overwrite" in op and op["overwrite"]:
631             op["overwrite"] = True
632         elif "overwrite" in op and not op["overwrite"]:
633             op["merge"] = True
634             del op["overwrite"]
635         db_mode = op.pop("mode", "exclusive")
636         if write_diff and db_mode in ["dynamic", "ephemeral"]:
637             ret[
638                 "message"
639             ] = "Write diff is not supported with dynamic/ephemeral configuration mode"
640             ret["out"] = False
641             return ret
642         config_params = {}
643         if "ephemeral_instance" in op:
644             config_params["ephemeral_instance"] = op.pop("ephemeral_instance")
645         try:
646             with Config(conn, mode=db_mode, **config_params) as cu:
647                 try:
648                     cu.load(**op)
649                 except Exception as exception:  # pylint: disable=broad-except
650                     ret[
651                         "message"
652                     ] = 'Could not load configuration due to : "{}"'.format(exception)
653                     ret["format"] = op["format"]
654                     ret["out"] = False
655                     _restart_connection()
656                     return ret
657                 config_diff = None
658                 if db_mode in ["dynamic", "ephemeral"]:
659                     log.warning("diff is not supported for dynamic and ephemeral")
660                 else:
661                     config_diff = cu.diff()
662                     if config_diff is None:
663                         ret["message"] = "Configuration already applied!"
664                         ret["out"] = True
665                         return ret
666                 commit_params = {}
667                 if "confirm" in op:
668                     commit_params["confirm"] = op["confirm"]
669                 if "comment" in op:
670                     commit_params["comment"] = op["comment"]
671                 check = True
672                 if db_mode in ["dynamic", "ephemeral"]:
673                     log.warning("commit check not supported for dynamic and ephemeral")
674                 else:
675                     try:
676                         check = cu.commit_check()
677                     except Exception as exception:  # pylint: disable=broad-except
678                         ret[
679                             "message"
680                         ] = 'Commit check threw the following exception: "{}"'.format(
681                             exception
682                         )
683                         ret["out"] = False
684                         _restart_connection()
685                         return ret
686                 if check and not test:
687                     try:
688                         cu.commit(**commit_params)
689                         ret["message"] = "Successfully loaded and committed!"
690                     except Exception as exception:  # pylint: disable=broad-except
691                         ret[
692                             "message"
693                         ] = 'Commit check successful but commit failed with "{}"'.format(
694                             exception
695                         )
696                         ret["out"] = False
697                         _restart_connection()
698                         return ret
699                 elif not check:
700                     try:
701                         cu.rollback()
702                         ret["message"] = (
703                             "Loaded configuration but commit check failed, hence"
704                             " rolling back configuration."
705                         )
706                     except Exception as exception:  # pylint: disable=broad-except
707                         ret["message"] = (
708                             "Loaded configuration but commit check failed, and"
709                             ' exception occurred during rolling back configuration "{}"'.format(
710                                 exception
711                             )
712                         )
713                         _restart_connection()
714                     ret["out"] = False
715                 else:
716                     try:
717                         cu.rollback()
718                         ret["message"] = (
719                             "Commit check passed, but skipping commit for dry-run and"
720                             " rolling back configuration."
721                         )
722                         ret["out"] = True
723                     except Exception as exception:  # pylint: disable=broad-except
724                         ret["message"] = (
725                             "Commit check passed, but skipping commit for dry-run and"
726                             ' while rolling back configuration exception occurred "{}"'.format(
727                                 exception
728                             )
729                         )
730                         ret["out"] = False
731                         _restart_connection()
732                 try:
733                     if write_diff and config_diff is not None:
734                         with salt.utils.files.fopen(write_diff, "w") as fp:
735                             fp.write(salt.utils.stringutils.to_str(config_diff))
736                 except Exception as exception:  # pylint: disable=broad-except
737                     ret[
738                         "message"
739                     ] = "Could not write into diffs_file due to: '{}'".format(exception)
740                     ret["out"] = False
741         except ValueError as ex:
742             message = "install_config failed due to: {}".format(str(ex))
743             log.error(message)
744             ret["message"] = message
745             ret["out"] = False
746         except LockError as ex:
747             log.error("Configuration database is locked")
748             ret["message"] = ex.message
749             ret["out"] = False
750         except RpcTimeoutError as ex:
751             message = "install_config failed due to timeout error : {}".format(str(ex))
752             log.error(message)
753             ret["message"] = message
754             ret["out"] = False
755         except Exception as exc:  # pylint: disable=broad-except
756             ret["message"] = "install_config failed due to exception: '{}'".format(exc)
757             ret["out"] = False
758         return ret
759 @_timeout_decorator_cleankwargs
760 def zeroize():
761     conn = __proxy__["junos.conn"]()
762     ret = {}
763     ret["out"] = True
764     try:
765         conn.cli("request system zeroize")
766         ret["message"] = "Completed zeroize and rebooted"
767     except Exception as exception:  # pylint: disable=broad-except
768         ret["message"] = 'Could not zeroize due to : "{}"'.format(exception)
769         ret["out"] = False
770         _restart_connection()
771     return ret
772 @_timeout_decorator
773 def install_os(path=None, **kwargs):
774     conn = __proxy__["junos.conn"]()
775     ret = {}
776     ret["out"] = True
777     op = {}
778     if "__pub_arg" in kwargs:
779         if kwargs["__pub_arg"]:
780             if isinstance(kwargs["__pub_arg"][-1], dict):
781                 op.update(kwargs["__pub_arg"][-1])
782     else:
783         op.update(kwargs)
784     dev_timeout = max(op.pop("dev_timeout", 0), op.pop("timeout", 0))
785     timeout = max(1800, conn.timeout, dev_timeout)
786     reboot = op.pop("reboot", False)
787     no_copy_ = op.get("no_copy", False)
788     if path is None:
789         ret[
790             "message"
791         ] = "Please provide the salt path where the junos image is present."
792         ret["out"] = False
793         return ret
794     if reboot:
795         __proxy__["junos.reboot_active"]()
796     install_status = False
797     if not no_copy_:
798         with HandleFileCopy(path) as image_path:
799             if image_path is None:
800                 ret["message"] = "Invalid path. Please provide a valid image path"
801                 ret["out"] = False
802                 __proxy__["junos.reboot_clear"]()
803                 return ret
804             if salt.utils.platform.is_junos():
805                 tmp_absfile = image_path
806                 op["no_copy"] = True
807                 op["remote_path"] = os.path.dirname(tmp_absfile)
808                 image_path = os.path.basename(tmp_absfile)
809             try:
810                 install_status, install_message = conn.sw.install(
811                     image_path, progress=True, timeout=timeout, **op
812                 )
813             except Exception as exception:  # pylint: disable=broad-except
814                 ret["message"] = 'Installation failed due to: "{}"'.format(exception)
815                 ret["out"] = False
816                 __proxy__["junos.reboot_clear"]()
817                 _restart_connection()
818                 return ret
819     else:
820         try:
821             install_status, install_message = conn.sw.install(
822                 path, progress=True, timeout=timeout, **op
823             )
824         except Exception as exception:  # pylint: disable=broad-except
825             ret["message"] = 'Installation failed due to: "{}"'.format(exception)
826             ret["out"] = False
827             __proxy__["junos.reboot_clear"]()
828             _restart_connection()
829             return ret
830     if install_status is True:
831         ret["out"] = True
832         ret["message"] = "Installed the os."
833     else:
834         ret["message"] = "Installation failed. Reason: {}".format(install_message)
835         ret["out"] = False
836         __proxy__["junos.reboot_clear"]()
837         return ret
838     if reboot is True:
839         reboot_kwargs = {}
840         if "vmhost" in op and op.get("vmhost") is True:
841             reboot_kwargs["vmhost"] = True
842         if "all_re" in op:
843             reboot_kwargs["all_re"] = op.get("all_re")
844         try:
845             __proxy__["junos.reboot_active"]()
846             conn.sw.reboot(**reboot_kwargs)
847         except Exception as exception:  # pylint: disable=broad-except
848             __proxy__["junos.reboot_clear"]()
849             ret[
850                 "message"
851             ] = 'Installation successful but reboot failed due to : "{}"'.format(
852                 exception
853             )
854             ret["out"] = False
855             _restart_connection()
856             return ret
857         __proxy__["junos.reboot_clear"]()
858         ret["out"] = True
859         ret["message"] = "Successfully installed and rebooted!"
860     return ret
861 @_timeout_decorator_cleankwargs
862 def file_copy(src, dest):
863     if salt.utils.platform.is_junos():
864         return {
865             "success": False,
866             "message": "This method is unsupported on the current operating system!",
867         }
868     conn = __proxy__["junos.conn"]()
869     ret = {}
870     ret["out"] = True
871     with HandleFileCopy(src) as fp:
872         if fp is None:
873             ret["message"] = "Invalid source file path {}".format(src)
874             ret["out"] = False
875             return ret
876         try:
877             with SCP(conn, progress=True) as scp:
878                 scp.put(fp, dest)
879             ret["message"] = "Successfully copied file from {} to {}".format(src, dest)
880         except Exception as exception:  # pylint: disable=broad-except
881             ret["message"] = 'Could not copy file : "{}"'.format(exception)
882             ret["out"] = False
883         return ret
884 @_timeout_decorator_cleankwargs
885 def lock():
886     conn = __proxy__["junos.conn"]()
887     ret = {}
888     ret["out"] = True
889     try:
890         conn.cu.lock()
891         ret["message"] = "Successfully locked the configuration."
892     except RpcTimeoutError as exception:
893         ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
894         ret["out"] = False
895         _restart_connection()
896     except LockError as exception:
897         ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
898         ret["out"] = False
899     return ret
900 @_timeout_decorator_cleankwargs
901 def unlock():
902     conn = __proxy__["junos.conn"]()
903     ret = {}
904     ret["out"] = True
905     try:
906         conn.cu.unlock()
907         ret["message"] = "Successfully unlocked the configuration."
908     except RpcTimeoutError as exception:
909         ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
910             exception
911         )
912         ret["out"] = False
913         _restart_connection()
914     except UnlockError as exception:
915         ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
916             exception
917         )
918         ret["out"] = False
919     return ret
920 @_timeout_decorator
921 def load(path=None, **kwargs):
922     conn = __proxy__["junos.conn"]()
923     ret = {}
924     ret["out"] = True
925     if path is None:
926         ret[
927             "message"
928         ] = "Please provide the salt path where the configuration is present"
929         ret["out"] = False
930         return ret
931     op = {}
932     if "__pub_arg" in kwargs:
933         if kwargs["__pub_arg"]:
934             if isinstance(kwargs["__pub_arg"][-1], dict):
935                 op.update(kwargs["__pub_arg"][-1])
936     else:
937         op.update(kwargs)
938     kwargs = {}
939     if "template_vars" in op:
940         kwargs.update({"template_vars": op["template_vars"]})
941     with HandleFileCopy(path, **kwargs) as template_cached_path:
942         if template_cached_path is None:
943             ret["message"] = "Invalid file path."
944             ret["out"] = False
945             return ret
946         if os.path.getsize(template_cached_path) == 0:
947             ret["message"] = "Template failed to render"
948             ret["out"] = False
949             return ret
950         op["path"] = template_cached_path
951         if "format" not in op:
952             if path.endswith("set"):
953                 template_format = "set"
954             elif path.endswith("xml"):
955                 template_format = "xml"
956             elif path.endswith("json"):
957                 template_format = "json"
958             else:
959                 template_format = "text"
960             op["format"] = template_format
961         actions = [
962             item
963             for item in ("overwrite", "replace", "update", "merge")
964             if op.get(item, False)
965         ]
966         if len(list(actions)) &gt; 1:
967             ret["message"] = "Only one config_action is allowed. Provided: {}".format(
968                 actions
969             )
970             ret["out"] = False
971             return ret
972         if "replace" in op and op["replace"]:
973             op["merge"] = False
974             del op["replace"]
975         elif "overwrite" in op and op["overwrite"]:
976             op["overwrite"] = True
977         elif "merge" in op and op["merge"]:
978             op["merge"] = True
979         elif "overwrite" in op and not op["overwrite"]:
980             op["merge"] = True
981             del op["overwrite"]
982         try:
983             conn.cu.load(**op)
984             ret["message"] = "Successfully loaded the configuration."
985         except Exception as exception:  # pylint: disable=broad-except
986             ret["message"] = 'Could not load configuration due to : "{}"'.format(
987                 exception
988             )
989             ret["format"] = op["format"]
990             ret["out"] = False
991             _restart_connection()
992             return ret
993         return ret
994 @_timeout_decorator_cleankwargs
995 def commit_check():
996     conn = __proxy__["junos.conn"]()
997     ret = {}
998     ret["out"] = True
999     try:
1000         conn.cu.commit_check()
1001         ret["message"] = "Commit check succeeded."
1002     except Exception as exception:  # pylint: disable=broad-except
1003         ret["message"] = "Commit check failed with {}".format(exception)
1004         ret["out"] = False
1005         _restart_connection()
1006     return ret
1007 @_timeout_decorator_cleankwargs
1008 def get_table(
1009     table,
1010     table_file,
1011     path=None,
1012     target=None,
1013     key=None,
1014     key_items=None,
1015     filters=None,
1016     table_args=None,
1017 ):
1018     conn = __proxy__["junos.conn"]()
1019     ret = {}
1020     ret["out"] = True
1021     ret["hostname"] = conn._hostname
1022     ret["tablename"] = table
1023     get_kvargs = {}
1024     if target is not None:
1025         get_kvargs["target"] = target
1026     if key is not None:
1027         get_kvargs["key"] = key
1028     if key_items is not None:
1029         get_kvargs["key_items"] = key_items
1030     if filters is not None:
1031         get_kvargs["filters"] = filters
1032     if table_args is not None and isinstance(table_args, dict):
1033         get_kvargs["args"] = table_args
1034     pyez_tables_path = os.path.dirname(os.path.abspath(tables_dir.__file__))
1035     try:
1036         if path is not None:
1037             file_path = os.path.join(path, "{}".format(table_file))
1038         else:
1039             file_path = os.path.join(pyez_tables_path, "{}".format(table_file))
1040         with HandleFileCopy(file_path) as file_loc:
1041             if file_loc is None:
1042                 ret["message"] = "Given table file {} cannot be located".format(
1043                     table_file
1044                 )
1045                 ret["out"] = False
1046                 return ret
1047             try:
1048                 with salt.utils.files.fopen(file_loc) as fp:
1049                     ret["table"] = yaml.load(
1050                         fp.read(), Loader=yamlordereddictloader.Loader
1051                     )
1052                     globals().update(FactoryLoader().load(ret["table"]))
1053             except OSError as err:
1054                 ret[
1055                     "message"
1056                 ] = "Uncaught exception during YAML Load - please report: {}".format(
1057                     str(err)
1058                 )
1059                 ret["out"] = False
1060                 return ret
1061             try:
1062                 data = globals()[table](conn)
1063                 data.get(**get_kvargs)
1064             except KeyError as err:
1065                 ret[
1066                     "message"
1067                 ] = "Uncaught exception during get API call - please report: {}".format(
1068                     str(err)
1069                 )
1070                 ret["out"] = False
1071                 return ret
1072             except ConnectClosedError:
1073                 ret[
1074                     "message"
1075                 ] = "Got ConnectClosedError exception. Connection lost with {}".format(
1076                     conn
1077                 )
1078                 ret["out"] = False
1079                 _restart_connection()
1080                 return ret
1081             ret["reply"] = json.loads(data.to_json())
1082             if data.__class__.__bases__[0] in [OpTable, CfgTable]:
1083                 if ret["table"][table].get("key") is None:
1084                     ret["table"][table]["key"] = data.ITEM_NAME_XPATH
1085                 if key is not None:
1086                     ret["table"][table]["key"] = data.KEY
1087                 if table_args is not None:
1088                     args = copy.copy(data.GET_ARGS)
1089                     args.update(table_args)
1090                     ret["table"][table]["args"] = args
1091             else:
1092                 if target is not None:
1093                     ret["table"][table]["target"] = data.TARGET
1094                 if key is not None:
1095                     ret["table"][table]["key"] = data.KEY
1096                 if key_items is not None:
1097                     ret["table"][table]["key_items"] = data.KEY_ITEMS
1098                 if table_args is not None:
1099                     args = copy.copy(data.CMD_ARGS)
1100                     args.update(table_args)
1101                     ret["table"][table]["args"] = args
1102                     ret["table"][table]["command"] = data.GET_CMD
1103     except ConnectClosedError:
1104         ret[
1105             "message"
1106         ] = "Got ConnectClosedError exception. Connection lost with {}".format(
1107             str(conn)
1108         )
1109         ret["out"] = False
1110         _restart_connection()
1111         return ret
1112     except Exception as err:  # pylint: disable=broad-except
1113         ret["message"] = "Uncaught exception - please report: {}".format(str(err))
1114         ret["out"] = False
1115         _restart_connection()
1116         return ret
1117     return ret
1118 def _recursive_dict(node):
1119     result = {}
1120     for element in node.iterchildren():
1121         key = element.tag.split("}")[1] if "}" in element.tag else element.tag
1122         if element.text and element.text.strip():
1123             value = element.text
1124         else:
1125             value = _recursive_dict(element)
1126         if key in result:
1127             if type(result[key]) is list:
1128                 result[key].append(value)
1129             else:
1130                 tempvalue = result[key].copy()
1131                 result[key] = [tempvalue, value]
1132         else:
1133             result[key] = value
1134     return result
1135 @_timeout_decorator
1136 def rpc_file_list(path, **kwargs):
1137     kwargs = salt.utils.args.clean_kwargs(**kwargs)
1138     conn = __proxy__["junos.conn"]()
1139     if conn._conn is None:
1140         return False
1141     results = conn.rpc.file_list(path=path)
1142     ret = {}
1143     ret["files"] = _recursive_dict(results)
1144     ret["success"] = True
1145     return ret
1146 def _strip_newlines(str):
1147     stripped = str.replace("\n", "")
1148     return stripped
1149 def _make_source_list(dir):
1150     dir_list = []
1151     if not dir:
1152         return
1153     base = rpc_file_list(dir)["files"]["directory"]
1154     if "file-information" not in base:
1155         if "directory_name" not in base:
1156             return None
1157         return [os.path.join(_strip_newlines(base.get("directory-name", None))) + "/"]
1158     if isinstance(base["file-information"], dict):
1159         dirname = os.path.join(
1160             dir, _strip_newlines(base["file-information"]["file-name"])
1161         )
1162         if "file-directory" in base["file-information"]:
1163             new_list = _make_source_list(os.path.join(dir, dirname))
1164             return new_list
1165         else:
1166             return [dirname]
1167     for entry in base["file-information"]:
1168         if "file-directory" in entry:
1169             new_list = _make_source_list(
1170                 os.path.join(dir, _strip_newlines(entry["file-name"]))
1171             )
1172             if new_list:
1173                 dir_list.extend(new_list)
1174         else:
1175             dir_list.append(os.path.join(dir, _strip_newlines(entry["file-name"])))
1176     return dir_list
1177 @_timeout_decorator
1178 def file_compare(file1, file2, **kwargs):
1179     if not salt.utils.platform.is_junos():
1180         return {
1181             "success": False,
1182             "message": "This method is unsupported on the current operating system!",
1183         }
1184     ret = {"message": "", "identical": False, "success": True}
1185     junos_cli = salt.utils.path.which("cli")
1186     if not junos_cli:
1187         return {"success": False, "message": "Cannot find Junos cli command"}
1188     cliret = __salt__["cmd.run"](
1189         "{} file compare files {} {} ".format(junos_cli, file1, file2)
1190     )
1191     clilines = cliret.splitlines()
1192     for r in clilines:
1193         if r.strip() != "":
1194             if "No such file" in r:
1195                 ret["identical"] = False
1196                 ret["success"] = False
1197                 return ret
1198             ret["identical"] = False
1199             ret["success"] = True
1200             return ret
1201     ret["identical"] = True
1202     ret["success"] = True
1203     return ret
1204 @_timeout_decorator
1205 def fsentry_exists(dir, **kwargs):
1206     if not salt.utils.platform.is_junos():
1207         return {
1208             "success": False,
1209             "message": "This method is unsupported on the current operating system!",
1210         }
1211     junos_cli = salt.utils.path.which("cli")
1212     if not junos_cli:
1213         return {"success": False, "message": "Cannot find Junos cli command"}
1214     ret = __salt__["cmd.run"]("{} file show {}".format(junos_cli, dir))
1215     retlines = ret.splitlines()
1216     exists = True
1217     is_dir = False
1218     status = {"is_dir": False, "exists": True}
1219     for r in retlines:
1220         if "could not resolve" in r or "error: Could not connect" in r:
1221             status["is_dir"] = False
1222             status["exists"] = False
1223         if "is not a regular file" in r:
1224             status["is_dir"] = True
1225             status["exists"] = True
1226     return status
1227 def _find_routing_engines():
1228     junos_cli = salt.utils.path.which("cli")
1229     if not junos_cli:
1230         return {"success": False, "message": "Cannot find Junos cli command"}
1231     re_check = __salt__["cmd.run"]("{} show chassis routing-engine".format(junos_cli))
1232     engine_present = True
1233     engine = {}
1234     current_engine = None
1235     status = None
1236     for l in re_check.splitlines():
1237         if "Slot" in l:
1238             mat = re.search(".*(\\d+):.*", l)
1239             if mat:
1240                 current_engine = "re" + str(mat.group(1)) + ":"
1241         if "Current state" in l:
1242             if "Master" in l:
1243                 status = "Master"
1244             if "Disabled" in l:
1245                 status = "Disabled"
1246             if "Backup" in l:
1247                 status = "Backup"
1248         if current_engine and status:
1249             engine[current_engine] = status
1250             current_engine = None
1251             status = None
1252     if not engine:
1253         return {
1254             "success": False,
1255             "message": "Junos cli command returned no information",
1256         }
1257     engine["success"] = True
1258     return engine
1259 @_timeout_decorator
1260 def routing_engine(**kwargs):
1261     engine_status = _find_routing_engines()
1262     if not engine_status["success"]:
1263         return {"success": False}
1264     master = None
1265     backup = []
1266     for k, v in engine_status.items():
1267         if v == "Master":
1268             master = k
1269         if v == "Backup" or v == "Disabled":
1270             backup.append(k)
1271     if master:
1272         ret = {"master": master, "backup": backup, "success": True}
1273     else:
1274         ret = {"master": master, "backup": backup, "success": False}
1275     log.debug(ret)
1276     return ret
1277 @_timeout_decorator
1278 def dir_copy(source, dest, force=False, **kwargs):
1279     if not salt.utils.platform.is_junos():
1280         return {
1281             "success": False,
1282             "message": "This method is unsupported on the current operating system!",
1283         }
1284     junos_cli = salt.utils.path.which("cli")
1285     if not junos_cli:
1286         return {"success": False, "message": "Cannot find Junos cli command"}
1287     ret = {}
1288     ret_messages = ""
1289     if not source.startswith("/"):
1290         ret["message"] = "Source directory must be a fully qualified path."
1291         ret["success"] = False
1292         return ret
1293     if not (dest.endswith(":") or dest.startswith("/")):
1294         ret["message"] = (
1295             "Destination must be a routing engine reference (e.g. re1:) or a fully"
1296             " qualified path."
1297         )
1298         ret["success"] = False
1299         return ret
1300     check_source = fsentry_exists(source)
1301     if not check_source["exists"]:
1302         ret["message"] = "Source does not exist"
1303         ret["success"] = False
1304         return ret
1305     if not check_source["is_dir"]:
1306         ret["message"] = "Source is not a directory."
1307         ret["success"] = False
1308         return ret
1309     filelist = _make_source_list(source)
1310     dirops = []
1311     for f in filelist:
1312         splitpath = os.path.split(f)[0]
1313         fullpath = "/"
1314         for component in splitpath.split("/"):
1315             fullpath = os.path.join(fullpath, component)
1316             if fullpath not in dirops:
1317                 dirops.append(fullpath)
1318     for d in dirops:
1319         target = dest + d
1320         status = fsentry_exists(target)
1321         if not status["exists"]:
1322             ret = __salt__["cmd.run"](
1323                 "{} file make-directory {}".format(junos_cli, target)
1324             )
1325             ret = ret_messages + ret
1326         else:
1327             ret_messages = ret_messages + "Directory " + target + " already exists.\n"
1328     for f in filelist:
1329         if not f.endswith("/"):
1330             target = dest + f
1331             comp_result = file_compare(f, target)
1332             if not comp_result["identical"] or force:
1333                 ret = __salt__["cmd.run"](
1334                     "{} file copy {} {}".format(junos_cli, f, target)
1335                 )
1336                 ret = ret_messages + ret
1337             else:
1338                 ret_messages = (
1339                     ret_messages
1340                     + "Files {} and {} are identical, not copying.\n".format(f, target)
1341                 )
1342     return ret_messages
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
