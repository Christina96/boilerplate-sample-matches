<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_elasticsearch_domain_1.py &amp; junos_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_elasticsearch_domain_1.py &amp; junos_1.py
      </h3>
<h1 align="center">
        0.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_elasticsearch_domain_1.py (2.5974026%)<th>junos_1.py (0.45300114%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-15)<td><a href="#" name="0">(19-32)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_elasticsearch_domain_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
2 import logging
3 import random
4 import string
5 import salt.loader
6 import salt.modules.boto_elasticsearch_domain as boto_elasticsearch_domain
7 from salt.utils.versions import LooseVersion
8 from tests.support.mixins import LoaderModuleMockMixin
9 from tests.support.mock import MagicMock, patch
10 from tests.support.unit import TestCase, skipIf
11 try:
12     import</b></font> boto3
13     from botocore.exceptions import ClientError
14     HAS_BOTO = True
15 except ImportError:
16     HAS_BOTO = False
17 required_boto3_version = "1.2.1"
18 def _has_required_boto():
19     if not HAS_BOTO:
20         return False
21     elif LooseVersion(boto3.__version__) &lt; LooseVersion(required_boto3_version):
22         return False
23     else:
24         return True
25 if _has_required_boto():
26     region = "us-east-1"
27     access_key = "GKTADJGHEIQSXMKKRBJ08H"
28     secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
29     conn_parameters = {
30         "region": region,
31         "key": access_key,
32         "keyid": secret_key,
33         "profile": {},
34     }
35     error_message = (
36         "An error occurred (101) when calling the {0} operation: Test-defined error"
37     )
38     error_content = {"Error": {"Code": 101, "Message": "Test-defined error"}}
39     not_found_error = ClientError(
40         {
41             "Error": {
42                 "Code": "ResourceNotFoundException",
43                 "Message": "Test-defined error",
44             }
45         },
46         "msg",
47     )
48     domain_ret = dict(
49         DomainName="testdomain",
50         ElasticsearchClusterConfig={},
51         EBSOptions={},
52         AccessPolicies={},
53         SnapshotOptions={},
54         AdvancedOptions={},
55     )
56 log = logging.getLogger(__name__)
57 class BotoElasticsearchDomainTestCaseBase(TestCase, LoaderModuleMockMixin):
58     conn = None
59     def setup_loader_modules(self):
60         self.opts = salt.config.DEFAULT_MINION_OPTS.copy()
61         utils = salt.loader.utils(
62             self.opts,
63             whitelist=["boto3", "args", "systemd", "path", "platform"],
64             context={},
65         )
66         return {boto_elasticsearch_domain: {"__utils__": utils}}
67     def setUp(self):
68         super().setUp()
69         boto_elasticsearch_domain.__init__(self.opts)
70         del self.opts
71         conn_parameters["key"] = "".join(
72             random.choice(string.ascii_lowercase + string.digits) for _ in range(50)
73         )
74         self.patcher = patch("boto3.session.Session")
75         self.addCleanup(self.patcher.stop)
76         self.addCleanup(delattr, self, "patcher")
77         mock_session = self.patcher.start()
78         session_instance = mock_session.return_value
79         self.conn = MagicMock()
80         self.addCleanup(delattr, self, "conn")
81         session_instance.client.return_value = self.conn
82 class BotoElasticsearchDomainTestCaseMixin:
83     pass
84 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
85 @skipIf(
86     _has_required_boto() is False,
87     "The boto3 module must be greater than or equal to version {}".format(
88         required_boto3_version
89     ),
90 )
91 class BotoElasticsearchDomainTestCase(
92     BotoElasticsearchDomainTestCaseBase, BotoElasticsearchDomainTestCaseMixin
93 ):
94     def test_that_when_checking_if_a_domain_exists_and_a_domain_exists_the_domain_exists_method_returns_true(
95         self,
96     ):
97         result = boto_elasticsearch_domain.exists(
98             DomainName="testdomain", **conn_parameters
99         )
100         self.assertTrue(result["exists"])
101     def test_that_when_checking_if_a_domain_exists_and_a_domain_does_not_exist_the_domain_exists_method_returns_false(
102         self,
103     ):
104         self.conn.describe_elasticsearch_domain.side_effect = not_found_error
105         result = boto_elasticsearch_domain.exists(
106             DomainName="mydomain", **conn_parameters
107         )
108         self.assertFalse(result["exists"])
109     def test_that_when_checking_if_a_domain_exists_and_boto3_returns_an_error_the_domain_exists_method_returns_error(
110         self,
111     ):
112         self.conn.describe_elasticsearch_domain.side_effect = ClientError(
113             error_content, "list_domains"
114         )
115         result = boto_elasticsearch_domain.exists(
116             DomainName="mydomain", **conn_parameters
117         )
118         self.assertEqual(
119             result.get("error", {}).get("message"), error_message.format("list_domains")
120         )
121     def test_that_when_checking_domain_status_and_a_domain_exists_the_domain_status_method_returns_info(
122         self,
123     ):
124         self.conn.describe_elasticsearch_domain.return_value = {
125             "DomainStatus": domain_ret
126         }
127         result = boto_elasticsearch_domain.status(
128             DomainName="testdomain", **conn_parameters
129         )
130         self.assertTrue(result["domain"])
131     def test_that_when_checking_domain_status_and_boto3_returns_an_error_the_domain_status_method_returns_error(
132         self,
133     ):
134         self.conn.describe_elasticsearch_domain.side_effect = ClientError(
135             error_content, "list_domains"
136         )
137         result = boto_elasticsearch_domain.status(
138             DomainName="mydomain", **conn_parameters
139         )
140         self.assertEqual(
141             result.get("error", {}).get("message"), error_message.format("list_domains")
142         )
143     def test_that_when_describing_domain_it_returns_the_dict_of_properties_returns_true(
144         self,
145     ):
146         domainconfig = {}
147         for k, v in domain_ret.items():
148             if k == "DomainName":
149                 continue
150             domainconfig[k] = {"Options": v}
151         self.conn.describe_elasticsearch_domain_config.return_value = {
152             "DomainConfig": domainconfig
153         }
154         result = boto_elasticsearch_domain.describe(
155             DomainName=domain_ret["DomainName"], **conn_parameters
156         )
157         log.warning(result)
158         desired_ret = copy.copy(domain_ret)
159         desired_ret.pop("DomainName")
160         self.assertEqual(result, {"domain": desired_ret})
161     def test_that_when_describing_domain_on_client_error_it_returns_error(self):
162         self.conn.describe_elasticsearch_domain_config.side_effect = ClientError(
163             error_content, "list_domains"
164         )
165         result = boto_elasticsearch_domain.describe(
166             DomainName="testdomain", **conn_parameters
167         )
168         self.assertTrue("error" in result)
169     def test_that_when_creating_a_domain_succeeds_the_create_domain_method_returns_true(
170         self,
171     ):
172         self.conn.create_elasticsearch_domain.return_value = {
173             "DomainStatus": domain_ret
174         }
175         args = copy.copy(domain_ret)
176         args.update(conn_parameters)
177         result = boto_elasticsearch_domain.create(**args)
178         self.assertTrue(result["created"])
179     def test_that_when_creating_a_domain_fails_the_create_domain_method_returns_error(
180         self,
181     ):
182         self.conn.create_elasticsearch_domain.side_effect = ClientError(
183             error_content, "create_domain"
184         )
185         args = copy.copy(domain_ret)
186         args.update(conn_parameters)
187         result = boto_elasticsearch_domain.create(**args)
188         self.assertEqual(
189             result.get("error", {}).get("message"),
190             error_message.format("create_domain"),
191         )
192     def test_that_when_deleting_a_domain_succeeds_the_delete_domain_method_returns_true(
193         self,
194     ):
195         result = boto_elasticsearch_domain.delete(
196             DomainName="testdomain", **conn_parameters
197         )
198         self.assertTrue(result["deleted"])
199     def test_that_when_deleting_a_domain_fails_the_delete_domain_method_returns_false(
200         self,
201     ):
202         self.conn.delete_elasticsearch_domain.side_effect = ClientError(
203             error_content, "delete_domain"
204         )
205         result = boto_elasticsearch_domain.delete(
206             DomainName="testdomain", **conn_parameters
207         )
208         self.assertFalse(result["deleted"])
209     def test_that_when_updating_a_domain_succeeds_the_update_domain_method_returns_true(
210         self,
211     ):
212         self.conn.update_elasticsearch_domain_config.return_value = {
213             "DomainConfig": domain_ret
214         }
215         args = copy.copy(domain_ret)
216         args.update(conn_parameters)
217         result = boto_elasticsearch_domain.update(**args)
218         self.assertTrue(result["updated"])
219     def test_that_when_updating_a_domain_fails_the_update_domain_method_returns_error(
220         self,
221     ):
222         self.conn.update_elasticsearch_domain_config.side_effect = ClientError(
223             error_content, "update_domain"
224         )
225         args = copy.copy(domain_ret)
226         args.update(conn_parameters)
227         result = boto_elasticsearch_domain.update(**args)
228         self.assertEqual(
229             result.get("error", {}).get("message"),
230             error_message.format("update_domain"),
231         )
232     def test_that_when_adding_tags_succeeds_the_add_tags_method_returns_true(self):
233         self.conn.describe_elasticsearch_domain.return_value = {
234             "DomainStatus": domain_ret
235         }
236         result = boto_elasticsearch_domain.add_tags(
237             DomainName="testdomain", a="b", **conn_parameters
238         )
239         self.assertTrue(result["tagged"])
240     def test_that_when_adding_tags_fails_the_add_tags_method_returns_false(self):
241         self.conn.add_tags.side_effect = ClientError(error_content, "add_tags")
242         self.conn.describe_elasticsearch_domain.return_value = {
243             "DomainStatus": domain_ret
244         }
245         result = boto_elasticsearch_domain.add_tags(
246             DomainName=domain_ret["DomainName"], a="b", **conn_parameters
247         )
248         self.assertFalse(result["tagged"])
249     def test_that_when_removing_tags_succeeds_the_remove_tags_method_returns_true(self):
250         self.conn.describe_elasticsearch_domain.return_value = {
251             "DomainStatus": domain_ret
252         }
253         result = boto_elasticsearch_domain.remove_tags(
254             DomainName=domain_ret["DomainName"], TagKeys=["a"], **conn_parameters
255         )
256         self.assertTrue(result["tagged"])
257     def test_that_when_removing_tags_fails_the_remove_tags_method_returns_false(self):
258         self.conn.remove_tags.side_effect = ClientError(error_content, "remove_tags")
259         self.conn.describe_elasticsearch_domain.return_value = {
260             "DomainStatus": domain_ret
261         }
262         result = boto_elasticsearch_domain.remove_tags(
263             DomainName=domain_ret["DomainName"], TagKeys=["b"], **conn_parameters
264         )
265         self.assertFalse(result["tagged"])
266     def test_that_when_listing_tags_succeeds_the_list_tags_method_returns_true(self):
267         self.conn.describe_elasticsearch_domain.return_value = {
268             "DomainStatus": domain_ret
269         }
270         result = boto_elasticsearch_domain.list_tags(
271             DomainName=domain_ret["DomainName"], **conn_parameters
272         )
273         self.assertEqual(result["tags"], {})
274     def test_that_when_listing_tags_fails_the_list_tags_method_returns_false(self):
275         self.conn.list_tags.side_effect = ClientError(error_content, "list_tags")
276         self.conn.describe_elasticsearch_domain.return_value = {
277             "DomainStatus": domain_ret
278         }
279         result = boto_elasticsearch_domain.list_tags(
280             DomainName=domain_ret["DomainName"], **conn_parameters
281         )
282         self.assertTrue(result["error"])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>junos_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>import copy
2 import json
3 import logging
4 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import os
5 import re
6 from functools import wraps
7 import salt.utils.args
8 import salt.utils.files
9 import salt.utils.json
10 import salt.utils.path
11 import salt.utils.platform
12 import salt.utils.stringutils
13 import yaml
14 try:
15     from</b></font> lxml import etree
16 except ImportError:
17     import xml.etree.ElementTree as etree
18 try:
19     import jnpr.junos.cfg
20     import jnpr.junos.op as tables_dir
21     import jnpr.junos.utils
22     import jxmlease
23     import yamlordereddictloader
24     from jnpr.junos import Device
25     from jnpr.junos.exception import (
26         ConnectClosedError,
27         LockError,
28         RpcTimeoutError,
29         UnlockError,
30     )
31     from jnpr.junos.factory.cfgtable import CfgTable
32     from jnpr.junos.factory.factory_loader import FactoryLoader
33     from jnpr.junos.factory.optable import OpTable
34     from jnpr.junos.utils.config import Config
35     from jnpr.junos.utils.scp import SCP
36     from jnpr.junos.utils.sw import SW
37     HAS_JUNOS = True
38 except ImportError:
39     HAS_JUNOS = False
40 log = logging.getLogger(__name__)
41 __virtualname__ = "junos"
42 __proxyenabled__ = ["junos"]
43 def __virtual__():
44     if HAS_JUNOS and "proxy" in __opts__:
45         return __virtualname__
46     else:
47         return (
48             False,
49             "The junos or dependent module could not be loaded: "
50             "junos-eznc or jxmlease or yamlordereddictloader or "
51             "proxy could not be loaded.",
52         )
53 class HandleFileCopy:
54     def __init__(self, path, **kwargs):
55         self._file_path = path
56         self._cached_folder = None
57         self._cached_file = None
58         self._kwargs = kwargs
59     def __enter__(self):
60         if self._file_path.startswith("salt://"):
61             local_cache_path = __salt__["cp.is_cached"](self._file_path)
62             if local_cache_path:
63                 master_hash = __salt__["cp.hash_file"](self._file_path)
64                 proxy_hash = __salt__["file.get_hash"](local_cache_path)
65                 if master_hash.get("hsum") == proxy_hash:
66                     self._cached_file = salt.utils.files.mkstemp()
67                     with salt.utils.files.fopen(self._cached_file, "w") as fp:
68                         template_string = __salt__["slsutil.renderer"](
69                             path=local_cache_path,
70                             default_renderer="jinja",
71                             **self._kwargs,
72                         )
73                         fp.write(template_string)
74                     return self._cached_file
75             self._cached_file = salt.utils.files.mkstemp()
76             __salt__["cp.get_template"](
77                 self._file_path, self._cached_file, **self._kwargs
78             )
79             if self._cached_file != "":
80                 return self._cached_file
81         else:
82             if __salt__["file.file_exists"](self._file_path):
83                 self._cached_file = salt.utils.files.mkstemp()
84                 with salt.utils.files.fopen(self._cached_file, "w") as fp:
85                     template_string = __salt__["slsutil.renderer"](
86                         path=self._file_path, default_renderer="jinja", **self._kwargs
87                     )
88                     fp.write(template_string)
89                 return self._cached_file
90     def __exit__(self, exc_type, exc_value, exc_traceback):
91         if self._cached_file is not None:
92             salt.utils.files.safe_rm(self._cached_file)
93             log.debug("Deleted cached file: %s", self._cached_file)
94         if self._cached_folder is not None:
95             __salt__["file.rmdir"](self._cached_folder)
96             log.debug("Deleted cached folder: %s", self._cached_folder)
97 def _timeout_decorator(function):
98     @wraps(function)
99     def wrapper(*args, **kwargs):
100         if "dev_timeout" in kwargs or "timeout" in kwargs:
101             ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
102             conn = __proxy__["junos.conn"]()
103             restore_timeout = conn.timeout
104             conn.timeout = ldev_timeout
105             try:
106                 result = function(*args, **kwargs)
107                 conn.timeout = restore_timeout
108                 return result
109             except Exception:  # pylint: disable=broad-except
110                 conn.timeout = restore_timeout
111                 raise
112         else:
113             return function(*args, **kwargs)
114     return wrapper
115 def _timeout_decorator_cleankwargs(function):
116     @wraps(function)
117     def wrapper(*args, **kwargs):
118         if "dev_timeout" in kwargs or "timeout" in kwargs:
119             ldev_timeout = max(kwargs.pop("dev_timeout", 0), kwargs.pop("timeout", 0))
120             conn = __proxy__["junos.conn"]()
121             restore_timeout = conn.timeout
122             conn.timeout = ldev_timeout
123             try:
124                 restore_kwargs = False
125                 del_list = []
126                 op = {}
127                 op.update(kwargs)
128                 for keychk in kwargs:
129                     if keychk.startswith("__pub"):
130                         del_list.append(keychk)
131                 if del_list:
132                     restore_kwargs = True
133                     for delkey in del_list:
134                         kwargs.pop(delkey)
135                 result = function(*args, **kwargs)
136                 if restore_kwargs:
137                     kwargs.update(op)
138                 conn.timeout = restore_timeout
139                 return result
140             except Exception:  # pylint: disable=broad-except
141                 conn.timeout = restore_timeout
142                 raise
143         else:
144             restore_kwargs = False
145             del_list = []
146             op = {}
147             op.update(kwargs)
148             for keychk in kwargs:
149                 if keychk.startswith("__pub"):
150                     del_list.append(keychk)
151             if del_list:
152                 restore_kwargs = True
153                 for delkey in del_list:
154                     kwargs.pop(delkey)
155             ret = function(*args, **kwargs)
156             if restore_kwargs:
157                 kwargs.update(op)
158             return ret
159     return wrapper
160 def _restart_connection():
161     minion_id = __opts__.get("proxyid", "") or __opts__.get("id", "")
162     log.info(
163         "Junos exception occurred %s (junos proxy) is down. Restarting.", minion_id
164     )
165     __salt__["event.fire_master"](
166         {}, "junos/proxy/{}/stop".format(__opts__["proxy"]["host"])
167     )
168     __proxy__["junos.shutdown"](__opts__)  # safely close connection
169     __proxy__["junos.init"](__opts__)  # reopen connection
170     log.debug("Junos exception occurred, restarted %s (junos proxy)!", minion_id)
171 @_timeout_decorator_cleankwargs
172 def facts_refresh():
173     conn = __proxy__["junos.conn"]()
174     ret = {}
175     ret["out"] = True
176     try:
177         conn.facts_refresh()
178     except Exception as exception:  # pylint: disable=broad-except
179         ret["message"] = 'Execution failed due to "{}"'.format(exception)
180         ret["out"] = False
181         _restart_connection()
182         return ret
183     ret["facts"] = __proxy__["junos.get_serialized_facts"]()
184     try:
185         __salt__["saltutil.sync_grains"]()
186     except Exception as exception:  # pylint: disable=broad-except
187         log.error('Grains could not be updated due to "%s"', exception)
188     return ret
189 def facts():
190     ret = {}
191     try:
192         ret["facts"] = __proxy__["junos.get_serialized_facts"]()
193         ret["out"] = True
194     except Exception as exception:  # pylint: disable=broad-except
195         ret["message"] = 'Could not display facts due to "{}"'.format(exception)
196         ret["out"] = False
197         _restart_connection()
198     return ret
199 @_timeout_decorator
200 def rpc(cmd=None, dest=None, **kwargs):
201     conn = __proxy__["junos.conn"]()
202     ret = {}
203     ret["out"] = True
204     op = dict()
205     if "__pub_arg" in kwargs:
206         if kwargs["__pub_arg"]:
207             if isinstance(kwargs["__pub_arg"][-1], dict):
208                 op.update(kwargs["__pub_arg"][-1])
209     elif "__pub_schedule" in kwargs:
210         for key, value in kwargs.items():
211             if not key.startswith("__pub_"):
212                 op[key] = value
213     else:
214         op.update(kwargs)
215     if cmd is None:
216         ret["message"] = "Please provide the rpc to execute."
217         ret["out"] = False
218         return ret
219     format_ = op.pop("format", "xml")
220     op.pop("dest", dest)
221     if cmd in ["get-config", "get_config"]:
222         filter_reply = None
223         if "filter" in op:
224             try:
225                 filter_reply = etree.XML(op["filter"])
226             except etree.XMLSyntaxError as ex:
227                 ret["message"] = "Invalid filter: {}".format(str(ex))
228                 ret["out"] = False
229                 return ret
230             del op["filter"]
231         op.update({"format": format_})
232         try:
233             reply = getattr(conn.rpc, cmd.replace("-", "_"))(filter_reply, options=op)
234         except Exception as exception:  # pylint: disable=broad-except
235             ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
236             ret["out"] = False
237             _restart_connection()
238             return ret
239     else:
240         if "filter" in op:
241             log.warning('Filter ignored as it is only used with "get-config" rpc')
242         if "dest" in op:
243             log.warning("dest in op, rpc may reject this for cmd '%s'", cmd)
244         try:
245             reply = getattr(conn.rpc, cmd.replace("-", "_"))({"format": format_}, **op)
246         except Exception as exception:  # pylint: disable=broad-except
247             ret["message"] = 'RPC execution failed due to "{}"'.format(exception)
248             ret["out"] = False
249             _restart_connection()
250             return ret
251     if format_ == "text":
252         ret["rpc_reply"] = reply.text
253     elif format_ == "json":
254         ret["rpc_reply"] = reply
255     else:
256         ret["rpc_reply"] = jxmlease.parse(etree.tostring(reply))
257     if dest:
258         if format_ == "text":
259             write_response = reply.text
260         elif format_ == "json":
261             write_response = salt.utils.json.dumps(reply, indent=1)
262         else:
263             write_response = etree.tostring(reply)
264         with salt.utils.files.fopen(dest, "w") as fp:
265             fp.write(salt.utils.stringutils.to_str(write_response))
266     return ret
267 @_timeout_decorator
268 def set_hostname(hostname=None, **kwargs):
269     conn = __proxy__["junos.conn"]()
270     ret = {}
271     if hostname is None:
272         ret["message"] = "Please provide the hostname."
273         ret["out"] = False
274         return ret
275     op = dict()
276     if "__pub_arg" in kwargs:
277         if kwargs["__pub_arg"]:
278             if isinstance(kwargs["__pub_arg"][-1], dict):
279                 op.update(kwargs["__pub_arg"][-1])
280     else:
281         op.update(kwargs)
282     set_string = "set system host-name {}".format(hostname)
283     try:
284         conn.cu.load(set_string, format="set")
285     except Exception as exception:  # pylint: disable=broad-except
286         ret["message"] = 'Could not load configuration due to error "{}"'.format(
287             exception
288         )
289         ret["out"] = False
290         _restart_connection()
291         return ret
292     try:
293         commit_ok = conn.cu.commit_check()
294     except Exception as exception:  # pylint: disable=broad-except
295         ret["message"] = 'Could not commit check due to error "{}"'.format(exception)
296         ret["out"] = False
297         _restart_connection()
298         return ret
299     if commit_ok:
300         try:
301             conn.cu.commit(**op)
302             ret["message"] = "Successfully changed hostname."
303             ret["out"] = True
304         except Exception as exception:  # pylint: disable=broad-except
305             ret["out"] = False
306             ret[
307                 "message"
308             ] = 'Successfully loaded host-name but commit failed with "{}"'.format(
309                 exception
310             )
311             _restart_connection()
312             return ret
313     else:
314         ret["out"] = False
315         ret["message"] = "Successfully loaded host-name but pre-commit check failed."
316         try:
317             conn.cu.rollback()
318         except Exception as exception:  # pylint: disable=broad-except
319             ret["out"] = False
320             ret[
321                 "message"
322             ] = 'Successfully loaded host-name but rollback before exit failed "{}"'.format(
323                 exception
324             )
325             _restart_connection()
326     return ret
327 @_timeout_decorator
328 def commit(**kwargs):
329     conn = __proxy__["junos.conn"]()
330     ret = {}
331     op = dict()
332     if "__pub_arg" in kwargs:
333         if kwargs["__pub_arg"]:
334             if isinstance(kwargs["__pub_arg"][-1], dict):
335                 op.update(kwargs["__pub_arg"][-1])
336     else:
337         op.update(kwargs)
338     op["detail"] = op.get("detail", False)
339     try:
340         commit_ok = conn.cu.commit_check()
341     except Exception as exception:  # pylint: disable=broad-except
342         ret["message"] = 'Could not perform commit check due to "{}"'.format(exception)
343         ret["out"] = False
344         _restart_connection()
345         return ret
346     if commit_ok:
347         try:
348             commit = conn.cu.commit(**op)
349             ret["out"] = True
350             if commit:
351                 if op["detail"]:
352                     ret["message"] = jxmlease.parse(etree.tostring(commit))
353                 else:
354                     ret["message"] = "Commit Successful."
355             else:
356                 ret["message"] = "Commit failed."
357                 ret["out"] = False
358         except Exception as exception:  # pylint: disable=broad-except
359             ret["out"] = False
360             ret[
361                 "message"
362             ] = 'Commit check succeeded but actual commit failed with "{}"'.format(
363                 exception
364             )
365             _restart_connection()
366     else:
367         ret["out"] = False
368         ret["message"] = "Pre-commit check failed."
369         try:
370             conn.cu.rollback()
371         except Exception as exception:  # pylint: disable=broad-except
372             ret["out"] = False
373             ret[
374                 "message"
375             ] = 'Pre-commit check failed, and exception during rollback "{}"'.format(
376                 exception
377             )
378             _restart_connection()
379     return ret
380 @_timeout_decorator
381 def rollback(**kwargs):
382     ids_passed = 0
383     id_ = 0
384     if "d_id" in kwargs:
385         id_ = kwargs.pop("d_id")
386         ids_passed = ids_passed + 1
387     if "id" in kwargs:
388         id_ = kwargs.pop("id", 0)
389         ids_passed = ids_passed + 1
390     if ids_passed &gt; 1:
391         log.warning(
392             "junos.rollback called with more than one possible ID. "
393             "Use only one of the positional argument, `id`, or `d_id` kwargs"
394         )
395     ret = {}
396     conn = __proxy__["junos.conn"]()
397     op = dict()
398     if "__pub_arg" in kwargs:
399         if kwargs["__pub_arg"]:
400             if isinstance(kwargs["__pub_arg"][-1], dict):
401                 op.update(kwargs["__pub_arg"][-1])
402     else:
403         op.update(kwargs)
404     try:
405         ret["out"] = conn.cu.rollback(id_)
406     except Exception as exception:  # pylint: disable=broad-except
407         ret["message"] = 'Rollback failed due to "{}"'.format(exception)
408         ret["out"] = False
409         _restart_connection()
410         return ret
411     if ret["out"]:
412         ret["message"] = "Rollback successful"
413     else:
414         ret["message"] = "Rollback failed"
415         return ret
416     if "diffs_file" in op and op["diffs_file"] is not None:
417         diff = conn.cu.diff()
418         if diff is not None:
419             with salt.utils.files.fopen(op["diffs_file"], "w") as fp:
420                 fp.write(salt.utils.stringutils.to_str(diff))
421         else:
422             log.info(
423                 "No diff between current configuration and "
424                 "rollbacked configuration, so no diff file created"
425             )
426     try:
427         commit_ok = conn.cu.commit_check()
428     except Exception as exception:  # pylint: disable=broad-except
429         ret["message"] = 'Could not commit check due to "{}"'.format(exception)
430         ret["out"] = False
431         _restart_connection()
432         return ret
433     if commit_ok:
434         try:
435             conn.cu.commit(**op)
436             ret["out"] = True
437         except Exception as exception:  # pylint: disable=broad-except
438             ret["out"] = False
439             ret[
440                 "message"
441             ] = 'Rollback successful but commit failed with error "{}"'.format(
442                 exception
443             )
444             _restart_connection()
445             return ret
446     else:
447         ret["message"] = "Rollback successful but pre-commit check failed."
448         ret["out"] = False
449     return ret
450 @_timeout_decorator
451 def diff(**kwargs):
452     kwargs = salt.utils.args.clean_kwargs(**kwargs)
453     ids_passed = 0
454     id_ = 0
455     if "d_id" in kwargs:
456         id_ = kwargs.pop("d_id")
457         ids_passed = ids_passed + 1
458     if "id" in kwargs:
459         id_ = kwargs.pop("id", 0)
460         ids_passed = ids_passed + 1
461     if ids_passed &gt; 1:
462         log.warning(
463             "junos.rollback called with more than one possible ID. "
464             "Use only one of the positional argument, `id`, or `d_id` kwargs"
465         )
466     if kwargs:
467         salt.utils.args.invalid_kwargs(kwargs)
468     conn = __proxy__["junos.conn"]()
469     ret = {}
470     ret["out"] = True
471     try:
472         ret["message"] = conn.cu.diff(rb_id=id_)
473     except Exception as exception:  # pylint: disable=broad-except
474         ret["message"] = 'Could not get diff with error "{}"'.format(exception)
475         ret["out"] = False
476         _restart_connection()
477     return ret
478 @_timeout_decorator
479 def ping(dest_ip=None, **kwargs):
480     conn = __proxy__["junos.conn"]()
481     ret = {}
482     if dest_ip is None:
483         ret["message"] = "Please specify the destination ip to ping."
484         ret["out"] = False
485         return ret
486     op = {"host": dest_ip}
487     if "__pub_arg" in kwargs:
488         if kwargs["__pub_arg"]:
489             if isinstance(kwargs["__pub_arg"][-1], dict):
490                 op.update(kwargs["__pub_arg"][-1])
491     else:
492         op.update(kwargs)
493     op["count"] = str(op.pop("count", 5))
494     if "ttl" in op:
495         op["ttl"] = str(op["ttl"])
496     ret["out"] = True
497     try:
498         ret["message"] = jxmlease.parse(etree.tostring(conn.rpc.ping(**op)))
499     except Exception as exception:  # pylint: disable=broad-except
500         ret["message"] = 'Execution failed due to "{}"'.format(exception)
501         ret["out"] = False
502         _restart_connection()
503     return ret
504 @_timeout_decorator
505 def cli(command=None, **kwargs):
506     conn = __proxy__["junos.conn"]()
507     format_ = kwargs.pop("format", "text")
508     if not format_:
509         format_ = "text"
510     ret = {}
511     if command is None:
512         ret["message"] = "Please provide the CLI command to be executed."
513         ret["out"] = False
514         return ret
515     op = dict()
516     if "__pub_arg" in kwargs:
517         if kwargs["__pub_arg"]:
518             if isinstance(kwargs["__pub_arg"][-1], dict):
519                 op.update(kwargs["__pub_arg"][-1])
520     else:
521         op.update(kwargs)
522     try:
523         result = conn.cli(command, format_, warning=False)
524     except Exception as exception:  # pylint: disable=broad-except
525         ret["message"] = 'Execution failed due to "{}"'.format(exception)
526         ret["out"] = False
527         _restart_connection()
528         return ret
529     if format_ == "text":
530         ret["message"] = result
531     else:
532         result = etree.tostring(result)
533         ret["message"] = jxmlease.parse(result)
534     if "dest" in op and op["dest"] is not None:
535         try:
536             with salt.utils.files.fopen(op["dest"], "w") as fp:
537                 fp.write(salt.utils.stringutils.to_str(result))
538         except OSError:
539             ret["message"] = 'Unable to open "{}" to write'.format(op["dest"])
540             ret["out"] = False
541             return ret
542     ret["out"] = True
543     return ret
544 @_timeout_decorator
545 def shutdown(**kwargs):
546     conn = __proxy__["junos.conn"]()
547     ret = {}
548     sw = SW(conn)
549     op = {}
550     if "__pub_arg" in kwargs:
551         if kwargs["__pub_arg"]:
552             if isinstance(kwargs["__pub_arg"][-1], dict):
553                 op.update(kwargs["__pub_arg"][-1])
554     else:
555         op.update(kwargs)
556     if "shutdown" not in op and "reboot" not in op:
557         ret["message"] = "Provide either one of the arguments: shutdown or reboot."
558         ret["out"] = False
559         return ret
560     try:
561         if "reboot" in op and op["reboot"]:
562             shut = sw.reboot
563         elif "shutdown" in op and op["shutdown"]:
564             shut = sw.poweroff
565         else:
566             ret["message"] = "Nothing to be done."
567             ret["out"] = False
568             return ret
569         if "in_min" in op:
570             shut(in_min=op["in_min"])
571         elif "at" in op:
572             shut(at=op["at"])
573         else:
574             shut()
575         ret["message"] = "Successfully powered off/rebooted."
576         ret["out"] = True
577     except Exception as exception:  # pylint: disable=broad-except
578         ret["message"] = 'Could not poweroff/reboot because "{}"'.format(exception)
579         ret["out"] = False
580         _restart_connection()
581     return ret
582 @_timeout_decorator
583 def install_config(path=None, **kwargs):
584     conn = __proxy__["junos.conn"]()
585     ret = {}
586     ret["out"] = True
587     if path is None:
588         ret[
589             "message"
590         ] = "Please provide the salt path where the configuration is present"
591         ret["out"] = False
592         return ret
593     op = {}
594     if "__pub_arg" in kwargs:
595         if kwargs["__pub_arg"]:
596             if isinstance(kwargs["__pub_arg"][-1], dict):
597                 op.update(kwargs["__pub_arg"][-1])
598     else:
599         op.update(kwargs)
600     test = op.pop("test", False)
601     kwargs = {}
602     if "template_vars" in op:
603         kwargs.update({"template_vars": op["template_vars"]})
604     with HandleFileCopy(path, **kwargs) as template_cached_path:
605         if template_cached_path is None:
606             ret["message"] = "Invalid file path."
607             ret["out"] = False
608             return ret
609         if os.path.getsize(template_cached_path) == 0:
610             ret["message"] = "Template failed to render"
611             ret["out"] = False
612             return ret
613         write_diff = ""
614         if "diffs_file" in op and op["diffs_file"] is not None:
615             write_diff = op["diffs_file"]
616             del op["diffs_file"]
617         op["path"] = template_cached_path
618         if "format" not in op:
619             if path.endswith("set"):
620                 template_format = "set"
621             elif path.endswith("xml"):
622                 template_format = "xml"
623             elif path.endswith("json"):
624                 template_format = "json"
625             else:
626                 template_format = "text"
627             op["format"] = template_format
628         if "replace" in op and op["replace"]:
629             op["merge"] = False
630             del op["replace"]
631         elif "overwrite" in op and op["overwrite"]:
632             op["overwrite"] = True
633         elif "overwrite" in op and not op["overwrite"]:
634             op["merge"] = True
635             del op["overwrite"]
636         db_mode = op.pop("mode", "exclusive")
637         if write_diff and db_mode in ["dynamic", "ephemeral"]:
638             ret[
639                 "message"
640             ] = "Write diff is not supported with dynamic/ephemeral configuration mode"
641             ret["out"] = False
642             return ret
643         config_params = {}
644         if "ephemeral_instance" in op:
645             config_params["ephemeral_instance"] = op.pop("ephemeral_instance")
646         try:
647             with Config(conn, mode=db_mode, **config_params) as cu:
648                 try:
649                     cu.load(**op)
650                 except Exception as exception:  # pylint: disable=broad-except
651                     ret[
652                         "message"
653                     ] = 'Could not load configuration due to : "{}"'.format(exception)
654                     ret["format"] = op["format"]
655                     ret["out"] = False
656                     _restart_connection()
657                     return ret
658                 config_diff = None
659                 if db_mode in ["dynamic", "ephemeral"]:
660                     log.warning("diff is not supported for dynamic and ephemeral")
661                 else:
662                     config_diff = cu.diff()
663                     if config_diff is None:
664                         ret["message"] = "Configuration already applied!"
665                         ret["out"] = True
666                         return ret
667                 commit_params = {}
668                 if "confirm" in op:
669                     commit_params["confirm"] = op["confirm"]
670                 if "comment" in op:
671                     commit_params["comment"] = op["comment"]
672                 check = True
673                 if db_mode in ["dynamic", "ephemeral"]:
674                     log.warning("commit check not supported for dynamic and ephemeral")
675                 else:
676                     try:
677                         check = cu.commit_check()
678                     except Exception as exception:  # pylint: disable=broad-except
679                         ret[
680                             "message"
681                         ] = 'Commit check threw the following exception: "{}"'.format(
682                             exception
683                         )
684                         ret["out"] = False
685                         _restart_connection()
686                         return ret
687                 if check and not test:
688                     try:
689                         cu.commit(**commit_params)
690                         ret["message"] = "Successfully loaded and committed!"
691                     except Exception as exception:  # pylint: disable=broad-except
692                         ret[
693                             "message"
694                         ] = 'Commit check successful but commit failed with "{}"'.format(
695                             exception
696                         )
697                         ret["out"] = False
698                         _restart_connection()
699                         return ret
700                 elif not check:
701                     try:
702                         cu.rollback()
703                         ret["message"] = (
704                             "Loaded configuration but commit check failed, hence"
705                             " rolling back configuration."
706                         )
707                     except Exception as exception:  # pylint: disable=broad-except
708                         ret["message"] = (
709                             "Loaded configuration but commit check failed, and"
710                             ' exception occurred during rolling back configuration "{}"'.format(
711                                 exception
712                             )
713                         )
714                         _restart_connection()
715                     ret["out"] = False
716                 else:
717                     try:
718                         cu.rollback()
719                         ret["message"] = (
720                             "Commit check passed, but skipping commit for dry-run and"
721                             " rolling back configuration."
722                         )
723                         ret["out"] = True
724                     except Exception as exception:  # pylint: disable=broad-except
725                         ret["message"] = (
726                             "Commit check passed, but skipping commit for dry-run and"
727                             ' while rolling back configuration exception occurred "{}"'.format(
728                                 exception
729                             )
730                         )
731                         ret["out"] = False
732                         _restart_connection()
733                 try:
734                     if write_diff and config_diff is not None:
735                         with salt.utils.files.fopen(write_diff, "w") as fp:
736                             fp.write(salt.utils.stringutils.to_str(config_diff))
737                 except Exception as exception:  # pylint: disable=broad-except
738                     ret[
739                         "message"
740                     ] = "Could not write into diffs_file due to: '{}'".format(exception)
741                     ret["out"] = False
742         except ValueError as ex:
743             message = "install_config failed due to: {}".format(str(ex))
744             log.error(message)
745             ret["message"] = message
746             ret["out"] = False
747         except LockError as ex:
748             log.error("Configuration database is locked")
749             ret["message"] = ex.message
750             ret["out"] = False
751         except RpcTimeoutError as ex:
752             message = "install_config failed due to timeout error : {}".format(str(ex))
753             log.error(message)
754             ret["message"] = message
755             ret["out"] = False
756         except Exception as exc:  # pylint: disable=broad-except
757             ret["message"] = "install_config failed due to exception: '{}'".format(exc)
758             ret["out"] = False
759         return ret
760 @_timeout_decorator_cleankwargs
761 def zeroize():
762     conn = __proxy__["junos.conn"]()
763     ret = {}
764     ret["out"] = True
765     try:
766         conn.cli("request system zeroize")
767         ret["message"] = "Completed zeroize and rebooted"
768     except Exception as exception:  # pylint: disable=broad-except
769         ret["message"] = 'Could not zeroize due to : "{}"'.format(exception)
770         ret["out"] = False
771         _restart_connection()
772     return ret
773 @_timeout_decorator
774 def install_os(path=None, **kwargs):
775     conn = __proxy__["junos.conn"]()
776     ret = {}
777     ret["out"] = True
778     op = {}
779     if "__pub_arg" in kwargs:
780         if kwargs["__pub_arg"]:
781             if isinstance(kwargs["__pub_arg"][-1], dict):
782                 op.update(kwargs["__pub_arg"][-1])
783     else:
784         op.update(kwargs)
785     dev_timeout = max(op.pop("dev_timeout", 0), op.pop("timeout", 0))
786     timeout = max(1800, conn.timeout, dev_timeout)
787     reboot = op.pop("reboot", False)
788     no_copy_ = op.get("no_copy", False)
789     if path is None:
790         ret[
791             "message"
792         ] = "Please provide the salt path where the junos image is present."
793         ret["out"] = False
794         return ret
795     if reboot:
796         __proxy__["junos.reboot_active"]()
797     install_status = False
798     if not no_copy_:
799         with HandleFileCopy(path) as image_path:
800             if image_path is None:
801                 ret["message"] = "Invalid path. Please provide a valid image path"
802                 ret["out"] = False
803                 __proxy__["junos.reboot_clear"]()
804                 return ret
805             if salt.utils.platform.is_junos():
806                 tmp_absfile = image_path
807                 op["no_copy"] = True
808                 op["remote_path"] = os.path.dirname(tmp_absfile)
809                 image_path = os.path.basename(tmp_absfile)
810             try:
811                 install_status, install_message = conn.sw.install(
812                     image_path, progress=True, timeout=timeout, **op
813                 )
814             except Exception as exception:  # pylint: disable=broad-except
815                 ret["message"] = 'Installation failed due to: "{}"'.format(exception)
816                 ret["out"] = False
817                 __proxy__["junos.reboot_clear"]()
818                 _restart_connection()
819                 return ret
820     else:
821         try:
822             install_status, install_message = conn.sw.install(
823                 path, progress=True, timeout=timeout, **op
824             )
825         except Exception as exception:  # pylint: disable=broad-except
826             ret["message"] = 'Installation failed due to: "{}"'.format(exception)
827             ret["out"] = False
828             __proxy__["junos.reboot_clear"]()
829             _restart_connection()
830             return ret
831     if install_status is True:
832         ret["out"] = True
833         ret["message"] = "Installed the os."
834     else:
835         ret["message"] = "Installation failed. Reason: {}".format(install_message)
836         ret["out"] = False
837         __proxy__["junos.reboot_clear"]()
838         return ret
839     if reboot is True:
840         reboot_kwargs = {}
841         if "vmhost" in op and op.get("vmhost") is True:
842             reboot_kwargs["vmhost"] = True
843         if "all_re" in op:
844             reboot_kwargs["all_re"] = op.get("all_re")
845         try:
846             __proxy__["junos.reboot_active"]()
847             conn.sw.reboot(**reboot_kwargs)
848         except Exception as exception:  # pylint: disable=broad-except
849             __proxy__["junos.reboot_clear"]()
850             ret[
851                 "message"
852             ] = 'Installation successful but reboot failed due to : "{}"'.format(
853                 exception
854             )
855             ret["out"] = False
856             _restart_connection()
857             return ret
858         __proxy__["junos.reboot_clear"]()
859         ret["out"] = True
860         ret["message"] = "Successfully installed and rebooted!"
861     return ret
862 @_timeout_decorator_cleankwargs
863 def file_copy(src, dest):
864     if salt.utils.platform.is_junos():
865         return {
866             "success": False,
867             "message": "This method is unsupported on the current operating system!",
868         }
869     conn = __proxy__["junos.conn"]()
870     ret = {}
871     ret["out"] = True
872     with HandleFileCopy(src) as fp:
873         if fp is None:
874             ret["message"] = "Invalid source file path {}".format(src)
875             ret["out"] = False
876             return ret
877         try:
878             with SCP(conn, progress=True) as scp:
879                 scp.put(fp, dest)
880             ret["message"] = "Successfully copied file from {} to {}".format(src, dest)
881         except Exception as exception:  # pylint: disable=broad-except
882             ret["message"] = 'Could not copy file : "{}"'.format(exception)
883             ret["out"] = False
884         return ret
885 @_timeout_decorator_cleankwargs
886 def lock():
887     conn = __proxy__["junos.conn"]()
888     ret = {}
889     ret["out"] = True
890     try:
891         conn.cu.lock()
892         ret["message"] = "Successfully locked the configuration."
893     except RpcTimeoutError as exception:
894         ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
895         ret["out"] = False
896         _restart_connection()
897     except LockError as exception:
898         ret["message"] = 'Could not gain lock due to : "{}"'.format(exception)
899         ret["out"] = False
900     return ret
901 @_timeout_decorator_cleankwargs
902 def unlock():
903     conn = __proxy__["junos.conn"]()
904     ret = {}
905     ret["out"] = True
906     try:
907         conn.cu.unlock()
908         ret["message"] = "Successfully unlocked the configuration."
909     except RpcTimeoutError as exception:
910         ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
911             exception
912         )
913         ret["out"] = False
914         _restart_connection()
915     except UnlockError as exception:
916         ret["message"] = 'Could not unlock configuration due to : "{}"'.format(
917             exception
918         )
919         ret["out"] = False
920     return ret
921 @_timeout_decorator
922 def load(path=None, **kwargs):
923     conn = __proxy__["junos.conn"]()
924     ret = {}
925     ret["out"] = True
926     if path is None:
927         ret[
928             "message"
929         ] = "Please provide the salt path where the configuration is present"
930         ret["out"] = False
931         return ret
932     op = {}
933     if "__pub_arg" in kwargs:
934         if kwargs["__pub_arg"]:
935             if isinstance(kwargs["__pub_arg"][-1], dict):
936                 op.update(kwargs["__pub_arg"][-1])
937     else:
938         op.update(kwargs)
939     kwargs = {}
940     if "template_vars" in op:
941         kwargs.update({"template_vars": op["template_vars"]})
942     with HandleFileCopy(path, **kwargs) as template_cached_path:
943         if template_cached_path is None:
944             ret["message"] = "Invalid file path."
945             ret["out"] = False
946             return ret
947         if os.path.getsize(template_cached_path) == 0:
948             ret["message"] = "Template failed to render"
949             ret["out"] = False
950             return ret
951         op["path"] = template_cached_path
952         if "format" not in op:
953             if path.endswith("set"):
954                 template_format = "set"
955             elif path.endswith("xml"):
956                 template_format = "xml"
957             elif path.endswith("json"):
958                 template_format = "json"
959             else:
960                 template_format = "text"
961             op["format"] = template_format
962         actions = [
963             item
964             for item in ("overwrite", "replace", "update", "merge")
965             if op.get(item, False)
966         ]
967         if len(list(actions)) &gt; 1:
968             ret["message"] = "Only one config_action is allowed. Provided: {}".format(
969                 actions
970             )
971             ret["out"] = False
972             return ret
973         if "replace" in op and op["replace"]:
974             op["merge"] = False
975             del op["replace"]
976         elif "overwrite" in op and op["overwrite"]:
977             op["overwrite"] = True
978         elif "merge" in op and op["merge"]:
979             op["merge"] = True
980         elif "overwrite" in op and not op["overwrite"]:
981             op["merge"] = True
982             del op["overwrite"]
983         try:
984             conn.cu.load(**op)
985             ret["message"] = "Successfully loaded the configuration."
986         except Exception as exception:  # pylint: disable=broad-except
987             ret["message"] = 'Could not load configuration due to : "{}"'.format(
988                 exception
989             )
990             ret["format"] = op["format"]
991             ret["out"] = False
992             _restart_connection()
993             return ret
994         return ret
995 @_timeout_decorator_cleankwargs
996 def commit_check():
997     conn = __proxy__["junos.conn"]()
998     ret = {}
999     ret["out"] = True
1000     try:
1001         conn.cu.commit_check()
1002         ret["message"] = "Commit check succeeded."
1003     except Exception as exception:  # pylint: disable=broad-except
1004         ret["message"] = "Commit check failed with {}".format(exception)
1005         ret["out"] = False
1006         _restart_connection()
1007     return ret
1008 @_timeout_decorator_cleankwargs
1009 def get_table(
1010     table,
1011     table_file,
1012     path=None,
1013     target=None,
1014     key=None,
1015     key_items=None,
1016     filters=None,
1017     table_args=None,
1018 ):
1019     conn = __proxy__["junos.conn"]()
1020     ret = {}
1021     ret["out"] = True
1022     ret["hostname"] = conn._hostname
1023     ret["tablename"] = table
1024     get_kvargs = {}
1025     if target is not None:
1026         get_kvargs["target"] = target
1027     if key is not None:
1028         get_kvargs["key"] = key
1029     if key_items is not None:
1030         get_kvargs["key_items"] = key_items
1031     if filters is not None:
1032         get_kvargs["filters"] = filters
1033     if table_args is not None and isinstance(table_args, dict):
1034         get_kvargs["args"] = table_args
1035     pyez_tables_path = os.path.dirname(os.path.abspath(tables_dir.__file__))
1036     try:
1037         if path is not None:
1038             file_path = os.path.join(path, "{}".format(table_file))
1039         else:
1040             file_path = os.path.join(pyez_tables_path, "{}".format(table_file))
1041         with HandleFileCopy(file_path) as file_loc:
1042             if file_loc is None:
1043                 ret["message"] = "Given table file {} cannot be located".format(
1044                     table_file
1045                 )
1046                 ret["out"] = False
1047                 return ret
1048             try:
1049                 with salt.utils.files.fopen(file_loc) as fp:
1050                     ret["table"] = yaml.load(
1051                         fp.read(), Loader=yamlordereddictloader.Loader
1052                     )
1053                     globals().update(FactoryLoader().load(ret["table"]))
1054             except OSError as err:
1055                 ret[
1056                     "message"
1057                 ] = "Uncaught exception during YAML Load - please report: {}".format(
1058                     str(err)
1059                 )
1060                 ret["out"] = False
1061                 return ret
1062             try:
1063                 data = globals()[table](conn)
1064                 data.get(**get_kvargs)
1065             except KeyError as err:
1066                 ret[
1067                     "message"
1068                 ] = "Uncaught exception during get API call - please report: {}".format(
1069                     str(err)
1070                 )
1071                 ret["out"] = False
1072                 return ret
1073             except ConnectClosedError:
1074                 ret[
1075                     "message"
1076                 ] = "Got ConnectClosedError exception. Connection lost with {}".format(
1077                     conn
1078                 )
1079                 ret["out"] = False
1080                 _restart_connection()
1081                 return ret
1082             ret["reply"] = json.loads(data.to_json())
1083             if data.__class__.__bases__[0] in [OpTable, CfgTable]:
1084                 if ret["table"][table].get("key") is None:
1085                     ret["table"][table]["key"] = data.ITEM_NAME_XPATH
1086                 if key is not None:
1087                     ret["table"][table]["key"] = data.KEY
1088                 if table_args is not None:
1089                     args = copy.copy(data.GET_ARGS)
1090                     args.update(table_args)
1091                     ret["table"][table]["args"] = args
1092             else:
1093                 if target is not None:
1094                     ret["table"][table]["target"] = data.TARGET
1095                 if key is not None:
1096                     ret["table"][table]["key"] = data.KEY
1097                 if key_items is not None:
1098                     ret["table"][table]["key_items"] = data.KEY_ITEMS
1099                 if table_args is not None:
1100                     args = copy.copy(data.CMD_ARGS)
1101                     args.update(table_args)
1102                     ret["table"][table]["args"] = args
1103                     ret["table"][table]["command"] = data.GET_CMD
1104     except ConnectClosedError:
1105         ret[
1106             "message"
1107         ] = "Got ConnectClosedError exception. Connection lost with {}".format(
1108             str(conn)
1109         )
1110         ret["out"] = False
1111         _restart_connection()
1112         return ret
1113     except Exception as err:  # pylint: disable=broad-except
1114         ret["message"] = "Uncaught exception - please report: {}".format(str(err))
1115         ret["out"] = False
1116         _restart_connection()
1117         return ret
1118     return ret
1119 def _recursive_dict(node):
1120     result = {}
1121     for element in node.iterchildren():
1122         key = element.tag.split("}")[1] if "}" in element.tag else element.tag
1123         if element.text and element.text.strip():
1124             value = element.text
1125         else:
1126             value = _recursive_dict(element)
1127         if key in result:
1128             if type(result[key]) is list:
1129                 result[key].append(value)
1130             else:
1131                 tempvalue = result[key].copy()
1132                 result[key] = [tempvalue, value]
1133         else:
1134             result[key] = value
1135     return result
1136 @_timeout_decorator
1137 def rpc_file_list(path, **kwargs):
1138     kwargs = salt.utils.args.clean_kwargs(**kwargs)
1139     conn = __proxy__["junos.conn"]()
1140     if conn._conn is None:
1141         return False
1142     results = conn.rpc.file_list(path=path)
1143     ret = {}
1144     ret["files"] = _recursive_dict(results)
1145     ret["success"] = True
1146     return ret
1147 def _strip_newlines(str):
1148     stripped = str.replace("\n", "")
1149     return stripped
1150 def _make_source_list(dir):
1151     dir_list = []
1152     if not dir:
1153         return
1154     base = rpc_file_list(dir)["files"]["directory"]
1155     if "file-information" not in base:
1156         if "directory_name" not in base:
1157             return None
1158         return [os.path.join(_strip_newlines(base.get("directory-name", None))) + "/"]
1159     if isinstance(base["file-information"], dict):
1160         dirname = os.path.join(
1161             dir, _strip_newlines(base["file-information"]["file-name"])
1162         )
1163         if "file-directory" in base["file-information"]:
1164             new_list = _make_source_list(os.path.join(dir, dirname))
1165             return new_list
1166         else:
1167             return [dirname]
1168     for entry in base["file-information"]:
1169         if "file-directory" in entry:
1170             new_list = _make_source_list(
1171                 os.path.join(dir, _strip_newlines(entry["file-name"]))
1172             )
1173             if new_list:
1174                 dir_list.extend(new_list)
1175         else:
1176             dir_list.append(os.path.join(dir, _strip_newlines(entry["file-name"])))
1177     return dir_list
1178 @_timeout_decorator
1179 def file_compare(file1, file2, **kwargs):
1180     if not salt.utils.platform.is_junos():
1181         return {
1182             "success": False,
1183             "message": "This method is unsupported on the current operating system!",
1184         }
1185     ret = {"message": "", "identical": False, "success": True}
1186     junos_cli = salt.utils.path.which("cli")
1187     if not junos_cli:
1188         return {"success": False, "message": "Cannot find Junos cli command"}
1189     cliret = __salt__["cmd.run"](
1190         "{} file compare files {} {} ".format(junos_cli, file1, file2)
1191     )
1192     clilines = cliret.splitlines()
1193     for r in clilines:
1194         if r.strip() != "":
1195             if "No such file" in r:
1196                 ret["identical"] = False
1197                 ret["success"] = False
1198                 return ret
1199             ret["identical"] = False
1200             ret["success"] = True
1201             return ret
1202     ret["identical"] = True
1203     ret["success"] = True
1204     return ret
1205 @_timeout_decorator
1206 def fsentry_exists(dir, **kwargs):
1207     if not salt.utils.platform.is_junos():
1208         return {
1209             "success": False,
1210             "message": "This method is unsupported on the current operating system!",
1211         }
1212     junos_cli = salt.utils.path.which("cli")
1213     if not junos_cli:
1214         return {"success": False, "message": "Cannot find Junos cli command"}
1215     ret = __salt__["cmd.run"]("{} file show {}".format(junos_cli, dir))
1216     retlines = ret.splitlines()
1217     exists = True
1218     is_dir = False
1219     status = {"is_dir": False, "exists": True}
1220     for r in retlines:
1221         if "could not resolve" in r or "error: Could not connect" in r:
1222             status["is_dir"] = False
1223             status["exists"] = False
1224         if "is not a regular file" in r:
1225             status["is_dir"] = True
1226             status["exists"] = True
1227     return status
1228 def _find_routing_engines():
1229     junos_cli = salt.utils.path.which("cli")
1230     if not junos_cli:
1231         return {"success": False, "message": "Cannot find Junos cli command"}
1232     re_check = __salt__["cmd.run"]("{} show chassis routing-engine".format(junos_cli))
1233     engine_present = True
1234     engine = {}
1235     current_engine = None
1236     status = None
1237     for l in re_check.splitlines():
1238         if "Slot" in l:
1239             mat = re.search(".*(\\d+):.*", l)
1240             if mat:
1241                 current_engine = "re" + str(mat.group(1)) + ":"
1242         if "Current state" in l:
1243             if "Master" in l:
1244                 status = "Master"
1245             if "Disabled" in l:
1246                 status = "Disabled"
1247             if "Backup" in l:
1248                 status = "Backup"
1249         if current_engine and status:
1250             engine[current_engine] = status
1251             current_engine = None
1252             status = None
1253     if not engine:
1254         return {
1255             "success": False,
1256             "message": "Junos cli command returned no information",
1257         }
1258     engine["success"] = True
1259     return engine
1260 @_timeout_decorator
1261 def routing_engine(**kwargs):
1262     engine_status = _find_routing_engines()
1263     if not engine_status["success"]:
1264         return {"success": False}
1265     master = None
1266     backup = []
1267     for k, v in engine_status.items():
1268         if v == "Master":
1269             master = k
1270         if v == "Backup" or v == "Disabled":
1271             backup.append(k)
1272     if master:
1273         ret = {"master": master, "backup": backup, "success": True}
1274     else:
1275         ret = {"master": master, "backup": backup, "success": False}
1276     log.debug(ret)
1277     return ret
1278 @_timeout_decorator
1279 def dir_copy(source, dest, force=False, **kwargs):
1280     if not salt.utils.platform.is_junos():
1281         return {
1282             "success": False,
1283             "message": "This method is unsupported on the current operating system!",
1284         }
1285     junos_cli = salt.utils.path.which("cli")
1286     if not junos_cli:
1287         return {"success": False, "message": "Cannot find Junos cli command"}
1288     ret = {}
1289     ret_messages = ""
1290     if not source.startswith("/"):
1291         ret["message"] = "Source directory must be a fully qualified path."
1292         ret["success"] = False
1293         return ret
1294     if not (dest.endswith(":") or dest.startswith("/")):
1295         ret["message"] = (
1296             "Destination must be a routing engine reference (e.g. re1:) or a fully"
1297             " qualified path."
1298         )
1299         ret["success"] = False
1300         return ret
1301     check_source = fsentry_exists(source)
1302     if not check_source["exists"]:
1303         ret["message"] = "Source does not exist"
1304         ret["success"] = False
1305         return ret
1306     if not check_source["is_dir"]:
1307         ret["message"] = "Source is not a directory."
1308         ret["success"] = False
1309         return ret
1310     filelist = _make_source_list(source)
1311     dirops = []
1312     for f in filelist:
1313         splitpath = os.path.split(f)[0]
1314         fullpath = "/"
1315         for component in splitpath.split("/"):
1316             fullpath = os.path.join(fullpath, component)
1317             if fullpath not in dirops:
1318                 dirops.append(fullpath)
1319     for d in dirops:
1320         target = dest + d
1321         status = fsentry_exists(target)
1322         if not status["exists"]:
1323             ret = __salt__["cmd.run"](
1324                 "{} file make-directory {}".format(junos_cli, target)
1325             )
1326             ret = ret_messages + ret
1327         else:
1328             ret_messages = ret_messages + "Directory " + target + " already exists.\n"
1329     for f in filelist:
1330         if not f.endswith("/"):
1331             target = dest + f
1332             comp_result = file_compare(f, target)
1333             if not comp_result["identical"] or force:
1334                 ret = __salt__["cmd.run"](
1335                     "{} file copy {} {}".format(junos_cli, f, target)
1336                 )
1337                 ret = ret_messages + ret
1338             else:
1339                 ret_messages = (
1340                     ret_messages
1341                     + "Files {} and {} are identical, not copying.\n".format(f, target)
1342                 )
1343     return ret_messages
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
