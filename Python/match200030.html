<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mysql_query.py &amp; pip_state.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mysql_query.py &amp; pip_state.py
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mysql_query.py (2.9017856%)<th>pip_state.py (1.1638317%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(241-294)<td><a href="#" name="0">(1092-1105)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mysql_query.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os.path
import sys
import salt.utils.files
import salt.utils.stringutils
def __virtual__():
    if "mysql.query" in __salt__:
        return True
    return (False, "mysql module could not be loaded")
def _get_mysql_error():
    return sys.modules[__salt__["test.ping"].__module__].__context__.pop(
        "mysql.error", None
    )
def run_file(
    name,
    database,
    query_file=None,
    output=None,
    grain=None,
    key=None,
    overwrite=True,
    saltenv=None,
    check_db_exists=True,
    client_flags=None,
    **connection_args
):
    ret = {
        "name": name,
        "changes": {},
        "result": True,
        "comment": "Database {} is already present".format(database),
    }
    if client_flags is None:
        client_flags = []
    connection_args["client_flags"] = client_flags
    if not isinstance(client_flags, list):
        ret["comment"] = "Error: client_flags must be a list."
        ret["result"] = False
        return ret
    if any(
        [
            query_file.startswith(proto)
            for proto in ["http://", "https://", "salt://", "s3://", "swift://"]
        ]
    ):
        query_file = __salt__["cp.cache_file"](query_file, saltenv=saltenv or __env__)
    if not os.path.exists(query_file):
        ret["comment"] = "File {} does not exist".format(query_file)
        ret["result"] = False
        return ret
    if check_db_exists and not __salt__["mysql.db_exists"](database, **connection_args):
        err = _get_mysql_error()
        if err is not None:
            ret["comment"] = err
            ret["result"] = False
            return ret
        ret["result"] = None
        ret["comment"] = "Database {} is not present".format(database)
        return ret
    if output == "grain":
        if grain is not None and key is None:
            if not overwrite and grain in __salt__["grains.ls"]():
                ret["comment"] = "No execution needed. Grain " + grain + " already set"
                return ret
            elif __opts__["test"]:
                ret["result"] = None
                ret["comment"] = (
                    "Query would execute, storing result in " + "grain: " + grain
                )
                return ret
        elif grain is not None:
            if grain in __salt__["grains.ls"]():
                grain_value = __salt__["grains.get"](grain)
            else:
                grain_value = {}
            if not overwrite and key in grain_value:
                ret["comment"] = (
                    "No execution needed. Grain " + grain + ":" + key + " already set"
                )
                return ret
            elif __opts__["test"]:
                ret["result"] = None
                ret["comment"] = (
                    "Query would execute, storing result in "
                    + "grain: "
                    + grain
                    + ":"
                    + key
                )
                return ret
        else:
            ret["result"] = False
            ret["comment"] = (
                "Error: output type 'grain' needs the grain " + "parameter\n"
            )
            return ret
    elif output is not None:
        if not overwrite and os.path.isfile(output):
            ret["comment"] = "No execution needed. File " + output + " already set"
            return ret
        elif __opts__["test"]:
            ret["result"] = None
            ret["comment"] = (
                "Query would execute, storing result in " + "file: " + output
            )
            return ret
    elif __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Query would execute, not storing result"
        return ret
    query_result = __salt__["mysql.file_query"](database, query_file, **connection_args)
    if query_result is False:
        ret["result"] = False
        return ret
    mapped_results = []
    if "results" in query_result:
        for res in query_result["results"]:
            mapped_line = {}
            for idx, col in enumerate(query_result["columns"]):
                mapped_line[col] = res[idx]
            mapped_results.append(mapped_line)
        query_result["results"] = mapped_results
    ret["comment"] = str(query_result)
    if output == "grain":
        if grain is not None and key is None:
            __salt__["grains.setval"](grain, query_result)
            ret["changes"]["query"] = "Executed. Output into grain: " + grain
        elif grain is not None:
            if grain in __salt__["grains.ls"]():
                grain_value = __salt__["grains.get"](grain)
            else:
                grain_value = {}
            grain_value[key] = query_result
            __salt__["grains.setval"](grain, grain_value)
            ret["changes"]["query"] = (
                "Executed. Output into grain: " + grain + ":" + key
            )
    elif output is not None:
        ret["changes"]["query"] = "Executed. Output into " + output
        with salt.utils.files.fopen(output, "w") as output_file:
            if "results" in query_result:
                for res in query_result["results"]:
                    for col, val in res.items():
                        output_file.write(
                            salt.utils.stringutils.to_str(col + ":" + val + "\n")
                        )
<a name="0"></a>            else:
                output_file.write(salt.utils.stringutils.to_str(query_result))
    else:
        ret["changes"]<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["query"] = "Executed"
    return ret
def run(
    name,
    database,
    query,
    output=None,
    grain=None,
    key=None,
    overwrite=True,
    check_db_exists=True,
    client_flags=None,
    **connection_args
):
    ret =</b></font> {
        "name": name,
        "changes": {},
        "result": True,
        "comment": "Database {} is already present".format(database),
    }
    if client_flags is None:
        client_flags = []
    connection_args["client_flags"] = client_flags
    if not isinstance(client_flags, list):
        ret["comment"] = "Error: client_flags must be a list."
        ret["result"] = False
        return ret
    if check_db_exists and not __salt__["mysql.db_exists"](database, **connection_args):
        err = _get_mysql_error()
        if err is not None:
            ret["comment"] = err
            ret["result"] = False
            return ret
        ret["result"] = None
        ret["comment"] = "Database {} is not present".format(name)
        return ret
    if output == "grain":
        if grain is not None and key is None:
            if not overwrite and grain in __salt__["grains.ls"]():
                ret["comment"] = "No execution needed. Grain " + grain + " already set"
                return ret
            elif __opts__["test"]:
                ret["result"] = None
                ret["comment"] = (
                    "Query would execute, storing result in " + "grain: " + grain
                )
                return ret
        elif grain is not None:
            if grain in __salt__["grains.ls"]():
                grain_value = __salt__["grains.get"](grain)
            else:
                grain_value = {}
            if not overwrite and key in grain_value:
                ret["comment"] = (
                    "No execution needed. Grain " + grain + ":" + key + " already set"
                )
                return ret
            elif __opts__["test"]:
                ret["result"] = None
                ret["comment"] = (
                    "Query would execute, storing result in "
                    + "grain: "
                    + grain
                    + ":"
                    + key
                )
                return ret
        else:
            ret["result"] = False
            ret["comment"] = (
                "Error: output type 'grain' needs the grain " + "parameter\n"
            )
            return ret
    elif output is not None:
        if not overwrite and os.path.isfile(output):
            ret["comment"] = "No execution needed. File " + output + " already set"
            return ret
        elif __opts__["test"]:
            ret["result"] = None
            ret["comment"] = (
                "Query would execute, storing result in " + "file: " + output
            )
            return ret
    elif __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Query would execute, not storing result"
        return ret
    query_result = __salt__["mysql.query"](database, query, **connection_args)
    mapped_results = []
    if "results" in query_result:
        for res in query_result["results"]:
            mapped_line = {}
            for idx, col in enumerate(query_result["columns"]):
                mapped_line[col] = res[idx]
            mapped_results.append(mapped_line)
        query_result["results"] = mapped_results
    ret["comment"] = str(query_result)
    if output == "grain":
        if grain is not None and key is None:
            __salt__["grains.setval"](grain, query_result)
            ret["changes"]["query"] = "Executed. Output into grain: " + grain
        elif grain is not None:
            if grain in __salt__["grains.ls"]():
                grain_value = __salt__["grains.get"](grain)
            else:
                grain_value = {}
            grain_value[key] = query_result
            __salt__["grains.setval"](grain, grain_value)
            ret["changes"]["query"] = (
                "Executed. Output into grain: " + grain + ":" + key
            )
    elif output is not None:
        ret["changes"]["query"] = "Executed. Output into " + output
        with salt.utils.files.fopen(output, "w") as output_file:
            if "results" in query_result:
                for res in query_result["results"]:
                    for col, val in res.items():
                        output_file.write(
                            salt.utils.stringutils.to_str(col + ":" + val + "\n")
                        )
            else:
                if isinstance(query_result, str):
                    output_file.write(salt.utils.stringutils.to_str(query_result))
                else:
                    for col, val in query_result.items():
                        output_file.write(
                            salt.utils.stringutils.to_str("{}:{}\n".format(col, val))
                        )
    else:
        ret["changes"]["query"] = "Executed"
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pip_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import re
import sys
import types
import salt.utils.data
import salt.utils.versions
from salt.exceptions import CommandExecutionError, CommandNotFoundError
try:
    import pkg_resources
    HAS_PKG_RESOURCES = True
except ImportError:
    HAS_PKG_RESOURCES = False
def purge_pip():
    if "pip" not in sys.modules:
        return
    pip_related_entries = [
        (k, v)
        for (k, v) in sys.modules.items()
        if getattr(v, "__module__", "").startswith("pip.")
        or (isinstance(v, types.ModuleType) and v.__name__.startswith("pip."))
    ]
    for name, entry in pip_related_entries:
        sys.modules.pop(name)
        del entry
    if "pip" in globals():
        del globals()["pip"]
    if "pip" in locals():
        del locals()["pip"]
    sys_modules_pip = sys.modules.pop("pip", None)
    if sys_modules_pip is not None:
        del sys_modules_pip
def pip_has_internal_exceptions_mod(ver):
    return salt.utils.versions.compare(
        ver1=ver,
        oper="&gt;=",
        ver2="10.0",
    )
def pip_has_exceptions_mod(ver):
    if pip_has_internal_exceptions_mod(ver):
        return False
    return salt.utils.versions.compare(ver1=ver, oper="&gt;=", ver2="1.0")
try:
    import pip
    HAS_PIP = True
except ImportError:
    HAS_PIP = False
    purge_pip()
if HAS_PIP is True:
    if not hasattr(purge_pip, "__pip_ver__"):
        purge_pip.__pip_ver__ = pip.__version__
    elif purge_pip.__pip_ver__ != pip.__version__:
        purge_pip()
        import pip
        purge_pip.__pip_ver__ = pip.__version__
    if salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="10.0"):
        from pip._internal.exceptions import (
            InstallationError,
        )  # pylint: disable=E0611,E0401
    elif salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="1.0"):
        from pip.exceptions import InstallationError  # pylint: disable=E0611,E0401
    else:
        InstallationError = ValueError
log = logging.getLogger(__name__)
__virtualname__ = "pip"
def _from_line(*args, **kwargs):
    import pip
    if salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="18.1"):
        import pip._internal.req.constructors  # pylint: disable=E0611,E0401
        return pip._internal.req.constructors.install_req_from_line(*args, **kwargs)
    elif salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="10.0"):
        import pip._internal.req  # pylint: disable=E0611,E0401
        return pip._internal.req.InstallRequirement.from_line(*args, **kwargs)
    else:
        import pip.req  # pylint: disable=E0611,E0401
        return pip.req.InstallRequirement.from_line(*args, **kwargs)
def __virtual__():
    if HAS_PKG_RESOURCES is False:
        return False, "The pkg_resources python library is not installed"
    if "pip.list" in __salt__:
        return __virtualname__
    return False
def _fulfills_version_spec(version, version_spec):
    for oper, spec in version_spec:
        if oper is None:
            continue
        if not salt.utils.versions.compare(
            ver1=version, oper=oper, ver2=spec, cmp_func=_pep440_version_cmp
        ):
            return False
    return True
def _check_pkg_version_format(pkg):
    ret = {"result": False, "comment": None, "prefix": None, "version_spec": None}
    if not HAS_PIP:
        ret["comment"] = (
            "An importable Python 2 pip module is required but could not be "
            "found on your system. This usually means that the system's pip "
            "package is not installed properly."
        )
        return ret
    from_vcs = False
    try:
        try:
            log.debug("Installed pip version: %s", pip.__version__)
            install_req = _from_line(pkg)
        except AttributeError:
            log.debug("Installed pip version is lower than 1.2")
            supported_vcs = ("git", "svn", "hg", "bzr")
            if pkg.startswith(supported_vcs):
                for vcs in supported_vcs:
                    if pkg.startswith(vcs):
                        from_vcs = True
                        install_req = _from_line(pkg.split("{}+".format(vcs))[-1])
                        break
            else:
                install_req = _from_line(pkg)
    except (ValueError, InstallationError) as exc:
        ret["result"] = False
        if not from_vcs and "=" in pkg and "==" not in pkg:
            ret["comment"] = (
                "Invalid version specification in package {}. '=' is "
                "not supported, use '==' instead.".format(pkg)
            )
            return ret
        ret["comment"] = "pip raised an exception while parsing '{}': {}".format(
            pkg, exc
        )
        return ret
    if install_req.req is None:
        ret["result"] = True
        ret["prefix"] = ""
        ret["version_spec"] = []
    else:
        ret["result"] = True
        try:
            ret["prefix"] = install_req.req.project_name
            ret["version_spec"] = install_req.req.specs
        except Exception:  # pylint: disable=broad-except
            ret["prefix"] = re.sub("[^A-Za-z0-9.]+", "-", install_req.name)
            if hasattr(install_req, "specifier"):
                specifier = install_req.specifier
            else:
                specifier = install_req.req.specifier
            ret["version_spec"] = [(spec.operator, spec.version) for spec in specifier]
    return ret
def _check_if_installed(
    prefix,
    state_pkg_name,
    version_spec,
    ignore_installed,
    force_reinstall,
    upgrade,
    user,
    cwd,
    bin_env,
    env_vars,
    index_url,
    extra_index_url,
    pip_list=False,
    **kwargs
):
    ret = {"result": False, "comment": None}
    pip_list = salt.utils.data.CaseInsensitiveDict(
        pip_list
        or __salt__["pip.list"](
            prefix, bin_env=bin_env, user=user, cwd=cwd, env_vars=env_vars, **kwargs
        )
    )
    if ignore_installed is False and prefix in pip_list:
        if force_reinstall is False and not upgrade:
            if (
                any(version_spec)
                and _fulfills_version_spec(pip_list[prefix], version_spec)
            ) or (not any(version_spec)):
                ret["result"] = True
                ret["comment"] = "Python package {} was already installed".format(
                    state_pkg_name
                )
                return ret
        if force_reinstall is False and upgrade:
            include_alpha = False
            include_beta = False
            include_rc = False
            if any(version_spec):
                for spec in version_spec:
                    if "a" in spec[1]:
                        include_alpha = True
                    if "b" in spec[1]:
                        include_beta = True
                    if "rc" in spec[1]:
                        include_rc = True
            available_versions = __salt__["pip.list_all_versions"](
                prefix,
                bin_env=bin_env,
                include_alpha=include_alpha,
                include_beta=include_beta,
                include_rc=include_rc,
                user=user,
                cwd=cwd,
                index_url=index_url,
                extra_index_url=extra_index_url,
            )
            desired_version = ""
            if any(version_spec) and available_versions:
                for version in reversed(available_versions):
                    if _fulfills_version_spec(version, version_spec):
                        desired_version = version
                        break
            elif available_versions:
                desired_version = available_versions[-1]
            if not desired_version:
                ret["result"] = True
                ret["comment"] = (
                    "Python package {} was already "
                    "installed and\nthe available upgrade "
                    "doesn't fulfills the version "
                    "requirements".format(prefix)
                )
                return ret
            if _pep440_version_cmp(pip_list[prefix], desired_version) == 0:
                ret["result"] = True
                ret["comment"] = "Python package {} was already installed".format(
                    state_pkg_name
                )
                return ret
    return ret
def _pep440_version_cmp(pkg1, pkg2, ignore_epoch=False):
    if HAS_PKG_RESOURCES is False:
        log.warning(
            "The pkg_resources packages was not loaded. Please install setuptools."
        )
        return None
    normalize = lambda x: str(x).split("!", 1)[-1] if ignore_epoch else str(x)
    pkg1 = normalize(pkg1)
    pkg2 = normalize(pkg2)
    try:
        if pkg_resources.parse_version(pkg1) &lt; pkg_resources.parse_version(pkg2):
            return -1
        if pkg_resources.parse_version(pkg1) == pkg_resources.parse_version(pkg2):
            return 0
        if pkg_resources.parse_version(pkg1) &gt; pkg_resources.parse_version(pkg2):
            return 1
    except Exception as exc:  # pylint: disable=broad-except
        log.exception(exc)
    return None
def installed(
    name,
    pkgs=None,
    pip_bin=None,
    requirements=None,
    bin_env=None,
    use_wheel=False,
    no_use_wheel=False,
    log=None,
    proxy=None,
    timeout=None,
    repo=None,
    editable=None,
    find_links=None,
    index_url=None,
    extra_index_url=None,
    no_index=False,
    mirrors=None,
    build=None,
    target=None,
    download=None,
    download_cache=None,
    source=None,
    upgrade=False,
    force_reinstall=False,
    ignore_installed=False,
    exists_action=None,
    no_deps=False,
    no_install=False,
    no_download=False,
    install_options=None,
    global_options=None,
    user=None,
    cwd=None,
    pre_releases=False,
    cert=None,
    allow_all_external=False,
    allow_external=None,
    allow_unverified=None,
    process_dependency_links=False,
    env_vars=None,
    use_vt=False,
    trusted_host=None,
    no_cache_dir=False,
    cache_dir=None,
    no_binary=None,
    extra_args=None,
    **kwargs
):
    if pip_bin and not bin_env:
        bin_env = pip_bin
    if pkgs:
        if not isinstance(pkgs, list):
            return {
                "name": name,
                "result": False,
                "changes": {},
                "comment": "pkgs argument must be formatted as a list",
            }
    else:
        pkgs = [name]
    prepro = (
        lambda pkg: pkg
        if isinstance(pkg, str)
        else " ".join((pkg.items()[0][0], pkg.items()[0][1]))
    )
    pkgs = [prepro(pkg) for pkg in pkgs]
    ret = {"name": ";".join(pkgs), "result": None, "comment": "", "changes": {}}
    try:
        cur_version = __salt__["pip.version"](bin_env)
    except (CommandNotFoundError, CommandExecutionError) as err:
        ret["result"] = False
        ret["comment"] = "Error installing '{}': {}".format(name, err)
        return ret
    if use_wheel:
        min_version = "1.4"
        max_version = "9.0.3"
        too_low = salt.utils.versions.compare(
            ver1=cur_version, oper="&lt;", ver2=min_version
        )
        too_high = salt.utils.versions.compare(
            ver1=cur_version, oper="&gt;", ver2=max_version
        )
        if too_low or too_high:
            ret["result"] = False
            ret["comment"] = (
                "The 'use_wheel' option is only supported in "
                "pip between {} and {}. The version of pip detected "
                "was {}.".format(min_version, max_version, cur_version)
            )
            return ret
    if no_use_wheel:
        min_version = "1.4"
        max_version = "9.0.3"
        too_low = salt.utils.versions.compare(
            ver1=cur_version, oper="&lt;", ver2=min_version
        )
        too_high = salt.utils.versions.compare(
            ver1=cur_version, oper="&gt;", ver2=max_version
        )
        if too_low or too_high:
            ret["result"] = False
            ret["comment"] = (
                "The 'no_use_wheel' option is only supported in "
                "pip between {} and {}. The version of pip detected "
                "was {}.".format(min_version, max_version, cur_version)
            )
            return ret
    if no_binary:
        min_version = "7.0.0"
        too_low = salt.utils.versions.compare(
            ver1=cur_version, oper="&lt;", ver2=min_version
        )
        if too_low:
            ret["result"] = False
            ret["comment"] = (
                "The 'no_binary' option is only supported in "
                "pip {} and newer. The version of pip detected "
                "was {}.".format(min_version, cur_version)
            )
            return ret
    pkgs_details = []
    if pkgs and not (requirements or editable):
        comments = []
        for pkg in iter(pkgs):
            out = _check_pkg_version_format(pkg)
            if out["result"] is False:
                ret["result"] = False
                comments.append(out["comment"])
            elif out["result"] is True:
                pkgs_details.append((out["prefix"], pkg, out["version_spec"]))
        if ret["result"] is False:
            ret["comment"] = "\n".join(comments)
            return ret
    target_pkgs = []
    already_installed_comments = []
    if requirements or editable:
        comments = []
        if __opts__["test"]:
            ret["result"] = None
            if requirements:
                comments.append(
                    "Requirements file '{}' will be processed.".format(requirements)
                )
            if editable:
                comments.append(
                    "Package will be installed in editable mode (i.e. "
                    'setuptools "develop mode") from {}.'.format(editable)
                )
            ret["comment"] = " ".join(comments)
            return ret
    else:
        try:
            pip_list = __salt__["pip.list"](bin_env=bin_env, user=user, cwd=cwd)
        except Exception as exc:  # pylint: disable=broad-except
            log.exception(exc)
            pip_list = False
        for prefix, state_pkg_name, version_spec in pkgs_details:
            if prefix:
                out = _check_if_installed(
                    prefix,
                    state_pkg_name,
                    version_spec,
                    ignore_installed,
                    force_reinstall,
                    upgrade,
                    user,
                    cwd,
                    bin_env,
                    env_vars,
                    index_url,
                    extra_index_url,
                    pip_list,
                    **kwargs
                )
                if out["result"] is None:
                    ret["result"] = False
                    ret["comment"] = out["comment"]
                    return ret
            else:
                out = {"result": False, "comment": None}
            result = out["result"]
            if result is False:
                target_pkgs.append((prefix, state_pkg_name.replace(",", ";")))
                if __opts__["test"]:
                    if len(pkgs_details) &gt; 1:
                        msg = "Python package(s) set to be installed:"
                        for pkg in pkgs_details:
                            msg += "\n"
                            msg += pkg[1]
                            ret["comment"] = msg
                    else:
                        msg = "Python package {0} is set to be installed"
                        ret["comment"] = msg.format(state_pkg_name)
                    ret["result"] = None
                    return ret
            elif result is True:
                already_installed_comments.append(out["comment"])
            elif result is None:
                ret["result"] = None
                ret["comment"] = out["comment"]
                return ret
        if not target_pkgs:
            ret["result"] = True
            aicomms = "\n".join(already_installed_comments)
            last_line = "All specified packages are already installed" + (
                " and up-to-date" if upgrade else ""
            )
            ret["comment"] = aicomms + ("\n" if aicomms else "") + last_line
            return ret
    pkgs_str = ",".join([state_name for _, state_name in target_pkgs])
    pip_install_call = __salt__["pip.install"](
        pkgs="{}".format(pkgs_str) if pkgs_str else "",
        requirements=requirements,
        bin_env=bin_env,
        use_wheel=use_wheel,
        no_use_wheel=no_use_wheel,
        no_binary=no_binary,
        log=log,
        proxy=proxy,
        timeout=timeout,
        editable=editable,
        find_links=find_links,
        index_url=index_url,
        extra_index_url=extra_index_url,
        no_index=no_index,
        mirrors=mirrors,
        build=build,
        target=target,
        download=download,
        download_cache=download_cache,
        source=source,
        upgrade=upgrade,
        force_reinstall=force_reinstall,
        ignore_installed=ignore_installed,
        exists_action=exists_action,
        no_deps=no_deps,
        no_install=no_install,
        no_download=no_download,
        install_options=install_options,
        global_options=global_options,
        user=user,
        cwd=cwd,
        pre_releases=pre_releases,
        cert=cert,
        allow_all_external=allow_all_external,
        allow_external=allow_external,
        allow_unverified=allow_unverified,
        process_dependency_links=process_dependency_links,
        saltenv=__env__,
        env_vars=env_vars,
        use_vt=use_vt,
        trusted_host=trusted_host,
        no_cache_dir=no_cache_dir,
        extra_args=extra_args,
        disable_version_check=True,
        **kwargs
    )
    if pip_install_call and pip_install_call.get("retcode", 1) == 0:
        ret["result"] = True
        if requirements or editable:
            comments = []
            if requirements:
                PIP_REQUIREMENTS_NOCHANGE = [
                    "Requirement already satisfied",
                    "Requirement already up-to-date",
                    "Requirement not upgraded",
                    "Collecting",
                    "Cloning",
                    "Cleaning up...",
                    "Looking in indexes",
                ]
                for line in pip_install_call.get("stdout", "").split("\n"):
                    if not any(
                        [line.strip().startswith(x) for x in PIP_REQUIREMENTS_NOCHANGE]
                    ):
                        ret["changes"]["requirements"] = True
                if ret["changes"].get("requirements"):
                    comments.append(
                        "Successfully processed requirements file {}.".format(
                            requirements
                        )
                    )
                else:
                    comments.append("Requirements were already installed.")
            if editable:
                comments.append(
                    "Package successfully installed from VCS checkout {}.".format(
                        editable
                    )
                )
                ret["changes"]["editable"] = True
            ret["comment"] = " ".join(comments)
        else:
            pkg_404_comms = []
            already_installed_packages = set()
            for line in pip_install_call.get("stdout", "").split("\n"):
                if line.startswith("Requirement already up-to-date: "):
                    package = line.split(":", 1)[1].split()[0]
                    already_installed_packages.add(package.lower())
            for prefix, state_name in target_pkgs:
                if prefix:
                    pipsearch = salt.utils.data.CaseInsensitiveDict(
                        __salt__["pip.list"](
                            prefix,
                            bin_env,
                            user=user,
                            cwd=cwd,
                            env_vars=env_vars,
                            **kwargs
                        )
                    )
                    if not pipsearch:
                        pkg_404_comms.append(
                            "There was no error installing package '{}' "
                            "although it does not show when calling "
                            "'pip.freeze'.".format(pkg)
                        )
                    else:
                        if (
                            prefix in pipsearch
                            and prefix.lower() not in already_installed_packages
                        ):
                            ver = pipsearch[prefix]
                            ret["changes"]["{}=={}".format(prefix, ver)] = "Installed"
                else:
                    ret["changes"]["{}==???".format(state_name)] = "Installed"
            aicomms = "\n".join(already_installed_comments)
            succ_comm = (
                "All packages were successfully installed"
                if not pkg_404_comms
                else "\n".join(pkg_404_comms)
            )
            ret["comment"] = aicomms + ("\n" if aicomms else "") + succ_comm
            return ret
    elif pip_install_call:
        ret["result"] = False
        if "stdout" in pip_install_call:
            error = "Error: {} {}".format(
                pip_install_call["stdout"], pip_install_call["stderr"]
            )
        else:
            error = "Error: {}".format(pip_install_call["comment"])
        if requirements or editable:
            comments = []
            if requirements:
                comments.append(
                    'Unable to process requirements file "{}"'.format(requirements)
                )
            if editable:
                comments.append(
                    "Unable to install from VCS checkout {}.".format(editable)
                )
            comments.append(error)
            ret["comment"] = " ".join(comments)
        else:
            pkgs_str = ", ".join([state_name for _, state_name in target_pkgs])
            aicomms = "\n".join(already_installed_comments)
            error_comm = "Failed to install packages: {}. {}".format(pkgs_str, error)
<a name="0"></a>            ret["comment"] = aicomms + ("\n" if aicomms else "") + error_comm
    else:
        ret["result"] = False
        ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "Could not install package"
    return ret
def removed(
    name,
    requirements=None,
    bin_env=None,
    log=None,
    proxy=None,
    timeout=None,
    user=None,
    cwd=</b></font>None,
    use_vt=False,
):
    ret = {"name": name, "result": None, "comment": "", "changes": {}}
    try:
        pip_list = __salt__["pip.list"](bin_env=bin_env, user=user, cwd=cwd)
    except (CommandExecutionError, CommandNotFoundError) as err:
        ret["result"] = False
        ret["comment"] = "Error uninstalling '{}': {}".format(name, err)
        return ret
    if name not in pip_list:
        ret["result"] = True
        ret["comment"] = "Package is not installed."
        return ret
    if __opts__["test"]:
        ret["result"] = None
        ret["comment"] = "Package {} is set to be removed".format(name)
        return ret
    if __salt__["pip.uninstall"](
        pkgs=name,
        requirements=requirements,
        bin_env=bin_env,
        log=log,
        proxy=proxy,
        timeout=timeout,
        user=user,
        cwd=cwd,
        use_vt=use_vt,
    ):
        ret["result"] = True
        ret["changes"][name] = "Removed"
        ret["comment"] = "Package was successfully removed."
    else:
        ret["result"] = False
        ret["comment"] = "Could not remove package."
    return ret
def uptodate(name, bin_env=None, user=None, cwd=None, use_vt=False):
    ret = {"name": name, "changes": {}, "result": False, "comment": "Failed to update."}
    try:
        packages = __salt__["pip.list_upgrades"](bin_env=bin_env, user=user, cwd=cwd)
    except Exception as e:  # pylint: disable=broad-except
        ret["comment"] = str(e)
        return ret
    if not packages:
        ret["comment"] = "System is already up-to-date."
        ret["result"] = True
        return ret
    elif __opts__["test"]:
        ret["comment"] = "System update will be performed"
        ret["result"] = None
        return ret
    updated = __salt__["pip.upgrade"](
        bin_env=bin_env, user=user, cwd=cwd, use_vt=use_vt
    )
    if updated.get("result") is False:
        ret.update(updated)
    elif updated:
        ret["changes"] = updated
        ret["comment"] = "Upgrade successful."
        ret["result"] = True
    else:
        ret["comment"] = "Upgrade failed."
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
