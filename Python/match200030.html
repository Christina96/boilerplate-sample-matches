<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mysql_query.py &amp; pip_state.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mysql_query.py &amp; pip_state.py
      </h3>
<h1 align="center">
        1.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mysql_query.py (2.9017856%)<th>pip_state.py (1.1638317%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(241-294)<td><a href="#" name="0">(1092-1105)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mysql_query.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os.path
2 import sys
3 import salt.utils.files
4 import salt.utils.stringutils
5 def __virtual__():
6     if "mysql.query" in __salt__:
7         return True
8     return (False, "mysql module could not be loaded")
9 def _get_mysql_error():
10     return sys.modules[__salt__["test.ping"].__module__].__context__.pop(
11         "mysql.error", None
12     )
13 def run_file(
14     name,
15     database,
16     query_file=None,
17     output=None,
18     grain=None,
19     key=None,
20     overwrite=True,
21     saltenv=None,
22     check_db_exists=True,
23     client_flags=None,
24     **connection_args
25 ):
26     ret = {
27         "name": name,
28         "changes": {},
29         "result": True,
30         "comment": "Database {} is already present".format(database),
31     }
32     if client_flags is None:
33         client_flags = []
34     connection_args["client_flags"] = client_flags
35     if not isinstance(client_flags, list):
36         ret["comment"] = "Error: client_flags must be a list."
37         ret["result"] = False
38         return ret
39     if any(
40         [
41             query_file.startswith(proto)
42             for proto in ["http://", "https://", "salt://", "s3://", "swift://"]
43         ]
44     ):
45         query_file = __salt__["cp.cache_file"](query_file, saltenv=saltenv or __env__)
46     if not os.path.exists(query_file):
47         ret["comment"] = "File {} does not exist".format(query_file)
48         ret["result"] = False
49         return ret
50     if check_db_exists and not __salt__["mysql.db_exists"](database, **connection_args):
51         err = _get_mysql_error()
52         if err is not None:
53             ret["comment"] = err
54             ret["result"] = False
55             return ret
56         ret["result"] = None
57         ret["comment"] = "Database {} is not present".format(database)
58         return ret
59     if output == "grain":
60         if grain is not None and key is None:
61             if not overwrite and grain in __salt__["grains.ls"]():
62                 ret["comment"] = "No execution needed. Grain " + grain + " already set"
63                 return ret
64             elif __opts__["test"]:
65                 ret["result"] = None
66                 ret["comment"] = (
67                     "Query would execute, storing result in " + "grain: " + grain
68                 )
69                 return ret
70         elif grain is not None:
71             if grain in __salt__["grains.ls"]():
72                 grain_value = __salt__["grains.get"](grain)
73             else:
74                 grain_value = {}
75             if not overwrite and key in grain_value:
76                 ret["comment"] = (
77                     "No execution needed. Grain " + grain + ":" + key + " already set"
78                 )
79                 return ret
80             elif __opts__["test"]:
81                 ret["result"] = None
82                 ret["comment"] = (
83                     "Query would execute, storing result in "
84                     + "grain: "
85                     + grain
86                     + ":"
87                     + key
88                 )
89                 return ret
90         else:
91             ret["result"] = False
92             ret["comment"] = (
93                 "Error: output type 'grain' needs the grain " + "parameter\n"
94             )
95             return ret
96     elif output is not None:
97         if not overwrite and os.path.isfile(output):
98             ret["comment"] = "No execution needed. File " + output + " already set"
99             return ret
100         elif __opts__["test"]:
101             ret["result"] = None
102             ret["comment"] = (
103                 "Query would execute, storing result in " + "file: " + output
104             )
105             return ret
106     elif __opts__["test"]:
107         ret["result"] = None
108         ret["comment"] = "Query would execute, not storing result"
109         return ret
110     query_result = __salt__["mysql.file_query"](database, query_file, **connection_args)
111     if query_result is False:
112         ret["result"] = False
113         return ret
114     mapped_results = []
115     if "results" in query_result:
116         for res in query_result["results"]:
117             mapped_line = {}
118             for idx, col in enumerate(query_result["columns"]):
119                 mapped_line[col] = res[idx]
120             mapped_results.append(mapped_line)
121         query_result["results"] = mapped_results
122     ret["comment"] = str(query_result)
123     if output == "grain":
124         if grain is not None and key is None:
125             __salt__["grains.setval"](grain, query_result)
126             ret["changes"]["query"] = "Executed. Output into grain: " + grain
127         elif grain is not None:
128             if grain in __salt__["grains.ls"]():
129                 grain_value = __salt__["grains.get"](grain)
130             else:
131                 grain_value = {}
132             grain_value[key] = query_result
133             __salt__["grains.setval"](grain, grain_value)
134             ret["changes"]["query"] = (
135                 "Executed. Output into grain: " + grain + ":" + key
136             )
137     elif output is not None:
138         ret["changes"]["query"] = "Executed. Output into " + output
139         with salt.utils.files.fopen(output, "w") as output_file:
140             if "results" in query_result:
141                 for res in query_result["results"]:
142                     for col, val in res.items():
143                         output_file.write(
144                             salt.utils.stringutils.to_str(col + ":" + val + "\n")
145                         )
146                 output_file.write(salt.utils.stringutils.to_str(query_result))
147     else:
148         ret["changes"]<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["query"] = "Executed"
149     return ret
150 def run(
151     name,
152     database,
153     query,
154     output=None,
155     grain=None,
156     key=None,
157     overwrite=True,
158     check_db_exists=True,
159     client_flags=None,
160     **connection_args
161 ):
162     ret =</b></font> {
163         "name": name,
164         "changes": {},
165         "result": True,
166         "comment": "Database {} is already present".format(database),
167     }
168     if client_flags is None:
169         client_flags = []
170     connection_args["client_flags"] = client_flags
171     if not isinstance(client_flags, list):
172         ret["comment"] = "Error: client_flags must be a list."
173         ret["result"] = False
174         return ret
175     if check_db_exists and not __salt__["mysql.db_exists"](database, **connection_args):
176         err = _get_mysql_error()
177         if err is not None:
178             ret["comment"] = err
179             ret["result"] = False
180             return ret
181         ret["result"] = None
182         ret["comment"] = "Database {} is not present".format(name)
183         return ret
184     if output == "grain":
185         if grain is not None and key is None:
186             if not overwrite and grain in __salt__["grains.ls"]():
187                 ret["comment"] = "No execution needed. Grain " + grain + " already set"
188                 return ret
189             elif __opts__["test"]:
190                 ret["result"] = None
191                 ret["comment"] = (
192                     "Query would execute, storing result in " + "grain: " + grain
193                 )
194                 return ret
195         elif grain is not None:
196             if grain in __salt__["grains.ls"]():
197                 grain_value = __salt__["grains.get"](grain)
198             else:
199                 grain_value = {}
200             if not overwrite and key in grain_value:
201                 ret["comment"] = (
202                     "No execution needed. Grain " + grain + ":" + key + " already set"
203                 )
204                 return ret
205             elif __opts__["test"]:
206                 ret["result"] = None
207                 ret["comment"] = (
208                     "Query would execute, storing result in "
209                     + "grain: "
210                     + grain
211                     + ":"
212                     + key
213                 )
214                 return ret
215         else:
216             ret["result"] = False
217             ret["comment"] = (
218                 "Error: output type 'grain' needs the grain " + "parameter\n"
219             )
220             return ret
221     elif output is not None:
222         if not overwrite and os.path.isfile(output):
223             ret["comment"] = "No execution needed. File " + output + " already set"
224             return ret
225         elif __opts__["test"]:
226             ret["result"] = None
227             ret["comment"] = (
228                 "Query would execute, storing result in " + "file: " + output
229             )
230             return ret
231     elif __opts__["test"]:
232         ret["result"] = None
233         ret["comment"] = "Query would execute, not storing result"
234         return ret
235     query_result = __salt__["mysql.query"](database, query, **connection_args)
236     mapped_results = []
237     if "results" in query_result:
238         for res in query_result["results"]:
239             mapped_line = {}
240             for idx, col in enumerate(query_result["columns"]):
241                 mapped_line[col] = res[idx]
242             mapped_results.append(mapped_line)
243         query_result["results"] = mapped_results
244     ret["comment"] = str(query_result)
245     if output == "grain":
246         if grain is not None and key is None:
247             __salt__["grains.setval"](grain, query_result)
248             ret["changes"]["query"] = "Executed. Output into grain: " + grain
249         elif grain is not None:
250             if grain in __salt__["grains.ls"]():
251                 grain_value = __salt__["grains.get"](grain)
252             else:
253                 grain_value = {}
254             grain_value[key] = query_result
255             __salt__["grains.setval"](grain, grain_value)
256             ret["changes"]["query"] = (
257                 "Executed. Output into grain: " + grain + ":" + key
258             )
259     elif output is not None:
260         ret["changes"]["query"] = "Executed. Output into " + output
261         with salt.utils.files.fopen(output, "w") as output_file:
262             if "results" in query_result:
263                 for res in query_result["results"]:
264                     for col, val in res.items():
265                         output_file.write(
266                             salt.utils.stringutils.to_str(col + ":" + val + "\n")
267                         )
268             else:
269                 if isinstance(query_result, str):
270                     output_file.write(salt.utils.stringutils.to_str(query_result))
271                 else:
272                     for col, val in query_result.items():
273                         output_file.write(
274                             salt.utils.stringutils.to_str("{}:{}\n".format(col, val))
275                         )
276     else:
277         ret["changes"]["query"] = "Executed"
278     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pip_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import re
3 import sys
4 import types
5 import salt.utils.data
6 import salt.utils.versions
7 from salt.exceptions import CommandExecutionError, CommandNotFoundError
8 try:
9     import pkg_resources
10     HAS_PKG_RESOURCES = True
11 except ImportError:
12     HAS_PKG_RESOURCES = False
13 def purge_pip():
14     if "pip" not in sys.modules:
15         return
16     pip_related_entries = [
17         (k, v)
18         for (k, v) in sys.modules.items()
19         if getattr(v, "__module__", "").startswith("pip.")
20         or (isinstance(v, types.ModuleType) and v.__name__.startswith("pip."))
21     ]
22     for name, entry in pip_related_entries:
23         sys.modules.pop(name)
24         del entry
25     if "pip" in globals():
26         del globals()["pip"]
27     if "pip" in locals():
28         del locals()["pip"]
29     sys_modules_pip = sys.modules.pop("pip", None)
30     if sys_modules_pip is not None:
31         del sys_modules_pip
32 def pip_has_internal_exceptions_mod(ver):
33     return salt.utils.versions.compare(
34         ver1=ver,
35         oper="&gt;=",
36         ver2="10.0",
37     )
38 def pip_has_exceptions_mod(ver):
39     if pip_has_internal_exceptions_mod(ver):
40         return False
41     return salt.utils.versions.compare(ver1=ver, oper="&gt;=", ver2="1.0")
42 try:
43     import pip
44     HAS_PIP = True
45 except ImportError:
46     HAS_PIP = False
47     purge_pip()
48 if HAS_PIP is True:
49     if not hasattr(purge_pip, "__pip_ver__"):
50         purge_pip.__pip_ver__ = pip.__version__
51     elif purge_pip.__pip_ver__ != pip.__version__:
52         purge_pip()
53         import pip
54         purge_pip.__pip_ver__ = pip.__version__
55     if salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="10.0"):
56         from pip._internal.exceptions import (
57             InstallationError,
58         )  # pylint: disable=E0611,E0401
59     elif salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="1.0"):
60         from pip.exceptions import InstallationError  # pylint: disable=E0611,E0401
61     else:
62         InstallationError = ValueError
63 log = logging.getLogger(__name__)
64 __virtualname__ = "pip"
65 def _from_line(*args, **kwargs):
66     import pip
67     if salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="18.1"):
68         import pip._internal.req.constructors  # pylint: disable=E0611,E0401
69         return pip._internal.req.constructors.install_req_from_line(*args, **kwargs)
70     elif salt.utils.versions.compare(ver1=pip.__version__, oper="&gt;=", ver2="10.0"):
71         import pip._internal.req  # pylint: disable=E0611,E0401
72         return pip._internal.req.InstallRequirement.from_line(*args, **kwargs)
73     else:
74         import pip.req  # pylint: disable=E0611,E0401
75         return pip.req.InstallRequirement.from_line(*args, **kwargs)
76 def __virtual__():
77     if HAS_PKG_RESOURCES is False:
78         return False, "The pkg_resources python library is not installed"
79     if "pip.list" in __salt__:
80         return __virtualname__
81     return False
82 def _fulfills_version_spec(version, version_spec):
83     for oper, spec in version_spec:
84         if oper is None:
85             continue
86         if not salt.utils.versions.compare(
87             ver1=version, oper=oper, ver2=spec, cmp_func=_pep440_version_cmp
88         ):
89             return False
90     return True
91 def _check_pkg_version_format(pkg):
92     ret = {"result": False, "comment": None, "prefix": None, "version_spec": None}
93     if not HAS_PIP:
94         ret["comment"] = (
95             "An importable Python 2 pip module is required but could not be "
96             "found on your system. This usually means that the system's pip "
97             "package is not installed properly."
98         )
99         return ret
100     from_vcs = False
101     try:
102         try:
103             log.debug("Installed pip version: %s", pip.__version__)
104             install_req = _from_line(pkg)
105         except AttributeError:
106             log.debug("Installed pip version is lower than 1.2")
107             supported_vcs = ("git", "svn", "hg", "bzr")
108             if pkg.startswith(supported_vcs):
109                 for vcs in supported_vcs:
110                     if pkg.startswith(vcs):
111                         from_vcs = True
112                         install_req = _from_line(pkg.split("{}+".format(vcs))[-1])
113                         break
114             else:
115                 install_req = _from_line(pkg)
116     except (ValueError, InstallationError) as exc:
117         ret["result"] = False
118         if not from_vcs and "=" in pkg and "==" not in pkg:
119             ret["comment"] = (
120                 "Invalid version specification in package {}. '=' is "
121                 "not supported, use '==' instead.".format(pkg)
122             )
123             return ret
124         ret["comment"] = "pip raised an exception while parsing '{}': {}".format(
125             pkg, exc
126         )
127         return ret
128     if install_req.req is None:
129         ret["result"] = True
130         ret["prefix"] = ""
131         ret["version_spec"] = []
132     else:
133         ret["result"] = True
134         try:
135             ret["prefix"] = install_req.req.project_name
136             ret["version_spec"] = install_req.req.specs
137         except Exception:  # pylint: disable=broad-except
138             ret["prefix"] = re.sub("[^A-Za-z0-9.]+", "-", install_req.name)
139             if hasattr(install_req, "specifier"):
140                 specifier = install_req.specifier
141             else:
142                 specifier = install_req.req.specifier
143             ret["version_spec"] = [(spec.operator, spec.version) for spec in specifier]
144     return ret
145 def _check_if_installed(
146     prefix,
147     state_pkg_name,
148     version_spec,
149     ignore_installed,
150     force_reinstall,
151     upgrade,
152     user,
153     cwd,
154     bin_env,
155     env_vars,
156     index_url,
157     extra_index_url,
158     pip_list=False,
159     **kwargs
160 ):
161     ret = {"result": False, "comment": None}
162     pip_list = salt.utils.data.CaseInsensitiveDict(
163         pip_list
164         or __salt__["pip.list"](
165             prefix, bin_env=bin_env, user=user, cwd=cwd, env_vars=env_vars, **kwargs
166         )
167     )
168     if ignore_installed is False and prefix in pip_list:
169         if force_reinstall is False and not upgrade:
170             if (
171                 any(version_spec)
172                 and _fulfills_version_spec(pip_list[prefix], version_spec)
173             ) or (not any(version_spec)):
174                 ret["result"] = True
175                 ret["comment"] = "Python package {} was already installed".format(
176                     state_pkg_name
177                 )
178                 return ret
179         if force_reinstall is False and upgrade:
180             include_alpha = False
181             include_beta = False
182             include_rc = False
183             if any(version_spec):
184                 for spec in version_spec:
185                     if "a" in spec[1]:
186                         include_alpha = True
187                     if "b" in spec[1]:
188                         include_beta = True
189                     if "rc" in spec[1]:
190                         include_rc = True
191             available_versions = __salt__["pip.list_all_versions"](
192                 prefix,
193                 bin_env=bin_env,
194                 include_alpha=include_alpha,
195                 include_beta=include_beta,
196                 include_rc=include_rc,
197                 user=user,
198                 cwd=cwd,
199                 index_url=index_url,
200                 extra_index_url=extra_index_url,
201             )
202             desired_version = ""
203             if any(version_spec) and available_versions:
204                 for version in reversed(available_versions):
205                     if _fulfills_version_spec(version, version_spec):
206                         desired_version = version
207                         break
208             elif available_versions:
209                 desired_version = available_versions[-1]
210             if not desired_version:
211                 ret["result"] = True
212                 ret["comment"] = (
213                     "Python package {} was already "
214                     "installed and\nthe available upgrade "
215                     "doesn't fulfills the version "
216                     "requirements".format(prefix)
217                 )
218                 return ret
219             if _pep440_version_cmp(pip_list[prefix], desired_version) == 0:
220                 ret["result"] = True
221                 ret["comment"] = "Python package {} was already installed".format(
222                     state_pkg_name
223                 )
224                 return ret
225     return ret
226 def _pep440_version_cmp(pkg1, pkg2, ignore_epoch=False):
227     if HAS_PKG_RESOURCES is False:
228         log.warning(
229             "The pkg_resources packages was not loaded. Please install setuptools."
230         )
231         return None
232     normalize = lambda x: str(x).split("!", 1)[-1] if ignore_epoch else str(x)
233     pkg1 = normalize(pkg1)
234     pkg2 = normalize(pkg2)
235     try:
236         if pkg_resources.parse_version(pkg1) &lt; pkg_resources.parse_version(pkg2):
237             return -1
238         if pkg_resources.parse_version(pkg1) == pkg_resources.parse_version(pkg2):
239             return 0
240         if pkg_resources.parse_version(pkg1) &gt; pkg_resources.parse_version(pkg2):
241             return 1
242     except Exception as exc:  # pylint: disable=broad-except
243         log.exception(exc)
244     return None
245 def installed(
246     name,
247     pkgs=None,
248     pip_bin=None,
249     requirements=None,
250     bin_env=None,
251     use_wheel=False,
252     no_use_wheel=False,
253     log=None,
254     proxy=None,
255     timeout=None,
256     repo=None,
257     editable=None,
258     find_links=None,
259     index_url=None,
260     extra_index_url=None,
261     no_index=False,
262     mirrors=None,
263     build=None,
264     target=None,
265     download=None,
266     download_cache=None,
267     source=None,
268     upgrade=False,
269     force_reinstall=False,
270     ignore_installed=False,
271     exists_action=None,
272     no_deps=False,
273     no_install=False,
274     no_download=False,
275     install_options=None,
276     global_options=None,
277     user=None,
278     cwd=None,
279     pre_releases=False,
280     cert=None,
281     allow_all_external=False,
282     allow_external=None,
283     allow_unverified=None,
284     process_dependency_links=False,
285     env_vars=None,
286     use_vt=False,
287     trusted_host=None,
288     no_cache_dir=False,
289     cache_dir=None,
290     no_binary=None,
291     extra_args=None,
292     **kwargs
293 ):
294     if pip_bin and not bin_env:
295         bin_env = pip_bin
296     if pkgs:
297         if not isinstance(pkgs, list):
298             return {
299                 "name": name,
300                 "result": False,
301                 "changes": {},
302                 "comment": "pkgs argument must be formatted as a list",
303             }
304     else:
305         pkgs = [name]
306     prepro = (
307         lambda pkg: pkg
308         if isinstance(pkg, str)
309         else " ".join((pkg.items()[0][0], pkg.items()[0][1]))
310     )
311     pkgs = [prepro(pkg) for pkg in pkgs]
312     ret = {"name": ";".join(pkgs), "result": None, "comment": "", "changes": {}}
313     try:
314         cur_version = __salt__["pip.version"](bin_env)
315     except (CommandNotFoundError, CommandExecutionError) as err:
316         ret["result"] = False
317         ret["comment"] = "Error installing '{}': {}".format(name, err)
318         return ret
319     if use_wheel:
320         min_version = "1.4"
321         max_version = "9.0.3"
322         too_low = salt.utils.versions.compare(
323             ver1=cur_version, oper="&lt;", ver2=min_version
324         )
325         too_high = salt.utils.versions.compare(
326             ver1=cur_version, oper="&gt;", ver2=max_version
327         )
328         if too_low or too_high:
329             ret["result"] = False
330             ret["comment"] = (
331                 "The 'use_wheel' option is only supported in "
332                 "pip between {} and {}. The version of pip detected "
333                 "was {}.".format(min_version, max_version, cur_version)
334             )
335             return ret
336     if no_use_wheel:
337         min_version = "1.4"
338         max_version = "9.0.3"
339         too_low = salt.utils.versions.compare(
340             ver1=cur_version, oper="&lt;", ver2=min_version
341         )
342         too_high = salt.utils.versions.compare(
343             ver1=cur_version, oper="&gt;", ver2=max_version
344         )
345         if too_low or too_high:
346             ret["result"] = False
347             ret["comment"] = (
348                 "The 'no_use_wheel' option is only supported in "
349                 "pip between {} and {}. The version of pip detected "
350                 "was {}.".format(min_version, max_version, cur_version)
351             )
352             return ret
353     if no_binary:
354         min_version = "7.0.0"
355         too_low = salt.utils.versions.compare(
356             ver1=cur_version, oper="&lt;", ver2=min_version
357         )
358         if too_low:
359             ret["result"] = False
360             ret["comment"] = (
361                 "The 'no_binary' option is only supported in "
362                 "pip {} and newer. The version of pip detected "
363                 "was {}.".format(min_version, cur_version)
364             )
365             return ret
366     pkgs_details = []
367     if pkgs and not (requirements or editable):
368         comments = []
369         for pkg in iter(pkgs):
370             out = _check_pkg_version_format(pkg)
371             if out["result"] is False:
372                 ret["result"] = False
373                 comments.append(out["comment"])
374             elif out["result"] is True:
375                 pkgs_details.append((out["prefix"], pkg, out["version_spec"]))
376         if ret["result"] is False:
377             ret["comment"] = "\n".join(comments)
378             return ret
379     target_pkgs = []
380     already_installed_comments = []
381     if requirements or editable:
382         comments = []
383         if __opts__["test"]:
384             ret["result"] = None
385             if requirements:
386                 comments.append(
387                     "Requirements file '{}' will be processed.".format(requirements)
388                 )
389             if editable:
390                 comments.append(
391                     "Package will be installed in editable mode (i.e. "
392                     'setuptools "develop mode") from {}.'.format(editable)
393                 )
394             ret["comment"] = " ".join(comments)
395             return ret
396     else:
397         try:
398             pip_list = __salt__["pip.list"](bin_env=bin_env, user=user, cwd=cwd)
399         except Exception as exc:  # pylint: disable=broad-except
400             log.exception(exc)
401             pip_list = False
402         for prefix, state_pkg_name, version_spec in pkgs_details:
403             if prefix:
404                 out = _check_if_installed(
405                     prefix,
406                     state_pkg_name,
407                     version_spec,
408                     ignore_installed,
409                     force_reinstall,
410                     upgrade,
411                     user,
412                     cwd,
413                     bin_env,
414                     env_vars,
415                     index_url,
416                     extra_index_url,
417                     pip_list,
418                     **kwargs
419                 )
420                 if out["result"] is None:
421                     ret["result"] = False
422                     ret["comment"] = out["comment"]
423                     return ret
424             else:
425                 out = {"result": False, "comment": None}
426             result = out["result"]
427             if result is False:
428                 target_pkgs.append((prefix, state_pkg_name.replace(",", ";")))
429                 if __opts__["test"]:
430                     if len(pkgs_details) &gt; 1:
431                         msg = "Python package(s) set to be installed:"
432                         for pkg in pkgs_details:
433                             msg += "\n"
434                             msg += pkg[1]
435                             ret["comment"] = msg
436                     else:
437                         msg = "Python package {0} is set to be installed"
438                         ret["comment"] = msg.format(state_pkg_name)
439                     ret["result"] = None
440                     return ret
441             elif result is True:
442                 already_installed_comments.append(out["comment"])
443             elif result is None:
444                 ret["result"] = None
445                 ret["comment"] = out["comment"]
446                 return ret
447         if not target_pkgs:
448             ret["result"] = True
449             aicomms = "\n".join(already_installed_comments)
450             last_line = "All specified packages are already installed" + (
451                 " and up-to-date" if upgrade else ""
452             )
453             ret["comment"] = aicomms + ("\n" if aicomms else "") + last_line
454             return ret
455     pkgs_str = ",".join([state_name for _, state_name in target_pkgs])
456     pip_install_call = __salt__["pip.install"](
457         pkgs="{}".format(pkgs_str) if pkgs_str else "",
458         requirements=requirements,
459         bin_env=bin_env,
460         use_wheel=use_wheel,
461         no_use_wheel=no_use_wheel,
462         no_binary=no_binary,
463         log=log,
464         proxy=proxy,
465         timeout=timeout,
466         editable=editable,
467         find_links=find_links,
468         index_url=index_url,
469         extra_index_url=extra_index_url,
470         no_index=no_index,
471         mirrors=mirrors,
472         build=build,
473         target=target,
474         download=download,
475         download_cache=download_cache,
476         source=source,
477         upgrade=upgrade,
478         force_reinstall=force_reinstall,
479         ignore_installed=ignore_installed,
480         exists_action=exists_action,
481         no_deps=no_deps,
482         no_install=no_install,
483         no_download=no_download,
484         install_options=install_options,
485         global_options=global_options,
486         user=user,
487         cwd=cwd,
488         pre_releases=pre_releases,
489         cert=cert,
490         allow_all_external=allow_all_external,
491         allow_external=allow_external,
492         allow_unverified=allow_unverified,
493         process_dependency_links=process_dependency_links,
494         saltenv=__env__,
495         env_vars=env_vars,
496         use_vt=use_vt,
497         trusted_host=trusted_host,
498         no_cache_dir=no_cache_dir,
499         extra_args=extra_args,
500         disable_version_check=True,
501         **kwargs
502     )
503     if pip_install_call and pip_install_call.get("retcode", 1) == 0:
504         ret["result"] = True
505         if requirements or editable:
506             comments = []
507             if requirements:
508                 PIP_REQUIREMENTS_NOCHANGE = [
509                     "Requirement already satisfied",
510                     "Requirement already up-to-date",
511                     "Requirement not upgraded",
512                     "Collecting",
513                     "Cloning",
514                     "Cleaning up...",
515                     "Looking in indexes",
516                 ]
517                 for line in pip_install_call.get("stdout", "").split("\n"):
518                     if not any(
519                         [line.strip().startswith(x) for x in PIP_REQUIREMENTS_NOCHANGE]
520                     ):
521                         ret["changes"]["requirements"] = True
522                 if ret["changes"].get("requirements"):
523                     comments.append(
524                         "Successfully processed requirements file {}.".format(
525                             requirements
526                         )
527                     )
528                 else:
529                     comments.append("Requirements were already installed.")
530             if editable:
531                 comments.append(
532                     "Package successfully installed from VCS checkout {}.".format(
533                         editable
534                     )
535                 )
536                 ret["changes"]["editable"] = True
537             ret["comment"] = " ".join(comments)
538         else:
539             pkg_404_comms = []
540             already_installed_packages = set()
541             for line in pip_install_call.get("stdout", "").split("\n"):
542                 if line.startswith("Requirement already up-to-date: "):
543                     package = line.split(":", 1)[1].split()[0]
544                     already_installed_packages.add(package.lower())
545             for prefix, state_name in target_pkgs:
546                 if prefix:
547                     pipsearch = salt.utils.data.CaseInsensitiveDict(
548                         __salt__["pip.list"](
549                             prefix,
550                             bin_env,
551                             user=user,
552                             cwd=cwd,
553                             env_vars=env_vars,
554                             **kwargs
555                         )
556                     )
557                     if not pipsearch:
558                         pkg_404_comms.append(
559                             "There was no error installing package '{}' "
560                             "although it does not show when calling "
561                             "'pip.freeze'.".format(pkg)
562                         )
563                     else:
564                         if (
565                             prefix in pipsearch
566                             and prefix.lower() not in already_installed_packages
567                         ):
568                             ver = pipsearch[prefix]
569                             ret["changes"]["{}=={}".format(prefix, ver)] = "Installed"
570                 else:
571                     ret["changes"]["{}==???".format(state_name)] = "Installed"
572             aicomms = "\n".join(already_installed_comments)
573             succ_comm = (
574                 "All packages were successfully installed"
575                 if not pkg_404_comms
576                 else "\n".join(pkg_404_comms)
577             )
578             ret["comment"] = aicomms + ("\n" if aicomms else "") + succ_comm
579             return ret
580     elif pip_install_call:
581         ret["result"] = False
582         if "stdout" in pip_install_call:
583             error = "Error: {} {}".format(
584                 pip_install_call["stdout"], pip_install_call["stderr"]
585             )
586         else:
587             error = "Error: {}".format(pip_install_call["comment"])
588         if requirements or editable:
589             comments = []
590             if requirements:
591                 comments.append(
592                     'Unable to process requirements file "{}"'.format(requirements)
593                 )
594             if editable:
595                 comments.append(
596                     "Unable to install from VCS checkout {}.".format(editable)
597                 )
598             comments.append(error)
599             ret["comment"] = " ".join(comments)
600         else:
601             pkgs_str = ", ".join([state_name for _, state_name in target_pkgs])
602             aicomms = "\n".join(already_installed_comments)
603             error_comm = "Failed to install packages: {}. {}".format(pkgs_str, error)
604     else:
605         ret["result"] = False
606         ret<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["comment"] = "Could not install package"
607     return ret
608 def removed(
609     name,
610     requirements=None,
611     bin_env=None,
612     log=None,
613     proxy=None,
614     timeout=None,
615     user=None,
616     cwd=</b></font>None,
617     use_vt=False,
618 ):
619     ret = {"name": name, "result": None, "comment": "", "changes": {}}
620     try:
621         pip_list = __salt__["pip.list"](bin_env=bin_env, user=user, cwd=cwd)
622     except (CommandExecutionError, CommandNotFoundError) as err:
623         ret["result"] = False
624         ret["comment"] = "Error uninstalling '{}': {}".format(name, err)
625         return ret
626     if name not in pip_list:
627         ret["result"] = True
628         ret["comment"] = "Package is not installed."
629         return ret
630     if __opts__["test"]:
631         ret["result"] = None
632         ret["comment"] = "Package {} is set to be removed".format(name)
633         return ret
634     if __salt__["pip.uninstall"](
635         pkgs=name,
636         requirements=requirements,
637         bin_env=bin_env,
638         log=log,
639         proxy=proxy,
640         timeout=timeout,
641         user=user,
642         cwd=cwd,
643         use_vt=use_vt,
644     ):
645         ret["result"] = True
646         ret["changes"][name] = "Removed"
647         ret["comment"] = "Package was successfully removed."
648     else:
649         ret["result"] = False
650         ret["comment"] = "Could not remove package."
651     return ret
652 def uptodate(name, bin_env=None, user=None, cwd=None, use_vt=False):
653     ret = {"name": name, "changes": {}, "result": False, "comment": "Failed to update."}
654     try:
655         packages = __salt__["pip.list_upgrades"](bin_env=bin_env, user=user, cwd=cwd)
656     except Exception as e:  # pylint: disable=broad-except
657         ret["comment"] = str(e)
658         return ret
659     if not packages:
660         ret["comment"] = "System is already up-to-date."
661         ret["result"] = True
662         return ret
663     elif __opts__["test"]:
664         ret["comment"] = "System update will be performed"
665         ret["result"] = None
666         return ret
667     updated = __salt__["pip.upgrade"](
668         bin_env=bin_env, user=user, cwd=cwd, use_vt=use_vt
669     )
670     if updated.get("result") is False:
671         ret.update(updated)
672     elif updated:
673         ret["changes"] = updated
674         ret["comment"] = "Upgrade successful."
675         ret["result"] = True
676     else:
677         ret["comment"] = "Upgrade failed."
678     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
