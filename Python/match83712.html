<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for s3fs.py &amp; boto_secgroup.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for s3fs.py &amp; boto_secgroup.py
      </h3>
<h1 align="center">
        3.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>s3fs.py (4.6568627%)<th>boto_secgroup.py (3.442029%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(730-743)<td><a href="#" name="0">(960-970)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(424-436)<td><a href="#" name="1">(128-197)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(774-782)<td><a href="#" name="2">(301-311)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>s3fs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import logging
3 import os
4 import pickle
5 import time
6 import urllib.parse
7 import salt.fileserver as fs
8 import salt.modules
9 import salt.utils.files
10 import salt.utils.gzip_util
11 import salt.utils.hashutils
12 import salt.utils.versions
13 log = logging.getLogger(__name__)
14 S3_CACHE_EXPIRE = 30  # cache for 30 seconds
15 S3_SYNC_ON_UPDATE = True  # sync cache on update rather than jit
16 def envs():
17     metadata = _init()
18     return list(metadata.keys())
19 def update():
20     metadata = _init()
21     if S3_SYNC_ON_UPDATE:
22         log.info("Syncing local cache from S3...")
23         for saltenv, env_meta in metadata.items():
24             for bucket_files in _find_files(env_meta):
25                 for bucket, files in bucket_files.items():
26                     for file_path in files:
27                         cached_file_path = _get_cached_file_name(
28                             bucket, saltenv, file_path
29                         )
30                         log.info("%s - %s : %s", bucket, saltenv, file_path)
31                         _get_file_from_s3(
32                             metadata, saltenv, bucket, file_path, cached_file_path
33                         )
34         log.info("Sync local cache from S3 completed.")
35 def find_file(path, saltenv="base", **kwargs):
36     if "env" in kwargs:
37         kwargs.pop("env")
38     fnd = {"bucket": None, "path": None}
39     metadata = _init()
40     if not metadata or saltenv not in metadata:
41         return fnd
42     env_files = _find_files(metadata[saltenv])
43     if not _is_env_per_bucket():
44         path = os.path.join(saltenv, path)
45     for bucket in env_files:
46         for bucket_name, files in bucket.items():
47             if path in files and not fs.is_file_ignored(__opts__, path):
48                 fnd["bucket"] = bucket_name
49                 fnd["path"] = path
50                 break
51         else:
52             continue  # only executes if we didn't break
53         break
54     if not fnd["path"] or not fnd["bucket"]:
55         return fnd
56     cached_file_path = _get_cached_file_name(fnd["bucket"], saltenv, path)
57     _get_file_from_s3(metadata, saltenv, fnd["bucket"], path, cached_file_path)
58     return fnd
59 def file_hash(load, fnd):
60     if "env" in load:
61         load.pop("env")
62     ret = {}
63     if "saltenv" not in load:
64         return ret
65     if "path" not in fnd or "bucket" not in fnd or not fnd["path"]:
66         return ret
67     cached_file_path = _get_cached_file_name(
68         fnd["bucket"], load["saltenv"], fnd["path"]
69     )
70     if os.path.isfile(cached_file_path):
71         ret["hsum"] = salt.utils.hashutils.get_hash(cached_file_path)
72         ret["hash_type"] = "md5"
73     return ret
74 def serve_file(load, fnd):
75     if "env" in load:
76         load.pop("env")
77     ret = {"data": "", "dest": ""}
78     if "path" not in load or "loc" not in load or "saltenv" not in load:
79         return ret
80     if "path" not in fnd or "bucket" not in fnd:
81         return ret
82     gzip = load.get("gzip", None)
83     cached_file_path = _get_cached_file_name(
84         fnd["bucket"], load["saltenv"], fnd["path"]
85     )
86     ret["dest"] = _trim_env_off_path([fnd["path"]], load["saltenv"])[0]
87     with salt.utils.files.fopen(cached_file_path, "rb") as fp_:
88         fp_.seek(load["loc"])
89         data = fp_.read(__opts__["file_buffer_size"])
90         if data and not salt.utils.files.is_binary(cached_file_path):
91             data = data.decode(__salt_system_encoding__)
92         if gzip and data:
93             data = salt.utils.gzip_util.compress(data, gzip)
94             ret["gzip"] = gzip
95         ret["data"] = data
96     return ret
97 def file_list(load):
98     if "env" in load:
99         load.pop("env")
100     ret = []
101     if "saltenv" not in load:
102         return ret
103     saltenv = load["saltenv"]
104     metadata = _init()
105     if not metadata or saltenv not in metadata:
106         return ret
107     for bucket in _find_files(metadata[saltenv]):
108         for buckets in bucket.values():
109             files = [f for f in buckets if not fs.is_file_ignored(__opts__, f)]
110             ret += _trim_env_off_path(files, saltenv)
111     return ret
112 def file_list_emptydirs(load):
113     _init()
114     return []
115 def dir_list(load):
116     if "env" in load:
117         load.pop("env")
118     ret = []
119     if "saltenv" not in load:
120         return ret
121     saltenv = load["saltenv"]
122     metadata = _init()
123     if not metadata or saltenv not in metadata:
124         return ret
125     for bucket in _find_dirs(metadata[saltenv]):
126         for dirs in bucket.values():
127             dirs = _trim_env_off_path(dirs, saltenv, trim_slash=True)
128             ret += [_f for _f in dirs if _f]
129     return ret
130 def _get_s3_key():
131     key = __opts__["s3.key"] if "s3.key" in __opts__ else None
132     keyid = __opts__["s3.keyid"] if "s3.keyid" in __opts__ else None
133     service_url = __opts__["s3.service_url"] if "s3.service_url" in __opts__ else None
134     verify_ssl = __opts__["s3.verify_ssl"] if "s3.verify_ssl" in __opts__ else None
135     kms_keyid = __opts__["aws.kmw.keyid"] if "aws.kms.keyid" in __opts__ else None
136     location = __opts__["s3.location"] if "s3.location" in __opts__ else None
137     path_style = __opts__["s3.path_style"] if "s3.path_style" in __opts__ else None
138     https_enable = (
139         __opts__["s3.https_enable"] if "s3.https_enable" in __opts__ else None
140     )
141     return (
142         key,
143         keyid,
144         service_url,
145         verify_ssl,
146         kms_keyid,
147         location,
148         path_style,
149         https_enable,
150     )
151 def _init():
152     cache_file = _get_buckets_cache_filename()
153     exp = time.time() - S3_CACHE_EXPIRE
154     metadata = None
155     try:
156         if os.path.getmtime(cache_file) &gt; exp:
157             metadata = _read_buckets_cache_file(cache_file)
158     except OSError:
159         pass
160     if metadata is None:
161         metadata = _refresh_buckets_cache_file(cache_file)
162     return metadata
163 def _get_cache_dir():
164     return os.path.join(__opts__["cachedir"], "s3cache")
165 def _get_cached_file_name(bucket_name, saltenv, path):
166     file_path = os.path.join(_get_cache_dir(), saltenv, bucket_name, path)
167     if not os.path.exists(os.path.dirname(file_path)):
168         os.makedirs(os.path.dirname(file_path))
169     return file_path
170 def _get_buckets_cache_filename():
171     cache_dir = _get_cache_dir()
172     if not os.path.exists(cache_dir):
173         os.makedirs(cache_dir)
174     return os.path.join(cache_dir, "buckets_files.cache")
175 def _refresh_buckets_cache_file(cache_file):
176     log.debug("Refreshing buckets cache file")
177     (
178         key,
179         keyid,
180         service_url,
181         verify_ssl,
182         kms_keyid,
183         location,
184         path_style,
185         https_enable,
186     ) = _get_s3_key()
187     metadata = {}
188     def __get_s3_meta(bucket, key=key, keyid=keyid):
189         while True:
190             tmp = __utils__["s3.query"](
191                 key<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=key,
192                 keyid=keyid,
193                 kms_keyid=keyid,
194                 bucket=bucket,
195                 service_url=service_url,
196                 verify_ssl=verify_ssl,
197                 location=location,
198                 return_bin=False,
199                 path_style=path_style,
200                 https_enable=https_enable,
201                 params={"marker": marker},
202             )
203             headers =</b></font> []
204             for header in tmp:
205                 if "Key" in header:
206                     break
207                 headers.append(header)
208             ret.extend(tmp)
209             if all(
210                 [header.get("IsTruncated", "false") == "false" for header in headers]
211             ):
212                 break
213             marker = tmp[-1]["Key"]
214         return ret
215     if _is_env_per_bucket():
216         for saltenv, buckets in _get_buckets().items():
217             bucket_files_list = []
218             for bucket_name in buckets:
219                 bucket_files = {}
220                 s3_meta = __get_s3_meta(bucket_name)
221                 if not s3_meta:
222                     continue
223                 bucket_files[bucket_name] = [k for k in s3_meta if "Key" in k]
224                 bucket_files_list.append(bucket_files)
225                 if not bucket_files[bucket_name]:
226                     meta_response = {}
227                     for k in s3_meta:
228                         if "Code" in k or "Message" in k:
229                             meta_response.update(k)
230                     try:
231                         log.warning(
232                             "'%s' response for bucket '%s'",
233                             meta_response["Message"],
234                             bucket_name,
235                         )
236                         continue
237                     except KeyError:
238                         if "Code" in meta_response:
239                             log.warning(
240                                 "'%s' response for bucket '%s'",
241                                 meta_response["Code"],
242                                 bucket_name,
243                             )
244                             continue
245                         else:
246                             log.warning(
247                                 "S3 Error! Do you have any files in your S3 bucket?"
248                             )
249                             return {}
250             metadata[saltenv] = bucket_files_list
251     else:
252         for bucket_name in _get_buckets():
253             s3_meta = __get_s3_meta(bucket_name)
254             if not s3_meta:
255                 continue
256             files = [k for k in s3_meta if "Key" in k]
257             if not files:
258                 meta_response = {}
259                 for k in s3_meta:
260                     if "Code" in k or "Message" in k:
261                         meta_response.update(k)
262                 try:
263                     log.warning(
264                         "'%s' response for bucket '%s'",
265                         meta_response["Message"],
266                         bucket_name,
267                     )
268                     continue
269                 except KeyError:
270                     if "Code" in meta_response:
271                         log.warning(
272                             "'%s' response for bucket '%s'",
273                             meta_response["Code"],
274                             bucket_name,
275                         )
276                         continue
277                     else:
278                         log.warning(
279                             "S3 Error! Do you have any files in your S3 bucket?"
280                         )
281                         return {}
282             environments = [(os.path.dirname(k["Key"]).split("/", 1))[0] for k in files]
283             environments = set(environments)
284             for saltenv in environments:
285                 env_files = [k for k in files if k["Key"].startswith(saltenv)]
286                 if saltenv not in metadata:
287                     metadata[saltenv] = []
288                 found = False
289                 for bucket_files in metadata[saltenv]:
290                     if bucket_name in bucket_files:
291                         bucket_files[bucket_name] += env_files
292                         found = True
293                         break
294                 if not found:
295                     metadata[saltenv].append({bucket_name: env_files})
296     _write_buckets_cache_file(metadata, cache_file)
297     return metadata
298 def _write_buckets_cache_file(metadata, cache_file):
299     if os.path.isfile(cache_file):
300         os.remove(cache_file)
301     log.debug("Writing buckets cache file")
302     with salt.utils.files.fopen(cache_file, "wb") as fp_:
303         pickle.dump(metadata, fp_)
304 def _read_buckets_cache_file(cache_file):
305     log.debug("Reading buckets cache file")
306     with salt.utils.files.fopen(cache_file, "rb") as fp_:
307         try:
308             data = pickle.load(fp_)
309         except (
310             pickle.UnpicklingError,
311             AttributeError,
312             EOFError,
313             ImportError,
314             IndexError,
315             KeyError,
316             ValueError,
317         ) as exc:
318             log.debug("Exception reading buckets cache file: '%s'", exc)
319             data = None
320     return data
321 def _find_files(metadata):
322     ret = []
323     found = {}
324     for bucket_dict in metadata:
325         for bucket_name, data in bucket_dict.items():
326             filepaths = [k["Key"] for k in data]
327             filepaths = [k for k in filepaths if not k.endswith("/")]
328             if bucket_name not in found:
329                 found[bucket_name] = True
330                 ret.append({bucket_name: filepaths})
331             else:
332                 for bucket in ret:
333                     if bucket_name in bucket:
334                         bucket[bucket_name] += filepaths
335                         break
336     return ret
337 def _find_dirs(metadata):
338     ret = []
339     found = {}
340     for bucket_dict in metadata:
341         for bucket_name, data in bucket_dict.items():
342             dirpaths = set()
343             for path in [k["Key"] for k in data]:
344                 prefix = ""
345                 for part in path.split("/")[:-1]:
346                     directory = prefix + part + "/"
347                     dirpaths.add(directory)
348                     prefix = directory
349             if bucket_name not in found:
350                 found[bucket_name] = True
351                 ret.append({bucket_name: list(dirpaths)})
352             else:
353                 for bucket in ret:
354                     if bucket_name in bucket:
355                         bucket[bucket_name] += list(dirpaths)
356                         bucket[bucket_name] = list(set(bucket[bucket_name]))
357                         break
358     return ret
359 def _find_file_meta(metadata, bucket_name, saltenv, path):
360     env_meta = metadata[saltenv] if saltenv in metadata else {}
361     bucket_meta = {}
362     for bucket in env_meta:
363         if bucket_name in bucket:
364             bucket_meta = bucket[bucket_name]
365     files_meta = list(list(filter((lambda k: "Key" in k), bucket_meta)))
366     for item_meta in files_meta:
367         if "Key" in item_meta and item_meta["Key"] == path:
368             try:
369                 item_meta["ETag"] = item_meta["ETag"].strip('"')
370             except KeyError:
371                 pass
372             return item_meta
373 def _get_buckets():
374     return __opts__["s3.buckets"] if "s3.buckets" in __opts__ else {}
375 def _get_file_from_s3(metadata, saltenv, bucket_name, path, cached_file_path):
376     (
377         key,
378         keyid,
379         service_url,
380         verify_ssl,
381         kms_keyid,
382         location,
383         path_style,
384         https_enable,
385     ) = _get_s3_key()
386     if os.path.isfile(cached_file_path):
387         file_meta = _find_file_meta(metadata, bucket_name, saltenv, path)
388         if file_meta:
389             file_etag = file_meta["ETag"]
390             if file_etag.find("-") == -1:
391                 file_md5 = file_etag
392                 cached_md5 = salt.utils.hashutils.get_hash(cached_file_path, "md5")
393                 if cached_md5 == file_md5:
394                     return
395             else:
396                 cached_file_stat = os.stat(cached_file_path)
397                 cached_file_size = cached_file_stat.st_size
398                 cached_file_mtime = datetime.datetime.fromtimestamp(
399                     cached_file_stat.st_mtime
400                 )
401                 cached_file_lastmod = datetime.datetime.strptime(
402                     file_meta["LastModified"], "%Y-%m-%dT%H:%M:%S.%fZ"
403                 )
404                 if (
405                     and cached_file_mtime &gt; cached_file_lastmod
406                 ):
407                     log<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.debug(
408                         "cached file size equal to metadata size and "
409                         "cached file mtime later than metadata last "
410                         "modification time."
411                     )
412                     ret = __utils__["s3.query"](
413                         key=key,
414                         keyid=keyid,
415                         kms_keyid=keyid,
416                         method="HEAD",
417                         bucket=bucket_name,
418                         service_url=service_url,
419                         verify_ssl=verify_ssl,
420                         location=</b></font>location,
421                         path=urllib.parse.quote(path),
422                         local_file=cached_file_path,
423                         full_headers=True,
424                         path_style=path_style,
425                         https_enable=https_enable,
426                     )
427                     if ret is not None:
428                         for header_name, header_value in ret["headers"].items():
429                             name = header_name.strip()
430                             value = header_value.strip()
431                             if str(name).lower() == "last-modified":
432                                 s3_file_mtime = datetime.datetime.strptime(
433                                     value, "%a, %d %b %Y %H:%M:%S %Z"
434                                 )
435                             elif str(name).lower() == "content-length":
436                                 s3_file_size = int(value)
437                         if (
438                             cached_file_size == s3_file_size
439                             and cached_file_mtime &gt; s3_file_mtime
440                         ):
441                             log.info(
442                                 "%s - %s : %s skipped download since cached file size "
443                                 "equal to and mtime after s3 values",
444                                 bucket_name,
445                                 saltenv,
446                                 path,
447                             )
448     __utils__<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["s3.query"](
449         key=key,
450         keyid=keyid,
451         kms_keyid=keyid,
452         bucket=bucket_name,
453         service_url=service_url,
454         verify_ssl=verify_ssl,
455         location=location,
456         path=urllib.parse.</b></font>quote(path),
457         local_file=cached_file_path,
458         path_style=path_style,
459         https_enable=https_enable,
460     )
461 def _trim_env_off_path(paths, saltenv, trim_slash=False):
462     env_len = None if _is_env_per_bucket() else len(saltenv) + 1
463     slash_len = -1 if trim_slash else None
464     return [d[env_len:slash_len] for d in paths]
465 def _is_env_per_bucket():
466     buckets = _get_buckets()
467     if isinstance(buckets, dict):
468         return True
469     elif isinstance(buckets, list):
470         return False
471     else:
472         raise ValueError("Incorrect s3.buckets type given in config")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_secgroup.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import pprint
3 import salt.utils.dictupdate as dictupdate
4 from salt.exceptions import SaltInvocationError
5 log = logging.getLogger(__name__)
6 def __virtual__():
7     if "boto_secgroup.exists" in __salt__:
8         return "boto_secgroup"
9     return (False, "boto_secgroup module could not be loaded")
10 def present(
11     description,
12     vpc_id=None,
13     vpc_name<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None,
14     rules=None,
15     rules_egress=None,
16     delete_ingress_rules=True,
17     delete_egress_rules=True,
18     region=None,
19     key=None,
20     keyid=None,
21     profile=None,
22     tags=None,
23 ):
24     ret = {"name": name, "result": True, "comment": "", "changes": {}}
25     _ret =</b></font> _security_group_present(
26         name,
27         description,
28         vpc_id=vpc_id,
29         vpc_name=vpc_name,
30         region=region,
31         key=key,
32         keyid=keyid,
33         profile=profile,
34     )
35     ret["changes"] = _ret["changes"]
36     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
37     if not _ret["result"]:
38         ret["result"] = _ret["result"]
39         if ret["result"] is False:
40             return ret
41         elif ret["result"] is None:
42             return ret
43     if rules is not None:
44         _ret = _rules_present(
45             name,
46             rules,
47             delete_ingress_rules,
48             vpc_id=vpc_id,
49             vpc_name=vpc_name,
50             region=region,
51             key=key,
52             keyid=keyid,
53             profile=profile,
54         )
55         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
56         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
57         if not _ret["result"]:
58             ret["result"] = _ret["result"]
59     if rules_egress is not None:
60         _ret = _rules_egress_present(
61             name,
62             rules_egress,
63             delete_egress_rules,
64             vpc_id=vpc_id,
65             vpc_name=vpc_name,
66             region=region,
67             key=key,
68             keyid=keyid,
69             profile=profile,
70         )
71         ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
72         ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
73         if not _ret["result"]:
74             ret["result"] = _ret["result"]
75     _ret = _tags_present(
76         name=name,
77         tags=tags,
78         vpc_id=vpc_id,
79         vpc_name=vpc_name,
80         region=region,
81         key=key,
82         keyid=keyid,
83         profile=profile,
84     )
85     ret["changes"] = dictupdate.update(ret["changes"], _ret["changes"])
86     ret["comment"] = " ".join([ret["comment"], _ret["comment"]])
87     if not _ret["result"]:
88         ret["result"] = _ret["result"]
89     return ret
90 def _security_group_present(
91     name,
92     description,
93     vpc_id=None,
94     vpc_name=None,
95     region=None,
96     key=None,
97     keyid=None,
98     profile=None,
99 ):
100     ret = {"result": True, "comment": "", "changes": {}}
101     exists = __salt__["boto_secgroup.exists"](
102         name, region, key, keyid, profile, vpc_id, vpc_name
103     )
104     if not exists:
105         if __opts__["test"]:
106             ret["comment"] = "Security group {} is set to be created.".format(name)
107             ret["result"] = None
108             return ret
109         created = __salt__["boto_secgroup.create"](
110             name=name,
111             description=description,
112             vpc_id=vpc_id,
113             vpc_name=vpc_name,
114             region=region,
115             key=key,
116             keyid=keyid,
117             profile=profile,
118         if created:
119             ret["changes"]["old"] = {"secgroup": None}
120             sg = __salt__<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["boto_secgroup.get_config"](
121                 name=name,
122                 group_id=None,
123                 region=region,
124                 key=key,
125                 keyid=keyid,
126                 profile=profile,
127                 vpc_id=vpc_id,
128                 vpc_name=vpc_name,
129             )
130             ret["changes"][</b></font>"new"] = {"secgroup": sg}
131             ret["comment"] = "Security group {} created.".format(name)
132         else:
133             ret["result"] = False
134             ret["comment"] = "Failed to create {} security group.".format(name)
135     else:
136         ret["comment"] = "Security group {} present.".format(name)
137     return ret
138 def _split_rules(rules):
139     split = []
140     for rule in rules:
141         cidr_ip = rule.get("cidr_ip")
142         group_name = rule.get("source_group_name")
143         group_id = rule.get("source_group_group_id")
144         if cidr_ip and not isinstance(cidr_ip, str):
145             for ip in cidr_ip:
146                 _rule = rule.copy()
147                 _rule["cidr_ip"] = ip
148                 split.append(_rule)
149         elif group_name and not isinstance(group_name, str):
150             for name in group_name:
151                 _rule = rule.copy()
152                 _rule["source_group_name"] = name
153                 split.append(_rule)
154         elif group_id and not isinstance(group_id, str):
155             for _id in group_id:
156                 _rule = rule.copy()
157                 _rule["source_group_group_id"] = _id
158                 split.append(_rule)
159         else:
160             split.append(rule)
161     return split
162 def _check_rule(rule, _rule):
163     if _rule.get("from_port") is None:
164         _rule["from_port"] = -1
165     if _rule.get("to_port") is None:
166         _rule["to_port"] = -1
167     if (
168         rule["ip_protocol"] == _rule["ip_protocol"]
169         and str(rule["from_port"]) == str(_rule["from_port"])
170         and str(rule["to_port"]) == str(_rule["to_port"])
171     ):
172         _cidr_ip = _rule.get("cidr_ip")
173         if _cidr_ip and _cidr_ip == rule.get("cidr_ip"):
174             return True
175         _owner_id = _rule.get("source_group_owner_id")
176         if _owner_id and _owner_id == rule.get("source_group_owner_id"):
177             return True
178         _group_id = _rule.get("source_group_group_id")
179         if _group_id and _group_id == rule.get("source_group_group_id"):
180             return True
181         _group_name = _rule.get("source_group_name")
182         if _group_name and _group_id == rule.get("source_group_name"):
183             return True
184     return False
185 def _get_rule_changes(rules, _rules):
186     to_delete = []
187     to_create = []
188     for rule in rules:
189         try:
190             ip_protocol = str(rule.get("ip_protocol"))
191         except KeyError:
192             raise SaltInvocationError(
193                 "ip_protocol, to_port, and from_port are"
194                 " required arguments for security group"
195                 " rules."
196             )
197         supported_protocols = [
198             "tcp",
199             "6",
200             6,
201             "udp",
202             "17",
203             17,
204             "icmp",
205             "1",
206             1,
207             "all",
208             "-1",
209             -1,
210         ]
211         if ip_protocol not in supported_protocols and (
212             not "{}".format(ip_protocol).isdigit() or int(ip_protocol) &gt; 255
213         ):
214             raise SaltInvocationError(
215                 "Invalid ip_protocol {} specified in security group rule.".format(
216                     ip_protocol
217                 )
218             )
219         if ip_protocol == "all":
220             rule["ip_protocol"] = "-1"
221         cidr_ip = rule.get("cidr_ip", None)
222         group_name = rule.get("source_group_name", None)
223         group_id = rule.get("source_group_group_id", None)
224         if cidr_ip and (group_id or group_name):
225             raise SaltInvocationError(
226                 "cidr_ip and source groups can not both"
227                 " be specified in security group rules."
228             )
229         if group_id and group_name:
230             raise SaltInvocationError(
231                 "Either source_group_group_id or"
232                 " source_group_name can be specified in"
233                 " security group rules, but not both."
234             )
235         if not (cidr_ip or group_id or group_name):
236             raise SaltInvocationError(
237                 "cidr_ip, source_group_group_id, or"
238                 " source_group_name must be provided for"
239                 " security group rules."
240             )
241         rule_found = False
242         for _rule in _rules:
243             if _check_rule(rule, _rule):
244                 rule_found = True
245                 break
246         if not rule_found:
247             to_create.append(rule)
248     for _rule in _rules:
249         rule_found = False
250         for rule in rules:
251             if _check_rule(rule, _rule):
252                 rule_found = True
253                 break
254         if not rule_found:
255             _rule.pop("source_group_name", None)
256             to_delete.append(_rule)
257     log.debug("Rules to be deleted: %s", to_delete)
258     log.debug("Rules to be created: %s", to_create)
259     return (to_delete, to_create)
260 def _rules_present(
261     name,
262     rules,
263     delete_ingress_rules=True,
264     vpc_id=None,
265     vpc_name=None,
266     region=None,
267     key=None,
268     keyid=None,
269     profile=None,
270 ):
271     ret = {"result": True, "comment": "", "changes": {}}
272     sg = __salt__["boto_secgroup.get_config"](
273         name=name,
274         group_id=None,
275         region=region,
276         key=key,
277         keyid=keyid,
278         profile=profile,
279         vpc_id=vpc_id,
280         vpc_name=vpc_name,
281     )
282     if not sg:
283         ret[
284             "comment"
285         ] = "{} security group configuration could not be retrieved.".format(name)
286         ret["result"] = False
287         return ret
288     rules = _split_rules(rules)
289     if vpc_id or vpc_name:
290         for rule in rules:
291             _source_group_name = rule.get("source_group_name", None)
292             if _source_group_name:
293                 _group_vpc_name = vpc_name
294                 _group_vpc_id = vpc_id
295                 _source_group_name_vpc = rule.get("source_group_name_vpc", None)
296                 if _source_group_name_vpc:
297                     _group_vpc_name = _source_group_name_vpc
298                     _group_vpc_id = None
299                 _group_id = __salt__["boto_secgroup.get_group_id"](
300                     name=_source_group_name,
301                     vpc_id=_group_vpc_id,
302                     vpc_name=_group_vpc_name,
303                     region=region,
304                     key=key,
305                     keyid=keyid,
306                     profile=profile,
307                 )
308                 if not _group_id:
309                     raise SaltInvocationError(
310                         "source_group_name {} does not map to a valid "
311                         "source group id.".format(_source_group_name)
312                     )
313                 rule["source_group_name"] = None
314                 if _source_group_name_vpc:
315                     rule.pop("source_group_name_vpc")
316                 rule["source_group_group_id"] = _group_id
317     to_delete, to_create = _get_rule_changes(rules, sg["rules"])
318     to_delete = to_delete if delete_ingress_rules else []
319     if to_create or to_delete:
320         if __opts__["test"]:
321             msg = """Security group {} set to have rules modified.
322             To be created: {}
323             To be deleted: {}""".format(
324                 name, pprint.pformat(to_create), pprint.pformat(to_delete)
325             )
326             ret["comment"] = msg
327             ret["result"] = None
328             return ret
329         if to_delete:
330             deleted = True
331             for rule in to_delete:
332                 _deleted = __salt__["boto_secgroup.revoke"](
333                     name,
334                     vpc_id=vpc_id,
335                     vpc_name=vpc_name,
336                     region=region,
337                     key=key,
338                     keyid=keyid,
339                     profile=profile,
340                     **rule
341                 )
342                 if not _deleted:
343                     deleted = False
344             if deleted:
345                 ret["comment"] = "Removed rules on {} security group.".format(name)
346             else:
347                 ret["comment"] = "Failed to remove rules on {} security group.".format(
348                     name
349                 )
350                 ret["result"] = False
351         if to_create:
352             created = True
353             for rule in to_create:
354                 _created = __salt__["boto_secgroup.authorize"](
355                     name,
356                     vpc_id=vpc_id,
357                     vpc_name=vpc_name,
358                     region=region,
359                     key=key,
360                     keyid=keyid,
361                     profile=profile,
362                     **rule
363                 )
364                 if not _created:
365                     created = False
366             if created:
367                 ret["comment"] = " ".join(
368                     [
369                         ret["comment"],
370                         "Created rules on {} security group.".format(name),
371                     ]
372                 )
373             else:
374                 ret["comment"] = " ".join(
375                     [
376                         ret["comment"],
377                         "Failed to create rules on {} security group.".format(name),
378                     ]
379                 )
380                 ret["result"] = False
381         ret["changes"]["old"] = {"rules": sg["rules"]}
382         sg = __salt__["boto_secgroup.get_config"](
383             name=name,
384             group_id=None,
385             region=region,
386             key=key,
387             keyid=keyid,
388             profile=profile,
389             vpc_id=vpc_id,
390             vpc_name=vpc_name,
391         )
392         ret["changes"]["new"] = {"rules": sg["rules"]}
393     return ret
394 def _rules_egress_present(
395     name,
396     rules_egress,
397     delete_egress_rules=True,
398     vpc_id=None,
399     vpc_name=None,
400     region=None,
401     key=None,
402     keyid=None,
403     profile=None,
404 ):
405     ret = {"result": True, "comment": "", "changes": {}}
406     sg = __salt__["boto_secgroup.get_config"](
407         name=name,
408         group_id=None,
409         region=region,
410         key=key,
411         keyid=keyid,
412         profile=profile,
413         vpc_id=vpc_id,
414         vpc_name=vpc_name,
415     )
416     if not sg:
417         ret[
418             "comment"
419         ] = "{} security group configuration could not be retrieved.".format(name)
420         ret["result"] = False
421         return ret
422     rules_egress = _split_rules(rules_egress)
423     if vpc_id or vpc_name:
424         for rule in rules_egress:
425             _source_group_name = rule.get("source_group_name", None)
426             if _source_group_name:
427                 _group_vpc_name = vpc_name
428                 _group_vpc_id = vpc_id
429                 _source_group_name_vpc = rule.get("source_group_name_vpc", None)
430                 if _source_group_name_vpc:
431                     _group_vpc_name = _source_group_name_vpc
432                     _group_vpc_id = None
433                 _group_id = __salt__["boto_secgroup.get_group_id"](
434                     name=_source_group_name,
435                     vpc_id=_group_vpc_id,
436                     vpc_name=_group_vpc_name,
437                     region=region,
438                     key=key,
439                     keyid=keyid,
440                     profile=profile,
441                 )
442                 if not _group_id:
443                     raise SaltInvocationError(
444                         "source_group_name {} does not map to a valid "
445                         "source group id.".format(_source_group_name)
446                     )
447                 rule["source_group_name"] = None
448                 if _source_group_name_vpc:
449                     rule.pop("source_group_name_vpc")
450                 rule["source_group_group_id"] = _group_id
451     to_delete, to_create = _get_rule_changes(rules_egress, sg["rules_egress"])
452     to_delete = to_delete if delete_egress_rules else []
453     if to_create or to_delete:
454         if __opts__["test"]:
455             msg = """Security group {} set to have rules modified.
456             To be created: {}
457             To be deleted: {}""".format(
458                 name, pprint.pformat(to_create), pprint.pformat(to_delete)
459             )
460             ret["comment"] = msg
461             ret["result"] = None
462             return ret
463         if to_delete:
464             deleted = True
465             for rule in to_delete:
466                 _deleted = __salt__["boto_secgroup.revoke"](
467                     name,
468                     vpc_id=vpc_id,
469                     vpc_name=vpc_name,
470                     region=region,
471                     key=key,
472                     keyid=keyid,
473                     profile=profile,
474                     egress=True,
475                     **rule
476                 )
477                 if not _deleted:
478                     deleted = False
479             if deleted:
480                 ret["comment"] = " ".join(
481                     [
482                         ret["comment"],
483                         "Removed egress rule on {} security group.".format(name),
484                     ]
485                 )
486             else:
487                 ret["comment"] = " ".join(
488                     [
489                         ret["comment"],
490                         "Failed to remove egress rule on {} security group.".format(
491                             name
492                         ),
493                     ]
494                 )
495                 ret["result"] = False
496         if to_create:
497             created = True
498             for rule in to_create:
499                 _created = __salt__["boto_secgroup.authorize"](
500                     name,
501                     vpc_id=vpc_id,
502                     vpc_name=vpc_name,
503                     region=region,
504                     key=key,
505                     keyid=keyid,
506                     profile=profile,
507                     egress=True,
508                     **rule
509                 )
510                 if not _created:
511                     created = False
512             if created:
513                 ret["comment"] = " ".join(
514                     [
515                         ret["comment"],
516                         "Created egress rules on {} security group.".format(name),
517                     ]
518                 )
519             else:
520                 ret["comment"] = " ".join(
521                     [
522                         ret["comment"],
523                         "Failed to create egress rules on {} security group.".format(
524                             name
525                         ),
526                     ]
527                 )
528                 ret["result"] = False
529         ret["changes"]["old"] = {"rules_egress": sg["rules_egress"]}
530         sg = __salt__["boto_secgroup.get_config"](
531             name=name,
532             group_id=None,
533             region=region,
534             key=key,
535             keyid=keyid,
536             profile=profile,
537             vpc_id=vpc_id,
538             vpc_name=vpc_name,
539         )
540         ret["changes"]["new"] = {"rules_egress": sg["rules_egress"]}
541     return ret
542 def absent(
543     name, vpc_id=None, vpc_name=None, region=None, key=None, keyid=None, profile=None
544 ):
545     ret = {"name": name, "result": True, "comment": "", "changes": {}}
546     sg = __salt__["boto_secgroup.get_config"](
547         name=name,
548         group_id=None,
549         region=region,
550         key=key,
551         keyid=keyid,
552         profile=profile,
553         vpc_id=vpc_id,
554         vpc_name=vpc_name,
555     )
556     if sg:
557         if __opts__["test"]:
558             ret["comment"] = "Security group {} is set to be removed.".format(name)
559             ret["result"] = None
560             return ret
561         deleted = __salt__["boto_secgroup.delete"](
562             name=name,
563             group_id=None,
564             region=region,
565             key=key,
566             keyid=keyid,
567             profile=profile,
568             vpc_id=vpc_id,
569             vpc_name=vpc_name,
570         )
571         if deleted:
572             ret["changes"]["old"] = {"secgroup": sg}
573             ret["changes"]["new"] = {"secgroup": None}
574             ret["comment"] = "Security group {} deleted.".format(name)
575         else:
576             ret["result"] = False
577             ret["comment"] = "Failed to delete {} security group.".format(name)
578     else:
579         ret["comment"] = "{} security group does not exist.".format(name)
580     return ret
581 def _tags_present(
582     name,
583     tags,
584     vpc_id=None,
585     vpc_name=None,
586     region=None,
587     key=None,
588     keyid=None,
589     profile=None,
590 ):
591     ret = {"result": True, "comment": "", "changes": {}}
592     if tags:
593         sg = __salt__["boto_secgroup.get_config"](
594             name=name,
595             group_id=None,
596             region=region,
597             key=key,
598             keyid=keyid,
599             profile=profile,
600             vpc_id=vpc_id,
601             vpc_name=vpc_name,
602         )
603         if not sg:
604             ret[
605                 "comment"
606             ] = "{} security group configuration could not be retrieved.".format(name)
607             ret["result"] = False
608             return ret
609         tags_to_add = tags
610         tags_to_update = {}
611         tags_to_remove = []
612         if sg.get("tags"):
613             for existing_tag in sg["tags"]:
614                 if existing_tag not in tags:
615                     if existing_tag not in tags_to_remove:
616                         tags_to_remove.append(existing_tag)
617                 else:
618                     if tags[existing_tag] != sg["tags"][existing_tag]:
619                         tags_to_update[existing_tag] = tags[existing_tag]
620                     tags_to_add.pop(existing_tag)
621         if tags_to_remove:
622             if __opts__["test"]:
623                 msg = "The following tag{} set to be removed: {}.".format(
624                     ("s are" if len(tags_to_remove) &gt; 1 else " is"),
625                     ", ".join(tags_to_remove),
626                 )
627                 ret["comment"] = " ".join([ret["comment"], msg])
628                 ret["result"] = None
629             else:
630                 temp_ret = __salt__["boto_secgroup.delete_tags"](
631                     tags_to_remove,
632                     name=name,
633                     group_id=None,
634                     vpc_name=vpc_name,
635                     vpc_id=vpc_id,
636                     region=region,
637                     key=key,
638                     keyid=keyid,
639                     profile=profile,
640                 )
641                 if not temp_ret:
642                     ret["result"] = False
643                     ret["comment"] = " ".join(
644                         [
645                             ret["comment"],
646                             "Error attempting to delete tags {}.".format(
647                                 tags_to_remove
648                             ),
649                         ]
650                     )
651                     return ret
652                 if "old" not in ret["changes"]:
653                     ret["changes"] = dictupdate.update(
654                         ret["changes"], {"old": {"tags": {}}}
655                     )
656                 for rem_tag in tags_to_remove:
657                     ret["changes"]["old"]["tags"][rem_tag] = sg["tags"][rem_tag]
658         if tags_to_add or tags_to_update:
659             if __opts__["test"]:
660                 if tags_to_add:
661                     msg = "The following tag{} set to be added: {}.".format(
662                         ("s are" if len(tags_to_add.keys()) &gt; 1 else " is"),
663                         ", ".join(tags_to_add.keys()),
664                     )
665                     ret["comment"] = " ".join([ret["comment"], msg])
666                     ret["result"] = None
667                 if tags_to_update:
668                     msg = "The following tag {} set to be updated: {}.".format(
669                         (
670                             "values are"
671                             if len(tags_to_update.keys()) &gt; 1
672                             else "value is"
673                         ),
674                         ", ".join(tags_to_update.keys()),
675                     )
676                     ret["result"] = None
677             else:
678                 all_tag_changes = dictupdate<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.update(tags_to_add, tags_to_update)
679                 temp_ret = __salt__["boto_secgroup.set_tags"](
680                     all_tag_changes,
681                     name=name,
682                     group_id=None,
683                     vpc_name=vpc_name,
684                     vpc_id=vpc_id,
685                     region=region,
686                     key=key,
687                     keyid=keyid,
688                     profile=</b></font>profile,
689                 )
690                 if not temp_ret:
691                     ret["result"] = False
692                     msg = "Error attempting to set tags."
693                     ret["comment"] = " ".join([ret["comment"], msg])
694                     return ret
695                 if "old" not in ret["changes"]:
696                     ret["changes"] = dictupdate.update(
697                         ret["changes"], {"old": {"tags": {}}}
698                     )
699                 if "new" not in ret["changes"]:
700                     ret["changes"] = dictupdate.update(
701                         ret["changes"], {"new": {"tags": {}}}
702                     )
703                 for tag in all_tag_changes:
704                     ret["changes"]["new"]["tags"][tag] = tags[tag]
705                     if "tags" in sg:
706                         if sg["tags"]:
707                             if tag in sg["tags"]:
708                                 ret["changes"]["old"]["tags"][tag] = sg["tags"][tag]
709         if not tags_to_update and not tags_to_remove and not tags_to_add:
710             ret["comment"] = " ".join([ret["comment"], "Tags are already set."])
711     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
