<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for capirca_acl.py & test_network_4.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for capirca_acl.py & test_network_4.py
      </h3>
      <h1 align="center">
        3.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>capirca_acl.py (4.506699%)<TH>test_network_4.py (2.5255973%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match106572-0.html#0',2,'match106572-1.html#0',3)" NAME="0">(375-385)<TD><A HREF="javascript:ZweiFrames('match106572-0.html#0',2,'match106572-1.html#0',3)" NAME="0">(209-214)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match106572-0.html#1',2,'match106572-1.html#1',3)" NAME="1">(628-874)<TD><A HREF="javascript:ZweiFrames('match106572-0.html#1',2,'match106572-1.html#1',3)" NAME="1">(15-129)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match106572-0.html#2',2,'match106572-1.html#2',3)" NAME="2">(354-359)<TD><A HREF="javascript:ZweiFrames('match106572-0.html#2',2,'match106572-1.html#2',3)" NAME="2">(202-206)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>capirca_acl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Capirca ACL
===========

Generate ACL (firewall) configuration for network devices.

.. versionadded:: 2017.7.0

:codeauthor: Mircea Ulinic &lt;ping@mirceaulinic.net&gt; &amp; Robert Ankeny &lt;robankeny@google.com&gt;
:maturity:   new
:depends:    capirca
:platform:   unix

Dependencies
------------

The firewall configuration is generated by Capirca_.

.. _Capirca: https://github.com/google/capirca

To install Capirca, execute: ``pip install capirca``.
&quot;&quot;&quot;

import datetime
import inspect
import logging
import re

import salt.utils.files

log = logging.getLogger(__file__)


try:
    import capirca
    import capirca.aclgen
    import capirca.lib.policy
    import capirca.lib.aclgenerator

    HAS_CAPIRCA = True
except ImportError:
    HAS_CAPIRCA = False


# ------------------------------------------------------------------------------
# module properties
# ------------------------------------------------------------------------------

__virtualname__ = &quot;capirca&quot;
__proxyenabled__ = [&quot;*&quot;]
# allow any proxy type

# ------------------------------------------------------------------------------
# property functions
# ------------------------------------------------------------------------------


def __virtual__():
    &quot;&quot;&quot;
    This module requires at least Capirca to work.
    &quot;&quot;&quot;
    if HAS_CAPIRCA:
        return __virtualname__
    else:
        return (False, &quot;The capirca module (capirca_acl) cannot be loaded.&quot;)


# ------------------------------------------------------------------------------
# module globals
# ------------------------------------------------------------------------------


# define the default values for all possible term fields
# we could also extract them from the `policy` module, inspecting the `Policy`
# class, but that might be overkill &amp; it would make the code less obvious.
# we can revisit this later if necessary.

_TERM_FIELDS = {
    &quot;action&quot;: [],
    &quot;address&quot;: [],
    &quot;address_exclude&quot;: [],
    &quot;comment&quot;: [],
    &quot;counter&quot;: None,
    &quot;expiration&quot;: None,
    &quot;destination_address&quot;: [],
    &quot;destination_address_exclude&quot;: [],
    &quot;destination_port&quot;: [],
    &quot;destination_prefix&quot;: [],
    &quot;forwarding_class&quot;: [],
    &quot;forwarding_class_except&quot;: [],
    &quot;logging&quot;: [],
    &quot;log_name&quot;: None,
    &quot;loss_priority&quot;: None,
    &quot;option&quot;: [],
    &quot;owner&quot;: None,
    &quot;policer&quot;: None,
    &quot;port&quot;: [],
    &quot;precedence&quot;: [],
    &quot;principals&quot;: [],
    &quot;protocol&quot;: [],
    &quot;protocol_except&quot;: [],
    &quot;qos&quot;: None,
    &quot;pan_application&quot;: [],
    &quot;routing_instance&quot;: None,
    &quot;source_address&quot;: [],
    &quot;source_address_exclude&quot;: [],
    &quot;source_port&quot;: [],
    &quot;source_prefix&quot;: [],
    &quot;verbatim&quot;: [],
    &quot;packet_length&quot;: None,
    &quot;fragment_offset&quot;: None,
    &quot;hop_limit&quot;: None,
    &quot;icmp_type&quot;: [],
    &quot;icmp_code&quot;: None,
    &quot;ether_type&quot;: [],
    &quot;traffic_class_count&quot;: None,
    &quot;traffic_type&quot;: [],
    &quot;translated&quot;: False,
    &quot;dscp_set&quot;: None,
    &quot;dscp_match&quot;: [],
    &quot;dscp_except&quot;: [],
    &quot;next_ip&quot;: None,
    &quot;flexible_match_range&quot;: [],
    &quot;source_prefix_except&quot;: [],
    &quot;destination_prefix_except&quot;: [],
    &quot;vpn&quot;: None,
    &quot;source_tag&quot;: [],
    &quot;destination_tag&quot;: [],
    &quot;source_interface&quot;: None,
    &quot;destination_interface&quot;: None,
    &quot;platform&quot;: [],
    &quot;platform_exclude&quot;: [],
    &quot;timeout&quot;: None,
    &quot;flattened&quot;: False,
    &quot;flattened_addr&quot;: None,
    &quot;flattened_saddr&quot;: None,
    &quot;flattened_daddr&quot;: None,
    &quot;priority&quot;: None,
    &quot;ttl&quot;: None,
}

# IP-type fields
# when it comes to IP fields, Capirca does not ingest raw text
# but they need to be converted to `nacaddr.IP`
# this pre-processing is done in `_clean_term_opts`
_IP_FILEDS = [
    &quot;source_address&quot;,
    &quot;source_address_exclude&quot;,
    &quot;destination_address&quot;,
    &quot;address&quot;,
    &quot;address_exclude&quot;,
    &quot;flattened_addr&quot;,
    &quot;flattened_saddr&quot;,
    &quot;flattened_daddr&quot;,
    &quot;next_ip&quot;,
]

_SERVICES = {}

# ------------------------------------------------------------------------------
# helper functions -- will not be exported
# ------------------------------------------------------------------------------


if HAS_CAPIRCA:
    _TempTerm = capirca.lib.policy.Term

    def _add_object(self, obj):
        return

    setattr(_TempTerm, &quot;AddObject&quot;, _add_object)
    dumy_term = _TempTerm(None)
    for item in dir(dumy_term):
        if hasattr(item, &quot;__func__&quot;) or item.startswith(&quot;_&quot;) or item != item.lower():
            continue
        _TERM_FIELDS[item] = getattr(dumy_term, item)

    class _Policy(capirca.lib.policy.Policy):
        &quot;&quot;&quot;
        Extending the Capirca Policy class to allow inserting custom filters.
        &quot;&quot;&quot;

        def __init__(self):
            self.filters = []
            self.filename = &quot;&quot;

    class _Term(capirca.lib.policy.Term):
        &quot;&quot;&quot;
        Extending the Capirca Term class to allow setting field valued on the fly.
        &quot;&quot;&quot;

        def __init__(self):
            for field, default in _TERM_FIELDS.items():
                setattr(self, field, default)


def _import_platform_generator(platform):
    &quot;&quot;&quot;
    Given a specific platform (under the Capirca conventions),
    return the generator class.
    The generator class is identified looking under the &lt;platform&gt; module
    for a class inheriting the `ACLGenerator` class.
    &quot;&quot;&quot;
    log.debug(&quot;Using platform: %s&quot;, platform)
    for mod_name, mod_obj in inspect.getmembers(capirca.aclgen):
        if mod_name == platform and inspect.ismodule(mod_obj):
            for plat_obj_name, plat_obj in inspect.getmembers(
                mod_obj
            ):  # pylint: disable=unused-variable
                if inspect.isclass(plat_obj) and issubclass(
                    plat_obj, capirca.lib.aclgenerator.ACLGenerator
                ):
                    log.debug(&quot;Identified Capirca class %s for %s&quot;, plat_obj, platform)
                    return plat_obj
    log.error(&quot;Unable to identify any Capirca plaform class for %s&quot;, platform)


def _get_services_mapping():
    &quot;&quot;&quot;
    Build a map of services based on the IANA assignment list:
    http://www.iana.org/assignments/port-numbers

    It will load the /etc/services file and will build the mapping on the fly,
    similar to the Capirca's SERVICES file:
    https://github.com/google/capirca/blob/master/def/SERVICES.svc

    As this module is be available on Unix systems only,
    we'll read the services from /etc/services.
    In the worst case, the user will not be able to specify the
    services shortcut and they will need to specify the protocol / port combination
    using the source_port / destination_port &amp; protocol fields.
    &quot;&quot;&quot;
    if _SERVICES:
        return _SERVICES
    services_txt = &quot;&quot;
    try:
        with salt.utils.files.fopen(&quot;/etc/services&quot;, &quot;r&quot;) as srv_f:
            services_txt = salt.utils.stringutils.to_unicode(srv_f.read())
    except OSError as ioe:
        log.error(&quot;Unable to read from /etc/services:&quot;)
        log.error(ioe)
        return _SERVICES  # no mapping possible, sorry
        # will return the default mapping
    service_rgx = re.compile(r&quot;^([a-zA-Z0-9-]+)\s+(\d+)\/(tcp|udp)(.*)$&quot;)
    for line in services_txt.splitlines():
        service_rgx_s = service_rgx.search(line)
        if service_rgx_s and len(service_rgx_s.groups()) == 4:
            srv_name, port, protocol, _ = service_rgx_s.groups()
            if srv_name not in _SERVICES:
                _SERVICES[srv_name] = {&quot;port&quot;: [], &quot;protocol&quot;: []}
            try:
                _SERVICES[srv_name][&quot;port&quot;].append(int(port))
            except ValueError as verr:
                log.error(verr)
                log.error(&quot;Did not read that properly:&quot;)
                log.error(line)
                log.error(
                    &quot;Please report the above error: %s does not seem a valid port&quot;
                    &quot; value!&quot;,
                    port,
                )
            _SERVICES[srv_name][&quot;protocol&quot;].append(protocol)
    return _SERVICES


def _translate_port(port):
    &quot;&quot;&quot;
    Look into services and return the port value using the
    service name as lookup value.
    &quot;&quot;&quot;
    services = _get_services_mapping()
    if port in services and services[port][&quot;port&quot;]:
        return services[port][&quot;port&quot;][0]
    return port


def _make_it_list(dict_, field_name, value):
    &quot;&quot;&quot;
    Return the object list.
    &quot;&quot;&quot;
    prev_value = []
    # firsly we'll collect the prev value
    if field_name in dict_:
        prev_value = dict_[field_name]
    if value is None:
        return prev_value
    elif isinstance(value, (tuple, list)):
        # other type of iterables
        if field_name in (&quot;source_port&quot;, &quot;destination_port&quot;):
            # port fields are more special
            # they can either be a list of integers, either a list of tuples
            # list of integers = a list of ports
            # list of tuples = a list of ranges,
            # e.g.: [(1000, 2000), (3000, 4000)] means the 1000-2000 and 3000-4000 ranges
            portval = []
            for port in value:
                if not isinstance(port, (tuple, list)):
                    # to make sure everything is consistent,
                    # we'll transform indivitual ports into tuples
                    # thus an individual port e.g. 1000 will be transormed into the port range 1000-1000
                    # which is the equivalent
                    # but assures consistency for the Capirca parser
                    portval.append((port, port))
                else:
                    portval.append(port)
            translated_portval = []
            # and the ports sent as string, e.g. ntp instead of 123
            # needs to be translated
            # again, using the same /etc/services
            for port_start, port_end in portval:
                if not isinstance(port_start, int):
                    port_start = _translate_port(port_start)
                if not isinstance(port_end, int):
                    port_end = _translate_port(port_end)
                translated_portval.append((port_start, port_end))
            return list(set(prev_value + translated_portval))
        return list(set(prev_value + list(value)))
    if field_name in (&quot;source_port&quot;, &quot;destination_port&quot;):
        if not isinstance(value, int):
            value = _translate_port(value)
        return list(set(prev_value + [(value, value)]))  # a list of tuples
    # anything else will be enclosed in a list-type
    return list(set(prev_value + [value]))


def _clean_term_opts(term_opts):
    &quot;&quot;&quot;
    Cleanup the term opts:

    - strip Null and empty valuee, defaulting their value to their base definition from _TERM_FIELDS
    - convert to `nacaddr.IP` fields from `_IP_FILEDS`
    - create lists for those fields requiring it
    &quot;&quot;&quot;
    clean_opts = {}
    _services = _get_services_mapping()
    for field, value in term_opts.items():
        # firstly we'll process special fields like source_service or destination_services
        # which will inject values directly in the source or destination port and protocol
        if field == &quot;source_service&quot; and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug(&quot;Processing special source services:&quot;)
            log.debug(value)
            for service in value:
                if service and service in _services:
                    # if valid source_service
                    # take the port and protocol values from the global and inject in the term config
                    clean_opts[&quot;source_port&quot;] = _make_it_list(
                        clean_opts, &quot;source_port&quot;, _services[service][&quot;port&quot;]
                    )
<A NAME="2"></A>                    clean_opts[&quot;protocol&quot;] = _make_it_list(
                        clean_opts, &quot;protocol&quot;, _services[service][&quot;protocol&quot;]
                    )
            log<FONT color="#980517"><A HREF="javascript:ZweiFrames('match106572-1.html#2',3,'match106572-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.debug(
                &quot;Built source_port field, after processing special source services:&quot;
            )
            log.debug(clean_opts.get(&quot;source_port&quot;))
            log.debug(&quot;Built protocol field, after processing special source services:&quot;)
            log.debug(clean_opts.get(</B></FONT>&quot;protocol&quot;))
        elif field == &quot;destination_service&quot; and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug(&quot;Processing special destination services:&quot;)
            log.debug(value)
            for service in value:
                if service and service in _services:
                    # if valid destination_service
                    # take the port and protocol values from the global and inject in the term config
                    clean_opts[&quot;destination_port&quot;] = _make_it_list(
                        clean_opts, &quot;destination_port&quot;, _services[service][&quot;port&quot;]
                    )
<A NAME="0"></A>                    clean_opts[&quot;protocol&quot;] = _make_it_list(
                        clean_opts, &quot;protocol&quot;, _services[service][&quot;protocol&quot;]
                    )
            log<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match106572-1.html#0',3,'match106572-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.debug(
                &quot;Built source_port field, after processing special destination&quot;
                &quot; services:&quot;
            )
            log.debug(clean_opts.get(&quot;destination_service&quot;))
            log.debug(
                &quot;Built protocol field, after processing special destination services:&quot;
            )
            log.debug(clean_opts.get(&quot;protocol&quot;))
        # not a special field, but it has to be a valid one
        elif field in _TERM_FIELDS and value and value != _TERM_FIELDS[</B></FONT>field]:
            # if not a special field type
            if isinstance(_TERM_FIELDS[field], list):
                value = _make_it_list(clean_opts, field, value)
            if field in _IP_FILEDS:
                # IP-type fields need to be transformed
                ip_values = []
                for addr in value:
                    ip_values.append(capirca.lib.policy.nacaddr.IP(addr))
                value = ip_values[:]
            clean_opts[field] = value
    return clean_opts


def _lookup_element(lst, key):
    &quot;&quot;&quot;
    Find an dictionary in a list of dictionaries, given its main key.
    &quot;&quot;&quot;
    if not lst:
        return {}
    for ele in lst:
        if not ele or not isinstance(ele, dict):
            continue
        if key in ele:
            return ele[key]
    return {}


def _get_pillar_cfg(pillar_key, pillarenv=None, saltenv=None):
    &quot;&quot;&quot;
    Retrieve the pillar data from the right environment.
    &quot;&quot;&quot;
    pillar_cfg = __salt__[&quot;pillar.get&quot;](
        pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    return pillar_cfg


def _cleanup(lst):
    &quot;&quot;&quot;
    Return a list of non-empty dictionaries.
    &quot;&quot;&quot;
    clean = []
    for ele in lst:
        if ele and isinstance(ele, dict):
            clean.append(ele)
    return clean


def _merge_list_of_dict(first, second, prepend=True):
    &quot;&quot;&quot;
    Merge lists of dictionaries.
    Each element of the list is a dictionary having one single key.
    That key is then used as unique lookup.
    The first element list has higher priority than the second.
    When there's an overlap between the two lists,
    it won't change the position, but the content.
    &quot;&quot;&quot;
    first = _cleanup(first)
    second = _cleanup(second)
    if not first and not second:
        return []
    if not first and second:
        return second
    if first and not second:
        return first
    # Determine overlaps
    # So we don't change the position of the existing terms/filters
    overlaps = []
    merged = []
    appended = []
    for ele in first:
        if _lookup_element(second, next(iter(ele))):
            overlaps.append(ele)
        elif prepend:
            merged.append(ele)
        elif not prepend:
            appended.append(ele)
    for ele in second:
        ele_key = next(iter(ele))
        if _lookup_element(overlaps, ele_key):
            # If there's an overlap, get the value from the first
            # But inserted into the right position
            ele_val_first = _lookup_element(first, ele_key)
            merged.append({ele_key: ele_val_first})
        else:
            merged.append(ele)
    if not prepend:
        merged.extend(appended)
    return merged


def _get_term_object(
    filter_name,
    term_name,
    pillar_key=&quot;acl&quot;,
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    **term_fields
):
    &quot;&quot;&quot;
    Return an instance of the ``_Term`` class given the term options.
    &quot;&quot;&quot;
    log.debug(&quot;Generating config for term %s under filter %s&quot;, term_name, filter_name)
    term = _Term()
    term.name = term_name
    term_opts = {}
    if merge_pillar:
        term_opts = get_term_pillar(
            filter_name,
            term_name,
            pillar_key=pillar_key,
            saltenv=saltenv,
            pillarenv=pillarenv,
        )
        log.debug(&quot;Merging with pillar data:&quot;)
        log.debug(term_opts)
        term_opts = _clean_term_opts(term_opts)
        log.debug(&quot;Cleaning up pillar data:&quot;)
        log.debug(term_opts)
    log.debug(&quot;Received processing opts:&quot;)
    log.debug(term_fields)
    log.debug(&quot;Cleaning up processing opts:&quot;)
    term_fields = _clean_term_opts(term_fields)
    log.debug(term_fields)
    log.debug(&quot;Final term opts:&quot;)
    term_opts.update(term_fields)
    log.debug(term_fields)
    for field, value in term_opts.items():
        # setting the field attributes to the term instance of _Term
        setattr(term, field, value)
    log.debug(&quot;Term config:&quot;)
    log.debug(str(term))
    return term


def _get_policy_object(
    platform,
    filters=None,
    pillar_key=&quot;acl&quot;,
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
):
    &quot;&quot;&quot;
    Return an instance of the ``_Policy`` class given the filters config.
    &quot;&quot;&quot;
    policy = _Policy()
    policy_filters = []
    if not filters:
        filters = []
    for filter_ in filters:
        if not filter_ or not isinstance(filter_, dict):
            continue  # go to the next filter
        filter_name, filter_config = next(iter(filter_.items()))
        header = capirca.lib.policy.Header()  # same header everywhere
        target_opts = [platform, filter_name]
        filter_options = filter_config.pop(&quot;options&quot;, None)
        if filter_options:
            filter_options = _make_it_list({}, filter_name, filter_options)
            # make sure the filter options are sent as list
            target_opts.extend(filter_options)
        target = capirca.lib.policy.Target(target_opts)
        header.AddObject(target)
        filter_terms = []
        for term_ in filter_config.get(&quot;terms&quot;, []):
            if term_ and isinstance(term_, dict):
                term_name, term_fields = next(iter(term_.items()))
                term = _get_term_object(
                    filter_name,
                    term_name,
                    pillar_key=pillar_key,
                    pillarenv=pillarenv,
                    saltenv=saltenv,
                    merge_pillar=merge_pillar,
                    **term_fields
                )
            filter_terms.append(term)
        policy_filters.append((header, filter_terms))
    policy.filters = policy_filters
    log.debug(&quot;Policy config:&quot;)
    log.debug(str(policy))
    platform_generator = _import_platform_generator(platform)
    policy_config = platform_generator(policy, 2)
    log.debug(&quot;Generating policy config for %s:&quot;, platform)
    log.debug(str(policy_config))
    return policy_config


def _revision_tag(
    text,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format=&quot;%Y/%m/%d&quot;,
):
    &quot;&quot;&quot;
    Refactor revision tag comments.
    Capirca generates the filter text having the following tag keys:

    - $Id:$
    - $Revision:$
    - $Date:$

    This function goes through all the config lines and replaces
    those tags with the content requested by the user.
    If a certain value is not provided, the corresponding tag will be stripped.
    &quot;&quot;&quot;
    timestamp = datetime.datetime.now().strftime(revision_date_format)
    new_text = []
    for line in text.splitlines():
        if &quot;$Id:$&quot; in line:
            if not revision_id:  # if no explicit revision ID required
                continue  # jump to next line, ignore this one
            line = line.replace(&quot;$Id:$&quot;, &quot;$Id: {rev_id} $&quot;.format(rev_id=revision_id))
        if &quot;$Revision:$&quot; in line:
            if not revision_no:  # if no explicit revision number required
                continue  # jump to next line, ignore this one
            line = line.replace(
                &quot;$Revision:$&quot;, &quot;$Revision: {rev_no} $&quot;.format(rev_no=revision_no)
            )
        if &quot;$Date:$&quot; in line:
            if not revision_date:
                continue  # jump
            line = line.replace(&quot;$Date:$&quot;, &quot;$Date: {ts} $&quot;.format(ts=timestamp))
        new_text.append(line)
    return &quot;\n&quot;.join(new_text)


# ------------------------------------------------------------------------------
# callable functions
# ------------------------------------------------------------------------------


def get_term_config(
    platform,
    filter_name,
    term_name,
    filter_options=None,
<A NAME="1"></A>    pillar_key=&quot;acl&quot;,
    pillarenv=None,
    saltenv=None,
    merge_pillar<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match106572-1.html#1',3,'match106572-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=True,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format=&quot;%Y/%m/%d&quot;,
    source_service=None,
    destination_service=None,
    **term_fields
):
    &quot;&quot;&quot;
    Return the configuration of a single policy term.

    platform
        The name of the Capirca platform.

    filter_name
        The name of the policy filter.

    term_name
        The name of the term.

    filter_options
        Additional filter options. These options are platform-specific.
        E.g.: ``inet6``, ``bridge``, ``object-group``,
        See the complete list of options_.

        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section

    pillar_key: ``acl``
        The key in the pillar containing the default attributes values. Default: ``acl``.
        If the pillar contains the following structure:

        .. code-block:: yaml

            firewall:
              - my-filter:
                  terms:
                    - my-term:
                        source_port: 1234
                        source_address:
                            - 1.2.3.4/32
                            - 5.6.7.8/32

        The ``pillar_key`` field would be specified as ``firewall``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

    merge_pillar: ``True``
        Merge the CLI variables with the pillar. Default: ``True``.

    revision_id
        Add a comment in the term config having the description for the changes applied.

    revision_no
        The revision count.

    revision_date: ``True``
        Boolean flag: display the date when the term configuration was generated. Default: ``True``.

    revision_date_format: ``%Y/%m/%d``
        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (&lt;year&gt;/&lt;month&gt;/&lt;day&gt;).

    source_service
        A special service to choose from. This is a helper so the user is able to
        select a source just using the name, instead of specifying a source_port and protocol.

        As this module is available on Unix platforms only,
        it reads the IANA_ port assignment from ``/etc/services``.

        If the user requires additional shortcuts to be referenced, they can add entries under ``/etc/services``,
        which can be managed using the :mod:`file state &lt;salt.states.file&gt;`.

        .. _IANA: http://www.iana.org/assignments/port-numbers

    destination_service
        A special service to choose from. This is a helper so the user is able to
        select a source just using the name, instead of specifying a destination_port and protocol.
        Allows the same options as ``source_service``.

    term_fields
        Term attributes.
        To see what fields are supported, please consult the list of supported keywords_.
        Some platforms have few other optional_ keywords.

        .. _keywords: https://github.com/google/capirca/wiki/Policy-format#keywords
        .. _optional: https://github.com/google/capirca/wiki/Policy-format#optionally-supported-keywords

    .. note::
        The following fields are accepted:

        - action
        - address
        - address_exclude
        - comment
        - counter
        - expiration
        - destination_address
        - destination_address_exclude
        - destination_port
        - destination_prefix
        - forwarding_class
        - forwarding_class_except
        - logging
        - log_name
        - loss_priority
        - option
        - policer
        - port
        - precedence
        - principals
        - protocol
        - protocol_except
        - qos
        - pan_application
        - routing_instance
        - source_address
        - source_address_exclude
        - source_port
        - source_prefix
        - verbatim
        - packet_length
        - fragment_offset
        - hop_limit
        - icmp_type
        - ether_type
        - traffic_class_count
        - traffic_type
        - translated
        - dscp_set
        - dscp_match
        - dscp_except
        - next_ip
        - flexible_match_range
        - source_prefix_except
        - destination_prefix_except
        - vpn
        - source_tag
        - destination_tag
        - source_interface
        - destination_interface
        - flattened
        - flattened_addr
        - flattened_saddr
        - flattened_daddr
        - priority

    .. note::
        The following fields can be also a single value and a list of values:

        - action
        - address
        - address_exclude
        - comment
        - destination_address
        - destination_address_exclude
        - destination_port
        - destination_prefix
        - forwarding_class
        - forwarding_class_except
        - logging
        - option
        - port
        - precedence
        - principals
        - protocol
        - protocol_except
        - pan_application
        - source_address
        - source_address_exclude
        - source_port
        - source_prefix
        - verbatim
        - icmp_type
        - ether_type
        - traffic_type
        - dscp_match
        - dscp_except
        - flexible_match_range
        - source_prefix_except
        - destination_prefix_except
        - source_tag
        - destination_tag
        - source_service
        - destination_service

        Example: ``destination_address`` can be either defined as:

        .. code-block:: yaml

            destination_address: 172.17.17.1/24

        or as a list of destination IP addresses:

        .. code-block:: yaml

            destination_address:
                - 172.17.17.1/24
                - 172.17.19.1/24

        or a list of services to be matched:

        .. code-block:: yaml

            source_service:
                - ntp
                - snmp
                - ldap
                - bgpd

    .. note::
        The port fields ``source_port`` and ``destination_port`` can be used as above to select either
        a single value, either a list of values, but also they can select port ranges. Example:

        .. code-block:: yaml

            source_port:
                - [1000, 2000]
                - [3000, 4000]

        With the configuration above, the user is able to select the 1000-2000 and 3000-4000 source port ranges.

    CLI Example:

    .. code-block:: bash

        salt '*' capirca.get_term_config arista filter-name term-name source_address=1.2.3.4 destination_address=5.6.7.8 action=accept

    Output Example:

    .. code-block:: text

        ! $Date: 2017/03/22 $
        no ip access-list filter-name
        ip access-list filter-name
         remark term-name
         permit ip host 1.2.3.4 host 5.6.7.8
        exit
    &quot;&quot;&quot;
    terms = []
    term = {term_name: {}}
    term[term_name].</B></FONT>update(term_fields)
    term[term_name].update(
        {
            &quot;source_service&quot;: _make_it_list({}, &quot;source_service&quot;, source_service),
            &quot;destination_service&quot;: _make_it_list(
                {}, &quot;destination_service&quot;, destination_service
            ),
        }
    )
    terms.append(term)
    if not filter_options:
        filter_options = []
    return get_filter_config(
        platform,
        filter_name,
        filter_options=filter_options,
        terms=terms,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )


def get_filter_config(
    platform,
    filter_name,
    filter_options=None,
    terms=None,
    prepend=True,
    pillar_key=&quot;acl&quot;,
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format=&quot;%Y/%m/%d&quot;,
):
    &quot;&quot;&quot;
    Return the configuration of a policy filter.

    platform
        The name of the Capirca platform.

    filter_name
        The name of the policy filter.

    filter_options
        Additional filter options. These options are platform-specific.
        See the complete list of options_.

        .. _options: https://github.com/google/capirca/wiki/Policy-format#header-section

    terms
        List of terms for this policy filter.
        If not specified or empty, will try to load the configuration from the pillar,
        unless ``merge_pillar`` is set as ``False``.

    prepend: ``True``
        When ``merge_pillar`` is set as ``True``, the final list of terms generated by merging
        the terms from ``terms`` with those defined in the pillar (if any): new terms are prepended
        at the beginning, while existing ones will preserve the position. To add the new terms
        at the end of the list, set this argument to ``False``.

    pillar_key: ``acl``
        The key in the pillar containing the default attributes values. Default: ``acl``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

    merge_pillar: ``True``
        Merge the CLI variables with the pillar. Default: ``True``.

    only_lower_merge: ``False``
        Specify if it should merge only the terms fields. Otherwise it will try
        to merge also filters fields. Default: ``False``.

    revision_id
        Add a comment in the filter config having the description for the changes applied.

    revision_no
        The revision count.

    revision_date: ``True``
        Boolean flag: display the date when the filter configuration was generated. Default: ``True``.

    revision_date_format: ``%Y/%m/%d``
        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (&lt;year&gt;/&lt;month&gt;/&lt;day&gt;).

    CLI Example:

    .. code-block:: bash

        salt '*' capirca.get_filter_config ciscoxr my-filter pillar_key=netacl

    Output Example:

    .. code-block:: text

        ! $Id:$
        ! $Date:$
        ! $Revision:$
        no ipv4 access-list my-filter
        ipv4 access-list my-filter
         remark $Id:$
         remark my-term
         deny ipv4 any eq 1234 any
         deny ipv4 any eq 1235 any
         remark my-other-term
         permit tcp any range 5678 5680 any
        exit

    The filter configuration has been loaded from the pillar, having the following structure:

    .. code-block:: yaml

        netacl:
          - my-filter:
              terms:
                - my-term:
                    source_port: [1234, 1235]
                    action: reject
                - my-other-term:
                    source_port:
                      - [5678, 5680]
                    protocol: tcp
                    action: accept
    &quot;&quot;&quot;
    if not filter_options:
        filter_options = []
    if not terms:
        terms = []
    if merge_pillar and not only_lower_merge:
        acl_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        filter_pillar_cfg = _lookup_element(acl_pillar_cfg, filter_name)
        filter_options = filter_options or filter_pillar_cfg.pop(&quot;options&quot;, None)
        if filter_pillar_cfg:
            # Only when it was able to find the filter in the ACL config
            pillar_terms = filter_pillar_cfg.get(
                &quot;terms&quot;, []
            )  # No problem if empty in the pillar
            terms = _merge_list_of_dict(terms, pillar_terms, prepend=prepend)
            # merge the passed variable with the pillar data
            # any filter term not defined here, will be appended from the pillar
            # new terms won't be removed
    filters = []
    filters.append(
        {
            filter_name: {
                &quot;options&quot;: _make_it_list({}, filter_name, filter_options),
                &quot;terms&quot;: terms,
            }
        }
    )
    return get_policy_config(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )


def get_policy_config(
    platform,
    filters=None,
    prepend=True,
    pillar_key=&quot;acl&quot;,
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format=&quot;%Y/%m/%d&quot;,
):
    &quot;&quot;&quot;
    Return the configuration of the whole policy.

    platform
        The name of the Capirca platform.

    filters
        List of filters for this policy.
        If not specified or empty, will try to load the configuration from the pillar,
        unless ``merge_pillar`` is set as ``False``.

    prepend: ``True``
        When ``merge_pillar`` is set as ``True``, the final list of filters generated by merging
        the filters from ``filters`` with those defined in the pillar (if any): new filters are prepended
        at the beginning, while existing ones will preserve the position. To add the new filters
        at the end of the list, set this argument to ``False``.

    pillar_key: ``acl``
        The key in the pillar containing the default attributes values. Default: ``acl``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.

    merge_pillar: ``True``
        Merge the CLI variables with the pillar. Default: ``True``.

    only_lower_merge: ``False``
        Specify if it should merge only the filters and terms fields. Otherwise it will try
        to merge everything at the policy level. Default: ``False``.

    revision_id
        Add a comment in the policy config having the description for the changes applied.

    revision_no
        The revision count.

    revision_date: ``True``
        Boolean flag: display the date when the policy configuration was generated. Default: ``True``.

    revision_date_format: ``%Y/%m/%d``
        The date format to be used when generating the perforce data. Default: ``%Y/%m/%d`` (&lt;year&gt;/&lt;month&gt;/&lt;day&gt;).

    CLI Example:

    .. code-block:: bash

        salt '*' capirca.get_policy_config juniper pillar_key=netacl

    Output Example:

    .. code-block:: text

        firewall {
            family inet {
                replace:
                /*
                ** $Id:$
                ** $Date:$
                ** $Revision:$
                **
                */
                filter my-filter {
                    term my-term {
                        from {
                            source-port [ 1234 1235 ];
                        }
                        then {
                            reject;
                        }
                    }
                    term my-other-term {
                        from {
                            protocol tcp;
                            source-port 5678-5680;
                        }
                        then accept;
                    }
                }
            }
        }
        firewall {
            family inet {
                replace:
                /*
                ** $Id:$
                ** $Date:$
                ** $Revision:$
                **
                */
                filter my-other-filter {
                    interface-specific;
                    term dummy-term {
                        from {
                            protocol [ tcp udp ];
                        }
                        then {
                            reject;
                        }
                    }
                }
            }
        }

    The policy configuration has been loaded from the pillar, having the following structure:

    .. code-block:: yaml

        netacl:
          - my-filter:
              options:
                - not-interface-specific
              terms:
                - my-term:
                    source_port: [1234, 1235]
                    action: reject
                - my-other-term:
                    source_port:
                      - [5678, 5680]
                    protocol: tcp
                    action: accept
          - my-other-filter:
              terms:
                - dummy-term:
                    protocol:
                      - tcp
                      - udp
                    action: reject
    &quot;&quot;&quot;
    if not filters:
        filters = []
    if merge_pillar and not only_lower_merge:
        # the pillar key for the policy config is the `pillar_key` itself
        policy_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        # now, let's merge everything witht the pillar data
        # again, this will not remove any extra filters/terms
        # but it will merge with the pillar data
        # if this behaviour is not wanted, the user can set `merge_pillar` as `False`
        filters = _merge_list_of_dict(filters, policy_pillar_cfg, prepend=prepend)
    policy_object = _get_policy_object(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
    )
    policy_text = str(policy_object)
    return _revision_tag(
        policy_text,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )


def get_filter_pillar(filter_name, pillar_key=&quot;acl&quot;, pillarenv=None, saltenv=None):
    &quot;&quot;&quot;
    Helper that can be used inside a state SLS,
    in order to get the filter configuration given its name.

    filter_name
        The name of the filter.

    pillar_key
        The root key of the whole policy config.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.
    &quot;&quot;&quot;
    pillar_cfg = _get_pillar_cfg(pillar_key, pillarenv=pillarenv, saltenv=saltenv)
    return _lookup_element(pillar_cfg, filter_name)


def get_term_pillar(
    filter_name, term_name, pillar_key=&quot;acl&quot;, pillarenv=None, saltenv=None
):
    &quot;&quot;&quot;
    Helper that can be used inside a state SLS,
    in order to get the term configuration given its name,
    under a certain filter uniquely identified by its name.

    filter_name
        The name of the filter.

    term_name
        The name of the term.

    pillar_key: ``acl``
        The root key of the whole policy config. Default: ``acl``.

    pillarenv
        Query the master to generate fresh pillar data on the fly,
        specifically from the requested pillar environment.

    saltenv
        Included only for compatibility with
        :conf_minion:`pillarenv_from_saltenv`, and is otherwise ignored.
    &quot;&quot;&quot;
    filter_pillar_cfg = get_filter_pillar(
        filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    term_pillar_cfg = filter_pillar_cfg.get(&quot;terms&quot;, [])
    term_opts = _lookup_element(term_pillar_cfg, term_name)
    return term_opts
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_network_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import logging
import socket
import textwrap
import time

import pytest
import salt.exceptions
import salt.utils.network as network
from salt._compat import ipaddress
from tests.support.mock import MagicMock, create_autospec, mock_open, patch
from tests.support.unit import TestCase
<A NAME="1"></A>
log = logging.getLogger(__name__)

LINUX <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match106572-0.html#1',2,'match106572-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;&quot;&quot;\
eth0      Link encap:Ethernet  HWaddr e0:3f:49:85:6a:af
          inet addr:10.10.10.56  Bcast:10.10.10.255  Mask:255.255.252.0
          inet6 addr: fe80::e23f:49ff:fe85:6aaf/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:643363 errors:0 dropped:0 overruns:0 frame:0
          TX packets:196539 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:386388355 (368.4 MiB)  TX bytes:25600939 (24.4 MiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:548901 errors:0 dropped:0 overruns:0 frame:0
          TX packets:548901 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:613479895 (585.0 MiB)  TX bytes:613479895 (585.0 MiB)
&quot;&quot;&quot;

FREEBSD = &quot;&quot;&quot;
em0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=4219b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4,WOL_MAGIC,VLAN_HWTSO&gt;
        ether 00:30:48:ff:ff:ff
        inet 10.10.10.250 netmask 0xffffffe0 broadcast 10.10.10.255
        inet 10.10.10.56 netmask 0xffffffc0 broadcast 10.10.10.63
        media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
        status: active
em1: flags=8c02&lt;BROADCAST,OACTIVE,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=4219b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4,WOL_MAGIC,VLAN_HWTSO&gt;
        ether 00:30:48:aa:aa:aa
        media: Ethernet autoselect
        status: no carrier
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        options=3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x8
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=3&lt;PERFORMNUD,ACCEPT_RTADV&gt;
tun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; metric 0 mtu 1500
        options=80000&lt;LINKSTATE&gt;
        inet 10.12.0.1 --&gt; 10.12.0.2 netmask 0xffffffff
        Opened by PID 1964
&quot;&quot;&quot;

SOLARIS = &quot;&quot;&quot;\
lo0: flags=2001000849&lt;UP,LOOPBACK,RUNNING,MULTICAST,IPv4,VIRTUAL&gt; mtu 8232 index 1
        inet 127.0.0.1 netmask ff000000
net0: flags=100001100943&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST,ROUTER,IPv4,PHYSRUNNING&gt; mtu 1500 index 2
        inet 10.10.10.38 netmask ffffffe0 broadcast 10.10.10.63
ilbint0: flags=110001100843&lt;UP,BROADCAST,RUNNING,MULTICAST,ROUTER,IPv4,VRRP,PHYSRUNNING&gt; mtu 1500 index 3
        inet 10.6.0.11 netmask ffffff00 broadcast 10.6.0.255
ilbext0: flags=110001100843&lt;UP,BROADCAST,RUNNING,MULTICAST,ROUTER,IPv4,VRRP,PHYSRUNNING&gt; mtu 1500 index 4
        inet 10.10.11.11 netmask ffffffe0 broadcast 10.10.11.31
ilbext0:1: flags=110001100843&lt;UP,BROADCAST,RUNNING,MULTICAST,ROUTER,IPv4,VRRP,PHYSRUNNING&gt; mtu 1500 index 4
        inet 10.10.11.12 netmask ffffffe0 broadcast 10.10.11.31
vpn0: flags=1000011008d1&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST,ROUTER,IPv4,PHYSRUNNING&gt; mtu 1480 index 5
        inet tunnel src 10.10.11.12 tunnel dst 10.10.5.5
        tunnel hop limit 64
        inet 10.6.0.14 --&gt; 10.6.0.15 netmask ff000000
lo0: flags=2002000849&lt;UP,LOOPBACK,RUNNING,MULTICAST,IPv6,VIRTUAL&gt; mtu 8252 index 1
        inet6 ::1/128
net0: flags=120002004941&lt;UP,RUNNING,PROMISC,MULTICAST,DHCP,IPv6,PHYSRUNNING&gt; mtu 1500 index 2
        inet6 fe80::221:9bff:fefd:2a22/10
ilbint0: flags=120002000840&lt;RUNNING,MULTICAST,IPv6,PHYSRUNNING&gt; mtu 1500 index 3
        inet6 ::/0
ilbext0: flags=120002000840&lt;RUNNING,MULTICAST,IPv6,PHYSRUNNING&gt; mtu 1500 index 4
        inet6 ::/0
vpn0: flags=120002200850&lt;POINTOPOINT,RUNNING,MULTICAST,NONUD,IPv6,PHYSRUNNING&gt; mtu 1480 index 5
        inet tunnel src 10.10.11.12 tunnel dst 10.10.5.5
        tunnel hop limit 64
        inet6 ::/0 --&gt; fe80::b2d6:7c10
&quot;&quot;&quot;

NETBSD = &quot;&quot;&quot;\
vioif0: flags=0x8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
        ec_capabilities=1&lt;VLAN_MTU&gt;
        ec_enabled=0
        address: 00:a0:98:e6:83:18
        inet 192.168.1.80/24 broadcast 192.168.1.255 flags 0x0
        inet6 fe80::2a0:98ff:fee6:8318%vioif0/64 flags 0x0 scopeid 0x1
lo0: flags=0x8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33624
        inet 127.0.0.1/8 flags 0x0
        inet6 ::1/128 flags 0x20&lt;NODAD&gt;
        inet6 fe80::1%lo0/64 flags 0x0 scopeid 0x2
&quot;&quot;&quot;

FREEBSD_SOCKSTAT = &quot;&quot;&quot;\
USER    COMMAND     PID     FD  PROTO  LOCAL ADDRESS    FOREIGN ADDRESS
root    python2.7   1294    41  tcp4   127.0.0.1:61115  127.0.0.1:4506
&quot;&quot;&quot;

FREEBSD_SOCKSTAT_WITH_FAT_PID = &quot;&quot;&quot;\
USER     COMMAND    PID   FD PROTO  LOCAL ADDRESS    FOREIGN ADDRESS
salt-master python2.781106 35 tcp4  127.0.0.1:61115  127.0.0.1:4506
&quot;&quot;&quot;

NETLINK_SS = &quot;&quot;&quot;
State      Recv-Q Send-Q               Local Address:Port                 Peer Address:Port
ESTAB      0      0                    127.0.0.1:56726                    127.0.0.1:4505
ESTAB      0      0                    ::ffff:1.2.3.4:5678                ::ffff:1.2.3.4:4505
&quot;&quot;&quot;

LINUX_NETLINK_SS_OUTPUT = &quot;&quot;&quot;\
State       Recv-Q Send-Q                                                            Local Address:Port                                                                           Peer Address:Port
TIME-WAIT   0      0                                                                         [::1]:8009                                                                                  [::1]:40368
LISTEN      0      128                                                                   127.0.0.1:5903                                                                                0.0.0.0:*
ESTAB       0      0                                                            [::ffff:127.0.0.1]:4506                                                                    [::ffff:127.0.0.1]:32315
ESTAB       0      0                                                                 192.168.122.1:4506                                                                       192.168.122.177:24545
&quot;&quot;&quot;

IPV4_SUBNETS = {
    True: (&quot;10.10.0.0/24&quot;,),
    False: (&quot;10.10.0.0&quot;</B></FONT>, &quot;10.10.0.0/33&quot;, &quot;FOO&quot;, 9, &quot;0.9.800.1000/24&quot;),
}
IPV6_SUBNETS = {
    True: (&quot;::1/128&quot;,),
    False: (&quot;::1&quot;, &quot;::1/129&quot;, &quot;FOO&quot;, 9, &quot;aj01::feac/64&quot;),
}


class NetworkTestCase(TestCase):
    def test_sanitize_host_ip(self):
        ret = network.sanitize_host(&quot;10.1./2.$3&quot;)
        self.assertEqual(ret, &quot;10.1.2.3&quot;)

    def test_sanitize_host_name(self):
        &quot;&quot;&quot;
        Should not remove the underscore
        &quot;&quot;&quot;
        ret = network.sanitize_host(&quot;foo_bar&quot;)
        self.assertEqual(ret, &quot;foo_bar&quot;)

    def test_host_to_ips(self):
        &quot;&quot;&quot;
        NOTE: When this test fails it's usually because the IP address has
        changed. In these cases, we just need to update the IP address in the
        assertion.
        &quot;&quot;&quot;

        def _side_effect(host, *args):
            try:
                return {
                    &quot;github.com&quot;: [
                        (2, 1, 6, &quot;&quot;, (&quot;192.30.255.112&quot;, 0)),
                        (2, 1, 6, &quot;&quot;, (&quot;192.30.255.113&quot;, 0)),
                    ],
                    &quot;ipv6host.foo&quot;: [
                        (socket.AF_INET6, 1, 6, &quot;&quot;, (&quot;2001:a71::1&quot;, 0, 0, 0)),
                    ],
                }[host]
            except KeyError:
                raise socket.gaierror(-2, &quot;Name or service not known&quot;)

        getaddrinfo_mock = MagicMock(side_effect=_side_effect)
        with patch.object(socket, &quot;getaddrinfo&quot;, getaddrinfo_mock):
            # Test host that can be resolved
            ret = network.host_to_ips(&quot;github.com&quot;)
            self.assertEqual(ret, [&quot;192.30.255.112&quot;, &quot;192.30.255.113&quot;])
            # Test ipv6
            ret = network.host_to_ips(&quot;ipv6host.foo&quot;)
            self.assertEqual(ret, [&quot;2001:a71::1&quot;])
            # Test host that can't be resolved
            ret = network.host_to_ips(&quot;someothersite.com&quot;)
            self.assertEqual(ret, None)

    def test_generate_minion_id(self):
        self.assertTrue(network.generate_minion_id())

    def test__generate_minion_id_with_unicode_in_etc_hosts(self):
        &quot;&quot;&quot;
        Test that unicode in /etc/hosts doesn't raise an error when
        _generate_minion_id() helper is called to gather the hosts.
        &quot;&quot;&quot;
        content = textwrap.dedent(
            &quot;&quot;&quot;\
        # 以下为主机名解析
        ## ccc
        127.0.0.1       localhost thisismyhostname     # 本机
        &quot;&quot;&quot;
        )
        fopen_mock = mock_open(read_data={&quot;/etc/hosts&quot;: content})
        with patch(&quot;salt.utils.files.fopen&quot;, fopen_mock):
<A NAME="2"></A>            assert &quot;thisismyhostname&quot; in network._generate_minion_id()

    def test_is_ip(self):
        self<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match106572-0.html#2',2,'match106572-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertTrue(network.is_ip(&quot;10.10.0.3&quot;))
        self.assertFalse(network.is_ip(&quot;0.9.800.1000&quot;))
        # Check 16-char-long unicode string
        # https://github.com/saltstack/salt/issues/51258
<A NAME="0"></A>        self.assertFalse(network.is_ipv6(</B></FONT>&quot;sixteen-char-str&quot;))

    def test_is_ipv4(self):
        self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match106572-0.html#0',2,'match106572-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.assertTrue(network.is_ipv4(&quot;10.10.0.3&quot;))
        self.assertFalse(network.is_ipv4(&quot;10.100.1&quot;))
        self.assertFalse(network.is_ipv4(&quot;2001:db8:0:1:1:1:1:1&quot;))
        # Check 16-char-long unicode string
        # https://github.com/saltstack/salt/issues/51258
        self.</B></FONT>assertFalse(network.is_ipv4(&quot;sixteen-char-str&quot;))

    def test_is_ipv6(self):
        self.assertTrue(network.is_ipv6(&quot;2001:db8:0:1:1:1:1:1&quot;))
        self.assertTrue(network.is_ipv6(&quot;0:0:0:0:0:0:0:1&quot;))
        self.assertTrue(network.is_ipv6(&quot;::1&quot;))
        self.assertTrue(network.is_ipv6(&quot;::&quot;))
        self.assertTrue(network.is_ipv6(&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;))
        self.assertTrue(network.is_ipv6(&quot;2001:0db8:85a3::8a2e:0370:7334&quot;))
        self.assertFalse(network.is_ipv6(&quot;2001:0db8:0370:7334&quot;))
        self.assertFalse(network.is_ipv6(&quot;2001:0db8:::0370:7334&quot;))
        self.assertFalse(network.is_ipv6(&quot;10.0.1.2&quot;))
        self.assertFalse(network.is_ipv6(&quot;2001.0db8.85a3.0000.0000.8a2e.0370.7334&quot;))
        # Check 16-char-long unicode string
        # https://github.com/saltstack/salt/issues/51258
        self.assertFalse(network.is_ipv6(&quot;sixteen-char-str&quot;))

    def test_ipv6(self):
        self.assertTrue(network.ipv6(&quot;2001:db8:0:1:1:1:1:1&quot;))
        self.assertTrue(network.ipv6(&quot;0:0:0:0:0:0:0:1&quot;))
        self.assertTrue(network.ipv6(&quot;::1&quot;))
        self.assertTrue(network.ipv6(&quot;::&quot;))
        self.assertTrue(network.ipv6(&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;))
        self.assertTrue(network.ipv6(&quot;2001:0db8:85a3::8a2e:0370:7334&quot;))
        self.assertTrue(network.ipv6(&quot;2001:67c:2e8::/48&quot;))

    def test_parse_host_port(self):
        _ip = ipaddress.ip_address
        good_host_ports = {
            &quot;10.10.0.3&quot;: (_ip(&quot;10.10.0.3&quot;).compressed, None),
            &quot;10.10.0.3:1234&quot;: (_ip(&quot;10.10.0.3&quot;).compressed, 1234),
            &quot;2001:0db8:85a3::8a2e:0370:7334&quot;: (
                _ip(&quot;2001:0db8:85a3::8a2e:0370:7334&quot;).compressed,
                None,
            ),
            &quot;[2001:0db8:85a3::8a2e:0370:7334]:1234&quot;: (
                _ip(&quot;2001:0db8:85a3::8a2e:0370:7334&quot;).compressed,
                1234,
            ),
            &quot;2001:0db8:85a3::7334&quot;: (_ip(&quot;2001:0db8:85a3::7334&quot;).compressed, None),
            &quot;[2001:0db8:85a3::7334]:1234&quot;: (
                _ip(&quot;2001:0db8:85a3::7334&quot;).compressed,
                1234,
            ),
        }
        bad_host_ports = [
            &quot;10.10.0.3/24&quot;,
            &quot;10.10.0.3::1234&quot;,
            &quot;2001:0db8:0370:7334&quot;,
            &quot;2001:0db8:0370::7334]:1234&quot;,
            &quot;2001:0db8:0370:0:a:b:c:d:1234&quot;,
            &quot;host name&quot;,
            &quot;host name:1234&quot;,
            &quot;10.10.0.3:abcd&quot;,
        ]
        for host_port, assertion_value in good_host_ports.items():
            host = port = None
            host, port = network.parse_host_port(host_port)
            self.assertEqual((host, port), assertion_value)

        for host_port in bad_host_ports:
            try:
                self.assertRaises(ValueError, network.parse_host_port, host_port)
            except AssertionError as _e_:
                log.error(
                    'bad host_port value: &quot;%s&quot; failed to trigger ValueError exception',
                    host_port,
                )
                raise _e_

    def test_dns_check(self):
        hosts = [
            {
                &quot;host&quot;: &quot;10.10.0.3&quot;,
                &quot;port&quot;: &quot;&quot;,
                &quot;mocked&quot;: [(2, 1, 6, &quot;&quot;, (&quot;10.10.0.3&quot;, 0))],
                &quot;ret&quot;: &quot;10.10.0.3&quot;,
            },
            {
                &quot;host&quot;: &quot;10.10.0.3&quot;,
                &quot;port&quot;: &quot;1234&quot;,
                &quot;mocked&quot;: [(2, 1, 6, &quot;&quot;, (&quot;10.10.0.3&quot;, 0))],
                &quot;ret&quot;: &quot;10.10.0.3&quot;,
            },
            {
                &quot;host&quot;: &quot;2001:0db8:85a3::8a2e:0370:7334&quot;,
                &quot;port&quot;: &quot;&quot;,
                &quot;mocked&quot;: [(10, 1, 6, &quot;&quot;, (&quot;2001:db8:85a3::8a2e:370:7334&quot;, 0, 0, 0))],
                &quot;ret&quot;: &quot;[2001:db8:85a3::8a2e:370:7334]&quot;,
            },
            {
                &quot;host&quot;: &quot;2001:0db8:85a3::8a2e:370:7334&quot;,
                &quot;port&quot;: &quot;1234&quot;,
                &quot;mocked&quot;: [(10, 1, 6, &quot;&quot;, (&quot;2001:db8:85a3::8a2e:370:7334&quot;, 0, 0, 0))],
                &quot;ret&quot;: &quot;[2001:db8:85a3::8a2e:370:7334]&quot;,
            },
            {
                &quot;host&quot;: &quot;salt-master&quot;,
                &quot;port&quot;: &quot;1234&quot;,
                &quot;mocked&quot;: [(2, 1, 6, &quot;&quot;, (&quot;127.0.0.1&quot;, 0))],
                &quot;ret&quot;: &quot;127.0.0.1&quot;,
            },
        ]
        for host in hosts:
            with patch.object(
                socket,
                &quot;getaddrinfo&quot;,
                create_autospec(socket.getaddrinfo, return_value=host[&quot;mocked&quot;]),
            ):
                with patch(&quot;socket.socket&quot;, create_autospec(socket.socket)):
                    ret = network.dns_check(host[&quot;host&quot;], host[&quot;port&quot;])
                    self.assertEqual(ret, host[&quot;ret&quot;])

    def test_dns_check_ipv6_filter(self):
        # raise exception to skip everything after the getaddrinfo call
        with patch.object(
            socket,
            &quot;getaddrinfo&quot;,
            create_autospec(socket.getaddrinfo, side_effect=Exception),
        ) as getaddrinfo:
            for ipv6, param in [
                (None, socket.AF_UNSPEC),
                (True, socket.AF_INET6),
                (False, socket.AF_INET),
            ]:
                with self.assertRaises(Exception):
                    network.dns_check(&quot;foo&quot;, &quot;1&quot;, ipv6=ipv6)
                getaddrinfo.assert_called_with(&quot;foo&quot;, &quot;1&quot;, param, socket.SOCK_STREAM)

    def test_dns_check_errors(self):
        with patch.object(
            socket, &quot;getaddrinfo&quot;, create_autospec(socket.getaddrinfo, return_value=[])
        ):
            with self.assertRaisesRegex(
                salt.exceptions.SaltSystemExit,
                &quot;DNS lookup or connection check of 'foo' failed&quot;,
            ):
                network.dns_check(&quot;foo&quot;, &quot;1&quot;)

        with patch.object(
            socket,
            &quot;getaddrinfo&quot;,
            create_autospec(socket.getaddrinfo, side_effect=TypeError),
        ):
            with self.assertRaisesRegex(
                salt.exceptions.SaltSystemExit, &quot;Invalid or unresolveable address&quot;
            ):
                network.dns_check(&quot;foo&quot;, &quot;1&quot;)

    def test_test_addrs(self):
        # subset of real data from getaddrinfo against saltstack.com
        addrinfo = [
            (30, 2, 17, &quot;&quot;, (&quot;2600:9000:21eb:a800:8:1031:abc0:93a1&quot;, 0, 0, 0)),
            (30, 1, 6, &quot;&quot;, (&quot;2600:9000:21eb:a800:8:1031:abc0:93a1&quot;, 0, 0, 0)),
            (30, 2, 17, &quot;&quot;, (&quot;2600:9000:21eb:b400:8:1031:abc0:93a1&quot;, 0, 0, 0)),
            (30, 1, 6, &quot;&quot;, (&quot;2600:9000:21eb:b400:8:1031:abc0:93a1&quot;, 0, 0, 0)),
            (2, 1, 6, &quot;&quot;, (&quot;13.35.99.52&quot;, 0)),
            (2, 2, 17, &quot;&quot;, (&quot;13.35.99.85&quot;, 0)),
            (2, 1, 6, &quot;&quot;, (&quot;13.35.99.85&quot;, 0)),
            (2, 2, 17, &quot;&quot;, (&quot;13.35.99.122&quot;, 0)),
        ]
        with patch(&quot;socket.socket&quot;, create_autospec(socket.socket)) as s:
            # we connect to the first address
            addrs = network._test_addrs(addrinfo, 80)
            self.assertTrue(len(addrs) == 1)
            self.assertTrue(addrs[0] == addrinfo[0][4][0])

            # the first lookup fails, succeeds on next check
            s.side_effect = [socket.error, MagicMock()]
            addrs = network._test_addrs(addrinfo, 80)
            self.assertTrue(len(addrs) == 1)
            self.assertTrue(addrs[0] == addrinfo[2][4][0])

            # attempt to connect to resolved address with default timeout
            s.side_effect = socket.error
            addrs = network._test_addrs(addrinfo, 80)
            time.sleep(2)
            self.assertFalse(len(addrs) == 0)

            # nothing can connect, but we've eliminated duplicates
            s.side_effect = socket.error
            addrs = network._test_addrs(addrinfo, 80)
            self.assertTrue(len(addrs) == 5)

    def test_is_subnet(self):
        for subnet_data in (IPV4_SUBNETS, IPV6_SUBNETS):
            for item in subnet_data[True]:
                log.debug(&quot;Testing that %s is a valid subnet&quot;, item)
                self.assertTrue(network.is_subnet(item))
            for item in subnet_data[False]:
                log.debug(&quot;Testing that %s is not a valid subnet&quot;, item)
                self.assertFalse(network.is_subnet(item))

    def test_is_ipv4_subnet(self):
        for item in IPV4_SUBNETS[True]:
            log.debug(&quot;Testing that %s is a valid subnet&quot;, item)
            self.assertTrue(network.is_ipv4_subnet(item))
        for item in IPV4_SUBNETS[False]:
            log.debug(&quot;Testing that %s is not a valid subnet&quot;, item)
            self.assertFalse(network.is_ipv4_subnet(item))

    def test_is_ipv6_subnet(self):
        for item in IPV6_SUBNETS[True]:
            log.debug(&quot;Testing that %s is a valid subnet&quot;, item)
            self.assertTrue(network.is_ipv6_subnet(item))
        for item in IPV6_SUBNETS[False]:
            log.debug(&quot;Testing that %s is not a valid subnet&quot;, item)
            self.assertFalse(network.is_ipv6_subnet(item))

    def test_cidr_to_ipv4_netmask(self):
        self.assertEqual(network.cidr_to_ipv4_netmask(24), &quot;255.255.255.0&quot;)
        self.assertEqual(network.cidr_to_ipv4_netmask(21), &quot;255.255.248.0&quot;)
        self.assertEqual(network.cidr_to_ipv4_netmask(17), &quot;255.255.128.0&quot;)
        self.assertEqual(network.cidr_to_ipv4_netmask(9), &quot;255.128.0.0&quot;)
        self.assertEqual(network.cidr_to_ipv4_netmask(36), &quot;&quot;)
        self.assertEqual(network.cidr_to_ipv4_netmask(&quot;lol&quot;), &quot;&quot;)

    def test_number_of_set_bits_to_ipv4_netmask(self):
        set_bits_to_netmask = network._number_of_set_bits_to_ipv4_netmask(0xFFFFFF00)
        self.assertEqual(set_bits_to_netmask, &quot;255.255.255.0&quot;)
        set_bits_to_netmask = network._number_of_set_bits_to_ipv4_netmask(0xFFFF6400)

    def test_hex2ip(self):
        self.assertEqual(network.hex2ip(&quot;0x4A7D2B63&quot;), &quot;74.125.43.99&quot;)
        self.assertEqual(network.hex2ip(&quot;0x4A7D2B63&quot;, invert=True), &quot;99.43.125.74&quot;)
        self.assertEqual(
            network.hex2ip(&quot;00000000000000000000FFFF7F000001&quot;), &quot;127.0.0.1&quot;
        )
        self.assertEqual(
            network.hex2ip(&quot;0000000000000000FFFF00000100007F&quot;, invert=True), &quot;127.0.0.1&quot;
        )
        self.assertEqual(
            network.hex2ip(&quot;20010DB8000000000000000000000000&quot;), &quot;2001:db8::&quot;
        )
        self.assertEqual(
            network.hex2ip(&quot;B80D0120000000000000000000000000&quot;, invert=True),
            &quot;2001:db8::&quot;,
        )

    def test_interfaces_ifconfig_linux(self):
        interfaces = network._interfaces_ifconfig(LINUX)
        self.assertEqual(
            interfaces,
            {
                &quot;eth0&quot;: {
                    &quot;hwaddr&quot;: &quot;e0:3f:49:85:6a:af&quot;,
                    &quot;inet&quot;: [
                        {
                            &quot;address&quot;: &quot;10.10.10.56&quot;,
                            &quot;broadcast&quot;: &quot;10.10.10.255&quot;,
                            &quot;netmask&quot;: &quot;255.255.252.0&quot;,
                        }
                    ],
                    &quot;inet6&quot;: [
                        {
                            &quot;address&quot;: &quot;fe80::e23f:49ff:fe85:6aaf&quot;,
                            &quot;prefixlen&quot;: &quot;64&quot;,
                            &quot;scope&quot;: &quot;link&quot;,
                        }
                    ],
                    &quot;up&quot;: True,
                },
                &quot;lo&quot;: {
                    &quot;inet&quot;: [{&quot;address&quot;: &quot;127.0.0.1&quot;, &quot;netmask&quot;: &quot;255.0.0.0&quot;}],
                    &quot;inet6&quot;: [{&quot;address&quot;: &quot;::1&quot;, &quot;prefixlen&quot;: &quot;128&quot;, &quot;scope&quot;: &quot;host&quot;}],
                    &quot;up&quot;: True,
                },
            },
        )

    def test_interfaces_ifconfig_freebsd(self):
        interfaces = network._interfaces_ifconfig(FREEBSD)
        self.assertEqual(
            interfaces,
            {
                &quot;&quot;: {&quot;up&quot;: False},
                &quot;em0&quot;: {
                    &quot;hwaddr&quot;: &quot;00:30:48:ff:ff:ff&quot;,
                    &quot;inet&quot;: [
                        {
                            &quot;address&quot;: &quot;10.10.10.250&quot;,
                            &quot;broadcast&quot;: &quot;10.10.10.255&quot;,
                            &quot;netmask&quot;: &quot;255.255.255.224&quot;,
                        },
                        {
                            &quot;address&quot;: &quot;10.10.10.56&quot;,
                            &quot;broadcast&quot;: &quot;10.10.10.63&quot;,
                            &quot;netmask&quot;: &quot;255.255.255.192&quot;,
                        },
                    ],
                    &quot;up&quot;: True,
                },
                &quot;em1&quot;: {&quot;hwaddr&quot;: &quot;00:30:48:aa:aa:aa&quot;, &quot;up&quot;: False},
                &quot;lo0&quot;: {
                    &quot;inet&quot;: [{&quot;address&quot;: &quot;127.0.0.1&quot;, &quot;netmask&quot;: &quot;255.0.0.0&quot;}],
                    &quot;inet6&quot;: [
                        {&quot;address&quot;: &quot;fe80::1&quot;, &quot;prefixlen&quot;: &quot;64&quot;, &quot;scope&quot;: &quot;0x8&quot;},
                        {&quot;address&quot;: &quot;::1&quot;, &quot;prefixlen&quot;: &quot;128&quot;, &quot;scope&quot;: None},
                    ],
                    &quot;up&quot;: True,
                },
                &quot;plip0&quot;: {&quot;up&quot;: False},
                &quot;tun0&quot;: {
                    &quot;inet&quot;: [{&quot;address&quot;: &quot;10.12.0.1&quot;, &quot;netmask&quot;: &quot;255.255.255.255&quot;}],
                    &quot;up&quot;: True,
                },
            },
        )

    def test_interfaces_ifconfig_solaris(self):
        with patch(&quot;salt.utils.platform.is_sunos&quot;, lambda: True):
            interfaces = network._interfaces_ifconfig(SOLARIS)
            expected_interfaces = {
                &quot;ilbint0&quot;: {
                    &quot;inet6&quot;: [],
                    &quot;inet&quot;: [
                        {
                            &quot;broadcast&quot;: &quot;10.6.0.255&quot;,
                            &quot;netmask&quot;: &quot;255.255.255.0&quot;,
                            &quot;address&quot;: &quot;10.6.0.11&quot;,
                        }
                    ],
                    &quot;up&quot;: True,
                },
                &quot;lo0&quot;: {
                    &quot;inet6&quot;: [{&quot;prefixlen&quot;: &quot;128&quot;, &quot;address&quot;: &quot;::1&quot;}],
                    &quot;inet&quot;: [{&quot;netmask&quot;: &quot;255.0.0.0&quot;, &quot;address&quot;: &quot;127.0.0.1&quot;}],
                    &quot;up&quot;: True,
                },
                &quot;ilbext0&quot;: {
                    &quot;inet6&quot;: [],
                    &quot;inet&quot;: [
                        {
                            &quot;broadcast&quot;: &quot;10.10.11.31&quot;,
                            &quot;netmask&quot;: &quot;255.255.255.224&quot;,
                            &quot;address&quot;: &quot;10.10.11.11&quot;,
                        },
                        {
                            &quot;broadcast&quot;: &quot;10.10.11.31&quot;,
                            &quot;netmask&quot;: &quot;255.255.255.224&quot;,
                            &quot;address&quot;: &quot;10.10.11.12&quot;,
                        },
                    ],
                    &quot;up&quot;: True,
                },
                &quot;vpn0&quot;: {
                    &quot;inet6&quot;: [],
                    &quot;inet&quot;: [{&quot;netmask&quot;: &quot;255.0.0.0&quot;, &quot;address&quot;: &quot;10.6.0.14&quot;}],
                    &quot;up&quot;: True,
                },
                &quot;net0&quot;: {
                    &quot;inet6&quot;: [
                        {&quot;prefixlen&quot;: &quot;10&quot;, &quot;address&quot;: &quot;fe80::221:9bff:fefd:2a22&quot;}
                    ],
                    &quot;inet&quot;: [
                        {
                            &quot;broadcast&quot;: &quot;10.10.10.63&quot;,
                            &quot;netmask&quot;: &quot;255.255.255.224&quot;,
                            &quot;address&quot;: &quot;10.10.10.38&quot;,
                        }
                    ],
                    &quot;up&quot;: True,
                },
            }
            self.assertEqual(interfaces, expected_interfaces)

    def test_interfaces_ifconfig_netbsd(self):
        interfaces = network._netbsd_interfaces_ifconfig(NETBSD)
        self.assertEqual(
            interfaces,
            {
                &quot;lo0&quot;: {
                    &quot;inet&quot;: [{&quot;address&quot;: &quot;127.0.0.1&quot;, &quot;netmask&quot;: &quot;255.0.0.0&quot;}],
                    &quot;inet6&quot;: [
                        {&quot;address&quot;: &quot;fe80::1&quot;, &quot;prefixlen&quot;: &quot;64&quot;, &quot;scope&quot;: &quot;lo0&quot;}
                    ],
                    &quot;up&quot;: True,
                },
                &quot;vioif0&quot;: {
                    &quot;hwaddr&quot;: &quot;00:a0:98:e6:83:18&quot;,
                    &quot;inet&quot;: [
                        {
                            &quot;address&quot;: &quot;192.168.1.80&quot;,
                            &quot;broadcast&quot;: &quot;192.168.1.255&quot;,
                            &quot;netmask&quot;: &quot;255.255.255.0&quot;,
                        }
                    ],
                    &quot;inet6&quot;: [
                        {
                            &quot;address&quot;: &quot;fe80::2a0:98ff:fee6:8318&quot;,
                            &quot;prefixlen&quot;: &quot;64&quot;,
                            &quot;scope&quot;: &quot;vioif0&quot;,
                        }
                    ],
                    &quot;up&quot;: True,
                },
            },
        )

    def test_freebsd_remotes_on(self):
        with patch(&quot;salt.utils.platform.is_sunos&quot;, lambda: False):
            with patch(&quot;salt.utils.platform.is_freebsd&quot;, lambda: True):
                with patch(&quot;subprocess.check_output&quot;, return_value=FREEBSD_SOCKSTAT):
                    remotes = network._freebsd_remotes_on(&quot;4506&quot;, &quot;remote&quot;)
                    self.assertEqual(remotes, {&quot;127.0.0.1&quot;})

    def test_freebsd_remotes_on_with_fat_pid(self):
        with patch(&quot;salt.utils.platform.is_sunos&quot;, lambda: False):
            with patch(&quot;salt.utils.platform.is_freebsd&quot;, lambda: True):
                with patch(
                    &quot;subprocess.check_output&quot;,
                    return_value=FREEBSD_SOCKSTAT_WITH_FAT_PID,
                ):
                    remotes = network._freebsd_remotes_on(&quot;4506&quot;, &quot;remote&quot;)
                    self.assertEqual(remotes, {&quot;127.0.0.1&quot;})

    def test_netlink_tool_remote_on_a(self):
        with patch(&quot;salt.utils.platform.is_sunos&quot;, lambda: False):
            with patch(&quot;salt.utils.platform.is_linux&quot;, lambda: True):
                with patch(
                    &quot;subprocess.check_output&quot;, return_value=LINUX_NETLINK_SS_OUTPUT
                ):
                    remotes = network._netlink_tool_remote_on(&quot;4506&quot;, &quot;local&quot;)
                    self.assertEqual(remotes, {&quot;192.168.122.177&quot;, &quot;::ffff:127.0.0.1&quot;})

    def test_netlink_tool_remote_on_b(self):
        with patch(&quot;subprocess.check_output&quot;, return_value=NETLINK_SS):
            remotes = network._netlink_tool_remote_on(&quot;4505&quot;, &quot;remote_port&quot;)
            self.assertEqual(remotes, {&quot;127.0.0.1&quot;, &quot;::ffff:1.2.3.4&quot;})

    def test_generate_minion_id_distinct(self):
        &quot;&quot;&quot;
        Test if minion IDs are distinct in the pool.

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;nodename&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;hostname&quot;)
        ), patch(
            &quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;hostname.domainname.blank&quot;)
        ), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;attrname&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;1.2.3.4&quot;, &quot;5.6.7.8&quot;]),
        ):
            self.assertEqual(
                network._generate_minion_id(),
                [
                    &quot;hostname.domainname.blank&quot;,
                    &quot;nodename&quot;,
                    &quot;hostname&quot;,
                    &quot;1.2.3.4&quot;,
                    &quot;5.6.7.8&quot;,
                ],
            )

    def test_generate_minion_id_127_name(self):
        &quot;&quot;&quot;
        Test if minion IDs can be named 127.foo

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;127&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;127&quot;)
        ), patch(
            &quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;127.domainname.blank&quot;)
        ), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;attrname&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;1.2.3.4&quot;, &quot;5.6.7.8&quot;]),
        ):
            self.assertEqual(
                network._generate_minion_id(),
                [&quot;127.domainname.blank&quot;, &quot;127&quot;, &quot;1.2.3.4&quot;, &quot;5.6.7.8&quot;],
            )

    def test_generate_minion_id_127_name_startswith(self):
        &quot;&quot;&quot;
        Test if minion IDs can be named starting from &quot;127&quot;

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;127890&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;127890&quot;)
        ), patch(
            &quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;127890.domainname.blank&quot;)
        ), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;attrname&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;1.2.3.4&quot;, &quot;5.6.7.8&quot;]),
        ):
            self.assertEqual(
                network._generate_minion_id(),
                [&quot;127890.domainname.blank&quot;, &quot;127890&quot;, &quot;1.2.3.4&quot;, &quot;5.6.7.8&quot;],
            )

    def test_generate_minion_id_duplicate(self):
        &quot;&quot;&quot;
        Test if IP addresses in the minion IDs are distinct in the pool

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;hostname&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;hostname&quot;)
        ), patch(&quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;hostname&quot;)), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;hostname&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;1.2.3.4&quot;, &quot;1.2.3.4&quot;, &quot;1.2.3.4&quot;]),
        ):
            self.assertEqual(network._generate_minion_id(), [&quot;hostname&quot;, &quot;1.2.3.4&quot;])

    def test_generate_minion_id_platform_used(self):
        &quot;&quot;&quot;
        Test if platform.node is used for the first occurrence.
        The platform.node is most common hostname resolver before anything else.

        :return:
        &quot;&quot;&quot;
        with patch(
            &quot;platform.node&quot;, MagicMock(return_value=&quot;very.long.and.complex.domain.name&quot;)
        ), patch(&quot;socket.gethostname&quot;, MagicMock(return_value=&quot;hostname&quot;)), patch(
            &quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;&quot;)
        ), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;hostname&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;1.2.3.4&quot;, &quot;1.2.3.4&quot;, &quot;1.2.3.4&quot;]),
        ):
            self.assertEqual(
                network.generate_minion_id(), &quot;very.long.and.complex.domain.name&quot;
            )

    def test_generate_minion_id_platform_localhost_filtered(self):
        &quot;&quot;&quot;
        Test if localhost is filtered from the first occurrence.

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;localhost&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;pick.me&quot;)
        ), patch(
            &quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;hostname.domainname.blank&quot;)
        ), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;hostname&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;1.2.3.4&quot;, &quot;1.2.3.4&quot;, &quot;1.2.3.4&quot;]),
        ):
            self.assertEqual(network.generate_minion_id(), &quot;hostname.domainname.blank&quot;)

    def test_generate_minion_id_platform_localhost_filtered_all(self):
        &quot;&quot;&quot;
        Test if any of the localhost is filtered from everywhere.

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;localhost&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;ip6-loopback&quot;)
        ), patch(&quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;ip6-localhost&quot;)), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;localhost&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(
                return_value=[&quot;127.0.0.1&quot;, &quot;::1&quot;, &quot;fe00::0&quot;, &quot;fe02::1&quot;, &quot;1.2.3.4&quot;]
            ),
        ):
            self.assertEqual(network.generate_minion_id(), &quot;1.2.3.4&quot;)

    def test_generate_minion_id_platform_localhost_only(self):
        &quot;&quot;&quot;
        Test if there is no other choice but localhost.

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;localhost&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;ip6-loopback&quot;)
        ), patch(&quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;ip6-localhost&quot;)), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;localhost&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;127.0.0.1&quot;, &quot;::1&quot;, &quot;fe00::0&quot;, &quot;fe02::1&quot;]),
        ):
            self.assertEqual(network.generate_minion_id(), &quot;localhost&quot;)

    def test_generate_minion_id_platform_fqdn(self):
        &quot;&quot;&quot;
        Test if fqdn is picked up.

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;localhost&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;ip6-loopback&quot;)
        ), patch(&quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;pick.me&quot;)), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;localhost&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;127.0.0.1&quot;, &quot;::1&quot;, &quot;fe00::0&quot;, &quot;fe02::1&quot;]),
        ):
            self.assertEqual(network.generate_minion_id(), &quot;pick.me&quot;)

    def test_generate_minion_id_platform_localhost_addrinfo(self):
        &quot;&quot;&quot;
        Test if addinfo is picked up.

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;localhost&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;ip6-loopback&quot;)
        ), patch(&quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;ip6-localhost&quot;)), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;pick.me&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(return_value=[&quot;127.0.0.1&quot;, &quot;::1&quot;, &quot;fe00::0&quot;, &quot;fe02::1&quot;]),
        ):
            self.assertEqual(network.generate_minion_id(), &quot;pick.me&quot;)

    def test_generate_minion_id_platform_ip_addr_only(self):
        &quot;&quot;&quot;
        Test if IP address is the only what is used as a Minion ID in case no DNS name.

        :return:
        &quot;&quot;&quot;
        with patch(&quot;platform.node&quot;, MagicMock(return_value=&quot;localhost&quot;)), patch(
            &quot;socket.gethostname&quot;, MagicMock(return_value=&quot;ip6-loopback&quot;)
        ), patch(&quot;socket.getfqdn&quot;, MagicMock(return_value=&quot;ip6-localhost&quot;)), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;localhost&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ), patch(
            &quot;salt.utils.files.fopen&quot;, mock_open()
        ), patch(
            &quot;salt.utils.network.ip_addrs&quot;,
            MagicMock(
                return_value=[&quot;127.0.0.1&quot;, &quot;::1&quot;, &quot;fe00::0&quot;, &quot;fe02::1&quot;, &quot;1.2.3.4&quot;]
            ),
        ):
            self.assertEqual(network.generate_minion_id(), &quot;1.2.3.4&quot;)

    def test_gen_mac(self):
        with patch(&quot;random.randint&quot;, return_value=1) as random_mock:
            self.assertEqual(random_mock.return_value, 1)
            ret = network.gen_mac(&quot;00:16:3E&quot;)
            expected_mac = &quot;00:16:3E:01:01:01&quot;
            self.assertEqual(ret, expected_mac)

    def test_mac_str_to_bytes(self):
        self.assertRaises(ValueError, network.mac_str_to_bytes, &quot;31337&quot;)
        self.assertRaises(ValueError, network.mac_str_to_bytes, &quot;0001020304056&quot;)
        self.assertRaises(ValueError, network.mac_str_to_bytes, &quot;00:01:02:03:04:056&quot;)
        self.assertRaises(ValueError, network.mac_str_to_bytes, &quot;a0:b0:c0:d0:e0:fg&quot;)
        self.assertEqual(
            b&quot;\x10\x08\x06\x04\x02\x00&quot;, network.mac_str_to_bytes(&quot;100806040200&quot;)
        )
        self.assertEqual(
            b&quot;\xf8\xe7\xd6\xc5\xb4\xa3&quot;, network.mac_str_to_bytes(&quot;f8e7d6c5b4a3&quot;)
        )

    @pytest.mark.slow_test
    def test_generate_minion_id_with_long_hostname(self):
        &quot;&quot;&quot;
        Validate the fix for:

        https://github.com/saltstack/salt/issues/51160
        &quot;&quot;&quot;
        long_name = &quot;localhost-abcdefghijklmnopqrstuvwxyz-abcdefghijklmnopqrstuvwxyz&quot;
        with patch(&quot;socket.gethostname&quot;, MagicMock(return_value=long_name)):
            # An exception is raised if unicode is passed to socket.getfqdn
            minion_id = network.generate_minion_id()
        assert minion_id != &quot;&quot;, minion_id

    def test_filter_by_networks_with_no_filter(self):
        ips = [&quot;10.0.123.200&quot;, &quot;10.10.10.10&quot;]
        with pytest.raises(TypeError):
            network.filter_by_networks(ips)  # pylint: disable=no-value-for-parameter

    def test_filter_by_networks_empty_filter(self):
        ips = [&quot;10.0.123.200&quot;, &quot;10.10.10.10&quot;]
        assert network.filter_by_networks(ips, []) == []

    def test_filter_by_networks_ips_list(self):
        ips = [
            &quot;10.0.123.200&quot;,
            &quot;10.10.10.10&quot;,
            &quot;193.124.233.5&quot;,
            &quot;fe80::d210:cf3f:64e7:5423&quot;,
        ]
        networks = [&quot;10.0.0.0/8&quot;, &quot;fe80::/64&quot;]
        assert network.filter_by_networks(ips, networks) == [
            &quot;10.0.123.200&quot;,
            &quot;10.10.10.10&quot;,
            &quot;fe80::d210:cf3f:64e7:5423&quot;,
        ]

    def test_filter_by_networks_interfaces_dict(self):
        interfaces = {
            &quot;wlan0&quot;: [&quot;192.168.1.100&quot;, &quot;217.5.140.67&quot;, &quot;2001:db8::ff00:42:8329&quot;],
            &quot;eth0&quot;: [
                &quot;2001:0DB8:0:CD30:123:4567:89AB:CDEF&quot;,
                &quot;192.168.1.101&quot;,
                &quot;10.0.123.201&quot;,
            ],
        }
        assert network.filter_by_networks(
            interfaces, [&quot;192.168.1.0/24&quot;, &quot;2001:db8::/48&quot;]
        ) == {
            &quot;wlan0&quot;: [&quot;192.168.1.100&quot;, &quot;2001:db8::ff00:42:8329&quot;],
            &quot;eth0&quot;: [&quot;2001:0DB8:0:CD30:123:4567:89AB:CDEF&quot;, &quot;192.168.1.101&quot;],
        }

    def test_filter_by_networks_catch_all(self):
        ips = [
            &quot;10.0.123.200&quot;,
            &quot;10.10.10.10&quot;,
            &quot;193.124.233.5&quot;,
            &quot;fe80::d210:cf3f:64e7:5423&quot;,
        ]
        assert ips == network.filter_by_networks(ips, [&quot;0.0.0.0/0&quot;, &quot;::/0&quot;])

    def test_ip_networks(self):
        # We don't need to test with each platform's ifconfig/iproute2 output,
        # since this test isn't testing getting the interfaces. We already have
        # tests for that.
        interface_data = network._interfaces_ifconfig(LINUX)

        # Without loopback
        ret = network.ip_networks(interface_data=interface_data)
        assert ret == [&quot;10.10.8.0/22&quot;], ret
        # Without loopback, specific interface
        ret = network.ip_networks(interface=&quot;eth0&quot;, interface_data=interface_data)
        assert ret == [&quot;10.10.8.0/22&quot;], ret
        # Without loopback, multiple specific interfaces
        ret = network.ip_networks(interface=&quot;eth0,lo&quot;, interface_data=interface_data)
        assert ret == [&quot;10.10.8.0/22&quot;], ret
        # Without loopback, specific interface (not present)
        ret = network.ip_networks(interface=&quot;eth1&quot;, interface_data=interface_data)
        assert ret == [], ret
        # With loopback
        ret = network.ip_networks(include_loopback=True, interface_data=interface_data)
        assert ret == [&quot;10.10.8.0/22&quot;, &quot;127.0.0.0/8&quot;], ret
        # With loopback, specific interface
        ret = network.ip_networks(
            interface=&quot;eth0&quot;, include_loopback=True, interface_data=interface_data
        )
        assert ret == [&quot;10.10.8.0/22&quot;], ret
        # With loopback, multiple specific interfaces
        ret = network.ip_networks(
            interface=&quot;eth0,lo&quot;, include_loopback=True, interface_data=interface_data
        )
        assert ret == [&quot;10.10.8.0/22&quot;, &quot;127.0.0.0/8&quot;], ret
        # With loopback, specific interface (not present)
        ret = network.ip_networks(
            interface=&quot;eth1&quot;, include_loopback=True, interface_data=interface_data
        )
        assert ret == [], ret

        # Verbose, without loopback
        ret = network.ip_networks(verbose=True, interface_data=interface_data)
        assert ret == {
            &quot;10.10.8.0/22&quot;: {
                &quot;prefixlen&quot;: 22,
                &quot;netmask&quot;: &quot;255.255.252.0&quot;,
                &quot;num_addresses&quot;: 1024,
                &quot;address&quot;: &quot;10.10.8.0&quot;,
            },
        }, ret
        # Verbose, without loopback, specific interface
        ret = network.ip_networks(
            interface=&quot;eth0&quot;, verbose=True, interface_data=interface_data
        )
        assert ret == {
            &quot;10.10.8.0/22&quot;: {
                &quot;prefixlen&quot;: 22,
                &quot;netmask&quot;: &quot;255.255.252.0&quot;,
                &quot;num_addresses&quot;: 1024,
                &quot;address&quot;: &quot;10.10.8.0&quot;,
            },
        }, ret
        # Verbose, without loopback, multiple specific interfaces
        ret = network.ip_networks(
            interface=&quot;eth0,lo&quot;, verbose=True, interface_data=interface_data
        )
        assert ret == {
            &quot;10.10.8.0/22&quot;: {
                &quot;prefixlen&quot;: 22,
                &quot;netmask&quot;: &quot;255.255.252.0&quot;,
                &quot;num_addresses&quot;: 1024,
                &quot;address&quot;: &quot;10.10.8.0&quot;,
            },
        }, ret
        # Verbose, without loopback, specific interface (not present)
        ret = network.ip_networks(
            interface=&quot;eth1&quot;, verbose=True, interface_data=interface_data
        )
        assert ret == {}, ret
        # Verbose, with loopback
        ret = network.ip_networks(
            include_loopback=True, verbose=True, interface_data=interface_data
        )
        assert ret == {
            &quot;10.10.8.0/22&quot;: {
                &quot;prefixlen&quot;: 22,
                &quot;netmask&quot;: &quot;255.255.252.0&quot;,
                &quot;num_addresses&quot;: 1024,
                &quot;address&quot;: &quot;10.10.8.0&quot;,
            },
            &quot;127.0.0.0/8&quot;: {
                &quot;prefixlen&quot;: 8,
                &quot;netmask&quot;: &quot;255.0.0.0&quot;,
                &quot;num_addresses&quot;: 16777216,
                &quot;address&quot;: &quot;127.0.0.0&quot;,
            },
        }, ret
        # Verbose, with loopback, specific interface
        ret = network.ip_networks(
            interface=&quot;eth0&quot;,
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            &quot;10.10.8.0/22&quot;: {
                &quot;prefixlen&quot;: 22,
                &quot;netmask&quot;: &quot;255.255.252.0&quot;,
                &quot;num_addresses&quot;: 1024,
                &quot;address&quot;: &quot;10.10.8.0&quot;,
            },
        }, ret
        # Verbose, with loopback, multiple specific interfaces
        ret = network.ip_networks(
            interface=&quot;eth0,lo&quot;,
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            &quot;10.10.8.0/22&quot;: {
                &quot;prefixlen&quot;: 22,
                &quot;netmask&quot;: &quot;255.255.252.0&quot;,
                &quot;num_addresses&quot;: 1024,
                &quot;address&quot;: &quot;10.10.8.0&quot;,
            },
            &quot;127.0.0.0/8&quot;: {
                &quot;prefixlen&quot;: 8,
                &quot;netmask&quot;: &quot;255.0.0.0&quot;,
                &quot;num_addresses&quot;: 16777216,
                &quot;address&quot;: &quot;127.0.0.0&quot;,
            },
        }, ret
        # Verbose, with loopback, specific interface (not present)
        ret = network.ip_networks(
            interface=&quot;eth1&quot;,
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {}, ret

    def test_ip_networks6(self):
        # We don't need to test with each platform's ifconfig/iproute2 output,
        # since this test isn't testing getting the interfaces. We already have
        # tests for that.
        interface_data = network._interfaces_ifconfig(LINUX)

        # Without loopback
        ret = network.ip_networks6(interface_data=interface_data)
        assert ret == [&quot;fe80::/64&quot;], ret
        # Without loopback, specific interface
        ret = network.ip_networks6(interface=&quot;eth0&quot;, interface_data=interface_data)
        assert ret == [&quot;fe80::/64&quot;], ret
        # Without loopback, multiple specific interfaces
        ret = network.ip_networks6(interface=&quot;eth0,lo&quot;, interface_data=interface_data)
        assert ret == [&quot;fe80::/64&quot;], ret
        # Without loopback, specific interface (not present)
        ret = network.ip_networks6(interface=&quot;eth1&quot;, interface_data=interface_data)
        assert ret == [], ret
        # With loopback
        ret = network.ip_networks6(include_loopback=True, interface_data=interface_data)
        assert ret == [&quot;::1/128&quot;, &quot;fe80::/64&quot;], ret
        # With loopback, specific interface
        ret = network.ip_networks6(
            interface=&quot;eth0&quot;, include_loopback=True, interface_data=interface_data
        )
        assert ret == [&quot;fe80::/64&quot;], ret
        # With loopback, multiple specific interfaces
        ret = network.ip_networks6(
            interface=&quot;eth0,lo&quot;, include_loopback=True, interface_data=interface_data
        )
        assert ret == [&quot;::1/128&quot;, &quot;fe80::/64&quot;], ret
        # With loopback, specific interface (not present)
        ret = network.ip_networks6(
            interface=&quot;eth1&quot;, include_loopback=True, interface_data=interface_data
        )
        assert ret == [], ret

        # Verbose, without loopback
        ret = network.ip_networks6(verbose=True, interface_data=interface_data)
        assert ret == {
            &quot;fe80::/64&quot;: {
                &quot;prefixlen&quot;: 64,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff::&quot;,
                &quot;num_addresses&quot;: 18446744073709551616,
                &quot;address&quot;: &quot;fe80::&quot;,
            },
        }, ret
        # Verbose, without loopback, specific interface
        ret = network.ip_networks6(
            interface=&quot;eth0&quot;, verbose=True, interface_data=interface_data
        )
        assert ret == {
            &quot;fe80::/64&quot;: {
                &quot;prefixlen&quot;: 64,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff::&quot;,
                &quot;num_addresses&quot;: 18446744073709551616,
                &quot;address&quot;: &quot;fe80::&quot;,
            },
        }, ret
        # Verbose, without loopback, multiple specific interfaces
        ret = network.ip_networks6(
            interface=&quot;eth0,lo&quot;, verbose=True, interface_data=interface_data
        )
        assert ret == {
            &quot;fe80::/64&quot;: {
                &quot;prefixlen&quot;: 64,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff::&quot;,
                &quot;num_addresses&quot;: 18446744073709551616,
                &quot;address&quot;: &quot;fe80::&quot;,
            },
        }, ret
        # Verbose, without loopback, specific interface (not present)
        ret = network.ip_networks6(
            interface=&quot;eth1&quot;, verbose=True, interface_data=interface_data
        )
        assert ret == {}, ret
        # Verbose, with loopback
        ret = network.ip_networks6(
            include_loopback=True, verbose=True, interface_data=interface_data
        )
        assert ret == {
            &quot;fe80::/64&quot;: {
                &quot;prefixlen&quot;: 64,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff::&quot;,
                &quot;num_addresses&quot;: 18446744073709551616,
                &quot;address&quot;: &quot;fe80::&quot;,
            },
            &quot;::1/128&quot;: {
                &quot;prefixlen&quot;: 128,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;,
                &quot;num_addresses&quot;: 1,
                &quot;address&quot;: &quot;::1&quot;,
            },
        }, ret
        # Verbose, with loopback, specific interface
        ret = network.ip_networks6(
            interface=&quot;eth0&quot;,
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            &quot;fe80::/64&quot;: {
                &quot;prefixlen&quot;: 64,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff::&quot;,
                &quot;num_addresses&quot;: 18446744073709551616,
                &quot;address&quot;: &quot;fe80::&quot;,
            },
        }, ret
        # Verbose, with loopback, multiple specific interfaces
        ret = network.ip_networks6(
            interface=&quot;eth0,lo&quot;,
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            &quot;fe80::/64&quot;: {
                &quot;prefixlen&quot;: 64,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff::&quot;,
                &quot;num_addresses&quot;: 18446744073709551616,
                &quot;address&quot;: &quot;fe80::&quot;,
            },
            &quot;::1/128&quot;: {
                &quot;prefixlen&quot;: 128,
                &quot;netmask&quot;: &quot;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;,
                &quot;num_addresses&quot;: 1,
                &quot;address&quot;: &quot;::1&quot;,
            },
        }, ret
        # Verbose, with loopback, specific interface (not present)
        ret = network.ip_networks6(
            interface=&quot;eth1&quot;,
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {}, ret

    def test_get_fqhostname_return(self):
        &quot;&quot;&quot;
        Test if proper hostname is used when RevDNS differ from hostname

        :return:
        &quot;&quot;&quot;
        with patch(&quot;socket.gethostname&quot;, MagicMock(return_value=&quot;hostname&quot;)), patch(
            &quot;socket.getfqdn&quot;,
            MagicMock(return_value=&quot;very.long.and.complex.domain.name&quot;),
        ), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(return_value=[(2, 3, 0, &quot;hostname&quot;, (&quot;127.0.1.1&quot;, 0))]),
        ):
            self.assertEqual(network.get_fqhostname(), &quot;hostname&quot;)

    def test_get_fqhostname_return_empty_hostname(self):
        &quot;&quot;&quot;
        Test if proper hostname is used when hostname returns empty string
        &quot;&quot;&quot;
        host = &quot;hostname&quot;
        with patch(&quot;socket.gethostname&quot;, MagicMock(return_value=host)), patch(
            &quot;socket.getfqdn&quot;,
            MagicMock(return_value=&quot;very.long.and.complex.domain.name&quot;),
        ), patch(
            &quot;socket.getaddrinfo&quot;,
            MagicMock(
                return_value=[
                    (2, 3, 0, host, (&quot;127.0.1.1&quot;, 0)),
                    (2, 3, 0, &quot;&quot;, (&quot;127.0.1.1&quot;, 0)),
                ]
            ),
        ):
            self.assertEqual(network.get_fqhostname(), host)
</PRE>
</div>
  </div>
</body>
</html>
