<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for capirca_acl.py &amp; test_network_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for capirca_acl.py &amp; test_network_4.py
      </h3>
<h1 align="center">
        3.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>capirca_acl.py (4.506699%)<th>test_network_4.py (2.5255973%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(375-385)<td><a href="#" name="0">(209-214)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(628-874)<td><a href="#" name="1">(15-129)</a><td align="center"><font color="#eb0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(354-359)<td><a href="#" name="2">(202-206)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>capirca_acl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
import inspect
import logging
import re
import salt.utils.files
log = logging.getLogger(__file__)
try:
    import capirca
    import capirca.aclgen
    import capirca.lib.policy
    import capirca.lib.aclgenerator
    HAS_CAPIRCA = True
except ImportError:
    HAS_CAPIRCA = False
__virtualname__ = "capirca"
__proxyenabled__ = ["*"]
def __virtual__():
    if HAS_CAPIRCA:
        return __virtualname__
    else:
        return (False, "The capirca module (capirca_acl) cannot be loaded.")
_TERM_FIELDS = {
    "action": [],
    "address": [],
    "address_exclude": [],
    "comment": [],
    "counter": None,
    "expiration": None,
    "destination_address": [],
    "destination_address_exclude": [],
    "destination_port": [],
    "destination_prefix": [],
    "forwarding_class": [],
    "forwarding_class_except": [],
    "logging": [],
    "log_name": None,
    "loss_priority": None,
    "option": [],
    "owner": None,
    "policer": None,
    "port": [],
    "precedence": [],
    "principals": [],
    "protocol": [],
    "protocol_except": [],
    "qos": None,
    "pan_application": [],
    "routing_instance": None,
    "source_address": [],
    "source_address_exclude": [],
    "source_port": [],
    "source_prefix": [],
    "verbatim": [],
    "packet_length": None,
    "fragment_offset": None,
    "hop_limit": None,
    "icmp_type": [],
    "icmp_code": None,
    "ether_type": [],
    "traffic_class_count": None,
    "traffic_type": [],
    "translated": False,
    "dscp_set": None,
    "dscp_match": [],
    "dscp_except": [],
    "next_ip": None,
    "flexible_match_range": [],
    "source_prefix_except": [],
    "destination_prefix_except": [],
    "vpn": None,
    "source_tag": [],
    "destination_tag": [],
    "source_interface": None,
    "destination_interface": None,
    "platform": [],
    "platform_exclude": [],
    "timeout": None,
    "flattened": False,
    "flattened_addr": None,
    "flattened_saddr": None,
    "flattened_daddr": None,
    "priority": None,
    "ttl": None,
}
_IP_FILEDS = [
    "source_address",
    "source_address_exclude",
    "destination_address",
    "address",
    "address_exclude",
    "flattened_addr",
    "flattened_saddr",
    "flattened_daddr",
    "next_ip",
]
_SERVICES = {}
if HAS_CAPIRCA:
    _TempTerm = capirca.lib.policy.Term
    def _add_object(self, obj):
        return
    setattr(_TempTerm, "AddObject", _add_object)
    dumy_term = _TempTerm(None)
    for item in dir(dumy_term):
        if hasattr(item, "__func__") or item.startswith("_") or item != item.lower():
            continue
        _TERM_FIELDS[item] = getattr(dumy_term, item)
    class _Policy(capirca.lib.policy.Policy):
        def __init__(self):
            self.filters = []
            self.filename = ""
    class _Term(capirca.lib.policy.Term):
        def __init__(self):
            for field, default in _TERM_FIELDS.items():
                setattr(self, field, default)
def _import_platform_generator(platform):
    log.debug("Using platform: %s", platform)
    for mod_name, mod_obj in inspect.getmembers(capirca.aclgen):
        if mod_name == platform and inspect.ismodule(mod_obj):
            for plat_obj_name, plat_obj in inspect.getmembers(
                mod_obj
            ):  # pylint: disable=unused-variable
                if inspect.isclass(plat_obj) and issubclass(
                    plat_obj, capirca.lib.aclgenerator.ACLGenerator
                ):
                    log.debug("Identified Capirca class %s for %s", plat_obj, platform)
                    return plat_obj
    log.error("Unable to identify any Capirca plaform class for %s", platform)
def _get_services_mapping():
    if _SERVICES:
        return _SERVICES
    services_txt = ""
    try:
        with salt.utils.files.fopen("/etc/services", "r") as srv_f:
            services_txt = salt.utils.stringutils.to_unicode(srv_f.read())
    except OSError as ioe:
        log.error("Unable to read from /etc/services:")
        log.error(ioe)
        return _SERVICES  # no mapping possible, sorry
    service_rgx = re.compile(r"^([a-zA-Z0-9-]+)\s+(\d+)\/(tcp|udp)(.*)$")
    for line in services_txt.splitlines():
        service_rgx_s = service_rgx.search(line)
        if service_rgx_s and len(service_rgx_s.groups()) == 4:
            srv_name, port, protocol, _ = service_rgx_s.groups()
            if srv_name not in _SERVICES:
                _SERVICES[srv_name] = {"port": [], "protocol": []}
            try:
                _SERVICES[srv_name]["port"].append(int(port))
            except ValueError as verr:
                log.error(verr)
                log.error("Did not read that properly:")
                log.error(line)
                log.error(
                    "Please report the above error: %s does not seem a valid port"
                    " value!",
                    port,
                )
            _SERVICES[srv_name]["protocol"].append(protocol)
    return _SERVICES
def _translate_port(port):
    services = _get_services_mapping()
    if port in services and services[port]["port"]:
        return services[port]["port"][0]
    return port
def _make_it_list(dict_, field_name, value):
    prev_value = []
    if field_name in dict_:
        prev_value = dict_[field_name]
    if value is None:
        return prev_value
    elif isinstance(value, (tuple, list)):
        if field_name in ("source_port", "destination_port"):
            portval = []
            for port in value:
                if not isinstance(port, (tuple, list)):
                    portval.append((port, port))
                else:
                    portval.append(port)
            translated_portval = []
            for port_start, port_end in portval:
                if not isinstance(port_start, int):
                    port_start = _translate_port(port_start)
                if not isinstance(port_end, int):
                    port_end = _translate_port(port_end)
                translated_portval.append((port_start, port_end))
            return list(set(prev_value + translated_portval))
        return list(set(prev_value + list(value)))
    if field_name in ("source_port", "destination_port"):
        if not isinstance(value, int):
            value = _translate_port(value)
        return list(set(prev_value + [(value, value)]))  # a list of tuples
    return list(set(prev_value + [value]))
def _clean_term_opts(term_opts):
    clean_opts = {}
    _services = _get_services_mapping()
    for field, value in term_opts.items():
        if field == "source_service" and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug("Processing special source services:")
            log.debug(value)
            for service in value:
                if service and service in _services:
                    clean_opts["source_port"] = _make_it_list(
                        clean_opts, "source_port", _services[service]["port"]
                    )
<a name="2"></a>                    clean_opts["protocol"] = _make_it_list(
                        clean_opts, "protocol", _services[service]["protocol"]
                    )
            log<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.debug(
                "Built source_port field, after processing special source services:"
            )
            log.debug(clean_opts.get("source_port"))
            log.debug("Built protocol field, after processing special source services:")
            log.debug(clean_opts.get(</b></font>"protocol"))
        elif field == "destination_service" and value:
            if isinstance(value, str):
                value = _make_it_list(clean_opts, field, value)
            log.debug("Processing special destination services:")
            log.debug(value)
            for service in value:
                if service and service in _services:
                    clean_opts["destination_port"] = _make_it_list(
                        clean_opts, "destination_port", _services[service]["port"]
                    )
<a name="0"></a>                    clean_opts["protocol"] = _make_it_list(
                        clean_opts, "protocol", _services[service]["protocol"]
                    )
            log<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.debug(
                "Built source_port field, after processing special destination"
                " services:"
            )
            log.debug(clean_opts.get("destination_service"))
            log.debug(
                "Built protocol field, after processing special destination services:"
            )
            log.debug(clean_opts.get("protocol"))
        elif field in _TERM_FIELDS and value and value != _TERM_FIELDS[</b></font>field]:
            if isinstance(_TERM_FIELDS[field], list):
                value = _make_it_list(clean_opts, field, value)
            if field in _IP_FILEDS:
                ip_values = []
                for addr in value:
                    ip_values.append(capirca.lib.policy.nacaddr.IP(addr))
                value = ip_values[:]
            clean_opts[field] = value
    return clean_opts
def _lookup_element(lst, key):
    if not lst:
        return {}
    for ele in lst:
        if not ele or not isinstance(ele, dict):
            continue
        if key in ele:
            return ele[key]
    return {}
def _get_pillar_cfg(pillar_key, pillarenv=None, saltenv=None):
    pillar_cfg = __salt__["pillar.get"](
        pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    return pillar_cfg
def _cleanup(lst):
    clean = []
    for ele in lst:
        if ele and isinstance(ele, dict):
            clean.append(ele)
    return clean
def _merge_list_of_dict(first, second, prepend=True):
    first = _cleanup(first)
    second = _cleanup(second)
    if not first and not second:
        return []
    if not first and second:
        return second
    if first and not second:
        return first
    overlaps = []
    merged = []
    appended = []
    for ele in first:
        if _lookup_element(second, next(iter(ele))):
            overlaps.append(ele)
        elif prepend:
            merged.append(ele)
        elif not prepend:
            appended.append(ele)
    for ele in second:
        ele_key = next(iter(ele))
        if _lookup_element(overlaps, ele_key):
            ele_val_first = _lookup_element(first, ele_key)
            merged.append({ele_key: ele_val_first})
        else:
            merged.append(ele)
    if not prepend:
        merged.extend(appended)
    return merged
def _get_term_object(
    filter_name,
    term_name,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    **term_fields
):
    log.debug("Generating config for term %s under filter %s", term_name, filter_name)
    term = _Term()
    term.name = term_name
    term_opts = {}
    if merge_pillar:
        term_opts = get_term_pillar(
            filter_name,
            term_name,
            pillar_key=pillar_key,
            saltenv=saltenv,
            pillarenv=pillarenv,
        )
        log.debug("Merging with pillar data:")
        log.debug(term_opts)
        term_opts = _clean_term_opts(term_opts)
        log.debug("Cleaning up pillar data:")
        log.debug(term_opts)
    log.debug("Received processing opts:")
    log.debug(term_fields)
    log.debug("Cleaning up processing opts:")
    term_fields = _clean_term_opts(term_fields)
    log.debug(term_fields)
    log.debug("Final term opts:")
    term_opts.update(term_fields)
    log.debug(term_fields)
    for field, value in term_opts.items():
        setattr(term, field, value)
    log.debug("Term config:")
    log.debug(str(term))
    return term
def _get_policy_object(
    platform,
    filters=None,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
):
    policy = _Policy()
    policy_filters = []
    if not filters:
        filters = []
    for filter_ in filters:
        if not filter_ or not isinstance(filter_, dict):
            continue  # go to the next filter
        filter_name, filter_config = next(iter(filter_.items()))
        header = capirca.lib.policy.Header()  # same header everywhere
        target_opts = [platform, filter_name]
        filter_options = filter_config.pop("options", None)
        if filter_options:
            filter_options = _make_it_list({}, filter_name, filter_options)
            target_opts.extend(filter_options)
        target = capirca.lib.policy.Target(target_opts)
        header.AddObject(target)
        filter_terms = []
        for term_ in filter_config.get("terms", []):
            if term_ and isinstance(term_, dict):
                term_name, term_fields = next(iter(term_.items()))
                term = _get_term_object(
                    filter_name,
                    term_name,
                    pillar_key=pillar_key,
                    pillarenv=pillarenv,
                    saltenv=saltenv,
                    merge_pillar=merge_pillar,
                    **term_fields
                )
            filter_terms.append(term)
        policy_filters.append((header, filter_terms))
    policy.filters = policy_filters
    log.debug("Policy config:")
    log.debug(str(policy))
    platform_generator = _import_platform_generator(platform)
    policy_config = platform_generator(policy, 2)
    log.debug("Generating policy config for %s:", platform)
    log.debug(str(policy_config))
    return policy_config
def _revision_tag(
    text,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    timestamp = datetime.datetime.now().strftime(revision_date_format)
    new_text = []
    for line in text.splitlines():
        if "$Id:$" in line:
            if not revision_id:  # if no explicit revision ID required
                continue  # jump to next line, ignore this one
            line = line.replace("$Id:$", "$Id: {rev_id} $".format(rev_id=revision_id))
        if "$Revision:$" in line:
            if not revision_no:  # if no explicit revision number required
                continue  # jump to next line, ignore this one
            line = line.replace(
                "$Revision:$", "$Revision: {rev_no} $".format(rev_no=revision_no)
            )
        if "$Date:$" in line:
            if not revision_date:
                continue  # jump
            line = line.replace("$Date:$", "$Date: {ts} $".format(ts=timestamp))
        new_text.append(line)
    return "\n".join(new_text)
def get_term_config(
    platform,
    filter_name,
    term_name,
    filter_options=None,
<a name="1"></a>    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=True,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
    source_service=None,
    destination_service=None,
    **term_fields
):
    terms = []
    term = {term_name: {}}
    term[term_name].</b></font>update(term_fields)
    term[term_name].update(
        {
            "source_service": _make_it_list({}, "source_service", source_service),
            "destination_service": _make_it_list(
                {}, "destination_service", destination_service
            ),
        }
    )
    terms.append(term)
    if not filter_options:
        filter_options = []
    return get_filter_config(
        platform,
        filter_name,
        filter_options=filter_options,
        terms=terms,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )
def get_filter_config(
    platform,
    filter_name,
    filter_options=None,
    terms=None,
    prepend=True,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    if not filter_options:
        filter_options = []
    if not terms:
        terms = []
    if merge_pillar and not only_lower_merge:
        acl_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        filter_pillar_cfg = _lookup_element(acl_pillar_cfg, filter_name)
        filter_options = filter_options or filter_pillar_cfg.pop("options", None)
        if filter_pillar_cfg:
            pillar_terms = filter_pillar_cfg.get(
                "terms", []
            )  # No problem if empty in the pillar
            terms = _merge_list_of_dict(terms, pillar_terms, prepend=prepend)
    filters = []
    filters.append(
        {
            filter_name: {
                "options": _make_it_list({}, filter_name, filter_options),
                "terms": terms,
            }
        }
    )
    return get_policy_config(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
        only_lower_merge=True,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )
def get_policy_config(
    platform,
    filters=None,
    prepend=True,
    pillar_key="acl",
    pillarenv=None,
    saltenv=None,
    merge_pillar=True,
    only_lower_merge=False,
    revision_id=None,
    revision_no=None,
    revision_date=True,
    revision_date_format="%Y/%m/%d",
):
    if not filters:
        filters = []
    if merge_pillar and not only_lower_merge:
        policy_pillar_cfg = _get_pillar_cfg(
            pillar_key, saltenv=saltenv, pillarenv=pillarenv
        )
        filters = _merge_list_of_dict(filters, policy_pillar_cfg, prepend=prepend)
    policy_object = _get_policy_object(
        platform,
        filters=filters,
        pillar_key=pillar_key,
        pillarenv=pillarenv,
        saltenv=saltenv,
        merge_pillar=merge_pillar,
    )
    policy_text = str(policy_object)
    return _revision_tag(
        policy_text,
        revision_id=revision_id,
        revision_no=revision_no,
        revision_date=revision_date,
        revision_date_format=revision_date_format,
    )
def get_filter_pillar(filter_name, pillar_key="acl", pillarenv=None, saltenv=None):
    pillar_cfg = _get_pillar_cfg(pillar_key, pillarenv=pillarenv, saltenv=saltenv)
    return _lookup_element(pillar_cfg, filter_name)
def get_term_pillar(
    filter_name, term_name, pillar_key="acl", pillarenv=None, saltenv=None
):
    filter_pillar_cfg = get_filter_pillar(
        filter_name, pillar_key=pillar_key, pillarenv=pillarenv, saltenv=saltenv
    )
    term_pillar_cfg = filter_pillar_cfg.get("terms", [])
    term_opts = _lookup_element(term_pillar_cfg, term_name)
    return term_opts
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_network_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import socket
import textwrap
import time
import pytest
import salt.exceptions
import salt.utils.network as network
from salt._compat import ipaddress
from tests.support.mock import MagicMock, create_autospec, mock_open, patch
from tests.support.unit import TestCase
<a name="1"></a>
log = logging.getLogger(__name__)
LINUX <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= """\
eth0      Link encap:Ethernet  HWaddr e0:3f:49:85:6a:af
          inet addr:10.10.10.56  Bcast:10.10.10.255  Mask:255.255.252.0
          inet6 addr: fe80::e23f:49ff:fe85:6aaf/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:643363 errors:0 dropped:0 overruns:0 frame:0
          TX packets:196539 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:386388355 (368.4 MiB)  TX bytes:25600939 (24.4 MiB)
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:548901 errors:0 dropped:0 overruns:0 frame:0
          TX packets:548901 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:613479895 (585.0 MiB)  TX bytes:613479895 (585.0 MiB)
SOLARIS = """\
lo0: flags=2001000849&lt;UP,LOOPBACK,RUNNING,MULTICAST,IPv4,VIRTUAL&gt; mtu 8232 index 1
        inet 127.0.0.1 netmask ff000000
net0: flags=100001100943&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST,ROUTER,IPv4,PHYSRUNNING&gt; mtu 1500 index 2
        inet 10.10.10.38 netmask ffffffe0 broadcast 10.10.10.63
ilbint0: flags=110001100843&lt;UP,BROADCAST,RUNNING,MULTICAST,ROUTER,IPv4,VRRP,PHYSRUNNING&gt; mtu 1500 index 3
        inet 10.6.0.11 netmask ffffff00 broadcast 10.6.0.255
ilbext0: flags=110001100843&lt;UP,BROADCAST,RUNNING,MULTICAST,ROUTER,IPv4,VRRP,PHYSRUNNING&gt; mtu 1500 index 4
        inet 10.10.11.11 netmask ffffffe0 broadcast 10.10.11.31
ilbext0:1: flags=110001100843&lt;UP,BROADCAST,RUNNING,MULTICAST,ROUTER,IPv4,VRRP,PHYSRUNNING&gt; mtu 1500 index 4
        inet 10.10.11.12 netmask ffffffe0 broadcast 10.10.11.31
vpn0: flags=1000011008d1&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST,ROUTER,IPv4,PHYSRUNNING&gt; mtu 1480 index 5
        inet tunnel src 10.10.11.12 tunnel dst 10.10.5.5
        tunnel hop limit 64
        inet 10.6.0.14 --&gt; 10.6.0.15 netmask ff000000
lo0: flags=2002000849&lt;UP,LOOPBACK,RUNNING,MULTICAST,IPv6,VIRTUAL&gt; mtu 8252 index 1
        inet6 ::1/128
net0: flags=120002004941&lt;UP,RUNNING,PROMISC,MULTICAST,DHCP,IPv6,PHYSRUNNING&gt; mtu 1500 index 2
        inet6 fe80::221:9bff:fefd:2a22/10
ilbint0: flags=120002000840&lt;RUNNING,MULTICAST,IPv6,PHYSRUNNING&gt; mtu 1500 index 3
        inet6 ::/0
ilbext0: flags=120002000840&lt;RUNNING,MULTICAST,IPv6,PHYSRUNNING&gt; mtu 1500 index 4
        inet6 ::/0
vpn0: flags=120002200850&lt;POINTOPOINT,RUNNING,MULTICAST,NONUD,IPv6,PHYSRUNNING&gt; mtu 1480 index 5
        inet tunnel src 10.10.11.12 tunnel dst 10.10.5.5
        tunnel hop limit 64
        inet6 ::/0 --&gt; fe80::b2d6:7c10
"""
NETBSD = """\
vioif0: flags=0x8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
        ec_capabilities=1&lt;VLAN_MTU&gt;
        ec_enabled=0
        address: 00:a0:98:e6:83:18
        inet 192.168.1.80/24 broadcast 192.168.1.255 flags 0x0
        inet6 fe80::2a0:98ff:fee6:8318%vioif0/64 flags 0x0 scopeid 0x1
lo0: flags=0x8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33624
        inet 127.0.0.1/8 flags 0x0
        inet6 ::1/128 flags 0x20&lt;NODAD&gt;
        inet6 fe80::1%lo0/64 flags 0x0 scopeid 0x2
FREEBSD_SOCKSTAT_WITH_FAT_PID = """\
USER     COMMAND    PID   FD PROTO  LOCAL ADDRESS    FOREIGN ADDRESS
salt-master python2.781106 35 tcp4  127.0.0.1:61115  127.0.0.1:4506
LINUX_NETLINK_SS_OUTPUT = """\
State       Recv-Q Send-Q                                                            Local Address:Port                                                                           Peer Address:Port
TIME-WAIT   0      0                                                                         [::1]:8009                                                                                  [::1]:40368
LISTEN      0      128                                                                   127.0.0.1:5903                                                                                0.0.0.0:*
ESTAB       0      0                                                            [::ffff:127.0.0.1]:4506                                                                    [::ffff:127.0.0.1]:32315
ESTAB       0      0                                                                 192.168.122.1:4506                                                                       192.168.122.177:24545
    False: ("10.10.0.0"</b></font>, "10.10.0.0/33", "FOO", 9, "0.9.800.1000/24"),
}
IPV6_SUBNETS = {
    True: ("::1/128",),
    False: ("::1", "::1/129", "FOO", 9, "aj01::feac/64"),
}
class NetworkTestCase(TestCase):
    def test_sanitize_host_ip(self):
        ret = network.sanitize_host("10.1./2.$3")
        self.assertEqual(ret, "10.1.2.3")
    def test_sanitize_host_name(self):
        ret = network.sanitize_host("foo_bar")
        self.assertEqual(ret, "foo_bar")
    def test_host_to_ips(self):
        def _side_effect(host, *args):
            try:
                return {
                    "github.com": [
                        (2, 1, 6, "", ("192.30.255.112", 0)),
                        (2, 1, 6, "", ("192.30.255.113", 0)),
                    ],
                    "ipv6host.foo": [
                        (socket.AF_INET6, 1, 6, "", ("2001:a71::1", 0, 0, 0)),
                    ],
                }[host]
            except KeyError:
                raise socket.gaierror(-2, "Name or service not known")
        getaddrinfo_mock = MagicMock(side_effect=_side_effect)
        with patch.object(socket, "getaddrinfo", getaddrinfo_mock):
            ret = network.host_to_ips("github.com")
            self.assertEqual(ret, ["192.30.255.112", "192.30.255.113"])
            ret = network.host_to_ips("ipv6host.foo")
            self.assertEqual(ret, ["2001:a71::1"])
            ret = network.host_to_ips("someothersite.com")
            self.assertEqual(ret, None)
    def test_generate_minion_id(self):
        self.assertTrue(network.generate_minion_id())
    def test__generate_minion_id_with_unicode_in_etc_hosts(self):
        content = textwrap.dedent(
        )
        fopen_mock = mock_open(read_data={"/etc/hosts": content})
        with patch("salt.utils.files.fopen", fopen_mock):
<a name="2"></a>            assert "thisismyhostname" in network._generate_minion_id()
    def test_is_ip(self):
        self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertTrue(network.is_ip("10.10.0.3"))
        self.assertFalse(network.is_ip("0.9.800.1000"))
<a name="0"></a>        self.assertFalse(network.is_ipv6(</b></font>"sixteen-char-str"))
    def test_is_ipv4(self):
        self<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertTrue(network.is_ipv4("10.10.0.3"))
        self.assertFalse(network.is_ipv4("10.100.1"))
        self.assertFalse(network.is_ipv4("2001:db8:0:1:1:1:1:1"))
        self.</b></font>assertFalse(network.is_ipv4("sixteen-char-str"))
    def test_is_ipv6(self):
        self.assertTrue(network.is_ipv6("2001:db8:0:1:1:1:1:1"))
        self.assertTrue(network.is_ipv6("0:0:0:0:0:0:0:1"))
        self.assertTrue(network.is_ipv6("::1"))
        self.assertTrue(network.is_ipv6("::"))
        self.assertTrue(network.is_ipv6("2001:0db8:85a3:0000:0000:8a2e:0370:7334"))
        self.assertTrue(network.is_ipv6("2001:0db8:85a3::8a2e:0370:7334"))
        self.assertFalse(network.is_ipv6("2001:0db8:0370:7334"))
        self.assertFalse(network.is_ipv6("2001:0db8:::0370:7334"))
        self.assertFalse(network.is_ipv6("10.0.1.2"))
        self.assertFalse(network.is_ipv6("2001.0db8.85a3.0000.0000.8a2e.0370.7334"))
        self.assertFalse(network.is_ipv6("sixteen-char-str"))
    def test_ipv6(self):
        self.assertTrue(network.ipv6("2001:db8:0:1:1:1:1:1"))
        self.assertTrue(network.ipv6("0:0:0:0:0:0:0:1"))
        self.assertTrue(network.ipv6("::1"))
        self.assertTrue(network.ipv6("::"))
        self.assertTrue(network.ipv6("2001:0db8:85a3:0000:0000:8a2e:0370:7334"))
        self.assertTrue(network.ipv6("2001:0db8:85a3::8a2e:0370:7334"))
        self.assertTrue(network.ipv6("2001:67c:2e8::/48"))
    def test_parse_host_port(self):
        _ip = ipaddress.ip_address
        good_host_ports = {
            "10.10.0.3": (_ip("10.10.0.3").compressed, None),
            "10.10.0.3:1234": (_ip("10.10.0.3").compressed, 1234),
            "2001:0db8:85a3::8a2e:0370:7334": (
                _ip("2001:0db8:85a3::8a2e:0370:7334").compressed,
                None,
            ),
            "[2001:0db8:85a3::8a2e:0370:7334]:1234": (
                _ip("2001:0db8:85a3::8a2e:0370:7334").compressed,
                1234,
            ),
            "2001:0db8:85a3::7334": (_ip("2001:0db8:85a3::7334").compressed, None),
            "[2001:0db8:85a3::7334]:1234": (
                _ip("2001:0db8:85a3::7334").compressed,
                1234,
            ),
        }
        bad_host_ports = [
            "10.10.0.3/24",
            "10.10.0.3::1234",
            "2001:0db8:0370:7334",
            "2001:0db8:0370::7334]:1234",
            "2001:0db8:0370:0:a:b:c:d:1234",
            "host name",
            "host name:1234",
            "10.10.0.3:abcd",
        ]
        for host_port, assertion_value in good_host_ports.items():
            host = port = None
            host, port = network.parse_host_port(host_port)
            self.assertEqual((host, port), assertion_value)
        for host_port in bad_host_ports:
            try:
                self.assertRaises(ValueError, network.parse_host_port, host_port)
            except AssertionError as _e_:
                log.error(
                    'bad host_port value: "%s" failed to trigger ValueError exception',
                    host_port,
                )
                raise _e_
    def test_dns_check(self):
        hosts = [
            {
                "host": "10.10.0.3",
                "port": "",
                "mocked": [(2, 1, 6, "", ("10.10.0.3", 0))],
                "ret": "10.10.0.3",
            },
            {
                "host": "10.10.0.3",
                "port": "1234",
                "mocked": [(2, 1, 6, "", ("10.10.0.3", 0))],
                "ret": "10.10.0.3",
            },
            {
                "host": "2001:0db8:85a3::8a2e:0370:7334",
                "port": "",
                "mocked": [(10, 1, 6, "", ("2001:db8:85a3::8a2e:370:7334", 0, 0, 0))],
                "ret": "[2001:db8:85a3::8a2e:370:7334]",
            },
            {
                "host": "2001:0db8:85a3::8a2e:370:7334",
                "port": "1234",
                "mocked": [(10, 1, 6, "", ("2001:db8:85a3::8a2e:370:7334", 0, 0, 0))],
                "ret": "[2001:db8:85a3::8a2e:370:7334]",
            },
            {
                "host": "salt-master",
                "port": "1234",
                "mocked": [(2, 1, 6, "", ("127.0.0.1", 0))],
                "ret": "127.0.0.1",
            },
        ]
        for host in hosts:
            with patch.object(
                socket,
                "getaddrinfo",
                create_autospec(socket.getaddrinfo, return_value=host["mocked"]),
            ):
                with patch("socket.socket", create_autospec(socket.socket)):
                    ret = network.dns_check(host["host"], host["port"])
                    self.assertEqual(ret, host["ret"])
    def test_dns_check_ipv6_filter(self):
        with patch.object(
            socket,
            "getaddrinfo",
            create_autospec(socket.getaddrinfo, side_effect=Exception),
        ) as getaddrinfo:
            for ipv6, param in [
                (None, socket.AF_UNSPEC),
                (True, socket.AF_INET6),
                (False, socket.AF_INET),
            ]:
                with self.assertRaises(Exception):
                    network.dns_check("foo", "1", ipv6=ipv6)
                getaddrinfo.assert_called_with("foo", "1", param, socket.SOCK_STREAM)
    def test_dns_check_errors(self):
        with patch.object(
            socket, "getaddrinfo", create_autospec(socket.getaddrinfo, return_value=[])
        ):
            with self.assertRaisesRegex(
                salt.exceptions.SaltSystemExit,
                "DNS lookup or connection check of 'foo' failed",
            ):
                network.dns_check("foo", "1")
        with patch.object(
            socket,
            "getaddrinfo",
            create_autospec(socket.getaddrinfo, side_effect=TypeError),
        ):
            with self.assertRaisesRegex(
                salt.exceptions.SaltSystemExit, "Invalid or unresolveable address"
            ):
                network.dns_check("foo", "1")
    def test_test_addrs(self):
        addrinfo = [
            (30, 2, 17, "", ("2600:9000:21eb:a800:8:1031:abc0:93a1", 0, 0, 0)),
            (30, 1, 6, "", ("2600:9000:21eb:a800:8:1031:abc0:93a1", 0, 0, 0)),
            (30, 2, 17, "", ("2600:9000:21eb:b400:8:1031:abc0:93a1", 0, 0, 0)),
            (30, 1, 6, "", ("2600:9000:21eb:b400:8:1031:abc0:93a1", 0, 0, 0)),
            (2, 1, 6, "", ("13.35.99.52", 0)),
            (2, 2, 17, "", ("13.35.99.85", 0)),
            (2, 1, 6, "", ("13.35.99.85", 0)),
            (2, 2, 17, "", ("13.35.99.122", 0)),
        ]
        with patch("socket.socket", create_autospec(socket.socket)) as s:
            addrs = network._test_addrs(addrinfo, 80)
            self.assertTrue(len(addrs) == 1)
            self.assertTrue(addrs[0] == addrinfo[0][4][0])
            s.side_effect = [socket.error, MagicMock()]
            addrs = network._test_addrs(addrinfo, 80)
            self.assertTrue(len(addrs) == 1)
            self.assertTrue(addrs[0] == addrinfo[2][4][0])
            s.side_effect = socket.error
            addrs = network._test_addrs(addrinfo, 80)
            time.sleep(2)
            self.assertFalse(len(addrs) == 0)
            s.side_effect = socket.error
            addrs = network._test_addrs(addrinfo, 80)
            self.assertTrue(len(addrs) == 5)
    def test_is_subnet(self):
        for subnet_data in (IPV4_SUBNETS, IPV6_SUBNETS):
            for item in subnet_data[True]:
                log.debug("Testing that %s is a valid subnet", item)
                self.assertTrue(network.is_subnet(item))
            for item in subnet_data[False]:
                log.debug("Testing that %s is not a valid subnet", item)
                self.assertFalse(network.is_subnet(item))
    def test_is_ipv4_subnet(self):
        for item in IPV4_SUBNETS[True]:
            log.debug("Testing that %s is a valid subnet", item)
            self.assertTrue(network.is_ipv4_subnet(item))
        for item in IPV4_SUBNETS[False]:
            log.debug("Testing that %s is not a valid subnet", item)
            self.assertFalse(network.is_ipv4_subnet(item))
    def test_is_ipv6_subnet(self):
        for item in IPV6_SUBNETS[True]:
            log.debug("Testing that %s is a valid subnet", item)
            self.assertTrue(network.is_ipv6_subnet(item))
        for item in IPV6_SUBNETS[False]:
            log.debug("Testing that %s is not a valid subnet", item)
            self.assertFalse(network.is_ipv6_subnet(item))
    def test_cidr_to_ipv4_netmask(self):
        self.assertEqual(network.cidr_to_ipv4_netmask(24), "255.255.255.0")
        self.assertEqual(network.cidr_to_ipv4_netmask(21), "255.255.248.0")
        self.assertEqual(network.cidr_to_ipv4_netmask(17), "255.255.128.0")
        self.assertEqual(network.cidr_to_ipv4_netmask(9), "255.128.0.0")
        self.assertEqual(network.cidr_to_ipv4_netmask(36), "")
        self.assertEqual(network.cidr_to_ipv4_netmask("lol"), "")
    def test_number_of_set_bits_to_ipv4_netmask(self):
        set_bits_to_netmask = network._number_of_set_bits_to_ipv4_netmask(0xFFFFFF00)
        self.assertEqual(set_bits_to_netmask, "255.255.255.0")
        set_bits_to_netmask = network._number_of_set_bits_to_ipv4_netmask(0xFFFF6400)
    def test_hex2ip(self):
        self.assertEqual(network.hex2ip("0x4A7D2B63"), "74.125.43.99")
        self.assertEqual(network.hex2ip("0x4A7D2B63", invert=True), "99.43.125.74")
        self.assertEqual(
            network.hex2ip("00000000000000000000FFFF7F000001"), "127.0.0.1"
        )
        self.assertEqual(
            network.hex2ip("0000000000000000FFFF00000100007F", invert=True), "127.0.0.1"
        )
        self.assertEqual(
            network.hex2ip("20010DB8000000000000000000000000"), "2001:db8::"
        )
        self.assertEqual(
            network.hex2ip("B80D0120000000000000000000000000", invert=True),
            "2001:db8::",
        )
    def test_interfaces_ifconfig_linux(self):
        interfaces = network._interfaces_ifconfig(LINUX)
        self.assertEqual(
            interfaces,
            {
                "eth0": {
                    "hwaddr": "e0:3f:49:85:6a:af",
                    "inet": [
                        {
                            "address": "10.10.10.56",
                            "broadcast": "10.10.10.255",
                            "netmask": "255.255.252.0",
                        }
                    ],
                    "inet6": [
                        {
                            "address": "fe80::e23f:49ff:fe85:6aaf",
                            "prefixlen": "64",
                            "scope": "link",
                        }
                    ],
                    "up": True,
                },
                "lo": {
                    "inet": [{"address": "127.0.0.1", "netmask": "255.0.0.0"}],
                    "inet6": [{"address": "::1", "prefixlen": "128", "scope": "host"}],
                    "up": True,
                },
            },
        )
    def test_interfaces_ifconfig_freebsd(self):
        interfaces = network._interfaces_ifconfig(FREEBSD)
        self.assertEqual(
            interfaces,
            {
                "": {"up": False},
                "em0": {
                    "hwaddr": "00:30:48:ff:ff:ff",
                    "inet": [
                        {
                            "address": "10.10.10.250",
                            "broadcast": "10.10.10.255",
                            "netmask": "255.255.255.224",
                        },
                        {
                            "address": "10.10.10.56",
                            "broadcast": "10.10.10.63",
                            "netmask": "255.255.255.192",
                        },
                    ],
                    "up": True,
                },
                "em1": {"hwaddr": "00:30:48:aa:aa:aa", "up": False},
                "lo0": {
                    "inet": [{"address": "127.0.0.1", "netmask": "255.0.0.0"}],
                    "inet6": [
                        {"address": "fe80::1", "prefixlen": "64", "scope": "0x8"},
                        {"address": "::1", "prefixlen": "128", "scope": None},
                    ],
                    "up": True,
                },
                "plip0": {"up": False},
                "tun0": {
                    "inet": [{"address": "10.12.0.1", "netmask": "255.255.255.255"}],
                    "up": True,
                },
            },
        )
    def test_interfaces_ifconfig_solaris(self):
        with patch("salt.utils.platform.is_sunos", lambda: True):
            interfaces = network._interfaces_ifconfig(SOLARIS)
            expected_interfaces = {
                "ilbint0": {
                    "inet6": [],
                    "inet": [
                        {
                            "broadcast": "10.6.0.255",
                            "netmask": "255.255.255.0",
                            "address": "10.6.0.11",
                        }
                    ],
                    "up": True,
                },
                "lo0": {
                    "inet6": [{"prefixlen": "128", "address": "::1"}],
                    "inet": [{"netmask": "255.0.0.0", "address": "127.0.0.1"}],
                    "up": True,
                },
                "ilbext0": {
                    "inet6": [],
                    "inet": [
                        {
                            "broadcast": "10.10.11.31",
                            "netmask": "255.255.255.224",
                            "address": "10.10.11.11",
                        },
                        {
                            "broadcast": "10.10.11.31",
                            "netmask": "255.255.255.224",
                            "address": "10.10.11.12",
                        },
                    ],
                    "up": True,
                },
                "vpn0": {
                    "inet6": [],
                    "inet": [{"netmask": "255.0.0.0", "address": "10.6.0.14"}],
                    "up": True,
                },
                "net0": {
                    "inet6": [
                        {"prefixlen": "10", "address": "fe80::221:9bff:fefd:2a22"}
                    ],
                    "inet": [
                        {
                            "broadcast": "10.10.10.63",
                            "netmask": "255.255.255.224",
                            "address": "10.10.10.38",
                        }
                    ],
                    "up": True,
                },
            }
            self.assertEqual(interfaces, expected_interfaces)
    def test_interfaces_ifconfig_netbsd(self):
        interfaces = network._netbsd_interfaces_ifconfig(NETBSD)
        self.assertEqual(
            interfaces,
            {
                "lo0": {
                    "inet": [{"address": "127.0.0.1", "netmask": "255.0.0.0"}],
                    "inet6": [
                        {"address": "fe80::1", "prefixlen": "64", "scope": "lo0"}
                    ],
                    "up": True,
                },
                "vioif0": {
                    "hwaddr": "00:a0:98:e6:83:18",
                    "inet": [
                        {
                            "address": "192.168.1.80",
                            "broadcast": "192.168.1.255",
                            "netmask": "255.255.255.0",
                        }
                    ],
                    "inet6": [
                        {
                            "address": "fe80::2a0:98ff:fee6:8318",
                            "prefixlen": "64",
                            "scope": "vioif0",
                        }
                    ],
                    "up": True,
                },
            },
        )
    def test_freebsd_remotes_on(self):
        with patch("salt.utils.platform.is_sunos", lambda: False):
            with patch("salt.utils.platform.is_freebsd", lambda: True):
                with patch("subprocess.check_output", return_value=FREEBSD_SOCKSTAT):
                    remotes = network._freebsd_remotes_on("4506", "remote")
                    self.assertEqual(remotes, {"127.0.0.1"})
    def test_freebsd_remotes_on_with_fat_pid(self):
        with patch("salt.utils.platform.is_sunos", lambda: False):
            with patch("salt.utils.platform.is_freebsd", lambda: True):
                with patch(
                    "subprocess.check_output",
                    return_value=FREEBSD_SOCKSTAT_WITH_FAT_PID,
                ):
                    remotes = network._freebsd_remotes_on("4506", "remote")
                    self.assertEqual(remotes, {"127.0.0.1"})
    def test_netlink_tool_remote_on_a(self):
        with patch("salt.utils.platform.is_sunos", lambda: False):
            with patch("salt.utils.platform.is_linux", lambda: True):
                with patch(
                    "subprocess.check_output", return_value=LINUX_NETLINK_SS_OUTPUT
                ):
                    remotes = network._netlink_tool_remote_on("4506", "local")
                    self.assertEqual(remotes, {"192.168.122.177", "::ffff:127.0.0.1"})
    def test_netlink_tool_remote_on_b(self):
        with patch("subprocess.check_output", return_value=NETLINK_SS):
            remotes = network._netlink_tool_remote_on("4505", "remote_port")
            self.assertEqual(remotes, {"127.0.0.1", "::ffff:1.2.3.4"})
    def test_generate_minion_id_distinct(self):
        with patch("platform.node", MagicMock(return_value="nodename")), patch(
            "socket.gethostname", MagicMock(return_value="hostname")
        ), patch(
            "socket.getfqdn", MagicMock(return_value="hostname.domainname.blank")
        ), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "attrname", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["1.2.3.4", "5.6.7.8"]),
        ):
            self.assertEqual(
                network._generate_minion_id(),
                [
                    "hostname.domainname.blank",
                    "nodename",
                    "hostname",
                    "1.2.3.4",
                    "5.6.7.8",
                ],
            )
    def test_generate_minion_id_127_name(self):
        with patch("platform.node", MagicMock(return_value="127")), patch(
            "socket.gethostname", MagicMock(return_value="127")
        ), patch(
            "socket.getfqdn", MagicMock(return_value="127.domainname.blank")
        ), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "attrname", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["1.2.3.4", "5.6.7.8"]),
        ):
            self.assertEqual(
                network._generate_minion_id(),
                ["127.domainname.blank", "127", "1.2.3.4", "5.6.7.8"],
            )
    def test_generate_minion_id_127_name_startswith(self):
        with patch("platform.node", MagicMock(return_value="127890")), patch(
            "socket.gethostname", MagicMock(return_value="127890")
        ), patch(
            "socket.getfqdn", MagicMock(return_value="127890.domainname.blank")
        ), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "attrname", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["1.2.3.4", "5.6.7.8"]),
        ):
            self.assertEqual(
                network._generate_minion_id(),
                ["127890.domainname.blank", "127890", "1.2.3.4", "5.6.7.8"],
            )
    def test_generate_minion_id_duplicate(self):
        with patch("platform.node", MagicMock(return_value="hostname")), patch(
            "socket.gethostname", MagicMock(return_value="hostname")
        ), patch("socket.getfqdn", MagicMock(return_value="hostname")), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "hostname", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["1.2.3.4", "1.2.3.4", "1.2.3.4"]),
        ):
            self.assertEqual(network._generate_minion_id(), ["hostname", "1.2.3.4"])
    def test_generate_minion_id_platform_used(self):
        with patch(
            "platform.node", MagicMock(return_value="very.long.and.complex.domain.name")
        ), patch("socket.gethostname", MagicMock(return_value="hostname")), patch(
            "socket.getfqdn", MagicMock(return_value="")
        ), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "hostname", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["1.2.3.4", "1.2.3.4", "1.2.3.4"]),
        ):
            self.assertEqual(
                network.generate_minion_id(), "very.long.and.complex.domain.name"
            )
    def test_generate_minion_id_platform_localhost_filtered(self):
        with patch("platform.node", MagicMock(return_value="localhost")), patch(
            "socket.gethostname", MagicMock(return_value="pick.me")
        ), patch(
            "socket.getfqdn", MagicMock(return_value="hostname.domainname.blank")
        ), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "hostname", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["1.2.3.4", "1.2.3.4", "1.2.3.4"]),
        ):
            self.assertEqual(network.generate_minion_id(), "hostname.domainname.blank")
    def test_generate_minion_id_platform_localhost_filtered_all(self):
        with patch("platform.node", MagicMock(return_value="localhost")), patch(
            "socket.gethostname", MagicMock(return_value="ip6-loopback")
        ), patch("socket.getfqdn", MagicMock(return_value="ip6-localhost")), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "localhost", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(
                return_value=["127.0.0.1", "::1", "fe00::0", "fe02::1", "1.2.3.4"]
            ),
        ):
            self.assertEqual(network.generate_minion_id(), "1.2.3.4")
    def test_generate_minion_id_platform_localhost_only(self):
        with patch("platform.node", MagicMock(return_value="localhost")), patch(
            "socket.gethostname", MagicMock(return_value="ip6-loopback")
        ), patch("socket.getfqdn", MagicMock(return_value="ip6-localhost")), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "localhost", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["127.0.0.1", "::1", "fe00::0", "fe02::1"]),
        ):
            self.assertEqual(network.generate_minion_id(), "localhost")
    def test_generate_minion_id_platform_fqdn(self):
        with patch("platform.node", MagicMock(return_value="localhost")), patch(
            "socket.gethostname", MagicMock(return_value="ip6-loopback")
        ), patch("socket.getfqdn", MagicMock(return_value="pick.me")), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "localhost", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["127.0.0.1", "::1", "fe00::0", "fe02::1"]),
        ):
            self.assertEqual(network.generate_minion_id(), "pick.me")
    def test_generate_minion_id_platform_localhost_addrinfo(self):
        with patch("platform.node", MagicMock(return_value="localhost")), patch(
            "socket.gethostname", MagicMock(return_value="ip6-loopback")
        ), patch("socket.getfqdn", MagicMock(return_value="ip6-localhost")), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "pick.me", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(return_value=["127.0.0.1", "::1", "fe00::0", "fe02::1"]),
        ):
            self.assertEqual(network.generate_minion_id(), "pick.me")
    def test_generate_minion_id_platform_ip_addr_only(self):
        with patch("platform.node", MagicMock(return_value="localhost")), patch(
            "socket.gethostname", MagicMock(return_value="ip6-loopback")
        ), patch("socket.getfqdn", MagicMock(return_value="ip6-localhost")), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "localhost", ("127.0.1.1", 0))]),
        ), patch(
            "salt.utils.files.fopen", mock_open()
        ), patch(
            "salt.utils.network.ip_addrs",
            MagicMock(
                return_value=["127.0.0.1", "::1", "fe00::0", "fe02::1", "1.2.3.4"]
            ),
        ):
            self.assertEqual(network.generate_minion_id(), "1.2.3.4")
    def test_gen_mac(self):
        with patch("random.randint", return_value=1) as random_mock:
            self.assertEqual(random_mock.return_value, 1)
            ret = network.gen_mac("00:16:3E")
            expected_mac = "00:16:3E:01:01:01"
            self.assertEqual(ret, expected_mac)
    def test_mac_str_to_bytes(self):
        self.assertRaises(ValueError, network.mac_str_to_bytes, "31337")
        self.assertRaises(ValueError, network.mac_str_to_bytes, "0001020304056")
        self.assertRaises(ValueError, network.mac_str_to_bytes, "00:01:02:03:04:056")
        self.assertRaises(ValueError, network.mac_str_to_bytes, "a0:b0:c0:d0:e0:fg")
        self.assertEqual(
            b"\x10\x08\x06\x04\x02\x00", network.mac_str_to_bytes("100806040200")
        )
        self.assertEqual(
            b"\xf8\xe7\xd6\xc5\xb4\xa3", network.mac_str_to_bytes("f8e7d6c5b4a3")
        )
    @pytest.mark.slow_test
    def test_generate_minion_id_with_long_hostname(self):
        long_name = "localhost-abcdefghijklmnopqrstuvwxyz-abcdefghijklmnopqrstuvwxyz"
        with patch("socket.gethostname", MagicMock(return_value=long_name)):
            minion_id = network.generate_minion_id()
        assert minion_id != "", minion_id
    def test_filter_by_networks_with_no_filter(self):
        ips = ["10.0.123.200", "10.10.10.10"]
        with pytest.raises(TypeError):
            network.filter_by_networks(ips)  # pylint: disable=no-value-for-parameter
    def test_filter_by_networks_empty_filter(self):
        ips = ["10.0.123.200", "10.10.10.10"]
        assert network.filter_by_networks(ips, []) == []
    def test_filter_by_networks_ips_list(self):
        ips = [
            "10.0.123.200",
            "10.10.10.10",
            "193.124.233.5",
            "fe80::d210:cf3f:64e7:5423",
        ]
        networks = ["10.0.0.0/8", "fe80::/64"]
        assert network.filter_by_networks(ips, networks) == [
            "10.0.123.200",
            "10.10.10.10",
            "fe80::d210:cf3f:64e7:5423",
        ]
    def test_filter_by_networks_interfaces_dict(self):
        interfaces = {
            "wlan0": ["192.168.1.100", "217.5.140.67", "2001:db8::ff00:42:8329"],
            "eth0": [
                "2001:0DB8:0:CD30:123:4567:89AB:CDEF",
                "192.168.1.101",
                "10.0.123.201",
            ],
        }
        assert network.filter_by_networks(
            interfaces, ["192.168.1.0/24", "2001:db8::/48"]
        ) == {
            "wlan0": ["192.168.1.100", "2001:db8::ff00:42:8329"],
            "eth0": ["2001:0DB8:0:CD30:123:4567:89AB:CDEF", "192.168.1.101"],
        }
    def test_filter_by_networks_catch_all(self):
        ips = [
            "10.0.123.200",
            "10.10.10.10",
            "193.124.233.5",
            "fe80::d210:cf3f:64e7:5423",
        ]
        assert ips == network.filter_by_networks(ips, ["0.0.0.0/0", "::/0"])
    def test_ip_networks(self):
        interface_data = network._interfaces_ifconfig(LINUX)
        ret = network.ip_networks(interface_data=interface_data)
        assert ret == ["10.10.8.0/22"], ret
        ret = network.ip_networks(interface="eth0", interface_data=interface_data)
        assert ret == ["10.10.8.0/22"], ret
        ret = network.ip_networks(interface="eth0,lo", interface_data=interface_data)
        assert ret == ["10.10.8.0/22"], ret
        ret = network.ip_networks(interface="eth1", interface_data=interface_data)
        assert ret == [], ret
        ret = network.ip_networks(include_loopback=True, interface_data=interface_data)
        assert ret == ["10.10.8.0/22", "127.0.0.0/8"], ret
        ret = network.ip_networks(
            interface="eth0", include_loopback=True, interface_data=interface_data
        )
        assert ret == ["10.10.8.0/22"], ret
        ret = network.ip_networks(
            interface="eth0,lo", include_loopback=True, interface_data=interface_data
        )
        assert ret == ["10.10.8.0/22", "127.0.0.0/8"], ret
        ret = network.ip_networks(
            interface="eth1", include_loopback=True, interface_data=interface_data
        )
        assert ret == [], ret
        ret = network.ip_networks(verbose=True, interface_data=interface_data)
        assert ret == {
            "10.10.8.0/22": {
                "prefixlen": 22,
                "netmask": "255.255.252.0",
                "num_addresses": 1024,
                "address": "10.10.8.0",
            },
        }, ret
        ret = network.ip_networks(
            interface="eth0", verbose=True, interface_data=interface_data
        )
        assert ret == {
            "10.10.8.0/22": {
                "prefixlen": 22,
                "netmask": "255.255.252.0",
                "num_addresses": 1024,
                "address": "10.10.8.0",
            },
        }, ret
        ret = network.ip_networks(
            interface="eth0,lo", verbose=True, interface_data=interface_data
        )
        assert ret == {
            "10.10.8.0/22": {
                "prefixlen": 22,
                "netmask": "255.255.252.0",
                "num_addresses": 1024,
                "address": "10.10.8.0",
            },
        }, ret
        ret = network.ip_networks(
            interface="eth1", verbose=True, interface_data=interface_data
        )
        assert ret == {}, ret
        ret = network.ip_networks(
            include_loopback=True, verbose=True, interface_data=interface_data
        )
        assert ret == {
            "10.10.8.0/22": {
                "prefixlen": 22,
                "netmask": "255.255.252.0",
                "num_addresses": 1024,
                "address": "10.10.8.0",
            },
            "127.0.0.0/8": {
                "prefixlen": 8,
                "netmask": "255.0.0.0",
                "num_addresses": 16777216,
                "address": "127.0.0.0",
            },
        }, ret
        ret = network.ip_networks(
            interface="eth0",
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            "10.10.8.0/22": {
                "prefixlen": 22,
                "netmask": "255.255.252.0",
                "num_addresses": 1024,
                "address": "10.10.8.0",
            },
        }, ret
        ret = network.ip_networks(
            interface="eth0,lo",
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            "10.10.8.0/22": {
                "prefixlen": 22,
                "netmask": "255.255.252.0",
                "num_addresses": 1024,
                "address": "10.10.8.0",
            },
            "127.0.0.0/8": {
                "prefixlen": 8,
                "netmask": "255.0.0.0",
                "num_addresses": 16777216,
                "address": "127.0.0.0",
            },
        }, ret
        ret = network.ip_networks(
            interface="eth1",
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {}, ret
    def test_ip_networks6(self):
        interface_data = network._interfaces_ifconfig(LINUX)
        ret = network.ip_networks6(interface_data=interface_data)
        assert ret == ["fe80::/64"], ret
        ret = network.ip_networks6(interface="eth0", interface_data=interface_data)
        assert ret == ["fe80::/64"], ret
        ret = network.ip_networks6(interface="eth0,lo", interface_data=interface_data)
        assert ret == ["fe80::/64"], ret
        ret = network.ip_networks6(interface="eth1", interface_data=interface_data)
        assert ret == [], ret
        ret = network.ip_networks6(include_loopback=True, interface_data=interface_data)
        assert ret == ["::1/128", "fe80::/64"], ret
        ret = network.ip_networks6(
            interface="eth0", include_loopback=True, interface_data=interface_data
        )
        assert ret == ["fe80::/64"], ret
        ret = network.ip_networks6(
            interface="eth0,lo", include_loopback=True, interface_data=interface_data
        )
        assert ret == ["::1/128", "fe80::/64"], ret
        ret = network.ip_networks6(
            interface="eth1", include_loopback=True, interface_data=interface_data
        )
        assert ret == [], ret
        ret = network.ip_networks6(verbose=True, interface_data=interface_data)
        assert ret == {
            "fe80::/64": {
                "prefixlen": 64,
                "netmask": "ffff:ffff:ffff:ffff::",
                "num_addresses": 18446744073709551616,
                "address": "fe80::",
            },
        }, ret
        ret = network.ip_networks6(
            interface="eth0", verbose=True, interface_data=interface_data
        )
        assert ret == {
            "fe80::/64": {
                "prefixlen": 64,
                "netmask": "ffff:ffff:ffff:ffff::",
                "num_addresses": 18446744073709551616,
                "address": "fe80::",
            },
        }, ret
        ret = network.ip_networks6(
            interface="eth0,lo", verbose=True, interface_data=interface_data
        )
        assert ret == {
            "fe80::/64": {
                "prefixlen": 64,
                "netmask": "ffff:ffff:ffff:ffff::",
                "num_addresses": 18446744073709551616,
                "address": "fe80::",
            },
        }, ret
        ret = network.ip_networks6(
            interface="eth1", verbose=True, interface_data=interface_data
        )
        assert ret == {}, ret
        ret = network.ip_networks6(
            include_loopback=True, verbose=True, interface_data=interface_data
        )
        assert ret == {
            "fe80::/64": {
                "prefixlen": 64,
                "netmask": "ffff:ffff:ffff:ffff::",
                "num_addresses": 18446744073709551616,
                "address": "fe80::",
            },
            "::1/128": {
                "prefixlen": 128,
                "netmask": "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
                "num_addresses": 1,
                "address": "::1",
            },
        }, ret
        ret = network.ip_networks6(
            interface="eth0",
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            "fe80::/64": {
                "prefixlen": 64,
                "netmask": "ffff:ffff:ffff:ffff::",
                "num_addresses": 18446744073709551616,
                "address": "fe80::",
            },
        }, ret
        ret = network.ip_networks6(
            interface="eth0,lo",
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {
            "fe80::/64": {
                "prefixlen": 64,
                "netmask": "ffff:ffff:ffff:ffff::",
                "num_addresses": 18446744073709551616,
                "address": "fe80::",
            },
            "::1/128": {
                "prefixlen": 128,
                "netmask": "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
                "num_addresses": 1,
                "address": "::1",
            },
        }, ret
        ret = network.ip_networks6(
            interface="eth1",
            include_loopback=True,
            verbose=True,
            interface_data=interface_data,
        )
        assert ret == {}, ret
    def test_get_fqhostname_return(self):
        with patch("socket.gethostname", MagicMock(return_value="hostname")), patch(
            "socket.getfqdn",
            MagicMock(return_value="very.long.and.complex.domain.name"),
        ), patch(
            "socket.getaddrinfo",
            MagicMock(return_value=[(2, 3, 0, "hostname", ("127.0.1.1", 0))]),
        ):
            self.assertEqual(network.get_fqhostname(), "hostname")
    def test_get_fqhostname_return_empty_hostname(self):
        host = "hostname"
        with patch("socket.gethostname", MagicMock(return_value=host)), patch(
            "socket.getfqdn",
            MagicMock(return_value="very.long.and.complex.domain.name"),
        ), patch(
            "socket.getaddrinfo",
            MagicMock(
                return_value=[
                    (2, 3, 0, host, ("127.0.1.1", 0)),
                    (2, 3, 0, "", ("127.0.1.1", 0)),
                ]
            ),
        ):
            self.assertEqual(network.get_fqhostname(), host)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
