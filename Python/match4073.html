<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_graphmatrix.py &amp; test_planarity.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_graphmatrix.py &amp; test_planarity.py
      </h3>
<h1 align="center">
        6.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_graphmatrix.py (6.678082%)<th>test_planarity.py (6.1611376%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(31-42)<td><a href="#" name="0">(202-213)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(19-29)<td><a href="#" name="1">(177-178)</a><td align="center"><font color="#ec0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(14-15)<td><a href="#" name="2">(163-173)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_graphmatrix.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import pytest
np = pytest.importorskip("numpy")
pytest.importorskip("scipy")
import networkx as nx
from networkx.generators.degree_seq import havel_hakimi_graph
from networkx.exception import NetworkXError
    deg = [3, 2, 2, 1, 0]
    G = havel_hakimi_graph(deg)
    deg = [<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(1, 0), (1, 0), (1, 0), (2, 0), (1, 0), (2, 1), (0, 1), (0, 1)]
    MG = nx.random_clustered_graph(</b></font>deg, seed=42)
    I = nx.incidence_matrix(G).todense().astype(int)
    expected <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= np.array(
        [[1, 1, 1, 0],
         [0, 1, 0, 1],
         [1, 0, 0, 1],
         [0, 0, 1, 0],
         [0, 0, 0, 0]]
    )
    np.testing.assert_equal(I, expected)
    I =</b></font> nx.incidence_matrix(MG).todense().astype(int)
    expected <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= np.array(
        [[1, 0, 0, 0, 0, 0, 0],
         [1, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 1, 1, 0],
         [0, 0, 0, 0, 0, 1, 1],
         [0, 0, 0, 0, 1, 0, 1]]
    )
    np.testing.</b></font>assert_equal(I, expected)
    with pytest.raises(NetworkXError):
        nx.incidence_matrix(G, nodelist=[0, 1])
class TestGraphMatrix:
    @classmethod
    def setup_class(cls):
        deg = [3, 2, 2, 1, 0]
        cls.G = havel_hakimi_graph(deg)
        cls.OI = np.array(
            [[-1, -1, -1, 0],
             [1, 0, 0, -1],
             [0, 1, 0, 1],
             [0, 0, 1, 0],
             [0, 0, 0, 0]]
        )
        cls.A = np.array(
            [[0, 1, 1, 1, 0],
             [1, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        cls.WG = havel_hakimi_graph(deg)
        cls.WG.add_edges_from(
            (u, v, {"weight": 0.5, "other": 0.3}) for (u, v) in cls.G.edges()
        )
        cls.WA = np.array(
            [[0, 0.5, 0.5, 0.5, 0],
             [0.5, 0, 0.5, 0, 0],
             [0.5, 0.5, 0, 0, 0],
             [0.5, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        cls.MG = nx.MultiGraph(cls.G)
        cls.MG2 = cls.MG.copy()
        cls.MG2.add_edge(0, 1)
        cls.MG2A = np.array(
            [[0, 2, 1, 1, 0],
             [2, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        cls.MGOI = np.array(
            [[-1, -1, -1, -1, 0],
             [1, 1, 0, 0, -1],
             [0, 0, 1, 0, 1],
             [0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0]]
        )
        cls.no_edges_G = nx.Graph([(1, 2), (3, 2, {"weight": 8})])
        cls.no_edges_A = np.array([[0, 0], [0, 0]])
    def test_incidence_matrix(self):
        "Conversion to incidence matrix"
        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)
        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))
        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)
        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))
        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG2),
                edgelist=sorted(self.MG2.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.MGOI)
        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG2.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.MGOI))
    def test_weighted_incidence_matrix(self):
        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)
        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))
        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.OI)
        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=False,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.OI))
        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight="other",
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.OI)
        WMG = nx.MultiGraph(self.WG)
        WMG.add_edge(0, 1, weight=0.5, other=0.3)
        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.MGOI)
        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=False,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.MGOI))
        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight="other",
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.MGOI)
    def test_adjacency_matrix(self):
        "Conversion to adjacency matrix"
        np.testing.assert_equal(nx.adjacency_matrix(self.G).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG2).todense(), self.MG2A)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.G, nodelist=[0, 1]).todense(), self.A[:2, :2]
        )
        np.testing.assert_equal(nx.adjacency_matrix(self.WG).todense(), self.WA)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight=None).todense(), self.A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.MG2, weight=None).todense(), self.MG2A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight="other").todense(), 0.6 * self.WA
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.no_edges_G, nodelist=[1, 3]).todense(),
            self.no_edges_A,
        )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_planarity.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import pytest
import networkx as nx
from networkx.algorithms.planarity import get_counterexample
from networkx.algorithms.planarity import get_counterexample_recursive
from networkx.algorithms.planarity import check_planarity_recursive
class TestLRPlanarity:
    """Nose Unit tests for the :mod:`networkx.algorithms.planarity` module.
    Tests three things:
    1. Check that the result is correct
        (returns planar if and only if the graph is actually planar)
    2. In case a counter example is returned: Check if it is correct
    3. In case an embedding is returned: Check if its actually an embedding
    """
    @staticmethod
    def check_graph(G, is_planar=None):
        """Raises an exception if the lr_planarity check returns a wrong result
        Parameters
        ----------
        G : NetworkX graph
        is_planar : bool
            The expected result of the planarity check.
            If set to None only counter example or embedding are verified.
        """
        is_planar_lr, result = nx.check_planarity(G, True)
        is_planar_lr_rec, result_rec = check_planarity_recursive(G, True)
        if is_planar is not None:
            if is_planar:
                msg = "Wrong planarity check result. Should be planar."
            else:
                msg = "Wrong planarity check result. Should be non-planar."
            assert is_planar == is_planar_lr, msg
            assert is_planar == is_planar_lr_rec, msg
        if is_planar_lr:
            check_embedding(G, result)
            check_embedding(G, result_rec)
        else:
            check_counterexample(G, result)
            check_counterexample(G, result_rec)
    def test_simple_planar_graph(self):
        e = [
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 6),
            (6, 7),
            (7, 1),
            (1, 5),
            (5, 2),
            (2, 4),
            (4, 5),
            (5, 7),
        ]
        self.check_graph(nx.Graph(e), is_planar=True)
    def test_planar_with_selfloop(self):
        e = [
            (1, 1),
            (2, 2),
            (3, 3),
            (4, 4),
            (5, 5),
            (1, 2),
            (1, 3),
            (1, 5),
            (2, 5),
            (2, 4),
            (3, 4),
            (3, 5),
            (4, 5),
        ]
        self.check_graph(nx.Graph(e), is_planar=True)
    def test_k3_3(self):
        self.check_graph(nx.complete_bipartite_graph(3, 3), is_planar=False)
    def test_k5(self):
        self.check_graph(nx.complete_graph(5), is_planar=False)
    def test_multiple_components_planar(self):
        e = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]
        self.check_graph(nx.Graph(e), is_planar=True)
    def test_multiple_components_non_planar(self):
        G = nx.complete_graph(5)
        G.add_edges_from([(6, 7), (7, 8), (8, 6)])
        self.check_graph(G, is_planar=False)
    def test_non_planar_with_selfloop(self):
        G = nx.complete_graph(5)
        for i in range(5):
            G.add_edge(i, i)
        self.check_graph(G, is_planar=False)
    def test_non_planar1(self):
        e = [
            (1, 5),
            (1, 6),
            (1, 7),
            (2, 6),
            (2, 3),
            (3, 5),
            (3, 7),
            (4, 5),
            (4, 6),
            (4, 7),
        ]
        self.check_graph(nx.Graph(e), is_planar=False)
    def test_loop(self):
        e = [(1, 2), (2, 2)]
        G = nx.Graph(e)
        self.check_graph(G, is_planar=True)
    def test_comp(self):
        e = [(1, 2), (3, 4)]
        G = nx.Graph(e)
        G.remove_edge(1, 2)
        self.check_graph(G, is_planar=True)
    def test_goldner_harary(self):
        e = [
            (1, 2),
            (1, 3),
            (1, 4),
            (1, 5),
            (1, 7),
            (1, 8),
            (1, 10),
            (1, 11),
            (2, 3),
            (2, 4),
            (2, 6),
            (2, 7),
            (2, 9),
            (2, 10),
            (2, 11),
            (4, 5),
            (4, 6),
            (<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>4, 7),
            (5, 7),
            (6, 7),
            (7, 8),
            (7, 9),
            (7, 10),
            (8, 10),
            (9, 10),
            (10, 11),
        ]
        G = nx.Graph(</b></font>e)
    def test_planar_multigraph(self):
        G <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= nx.MultiGraph([(1, 2), (1, 2), (1, 2), (1, 2), (2, 3), (3, 1)])
        self.check_graph(G, is_planar=</b></font>True)
    def test_non_planar_multigraph(self):
        G = nx.MultiGraph(nx.complete_graph(5))
        G.add_edges_from([(1, 2)] * 5)
        self.check_graph(G, is_planar=False)
    def test_planar_digraph(self):
        G = nx.DiGraph([(1, 2), (2, 3), (2, 4), (4, 1), (4, 2), (1, 4), (3, 2)])
        self.check_graph(G, is_planar=True)
    def test_non_planar_digraph(self):
        G = nx.DiGraph(nx.complete_graph(5))
        G.remove_edge(1, 2)
        G.remove_edge(4, 1)
        self.check_graph(G, is_planar=False)
    def test_single_component(self):
        G = nx.Graph()
        G.add_node(1)
    def test_graph1(self):
        G <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= nx.OrderedGraph(
            [
                (3, 10),
                (2, 13),
                (1, 13),
                (7, 11),
                (0, 8),
                (8, 13),
                (0, 2),
                (0, 7),
                (0, 10),
                (1</b></font>, 7),
            ]
        )
        self.check_graph(G, is_planar=True)
    def test_graph2(self):
        G = nx.OrderedGraph(
            [
                (1, 2),
                (4, 13),
                (0, 13),
                (4, 5),
                (7, 10),
                (1, 7),
                (0, 3),
                (2, 6),
                (5, 6),
                (7, 13),
                (4, 8),
                (0, 8),
                (0, 9),
                (2, 13),
                (6, 7),
                (3, 6),
                (2, 8),
            ]
        )
        self.check_graph(G, is_planar=False)
    def test_graph3(self):
        G = nx.OrderedGraph(
            [
                (0, 7),
                (3, 11),
                (3, 4),
                (8, 9),
                (4, 11),
                (1, 7),
                (1, 13),
                (1, 11),
                (3, 5),
                (5, 7),
                (1, 3),
                (0, 4),
                (5, 11),
                (5, 13),
            ]
        )
        self.check_graph(G, is_planar=False)
    def test_counterexample_planar(self):
        with pytest.raises(nx.NetworkXException):
            G = nx.Graph()
            G.add_node(1)
            get_counterexample(G)
    def test_counterexample_planar_recursive(self):
        with pytest.raises(nx.NetworkXException):
            G = nx.Graph()
            G.add_node(1)
            get_counterexample_recursive(G)
def check_embedding(G, embedding):
    """Raises an exception if the combinatorial embedding is not correct
    Parameters
    ----------
    G : NetworkX graph
    embedding : a dict mapping nodes to a list of edges
        This specifies the ordering of the outgoing edges from a node for
        a combinatorial embedding
    Notes
    -----
    Checks the following things:
        - The type of the embedding is correct
        - The nodes and edges match the original graph
        - Every half edge has its matching opposite half edge
        - No intersections of edges (checked by Euler's formula)
    """
    if not isinstance(embedding, nx.PlanarEmbedding):
        raise nx.NetworkXException("Bad embedding. Not of type nx.PlanarEmbedding")
    embedding.check_structure()
    assert set(G.nodes) == set(
        embedding.nodes
    ), "Bad embedding. Nodes don't match the original graph."
    g_edges = set()
    for edge in G.edges:
        if edge[0] != edge[1]:
            g_edges.add((edge[0], edge[1]))
            g_edges.add((edge[1], edge[0]))
    assert g_edges == set(
        embedding.edges
    ), "Bad embedding. Edges don't match the original graph."
def check_counterexample(G, sub_graph):
    """Raises an exception if the counterexample is wrong.
    Parameters
    ----------
    G : NetworkX graph
    subdivision_nodes : set
        A set of nodes inducing a subgraph as a counterexample
    """
    sub_graph = nx.Graph(sub_graph)
    for u in sub_graph:
        if sub_graph.has_edge(u, u):
            sub_graph.remove_edge(u, u)
    contract = list(sub_graph)
    while len(contract) &gt; 0:
        contract_node = contract.pop()
        if contract_node not in sub_graph:
            continue
        degree = sub_graph.degree[contract_node]
        if degree == 2:
            neighbors = iter(sub_graph[contract_node])
            u = next(neighbors)
            v = next(neighbors)
            contract.append(u)
            contract.append(v)
            sub_graph.remove_node(contract_node)
            sub_graph.add_edge(u, v)
    if len(sub_graph) == 5:
        if not nx.is_isomorphic(nx.complete_graph(5), sub_graph):
            raise nx.NetworkXException("Bad counter example.")
    elif len(sub_graph) == 6:
        if not nx.is_isomorphic(nx.complete_bipartite_graph(3, 3), sub_graph):
            raise nx.NetworkXException("Bad counter example.")
    else:
        raise nx.NetworkXException("Bad counter example.")
class TestPlanarEmbeddingClass:
    def test_get_data(self):
        embedding = self.get_star_embedding(3)
        data = embedding.get_data()
        data_cmp = {0: [2, 1], 1: [0], 2: [0]}
        assert data == data_cmp
    def test_missing_edge_orientation(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_edge(1, 2)
            embedding.add_edge(2, 1)
            embedding.check_structure()
    def test_invalid_edge_orientation(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_half_edge_first(1, 2)
            embedding.add_half_edge_first(2, 1)
            embedding.add_edge(1, 3)
            embedding.check_structure()
    def test_missing_half_edge(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_half_edge_first(1, 2)
            embedding.check_structure()
    def test_not_fulfilling_euler_formula(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            for i in range(5):
                for j in range(5):
                    if i != j:
                        embedding.add_half_edge_first(i, j)
            embedding.check_structure()
    def test_missing_reference(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_half_edge_cw(1, 2, 3)
    def test_connect_components(self):
        embedding = nx.PlanarEmbedding()
        embedding.connect_components(1, 2)
    def test_successful_face_traversal(self):
        embedding = nx.PlanarEmbedding()
        embedding.add_half_edge_first(1, 2)
        embedding.add_half_edge_first(2, 1)
        face = embedding.traverse_face(1, 2)
        assert face == [1, 2]
    def test_unsuccessful_face_traversal(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_edge(1, 2, ccw=2, cw=3)
            embedding.add_edge(2, 1, ccw=1, cw=3)
            embedding.traverse_face(1, 2)
    @staticmethod
    def get_star_embedding(n):
        embedding = nx.PlanarEmbedding()
        for i in range(1, n):
            embedding.add_half_edge_first(0, i)
            embedding.add_half_edge_first(i, 0)
        return embedding
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
