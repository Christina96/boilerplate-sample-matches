<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_graphmatrix.py & test_planarity.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_graphmatrix.py & test_planarity.py
      </h3>
      <h1 align="center">
        6.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_graphmatrix.py (6.678082%)<TH>test_planarity.py (6.1611376%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4073-0.html#0',2,'match4073-1.html#0',3)" NAME="0">(31-42)<TD><A HREF="javascript:ZweiFrames('match4073-0.html#0',2,'match4073-1.html#0',3)" NAME="0">(202-213)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match4073-0.html#1',2,'match4073-1.html#1',3)" NAME="1">(19-29)<TD><A HREF="javascript:ZweiFrames('match4073-0.html#1',2,'match4073-1.html#1',3)" NAME="1">(177-178)</A><TD ALIGN=center><FONT COLOR="#ec0000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match4073-0.html#2',2,'match4073-1.html#2',3)" NAME="2">(14-15)<TD><A HREF="javascript:ZweiFrames('match4073-0.html#2',2,'match4073-1.html#2',3)" NAME="2">(163-173)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_graphmatrix.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest

np = pytest.importorskip(&quot;numpy&quot;)
pytest.importorskip(&quot;scipy&quot;)

import networkx as nx
from networkx.generators.degree_seq import havel_hakimi_graph
from networkx.exception import NetworkXError


<A NAME="2"></A>def test_incidence_matrix_simple():
    deg = [3, 2, 2, 1, 0]
    G = havel_hakimi_graph(deg)
    deg = [<FONT color="#980517"><A HREF="javascript:ZweiFrames('match4073-1.html#2',3,'match4073-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(1, 0), (1, 0), (1, 0), (2, 0), (1, 0), (2, 1), (0, 1), (0, 1)]
    MG = nx.random_clustered_graph(</B></FONT>deg, seed=42)
<A NAME="1"></A>
    I = nx.incidence_matrix(G).todense().astype(int)
    # fmt: off
    expected <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match4073-1.html#1',3,'match4073-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= np.array(
        [[1, 1, 1, 0],
         [0, 1, 0, 1],
         [1, 0, 0, 1],
         [0, 0, 1, 0],
         [0, 0, 0, 0]]
    )
    # fmt: on
    np.testing.assert_equal(I, expected)
<A NAME="0"></A>
    I =</B></FONT> nx.incidence_matrix(MG).todense().astype(int)
    # fmt: off
    expected <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match4073-1.html#0',3,'match4073-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= np.array(
        [[1, 0, 0, 0, 0, 0, 0],
         [1, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 1, 1, 0],
         [0, 0, 0, 0, 0, 1, 1],
         [0, 0, 0, 0, 1, 0, 1]]
    )
    # fmt: on
    np.testing.</B></FONT>assert_equal(I, expected)

    with pytest.raises(NetworkXError):
        nx.incidence_matrix(G, nodelist=[0, 1])


class TestGraphMatrix:
    @classmethod
    def setup_class(cls):
        deg = [3, 2, 2, 1, 0]
        cls.G = havel_hakimi_graph(deg)
        # fmt: off
        cls.OI = np.array(
            [[-1, -1, -1, 0],
             [1, 0, 0, -1],
             [0, 1, 0, 1],
             [0, 0, 1, 0],
             [0, 0, 0, 0]]
        )
        cls.A = np.array(
            [[0, 1, 1, 1, 0],
             [1, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.WG = havel_hakimi_graph(deg)
        cls.WG.add_edges_from(
            (u, v, {&quot;weight&quot;: 0.5, &quot;other&quot;: 0.3}) for (u, v) in cls.G.edges()
        )
        # fmt: off
        cls.WA = np.array(
            [[0, 0.5, 0.5, 0.5, 0],
             [0.5, 0, 0.5, 0, 0],
             [0.5, 0.5, 0, 0, 0],
             [0.5, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.MG = nx.MultiGraph(cls.G)
        cls.MG2 = cls.MG.copy()
        cls.MG2.add_edge(0, 1)
        # fmt: off
        cls.MG2A = np.array(
            [[0, 2, 1, 1, 0],
             [2, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        cls.MGOI = np.array(
            [[-1, -1, -1, -1, 0],
             [1, 1, 0, 0, -1],
             [0, 0, 1, 0, 1],
             [0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.no_edges_G = nx.Graph([(1, 2), (3, 2, {&quot;weight&quot;: 8})])
        cls.no_edges_A = np.array([[0, 0], [0, 0]])

    def test_incidence_matrix(self):
        &quot;Conversion to incidence matrix&quot;
        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG2),
                edgelist=sorted(self.MG2.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.MGOI)

        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG2.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.MGOI))

    def test_weighted_incidence_matrix(self):
        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        # np.testing.assert_equal(nx.incidence_matrix(self.WG,oriented=True,
        #                                  weight='weight').todense(),0.5*self.OI)
        # np.testing.assert_equal(nx.incidence_matrix(self.WG,weight='weight').todense(),
        #              np.abs(0.5*self.OI))
        # np.testing.assert_equal(nx.incidence_matrix(self.WG,oriented=True,weight='other').todense(),
        #              0.3*self.OI)

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.OI)

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=False,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.OI))

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight=&quot;other&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.OI)

        # WMG=nx.MultiGraph(self.WG)
        # WMG.add_edge(0,1,weight=0.5,other=0.3)
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='weight').todense(),
        #              np.abs(0.5*self.MGOI))
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='weight',oriented=True).todense(),
        #              0.5*self.MGOI)
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='other',oriented=True).todense(),
        #              0.3*self.MGOI)

        WMG = nx.MultiGraph(self.WG)
        WMG.add_edge(0, 1, weight=0.5, other=0.3)

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.MGOI)

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=False,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.MGOI))

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight=&quot;other&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.MGOI)

    def test_adjacency_matrix(self):
        &quot;Conversion to adjacency matrix&quot;
        np.testing.assert_equal(nx.adjacency_matrix(self.G).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG2).todense(), self.MG2A)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.G, nodelist=[0, 1]).todense(), self.A[:2, :2]
        )
        np.testing.assert_equal(nx.adjacency_matrix(self.WG).todense(), self.WA)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight=None).todense(), self.A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.MG2, weight=None).todense(), self.MG2A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight=&quot;other&quot;).todense(), 0.6 * self.WA
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.no_edges_G, nodelist=[1, 3]).todense(),
            self.no_edges_A,
        )
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_planarity.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest
import networkx as nx
from networkx.algorithms.planarity import get_counterexample
from networkx.algorithms.planarity import get_counterexample_recursive
from networkx.algorithms.planarity import check_planarity_recursive


class TestLRPlanarity:
    &quot;&quot;&quot;Nose Unit tests for the :mod:`networkx.algorithms.planarity` module.

    Tests three things:
    1. Check that the result is correct
        (returns planar if and only if the graph is actually planar)
    2. In case a counter example is returned: Check if it is correct
    3. In case an embedding is returned: Check if its actually an embedding
    &quot;&quot;&quot;

    @staticmethod
    def check_graph(G, is_planar=None):
        &quot;&quot;&quot;Raises an exception if the lr_planarity check returns a wrong result

        Parameters
        ----------
        G : NetworkX graph
        is_planar : bool
            The expected result of the planarity check.
            If set to None only counter example or embedding are verified.

        &quot;&quot;&quot;

        # obtain results of planarity check
        is_planar_lr, result = nx.check_planarity(G, True)
        is_planar_lr_rec, result_rec = check_planarity_recursive(G, True)

        if is_planar is not None:
            # set a message for the assert
            if is_planar:
                msg = &quot;Wrong planarity check result. Should be planar.&quot;
            else:
                msg = &quot;Wrong planarity check result. Should be non-planar.&quot;

            # check if the result is as expected
            assert is_planar == is_planar_lr, msg
            assert is_planar == is_planar_lr_rec, msg

        if is_planar_lr:
            # check embedding
            check_embedding(G, result)
            check_embedding(G, result_rec)
        else:
            # check counter example
            check_counterexample(G, result)
            check_counterexample(G, result_rec)

    def test_simple_planar_graph(self):
        e = [
            (1, 2),
            (2, 3),
            (3, 4),
            (4, 6),
            (6, 7),
            (7, 1),
            (1, 5),
            (5, 2),
            (2, 4),
            (4, 5),
            (5, 7),
        ]
        self.check_graph(nx.Graph(e), is_planar=True)

    def test_planar_with_selfloop(self):
        e = [
            (1, 1),
            (2, 2),
            (3, 3),
            (4, 4),
            (5, 5),
            (1, 2),
            (1, 3),
            (1, 5),
            (2, 5),
            (2, 4),
            (3, 4),
            (3, 5),
            (4, 5),
        ]
        self.check_graph(nx.Graph(e), is_planar=True)

    def test_k3_3(self):
        self.check_graph(nx.complete_bipartite_graph(3, 3), is_planar=False)

    def test_k5(self):
        self.check_graph(nx.complete_graph(5), is_planar=False)

    def test_multiple_components_planar(self):
        e = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6), (6, 4)]
        self.check_graph(nx.Graph(e), is_planar=True)

    def test_multiple_components_non_planar(self):
        G = nx.complete_graph(5)
        # add another planar component to the non planar component
        # G stays non planar
        G.add_edges_from([(6, 7), (7, 8), (8, 6)])
        self.check_graph(G, is_planar=False)

    def test_non_planar_with_selfloop(self):
        G = nx.complete_graph(5)
        # add self loops
        for i in range(5):
            G.add_edge(i, i)
        self.check_graph(G, is_planar=False)

    def test_non_planar1(self):
        # tests a graph that has no subgraph directly isomorph to K5 or K3_3
        e = [
            (1, 5),
            (1, 6),
            (1, 7),
            (2, 6),
            (2, 3),
            (3, 5),
            (3, 7),
            (4, 5),
            (4, 6),
            (4, 7),
        ]
        self.check_graph(nx.Graph(e), is_planar=False)

    def test_loop(self):
        # test a graph with a selfloop
        e = [(1, 2), (2, 2)]
        G = nx.Graph(e)
        self.check_graph(G, is_planar=True)

    def test_comp(self):
        # test multiple component graph
        e = [(1, 2), (3, 4)]
        G = nx.Graph(e)
        G.remove_edge(1, 2)
        self.check_graph(G, is_planar=True)

    def test_goldner_harary(self):
        # test goldner-harary graph (a maximal planar graph)
        e = [
            (1, 2),
            (1, 3),
            (1, 4),
            (1, 5),
            (1, 7),
            (1, 8),
            (1, 10),
            (1, 11),
            (2, 3),
            (2, 4),
            (2, 6),
            (2, 7),
            (2, 9),
            (2, 10),
            (2, 11),
<A NAME="2"></A>            (3, 4),
            (4, 5),
            (4, 6),
            (<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4073-0.html#2',2,'match4073-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>4, 7),
            (5, 7),
            (6, 7),
            (7, 8),
            (7, 9),
            (7, 10),
            (8, 10),
            (9, 10),
            (10, 11),
        ]
        G = nx.Graph(</B></FONT>e)
<A NAME="1"></A>        self.check_graph(G, is_planar=True)

    def test_planar_multigraph(self):
        G <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4073-0.html#1',2,'match4073-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= nx.MultiGraph([(1, 2), (1, 2), (1, 2), (1, 2), (2, 3), (3, 1)])
        self.check_graph(G, is_planar=</B></FONT>True)

    def test_non_planar_multigraph(self):
        G = nx.MultiGraph(nx.complete_graph(5))
        G.add_edges_from([(1, 2)] * 5)
        self.check_graph(G, is_planar=False)

    def test_planar_digraph(self):
        G = nx.DiGraph([(1, 2), (2, 3), (2, 4), (4, 1), (4, 2), (1, 4), (3, 2)])
        self.check_graph(G, is_planar=True)

    def test_non_planar_digraph(self):
        G = nx.DiGraph(nx.complete_graph(5))
        G.remove_edge(1, 2)
        G.remove_edge(4, 1)
        self.check_graph(G, is_planar=False)

    def test_single_component(self):
        # Test a graph with only a single node
        G = nx.Graph()
        G.add_node(1)
<A NAME="0"></A>        self.check_graph(G, is_planar=True)

    def test_graph1(self):
        G <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4073-0.html#0',2,'match4073-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= nx.OrderedGraph(
            [
                (3, 10),
                (2, 13),
                (1, 13),
                (7, 11),
                (0, 8),
                (8, 13),
                (0, 2),
                (0, 7),
                (0, 10),
                (1</B></FONT>, 7),
            ]
        )
        self.check_graph(G, is_planar=True)

    def test_graph2(self):
        G = nx.OrderedGraph(
            [
                (1, 2),
                (4, 13),
                (0, 13),
                (4, 5),
                (7, 10),
                (1, 7),
                (0, 3),
                (2, 6),
                (5, 6),
                (7, 13),
                (4, 8),
                (0, 8),
                (0, 9),
                (2, 13),
                (6, 7),
                (3, 6),
                (2, 8),
            ]
        )
        self.check_graph(G, is_planar=False)

    def test_graph3(self):
        G = nx.OrderedGraph(
            [
                (0, 7),
                (3, 11),
                (3, 4),
                (8, 9),
                (4, 11),
                (1, 7),
                (1, 13),
                (1, 11),
                (3, 5),
                (5, 7),
                (1, 3),
                (0, 4),
                (5, 11),
                (5, 13),
            ]
        )
        self.check_graph(G, is_planar=False)

    def test_counterexample_planar(self):
        with pytest.raises(nx.NetworkXException):
            # Try to get a counterexample of a planar graph
            G = nx.Graph()
            G.add_node(1)
            get_counterexample(G)

    def test_counterexample_planar_recursive(self):
        with pytest.raises(nx.NetworkXException):
            # Try to get a counterexample of a planar graph
            G = nx.Graph()
            G.add_node(1)
            get_counterexample_recursive(G)


def check_embedding(G, embedding):
    &quot;&quot;&quot;Raises an exception if the combinatorial embedding is not correct

    Parameters
    ----------
    G : NetworkX graph
    embedding : a dict mapping nodes to a list of edges
        This specifies the ordering of the outgoing edges from a node for
        a combinatorial embedding

    Notes
    -----
    Checks the following things:
        - The type of the embedding is correct
        - The nodes and edges match the original graph
        - Every half edge has its matching opposite half edge
        - No intersections of edges (checked by Euler's formula)
    &quot;&quot;&quot;

    if not isinstance(embedding, nx.PlanarEmbedding):
        raise nx.NetworkXException(&quot;Bad embedding. Not of type nx.PlanarEmbedding&quot;)

    # Check structure
    embedding.check_structure()

    # Check that graphs are equivalent

    assert set(G.nodes) == set(
        embedding.nodes
    ), &quot;Bad embedding. Nodes don't match the original graph.&quot;

    # Check that the edges are equal
    g_edges = set()
    for edge in G.edges:
        if edge[0] != edge[1]:
            g_edges.add((edge[0], edge[1]))
            g_edges.add((edge[1], edge[0]))
    assert g_edges == set(
        embedding.edges
    ), &quot;Bad embedding. Edges don't match the original graph.&quot;


def check_counterexample(G, sub_graph):
    &quot;&quot;&quot;Raises an exception if the counterexample is wrong.

    Parameters
    ----------
    G : NetworkX graph
    subdivision_nodes : set
        A set of nodes inducing a subgraph as a counterexample
    &quot;&quot;&quot;
    # 1. Create the sub graph
    sub_graph = nx.Graph(sub_graph)

    # 2. Remove self loops
    for u in sub_graph:
        if sub_graph.has_edge(u, u):
            sub_graph.remove_edge(u, u)

    # keep track of nodes we might need to contract
    contract = list(sub_graph)

    # 3. Contract Edges
    while len(contract) &gt; 0:
        contract_node = contract.pop()
        if contract_node not in sub_graph:
            # Node was already contracted
            continue
        degree = sub_graph.degree[contract_node]
        # Check if we can remove the node
        if degree == 2:
            # Get the two neighbors
            neighbors = iter(sub_graph[contract_node])
            u = next(neighbors)
            v = next(neighbors)
            # Save nodes for later
            contract.append(u)
            contract.append(v)
            # Contract edge
            sub_graph.remove_node(contract_node)
            sub_graph.add_edge(u, v)

    # 4. Check for isomorphism with K5 or K3_3 graphs
    if len(sub_graph) == 5:
        if not nx.is_isomorphic(nx.complete_graph(5), sub_graph):
            raise nx.NetworkXException(&quot;Bad counter example.&quot;)
    elif len(sub_graph) == 6:
        if not nx.is_isomorphic(nx.complete_bipartite_graph(3, 3), sub_graph):
            raise nx.NetworkXException(&quot;Bad counter example.&quot;)
    else:
        raise nx.NetworkXException(&quot;Bad counter example.&quot;)


class TestPlanarEmbeddingClass:
    def test_get_data(self):
        embedding = self.get_star_embedding(3)
        data = embedding.get_data()
        data_cmp = {0: [2, 1], 1: [0], 2: [0]}
        assert data == data_cmp

    def test_missing_edge_orientation(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_edge(1, 2)
            embedding.add_edge(2, 1)
            # Invalid structure because the orientation of the edge was not set
            embedding.check_structure()

    def test_invalid_edge_orientation(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_half_edge_first(1, 2)
            embedding.add_half_edge_first(2, 1)
            embedding.add_edge(1, 3)
            embedding.check_structure()

    def test_missing_half_edge(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_half_edge_first(1, 2)
            # Invalid structure because other half edge is missing
            embedding.check_structure()

    def test_not_fulfilling_euler_formula(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            for i in range(5):
                for j in range(5):
                    if i != j:
                        embedding.add_half_edge_first(i, j)
            embedding.check_structure()

    def test_missing_reference(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_half_edge_cw(1, 2, 3)

    def test_connect_components(self):
        embedding = nx.PlanarEmbedding()
        embedding.connect_components(1, 2)

    def test_successful_face_traversal(self):
        embedding = nx.PlanarEmbedding()
        embedding.add_half_edge_first(1, 2)
        embedding.add_half_edge_first(2, 1)
        face = embedding.traverse_face(1, 2)
        assert face == [1, 2]

    def test_unsuccessful_face_traversal(self):
        with pytest.raises(nx.NetworkXException):
            embedding = nx.PlanarEmbedding()
            embedding.add_edge(1, 2, ccw=2, cw=3)
            embedding.add_edge(2, 1, ccw=1, cw=3)
            embedding.traverse_face(1, 2)

    @staticmethod
    def get_star_embedding(n):
        embedding = nx.PlanarEmbedding()
        for i in range(1, n):
            embedding.add_half_edge_first(0, i)
            embedding.add_half_edge_first(i, 0)
        return embedding
</PRE>
</div>
  </div>
</body>
</html>
