<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_pub_server_channel.py &amp; test_git_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_pub_server_channel.py &amp; test_git_2.py
      </h3>
<h1 align="center">
        4.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_pub_server_channel.py (8.527132%)<th>test_git_2.py (2.7725267%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(2-21)<td><a href="#" name="0">(5-24)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(30-34)<td><a href="#" name="1">(762-766)</a><td align="center"><font color="#c60000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(44-47)<td><a href="#" name="2">(820-823)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pub_server_channel.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import multiprocessing
2 import time
3 from concurrent.futures.thread import ThreadPoolExecutor
4 import pytest
5 import salt.config
6 import salt.exceptions
7 import salt.ext.tornado.gen
8 import salt.ext.tornado.ioloop
9 import salt.log.setup
10 import salt.master
11 import salt.transport.zeromq
12 import salt.utils.platform
13 import salt.utils.process
14 import salt.utils.stringutils
15 import zmq
16 from saltfactories.utils.processes import terminate_process
17 from tests.support.mock import MagicMock, patch
18 log =</b></font> logging.getLogger(__name__)
19 class Collector(salt.utils.process.SignalHandlingProcess):
20     def __init__(self, minion_config, pub_uri, timeout=30, zmq_filtering=False):
21         super().__init__()
22         self.pub_uri = pub_uri
23         self.timeout = timeout
24         self.hard_timeout = time<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.time() + timeout + 30
25         self.manager = multiprocessing.Manager()
26         self.results = self.manager.list()
27         self.zmq_filtering = zmq_filtering
28         self.</b></font>stopped = multiprocessing.Event()
29         self.started = multiprocessing.Event()
30         self.running = multiprocessing.Event()
31     def run(self):
32         ctx = zmq.Context()
33         sock = ctx<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.socket(zmq.SUB)
34         sock.setsockopt(zmq.LINGER, -1)
35         sock.setsockopt(zmq.SUBSCRIBE, b"")
36         sock.connect(self.</b></font>pub_uri)
37         last_msg = time.time()
38         self.started.set()
39         while True:
40             curr_time = time.time()
41             if time.time() &gt; self.hard_timeout:
42                 break
43             if curr_time - last_msg &gt;= self.timeout:
44                 break
45             try:
46                 payload = sock.recv(zmq.NOBLOCK)
47             except zmq.ZMQError:
48                 time.sleep(0.1)
49             else:
50                 try:
51                     payload = salt.payload.loads(payload)
52                     if "start" in payload:
53                         self.running.set()
54                         continue
55                     if "stop" in payload:
56                         break
57                     last_msg = time.time()
58                     self.results.append(payload["jid"])
59                 except salt.exceptions.SaltDeserializationError:
60                     if not self.zmq_filtering:
61                         log.exception("Failed to deserialize...")
62                         break
63     def __enter__(self):
64         self.manager.__enter__()
65         self.start()
66         self.started.wait()
67         self.started.clear()
68         return self
69     def __exit__(self, *args):
70         join_secs = self.hard_timeout - time.time()
71         log.info("Waiting at most %s seconds before exiting the collector", join_secs)
72         self.join(join_secs)
73         self.terminate()
74         self.results = list(self.results)
75         self.manager.__exit__(*args)
76         log.debug("The collector has exited")
77         self.stopped.set()
78 class PubServerChannelProcess(salt.utils.process.SignalHandlingProcess):
79     def __init__(self, master_config, minion_config, **collector_kwargs):
80         super().__init__()
81         self._closing = False
82         self.master_config = master_config
83         self.minion_config = minion_config
84         self.collector_kwargs = collector_kwargs
85         self.process_manager = salt.utils.process.ProcessManager(
86             name="ZMQ-PubServer-ProcessManager"
87         )
88         self.pub_server_channel = salt.transport.zeromq.PublishServer(
89             self.master_config
90         )
91         self.pub_server_channel.pre_fork(self.process_manager)
92         self.pub_uri = "tcp://{interface}:{publish_port}".format(**self.master_config)
93         self.queue = multiprocessing.Queue()
94         self.stopped = multiprocessing.Event()
95         self.collector = Collector(
96             self.minion_config, self.pub_uri, **self.collector_kwargs
97         )
98     def run(self):
99         try:
100             while True:
101                 payload = self.queue.get()
102                 if payload is None:
103                     log.debug("We received the stop sentinel")
104                     break
105                 self.pub_server_channel.publish(payload)
106         except KeyboardInterrupt:
107             pass
108         finally:
109             self.stopped.set()
110     def _handle_signals(self, signum, sigframe):
111         self.close()
112         super()._handle_signals(signum, sigframe)
113     def close(self):
114         if self._closing:
115             return
116         self._closing = True
117         if self.process_manager is None:
118             return
119         self.process_manager.terminate()
120         self.pub_server_channel.pub_close()
121         for pid in self.process_manager._process_map:
122             terminate_process(pid=pid, kill_children=True, slow_stop=False)
123         self.process_manager = None
124     def publish(self, payload):
125         self.queue.put(payload)
126     def __enter__(self):
127         self.start()
128         self.collector.__enter__()
129         attempts = 30
130         while attempts &gt; 0:
131             self.publish({"tgt_type": "glob", "tgt": "*", "jid": -1, "start": True})
132             if self.collector.running.wait(1) is True:
133                 break
134             attempts -= 1
135         else:
136             pytest.fail("Failed to confirm the collector has started")
137         return self
138     def __exit__(self, *args):
139         self.publish({"tgt_type": "glob", "tgt": "*", "jid": -1, "stop": True})
140         self.collector.__exit__(*args)
141         self.collector.stopped.wait()
142         self.queue.put(None)
143         self.stopped.wait(10)
144         self.close()
145         self.terminate()
146         log.info("The PubServerChannelProcess has terminated")
147 @pytest.mark.skip_on_windows
148 @pytest.mark.slow_test
149 def test_publish_to_pubserv_ipc(salt_master, salt_minion):
150     opts = dict(salt_master.config.copy(), ipc_mode="ipc", pub_hwm=0)
151     with PubServerChannelProcess(opts, salt_minion.config.copy()) as server_channel:
152         send_num = 10000
153         expect = []
154         for idx in range(send_num):
155             expect.append(idx)
156             load = {"tgt_type": "glob", "tgt": "*", "jid": idx}
157             server_channel.publish(load)
158     results = server_channel.collector.results
159     assert len(results) == send_num, "{} != {}, difference: {}".format(
160         len(results), send_num, set(expect).difference(results)
161     )
162 @pytest.mark.skip_on_freebsd
163 @pytest.mark.slow_test
164 def test_issue_36469_tcp(salt_master, salt_minion):
165     def _send_small(server_channel, sid, num=10):
166         for idx in range(num):
167             load = {"tgt_type": "glob", "tgt": "*", "jid": "{}-s{}".format(sid, idx)}
168             server_channel.publish(load)
169     def _send_large(server_channel, sid, num=10, size=250000 * 3):
170         for idx in range(num):
171             load = {
172                 "tgt_type": "glob",
173                 "tgt": "*",
174                 "jid": "{}-l{}".format(sid, idx),
175                 "xdata": "0" * size,
176             }
177             server_channel.publish(load)
178     opts = dict(salt_master.config.copy(), ipc_mode="tcp", pub_hwm=0)
179     send_num = 10 * 4
180     expect = []
181     with PubServerChannelProcess(opts, salt_minion.config.copy()) as server_channel:
182         with ThreadPoolExecutor(max_workers=4) as executor:
183             executor.submit(_send_small, server_channel, 1)
184             executor.submit(_send_large, server_channel, 2)
185             executor.submit(_send_small, server_channel, 3)
186             executor.submit(_send_large, server_channel, 4)
187         expect.extend(["{}-s{}".format(a, b) for a in range(10) for b in (1, 3)])
188         expect.extend(["{}-l{}".format(a, b) for a in range(10) for b in (2, 4)])
189     results = server_channel.collector.results
190     assert len(results) == send_num, "{} != {}, difference: {}".format(
191         len(results), send_num, set(expect).difference(results)
192     )
193 @pytest.mark.skip_on_windows
194 @pytest.mark.slow_test
195 def test_zeromq_filtering(salt_master, salt_minion):
196     opts = dict(
197         salt_master.config.copy(),
198         ipc_mode="ipc",
199         pub_hwm=0,
200         zmq_filtering=True,
201         acceptance_wait_time=5,
202     )
203     send_num = 1
204     expect = []
205     with patch(
206         "salt.utils.minions.CkMinions.check_minions",
207         MagicMock(
208             return_value={
209                 "minions": [salt_minion.id],
210                 "missing": [],
211                 "ssh_minions": False,
212             }
213         ),
214     ):
215         with PubServerChannelProcess(
216             opts, salt_minion.config.copy(), zmq_filtering=True
217         ) as server_channel:
218             expect.append(send_num)
219             load = {"tgt_type": "glob", "tgt": "*", "jid": send_num}
220             server_channel.publish(load)
221         results = server_channel.collector.results
222         assert len(results) == send_num, "{} != {}, difference: {}".format(
223             len(results), send_num, set(expect).difference(results)
224         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_git_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import functools
2 import inspect
3 import logging
4 import os
5 import shutil
6 import socket
7 import string
8 import tempfile
9 import urllib.parse
10 import pytest
11 import salt.utils.files
12 import salt.utils.path
13 from salt.utils.versions import LooseVersion as _LooseVersion
14 from tests.support.case import ModuleCase
15 from tests.support.helpers import TstSuiteLoggingHandler, with_tempdir
16 from tests.support.mixins import SaltReturnAssertsMixin
17 from tests.support.runtests import RUNTIME_VARS
18 TEST_REPO =</b></font> "https://github.com/saltstack/salt-test-repo.git"
19 def __check_git_version(caller, min_version, skip_msg):
20     if inspect.isclass(caller):
21         actual_setup = getattr(caller, "setUp", None)
22         def setUp(self, *args, **kwargs):
23             if not salt.utils.path.which("git"):
24                 self.skipTest("git is not installed")
25             git_version = self.run_function("git.version")
26             if _LooseVersion(git_version) &lt; _LooseVersion(min_version):
27                 self.skipTest(skip_msg.format(min_version, git_version))
28             if actual_setup is not None:
29                 actual_setup(self, *args, **kwargs)
30         caller.setUp = setUp
31         return caller
32     @functools.wraps(caller)
33     def wrapper(self, *args, **kwargs):
34         if not salt.utils.path.which("git"):
35             self.skipTest("git is not installed")
36         git_version = self.run_function("git.version")
37         if _LooseVersion(git_version) &lt; _LooseVersion(min_version):
38             self.skipTest(skip_msg.format(min_version, git_version))
39         return caller(self, *args, **kwargs)
40     return wrapper
41 def ensure_min_git(caller=None, min_version="1.6.5"):
42     if caller is None:
43         return functools.partial(ensure_min_git, min_version=min_version)
44     return __check_git_version(
45         caller, min_version, "git {0} or newer required to run this test (detected {1})"
46     )
47 def uses_git_opts(caller):
48     min_version = "1.7.2"
49     return __check_git_version(
50         caller,
51         min_version,
52         "git_opts only supported in git {0} and newer (detected {1})",
53     )
54 class WithGitMirror:
55     def __init__(self, repo_url, **kwargs):
56         self.repo_url = repo_url
57         if "dir" not in kwargs:
58             kwargs["dir"] = RUNTIME_VARS.TMP
59         self.kwargs = kwargs
60     def __call__(self, func):
61         self.func = func
62         return functools.wraps(func)(
63             lambda testcase, *args, **kwargs: self.wrap(testcase, *args, **kwargs)
64         )
65     def wrap(self, testcase, *args, **kwargs):
66         mirror_dir = tempfile.mkdtemp(**self.kwargs)
67         admin_dir = tempfile.mkdtemp(**self.kwargs)
68         clone_dir = tempfile.mkdtemp(**self.kwargs)
69         os.rmdir(mirror_dir)
70         os.rmdir(admin_dir)
71         os.rmdir(clone_dir)
72         mirror_url = "file://" + mirror_dir
73         testcase.run_function("git.clone", [mirror_dir], url=TEST_REPO, opts="--mirror")
74         assert os.path.exists(mirror_dir)
75         ret = testcase.run_state("git.latest", name=mirror_url, target=admin_dir)
76         ret = ret[next(iter(ret))]
77         assert os.path.exists(admin_dir)
78         try:
79             return self.func(
80                 testcase, mirror_url, admin_dir, clone_dir, *args, **kwargs
81             )
82         finally:
83             shutil.rmtree(mirror_dir, ignore_errors=True)
84             shutil.rmtree(admin_dir, ignore_errors=True)
85             shutil.rmtree(clone_dir, ignore_errors=True)
86 with_git_mirror = WithGitMirror
87 @ensure_min_git
88 class GitTest(ModuleCase, SaltReturnAssertsMixin):
89     def setUp(self):
90         domain = urllib.parse.urlparse(TEST_REPO).netloc
91         try:
92             if hasattr(socket, "setdefaulttimeout"):
93                 socket.setdefaulttimeout(10)
94             socket.gethostbyname(domain)
95         except OSError:
96             msg = "error resolving {0}, possible network issue?"
97             self.skipTest(msg.format(domain))
98     def tearDown(self):
99         socket.setdefaulttimeout(None)
100     def _head(self, cwd):
101         return self.run_function("git.rev_parse", [cwd, "HEAD"])
102     @with_tempdir(create=False)
103     @pytest.mark.slow_test
104     def test_latest(self, target):
105         ret = self.run_state("git.latest", name=TEST_REPO, target=target)
106         self.assertSaltTrueReturn(ret)
107         self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
108     @with_tempdir(create=False)
109     @pytest.mark.slow_test
110     def test_latest_config_get_regexp_retcode(self, target):
111         log_format = "[%(levelname)-8s] %(jid)s %(message)s"
112         self.handler = TstSuiteLoggingHandler(format=log_format, level=logging.DEBUG)
113         ret_code_err = "failed with return code: 1"
114         with self.handler:
115             ret = self.run_state("git.latest", name=TEST_REPO, target=target)
116             self.assertSaltTrueReturn(ret)
117             self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
118             assert any(ret_code_err in s for s in self.handler.messages) is False, False
119     @with_tempdir(create=False)
120     @pytest.mark.slow_test
121     def test_latest_with_rev_and_submodules(self, target):
122         ret = self.run_state(
123             "git.latest", name=TEST_REPO, rev="develop", target=target, submodules=True
124         )
125         self.assertSaltTrueReturn(ret)
126         self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
127     @with_tempdir(create=False)
128     @pytest.mark.slow_test
129     def test_latest_failure(self, target):
130         ret = self.run_state(
131             "git.latest",
132             name="https://youSpelledGitHubWrong.com/saltstack/salt-test-repo.git",
133             rev="develop",
134             target=target,
135             submodules=True,
136         )
137         self.assertSaltFalseReturn(ret)
138         self.assertFalse(os.path.isdir(os.path.join(target, ".git")))
139     @with_tempdir()
140     @pytest.mark.slow_test
141     def test_latest_empty_dir(self, target):
142         ret = self.run_state(
143             "git.latest", name=TEST_REPO, rev="develop", target=target, submodules=True
144         )
145         self.assertSaltTrueReturn(ret)
146         self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
147     @with_tempdir(create=False)
148     @pytest.mark.slow_test
149     def test_latest_unless_no_cwd_issue_6800(self, target):
150         ret = self.run_state(
151             "git.latest",
152             name=TEST_REPO,
153             rev="develop",
154             target=target,
155             unless="test -e {}".format(target),
156             submodules=True,
157         )
158         self.assertSaltTrueReturn(ret)
159         self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
160     @with_tempdir(create=False)
161     @pytest.mark.slow_test
162     def test_numeric_rev(self, target):
163         ret = self.run_state(
164             "git.latest",
165             name=TEST_REPO,
166             rev=0.11,
167             target=target,
168             submodules=True,
169             timeout=120,
170         )
171         self.assertSaltTrueReturn(ret)
172         self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
173     @with_tempdir(create=False)
174     @pytest.mark.slow_test
175     def test_latest_with_local_changes(self, target):
176         ret = self.run_state("git.latest", name=TEST_REPO, target=target)
177         self.assertSaltTrueReturn(ret)
178         self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
179         with salt.utils.files.fopen(os.path.join(target, "LICENSE"), "a") as fp_:
180             fp_.write("Lorem ipsum dolor blah blah blah....\n")
181         self.assertTrue(self.run_function("git.diff", [target, "HEAD"]))
182         ret = self.run_state(
183             "git.latest", name=TEST_REPO, target=target, force_reset=False
184         )
185         self.assertSaltTrueReturn(ret)
186         self.assertEqual(
187             ret[next(iter(ret))]["comment"],
188             "Repository {} is up-to-date, but with uncommitted changes. "
189             "Set 'force_reset' to True to purge uncommitted changes.".format(target),
190         )
191         ret = self.run_state(
192             "git.latest", name=TEST_REPO, target=target, force_reset=True
193         )
194         self.assertSaltTrueReturn(ret)
195         self.assertFalse(self.run_function("git.diff", [target, "HEAD"]))
196     @with_git_mirror(TEST_REPO)
197     @uses_git_opts
198     @pytest.mark.slow_test
199     def test_latest_fast_forward(self, mirror_url, admin_dir, clone_dir):
200         ret = self.run_state("git.latest", name=mirror_url, target=clone_dir)
201         ret = ret[next(iter(ret))]
202         assert ret["result"]
203         head_pre = self._head(admin_dir)
204         with salt.utils.files.fopen(os.path.join(admin_dir, "LICENSE"), "a") as fp_:
205             fp_.write("Hello world!")
206         self.run_function(
207             "git.commit",
208             [admin_dir, "added a line"],
209             git_opts='-c user.name="Foo Bar" -c user.email=foo@bar.com',
210             opts="-a",
211         )
212         head_post = self._head(admin_dir)
213         assert head_pre != head_post
214         self.run_function("git.push", [admin_dir, "origin", "develop"])
215         ret = self.run_state("git.latest", name=mirror_url, target=clone_dir)
216         ret = ret[next(iter(ret))]
217         assert ret["result"]
218         assert head_post == self._head(clone_dir)
219     @with_tempdir(create=False)
220     def _changed_local_branch_helper(self, target, rev, hint):
221         ret = self.run_state("git.latest", name=TEST_REPO, rev=rev, target=target)
222         self.assertSaltTrueReturn(ret)
223         self.run_function("git.checkout", [target, "new_branch"], opts="-b")
224         with salt.utils.files.fopen(os.path.join(target, "foo"), "w"):
225             pass
226         self.run_function("git.add", [target, "."])
227         self.run_function(
228             "git.commit",
229             [target, "add file"],
230             git_opts='-c user.name="Foo Bar" -c user.email=foo@bar.com',
231         )
232         ret = self.run_state("git.latest", name=TEST_REPO, rev=rev, target=target)
233         self.assertSaltFalseReturn(ret)
234         comment = ret[next(iter(ret))]["comment"]
235         self.assertTrue(hint in comment)
236     @uses_git_opts
237     @pytest.mark.slow_test
238     def test_latest_changed_local_branch_rev_head(self):
239         self._changed_local_branch_helper(  # pylint: disable=no-value-for-parameter
240             "HEAD",
241             "The default remote branch (develop) differs from the local "
242             "branch (new_branch)",
243         )
244     @uses_git_opts
245     @pytest.mark.slow_test
246     def test_latest_changed_local_branch_rev_develop(self):
247         self._changed_local_branch_helper(  # pylint: disable=no-value-for-parameter
248             "develop",
249             "The desired rev (develop) differs from the name of the local "
250             "branch (new_branch)",
251         )
252     @uses_git_opts
253     @with_tempdir(create=False)
254     @with_tempdir()
255     @pytest.mark.slow_test
256     def test_latest_updated_remote_rev(self, name, target):
257         self.run_function("git.init", [name])
258         with salt.utils.files.fopen(os.path.join(name, "foo.txt"), "w") as fp_:
259             fp_.write("Hello world\n")
260         self.run_function("git.add", [name, "."])
261         self.run_function(
262             "git.commit",
263             [name, "initial commit"],
264             git_opts='-c user.name="Foo Bar" -c user.email=foo@bar.com',
265         )
266         ret = self.run_state(
267             "git.latest",
268             name=name,
269             target=target,
270         )
271         self.assertSaltTrueReturn(ret)
272         with salt.utils.files.fopen(os.path.join(name, "foo.txt"), "w") as fp_:
273             fp_.write("Added a line\n")
274         self.run_function(
275             "git.commit",
276             [name, "added a line"],
277             git_opts='-c user.name="Foo Bar" -c user.email=foo@bar.com',
278             opts="-a",
279         )
280         ret = self.run_state(
281             "git.latest",
282             name=name,
283             target=target,
284         )
285         self.assertSaltTrueReturn(ret)
286     @with_tempdir(create=False)
287     @pytest.mark.slow_test
288     def test_latest_depth(self, target):
289         ret = self.run_state(
290             "git.latest", name=TEST_REPO, rev="HEAD", target=target, depth=1
291         )
292         self.assertSaltFalseReturn(ret)
293         self.assertIn(
294             "must be set to the name of a branch", ret[next(iter(ret))]["comment"]
295         )
296         ret = self.run_state(
297             "git.latest",
298             name=TEST_REPO,
299             rev="non-default-branch",
300             target=target,
301             depth=1,
302         )
303         self.assertSaltTrueReturn(ret)
304         self.assertTrue(os.path.isdir(os.path.join(target, ".git")))
305     @with_git_mirror(TEST_REPO)
306     @uses_git_opts
307     @pytest.mark.slow_test
308     def test_latest_sync_tags(self, mirror_url, admin_dir, clone_dir):
309         tag1 = "mytag1"
310         tag2 = "mytag2"
311         self.run_function("git.tag", [admin_dir, tag1])
312         self.run_function("git.push", [admin_dir, "origin", tag1])
313         ret = self.run_state("git.latest", name=mirror_url, target=clone_dir)
314         ret = ret[next(iter(ret))]
315         assert ret["result"]
316         self.run_function("git.push", [admin_dir, "origin", ":{}".format(tag1)])
317         self.run_function("git.tag", [admin_dir, tag2])
318         self.run_function("git.push", [admin_dir, "origin", tag2])
319         ret = self.run_state(
320             "git.latest", name=mirror_url, target=clone_dir, sync_tags=False
321         )
322         ret = ret[next(iter(ret))]
323         assert ret["result"]
324         all_tags = self.run_function("git.list_tags", [clone_dir])
325         assert tag1 in all_tags
326         assert tag2 in all_tags
327         expected_changes = {"new_tags": [tag2]}
328         assert ret["changes"] == expected_changes, ret["changes"]
329         ret = self.run_state(
330             "git.latest", name=mirror_url, target=clone_dir, sync_tags=True
331         )
332         ret = ret[next(iter(ret))]
333         assert ret["result"]
334         all_tags = self.run_function("git.list_tags", [clone_dir])
335         assert tag1 not in all_tags
336         assert tag2 in all_tags
337         expected_changes = {"deleted_tags": [tag1]}
338         assert ret["changes"] == expected_changes, ret["changes"]
339     @with_tempdir(create=False)
340     @pytest.mark.slow_test
341     def test_cloned(self, target):
342         ret = self.run_state("git.cloned", name=TEST_REPO, target=target, test=True)
343         ret = ret[next(iter(ret))]
344         assert ret["result"] is None
345         assert ret["changes"] == {"new": "{} =&gt; {}".format(TEST_REPO, target)}
346         assert ret["comment"] == "{} would be cloned to {}".format(TEST_REPO, target)
347         ret = self.run_state("git.cloned", name=TEST_REPO, target=target)
348         ret = ret[next(iter(ret))]
349         assert ret["result"] is True
350         assert ret["changes"] == {"new": "{} =&gt; {}".format(TEST_REPO, target)}
351         assert ret["comment"] == "{} cloned to {}".format(TEST_REPO, target)
352         ret = self.run_state("git.cloned", name=TEST_REPO, target=target)
353         ret = ret[next(iter(ret))]
354         assert ret["result"] is True
355         assert not ret["changes"]
356         assert ret["comment"] == "Repository already exists at {}".format(target)
357         ret = self.run_state("git.cloned", name=TEST_REPO, target=target, test=True)
358         ret = ret[next(iter(ret))]
359         assert not ret["changes"]
360         assert ret["result"] is True
361         assert ret["comment"] == "Repository already exists at {}".format(target)
362     @with_tempdir(create=False)
363     @pytest.mark.slow_test
364     def test_cloned_with_branch(self, target):
365         old_branch = "master"
366         new_branch = "develop"
367         bad_branch = "thisbranchdoesnotexist"
368         ret = self.run_state(
369             "git.cloned", name=TEST_REPO, target=target, branch=old_branch, test=True
370         )
371         ret = ret[next(iter(ret))]
372         assert ret["result"] is None
373         assert ret["changes"] == {"new": "{} =&gt; {}".format(TEST_REPO, target)}
374         assert ret["comment"] == "{} would be cloned to {} with branch '{}'".format(
375             TEST_REPO, target, old_branch
376         )
377         ret = self.run_state(
378             "git.cloned", name=TEST_REPO, target=target, branch=old_branch
379         )
380         ret = ret[next(iter(ret))]
381         assert ret["result"] is True
382         assert ret["changes"] == {"new": "{} =&gt; {}".format(TEST_REPO, target)}
383         assert ret["comment"] == "{} cloned to {} with branch '{}'".format(
384             TEST_REPO, target, old_branch
385         )
386         ret = self.run_state(
387             "git.cloned", name=TEST_REPO, target=target, branch=old_branch
388         )
389         ret = ret[next(iter(ret))]
390         assert ret["result"] is True
391         assert not ret["changes"]
392         assert ret[
393             "comment"
394         ] == "Repository already exists at {} and is checked out to branch '{}'".format(
395             target, old_branch
396         )
397         ret = self.run_state(
398             "git.cloned", name=TEST_REPO, target=target, test=True, branch=old_branch
399         )
400         ret = ret[next(iter(ret))]
401         assert ret["result"] is True
402         assert not ret["changes"]
403         assert ret[
404             "comment"
405         ] == "Repository already exists at {} and is checked out to branch '{}'".format(
406             target, old_branch
407         )
408         ret = self.run_state(
409             "git.cloned", name=TEST_REPO, target=target, branch=new_branch, test=True
410         )
411         ret = ret[next(iter(ret))]
412         assert ret["result"] is None
413         assert ret["changes"] == {"branch": {"old": old_branch, "new": new_branch}}
414         assert ret["comment"] == "Branch would be changed to '{}'".format(new_branch)
415         ret = self.run_state(
416             "git.cloned", name=TEST_REPO, target=target, branch=new_branch
417         )
418         ret = ret[next(iter(ret))]
419         assert ret["result"] is True
420         assert ret["changes"] == {"branch": {"old": old_branch, "new": new_branch}}
421         assert ret["comment"] == "Branch changed to '{}'".format(new_branch)
422         ret = self.run_state(
423             "git.cloned", name=TEST_REPO, target=target, branch=old_branch
424         )
425         ret = ret[next(iter(ret))]
426         assert ret["result"] is True
427         assert ret["changes"] == {"branch": {"old": new_branch, "new": old_branch}}
428         assert ret["comment"] == "Branch changed to '{}'".format(old_branch)
429         ret = self.run_state(
430             "git.cloned", name=TEST_REPO, target=target, branch=bad_branch
431         )
432         ret = ret[next(iter(ret))]
433         assert ret["result"] is False
434         assert not ret["changes"]
435         assert ret["comment"].startswith(
436             "Failed to change branch to '{}':".format(bad_branch)
437         )
438     @with_tempdir(create=False)
439     @ensure_min_git(min_version="1.7.10")
440     @pytest.mark.slow_test
441     def test_cloned_with_nonexistant_branch(self, target):
442         branch = "thisbranchdoesnotexist"
443         ret = self.run_state(
444             "git.cloned", name=TEST_REPO, target=target, branch=branch, test=True
445         )
446         ret = ret[next(iter(ret))]
447         assert ret["result"] is None
448         assert ret["changes"]
449         assert ret["comment"] == "{} would be cloned to {} with branch '{}'".format(
450             TEST_REPO, target, branch
451         )
452         ret = self.run_state("git.cloned", name=TEST_REPO, target=target, branch=branch)
453         ret = ret[next(iter(ret))]
454         assert ret["result"] is False
455         assert not ret["changes"]
456         assert ret["comment"].startswith("Clone failed:")
457         assert "not found in upstream origin" in ret["comment"]
458     @with_tempdir(create=False)
459     @pytest.mark.slow_test
460     def test_present(self, name):
461         ret = self.run_state("git.present", name=name, bare=True)
462         self.assertSaltTrueReturn(ret)
463         self.assertTrue(os.path.isfile(os.path.join(name, "HEAD")))
464     @with_tempdir()
465     @pytest.mark.slow_test
466     def test_present_failure(self, name):
467         fname = os.path.join(name, "stoptheprocess")
468         with salt.utils.files.fopen(fname, "a"):
469             pass
470         ret = self.run_state("git.present", name=name, bare=True)
471         self.assertSaltFalseReturn(ret)
472         self.assertFalse(os.path.isfile(os.path.join(name, "HEAD")))
473     @with_tempdir()
474     @pytest.mark.slow_test
475     def test_present_empty_dir(self, name):
476         ret = self.run_state("git.present", name=name, bare=True)
477         self.assertSaltTrueReturn(ret)
478         self.assertTrue(os.path.isfile(os.path.join(name, "HEAD")))
479     @with_tempdir()
480     @pytest.mark.slow_test
481     def test_config_set_value_with_space_character(self, name):
482         self.run_function("git.init", [name])
483         ret = self.run_state(
484             "git.config_set",
485             name="user.name",
486             value="foo bar",
487             repo=name,
488             **{"global": False}
489         )
490         self.assertSaltTrueReturn(ret)
491 @ensure_min_git
492 @uses_git_opts
493 class LocalRepoGitTest(ModuleCase, SaltReturnAssertsMixin):
494     def setUp(self):
495         self.repo = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
496         self.admin = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
497         self.target = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
498         for dirname in (self.repo, self.admin, self.target):
499         self<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.run_function("git.init", [self.repo], bare=True)
500         self.run_function("git.clone", [self.admin], url=self.repo)
501         self._commit(self.admin, "", message="initial commit")
502         self.</b></font>_push(self.admin)
503     def _commit(self, repo_path, content, message):
504         with salt.utils.files.fopen(os.path.join(repo_path, "foo"), "a") as fp_:
505             fp_.write(content)
506         self.run_function("git.add", [repo_path, "."])
507         self.run_function(
508             "git.commit",
509             [repo_path, message],
510             git_opts='-c user.name="Foo Bar" -c user.email=foo@bar.com',
511         )
512     def _push(self, repo_path, remote="origin", ref="master"):
513         self.run_function("git.push", [repo_path], remote=remote, ref=ref)
514     def _test_latest_force_reset_setup(self):
515         ret = self.run_state("git.latest", name=self.repo, target=self.target)
516         self.assertSaltTrueReturn(ret)
517         self._commit(self.admin, content="Hello world!\n", message="added a line")
518         self._push(self.admin)
519         with salt.utils.files.fopen(os.path.join(self.target, "foo"), "a") as fp_:
520             fp_.write("Local changes!\n")
521     @pytest.mark.slow_test
522     def test_latest_force_reset_remote_changes(self):
523         self._test_latest_force_reset_setup()
524         ret = self.run_state("git.latest", name=self.repo, target=self.target)
525         self.assertSaltFalseReturn(ret)
526         ret = ret[next(iter(ret))]
527         self.assertIn("there are uncommitted changes", ret["comment"])
528         self.assertIn("Set 'force_reset' to True (or 'remote-changes')", ret["comment"])
529         self.assertEqual(ret["changes"], {})
530         ret = self.run_state(
531             "git.latest",
532             name=self.repo,
533             target=self.target,
534             force_reset="remote-changes",
535         self.assertSaltTrueReturn(ret)
536         ret = ret[next(iter(ret))]
537         self<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.assertIn("Uncommitted changes were discarded", ret["comment"])
538         self.assertIn("Repository was fast-forwarded", ret["comment"])
539         self.assertNotIn("forced update", ret["changes"])
540         self.assertIn("revision", ret[</b></font>"changes"])
541         with salt.utils.files.fopen(os.path.join(self.target, "foo"), "a") as fp_:
542             fp_.write("More local changes!\n")
543         ret = self.run_state(
544             "git.latest",
545             name=self.repo,
546             target=self.target,
547             force_reset="remote-changes",
548         )
549         self.assertSaltTrueReturn(ret)
550         ret = ret[next(iter(ret))]
551         self.assertIn("up-to-date, but with uncommitted changes", ret["comment"])
552         self.assertIn(
553             "Set 'force_reset' to True to purge uncommitted changes", ret["comment"]
554         )
555         self.assertEqual(ret["changes"], {})
556     @pytest.mark.slow_test
557     def test_latest_force_reset_true_fast_forward(self):
558         self._test_latest_force_reset_setup()
559         ret = self.run_state(
560             "git.latest", name=self.repo, target=self.target, force_reset=True
561         )
562         self.assertSaltTrueReturn(ret)
563         ret = ret[next(iter(ret))]
564         self.assertIn("Uncommitted changes were discarded", ret["comment"])
565         self.assertIn("Repository was fast-forwarded", ret["comment"])
566         with salt.utils.files.fopen(os.path.join(self.target, "foo"), "a") as fp_:
567             fp_.write("More local changes!\n")
568         ret = self.run_state("git.latest", name=self.repo, target=self.target)
569         self.assertSaltTrueReturn(ret)
570         ret = ret[next(iter(ret))]
571         self.assertIn("up-to-date, but with uncommitted changes", ret["comment"])
572         self.assertIn(
573             "Set 'force_reset' to True to purge uncommitted changes", ret["comment"]
574         )
575         self.assertEqual(ret["changes"], {})
576         ret = self.run_state(
577             "git.latest", name=TEST_REPO, target=self.target, force_reset=True
578         )
579         self.assertSaltTrueReturn(ret)
580         ret = ret[next(iter(ret))]
581         assert "Uncommitted changes were discarded" in ret["comment"]
582         assert "Repository was hard-reset" in ret["comment"]
583         assert "forced update" in ret["changes"]
584     @pytest.mark.slow_test
585     def test_latest_force_reset_true_non_fast_forward(self):
586         self._test_latest_force_reset_setup()
587         ret = self.run_state(
588             "git.latest", name=self.repo, target=self.target, force_reset=True
589         )
590         self.assertSaltTrueReturn(ret)
591         ret = ret[next(iter(ret))]
592         self.assertIn("Uncommitted changes were discarded", ret["comment"])
593         self.assertIn("Repository was fast-forwarded", ret["comment"])
594         self._commit(self.admin, content="New line\n", message="added another line")
595         self._push(self.admin)
596         self._commit(
597             self.target,
598             content="Different new line\n",
599             message="added a different line",
600         )
601         ret = self.run_state("git.latest", name=self.repo, target=self.target)
602         self.assertSaltFalseReturn(ret)
603         ret = ret[next(iter(ret))]
604         self.assertIn("this is not a fast-forward merge", ret["comment"])
605         self.assertIn("Set 'force_reset' to True to force this update", ret["comment"])
606         self.assertEqual(ret["changes"], {})
607         ret = self.run_state(
608             "git.latest", name=self.repo, target=self.target, force_reset=True
609         )
610         self.assertSaltTrueReturn(ret)
611         ret = ret[next(iter(ret))]
612         self.assertIn("Repository was hard-reset", ret["comment"])
613         self.assertIn("forced update", ret["changes"])
614         self.assertIn("revision", ret["changes"])
615     @pytest.mark.slow_test
616     def test_renamed_default_branch(self):
617         os.rename(
618             os.path.join(self.repo, "refs", "heads", "master"),
619             os.path.join(self.repo, "refs", "heads", "develop"),
620         )
621         ret = self.run_state(
622             "git.latest",
623             name=self.repo,
624             target=self.target,
625             rev="develop",
626         )
627         self.assertSaltFalseReturn(ret)
628         self.assertEqual(
629             ret[next(iter(ret))]["comment"],
630             "Remote HEAD refers to a ref that does not exist. "
631             "This can happen when the default branch on the "
632             "remote repository is renamed or deleted. If you "
633             "are unable to fix the remote repository, you can "
634             "work around this by setting the 'branch' argument "
635             "(which will ensure that the named branch is created "
636             "if it does not already exist).\n\n"
637             "Changes already made: {} cloned to {}".format(self.repo, self.target),
638         )
639         self.assertEqual(
640             ret[next(iter(ret))]["changes"],
641             {"new": "{} =&gt; {}".format(self.repo, self.target)},
642         )
643         ret = self.run_state(
644             "git.latest",
645             name=self.repo,
646             target=self.target,
647             rev="develop",
648         )
649         self.assertSaltFalseReturn(ret)
650         self.assertEqual(
651             ret[next(iter(ret))]["comment"],
652             "Cannot set/unset upstream tracking branch, local "
653             "HEAD refers to nonexistent branch. This may have "
654             "been caused by cloning a remote repository for which "
655             "the default branch was renamed or deleted. If you "
656             "are unable to fix the remote repository, you can "
657             "work around this by setting the 'branch' argument "
658             "(which will ensure that the named branch is created "
659             "if it does not already exist).",
660         )
661         self.assertEqual(ret[next(iter(ret))]["changes"], {})
662         ret = self.run_state(
663             "git.latest",
664             name=self.repo,
665             target=self.target,
666             rev="develop",
667             branch="develop",
668         )
669         self.assertSaltTrueReturn(ret)
670         self.assertSaltCommentRegexpMatches(
671             ret,
672             "New branch 'develop' was checked out, with origin/develop "
673             r"\([0-9a-f]{7}\) as a starting point",
674         )
675         self.assertEqual(list(ret[next(iter(ret))]["changes"].keys()), ["revision"])
676         self.assertEqual(ret[next(iter(ret))]["changes"]["revision"]["old"], None)
677         self.assertTrue(len(ret[next(iter(ret))]["changes"]["revision"]["new"]) == 40)
678         self.assertTrue(
679             all(
680                 [
681                     x in string.hexdigits
682                     for x in ret[next(iter(ret))]["changes"]["revision"]["new"]
683                 ]
684             )
685         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
