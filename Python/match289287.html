<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for grafana_dashboard.py &amp; boto_vpc_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for grafana_dashboard.py &amp; boto_vpc_1.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>grafana_dashboard.py (1.897019%)<th>boto_vpc_1.py (0.3711559%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-99)<td><a href="#" name="0">(1572-1588)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>grafana_dashboard.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import requests
3 import salt.utils.json
4 from salt.utils.dictdiffer import DictDiffer
5 def __virtual__():
6     if __salt__["config.get"]("grafana_version", 1) == 2:
7         return True
8     return (False, "Not configured for grafana_version 2")
9 _DEFAULT_DASHBOARD_PILLAR = "grafana_dashboards:default"
10 _DEFAULT_PANEL_PILLAR = "grafana_panels:default"
11 _DEFAULT_ROW_PILLAR = "grafana_rows:default"
12 <a name="0"></a>_PINNED_ROWS_PILLAR = "grafana_pinned_rows"
13 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def present(
14     name,
15     base_dashboards_from_pillar=None,
16     base_panels_from_pillar=None,
17     base_rows_from_pillar=None,
18     dashboard=None,
19     profile="grafana",
20 ):
21     ret = {"name": name, "result": True, "comment": "", "changes": {}}
22     base_dashboards_from_pillar = base_dashboards_from_pillar or []
23     base_panels_from_pillar = base_panels_from_pillar or []
24     base_rows_from_pillar = base_rows_from_pillar or []
25     dashboard = dashboard or {}
26     if isinstance(</b></font>profile, str):
27         profile = __salt__["config.option"](profile)
28     base_dashboards_from_pillar = [
29         _DEFAULT_DASHBOARD_PILLAR
30     ] + base_dashboards_from_pillar
31     base_panels_from_pillar = [_DEFAULT_PANEL_PILLAR] + base_panels_from_pillar
32     base_rows_from_pillar = [_DEFAULT_ROW_PILLAR] + base_rows_from_pillar
33     new_dashboard = _inherited_dashboard(dashboard, base_dashboards_from_pillar, ret)
34     new_dashboard["title"] = name
35     rows = new_dashboard.get("rows", [])
36     for i, row in enumerate(rows):
37         rows[i] = _inherited_row(row, base_rows_from_pillar, ret)
38     for row in rows:
39         panels = row.get("panels", [])
40         for i, panel in enumerate(panels):
41             panels[i] = _inherited_panel(panel, base_panels_from_pillar, ret)
42     _auto_adjust_panel_spans(new_dashboard)
43     _ensure_panel_ids(new_dashboard)
44     _ensure_annotations(new_dashboard)
45     url = "db/{}".format(name)
46     old_dashboard = _get(url, profile)
47     if not old_dashboard:
48         if __opts__["test"]:
49             ret["result"] = None
50             ret["comment"] = "Dashboard {} is set to be created.".format(name)
51             return ret
52         response = _update(new_dashboard, profile)
53         if response.get("status") == "success":
54             ret["comment"] = "Dashboard {} created.".format(name)
55             ret["changes"]["new"] = "Dashboard {} created.".format(name)
56         else:
57             ret["result"] = False
58             ret["comment"] = "Failed to create dashboard {}, response={}".format(
59                 name, response
60             )
61         return ret
62     managed_row_titles = [row.get("title") for row in new_dashboard.get("rows", [])]
63     new_rows = new_dashboard.get("rows", [])
64     for old_row in old_dashboard.get("rows", []):
65         if old_row.get("title") not in managed_row_titles:
66             new_rows.append(copy.deepcopy(old_row))
67     _ensure_pinned_rows(new_dashboard)
68     _ensure_panel_ids(new_dashboard)
69     dashboard_diff = DictDiffer(_cleaned(new_dashboard), _cleaned(old_dashboard))
70     updated_needed = (
71         dashboard_diff.changed() or dashboard_diff.added() or dashboard_diff.removed()
72     )
73     if updated_needed:
74         if __opts__["test"]:
75             ret["result"] = None
76             ret["comment"] = "Dashboard {} is set to be updated, changes={}".format(
77                 name,
78                 salt.utils.json.dumps(
79                     _dashboard_diff(_cleaned(new_dashboard), _cleaned(old_dashboard)),
80                     indent=4,
81                 ),
82             )
83             return ret
84         response = _update(new_dashboard, profile)
85         if response.get("status") == "success":
86             updated_dashboard = _get(url, profile)
87             dashboard_diff = DictDiffer(
88                 _cleaned(updated_dashboard), _cleaned(old_dashboard)
89             )
90             ret["comment"] = "Dashboard {} updated.".format(name)
91             ret["changes"] = _dashboard_diff(
92                 _cleaned(new_dashboard), _cleaned(old_dashboard)
93             )
94         else:
95             ret["result"] = False
96             ret["comment"] = "Failed to update dashboard {}, response={}".format(
97                 name, response
98             )
99         return ret
100     ret["comment"] = "Dashboard present"
101     return ret
102 def absent(name, profile="grafana"):
103     ret = {"name": name, "result": True, "comment": "", "changes": {}}
104     if isinstance(profile, str):
105         profile = __salt__["config.option"](profile)
106     url = "db/{}".format(name)
107     existing_dashboard = _get(url, profile)
108     if existing_dashboard:
109         if __opts__["test"]:
110             ret["result"] = None
111             ret["comment"] = "Dashboard {} is set to be deleted.".format(name)
112             return ret
113         _delete(url, profile)
114         ret["comment"] = "Dashboard {} deleted.".format(name)
115         ret["changes"]["new"] = "Dashboard {} deleted.".format(name)
116         return ret
117     ret["comment"] = "Dashboard absent"
118     return ret
119 _IGNORED_DASHBOARD_FIELDS = [
120     "id",
121     "originalTitle",
122     "version",
123 ]
124 _IGNORED_ROW_FIELDS = []
125 _IGNORED_PANEL_FIELDS = [
126     "grid",
127     "mode",
128     "tooltip",
129 ]
130 _IGNORED_TARGET_FIELDS = [
131     "textEditor",
132 ]
133 def _cleaned(_dashboard):
134     dashboard = copy.deepcopy(_dashboard)
135     for ignored_dashboard_field in _IGNORED_DASHBOARD_FIELDS:
136         dashboard.pop(ignored_dashboard_field, None)
137     for row in dashboard.get("rows", []):
138         for ignored_row_field in _IGNORED_ROW_FIELDS:
139             row.pop(ignored_row_field, None)
140         for i, panel in enumerate(row.get("panels", [])):
141             for ignored_panel_field in _IGNORED_PANEL_FIELDS:
142                 panel.pop(ignored_panel_field, None)
143             for target in panel.get("targets", []):
144                 for ignored_target_field in _IGNORED_TARGET_FIELDS:
145                     target.pop(ignored_target_field, None)
146             row["panels"][i] = _stripped(panel)
147     return dashboard
148 def _inherited_dashboard(dashboard, base_dashboards_from_pillar, ret):
149     base_dashboards = []
150     for base_dashboard_from_pillar in base_dashboards_from_pillar:
151         base_dashboard = __salt__["pillar.get"](base_dashboard_from_pillar)
152         if base_dashboard:
153             base_dashboards.append(base_dashboard)
154         elif base_dashboard_from_pillar != _DEFAULT_DASHBOARD_PILLAR:
155             ret.setdefault("warnings", [])
156             warning_message = 'Cannot find dashboard pillar "{}".'.format(
157                 base_dashboard_from_pillar
158             )
159             if warning_message not in ret["warnings"]:
160                 ret["warnings"].append(warning_message)
161     base_dashboards.append(dashboard)
162     result_dashboard = {}
163     tags = set()
164     for dashboard in base_dashboards:
165         tags.update(dashboard.get("tags", []))
166         result_dashboard.update(dashboard)
167     result_dashboard["tags"] = list(tags)
168     return result_dashboard
169 def _inherited_row(row, base_rows_from_pillar, ret):
170     base_rows = []
171     for base_row_from_pillar in base_rows_from_pillar:
172         base_row = __salt__["pillar.get"](base_row_from_pillar)
173         if base_row:
174             base_rows.append(base_row)
175         elif base_row_from_pillar != _DEFAULT_ROW_PILLAR:
176             ret.setdefault("warnings", [])
177             warning_message = 'Cannot find row pillar "{}".'.format(
178                 base_row_from_pillar
179             )
180             if warning_message not in ret["warnings"]:
181                 ret["warnings"].append(warning_message)
182     base_rows.append(row)
183     result_row = {}
184     for row in base_rows:
185         result_row.update(row)
186     return result_row
187 def _inherited_panel(panel, base_panels_from_pillar, ret):
188     base_panels = []
189     for base_panel_from_pillar in base_panels_from_pillar:
190         base_panel = __salt__["pillar.get"](base_panel_from_pillar)
191         if base_panel:
192             base_panels.append(base_panel)
193         elif base_panel_from_pillar != _DEFAULT_PANEL_PILLAR:
194             ret.setdefault("warnings", [])
195             warning_message = 'Cannot find panel pillar "{}".'.format(
196                 base_panel_from_pillar
197             )
198             if warning_message not in ret["warnings"]:
199                 ret["warnings"].append(warning_message)
200     base_panels.append(panel)
201     result_panel = {}
202     for panel in base_panels:
203         result_panel.update(panel)
204     return result_panel
205 _FULL_LEVEL_SPAN = 12
206 _DEFAULT_PANEL_SPAN = 2.5
207 def _auto_adjust_panel_spans(dashboard):
208     for row in dashboard.get("rows", []):
209         levels = []
210         current_level = []
211         levels.append(current_level)
212         for panel in row.get("panels", []):
213             current_level_span = sum(
214                 panel.get("span", _DEFAULT_PANEL_SPAN) for panel in current_level
215             )
216             span = panel.get("span", _DEFAULT_PANEL_SPAN)
217             if current_level_span + span &gt; _FULL_LEVEL_SPAN:
218                 current_level = [panel]
219                 levels.append(current_level)
220             else:
221                 current_level.append(panel)
222         for level in levels:
223             specified_panels = [panel for panel in level if "span" in panel]
224             unspecified_panels = [panel for panel in level if "span" not in panel]
225             if not unspecified_panels:
226                 continue
227             specified_span = sum(panel["span"] for panel in specified_panels)
228             available_span = _FULL_LEVEL_SPAN - specified_span
229             auto_span = float(available_span) / len(unspecified_panels)
230             for panel in unspecified_panels:
231                 panel["span"] = auto_span
232 def _ensure_pinned_rows(dashboard):
233     pinned_row_titles = __salt__["pillar.get"](_PINNED_ROWS_PILLAR)
234     if not pinned_row_titles:
235         return
236     pinned_row_titles_lower = []
237     for title in pinned_row_titles:
238         pinned_row_titles_lower.append(title.lower())
239     rows = dashboard.get("rows", [])
240     pinned_rows = []
241     for i, row in enumerate(rows):
242         if row.get("title", "").lower() in pinned_row_titles_lower:
243             del rows[i]
244             pinned_rows.append(row)
245     rows = pinned_rows + rows
246 def _ensure_panel_ids(dashboard):
247     panel_id = 1
248     for row in dashboard.get("rows", []):
249         for panel in row.get("panels", []):
250             panel["id"] = panel_id
251             panel_id += 1
252 def _ensure_annotations(dashboard):
253     if "annotation_tags" not in dashboard:
254         return
255     tags = dashboard["annotation_tags"]
256     annotations = {
257         "enable": True,
258         "list": [],
259     }
260     for tag in tags:
261         annotations["list"].append(
262             {
263                 "datasource": "graphite",
264                 "enable": False,
265                 "iconColor": "#C0C6BE",
266                 "iconSize": 13,
267                 "lineColor": "rgba(255, 96, 96, 0.592157)",
268                 "name": tag,
269                 "showLine": True,
270                 "tags": tag,
271             }
272         )
273     del dashboard["annotation_tags"]
274     dashboard["annotations"] = annotations
275 def _get(url, profile):
276     request_url = "{}/api/dashboards/{}".format(profile.get("grafana_url"), url)
277     response = requests.get(
278         request_url,
279         headers={
280             "Accept": "application/json",
281             "Authorization": "Bearer {}".format(profile.get("grafana_token")),
282         },
283         timeout=profile.get("grafana_timeout", 3),
284     )
285     data = response.json()
286     if data.get("message") == "Not found":
287         return None
288     if "dashboard" not in data:
289         return None
290     return data["dashboard"]
291 def _delete(url, profile):
292     request_url = "{}/api/dashboards/{}".format(profile.get("grafana_url"), url)
293     response = requests.delete(
294         request_url,
295         headers={
296             "Accept": "application/json",
297             "Authorization": "Bearer {}".format(profile.get("grafana_token")),
298         },
299         timeout=profile.get("grafana_timeout"),
300     )
301     data = response.json()
302     return data
303 def _update(dashboard, profile):
304     payload = {"dashboard": dashboard, "overwrite": True}
305     request_url = "{}/api/dashboards/db".format(profile.get("grafana_url"))
306     response = requests.post(
307         request_url,
308         headers={"Authorization": "Bearer {}".format(profile.get("grafana_token"))},
309         json=payload,
310     )
311     return response.json()
312 def _dashboard_diff(_new_dashboard, _old_dashboard):
313     diff = {}
314     new_dashboard = copy.deepcopy(_new_dashboard)
315     old_dashboard = copy.deepcopy(_old_dashboard)
316     dashboard_diff = DictDiffer(new_dashboard, old_dashboard)
317     diff["dashboard"] = _stripped(
318         {
319             "changed": list(dashboard_diff.changed()) or None,
320             "added": list(dashboard_diff.added()) or None,
321             "removed": list(dashboard_diff.removed()) or None,
322         }
323     )
324     new_rows = new_dashboard.get("rows", [])
325     old_rows = old_dashboard.get("rows", [])
326     new_rows_by_title = {}
327     old_rows_by_title = {}
328     for row in new_rows:
329         if "title" in row:
330             new_rows_by_title[row["title"]] = row
331     for row in old_rows:
332         if "title" in row:
333             old_rows_by_title[row["title"]] = row
334     rows_diff = DictDiffer(new_rows_by_title, old_rows_by_title)
335     diff["rows"] = _stripped(
336         {
337             "added": list(rows_diff.added()) or None,
338             "removed": list(rows_diff.removed()) or None,
339         }
340     )
341     for changed_row_title in rows_diff.changed():
342         old_row = old_rows_by_title[changed_row_title]
343         new_row = new_rows_by_title[changed_row_title]
344         row_diff = DictDiffer(new_row, old_row)
345         diff["rows"].setdefault("changed", {})
346         diff["rows"]["changed"][changed_row_title] = _stripped(
347             {
348                 "changed": list(row_diff.changed()) or None,
349                 "added": list(row_diff.added()) or None,
350                 "removed": list(row_diff.removed()) or None,
351             }
352         )
353     old_panels_by_id = {}
354     new_panels_by_id = {}
355     for row in old_dashboard.get("rows", []):
356         for panel in row.get("panels", []):
357             if "id" in panel:
358                 old_panels_by_id[panel["id"]] = panel
359     for row in new_dashboard.get("rows", []):
360         for panel in row.get("panels", []):
361             if "id" in panel:
362                 new_panels_by_id[panel["id"]] = panel
363     panels_diff = DictDiffer(new_panels_by_id, old_panels_by_id)
364     diff["panels"] = _stripped(
365         {
366             "added": list(panels_diff.added()) or None,
367             "removed": list(panels_diff.removed()) or None,
368         }
369     )
370     for changed_panel_id in panels_diff.changed():
371         old_panel = old_panels_by_id[changed_panel_id]
372         new_panel = new_panels_by_id[changed_panel_id]
373         panels_diff = DictDiffer(new_panel, old_panel)
374         diff["panels"].setdefault("changed", {})
375         diff["panels"]["changed"][changed_panel_id] = _stripped(
376             {
377                 "changed": list(panels_diff.changed()) or None,
378                 "added": list(panels_diff.added()) or None,
379                 "removed": list(panels_diff.removed()) or None,
380             }
381         )
382     return diff
383 def _stripped(d):
384     ret = {}
385     for k, v in d.items():
386         if v:
387             ret[k] = v
388     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_vpc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import random
3 import socket
4 import time
5 import salt.utils.compat
6 import salt.utils.versions
7 from salt.exceptions import CommandExecutionError, SaltInvocationError
8 PROVISIONING = "provisioning"
9 PENDING_ACCEPTANCE = "pending-acceptance"
10 ACTIVE = "active"
11 log = logging.getLogger(__name__)
12 try:
13     import boto
14     import botocore
15     import boto.vpc
16     from boto.exception import BotoServerError
17     logging.getLogger("boto").setLevel(logging.CRITICAL)
18     HAS_BOTO = True
19 except ImportError:
20     HAS_BOTO = False
21 try:
22     import boto3
23     logging.getLogger("boto3").setLevel(logging.CRITICAL)
24     HAS_BOTO3 = True
25 except ImportError:
26     HAS_BOTO3 = False
27 def __virtual__():
28     return salt.utils.versions.check_boto_reqs(boto_ver="2.8.0", boto3_ver="1.2.6")
29 def __init__(opts):
30     if HAS_BOTO:
31         __utils__["boto.assign_funcs"](__name__, "vpc", pack=__salt__)
32     if HAS_BOTO3:
33         __utils__["boto3.assign_funcs"](
34             __name__,
35             "ec2",
36             get_conn_funcname="_get_conn3",
37             cache_id_funcname="_cache_id3",
38             exactly_one_funcname=None,
39         )
40 def check_vpc(
41     vpc_id=None,
42     vpc_name=None,
43     region=None,
44     key=None,
45     keyid=None,
46     profile=None,
47 ):
48     if not _exactly_one((vpc_name, vpc_id)):
49         raise SaltInvocationError(
50             "One (but not both) of vpc_id or vpc_name must be provided."
51         )
52     if vpc_name:
53         vpc_id = _get_id(
54             vpc_name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
55         )
56     elif not _find_vpcs(
57         vpc_id=vpc_id, region=region, key=key, keyid=keyid, profile=profile
58     ):
59         log.info("VPC %s does not exist.", vpc_id)
60         return None
61     return vpc_id
62 def _create_resource(
63     resource,
64     name=None,
65     tags=None,
66     region=None,
67     key=None,
68     keyid=None,
69     profile=None,
70     **kwargs
71 ):
72     try:
73         try:
74             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
75             create_resource = getattr(conn, "create_" + resource)
76         except AttributeError:
77             raise AttributeError(
78                 "{} function does not exist for boto VPC connection.".format(
79                     "create_" + resource
80                 )
81             )
82         if name and _get_resource_id(
83             resource, name, region=region, key=key, keyid=keyid, profile=profile
84         ):
85             return {
86                 "created": False,
87                 "error": {
88                     "message": "A {} named {} already exists.".format(resource, name)
89                 },
90             }
91         r = create_resource(**kwargs)
92         if r:
93             if isinstance(r, bool):
94                 return {"created": True}
95             else:
96                 log.info("A %s with id %s was created", resource, r.id)
97                 _maybe_set_name_tag(name, r)
98                 _maybe_set_tags(tags, r)
99                 if name:
100                     _cache_id(
101                         name,
102                         sub_resource=resource,
103                         resource_id=r.id,
104                         region=region,
105                         key=key,
106                         keyid=keyid,
107                         profile=profile,
108                     )
109                 return {"created": True, "id": r.id}
110         else:
111             if name:
112                 e = "{} {} was not created.".format(resource, name)
113             else:
114                 e = "{} was not created.".format(resource)
115             log.warning(e)
116             return {"created": False, "error": {"message": e}}
117     except BotoServerError as e:
118         return {"created": False, "error": __utils__["boto.get_error"](e)}
119 def _delete_resource(
120     resource,
121     name=None,
122     resource_id=None,
123     region=None,
124     key=None,
125     keyid=None,
126     profile=None,
127     **kwargs
128 ):
129     if not _exactly_one((name, resource_id)):
130         raise SaltInvocationError("One (but not both) of name or id must be provided.")
131     try:
132         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
133         try:
134             delete_resource = getattr(conn, "delete_" + resource)
135         except AttributeError:
136             raise AttributeError(
137                 "{} function does not exist for boto VPC connection.".format(
138                     "delete_" + resource
139                 )
140             )
141         if name:
142             resource_id = _get_resource_id(
143                 resource, name, region=region, key=key, keyid=keyid, profile=profile
144             )
145             if not resource_id:
146                 return {
147                     "deleted": False,
148                     "error": {
149                         "message": "{} {} does not exist.".format(resource, name)
150                     },
151                 }
152         if delete_resource(resource_id, **kwargs):
153             _cache_id(
154                 name,
155                 sub_resource=resource,
156                 resource_id=resource_id,
157                 invalidate=True,
158                 region=region,
159                 key=key,
160                 keyid=keyid,
161                 profile=profile,
162             )
163             return {"deleted": True}
164         else:
165             if name:
166                 e = "{} {} was not deleted.".format(resource, name)
167             else:
168                 e = "{} was not deleted.".format(resource)
169             return {"deleted": False, "error": {"message": e}}
170     except BotoServerError as e:
171         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
172 def _get_resource(
173     resource,
174     name=None,
175     resource_id=None,
176     region=None,
177     key=None,
178     keyid=None,
179     profile=None,
180 ):
181     if not _exactly_one((name, resource_id)):
182         raise SaltInvocationError("One (but not both) of name or id must be provided.")
183     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
184     f = "get_all_{}".format(resource)
185     if not f.endswith("s"):
186         f = f + "s"
187     get_resources = getattr(conn, f)
188     filter_parameters = {}
189     if name:
190         filter_parameters["filters"] = {"tag:Name": name}
191     if resource_id:
192         filter_parameters["{}_ids".format(resource)] = resource_id
193     try:
194         r = get_resources(**filter_parameters)
195     except BotoServerError as e:
196         if e.code.endswith(".NotFound"):
197             return None
198         raise
199     if r:
200         if len(r) == 1:
201             if name:
202                 _cache_id(
203                     name,
204                     sub_resource=resource,
205                     resource_id=r[0].id,
206                     region=region,
207                     key=key,
208                     keyid=keyid,
209                     profile=profile,
210                 )
211             return r[0]
212         else:
213             raise CommandExecutionError(
214                 'Found more than one {} named "{}"'.format(resource, name)
215             )
216     else:
217         return None
218 def _find_resources(
219     resource,
220     name=None,
221     resource_id=None,
222     tags=None,
223     region=None,
224     key=None,
225     keyid=None,
226     profile=None,
227 ):
228     if all((resource_id, name)):
229         raise SaltInvocationError("Only one of name or id may be provided.")
230     if not any((resource_id, name, tags)):
231         raise SaltInvocationError(
232             "At least one of the following must be provided: id, name, or tags."
233         )
234     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
235     f = "get_all_{}".format(resource)
236     if not f.endswith("s"):
237         f = f + "s"
238     get_resources = getattr(conn, f)
239     filter_parameters = {}
240     if name:
241         filter_parameters["filters"] = {"tag:Name": name}
242     if resource_id:
243         filter_parameters["{}_ids".format(resource)] = resource_id
244     if tags:
245         for tag_name, tag_value in tags.items():
246             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
247     try:
248         r = get_resources(**filter_parameters)
249     except BotoServerError as e:
250         if e.code.endswith(".NotFound"):
251             return None
252         raise
253     return r
254 def _get_resource_id(resource, name, region=None, key=None, keyid=None, profile=None):
255     _id = _cache_id(
256         name,
257         sub_resource=resource,
258         region=region,
259         key=key,
260         keyid=keyid,
261         profile=profile,
262     )
263     if _id:
264         return _id
265     r = _get_resource(
266         resource, name=name, region=region, key=key, keyid=keyid, profile=profile
267     )
268     if r:
269         return r.id
270 def get_resource_id(
271     resource,
272     name=None,
273     resource_id=None,
274     region=None,
275     key=None,
276     keyid=None,
277     profile=None,
278 ):
279     try:
280         return {
281             "id": _get_resource_id(
282                 resource, name, region=region, key=key, keyid=keyid, profile=profile
283             )
284         }
285     except BotoServerError as e:
286         return {"error": __utils__["boto.get_error"](e)}
287 def resource_exists(
288     resource,
289     name=None,
290     resource_id=None,
291     tags=None,
292     region=None,
293     key=None,
294     keyid=None,
295     profile=None,
296 ):
297     try:
298         return {
299             "exists": bool(
300                 _find_resources(
301                     resource,
302                     name=name,
303                     resource_id=resource_id,
304                     tags=tags,
305                     region=region,
306                     key=key,
307                     keyid=keyid,
308                     profile=profile,
309                 )
310             )
311         }
312     except BotoServerError as e:
313         return {"error": __utils__["boto.get_error"](e)}
314 def _find_vpcs(
315     vpc_id=None,
316     vpc_name=None,
317     cidr=None,
318     tags=None,
319     region=None,
320     key=None,
321     keyid=None,
322     profile=None,
323 ):
324     if all((vpc_id, vpc_name)):
325         raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
326     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
327     filter_parameters = {"filters": {}}
328     if vpc_id:
329         filter_parameters["vpc_ids"] = [vpc_id]
330     if cidr:
331         filter_parameters["filters"]["cidr"] = cidr
332     if vpc_name:
333         filter_parameters["filters"]["tag:Name"] = vpc_name
334     if tags:
335         for tag_name, tag_value in tags.items():
336             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
337     vpcs = conn.get_all_vpcs(**filter_parameters)
338     log.debug(
339         "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
340     )
341     if vpcs:
342         if not any((vpc_id, vpc_name, cidr, tags)):
343             return [vpc.id for vpc in vpcs if vpc.is_default]
344         else:
345             return [vpc.id for vpc in vpcs]
346     else:
347         return []
348 def _get_id(
349     vpc_name=None,
350     cidr=None,
351     tags=None,
352     region=None,
353     key=None,
354     keyid=None,
355     profile=None,
356 ):
357     if not any((vpc_name, tags, cidr)):
358         raise SaltInvocationError(
359             "At least one of the following must be provided: vpc_name, cidr or tags."
360         )
361     if vpc_name and not any((cidr, tags)):
362         vpc_id = _cache_id(
363             vpc_name, region=region, key=key, keyid=keyid, profile=profile
364         )
365         if vpc_id:
366             return vpc_id
367     vpc_ids = _find_vpcs(
368         vpc_name=vpc_name,
369         cidr=cidr,
370         tags=tags,
371         region=region,
372         key=key,
373         keyid=keyid,
374         profile=profile,
375     )
376     if vpc_ids:
377         log.debug("Matching VPC: %s", " ".join(vpc_ids))
378         if len(vpc_ids) == 1:
379             vpc_id = vpc_ids[0]
380             if vpc_name:
381                 _cache_id(
382                     vpc_name,
383                     vpc_id,
384                     region=region,
385                     key=key,
386                     keyid=keyid,
387                     profile=profile,
388                 )
389             return vpc_id
390         else:
391             raise CommandExecutionError(
392                 "Found more than one VPC matching the criteria."
393             )
394     else:
395         log.info("No VPC found.")
396         return None
397 def get_id(
398     name=None,
399     cidr=None,
400     tags=None,
401     region=None,
402     key=None,
403     keyid=None,
404     profile=None,
405 ):
406     try:
407         return {
408             "id": _get_id(
409                 vpc_name=name,
410                 cidr=cidr,
411                 tags=tags,
412                 region=region,
413                 key=key,
414                 keyid=keyid,
415                 profile=profile,
416             )
417         }
418     except BotoServerError as e:
419         return {"error": __utils__["boto.get_error"](e)}
420 def exists(
421     vpc_id=None,
422     name=None,
423     cidr=None,
424     tags=None,
425     region=None,
426     key=None,
427     keyid=None,
428     profile=None,
429 ):
430     if not any((vpc_id, name, tags, cidr)):
431         raise SaltInvocationError(
432             "At least one of the following must be "
433             "provided: vpc_id, vpc_name, cidr or tags."
434         )
435     try:
436         vpc_ids = _find_vpcs(
437             vpc_id=vpc_id,
438             vpc_name=name,
439             cidr=cidr,
440             tags=tags,
441             region=region,
442             key=key,
443             keyid=keyid,
444             profile=profile,
445         )
446     except BotoServerError as err:
447         boto_err = __utils__["boto.get_error"](err)
448         if boto_err.get("aws", {}).get("code") == "InvalidVpcID.NotFound":
449             return {"exists": False}
450         return {"error": boto_err}
451     return {"exists": bool(vpc_ids)}
452 def create(
453     cidr_block,
454     instance_tenancy=None,
455     vpc_name=None,
456     enable_dns_support=None,
457     enable_dns_hostnames=None,
458     tags=None,
459     region=None,
460     key=None,
461     keyid=None,
462     profile=None,
463 ):
464     try:
465         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
466         vpc = conn.create_vpc(cidr_block, instance_tenancy=instance_tenancy)
467         if vpc:
468             log.info("The newly created VPC id is %s", vpc.id)
469             _maybe_set_name_tag(vpc_name, vpc)
470             _maybe_set_tags(tags, vpc)
471             _maybe_set_dns(conn, vpc.id, enable_dns_support, enable_dns_hostnames)
472             _maybe_name_route_table(conn, vpc.id, vpc_name)
473             if vpc_name:
474                 _cache_id(
475                     vpc_name,
476                     vpc.id,
477                     region=region,
478                     key=key,
479                     keyid=keyid,
480                     profile=profile,
481                 )
482             return {"created": True, "id": vpc.id}
483         else:
484             log.warning("VPC was not created")
485             return {"created": False}
486     except BotoServerError as e:
487         return {"created": False, "error": __utils__["boto.get_error"](e)}
488 def delete(
489     vpc_id=None,
490     name=None,
491     vpc_name=None,
492     tags=None,
493     region=None,
494     key=None,
495     keyid=None,
496     profile=None,
497 ):
498     if name:
499         log.warning(
500             "boto_vpc.delete: name parameter is deprecated use vpc_name instead."
501         )
502         vpc_name = name
503     if not _exactly_one((vpc_name, vpc_id)):
504         raise SaltInvocationError(
505             "One (but not both) of vpc_name or vpc_id must be provided."
506         )
507     try:
508         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
509         if not vpc_id:
510             vpc_id = _get_id(
511                 vpc_name=vpc_name,
512                 tags=tags,
513                 region=region,
514                 key=key,
515                 keyid=keyid,
516                 profile=profile,
517             )
518             if not vpc_id:
519                 return {
520                     "deleted": False,
521                     "error": {"message": "VPC {} not found".format(vpc_name)},
522                 }
523         if conn.delete_vpc(vpc_id):
524             log.info("VPC %s was deleted.", vpc_id)
525             if vpc_name:
526                 _cache_id(
527                     vpc_name,
528                     resource_id=vpc_id,
529                     invalidate=True,
530                     region=region,
531                     key=key,
532                     keyid=keyid,
533                     profile=profile,
534                 )
535             return {"deleted": True}
536         else:
537             log.warning("VPC %s was not deleted.", vpc_id)
538             return {"deleted": False}
539     except BotoServerError as e:
540         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
541 def describe(
542     vpc_id=None,
543     vpc_name=None,
544     region=None,
545     key=None,
546     keyid=None,
547     profile=None,
548 ):
549     try:
550         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
551         vpc_id = _find_vpcs(
552             vpc_id=vpc_id,
553             vpc_name=vpc_name,
554             region=region,
555             key=key,
556             keyid=keyid,
557             profile=profile,
558         )
559     except BotoServerError as err:
560         boto_err = __utils__["boto.get_error"](err)
561         if boto_err.get("aws", {}).get("code") == "InvalidVpcID.NotFound":
562             return {"vpc": None}
563         return {"error": boto_err}
564     if not vpc_id:
565         return {"vpc": None}
566     filter_parameters = {"vpc_ids": vpc_id}
567     try:
568         vpcs = conn.get_all_vpcs(**filter_parameters)
569     except BotoServerError as err:
570         return {"error": __utils__["boto.get_error"](err)}
571     if vpcs:
572         vpc = vpcs[0]  # Found!
573         log.debug("Found VPC: %s", vpc.id)
574         keys = (
575             "id",
576             "cidr_block",
577             "is_default",
578             "state",
579             "tags",
580             "dhcp_options_id",
581             "instance_tenancy",
582         )
583         _r = {k: getattr(vpc, k) for k in keys}
584         _r.update({"region": getattr(vpc, "region").name})
585         return {"vpc": _r}
586     else:
587         return {"vpc": None}
588 def describe_vpcs(
589     vpc_id=None,
590     name=None,
591     cidr=None,
592     tags=None,
593     region=None,
594     key=None,
595     keyid=None,
596     profile=None,
597 ):
598     keys = (
599         "id",
600         "cidr_block",
601         "is_default",
602         "state",
603         "tags",
604         "dhcp_options_id",
605         "instance_tenancy",
606     )
607     try:
608         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
609         filter_parameters = {"filters": {}}
610         if vpc_id:
611             filter_parameters["vpc_ids"] = [vpc_id]
612         if cidr:
613             filter_parameters["filters"]["cidr"] = cidr
614         if name:
615             filter_parameters["filters"]["tag:Name"] = name
616         if tags:
617             for tag_name, tag_value in tags.items():
618                 filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
619         vpcs = conn.get_all_vpcs(**filter_parameters)
620         if vpcs:
621             ret = []
622             for vpc in vpcs:
623                 _r = {k: getattr(vpc, k) for k in keys}
624                 _r.update({"region": getattr(vpc, "region").name})
625                 ret.append(_r)
626             return {"vpcs": ret}
627         else:
628             return {"vpcs": []}
629     except BotoServerError as e:
630         return {"error": __utils__["boto.get_error"](e)}
631 def _find_subnets(subnet_name=None, vpc_id=None, cidr=None, tags=None, conn=None):
632     if not any([subnet_name, tags, cidr]):
633         raise SaltInvocationError(
634             "At least one of the following must be "
635             "specified: subnet_name, cidr or tags."
636         )
637     filter_parameters = {"filters": {}}
638     if cidr:
639         filter_parameters["filters"]["cidr"] = cidr
640     if subnet_name:
641         filter_parameters["filters"]["tag:Name"] = subnet_name
642     if vpc_id:
643         filter_parameters["filters"]["VpcId"] = vpc_id
644     if tags:
645         for tag_name, tag_value in tags.items():
646             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
647     subnets = conn.get_all_subnets(**filter_parameters)
648     log.debug(
649         "The filters criteria %s matched the following subnets: %s",
650         filter_parameters,
651         subnets,
652     )
653     if subnets:
654         return [subnet.id for subnet in subnets]
655     else:
656         return False
657 def create_subnet(
658     vpc_id=None,
659     cidr_block=None,
660     vpc_name=None,
661     availability_zone=None,
662     subnet_name=None,
663     tags=None,
664     region=None,
665     key=None,
666     keyid=None,
667     profile=None,
668     auto_assign_public_ipv4=False,
669 ):
670     try:
671         vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
672         if not vpc_id:
673             return {
674                 "created": False,
675                 "error": {
676                     "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
677                 },
678             }
679     except BotoServerError as e:
680         return {"created": False, "error": __utils__["boto.get_error"](e)}
681     subnet_object_dict = _create_resource(
682         "subnet",
683         name=subnet_name,
684         tags=tags,
685         vpc_id=vpc_id,
686         availability_zone=availability_zone,
687         cidr_block=cidr_block,
688         region=region,
689         key=key,
690         keyid=keyid,
691         profile=profile,
692     )
693     if auto_assign_public_ipv4:
694         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
695         conn3.modify_subnet_attribute(
696             MapPublicIpOnLaunch={"Value": True}, SubnetId=subnet_object_dict["id"]
697         )
698     return subnet_object_dict
699 def delete_subnet(
700     subnet_id=None, subnet_name=None, region=None, key=None, keyid=None, profile=None
701 ):
702     return _delete_resource(
703         resource="subnet",
704         name=subnet_name,
705         resource_id=subnet_id,
706         region=region,
707         key=key,
708         keyid=keyid,
709         profile=profile,
710     )
711 def subnet_exists(
712     subnet_id=None,
713     name=None,
714     subnet_name=None,
715     cidr=None,
716     tags=None,
717     zones=None,
718     region=None,
719     key=None,
720     keyid=None,
721     profile=None,
722 ):
723     if name:
724         log.warning(
725             "boto_vpc.subnet_exists: name parameter is deprecated "
726             "use subnet_name instead."
727         )
728         subnet_name = name
729     if not any((subnet_id, subnet_name, cidr, tags, zones)):
730         raise SaltInvocationError(
731             "At least one of the following must be "
732             "specified: subnet id, cidr, subnet_name, "
733             "tags, or zones."
734         )
735     try:
736         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
737     except BotoServerError as err:
738         return {"error": __utils__["boto.get_error"](err)}
739     filter_parameters = {"filters": {}}
740     if subnet_id:
741         filter_parameters["subnet_ids"] = [subnet_id]
742     if subnet_name:
743         filter_parameters["filters"]["tag:Name"] = subnet_name
744     if cidr:
745         filter_parameters["filters"]["cidr"] = cidr
746     if tags:
747         for tag_name, tag_value in tags.items():
748             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
749     if zones:
750         filter_parameters["filters"]["availability_zone"] = zones
751     try:
752         subnets = conn.get_all_subnets(**filter_parameters)
753     except BotoServerError as err:
754         boto_err = __utils__["boto.get_error"](err)
755         if boto_err.get("aws", {}).get("code") == "InvalidSubnetID.NotFound":
756             return {"exists": False}
757         return {"error": boto_err}
758     log.debug(
759         "The filters criteria %s matched the following subnets:%s",
760         filter_parameters,
761         subnets,
762     )
763     if subnets:
764         log.info("Subnet %s exists.", subnet_name or subnet_id)
765         return {"exists": True}
766     else:
767         log.info("Subnet %s does not exist.", subnet_name or subnet_id)
768         return {"exists": False}
769 def get_subnet_association(subnets, region=None, key=None, keyid=None, profile=None):
770     try:
771         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
772         subnets = conn.get_all_subnets(subnet_ids=subnets)
773     except BotoServerError as e:
774         return {"error": __utils__["boto.get_error"](e)}
775     vpc_ids = set()
776     for subnet in subnets:
777         log.debug("examining subnet id: %s for vpc_id", subnet.id)
778         if subnet in subnets:
779             log.debug(
780                 "subnet id: %s is associated with vpc id: %s", subnet.id, subnet.vpc_id
781             )
782             vpc_ids.add(subnet.vpc_id)
783     if not vpc_ids:
784         return {"vpc_id": None}
785     elif len(vpc_ids) == 1:
786         return {"vpc_id": vpc_ids.pop()}
787     else:
788         return {"vpc_ids": list(vpc_ids)}
789 def describe_subnet(
790     subnet_id=None, subnet_name=None, region=None, key=None, keyid=None, profile=None
791 ):
792     try:
793         subnet = _get_resource(
794             "subnet",
795             name=subnet_name,
796             resource_id=subnet_id,
797             region=region,
798             key=key,
799             keyid=keyid,
800             profile=profile,
801         )
802     except BotoServerError as e:
803         return {"error": __utils__["boto.get_error"](e)}
804     if not subnet:
805         return {"subnet": None}
806     log.debug("Found subnet: %s", subnet.id)
807     keys = ("id", "cidr_block", "availability_zone", "tags", "vpc_id")
808     ret = {"subnet": {k: getattr(subnet, k) for k in keys}}
809     explicit_route_table_assoc = _get_subnet_explicit_route_table(
810         ret["subnet"]["id"],
811         ret["subnet"]["vpc_id"],
812         conn=None,
813         region=region,
814         key=key,
815         keyid=keyid,
816         profile=profile,
817     )
818     if explicit_route_table_assoc:
819         ret["subnet"][
820             "explicit_route_table_association_id"
821         ] = explicit_route_table_assoc
822     return ret
823 def describe_subnets(
824     subnet_ids=None,
825     subnet_names=None,
826     vpc_id=None,
827     cidr=None,
828     region=None,
829     key=None,
830     keyid=None,
831     profile=None,
832 ):
833     try:
834         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
835         filter_parameters = {"filters": {}}
836         if vpc_id:
837             filter_parameters["filters"]["vpcId"] = vpc_id
838         if cidr:
839             filter_parameters["filters"]["cidrBlock"] = cidr
840         if subnet_names:
841             filter_parameters["filters"]["tag:Name"] = subnet_names
842         subnets = conn.get_all_subnets(subnet_ids=subnet_ids, **filter_parameters)
843         log.debug(
844             "The filters criteria %s matched the following subnets: %s",
845             filter_parameters,
846             subnets,
847         )
848         if not subnets:
849             return {"subnets": None}
850         subnets_list = []
851         keys = ("id", "cidr_block", "availability_zone", "tags", "vpc_id")
852         for item in subnets:
853             subnet = {}
854             for key in keys:
855                 if hasattr(item, key):
856                     subnet[key] = getattr(item, key)
857             explicit_route_table_assoc = _get_subnet_explicit_route_table(
858                 subnet["id"], subnet["vpc_id"], conn=conn
859             )
860             if explicit_route_table_assoc:
861                 subnet[
862                     "explicit_route_table_association_id"
863                 ] = explicit_route_table_assoc
864             subnets_list.append(subnet)
865         return {"subnets": subnets_list}
866     except BotoServerError as e:
867         return {"error": __utils__["boto.get_error"](e)}
868 def create_internet_gateway(
869     internet_gateway_name=None,
870     vpc_id=None,
871     vpc_name=None,
872     tags=None,
873     region=None,
874     key=None,
875     keyid=None,
876     profile=None,
877 ):
878     try:
879         if vpc_id or vpc_name:
880             vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
881             if not vpc_id:
882                 return {
883                     "created": False,
884                     "error": {
885                         "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
886                     },
887                 }
888         r = _create_resource(
889             "internet_gateway",
890             name=internet_gateway_name,
891             tags=tags,
892             region=region,
893             key=key,
894             keyid=keyid,
895             profile=profile,
896         )
897         if r.get("created") and vpc_id:
898             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
899             conn.attach_internet_gateway(r["id"], vpc_id)
900             log.info(
901                 "Attached internet gateway %s to VPC %s", r["id"], vpc_name or vpc_id
902             )
903         return r
904     except BotoServerError as e:
905         return {"created": False, "error": __utils__["boto.get_error"](e)}
906 def delete_internet_gateway(
907     internet_gateway_id=None,
908     internet_gateway_name=None,
909     detach=False,
910     region=None,
911     key=None,
912     keyid=None,
913     profile=None,
914 ):
915     try:
916         if internet_gateway_name:
917             internet_gateway_id = _get_resource_id(
918                 "internet_gateway",
919                 internet_gateway_name,
920                 region=region,
921                 key=key,
922                 keyid=keyid,
923                 profile=profile,
924             )
925         if not internet_gateway_id:
926             return {
927                 "deleted": False,
928                 "error": {
929                     "message": "internet gateway {} does not exist.".format(
930                         internet_gateway_name
931                     )
932                 },
933             }
934         if detach:
935             igw = _get_resource(
936                 "internet_gateway",
937                 resource_id=internet_gateway_id,
938                 region=region,
939                 key=key,
940                 keyid=keyid,
941                 profile=profile,
942             )
943             if not igw:
944                 return {
945                     "deleted": False,
946                     "error": {
947                         "message": "internet gateway {} does not exist.".format(
948                             internet_gateway_id
949                         )
950                     },
951                 }
952             if igw.attachments:
953                 conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
954                 conn.detach_internet_gateway(
955                     internet_gateway_id, igw.attachments[0].vpc_id
956                 )
957         return _delete_resource(
958             "internet_gateway",
959             resource_id=internet_gateway_id,
960             region=region,
961             key=key,
962             keyid=keyid,
963             profile=profile,
964         )
965     except BotoServerError as e:
966 <a name="0"></a>        return {"deleted": False, "error": __utils__["boto.get_error"](e)}
967 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def _find_nat_gateways(
968     nat_gateway_id=None,
969     subnet_id=None,
970     subnet_name=None,
971     vpc_id=None,
972     vpc_name=None,
973     states=("pending", "available"),
974     region=None,
975     key=None,
976     keyid=None,
977     profile=None,
978 ):
979     if not any(</b></font>(nat_gateway_id, subnet_id, subnet_name, vpc_id, vpc_name)):
980         raise SaltInvocationError(
981             "At least one of the following must be "
982             "provided: nat_gateway_id, subnet_id, "
983             "subnet_name, vpc_id, or vpc_name."
984         )
985     filter_parameters = {"Filter": []}
986     if nat_gateway_id:
987         filter_parameters["NatGatewayIds"] = [nat_gateway_id]
988     if subnet_name:
989         subnet_id = _get_resource_id(
990             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
991         )
992         if not subnet_id:
993             return False
994     if subnet_id:
995         filter_parameters["Filter"].append({"Name": "subnet-id", "Values": [subnet_id]})
996     if vpc_name:
997         vpc_id = _get_resource_id(
998             "vpc", vpc_name, region=region, key=key, keyid=keyid, profile=profile
999         )
1000         if not vpc_id:
1001             return False
1002     if vpc_id:
1003         filter_parameters["Filter"].append({"Name": "vpc-id", "Values": [vpc_id]})
1004     conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
1005     nat_gateways = []
1006     for ret in __utils__["boto3.paged_call"](
1007         conn3.describe_nat_gateways,
1008         marker_flag="NextToken",
1009         marker_arg="NextToken",
1010         **filter_parameters
1011     ):
1012         for gw in ret.get("NatGateways", []):
1013             if gw.get("State") in states:
1014                 nat_gateways.append(gw)
1015     log.debug(
1016         "The filters criteria %s matched the following nat gateways: %s",
1017         filter_parameters,
1018         nat_gateways,
1019     )
1020     if nat_gateways:
1021         return nat_gateways
1022     else:
1023         return False
1024 def nat_gateway_exists(
1025     nat_gateway_id=None,
1026     subnet_id=None,
1027     subnet_name=None,
1028     vpc_id=None,
1029     vpc_name=None,
1030     states=("pending", "available"),
1031     region=None,
1032     key=None,
1033     keyid=None,
1034     profile=None,
1035 ):
1036     return bool(
1037         _find_nat_gateways(
1038             nat_gateway_id=nat_gateway_id,
1039             subnet_id=subnet_id,
1040             subnet_name=subnet_name,
1041             vpc_id=vpc_id,
1042             vpc_name=vpc_name,
1043             states=states,
1044             region=region,
1045             key=key,
1046             keyid=keyid,
1047             profile=profile,
1048         )
1049     )
1050 def describe_nat_gateways(
1051     nat_gateway_id=None,
1052     subnet_id=None,
1053     subnet_name=None,
1054     vpc_id=None,
1055     vpc_name=None,
1056     states=("pending", "available"),
1057     region=None,
1058     key=None,
1059     keyid=None,
1060     profile=None,
1061 ):
1062     return _find_nat_gateways(
1063         nat_gateway_id=nat_gateway_id,
1064         subnet_id=subnet_id,
1065         subnet_name=subnet_name,
1066         vpc_id=vpc_id,
1067         vpc_name=vpc_name,
1068         states=states,
1069         region=region,
1070         key=key,
1071         keyid=keyid,
1072         profile=profile,
1073     )
1074 def create_nat_gateway(
1075     subnet_id=None,
1076     subnet_name=None,
1077     allocation_id=None,
1078     region=None,
1079     key=None,
1080     keyid=None,
1081     profile=None,
1082 ):
1083     try:
1084         if all((subnet_id, subnet_name)):
1085             raise SaltInvocationError(
1086                 "Only one of subnet_name or subnet_id may be provided."
1087             )
1088         if subnet_name:
1089             subnet_id = _get_resource_id(
1090                 "subnet",
1091                 subnet_name,
1092                 region=region,
1093                 key=key,
1094                 keyid=keyid,
1095                 profile=profile,
1096             )
1097             if not subnet_id:
1098                 return {
1099                     "created": False,
1100                     "error": {
1101                         "message": "Subnet {} does not exist.".format(subnet_name)
1102                     },
1103                 }
1104         else:
1105             if not _get_resource(
1106                 "subnet",
1107                 resource_id=subnet_id,
1108                 region=region,
1109                 key=key,
1110                 keyid=keyid,
1111                 profile=profile,
1112             ):
1113                 return {
1114                     "created": False,
1115                     "error": {"message": "Subnet {} does not exist.".format(subnet_id)},
1116                 }
1117         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
1118         if not allocation_id:
1119             address = conn3.allocate_address(Domain="vpc")
1120             allocation_id = address.get("AllocationId")
1121         r = conn3.create_nat_gateway(SubnetId=subnet_id, AllocationId=allocation_id)
1122         return {"created": True, "id": r.get("NatGateway", {}).get("NatGatewayId")}
1123     except BotoServerError as e:
1124         return {"created": False, "error": __utils__["boto.get_error"](e)}
1125 def delete_nat_gateway(
1126     nat_gateway_id,
1127     release_eips=False,
1128     region=None,
1129     key=None,
1130     keyid=None,
1131     profile=None,
1132     wait_for_delete=False,
1133     wait_for_delete_retries=5,
1134 ):
1135     try:
1136         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
1137         gwinfo = conn3.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])
1138         if gwinfo:
1139             gwinfo = gwinfo.get("NatGateways", [None])[0]
1140         conn3.delete_nat_gateway(NatGatewayId=nat_gateway_id)
1141         if wait_for_delete:
1142             for retry in range(wait_for_delete_retries, 0, -1):
1143                 if gwinfo and gwinfo["State"] not in ["deleted", "failed"]:
1144                     time.sleep(
1145                         (2 ** (wait_for_delete_retries - retry))
1146                         + (random.randint(0, 1000) / 1000.0)
1147                     )
1148                     gwinfo = conn3.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])
1149                     if gwinfo:
1150                         gwinfo = gwinfo.get("NatGateways", [None])[0]
1151                         continue
1152                 break
1153         if release_eips and gwinfo:
1154             for addr in gwinfo.get("NatGatewayAddresses"):
1155                 conn3.release_address(AllocationId=addr.get("AllocationId"))
1156         return {"deleted": True}
1157     except BotoServerError as e:
1158         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
1159 def create_customer_gateway(
1160     vpn_connection_type,
1161     ip_address,
1162     bgp_asn,
1163     customer_gateway_name=None,
1164     tags=None,
1165     region=None,
1166     key=None,
1167     keyid=None,
1168     profile=None,
1169 ):
1170     return _create_resource(
1171         "customer_gateway",
1172         customer_gateway_name,
1173         type=vpn_connection_type,
1174         ip_address=ip_address,
1175         bgp_asn=bgp_asn,
1176         tags=tags,
1177         region=region,
1178         key=key,
1179         keyid=keyid,
1180         profile=profile,
1181     )
1182 def delete_customer_gateway(
1183     customer_gateway_id=None,
1184     customer_gateway_name=None,
1185     region=None,
1186     key=None,
1187     keyid=None,
1188     profile=None,
1189 ):
1190     return _delete_resource(
1191         resource="customer_gateway",
1192         name=customer_gateway_name,
1193         resource_id=customer_gateway_id,
1194         region=region,
1195         key=key,
1196         keyid=keyid,
1197         profile=profile,
1198     )
1199 def customer_gateway_exists(
1200     customer_gateway_id=None,
1201     customer_gateway_name=None,
1202     region=None,
1203     key=None,
1204     keyid=None,
1205     profile=None,
1206 ):
1207     return resource_exists(
1208         "customer_gateway",
1209         name=customer_gateway_name,
1210         resource_id=customer_gateway_id,
1211         region=region,
1212         key=key,
1213         keyid=keyid,
1214         profile=profile,
1215     )
1216 def create_dhcp_options(
1217     domain_name=None,
1218     domain_name_servers=None,
1219     ntp_servers=None,
1220     netbios_name_servers=None,
1221     netbios_node_type=None,
1222     dhcp_options_name=None,
1223     tags=None,
1224     vpc_id=None,
1225     vpc_name=None,
1226     region=None,
1227     key=None,
1228     keyid=None,
1229     profile=None,
1230 ):
1231     try:
1232         if vpc_id or vpc_name:
1233             vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1234             if not vpc_id:
1235                 return {
1236                     "created": False,
1237                     "error": {
1238                         "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
1239                     },
1240                 }
1241         r = _create_resource(
1242             "dhcp_options",
1243             name=dhcp_options_name,
1244             domain_name=domain_name,
1245             domain_name_servers=domain_name_servers,
1246             ntp_servers=ntp_servers,
1247             netbios_name_servers=netbios_name_servers,
1248             netbios_node_type=netbios_node_type,
1249             region=region,
1250             key=key,
1251             keyid=keyid,
1252             profile=profile,
1253         )
1254         if r.get("created") and vpc_id:
1255             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1256             conn.associate_dhcp_options(r["id"], vpc_id)
1257             log.info("Associated options %s to VPC %s", r["id"], vpc_name or vpc_id)
1258         return r
1259     except BotoServerError as e:
1260         return {"created": False, "error": __utils__["boto.get_error"](e)}
1261 def get_dhcp_options(
1262     dhcp_options_name=None,
1263     dhcp_options_id=None,
1264     region=None,
1265     key=None,
1266     keyid=None,
1267     profile=None,
1268 ):
1269     if not any((dhcp_options_name, dhcp_options_id)):
1270         raise SaltInvocationError(
1271             "At least one of the following must be specified: "
1272             "dhcp_options_name, dhcp_options_id."
1273         )
1274     if not dhcp_options_id and dhcp_options_name:
1275         dhcp_options_id = _get_resource_id(
1276             "dhcp_options",
1277             dhcp_options_name,
1278             region=region,
1279             key=key,
1280             keyid=keyid,
1281             profile=profile,
1282         )
1283     if not dhcp_options_id:
1284         return {"dhcp_options": {}}
1285     try:
1286         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1287         r = conn.get_all_dhcp_options(dhcp_options_ids=[dhcp_options_id])
1288     except BotoServerError as e:
1289         return {"error": __utils__["boto.get_error"](e)}
1290     if not r:
1291         return {"dhcp_options": None}
1292     keys = (
1293         "domain_name",
1294         "domain_name_servers",
1295         "ntp_servers",
1296         "netbios_name_servers",
1297         "netbios_node_type",
1298     )
1299     return {"dhcp_options": {k: r[0].options.get(k) for k in keys}}
1300 def delete_dhcp_options(
1301     dhcp_options_id=None,
1302     dhcp_options_name=None,
1303     region=None,
1304     key=None,
1305     keyid=None,
1306     profile=None,
1307 ):
1308     return _delete_resource(
1309         resource="dhcp_options",
1310         name=dhcp_options_name,
1311         resource_id=dhcp_options_id,
1312         region=region,
1313         key=key,
1314         keyid=keyid,
1315         profile=profile,
1316     )
1317 def associate_dhcp_options_to_vpc(
1318     dhcp_options_id,
1319     vpc_id=None,
1320     vpc_name=None,
1321     region=None,
1322     key=None,
1323     keyid=None,
1324     profile=None,
1325 ):
1326     try:
1327         vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1328         if not vpc_id:
1329             return {
1330                 "associated": False,
1331                 "error": {
1332                     "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
1333                 },
1334             }
1335         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1336         if conn.associate_dhcp_options(dhcp_options_id, vpc_id):
1337             log.info(
1338                 "DHCP options with id %s were associated with VPC %s",
1339                 dhcp_options_id,
1340                 vpc_id,
1341             )
1342             return {"associated": True}
1343         else:
1344             log.warning(
1345                 "DHCP options with id %s were not associated with VPC %s",
1346                 dhcp_options_id,
1347                 vpc_id,
1348             )
1349             return {
1350                 "associated": False,
1351                 "error": {"message": "DHCP options could not be associated."},
1352             }
1353     except BotoServerError as e:
1354         return {"associated": False, "error": __utils__["boto.get_error"](e)}
1355 def dhcp_options_exists(
1356     dhcp_options_id=None,
1357     name=None,
1358     dhcp_options_name=None,
1359     tags=None,
1360     region=None,
1361     key=None,
1362     keyid=None,
1363     profile=None,
1364 ):
1365     if name:
1366         log.warning(
1367             "boto_vpc.dhcp_options_exists: name parameter is deprecated "
1368             "use dhcp_options_name instead."
1369         )
1370         dhcp_options_name = name
1371     return resource_exists(
1372         "dhcp_options",
1373         name=dhcp_options_name,
1374         resource_id=dhcp_options_id,
1375         tags=tags,
1376         region=region,
1377         key=key,
1378         keyid=keyid,
1379         profile=profile,
1380     )
1381 def create_network_acl(
1382     vpc_id=None,
1383     vpc_name=None,
1384     network_acl_name=None,
1385     subnet_id=None,
1386     subnet_name=None,
1387     tags=None,
1388     region=None,
1389     key=None,
1390     keyid=None,
1391     profile=None,
1392 ):
1393     _id = vpc_name or vpc_id
1394     try:
1395         vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1396     except BotoServerError as e:
1397         return {"created": False, "error": __utils__["boto.get_error"](e)}
1398     if not vpc_id:
1399         return {
1400             "created": False,
1401             "error": {"message": "VPC {} does not exist.".format(_id)},
1402         }
1403     if all((subnet_id, subnet_name)):
1404         raise SaltInvocationError(
1405             "Only one of subnet_name or subnet_id may be provided."
1406         )
1407     if subnet_name:
1408         subnet_id = _get_resource_id(
1409             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
1410         )
1411         if not subnet_id:
1412             return {
1413                 "created": False,
1414                 "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
1415             }
1416     elif subnet_id:
1417         if not _get_resource(
1418             "subnet",
1419             resource_id=subnet_id,
1420             region=region,
1421             key=key,
1422             keyid=keyid,
1423             profile=profile,
1424         ):
1425             return {
1426                 "created": False,
1427                 "error": {"message": "Subnet {} does not exist.".format(subnet_id)},
1428             }
1429     r = _create_resource(
1430         "network_acl",
1431         name=network_acl_name,
1432         vpc_id=vpc_id,
1433         region=region,
1434         key=key,
1435         keyid=keyid,
1436         profile=profile,
1437     )
1438     if r.get("created") and subnet_id:
1439         try:
1440             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1441             association_id = conn.associate_network_acl(r["id"], subnet_id)
1442         except BotoServerError as e:
1443             return {"created": False, "error": __utils__["boto.get_error"](e)}
1444         r["association_id"] = association_id
1445     return r
1446 def delete_network_acl(
1447     network_acl_id=None,
1448     network_acl_name=None,
1449     disassociate=False,
1450     region=None,
1451     key=None,
1452     keyid=None,
1453     profile=None,
1454 ):
1455     if disassociate:
1456         network_acl = _get_resource(
1457             "network_acl",
1458             name=network_acl_name,
1459             region=region,
1460             key=key,
1461             keyid=keyid,
1462             profile=profile,
1463         )
1464         if network_acl and network_acl.associations:
1465             subnet_id = network_acl.associations[0].subnet_id
1466             try:
1467                 conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1468                 conn.disassociate_network_acl(subnet_id)
1469             except BotoServerError:
1470                 pass
1471     return _delete_resource(
1472         resource="network_acl",
1473         name=network_acl_name,
1474         resource_id=network_acl_id,
1475         region=region,
1476         key=key,
1477         keyid=keyid,
1478         profile=profile,
1479     )
1480 def network_acl_exists(
1481     network_acl_id=None,
1482     name=None,
1483     network_acl_name=None,
1484     tags=None,
1485     region=None,
1486     key=None,
1487     keyid=None,
1488     profile=None,
1489 ):
1490     if name:
1491         log.warning(
1492             "boto_vpc.network_acl_exists: name parameter is deprecated "
1493             "use network_acl_name instead."
1494         )
1495         network_acl_name = name
1496     return resource_exists(
1497         "network_acl",
1498         name=network_acl_name,
1499         resource_id=network_acl_id,
1500         tags=tags,
1501         region=region,
1502         key=key,
1503         keyid=keyid,
1504         profile=profile,
1505     )
1506 def associate_network_acl_to_subnet(
1507     network_acl_id=None,
1508     subnet_id=None,
1509     network_acl_name=None,
1510     subnet_name=None,
1511     region=None,
1512     key=None,
1513     keyid=None,
1514     profile=None,
1515 ):
1516     if network_acl_name:
1517         network_acl_id = _get_resource_id(
1518             "network_acl",
1519             network_acl_name,
1520             region=region,
1521             key=key,
1522             keyid=keyid,
1523             profile=profile,
1524         )
1525         if not network_acl_id:
1526             return {
1527                 "associated": False,
1528                 "error": {
1529                     "message": "Network ACL {} does not exist.".format(network_acl_name)
1530                 },
1531             }
1532     if subnet_name:
1533         subnet_id = _get_resource_id(
1534             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
1535         )
1536         if not subnet_id:
1537             return {
1538                 "associated": False,
1539                 "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
1540             }
1541     try:
1542         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1543         association_id = conn.associate_network_acl(network_acl_id, subnet_id)
1544         if association_id:
1545             log.info(
1546                 "Network ACL with id %s was associated with subnet %s",
1547                 network_acl_id,
1548                 subnet_id,
1549             )
1550             return {"associated": True, "id": association_id}
1551         else:
1552             log.warning(
1553                 "Network ACL with id %s was not associated with subnet %s",
1554                 network_acl_id,
1555                 subnet_id,
1556             )
1557             return {
1558                 "associated": False,
1559                 "error": {"message": "ACL could not be assocaited."},
1560             }
1561     except BotoServerError as e:
1562         return {"associated": False, "error": __utils__["boto.get_error"](e)}
1563 def disassociate_network_acl(
1564     subnet_id=None,
1565     vpc_id=None,
1566     subnet_name=None,
1567     vpc_name=None,
1568     region=None,
1569     key=None,
1570     keyid=None,
1571     profile=None,
1572 ):
1573     if not _exactly_one((subnet_name, subnet_id)):
1574         raise SaltInvocationError(
1575             "One (but not both) of subnet_id or subnet_name must be provided."
1576         )
1577     if all((vpc_name, vpc_id)):
1578         raise SaltInvocationError("Only one of vpc_id or vpc_name may be provided.")
1579     try:
1580         if subnet_name:
1581             subnet_id = _get_resource_id(
1582                 "subnet",
1583                 subnet_name,
1584                 region=region,
1585                 key=key,
1586                 keyid=keyid,
1587                 profile=profile,
1588             )
1589             if not subnet_id:
1590                 return {
1591                     "disassociated": False,
1592                     "error": {
1593                         "message": "Subnet {} does not exist.".format(subnet_name)
1594                     },
1595                 }
1596         if vpc_name or vpc_id:
1597             vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1598         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1599         association_id = conn.disassociate_network_acl(subnet_id, vpc_id=vpc_id)
1600         return {"disassociated": True, "association_id": association_id}
1601     except BotoServerError as e:
1602         return {"disassociated": False, "error": __utils__["boto.get_error"](e)}
1603 def _create_network_acl_entry(
1604     network_acl_id=None,
1605     rule_number=None,
1606     protocol=None,
1607     rule_action=None,
1608     cidr_block=None,
1609     egress=None,
1610     network_acl_name=None,
1611     icmp_code=None,
1612     icmp_type=None,
1613     port_range_from=None,
1614     port_range_to=None,
1615     replace=False,
1616     region=None,
1617     key=None,
1618     keyid=None,
1619     profile=None,
1620 ):
1621     if replace:
1622         rkey = "replaced"
1623     else:
1624         rkey = "created"
1625     if not _exactly_one((network_acl_name, network_acl_id)):
1626         raise SaltInvocationError(
1627             "One (but not both) of network_acl_id or network_acl_name must be provided."
1628         )
1629     for v in ("rule_number", "protocol", "rule_action", "cidr_block"):
1630         if locals()[v] is None:
1631             raise SaltInvocationError("{} is required.".format(v))
1632     if network_acl_name:
1633         network_acl_id = _get_resource_id(
1634             "network_acl",
1635             network_acl_name,
1636             region=region,
1637             key=key,
1638             keyid=keyid,
1639             profile=profile,
1640         )
1641     if not network_acl_id:
1642         return {
1643             rkey: False,
1644             "error": {
1645                 "message": "Network ACL {} does not exist.".format(
1646                     network_acl_name or network_acl_id
1647                 )
1648             },
1649         }
1650     if isinstance(protocol, str):
1651         if protocol == "all":
1652             protocol = -1
1653         else:
1654             try:
1655                 protocol = socket.getprotobyname(protocol)
1656             except OSError as e:
1657                 raise SaltInvocationError(e)
1658     try:
1659         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1660         if replace:
1661             f = conn.replace_network_acl_entry
1662         else:
1663             f = conn.create_network_acl_entry
1664         created = f(
1665             network_acl_id,
1666             rule_number,
1667             protocol,
1668             rule_action,
1669             cidr_block,
1670             egress=egress,
1671             icmp_code=icmp_code,
1672             icmp_type=icmp_type,
1673             port_range_from=port_range_from,
1674             port_range_to=port_range_to,
1675         )
1676         if created:
1677             log.info("Network ACL entry was %s", rkey)
1678         else:
1679             log.warning("Network ACL entry was not %s", rkey)
1680         return {rkey: created}
1681     except BotoServerError as e:
1682         return {rkey: False, "error": __utils__["boto.get_error"](e)}
1683 def create_network_acl_entry(
1684     network_acl_id=None,
1685     rule_number=None,
1686     protocol=None,
1687     rule_action=None,
1688     cidr_block=None,
1689     egress=None,
1690     network_acl_name=None,
1691     icmp_code=None,
1692     icmp_type=None,
1693     port_range_from=None,
1694     port_range_to=None,
1695     region=None,
1696     key=None,
1697     keyid=None,
1698     profile=None,
1699 ):
1700     kwargs = locals()
1701     return _create_network_acl_entry(**kwargs)
1702 def replace_network_acl_entry(
1703     network_acl_id=None,
1704     rule_number=None,
1705     protocol=None,
1706     rule_action=None,
1707     cidr_block=None,
1708     egress=None,
1709     network_acl_name=None,
1710     icmp_code=None,
1711     icmp_type=None,
1712     port_range_from=None,
1713     port_range_to=None,
1714     region=None,
1715     key=None,
1716     keyid=None,
1717     profile=None,
1718 ):
1719     kwargs = locals()
1720     return _create_network_acl_entry(replace=True, **kwargs)
1721 def delete_network_acl_entry(
1722     network_acl_id=None,
1723     rule_number=None,
1724     egress=None,
1725     network_acl_name=None,
1726     region=None,
1727     key=None,
1728     keyid=None,
1729     profile=None,
1730 ):
1731     if not _exactly_one((network_acl_name, network_acl_id)):
1732         raise SaltInvocationError(
1733             "One (but not both) of network_acl_id or network_acl_name must be provided."
1734         )
1735     for v in ("rule_number", "egress"):
1736         if locals()[v] is None:
1737             raise SaltInvocationError("{} is required.".format(v))
1738     if network_acl_name:
1739         network_acl_id = _get_resource_id(
1740             "network_acl",
1741             network_acl_name,
1742             region=region,
1743             key=key,
1744             keyid=keyid,
1745             profile=profile,
1746         )
1747     if not network_acl_id:
1748         return {
1749             "deleted": False,
1750             "error": {
1751                 "message": "Network ACL {} does not exist.".format(
1752                     network_acl_name or network_acl_id
1753                 )
1754             },
1755         }
1756     try:
1757         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1758         deleted = conn.delete_network_acl_entry(
1759             network_acl_id, rule_number, egress=egress
1760         )
1761         if deleted:
1762             log.info("Network ACL entry was deleted")
1763         else:
1764             log.warning("Network ACL was not deleted")
1765         return {"deleted": deleted}
1766     except BotoServerError as e:
1767         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
1768 def create_route_table(
1769     vpc_id=None,
1770     vpc_name=None,
1771     route_table_name=None,
1772     tags=None,
1773     region=None,
1774     key=None,
1775     keyid=None,
1776     profile=None,
1777 ):
1778     vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1779     if not vpc_id:
1780         return {
1781             "created": False,
1782             "error": {"message": "VPC {} does not exist.".format(vpc_name or vpc_id)},
1783         }
1784     return _create_resource(
1785         "route_table",
1786         route_table_name,
1787         tags=tags,
1788         vpc_id=vpc_id,
1789         region=region,
1790         key=key,
1791         keyid=keyid,
1792         profile=profile,
1793     )
1794 def delete_route_table(
1795     route_table_id=None,
1796     route_table_name=None,
1797     region=None,
1798     key=None,
1799     keyid=None,
1800     profile=None,
1801 ):
1802     return _delete_resource(
1803         resource="route_table",
1804         name=route_table_name,
1805         resource_id=route_table_id,
1806         region=region,
1807         key=key,
1808         keyid=keyid,
1809         profile=profile,
1810     )
1811 def route_table_exists(
1812     route_table_id=None,
1813     name=None,
1814     route_table_name=None,
1815     tags=None,
1816     region=None,
1817     key=None,
1818     keyid=None,
1819     profile=None,
1820 ):
1821     if name:
1822         log.warning(
1823             "boto_vpc.route_table_exists: name parameter is deprecated "
1824             "use route_table_name instead."
1825         )
1826         route_table_name = name
1827     return resource_exists(
1828         "route_table",
1829         name=route_table_name,
1830         resource_id=route_table_id,
1831         tags=tags,
1832         region=region,
1833         key=key,
1834         keyid=keyid,
1835         profile=profile,
1836     )
1837 def route_exists(
1838     destination_cidr_block,
1839     route_table_name=None,
1840     route_table_id=None,
1841     gateway_id=None,
1842     instance_id=None,
1843     interface_id=None,
1844     tags=None,
1845     region=None,
1846     key=None,
1847     keyid=None,
1848     profile=None,
1849     vpc_peering_connection_id=None,
1850 ):
1851     if not any((route_table_name, route_table_id)):
1852         raise SaltInvocationError(
1853             "At least one of the following must be specified: route table name or route"
1854             " table id."
1855         )
1856     if not any((gateway_id, instance_id, interface_id, vpc_peering_connection_id)):
1857         raise SaltInvocationError(
1858             "At least one of the following must be specified: gateway id, instance id, "
1859             "interface id or VPC peering connection id."
1860         )
1861     try:
1862         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1863         filter_parameters = {"filters": {}}
1864         if route_table_id:
1865             filter_parameters["route_table_ids"] = [route_table_id]
1866         if route_table_name:
1867             filter_parameters["filters"]["tag:Name"] = route_table_name
1868         if tags:
1869             for tag_name, tag_value in tags.items():
1870                 filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
1871         route_tables = conn.get_all_route_tables(**filter_parameters)
1872         if len(route_tables) != 1:
1873             raise SaltInvocationError("Found more than one route table.")
1874         route_check = {
1875             "destination_cidr_block": destination_cidr_block,
1876             "gateway_id": gateway_id,
1877             "instance_id": instance_id,
1878             "interface_id": interface_id,
1879             "vpc_peering_connection_id": vpc_peering_connection_id,
1880         }
1881         for route_match in route_tables[0].routes:
1882             route_dict = {
1883                 "destination_cidr_block": route_match.destination_cidr_block,
1884                 "gateway_id": route_match.gateway_id,
1885                 "instance_id": route_match.instance_id,
1886                 "interface_id": route_match.interface_id,
1887                 "vpc_peering_connection_id": vpc_peering_connection_id,
1888             }
1889             route_comp = set(route_dict.items()) ^ set(route_check.items())
1890             if not route_comp:
1891                 log.info("Route %s exists.", destination_cidr_block)
1892                 return {"exists": True}
1893         log.warning("Route %s does not exist.", destination_cidr_block)
1894         return {"exists": False}
1895     except BotoServerError as e:
1896         return {"error": __utils__["boto.get_error"](e)}
1897 def associate_route_table(
1898     route_table_id=None,
1899     subnet_id=None,
1900     route_table_name=None,
1901     subnet_name=None,
1902     region=None,
1903     key=None,
1904     keyid=None,
1905     profile=None,
1906 ):
1907     if all((subnet_id, subnet_name)):
1908         raise SaltInvocationError(
1909             "Only one of subnet_name or subnet_id may be provided."
1910         )
1911     if subnet_name:
1912         subnet_id = _get_resource_id(
1913             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
1914         )
1915         if not subnet_id:
1916             return {
1917                 "associated": False,
1918                 "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
1919             }
1920     if all((route_table_id, route_table_name)):
1921         raise SaltInvocationError(
1922             "Only one of route_table_name or route_table_id may be provided."
1923         )
1924     if route_table_name:
1925         route_table_id = _get_resource_id(
1926             "route_table",
1927             route_table_name,
1928             region=region,
1929             key=key,
1930             keyid=keyid,
1931             profile=profile,
1932         )
1933         if not route_table_id:
1934             return {
1935                 "associated": False,
1936                 "error": {
1937                     "message": "Route table {} does not exist.".format(route_table_name)
1938                 },
1939             }
1940     try:
1941         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1942         association_id = conn.associate_route_table(route_table_id, subnet_id)
1943         log.info(
1944             "Route table %s was associated with subnet %s", route_table_id, subnet_id
1945         )
1946         return {"association_id": association_id}
1947     except BotoServerError as e:
1948         return {"associated": False, "error": __utils__["boto.get_error"](e)}
1949 def disassociate_route_table(
1950     association_id, region=None, key=None, keyid=None, profile=None
1951 ):
1952     try:
1953         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1954         if conn.disassociate_route_table(association_id):
1955             log.info(
1956                 "Route table with association id %s has been disassociated.",
1957                 association_id,
1958             )
1959             return {"disassociated": True}
1960         else:
1961             log.warning(
1962                 "Route table with association id %s has not been disassociated.",
1963                 association_id,
1964             )
1965             return {"disassociated": False}
1966     except BotoServerError as e:
1967         return {"disassociated": False, "error": __utils__["boto.get_error"](e)}
1968 def replace_route_table_association(
1969     association_id, route_table_id, region=None, key=None, keyid=None, profile=None
1970 ):
1971     try:
1972         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1973         association_id = conn.replace_route_table_association_with_assoc(
1974             association_id, route_table_id
1975         )
1976         log.info(
1977             "Route table %s was reassociated with association id %s",
1978             route_table_id,
1979             association_id,
1980         )
1981         return {"replaced": True, "association_id": association_id}
1982     except BotoServerError as e:
1983         return {"replaced": False, "error": __utils__["boto.get_error"](e)}
1984 def create_route(
1985     route_table_id=None,
1986     destination_cidr_block=None,
1987     route_table_name=None,
1988     gateway_id=None,
1989     internet_gateway_name=None,
1990     instance_id=None,
1991     interface_id=None,
1992     vpc_peering_connection_id=None,
1993     vpc_peering_connection_name=None,
1994     region=None,
1995     key=None,
1996     keyid=None,
1997     profile=None,
1998     nat_gateway_id=None,
1999     nat_gateway_subnet_name=None,
2000     nat_gateway_subnet_id=None,
2001 ):
2002     if not _exactly_one((route_table_name, route_table_id)):
2003         raise SaltInvocationError(
2004             "One (but not both) of route_table_id or route_table_name must be provided."
2005         )
2006     if not _exactly_one(
2007         (
2008             gateway_id,
2009             internet_gateway_name,
2010             instance_id,
2011             interface_id,
2012             vpc_peering_connection_id,
2013             nat_gateway_id,
2014             nat_gateway_subnet_id,
2015             nat_gateway_subnet_name,
2016             vpc_peering_connection_name,
2017         )
2018     ):
2019         raise SaltInvocationError(
2020             "Only one of gateway_id, internet_gateway_name, instance_id, interface_id,"
2021             " vpc_peering_connection_id, nat_gateway_id, nat_gateway_subnet_id,"
2022             " nat_gateway_subnet_name or vpc_peering_connection_name may be provided."
2023         )
2024     if destination_cidr_block is None:
2025         raise SaltInvocationError("destination_cidr_block is required.")
2026     try:
2027         if route_table_name:
2028             route_table_id = _get_resource_id(
2029                 "route_table",
2030                 route_table_name,
2031                 region=region,
2032                 key=key,
2033                 keyid=keyid,
2034                 profile=profile,
2035             )
2036             if not route_table_id:
2037                 return {
2038                     "created": False,
2039                     "error": {
2040                         "message": "route table {} does not exist.".format(
2041                             route_table_name
2042                         )
2043                     },
2044                 }
2045         if internet_gateway_name:
2046             gateway_id = _get_resource_id(
2047                 "internet_gateway",
2048                 internet_gateway_name,
2049                 region=region,
2050                 key=key,
2051                 keyid=keyid,
2052                 profile=profile,
2053             )
2054             if not gateway_id:
2055                 return {
2056                     "created": False,
2057                     "error": {
2058                         "message": "internet gateway {} does not exist.".format(
2059                             internet_gateway_name
2060                         )
2061                     },
2062                 }
2063         if vpc_peering_connection_name:
2064             vpc_peering_connection_id = _get_resource_id(
2065                 "vpc_peering_connection",
2066                 vpc_peering_connection_name,
2067                 region=region,
2068                 key=key,
2069                 keyid=keyid,
2070                 profile=profile,
2071             )
2072             if not vpc_peering_connection_id:
2073                 return {
2074                     "created": False,
2075                     "error": {
2076                         "message": "VPC peering connection {} does not exist.".format(
2077                             vpc_peering_connection_name
2078                         )
2079                     },
2080                 }
2081         if nat_gateway_subnet_name:
2082             gws = describe_nat_gateways(
2083                 subnet_name=nat_gateway_subnet_name,
2084                 region=region,
2085                 key=key,
2086                 keyid=keyid,
2087                 profile=profile,
2088             )
2089             if not gws:
2090                 return {
2091                     "created": False,
2092                     "error": {
2093                         "message": "nat gateway for {} does not exist.".format(
2094                             nat_gateway_subnet_name
2095                         )
2096                     },
2097                 }
2098             nat_gateway_id = gws[0]["NatGatewayId"]
2099         if nat_gateway_subnet_id:
2100             gws = describe_nat_gateways(
2101                 subnet_id=nat_gateway_subnet_id,
2102                 region=region,
2103                 key=key,
2104                 keyid=keyid,
2105                 profile=profile,
2106             )
2107             if not gws:
2108                 return {
2109                     "created": False,
2110                     "error": {
2111                         "message": "nat gateway for {} does not exist.".format(
2112                             nat_gateway_subnet_id
2113                         )
2114                     },
2115                 }
2116             nat_gateway_id = gws[0]["NatGatewayId"]
2117     except BotoServerError as e:
2118         return {"created": False, "error": __utils__["boto.get_error"](e)}
2119     if not nat_gateway_id:
2120         return _create_resource(
2121             "route",
2122             route_table_id=route_table_id,
2123             destination_cidr_block=destination_cidr_block,
2124             gateway_id=gateway_id,
2125             instance_id=instance_id,
2126             interface_id=interface_id,
2127             vpc_peering_connection_id=vpc_peering_connection_id,
2128             region=region,
2129             key=key,
2130             keyid=keyid,
2131             profile=profile,
2132         )
2133     try:
2134         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2135         ret = conn3.create_route(
2136             RouteTableId=route_table_id,
2137             DestinationCidrBlock=destination_cidr_block,
2138             NatGatewayId=nat_gateway_id,
2139         )
2140         return {"created": True, "id": ret.get("NatGatewayId")}
2141     except BotoServerError as e:
2142         return {"created": False, "error": __utils__["boto.get_error"](e)}
2143 def delete_route(
2144     route_table_id=None,
2145     destination_cidr_block=None,
2146     route_table_name=None,
2147     region=None,
2148     key=None,
2149     keyid=None,
2150     profile=None,
2151 ):
2152     if not _exactly_one((route_table_name, route_table_id)):
2153         raise SaltInvocationError(
2154             "One (but not both) of route_table_id or route_table_name must be provided."
2155         )
2156     if destination_cidr_block is None:
2157         raise SaltInvocationError("destination_cidr_block is required.")
2158     try:
2159         if route_table_name:
2160             route_table_id = _get_resource_id(
2161                 "route_table",
2162                 route_table_name,
2163                 region=region,
2164                 key=key,
2165                 keyid=keyid,
2166                 profile=profile,
2167             )
2168             if not route_table_id:
2169                 return {
2170                     "created": False,
2171                     "error": {
2172                         "message": "route table {} does not exist.".format(
2173                             route_table_name
2174                         )
2175                     },
2176                 }
2177     except BotoServerError as e:
2178         return {"created": False, "error": __utils__["boto.get_error"](e)}
2179     return _delete_resource(
2180         resource="route",
2181         resource_id=route_table_id,
2182         destination_cidr_block=destination_cidr_block,
2183         region=region,
2184         key=key,
2185         keyid=keyid,
2186         profile=profile,
2187     )
2188 def replace_route(
2189     route_table_id=None,
2190     destination_cidr_block=None,
2191     route_table_name=None,
2192     gateway_id=None,
2193     instance_id=None,
2194     interface_id=None,
2195     region=None,
2196     key=None,
2197     keyid=None,
2198     profile=None,
2199     vpc_peering_connection_id=None,
2200 ):
2201     if not _exactly_one((route_table_name, route_table_id)):
2202         raise SaltInvocationError(
2203             "One (but not both) of route_table_id or route_table_name must be provided."
2204         )
2205     if destination_cidr_block is None:
2206         raise SaltInvocationError("destination_cidr_block is required.")
2207     try:
2208         if route_table_name:
2209             route_table_id = _get_resource_id(
2210                 "route_table",
2211                 route_table_name,
2212                 region=region,
2213                 key=key,
2214                 keyid=keyid,
2215                 profile=profile,
2216             )
2217             if not route_table_id:
2218                 return {
2219                     "replaced": False,
2220                     "error": {
2221                         "message": "route table {} does not exist.".format(
2222                             route_table_name
2223                         )
2224                     },
2225                 }
2226         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
2227         if conn.replace_route(
2228             route_table_id,
2229             destination_cidr_block,
2230             gateway_id=gateway_id,
2231             instance_id=instance_id,
2232             interface_id=interface_id,
2233             vpc_peering_connection_id=vpc_peering_connection_id,
2234         ):
2235             log.info(
2236                 "Route with cidr block %s on route table %s was replaced",
2237                 route_table_id,
2238                 destination_cidr_block,
2239             )
2240             return {"replaced": True}
2241         else:
2242             log.warning(
2243                 "Route with cidr block %s on route table %s was not replaced",
2244                 route_table_id,
2245                 destination_cidr_block,
2246             )
2247             return {"replaced": False}
2248     except BotoServerError as e:
2249         return {"replaced": False, "error": __utils__["boto.get_error"](e)}
2250 def describe_route_tables(
2251     route_table_id=None,
2252     route_table_name=None,
2253     vpc_id=None,
2254     tags=None,
2255     region=None,
2256     key=None,
2257     keyid=None,
2258     profile=None,
2259 ):
2260     if not any((route_table_id, route_table_name, tags, vpc_id)):
2261         raise SaltInvocationError(
2262             "At least one of the following must be specified: "
2263             "route table id, route table name, vpc_id, or tags."
2264         )
2265     try:
2266         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2267         filter_parameters = {"Filters": []}
2268         if route_table_id:
2269             filter_parameters["RouteTableIds"] = [route_table_id]
2270         if vpc_id:
2271             filter_parameters["Filters"].append({"Name": "vpc-id", "Values": [vpc_id]})
2272         if route_table_name:
2273             filter_parameters["Filters"].append(
2274                 {"Name": "tag:Name", "Values": [route_table_name]}
2275             )
2276         if tags:
2277             for tag_name, tag_value in tags.items():
2278                 filter_parameters["Filters"].append(
2279                     {"Name": "tag:{}".format(tag_name), "Values": [tag_value]}
2280                 )
2281         route_tables = conn3.describe_route_tables(**filter_parameters).get(
2282             "RouteTables", []
2283         )
2284         if not route_tables:
2285             return []
2286         tables = []
2287         keys = {
2288             "id": "RouteTableId",
2289             "vpc_id": "VpcId",
2290             "tags": "Tags",
2291             "routes": "Routes",
2292             "associations": "Associations",
2293         }
2294         route_keys = {
2295             "destination_cidr_block": "DestinationCidrBlock",
2296             "gateway_id": "GatewayId",
2297             "instance_id": "Instance",
2298             "interface_id": "NetworkInterfaceId",
2299             "nat_gateway_id": "NatGatewayId",
2300             "vpc_peering_connection_id": "VpcPeeringConnectionId",
2301         }
2302         assoc_keys = {
2303             "id": "RouteTableAssociationId",
2304             "main": "Main",
2305             "route_table_id": "RouteTableId",
2306             "SubnetId": "subnet_id",
2307         }
2308         for item in route_tables:
2309             route_table = {}
2310             for outkey, inkey in keys.items():
2311                 if inkey in item:
2312                     if outkey == "routes":
2313                         route_table[outkey] = _key_remap(inkey, route_keys, item)
2314                     elif outkey == "associations":
2315                         route_table[outkey] = _key_remap(inkey, assoc_keys, item)
2316                     elif outkey == "tags":
2317                         route_table[outkey] = {}
2318                         for tagitem in item.get(inkey, []):
2319                             route_table[outkey][tagitem.get("Key")] = tagitem.get(
2320                                 "Value"
2321                             )
2322                     else:
2323                         route_table[outkey] = item.get(inkey)
2324             tables.append(route_table)
2325         return tables
2326     except BotoServerError as e:
2327         return {"error": __utils__["boto.get_error"](e)}
2328 def _create_dhcp_options(
2329     conn,
2330     domain_name=None,
2331     domain_name_servers=None,
2332     ntp_servers=None,
2333     netbios_name_servers=None,
2334     netbios_node_type=None,
2335 ):
2336     return conn.create_dhcp_options(
2337         domain_name=domain_name,
2338         domain_name_servers=domain_name_servers,
2339         ntp_servers=ntp_servers,
2340         netbios_name_servers=netbios_name_servers,
2341         netbios_node_type=netbios_node_type,
2342     )
2343 def _maybe_set_name_tag(name, obj):
2344     if name:
2345         obj.add_tag("Name", name)
2346         log.debug("%s is now named as %s", obj, name)
2347 def _maybe_set_tags(tags, obj):
2348     if tags:
2349         try:
2350             obj.add_tags(tags)
2351         except AttributeError:
2352             for tag, value in tags.items():
2353                 obj.add_tag(tag, value)
2354         log.debug("The following tags: %s were added to %s", ", ".join(tags), obj)
2355 def _maybe_set_dns(conn, vpcid, dns_support, dns_hostnames):
2356     if dns_support:
2357         conn.modify_vpc_attribute(vpc_id=vpcid, enable_dns_support=dns_support)
2358         log.debug("DNS support was set to: %s on vpc %s", dns_support, vpcid)
2359     if dns_hostnames:
2360         conn.modify_vpc_attribute(vpc_id=vpcid, enable_dns_hostnames=dns_hostnames)
2361         log.debug("DNS hostnames was set to: %s on vpc %s", dns_hostnames, vpcid)
2362 def _maybe_name_route_table(conn, vpcid, vpc_name):
2363     route_tables = conn.get_all_route_tables(filters={"vpc_id": vpcid})
2364     if not route_tables:
2365         log.warning("no default route table found")
2366         return
2367     default_table = None
2368     for table in route_tables:
2369         for association in getattr(table, "associations", {}):
2370             if getattr(association, "main", False):
2371                 default_table = table
2372                 break
2373     if not default_table:
2374         log.warning("no default route table found")
2375         return
2376     name = "{}-default-table".format(vpc_name)
2377     _maybe_set_name_tag(name, default_table)
2378     log.debug("Default route table name was set to: %s on vpc %s", name, vpcid)
2379 def _key_iter(key, keys, item):
2380     elements_list = []
2381     for r_item in getattr(item, key):
2382         element = {}
2383         for r_key in keys:
2384             if hasattr(r_item, r_key):
2385                 element[r_key] = getattr(r_item, r_key)
2386         elements_list.append(element)
2387     return elements_list
2388 def _key_remap(key, keys, item):
2389     elements_list = []
2390     for r_item in item.get(key, []):
2391         element = {}
2392         for r_outkey, r_inkey in keys.items():
2393             if r_inkey in r_item:
2394                 element[r_outkey] = r_item.get(r_inkey)
2395         elements_list.append(element)
2396     return elements_list
2397 def _get_subnet_explicit_route_table(
2398     subnet_id, vpc_id, conn=None, region=None, key=None, keyid=None, profile=None
2399 ):
2400     if not conn:
2401         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
2402     if conn:
2403         vpc_route_tables = conn.get_all_route_tables(filters={"vpc_id": vpc_id})
2404         for vpc_route_table in vpc_route_tables:
2405             for rt_association in vpc_route_table.associations:
2406                 if rt_association.subnet_id == subnet_id and not rt_association.main:
2407                     return rt_association.id
2408     return None
2409 def request_vpc_peering_connection(
2410     requester_vpc_id=None,
2411     requester_vpc_name=None,
2412     peer_vpc_id=None,
2413     peer_vpc_name=None,
2414     name=None,
2415     peer_owner_id=None,
2416     peer_region=None,
2417     region=None,
2418     key=None,
2419     keyid=None,
2420     profile=None,
2421     dry_run=False,
2422 ):
2423     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2424     if name and _vpc_peering_conn_id_for_name(name, conn):
2425         raise SaltInvocationError(
2426             "A VPC peering connection with this name already "
2427             "exists! Please specify a different name."
2428         )
2429     if not _exactly_one((requester_vpc_id, requester_vpc_name)):
2430         raise SaltInvocationError(
2431             "Exactly one of requester_vpc_id or requester_vpc_name is required"
2432         )
2433     if not _exactly_one((peer_vpc_id, peer_vpc_name)):
2434         raise SaltInvocationError(
2435             "Exactly one of peer_vpc_id or peer_vpc_name is required."
2436         )
2437     if requester_vpc_name:
2438         requester_vpc_id = _get_id(
2439             vpc_name=requester_vpc_name,
2440             region=region,
2441             key=key,
2442             keyid=keyid,
2443             profile=profile,
2444         )
2445         if not requester_vpc_id:
2446             return {
2447                 "error": "Could not resolve VPC name {} to an ID".format(
2448                     requester_vpc_name
2449                 )
2450             }
2451     if peer_vpc_name:
2452         peer_vpc_id = _get_id(
2453             vpc_name=peer_vpc_name, region=region, key=key, keyid=keyid, profile=profile
2454         )
2455         if not peer_vpc_id:
2456             return {
2457                 "error": "Could not resolve VPC name {} to an ID".format(peer_vpc_name)
2458             }
2459     peering_params = {
2460         "VpcId": requester_vpc_id,
2461         "PeerVpcId": peer_vpc_id,
2462         "DryRun": dry_run,
2463     }
2464     if peer_owner_id:
2465         peering_params.update({"PeerOwnerId": peer_owner_id})
2466     if peer_region:
2467         peering_params.update({"PeerRegion": peer_region})
2468     try:
2469         log.debug("Trying to request vpc peering connection")
2470         if not peer_owner_id:
2471             vpc_peering = conn.create_vpc_peering_connection(**peering_params)
2472         else:
2473             vpc_peering = conn.create_vpc_peering_connection(**peering_params)
2474         peering = vpc_peering.get("VpcPeeringConnection", {})
2475         peering_conn_id = peering.get("VpcPeeringConnectionId", "ERROR")
2476         msg = "VPC peering {} requested.".format(peering_conn_id)
2477         log.debug(msg)
2478         if name:
2479             log.debug("Adding name tag to vpc peering connection")
2480             conn.create_tags(
2481                 Resources=[peering_conn_id], Tags=[{"Key": "Name", "Value": name}]
2482             )
2483             log.debug("Applied name tag to vpc peering connection")
2484             msg += " With name {}.".format(name)
2485         return {"msg": msg}
2486     except botocore.exceptions.ClientError as err:
2487         log.error("Got an error while trying to request vpc peering")
2488         return {"error": __utils__["boto.get_error"](err)}
2489 def _get_peering_connection_ids(name, conn):
2490     filters = [
2491         {"Name": "tag:Name", "Values": [name]},
2492         {"Name": "status-code", "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING]},
2493     ]
2494     peerings = conn.describe_vpc_peering_connections(Filters=filters).get(
2495         "VpcPeeringConnections", []
2496     )
2497     return [x["VpcPeeringConnectionId"] for x in peerings]
2498 def describe_vpc_peering_connection(
2499     name, region=None, key=None, keyid=None, profile=None
2500 ):
2501     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2502     return {"VPC-Peerings": _get_peering_connection_ids(name, conn)}
2503 def accept_vpc_peering_connection(  # pylint: disable=too-many-arguments
2504     conn_id="", name="", region=None, key=None, keyid=None, profile=None, dry_run=False
2505 ):
2506     if not _exactly_one((conn_id, name)):
2507         raise SaltInvocationError(
2508             "One (but not both) of vpc_peering_connection_id or name must be provided."
2509         )
2510     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2511     if name:
2512         conn_id = _vpc_peering_conn_id_for_name(name, conn)
2513         if not conn_id:
2514             raise SaltInvocationError(
2515                 "No ID found for this "
2516                 "VPC peering connection! ({}) "
2517                 "Please make sure this VPC peering "
2518                 "connection exists "
2519                 "or invoke this function with "
2520                 "a VPC peering connection "
2521                 "ID".format(name)
2522             )
2523     try:
2524         log.debug("Trying to accept vpc peering connection")
2525         conn.accept_vpc_peering_connection(
2526             DryRun=dry_run, VpcPeeringConnectionId=conn_id
2527         )
2528         return {"msg": "VPC peering connection accepted."}
2529     except botocore.exceptions.ClientError as err:
2530         log.error("Got an error while trying to accept vpc peering")
2531         return {"error": __utils__["boto.get_error"](err)}
2532 def _vpc_peering_conn_id_for_name(name, conn):
2533     log.debug("Retrieving VPC peering connection id")
2534     ids = _get_peering_connection_ids(name, conn)
2535     if not ids:
2536         ids = [None]  # Let callers handle the case where we have no id
2537     elif len(ids) &gt; 1:
2538         raise SaltInvocationError(
2539             "Found multiple VPC peering connections "
2540             "with the same name!! "
2541             "Please make sure you have only "
2542             "one VPC peering connection named {} "
2543             "or invoke this function with a VPC "
2544             "peering connection ID".format(name)
2545         )
2546     return ids[0]
2547 def delete_vpc_peering_connection(
2548     conn_id=None,
2549     conn_name=None,
2550     region=None,
2551     key=None,
2552     keyid=None,
2553     profile=None,
2554     dry_run=False,
2555 ):
2556     if not _exactly_one((conn_id, conn_name)):
2557         raise SaltInvocationError(
2558             "Exactly one of conn_id or conn_name must be provided."
2559         )
2560     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2561     if conn_name:
2562         conn_id = _vpc_peering_conn_id_for_name(conn_name, conn)
2563         if not conn_id:
2564             raise SaltInvocationError(
2565                 "Couldn't resolve VPC peering connection {} to an ID".format(conn_name)
2566             )
2567     try:
2568         log.debug("Trying to delete vpc peering connection")
2569         conn.delete_vpc_peering_connection(
2570             DryRun=dry_run, VpcPeeringConnectionId=conn_id
2571         )
2572         return {"msg": "VPC peering connection deleted."}
2573     except botocore.exceptions.ClientError as err:
2574         e = __utils__["boto.get_error"](err)
2575         log.error("Failed to delete VPC peering %s: %s", conn_name or conn_id, e)
2576         return {"error": e}
2577 def is_peering_connection_pending(
2578     conn_id=None, conn_name=None, region=None, key=None, keyid=None, profile=None
2579 ):
2580     if not _exactly_one((conn_id, conn_name)):
2581         raise SaltInvocationError(
2582             "Exactly one of conn_id or conn_name must be provided."
2583         )
2584     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2585     if conn_id:
2586         vpcs = conn.describe_vpc_peering_connections(
2587             VpcPeeringConnectionIds=[conn_id]
2588         ).get("VpcPeeringConnections", [])
2589     else:
2590         filters = [
2591             {"Name": "tag:Name", "Values": [conn_name]},
2592             {
2593                 "Name": "status-code",
2594                 "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING],
2595             },
2596         ]
2597         vpcs = conn.describe_vpc_peering_connections(Filters=filters).get(
2598             "VpcPeeringConnections", []
2599         )
2600     if not vpcs:
2601         return False
2602     elif len(vpcs) &gt; 1:
2603         raise SaltInvocationError(
2604             "Found more than one ID for the VPC peering "
2605             "connection ({}). Please call this function "
2606             "with an ID instead.".format(conn_id or conn_name)
2607         )
2608     else:
2609         status = vpcs[0]["Status"]["Code"]
2610     return status == PENDING_ACCEPTANCE
2611 def peering_connection_pending_from_vpc(
2612     conn_id=None,
2613     conn_name=None,
2614     vpc_id=None,
2615     vpc_name=None,
2616     region=None,
2617     key=None,
2618     keyid=None,
2619     profile=None,
2620 ):
2621     if not _exactly_one((conn_id, conn_name)):
2622         raise SaltInvocationError(
2623             "Exactly one of conn_id or conn_name must be provided."
2624         )
2625     if not _exactly_one((vpc_id, vpc_name)):
2626         raise SaltInvocationError("Exactly one of vpc_id or vpc_name must be provided.")
2627     if vpc_name:
2628         vpc_id = check_vpc(
2629             vpc_name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
2630         )
2631         if not vpc_id:
2632             log.warning("Could not resolve VPC name %s to an ID", vpc_name)
2633             return False
2634     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2635     filters = [
2636         {"Name": "requester-vpc-info.vpc-id", "Values": [vpc_id]},
2637         {"Name": "status-code", "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING]},
2638     ]
2639     if conn_id:
2640         filters += [{"Name": "vpc-peering-connection-id", "Values": [conn_id]}]
2641     else:
2642         filters += [{"Name": "tag:Name", "Values": [conn_name]}]
2643     vpcs = conn.describe_vpc_peering_connections(Filters=filters).get(
2644         "VpcPeeringConnections", []
2645     )
2646     if not vpcs:
2647         return False
2648     elif len(vpcs) &gt; 1:
2649         raise SaltInvocationError(
2650             "Found more than one ID for the VPC peering "
2651             "connection ({}). Please call this function "
2652             "with an ID instead.".format(conn_id or conn_name)
2653         )
2654     else:
2655         status = vpcs[0]["Status"]["Code"]
2656     return bool(status == PENDING_ACCEPTANCE)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
