<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for grafana_dashboard.py &amp; boto_vpc_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for grafana_dashboard.py &amp; boto_vpc_1.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>grafana_dashboard.py (1.897019%)<th>boto_vpc_1.py (0.3711559%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-99)<td><a href="#" name="0">(1572-1588)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>grafana_dashboard.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import requests
import salt.utils.json
from salt.utils.dictdiffer import DictDiffer
def __virtual__():
    if __salt__["config.get"]("grafana_version", 1) == 2:
        return True
    return (False, "Not configured for grafana_version 2")
_DEFAULT_DASHBOARD_PILLAR = "grafana_dashboards:default"
_DEFAULT_PANEL_PILLAR = "grafana_panels:default"
_DEFAULT_ROW_PILLAR = "grafana_rows:default"
<a name="0"></a>_PINNED_ROWS_PILLAR = "grafana_pinned_rows"
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def present(
    name,
    base_dashboards_from_pillar=None,
    base_panels_from_pillar=None,
    base_rows_from_pillar=None,
    dashboard=None,
    profile="grafana",
):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    base_dashboards_from_pillar = base_dashboards_from_pillar or []
    base_panels_from_pillar = base_panels_from_pillar or []
    base_rows_from_pillar = base_rows_from_pillar or []
    dashboard = dashboard or {}
    if isinstance(</b></font>profile, str):
        profile = __salt__["config.option"](profile)
    base_dashboards_from_pillar = [
        _DEFAULT_DASHBOARD_PILLAR
    ] + base_dashboards_from_pillar
    base_panels_from_pillar = [_DEFAULT_PANEL_PILLAR] + base_panels_from_pillar
    base_rows_from_pillar = [_DEFAULT_ROW_PILLAR] + base_rows_from_pillar
    new_dashboard = _inherited_dashboard(dashboard, base_dashboards_from_pillar, ret)
    new_dashboard["title"] = name
    rows = new_dashboard.get("rows", [])
    for i, row in enumerate(rows):
        rows[i] = _inherited_row(row, base_rows_from_pillar, ret)
    for row in rows:
        panels = row.get("panels", [])
        for i, panel in enumerate(panels):
            panels[i] = _inherited_panel(panel, base_panels_from_pillar, ret)
    _auto_adjust_panel_spans(new_dashboard)
    _ensure_panel_ids(new_dashboard)
    _ensure_annotations(new_dashboard)
    url = "db/{}".format(name)
    old_dashboard = _get(url, profile)
    if not old_dashboard:
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Dashboard {} is set to be created.".format(name)
            return ret
        response = _update(new_dashboard, profile)
        if response.get("status") == "success":
            ret["comment"] = "Dashboard {} created.".format(name)
            ret["changes"]["new"] = "Dashboard {} created.".format(name)
        else:
            ret["result"] = False
            ret["comment"] = "Failed to create dashboard {}, response={}".format(
                name, response
            )
        return ret
    managed_row_titles = [row.get("title") for row in new_dashboard.get("rows", [])]
    new_rows = new_dashboard.get("rows", [])
    for old_row in old_dashboard.get("rows", []):
        if old_row.get("title") not in managed_row_titles:
            new_rows.append(copy.deepcopy(old_row))
    _ensure_pinned_rows(new_dashboard)
    _ensure_panel_ids(new_dashboard)
    dashboard_diff = DictDiffer(_cleaned(new_dashboard), _cleaned(old_dashboard))
    updated_needed = (
        dashboard_diff.changed() or dashboard_diff.added() or dashboard_diff.removed()
    )
    if updated_needed:
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Dashboard {} is set to be updated, changes={}".format(
                name,
                salt.utils.json.dumps(
                    _dashboard_diff(_cleaned(new_dashboard), _cleaned(old_dashboard)),
                    indent=4,
                ),
            )
            return ret
        response = _update(new_dashboard, profile)
        if response.get("status") == "success":
            updated_dashboard = _get(url, profile)
            dashboard_diff = DictDiffer(
                _cleaned(updated_dashboard), _cleaned(old_dashboard)
            )
            ret["comment"] = "Dashboard {} updated.".format(name)
            ret["changes"] = _dashboard_diff(
                _cleaned(new_dashboard), _cleaned(old_dashboard)
            )
        else:
            ret["result"] = False
            ret["comment"] = "Failed to update dashboard {}, response={}".format(
                name, response
            )
        return ret
    ret["comment"] = "Dashboard present"
    return ret
def absent(name, profile="grafana"):
    ret = {"name": name, "result": True, "comment": "", "changes": {}}
    if isinstance(profile, str):
        profile = __salt__["config.option"](profile)
    url = "db/{}".format(name)
    existing_dashboard = _get(url, profile)
    if existing_dashboard:
        if __opts__["test"]:
            ret["result"] = None
            ret["comment"] = "Dashboard {} is set to be deleted.".format(name)
            return ret
        _delete(url, profile)
        ret["comment"] = "Dashboard {} deleted.".format(name)
        ret["changes"]["new"] = "Dashboard {} deleted.".format(name)
        return ret
    ret["comment"] = "Dashboard absent"
    return ret
_IGNORED_DASHBOARD_FIELDS = [
    "id",
    "originalTitle",
    "version",
]
_IGNORED_ROW_FIELDS = []
_IGNORED_PANEL_FIELDS = [
    "grid",
    "mode",
    "tooltip",
]
_IGNORED_TARGET_FIELDS = [
    "textEditor",
]
def _cleaned(_dashboard):
    dashboard = copy.deepcopy(_dashboard)
    for ignored_dashboard_field in _IGNORED_DASHBOARD_FIELDS:
        dashboard.pop(ignored_dashboard_field, None)
    for row in dashboard.get("rows", []):
        for ignored_row_field in _IGNORED_ROW_FIELDS:
            row.pop(ignored_row_field, None)
        for i, panel in enumerate(row.get("panels", [])):
            for ignored_panel_field in _IGNORED_PANEL_FIELDS:
                panel.pop(ignored_panel_field, None)
            for target in panel.get("targets", []):
                for ignored_target_field in _IGNORED_TARGET_FIELDS:
                    target.pop(ignored_target_field, None)
            row["panels"][i] = _stripped(panel)
    return dashboard
def _inherited_dashboard(dashboard, base_dashboards_from_pillar, ret):
    base_dashboards = []
    for base_dashboard_from_pillar in base_dashboards_from_pillar:
        base_dashboard = __salt__["pillar.get"](base_dashboard_from_pillar)
        if base_dashboard:
            base_dashboards.append(base_dashboard)
        elif base_dashboard_from_pillar != _DEFAULT_DASHBOARD_PILLAR:
            ret.setdefault("warnings", [])
            warning_message = 'Cannot find dashboard pillar "{}".'.format(
                base_dashboard_from_pillar
            )
            if warning_message not in ret["warnings"]:
                ret["warnings"].append(warning_message)
    base_dashboards.append(dashboard)
    result_dashboard = {}
    tags = set()
    for dashboard in base_dashboards:
        tags.update(dashboard.get("tags", []))
        result_dashboard.update(dashboard)
    result_dashboard["tags"] = list(tags)
    return result_dashboard
def _inherited_row(row, base_rows_from_pillar, ret):
    base_rows = []
    for base_row_from_pillar in base_rows_from_pillar:
        base_row = __salt__["pillar.get"](base_row_from_pillar)
        if base_row:
            base_rows.append(base_row)
        elif base_row_from_pillar != _DEFAULT_ROW_PILLAR:
            ret.setdefault("warnings", [])
            warning_message = 'Cannot find row pillar "{}".'.format(
                base_row_from_pillar
            )
            if warning_message not in ret["warnings"]:
                ret["warnings"].append(warning_message)
    base_rows.append(row)
    result_row = {}
    for row in base_rows:
        result_row.update(row)
    return result_row
def _inherited_panel(panel, base_panels_from_pillar, ret):
    base_panels = []
    for base_panel_from_pillar in base_panels_from_pillar:
        base_panel = __salt__["pillar.get"](base_panel_from_pillar)
        if base_panel:
            base_panels.append(base_panel)
        elif base_panel_from_pillar != _DEFAULT_PANEL_PILLAR:
            ret.setdefault("warnings", [])
            warning_message = 'Cannot find panel pillar "{}".'.format(
                base_panel_from_pillar
            )
            if warning_message not in ret["warnings"]:
                ret["warnings"].append(warning_message)
    base_panels.append(panel)
    result_panel = {}
    for panel in base_panels:
        result_panel.update(panel)
    return result_panel
_FULL_LEVEL_SPAN = 12
_DEFAULT_PANEL_SPAN = 2.5
def _auto_adjust_panel_spans(dashboard):
    for row in dashboard.get("rows", []):
        levels = []
        current_level = []
        levels.append(current_level)
        for panel in row.get("panels", []):
            current_level_span = sum(
                panel.get("span", _DEFAULT_PANEL_SPAN) for panel in current_level
            )
            span = panel.get("span", _DEFAULT_PANEL_SPAN)
            if current_level_span + span &gt; _FULL_LEVEL_SPAN:
                current_level = [panel]
                levels.append(current_level)
            else:
                current_level.append(panel)
        for level in levels:
            specified_panels = [panel for panel in level if "span" in panel]
            unspecified_panels = [panel for panel in level if "span" not in panel]
            if not unspecified_panels:
                continue
            specified_span = sum(panel["span"] for panel in specified_panels)
            available_span = _FULL_LEVEL_SPAN - specified_span
            auto_span = float(available_span) / len(unspecified_panels)
            for panel in unspecified_panels:
                panel["span"] = auto_span
def _ensure_pinned_rows(dashboard):
    pinned_row_titles = __salt__["pillar.get"](_PINNED_ROWS_PILLAR)
    if not pinned_row_titles:
        return
    pinned_row_titles_lower = []
    for title in pinned_row_titles:
        pinned_row_titles_lower.append(title.lower())
    rows = dashboard.get("rows", [])
    pinned_rows = []
    for i, row in enumerate(rows):
        if row.get("title", "").lower() in pinned_row_titles_lower:
            del rows[i]
            pinned_rows.append(row)
    rows = pinned_rows + rows
def _ensure_panel_ids(dashboard):
    panel_id = 1
    for row in dashboard.get("rows", []):
        for panel in row.get("panels", []):
            panel["id"] = panel_id
            panel_id += 1
def _ensure_annotations(dashboard):
    if "annotation_tags" not in dashboard:
        return
    tags = dashboard["annotation_tags"]
    annotations = {
        "enable": True,
        "list": [],
    }
    for tag in tags:
        annotations["list"].append(
            {
                "datasource": "graphite",
                "enable": False,
                "iconColor": "#C0C6BE",
                "iconSize": 13,
                "lineColor": "rgba(255, 96, 96, 0.592157)",
                "name": tag,
                "showLine": True,
                "tags": tag,
            }
        )
    del dashboard["annotation_tags"]
    dashboard["annotations"] = annotations
def _get(url, profile):
    request_url = "{}/api/dashboards/{}".format(profile.get("grafana_url"), url)
    response = requests.get(
        request_url,
        headers={
            "Accept": "application/json",
            "Authorization": "Bearer {}".format(profile.get("grafana_token")),
        },
        timeout=profile.get("grafana_timeout", 3),
    )
    data = response.json()
    if data.get("message") == "Not found":
        return None
    if "dashboard" not in data:
        return None
    return data["dashboard"]
def _delete(url, profile):
    request_url = "{}/api/dashboards/{}".format(profile.get("grafana_url"), url)
    response = requests.delete(
        request_url,
        headers={
            "Accept": "application/json",
            "Authorization": "Bearer {}".format(profile.get("grafana_token")),
        },
        timeout=profile.get("grafana_timeout"),
    )
    data = response.json()
    return data
def _update(dashboard, profile):
    payload = {"dashboard": dashboard, "overwrite": True}
    request_url = "{}/api/dashboards/db".format(profile.get("grafana_url"))
    response = requests.post(
        request_url,
        headers={"Authorization": "Bearer {}".format(profile.get("grafana_token"))},
        json=payload,
    )
    return response.json()
def _dashboard_diff(_new_dashboard, _old_dashboard):
    diff = {}
    new_dashboard = copy.deepcopy(_new_dashboard)
    old_dashboard = copy.deepcopy(_old_dashboard)
    dashboard_diff = DictDiffer(new_dashboard, old_dashboard)
    diff["dashboard"] = _stripped(
        {
            "changed": list(dashboard_diff.changed()) or None,
            "added": list(dashboard_diff.added()) or None,
            "removed": list(dashboard_diff.removed()) or None,
        }
    )
    new_rows = new_dashboard.get("rows", [])
    old_rows = old_dashboard.get("rows", [])
    new_rows_by_title = {}
    old_rows_by_title = {}
    for row in new_rows:
        if "title" in row:
            new_rows_by_title[row["title"]] = row
    for row in old_rows:
        if "title" in row:
            old_rows_by_title[row["title"]] = row
    rows_diff = DictDiffer(new_rows_by_title, old_rows_by_title)
    diff["rows"] = _stripped(
        {
            "added": list(rows_diff.added()) or None,
            "removed": list(rows_diff.removed()) or None,
        }
    )
    for changed_row_title in rows_diff.changed():
        old_row = old_rows_by_title[changed_row_title]
        new_row = new_rows_by_title[changed_row_title]
        row_diff = DictDiffer(new_row, old_row)
        diff["rows"].setdefault("changed", {})
        diff["rows"]["changed"][changed_row_title] = _stripped(
            {
                "changed": list(row_diff.changed()) or None,
                "added": list(row_diff.added()) or None,
                "removed": list(row_diff.removed()) or None,
            }
        )
    old_panels_by_id = {}
    new_panels_by_id = {}
    for row in old_dashboard.get("rows", []):
        for panel in row.get("panels", []):
            if "id" in panel:
                old_panels_by_id[panel["id"]] = panel
    for row in new_dashboard.get("rows", []):
        for panel in row.get("panels", []):
            if "id" in panel:
                new_panels_by_id[panel["id"]] = panel
    panels_diff = DictDiffer(new_panels_by_id, old_panels_by_id)
    diff["panels"] = _stripped(
        {
            "added": list(panels_diff.added()) or None,
            "removed": list(panels_diff.removed()) or None,
        }
    )
    for changed_panel_id in panels_diff.changed():
        old_panel = old_panels_by_id[changed_panel_id]
        new_panel = new_panels_by_id[changed_panel_id]
        panels_diff = DictDiffer(new_panel, old_panel)
        diff["panels"].setdefault("changed", {})
        diff["panels"]["changed"][changed_panel_id] = _stripped(
            {
                "changed": list(panels_diff.changed()) or None,
                "added": list(panels_diff.added()) or None,
                "removed": list(panels_diff.removed()) or None,
            }
        )
    return diff
def _stripped(d):
    ret = {}
    for k, v in d.items():
        if v:
            ret[k] = v
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_vpc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import random
import socket
import time
import salt.utils.compat
import salt.utils.versions
from salt.exceptions import CommandExecutionError, SaltInvocationError
PROVISIONING = "provisioning"
PENDING_ACCEPTANCE = "pending-acceptance"
ACTIVE = "active"
log = logging.getLogger(__name__)
try:
    import boto
    import botocore
    import boto.vpc
    from boto.exception import BotoServerError
    logging.getLogger("boto").setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
try:
    import boto3
    logging.getLogger("boto3").setLevel(logging.CRITICAL)
    HAS_BOTO3 = True
except ImportError:
    HAS_BOTO3 = False
def __virtual__():
    return salt.utils.versions.check_boto_reqs(boto_ver="2.8.0", boto3_ver="1.2.6")
def __init__(opts):
    if HAS_BOTO:
        __utils__["boto.assign_funcs"](__name__, "vpc", pack=__salt__)
    if HAS_BOTO3:
        __utils__["boto3.assign_funcs"](
            __name__,
            "ec2",
            get_conn_funcname="_get_conn3",
            cache_id_funcname="_cache_id3",
            exactly_one_funcname=None,
        )
def check_vpc(
    vpc_id=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((vpc_name, vpc_id)):
        raise SaltInvocationError(
            "One (but not both) of vpc_id or vpc_name must be provided."
        )
    if vpc_name:
        vpc_id = _get_id(
            vpc_name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
        )
    elif not _find_vpcs(
        vpc_id=vpc_id, region=region, key=key, keyid=keyid, profile=profile
    ):
        log.info("VPC %s does not exist.", vpc_id)
        return None
    return vpc_id
def _create_resource(
    resource,
    name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    **kwargs
):
    try:
        try:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            create_resource = getattr(conn, "create_" + resource)
        except AttributeError:
            raise AttributeError(
                "{} function does not exist for boto VPC connection.".format(
                    "create_" + resource
                )
            )
        if name and _get_resource_id(
            resource, name, region=region, key=key, keyid=keyid, profile=profile
        ):
            return {
                "created": False,
                "error": {
                    "message": "A {} named {} already exists.".format(resource, name)
                },
            }
        r = create_resource(**kwargs)
        if r:
            if isinstance(r, bool):
                return {"created": True}
            else:
                log.info("A %s with id %s was created", resource, r.id)
                _maybe_set_name_tag(name, r)
                _maybe_set_tags(tags, r)
                if name:
                    _cache_id(
                        name,
                        sub_resource=resource,
                        resource_id=r.id,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                return {"created": True, "id": r.id}
        else:
            if name:
                e = "{} {} was not created.".format(resource, name)
            else:
                e = "{} was not created.".format(resource)
            log.warning(e)
            return {"created": False, "error": {"message": e}}
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
def _delete_resource(
    resource,
    name=None,
    resource_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    **kwargs
):
    if not _exactly_one((name, resource_id)):
        raise SaltInvocationError("One (but not both) of name or id must be provided.")
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        try:
            delete_resource = getattr(conn, "delete_" + resource)
        except AttributeError:
            raise AttributeError(
                "{} function does not exist for boto VPC connection.".format(
                    "delete_" + resource
                )
            )
        if name:
            resource_id = _get_resource_id(
                resource, name, region=region, key=key, keyid=keyid, profile=profile
            )
            if not resource_id:
                return {
                    "deleted": False,
                    "error": {
                        "message": "{} {} does not exist.".format(resource, name)
                    },
                }
        if delete_resource(resource_id, **kwargs):
            _cache_id(
                name,
                sub_resource=resource,
                resource_id=resource_id,
                invalidate=True,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            return {"deleted": True}
        else:
            if name:
                e = "{} {} was not deleted.".format(resource, name)
            else:
                e = "{} was not deleted.".format(resource)
            return {"deleted": False, "error": {"message": e}}
    except BotoServerError as e:
        return {"deleted": False, "error": __utils__["boto.get_error"](e)}
def _get_resource(
    resource,
    name=None,
    resource_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((name, resource_id)):
        raise SaltInvocationError("One (but not both) of name or id must be provided.")
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    f = "get_all_{}".format(resource)
    if not f.endswith("s"):
        f = f + "s"
    get_resources = getattr(conn, f)
    filter_parameters = {}
    if name:
        filter_parameters["filters"] = {"tag:Name": name}
    if resource_id:
        filter_parameters["{}_ids".format(resource)] = resource_id
    try:
        r = get_resources(**filter_parameters)
    except BotoServerError as e:
        if e.code.endswith(".NotFound"):
            return None
        raise
    if r:
        if len(r) == 1:
            if name:
                _cache_id(
                    name,
                    sub_resource=resource,
                    resource_id=r[0].id,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
            return r[0]
        else:
            raise CommandExecutionError(
                'Found more than one {} named "{}"'.format(resource, name)
            )
    else:
        return None
def _find_resources(
    resource,
    name=None,
    resource_id=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if all((resource_id, name)):
        raise SaltInvocationError("Only one of name or id may be provided.")
    if not any((resource_id, name, tags)):
        raise SaltInvocationError(
            "At least one of the following must be provided: id, name, or tags."
        )
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    f = "get_all_{}".format(resource)
    if not f.endswith("s"):
        f = f + "s"
    get_resources = getattr(conn, f)
    filter_parameters = {}
    if name:
        filter_parameters["filters"] = {"tag:Name": name}
    if resource_id:
        filter_parameters["{}_ids".format(resource)] = resource_id
    if tags:
        for tag_name, tag_value in tags.items():
            filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
    try:
        r = get_resources(**filter_parameters)
    except BotoServerError as e:
        if e.code.endswith(".NotFound"):
            return None
        raise
    return r
def _get_resource_id(resource, name, region=None, key=None, keyid=None, profile=None):
    _id = _cache_id(
        name,
        sub_resource=resource,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if _id:
        return _id
    r = _get_resource(
        resource, name=name, region=region, key=key, keyid=keyid, profile=profile
    )
    if r:
        return r.id
def get_resource_id(
    resource,
    name=None,
    resource_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        return {
            "id": _get_resource_id(
                resource, name, region=region, key=key, keyid=keyid, profile=profile
            )
        }
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
def resource_exists(
    resource,
    name=None,
    resource_id=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        return {
            "exists": bool(
                _find_resources(
                    resource,
                    name=name,
                    resource_id=resource_id,
                    tags=tags,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
            )
        }
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
def _find_vpcs(
    vpc_id=None,
    vpc_name=None,
    cidr=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if all((vpc_id, vpc_name)):
        raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    filter_parameters = {"filters": {}}
    if vpc_id:
        filter_parameters["vpc_ids"] = [vpc_id]
    if cidr:
        filter_parameters["filters"]["cidr"] = cidr
    if vpc_name:
        filter_parameters["filters"]["tag:Name"] = vpc_name
    if tags:
        for tag_name, tag_value in tags.items():
            filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
    vpcs = conn.get_all_vpcs(**filter_parameters)
    log.debug(
        "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
    )
    if vpcs:
        if not any((vpc_id, vpc_name, cidr, tags)):
            return [vpc.id for vpc in vpcs if vpc.is_default]
        else:
            return [vpc.id for vpc in vpcs]
    else:
        return []
def _get_id(
    vpc_name=None,
    cidr=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not any((vpc_name, tags, cidr)):
        raise SaltInvocationError(
            "At least one of the following must be provided: vpc_name, cidr or tags."
        )
    if vpc_name and not any((cidr, tags)):
        vpc_id = _cache_id(
            vpc_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if vpc_id:
            return vpc_id
    vpc_ids = _find_vpcs(
        vpc_name=vpc_name,
        cidr=cidr,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if vpc_ids:
        log.debug("Matching VPC: %s", " ".join(vpc_ids))
        if len(vpc_ids) == 1:
            vpc_id = vpc_ids[0]
            if vpc_name:
                _cache_id(
                    vpc_name,
                    vpc_id,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
            return vpc_id
        else:
            raise CommandExecutionError(
                "Found more than one VPC matching the criteria."
            )
    else:
        log.info("No VPC found.")
        return None
def get_id(
    name=None,
    cidr=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        return {
            "id": _get_id(
                vpc_name=name,
                cidr=cidr,
                tags=tags,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        }
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
def exists(
    vpc_id=None,
    name=None,
    cidr=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not any((vpc_id, name, tags, cidr)):
        raise SaltInvocationError(
            "At least one of the following must be "
            "provided: vpc_id, vpc_name, cidr or tags."
        )
    try:
        vpc_ids = _find_vpcs(
            vpc_id=vpc_id,
            vpc_name=name,
            cidr=cidr,
            tags=tags,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    except BotoServerError as err:
        boto_err = __utils__["boto.get_error"](err)
        if boto_err.get("aws", {}).get("code") == "InvalidVpcID.NotFound":
            return {"exists": False}
        return {"error": boto_err}
    return {"exists": bool(vpc_ids)}
def create(
    cidr_block,
    instance_tenancy=None,
    vpc_name=None,
    enable_dns_support=None,
    enable_dns_hostnames=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        vpc = conn.create_vpc(cidr_block, instance_tenancy=instance_tenancy)
        if vpc:
            log.info("The newly created VPC id is %s", vpc.id)
            _maybe_set_name_tag(vpc_name, vpc)
            _maybe_set_tags(tags, vpc)
            _maybe_set_dns(conn, vpc.id, enable_dns_support, enable_dns_hostnames)
            _maybe_name_route_table(conn, vpc.id, vpc_name)
            if vpc_name:
                _cache_id(
                    vpc_name,
                    vpc.id,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
            return {"created": True, "id": vpc.id}
        else:
            log.warning("VPC was not created")
            return {"created": False}
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
def delete(
    vpc_id=None,
    name=None,
    vpc_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if name:
        log.warning(
            "boto_vpc.delete: name parameter is deprecated use vpc_name instead."
        )
        vpc_name = name
    if not _exactly_one((vpc_name, vpc_id)):
        raise SaltInvocationError(
            "One (but not both) of vpc_name or vpc_id must be provided."
        )
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if not vpc_id:
            vpc_id = _get_id(
                vpc_name=vpc_name,
                tags=tags,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not vpc_id:
                return {
                    "deleted": False,
                    "error": {"message": "VPC {} not found".format(vpc_name)},
                }
        if conn.delete_vpc(vpc_id):
            log.info("VPC %s was deleted.", vpc_id)
            if vpc_name:
                _cache_id(
                    vpc_name,
                    resource_id=vpc_id,
                    invalidate=True,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                )
            return {"deleted": True}
        else:
            log.warning("VPC %s was not deleted.", vpc_id)
            return {"deleted": False}
    except BotoServerError as e:
        return {"deleted": False, "error": __utils__["boto.get_error"](e)}
def describe(
    vpc_id=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        vpc_id = _find_vpcs(
            vpc_id=vpc_id,
            vpc_name=vpc_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    except BotoServerError as err:
        boto_err = __utils__["boto.get_error"](err)
        if boto_err.get("aws", {}).get("code") == "InvalidVpcID.NotFound":
            return {"vpc": None}
        return {"error": boto_err}
    if not vpc_id:
        return {"vpc": None}
    filter_parameters = {"vpc_ids": vpc_id}
    try:
        vpcs = conn.get_all_vpcs(**filter_parameters)
    except BotoServerError as err:
        return {"error": __utils__["boto.get_error"](err)}
    if vpcs:
        vpc = vpcs[0]  # Found!
        log.debug("Found VPC: %s", vpc.id)
        keys = (
            "id",
            "cidr_block",
            "is_default",
            "state",
            "tags",
            "dhcp_options_id",
            "instance_tenancy",
        )
        _r = {k: getattr(vpc, k) for k in keys}
        _r.update({"region": getattr(vpc, "region").name})
        return {"vpc": _r}
    else:
        return {"vpc": None}
def describe_vpcs(
    vpc_id=None,
    name=None,
    cidr=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    keys = (
        "id",
        "cidr_block",
        "is_default",
        "state",
        "tags",
        "dhcp_options_id",
        "instance_tenancy",
    )
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        filter_parameters = {"filters": {}}
        if vpc_id:
            filter_parameters["vpc_ids"] = [vpc_id]
        if cidr:
            filter_parameters["filters"]["cidr"] = cidr
        if name:
            filter_parameters["filters"]["tag:Name"] = name
        if tags:
            for tag_name, tag_value in tags.items():
                filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
        vpcs = conn.get_all_vpcs(**filter_parameters)
        if vpcs:
            ret = []
            for vpc in vpcs:
                _r = {k: getattr(vpc, k) for k in keys}
                _r.update({"region": getattr(vpc, "region").name})
                ret.append(_r)
            return {"vpcs": ret}
        else:
            return {"vpcs": []}
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
def _find_subnets(subnet_name=None, vpc_id=None, cidr=None, tags=None, conn=None):
    if not any([subnet_name, tags, cidr]):
        raise SaltInvocationError(
            "At least one of the following must be "
            "specified: subnet_name, cidr or tags."
        )
    filter_parameters = {"filters": {}}
    if cidr:
        filter_parameters["filters"]["cidr"] = cidr
    if subnet_name:
        filter_parameters["filters"]["tag:Name"] = subnet_name
    if vpc_id:
        filter_parameters["filters"]["VpcId"] = vpc_id
    if tags:
        for tag_name, tag_value in tags.items():
            filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
    subnets = conn.get_all_subnets(**filter_parameters)
    log.debug(
        "The filters criteria %s matched the following subnets: %s",
        filter_parameters,
        subnets,
    )
    if subnets:
        return [subnet.id for subnet in subnets]
    else:
        return False
def create_subnet(
    vpc_id=None,
    cidr_block=None,
    vpc_name=None,
    availability_zone=None,
    subnet_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    auto_assign_public_ipv4=False,
):
    try:
        vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
        if not vpc_id:
            return {
                "created": False,
                "error": {
                    "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
                },
            }
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
    subnet_object_dict = _create_resource(
        "subnet",
        name=subnet_name,
        tags=tags,
        vpc_id=vpc_id,
        availability_zone=availability_zone,
        cidr_block=cidr_block,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if auto_assign_public_ipv4:
        conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
        conn3.modify_subnet_attribute(
            MapPublicIpOnLaunch={"Value": True}, SubnetId=subnet_object_dict["id"]
        )
    return subnet_object_dict
def delete_subnet(
    subnet_id=None, subnet_name=None, region=None, key=None, keyid=None, profile=None
):
    return _delete_resource(
        resource="subnet",
        name=subnet_name,
        resource_id=subnet_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def subnet_exists(
    subnet_id=None,
    name=None,
    subnet_name=None,
    cidr=None,
    tags=None,
    zones=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if name:
        log.warning(
            "boto_vpc.subnet_exists: name parameter is deprecated "
            "use subnet_name instead."
        )
        subnet_name = name
    if not any((subnet_id, subnet_name, cidr, tags, zones)):
        raise SaltInvocationError(
            "At least one of the following must be "
            "specified: subnet id, cidr, subnet_name, "
            "tags, or zones."
        )
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    except BotoServerError as err:
        return {"error": __utils__["boto.get_error"](err)}
    filter_parameters = {"filters": {}}
    if subnet_id:
        filter_parameters["subnet_ids"] = [subnet_id]
    if subnet_name:
        filter_parameters["filters"]["tag:Name"] = subnet_name
    if cidr:
        filter_parameters["filters"]["cidr"] = cidr
    if tags:
        for tag_name, tag_value in tags.items():
            filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
    if zones:
        filter_parameters["filters"]["availability_zone"] = zones
    try:
        subnets = conn.get_all_subnets(**filter_parameters)
    except BotoServerError as err:
        boto_err = __utils__["boto.get_error"](err)
        if boto_err.get("aws", {}).get("code") == "InvalidSubnetID.NotFound":
            return {"exists": False}
        return {"error": boto_err}
    log.debug(
        "The filters criteria %s matched the following subnets:%s",
        filter_parameters,
        subnets,
    )
    if subnets:
        log.info("Subnet %s exists.", subnet_name or subnet_id)
        return {"exists": True}
    else:
        log.info("Subnet %s does not exist.", subnet_name or subnet_id)
        return {"exists": False}
def get_subnet_association(subnets, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        subnets = conn.get_all_subnets(subnet_ids=subnets)
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
    vpc_ids = set()
    for subnet in subnets:
        log.debug("examining subnet id: %s for vpc_id", subnet.id)
        if subnet in subnets:
            log.debug(
                "subnet id: %s is associated with vpc id: %s", subnet.id, subnet.vpc_id
            )
            vpc_ids.add(subnet.vpc_id)
    if not vpc_ids:
        return {"vpc_id": None}
    elif len(vpc_ids) == 1:
        return {"vpc_id": vpc_ids.pop()}
    else:
        return {"vpc_ids": list(vpc_ids)}
def describe_subnet(
    subnet_id=None, subnet_name=None, region=None, key=None, keyid=None, profile=None
):
    try:
        subnet = _get_resource(
            "subnet",
            name=subnet_name,
            resource_id=subnet_id,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
    if not subnet:
        return {"subnet": None}
    log.debug("Found subnet: %s", subnet.id)
    keys = ("id", "cidr_block", "availability_zone", "tags", "vpc_id")
    ret = {"subnet": {k: getattr(subnet, k) for k in keys}}
    explicit_route_table_assoc = _get_subnet_explicit_route_table(
        ret["subnet"]["id"],
        ret["subnet"]["vpc_id"],
        conn=None,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if explicit_route_table_assoc:
        ret["subnet"][
            "explicit_route_table_association_id"
        ] = explicit_route_table_assoc
    return ret
def describe_subnets(
    subnet_ids=None,
    subnet_names=None,
    vpc_id=None,
    cidr=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        filter_parameters = {"filters": {}}
        if vpc_id:
            filter_parameters["filters"]["vpcId"] = vpc_id
        if cidr:
            filter_parameters["filters"]["cidrBlock"] = cidr
        if subnet_names:
            filter_parameters["filters"]["tag:Name"] = subnet_names
        subnets = conn.get_all_subnets(subnet_ids=subnet_ids, **filter_parameters)
        log.debug(
            "The filters criteria %s matched the following subnets: %s",
            filter_parameters,
            subnets,
        )
        if not subnets:
            return {"subnets": None}
        subnets_list = []
        keys = ("id", "cidr_block", "availability_zone", "tags", "vpc_id")
        for item in subnets:
            subnet = {}
            for key in keys:
                if hasattr(item, key):
                    subnet[key] = getattr(item, key)
            explicit_route_table_assoc = _get_subnet_explicit_route_table(
                subnet["id"], subnet["vpc_id"], conn=conn
            )
            if explicit_route_table_assoc:
                subnet[
                    "explicit_route_table_association_id"
                ] = explicit_route_table_assoc
            subnets_list.append(subnet)
        return {"subnets": subnets_list}
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
def create_internet_gateway(
    internet_gateway_name=None,
    vpc_id=None,
    vpc_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        if vpc_id or vpc_name:
            vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
            if not vpc_id:
                return {
                    "created": False,
                    "error": {
                        "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
                    },
                }
        r = _create_resource(
            "internet_gateway",
            name=internet_gateway_name,
            tags=tags,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if r.get("created") and vpc_id:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            conn.attach_internet_gateway(r["id"], vpc_id)
            log.info(
                "Attached internet gateway %s to VPC %s", r["id"], vpc_name or vpc_id
            )
        return r
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
def delete_internet_gateway(
    internet_gateway_id=None,
    internet_gateway_name=None,
    detach=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        if internet_gateway_name:
            internet_gateway_id = _get_resource_id(
                "internet_gateway",
                internet_gateway_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        if not internet_gateway_id:
            return {
                "deleted": False,
                "error": {
                    "message": "internet gateway {} does not exist.".format(
                        internet_gateway_name
                    )
                },
            }
        if detach:
            igw = _get_resource(
                "internet_gateway",
                resource_id=internet_gateway_id,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not igw:
                return {
                    "deleted": False,
                    "error": {
                        "message": "internet gateway {} does not exist.".format(
                            internet_gateway_id
                        )
                    },
                }
            if igw.attachments:
                conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
                conn.detach_internet_gateway(
                    internet_gateway_id, igw.attachments[0].vpc_id
                )
        return _delete_resource(
            "internet_gateway",
            resource_id=internet_gateway_id,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    except BotoServerError as e:
<a name="0"></a>        return {"deleted": False, "error": __utils__["boto.get_error"](e)}
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def _find_nat_gateways(
    nat_gateway_id=None,
    subnet_id=None,
    subnet_name=None,
    vpc_id=None,
    vpc_name=None,
    states=("pending", "available"),
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not any(</b></font>(nat_gateway_id, subnet_id, subnet_name, vpc_id, vpc_name)):
        raise SaltInvocationError(
            "At least one of the following must be "
            "provided: nat_gateway_id, subnet_id, "
            "subnet_name, vpc_id, or vpc_name."
        )
    filter_parameters = {"Filter": []}
    if nat_gateway_id:
        filter_parameters["NatGatewayIds"] = [nat_gateway_id]
    if subnet_name:
        subnet_id = _get_resource_id(
            "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not subnet_id:
            return False
    if subnet_id:
        filter_parameters["Filter"].append({"Name": "subnet-id", "Values": [subnet_id]})
    if vpc_name:
        vpc_id = _get_resource_id(
            "vpc", vpc_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not vpc_id:
            return False
    if vpc_id:
        filter_parameters["Filter"].append({"Name": "vpc-id", "Values": [vpc_id]})
    conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
    nat_gateways = []
    for ret in __utils__["boto3.paged_call"](
        conn3.describe_nat_gateways,
        marker_flag="NextToken",
        marker_arg="NextToken",
        **filter_parameters
    ):
        for gw in ret.get("NatGateways", []):
            if gw.get("State") in states:
                nat_gateways.append(gw)
    log.debug(
        "The filters criteria %s matched the following nat gateways: %s",
        filter_parameters,
        nat_gateways,
    )
    if nat_gateways:
        return nat_gateways
    else:
        return False
def nat_gateway_exists(
    nat_gateway_id=None,
    subnet_id=None,
    subnet_name=None,
    vpc_id=None,
    vpc_name=None,
    states=("pending", "available"),
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    return bool(
        _find_nat_gateways(
            nat_gateway_id=nat_gateway_id,
            subnet_id=subnet_id,
            subnet_name=subnet_name,
            vpc_id=vpc_id,
            vpc_name=vpc_name,
            states=states,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    )
def describe_nat_gateways(
    nat_gateway_id=None,
    subnet_id=None,
    subnet_name=None,
    vpc_id=None,
    vpc_name=None,
    states=("pending", "available"),
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    return _find_nat_gateways(
        nat_gateway_id=nat_gateway_id,
        subnet_id=subnet_id,
        subnet_name=subnet_name,
        vpc_id=vpc_id,
        vpc_name=vpc_name,
        states=states,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def create_nat_gateway(
    subnet_id=None,
    subnet_name=None,
    allocation_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        if all((subnet_id, subnet_name)):
            raise SaltInvocationError(
                "Only one of subnet_name or subnet_id may be provided."
            )
        if subnet_name:
            subnet_id = _get_resource_id(
                "subnet",
                subnet_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not subnet_id:
                return {
                    "created": False,
                    "error": {
                        "message": "Subnet {} does not exist.".format(subnet_name)
                    },
                }
        else:
            if not _get_resource(
                "subnet",
                resource_id=subnet_id,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            ):
                return {
                    "created": False,
                    "error": {"message": "Subnet {} does not exist.".format(subnet_id)},
                }
        conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
        if not allocation_id:
            address = conn3.allocate_address(Domain="vpc")
            allocation_id = address.get("AllocationId")
        r = conn3.create_nat_gateway(SubnetId=subnet_id, AllocationId=allocation_id)
        return {"created": True, "id": r.get("NatGateway", {}).get("NatGatewayId")}
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
def delete_nat_gateway(
    nat_gateway_id,
    release_eips=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    wait_for_delete=False,
    wait_for_delete_retries=5,
):
    try:
        conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
        gwinfo = conn3.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])
        if gwinfo:
            gwinfo = gwinfo.get("NatGateways", [None])[0]
        conn3.delete_nat_gateway(NatGatewayId=nat_gateway_id)
        if wait_for_delete:
            for retry in range(wait_for_delete_retries, 0, -1):
                if gwinfo and gwinfo["State"] not in ["deleted", "failed"]:
                    time.sleep(
                        (2 ** (wait_for_delete_retries - retry))
                        + (random.randint(0, 1000) / 1000.0)
                    )
                    gwinfo = conn3.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])
                    if gwinfo:
                        gwinfo = gwinfo.get("NatGateways", [None])[0]
                        continue
                break
        if release_eips and gwinfo:
            for addr in gwinfo.get("NatGatewayAddresses"):
                conn3.release_address(AllocationId=addr.get("AllocationId"))
        return {"deleted": True}
    except BotoServerError as e:
        return {"deleted": False, "error": __utils__["boto.get_error"](e)}
def create_customer_gateway(
    vpn_connection_type,
    ip_address,
    bgp_asn,
    customer_gateway_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    return _create_resource(
        "customer_gateway",
        customer_gateway_name,
        type=vpn_connection_type,
        ip_address=ip_address,
        bgp_asn=bgp_asn,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def delete_customer_gateway(
    customer_gateway_id=None,
    customer_gateway_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    return _delete_resource(
        resource="customer_gateway",
        name=customer_gateway_name,
        resource_id=customer_gateway_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def customer_gateway_exists(
    customer_gateway_id=None,
    customer_gateway_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    return resource_exists(
        "customer_gateway",
        name=customer_gateway_name,
        resource_id=customer_gateway_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def create_dhcp_options(
    domain_name=None,
    domain_name_servers=None,
    ntp_servers=None,
    netbios_name_servers=None,
    netbios_node_type=None,
    dhcp_options_name=None,
    tags=None,
    vpc_id=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        if vpc_id or vpc_name:
            vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
            if not vpc_id:
                return {
                    "created": False,
                    "error": {
                        "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
                    },
                }
        r = _create_resource(
            "dhcp_options",
            name=dhcp_options_name,
            domain_name=domain_name,
            domain_name_servers=domain_name_servers,
            ntp_servers=ntp_servers,
            netbios_name_servers=netbios_name_servers,
            netbios_node_type=netbios_node_type,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if r.get("created") and vpc_id:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            conn.associate_dhcp_options(r["id"], vpc_id)
            log.info("Associated options %s to VPC %s", r["id"], vpc_name or vpc_id)
        return r
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
def get_dhcp_options(
    dhcp_options_name=None,
    dhcp_options_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not any((dhcp_options_name, dhcp_options_id)):
        raise SaltInvocationError(
            "At least one of the following must be specified: "
            "dhcp_options_name, dhcp_options_id."
        )
    if not dhcp_options_id and dhcp_options_name:
        dhcp_options_id = _get_resource_id(
            "dhcp_options",
            dhcp_options_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    if not dhcp_options_id:
        return {"dhcp_options": {}}
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        r = conn.get_all_dhcp_options(dhcp_options_ids=[dhcp_options_id])
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
    if not r:
        return {"dhcp_options": None}
    keys = (
        "domain_name",
        "domain_name_servers",
        "ntp_servers",
        "netbios_name_servers",
        "netbios_node_type",
    )
    return {"dhcp_options": {k: r[0].options.get(k) for k in keys}}
def delete_dhcp_options(
    dhcp_options_id=None,
    dhcp_options_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    return _delete_resource(
        resource="dhcp_options",
        name=dhcp_options_name,
        resource_id=dhcp_options_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def associate_dhcp_options_to_vpc(
    dhcp_options_id,
    vpc_id=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
        if not vpc_id:
            return {
                "associated": False,
                "error": {
                    "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
                },
            }
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if conn.associate_dhcp_options(dhcp_options_id, vpc_id):
            log.info(
                "DHCP options with id %s were associated with VPC %s",
                dhcp_options_id,
                vpc_id,
            )
            return {"associated": True}
        else:
            log.warning(
                "DHCP options with id %s were not associated with VPC %s",
                dhcp_options_id,
                vpc_id,
            )
            return {
                "associated": False,
                "error": {"message": "DHCP options could not be associated."},
            }
    except BotoServerError as e:
        return {"associated": False, "error": __utils__["boto.get_error"](e)}
def dhcp_options_exists(
    dhcp_options_id=None,
    name=None,
    dhcp_options_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if name:
        log.warning(
            "boto_vpc.dhcp_options_exists: name parameter is deprecated "
            "use dhcp_options_name instead."
        )
        dhcp_options_name = name
    return resource_exists(
        "dhcp_options",
        name=dhcp_options_name,
        resource_id=dhcp_options_id,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def create_network_acl(
    vpc_id=None,
    vpc_name=None,
    network_acl_name=None,
    subnet_id=None,
    subnet_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    _id = vpc_name or vpc_id
    try:
        vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
    if not vpc_id:
        return {
            "created": False,
            "error": {"message": "VPC {} does not exist.".format(_id)},
        }
    if all((subnet_id, subnet_name)):
        raise SaltInvocationError(
            "Only one of subnet_name or subnet_id may be provided."
        )
    if subnet_name:
        subnet_id = _get_resource_id(
            "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not subnet_id:
            return {
                "created": False,
                "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
            }
    elif subnet_id:
        if not _get_resource(
            "subnet",
            resource_id=subnet_id,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ):
            return {
                "created": False,
                "error": {"message": "Subnet {} does not exist.".format(subnet_id)},
            }
    r = _create_resource(
        "network_acl",
        name=network_acl_name,
        vpc_id=vpc_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
    if r.get("created") and subnet_id:
        try:
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            association_id = conn.associate_network_acl(r["id"], subnet_id)
        except BotoServerError as e:
            return {"created": False, "error": __utils__["boto.get_error"](e)}
        r["association_id"] = association_id
    return r
def delete_network_acl(
    network_acl_id=None,
    network_acl_name=None,
    disassociate=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if disassociate:
        network_acl = _get_resource(
            "network_acl",
            name=network_acl_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if network_acl and network_acl.associations:
            subnet_id = network_acl.associations[0].subnet_id
            try:
                conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
                conn.disassociate_network_acl(subnet_id)
            except BotoServerError:
                pass
    return _delete_resource(
        resource="network_acl",
        name=network_acl_name,
        resource_id=network_acl_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def network_acl_exists(
    network_acl_id=None,
    name=None,
    network_acl_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if name:
        log.warning(
            "boto_vpc.network_acl_exists: name parameter is deprecated "
            "use network_acl_name instead."
        )
        network_acl_name = name
    return resource_exists(
        "network_acl",
        name=network_acl_name,
        resource_id=network_acl_id,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def associate_network_acl_to_subnet(
    network_acl_id=None,
    subnet_id=None,
    network_acl_name=None,
    subnet_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if network_acl_name:
        network_acl_id = _get_resource_id(
            "network_acl",
            network_acl_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not network_acl_id:
            return {
                "associated": False,
                "error": {
                    "message": "Network ACL {} does not exist.".format(network_acl_name)
                },
            }
    if subnet_name:
        subnet_id = _get_resource_id(
            "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not subnet_id:
            return {
                "associated": False,
                "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
            }
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        association_id = conn.associate_network_acl(network_acl_id, subnet_id)
        if association_id:
            log.info(
                "Network ACL with id %s was associated with subnet %s",
                network_acl_id,
                subnet_id,
            )
            return {"associated": True, "id": association_id}
        else:
            log.warning(
                "Network ACL with id %s was not associated with subnet %s",
                network_acl_id,
                subnet_id,
            )
            return {
                "associated": False,
                "error": {"message": "ACL could not be assocaited."},
            }
    except BotoServerError as e:
        return {"associated": False, "error": __utils__["boto.get_error"](e)}
def disassociate_network_acl(
    subnet_id=None,
    vpc_id=None,
    subnet_name=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((subnet_name, subnet_id)):
        raise SaltInvocationError(
            "One (but not both) of subnet_id or subnet_name must be provided."
        )
    if all((vpc_name, vpc_id)):
        raise SaltInvocationError("Only one of vpc_id or vpc_name may be provided.")
    try:
        if subnet_name:
            subnet_id = _get_resource_id(
                "subnet",
                subnet_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not subnet_id:
                return {
                    "disassociated": False,
                    "error": {
                        "message": "Subnet {} does not exist.".format(subnet_name)
                    },
                }
        if vpc_name or vpc_id:
            vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        association_id = conn.disassociate_network_acl(subnet_id, vpc_id=vpc_id)
        return {"disassociated": True, "association_id": association_id}
    except BotoServerError as e:
        return {"disassociated": False, "error": __utils__["boto.get_error"](e)}
def _create_network_acl_entry(
    network_acl_id=None,
    rule_number=None,
    protocol=None,
    rule_action=None,
    cidr_block=None,
    egress=None,
    network_acl_name=None,
    icmp_code=None,
    icmp_type=None,
    port_range_from=None,
    port_range_to=None,
    replace=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if replace:
        rkey = "replaced"
    else:
        rkey = "created"
    if not _exactly_one((network_acl_name, network_acl_id)):
        raise SaltInvocationError(
            "One (but not both) of network_acl_id or network_acl_name must be provided."
        )
    for v in ("rule_number", "protocol", "rule_action", "cidr_block"):
        if locals()[v] is None:
            raise SaltInvocationError("{} is required.".format(v))
    if network_acl_name:
        network_acl_id = _get_resource_id(
            "network_acl",
            network_acl_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    if not network_acl_id:
        return {
            rkey: False,
            "error": {
                "message": "Network ACL {} does not exist.".format(
                    network_acl_name or network_acl_id
                )
            },
        }
    if isinstance(protocol, str):
        if protocol == "all":
            protocol = -1
        else:
            try:
                protocol = socket.getprotobyname(protocol)
            except OSError as e:
                raise SaltInvocationError(e)
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if replace:
            f = conn.replace_network_acl_entry
        else:
            f = conn.create_network_acl_entry
        created = f(
            network_acl_id,
            rule_number,
            protocol,
            rule_action,
            cidr_block,
            egress=egress,
            icmp_code=icmp_code,
            icmp_type=icmp_type,
            port_range_from=port_range_from,
            port_range_to=port_range_to,
        )
        if created:
            log.info("Network ACL entry was %s", rkey)
        else:
            log.warning("Network ACL entry was not %s", rkey)
        return {rkey: created}
    except BotoServerError as e:
        return {rkey: False, "error": __utils__["boto.get_error"](e)}
def create_network_acl_entry(
    network_acl_id=None,
    rule_number=None,
    protocol=None,
    rule_action=None,
    cidr_block=None,
    egress=None,
    network_acl_name=None,
    icmp_code=None,
    icmp_type=None,
    port_range_from=None,
    port_range_to=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    kwargs = locals()
    return _create_network_acl_entry(**kwargs)
def replace_network_acl_entry(
    network_acl_id=None,
    rule_number=None,
    protocol=None,
    rule_action=None,
    cidr_block=None,
    egress=None,
    network_acl_name=None,
    icmp_code=None,
    icmp_type=None,
    port_range_from=None,
    port_range_to=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    kwargs = locals()
    return _create_network_acl_entry(replace=True, **kwargs)
def delete_network_acl_entry(
    network_acl_id=None,
    rule_number=None,
    egress=None,
    network_acl_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((network_acl_name, network_acl_id)):
        raise SaltInvocationError(
            "One (but not both) of network_acl_id or network_acl_name must be provided."
        )
    for v in ("rule_number", "egress"):
        if locals()[v] is None:
            raise SaltInvocationError("{} is required.".format(v))
    if network_acl_name:
        network_acl_id = _get_resource_id(
            "network_acl",
            network_acl_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    if not network_acl_id:
        return {
            "deleted": False,
            "error": {
                "message": "Network ACL {} does not exist.".format(
                    network_acl_name or network_acl_id
                )
            },
        }
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        deleted = conn.delete_network_acl_entry(
            network_acl_id, rule_number, egress=egress
        )
        if deleted:
            log.info("Network ACL entry was deleted")
        else:
            log.warning("Network ACL was not deleted")
        return {"deleted": deleted}
    except BotoServerError as e:
        return {"deleted": False, "error": __utils__["boto.get_error"](e)}
def create_route_table(
    vpc_id=None,
    vpc_name=None,
    route_table_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
    if not vpc_id:
        return {
            "created": False,
            "error": {"message": "VPC {} does not exist.".format(vpc_name or vpc_id)},
        }
    return _create_resource(
        "route_table",
        route_table_name,
        tags=tags,
        vpc_id=vpc_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def delete_route_table(
    route_table_id=None,
    route_table_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    return _delete_resource(
        resource="route_table",
        name=route_table_name,
        resource_id=route_table_id,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def route_table_exists(
    route_table_id=None,
    name=None,
    route_table_name=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if name:
        log.warning(
            "boto_vpc.route_table_exists: name parameter is deprecated "
            "use route_table_name instead."
        )
        route_table_name = name
    return resource_exists(
        "route_table",
        name=route_table_name,
        resource_id=route_table_id,
        tags=tags,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def route_exists(
    destination_cidr_block,
    route_table_name=None,
    route_table_id=None,
    gateway_id=None,
    instance_id=None,
    interface_id=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_peering_connection_id=None,
):
    if not any((route_table_name, route_table_id)):
        raise SaltInvocationError(
            "At least one of the following must be specified: route table name or route"
            " table id."
        )
    if not any((gateway_id, instance_id, interface_id, vpc_peering_connection_id)):
        raise SaltInvocationError(
            "At least one of the following must be specified: gateway id, instance id, "
            "interface id or VPC peering connection id."
        )
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        filter_parameters = {"filters": {}}
        if route_table_id:
            filter_parameters["route_table_ids"] = [route_table_id]
        if route_table_name:
            filter_parameters["filters"]["tag:Name"] = route_table_name
        if tags:
            for tag_name, tag_value in tags.items():
                filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
        route_tables = conn.get_all_route_tables(**filter_parameters)
        if len(route_tables) != 1:
            raise SaltInvocationError("Found more than one route table.")
        route_check = {
            "destination_cidr_block": destination_cidr_block,
            "gateway_id": gateway_id,
            "instance_id": instance_id,
            "interface_id": interface_id,
            "vpc_peering_connection_id": vpc_peering_connection_id,
        }
        for route_match in route_tables[0].routes:
            route_dict = {
                "destination_cidr_block": route_match.destination_cidr_block,
                "gateway_id": route_match.gateway_id,
                "instance_id": route_match.instance_id,
                "interface_id": route_match.interface_id,
                "vpc_peering_connection_id": vpc_peering_connection_id,
            }
            route_comp = set(route_dict.items()) ^ set(route_check.items())
            if not route_comp:
                log.info("Route %s exists.", destination_cidr_block)
                return {"exists": True}
        log.warning("Route %s does not exist.", destination_cidr_block)
        return {"exists": False}
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
def associate_route_table(
    route_table_id=None,
    subnet_id=None,
    route_table_name=None,
    subnet_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if all((subnet_id, subnet_name)):
        raise SaltInvocationError(
            "Only one of subnet_name or subnet_id may be provided."
        )
    if subnet_name:
        subnet_id = _get_resource_id(
            "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not subnet_id:
            return {
                "associated": False,
                "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
            }
    if all((route_table_id, route_table_name)):
        raise SaltInvocationError(
            "Only one of route_table_name or route_table_id may be provided."
        )
    if route_table_name:
        route_table_id = _get_resource_id(
            "route_table",
            route_table_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not route_table_id:
            return {
                "associated": False,
                "error": {
                    "message": "Route table {} does not exist.".format(route_table_name)
                },
            }
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        association_id = conn.associate_route_table(route_table_id, subnet_id)
        log.info(
            "Route table %s was associated with subnet %s", route_table_id, subnet_id
        )
        return {"association_id": association_id}
    except BotoServerError as e:
        return {"associated": False, "error": __utils__["boto.get_error"](e)}
def disassociate_route_table(
    association_id, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if conn.disassociate_route_table(association_id):
            log.info(
                "Route table with association id %s has been disassociated.",
                association_id,
            )
            return {"disassociated": True}
        else:
            log.warning(
                "Route table with association id %s has not been disassociated.",
                association_id,
            )
            return {"disassociated": False}
    except BotoServerError as e:
        return {"disassociated": False, "error": __utils__["boto.get_error"](e)}
def replace_route_table_association(
    association_id, route_table_id, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        association_id = conn.replace_route_table_association_with_assoc(
            association_id, route_table_id
        )
        log.info(
            "Route table %s was reassociated with association id %s",
            route_table_id,
            association_id,
        )
        return {"replaced": True, "association_id": association_id}
    except BotoServerError as e:
        return {"replaced": False, "error": __utils__["boto.get_error"](e)}
def create_route(
    route_table_id=None,
    destination_cidr_block=None,
    route_table_name=None,
    gateway_id=None,
    internet_gateway_name=None,
    instance_id=None,
    interface_id=None,
    vpc_peering_connection_id=None,
    vpc_peering_connection_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    nat_gateway_id=None,
    nat_gateway_subnet_name=None,
    nat_gateway_subnet_id=None,
):
    if not _exactly_one((route_table_name, route_table_id)):
        raise SaltInvocationError(
            "One (but not both) of route_table_id or route_table_name must be provided."
        )
    if not _exactly_one(
        (
            gateway_id,
            internet_gateway_name,
            instance_id,
            interface_id,
            vpc_peering_connection_id,
            nat_gateway_id,
            nat_gateway_subnet_id,
            nat_gateway_subnet_name,
            vpc_peering_connection_name,
        )
    ):
        raise SaltInvocationError(
            "Only one of gateway_id, internet_gateway_name, instance_id, interface_id,"
            " vpc_peering_connection_id, nat_gateway_id, nat_gateway_subnet_id,"
            " nat_gateway_subnet_name or vpc_peering_connection_name may be provided."
        )
    if destination_cidr_block is None:
        raise SaltInvocationError("destination_cidr_block is required.")
    try:
        if route_table_name:
            route_table_id = _get_resource_id(
                "route_table",
                route_table_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not route_table_id:
                return {
                    "created": False,
                    "error": {
                        "message": "route table {} does not exist.".format(
                            route_table_name
                        )
                    },
                }
        if internet_gateway_name:
            gateway_id = _get_resource_id(
                "internet_gateway",
                internet_gateway_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not gateway_id:
                return {
                    "created": False,
                    "error": {
                        "message": "internet gateway {} does not exist.".format(
                            internet_gateway_name
                        )
                    },
                }
        if vpc_peering_connection_name:
            vpc_peering_connection_id = _get_resource_id(
                "vpc_peering_connection",
                vpc_peering_connection_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not vpc_peering_connection_id:
                return {
                    "created": False,
                    "error": {
                        "message": "VPC peering connection {} does not exist.".format(
                            vpc_peering_connection_name
                        )
                    },
                }
        if nat_gateway_subnet_name:
            gws = describe_nat_gateways(
                subnet_name=nat_gateway_subnet_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not gws:
                return {
                    "created": False,
                    "error": {
                        "message": "nat gateway for {} does not exist.".format(
                            nat_gateway_subnet_name
                        )
                    },
                }
            nat_gateway_id = gws[0]["NatGatewayId"]
        if nat_gateway_subnet_id:
            gws = describe_nat_gateways(
                subnet_id=nat_gateway_subnet_id,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not gws:
                return {
                    "created": False,
                    "error": {
                        "message": "nat gateway for {} does not exist.".format(
                            nat_gateway_subnet_id
                        )
                    },
                }
            nat_gateway_id = gws[0]["NatGatewayId"]
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
    if not nat_gateway_id:
        return _create_resource(
            "route",
            route_table_id=route_table_id,
            destination_cidr_block=destination_cidr_block,
            gateway_id=gateway_id,
            instance_id=instance_id,
            interface_id=interface_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
    try:
        conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
        ret = conn3.create_route(
            RouteTableId=route_table_id,
            DestinationCidrBlock=destination_cidr_block,
            NatGatewayId=nat_gateway_id,
        )
        return {"created": True, "id": ret.get("NatGatewayId")}
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
def delete_route(
    route_table_id=None,
    destination_cidr_block=None,
    route_table_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((route_table_name, route_table_id)):
        raise SaltInvocationError(
            "One (but not both) of route_table_id or route_table_name must be provided."
        )
    if destination_cidr_block is None:
        raise SaltInvocationError("destination_cidr_block is required.")
    try:
        if route_table_name:
            route_table_id = _get_resource_id(
                "route_table",
                route_table_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not route_table_id:
                return {
                    "created": False,
                    "error": {
                        "message": "route table {} does not exist.".format(
                            route_table_name
                        )
                    },
                }
    except BotoServerError as e:
        return {"created": False, "error": __utils__["boto.get_error"](e)}
    return _delete_resource(
        resource="route",
        resource_id=route_table_id,
        destination_cidr_block=destination_cidr_block,
        region=region,
        key=key,
        keyid=keyid,
        profile=profile,
    )
def replace_route(
    route_table_id=None,
    destination_cidr_block=None,
    route_table_name=None,
    gateway_id=None,
    instance_id=None,
    interface_id=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    vpc_peering_connection_id=None,
):
    if not _exactly_one((route_table_name, route_table_id)):
        raise SaltInvocationError(
            "One (but not both) of route_table_id or route_table_name must be provided."
        )
    if destination_cidr_block is None:
        raise SaltInvocationError("destination_cidr_block is required.")
    try:
        if route_table_name:
            route_table_id = _get_resource_id(
                "route_table",
                route_table_name,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
            if not route_table_id:
                return {
                    "replaced": False,
                    "error": {
                        "message": "route table {} does not exist.".format(
                            route_table_name
                        )
                    },
                }
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if conn.replace_route(
            route_table_id,
            destination_cidr_block,
            gateway_id=gateway_id,
            instance_id=instance_id,
            interface_id=interface_id,
            vpc_peering_connection_id=vpc_peering_connection_id,
        ):
            log.info(
                "Route with cidr block %s on route table %s was replaced",
                route_table_id,
                destination_cidr_block,
            )
            return {"replaced": True}
        else:
            log.warning(
                "Route with cidr block %s on route table %s was not replaced",
                route_table_id,
                destination_cidr_block,
            )
            return {"replaced": False}
    except BotoServerError as e:
        return {"replaced": False, "error": __utils__["boto.get_error"](e)}
def describe_route_tables(
    route_table_id=None,
    route_table_name=None,
    vpc_id=None,
    tags=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not any((route_table_id, route_table_name, tags, vpc_id)):
        raise SaltInvocationError(
            "At least one of the following must be specified: "
            "route table id, route table name, vpc_id, or tags."
        )
    try:
        conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
        filter_parameters = {"Filters": []}
        if route_table_id:
            filter_parameters["RouteTableIds"] = [route_table_id]
        if vpc_id:
            filter_parameters["Filters"].append({"Name": "vpc-id", "Values": [vpc_id]})
        if route_table_name:
            filter_parameters["Filters"].append(
                {"Name": "tag:Name", "Values": [route_table_name]}
            )
        if tags:
            for tag_name, tag_value in tags.items():
                filter_parameters["Filters"].append(
                    {"Name": "tag:{}".format(tag_name), "Values": [tag_value]}
                )
        route_tables = conn3.describe_route_tables(**filter_parameters).get(
            "RouteTables", []
        )
        if not route_tables:
            return []
        tables = []
        keys = {
            "id": "RouteTableId",
            "vpc_id": "VpcId",
            "tags": "Tags",
            "routes": "Routes",
            "associations": "Associations",
        }
        route_keys = {
            "destination_cidr_block": "DestinationCidrBlock",
            "gateway_id": "GatewayId",
            "instance_id": "Instance",
            "interface_id": "NetworkInterfaceId",
            "nat_gateway_id": "NatGatewayId",
            "vpc_peering_connection_id": "VpcPeeringConnectionId",
        }
        assoc_keys = {
            "id": "RouteTableAssociationId",
            "main": "Main",
            "route_table_id": "RouteTableId",
            "SubnetId": "subnet_id",
        }
        for item in route_tables:
            route_table = {}
            for outkey, inkey in keys.items():
                if inkey in item:
                    if outkey == "routes":
                        route_table[outkey] = _key_remap(inkey, route_keys, item)
                    elif outkey == "associations":
                        route_table[outkey] = _key_remap(inkey, assoc_keys, item)
                    elif outkey == "tags":
                        route_table[outkey] = {}
                        for tagitem in item.get(inkey, []):
                            route_table[outkey][tagitem.get("Key")] = tagitem.get(
                                "Value"
                            )
                    else:
                        route_table[outkey] = item.get(inkey)
            tables.append(route_table)
        return tables
    except BotoServerError as e:
        return {"error": __utils__["boto.get_error"](e)}
def _create_dhcp_options(
    conn,
    domain_name=None,
    domain_name_servers=None,
    ntp_servers=None,
    netbios_name_servers=None,
    netbios_node_type=None,
):
    return conn.create_dhcp_options(
        domain_name=domain_name,
        domain_name_servers=domain_name_servers,
        ntp_servers=ntp_servers,
        netbios_name_servers=netbios_name_servers,
        netbios_node_type=netbios_node_type,
    )
def _maybe_set_name_tag(name, obj):
    if name:
        obj.add_tag("Name", name)
        log.debug("%s is now named as %s", obj, name)
def _maybe_set_tags(tags, obj):
    if tags:
        try:
            obj.add_tags(tags)
        except AttributeError:
            for tag, value in tags.items():
                obj.add_tag(tag, value)
        log.debug("The following tags: %s were added to %s", ", ".join(tags), obj)
def _maybe_set_dns(conn, vpcid, dns_support, dns_hostnames):
    if dns_support:
        conn.modify_vpc_attribute(vpc_id=vpcid, enable_dns_support=dns_support)
        log.debug("DNS support was set to: %s on vpc %s", dns_support, vpcid)
    if dns_hostnames:
        conn.modify_vpc_attribute(vpc_id=vpcid, enable_dns_hostnames=dns_hostnames)
        log.debug("DNS hostnames was set to: %s on vpc %s", dns_hostnames, vpcid)
def _maybe_name_route_table(conn, vpcid, vpc_name):
    route_tables = conn.get_all_route_tables(filters={"vpc_id": vpcid})
    if not route_tables:
        log.warning("no default route table found")
        return
    default_table = None
    for table in route_tables:
        for association in getattr(table, "associations", {}):
            if getattr(association, "main", False):
                default_table = table
                break
    if not default_table:
        log.warning("no default route table found")
        return
    name = "{}-default-table".format(vpc_name)
    _maybe_set_name_tag(name, default_table)
    log.debug("Default route table name was set to: %s on vpc %s", name, vpcid)
def _key_iter(key, keys, item):
    elements_list = []
    for r_item in getattr(item, key):
        element = {}
        for r_key in keys:
            if hasattr(r_item, r_key):
                element[r_key] = getattr(r_item, r_key)
        elements_list.append(element)
    return elements_list
def _key_remap(key, keys, item):
    elements_list = []
    for r_item in item.get(key, []):
        element = {}
        for r_outkey, r_inkey in keys.items():
            if r_inkey in r_item:
                element[r_outkey] = r_item.get(r_inkey)
        elements_list.append(element)
    return elements_list
def _get_subnet_explicit_route_table(
    subnet_id, vpc_id, conn=None, region=None, key=None, keyid=None, profile=None
):
    if not conn:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    if conn:
        vpc_route_tables = conn.get_all_route_tables(filters={"vpc_id": vpc_id})
        for vpc_route_table in vpc_route_tables:
            for rt_association in vpc_route_table.associations:
                if rt_association.subnet_id == subnet_id and not rt_association.main:
                    return rt_association.id
    return None
def request_vpc_peering_connection(
    requester_vpc_id=None,
    requester_vpc_name=None,
    peer_vpc_id=None,
    peer_vpc_name=None,
    name=None,
    peer_owner_id=None,
    peer_region=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    dry_run=False,
):
    conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
    if name and _vpc_peering_conn_id_for_name(name, conn):
        raise SaltInvocationError(
            "A VPC peering connection with this name already "
            "exists! Please specify a different name."
        )
    if not _exactly_one((requester_vpc_id, requester_vpc_name)):
        raise SaltInvocationError(
            "Exactly one of requester_vpc_id or requester_vpc_name is required"
        )
    if not _exactly_one((peer_vpc_id, peer_vpc_name)):
        raise SaltInvocationError(
            "Exactly one of peer_vpc_id or peer_vpc_name is required."
        )
    if requester_vpc_name:
        requester_vpc_id = _get_id(
            vpc_name=requester_vpc_name,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not requester_vpc_id:
            return {
                "error": "Could not resolve VPC name {} to an ID".format(
                    requester_vpc_name
                )
            }
    if peer_vpc_name:
        peer_vpc_id = _get_id(
            vpc_name=peer_vpc_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not peer_vpc_id:
            return {
                "error": "Could not resolve VPC name {} to an ID".format(peer_vpc_name)
            }
    peering_params = {
        "VpcId": requester_vpc_id,
        "PeerVpcId": peer_vpc_id,
        "DryRun": dry_run,
    }
    if peer_owner_id:
        peering_params.update({"PeerOwnerId": peer_owner_id})
    if peer_region:
        peering_params.update({"PeerRegion": peer_region})
    try:
        log.debug("Trying to request vpc peering connection")
        if not peer_owner_id:
            vpc_peering = conn.create_vpc_peering_connection(**peering_params)
        else:
            vpc_peering = conn.create_vpc_peering_connection(**peering_params)
        peering = vpc_peering.get("VpcPeeringConnection", {})
        peering_conn_id = peering.get("VpcPeeringConnectionId", "ERROR")
        msg = "VPC peering {} requested.".format(peering_conn_id)
        log.debug(msg)
        if name:
            log.debug("Adding name tag to vpc peering connection")
            conn.create_tags(
                Resources=[peering_conn_id], Tags=[{"Key": "Name", "Value": name}]
            )
            log.debug("Applied name tag to vpc peering connection")
            msg += " With name {}.".format(name)
        return {"msg": msg}
    except botocore.exceptions.ClientError as err:
        log.error("Got an error while trying to request vpc peering")
        return {"error": __utils__["boto.get_error"](err)}
def _get_peering_connection_ids(name, conn):
    filters = [
        {"Name": "tag:Name", "Values": [name]},
        {"Name": "status-code", "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING]},
    ]
    peerings = conn.describe_vpc_peering_connections(Filters=filters).get(
        "VpcPeeringConnections", []
    )
    return [x["VpcPeeringConnectionId"] for x in peerings]
def describe_vpc_peering_connection(
    name, region=None, key=None, keyid=None, profile=None
):
    conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
    return {"VPC-Peerings": _get_peering_connection_ids(name, conn)}
def accept_vpc_peering_connection(  # pylint: disable=too-many-arguments
    conn_id="", name="", region=None, key=None, keyid=None, profile=None, dry_run=False
):
    if not _exactly_one((conn_id, name)):
        raise SaltInvocationError(
            "One (but not both) of vpc_peering_connection_id or name must be provided."
        )
    conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
    if name:
        conn_id = _vpc_peering_conn_id_for_name(name, conn)
        if not conn_id:
            raise SaltInvocationError(
                "No ID found for this "
                "VPC peering connection! ({}) "
                "Please make sure this VPC peering "
                "connection exists "
                "or invoke this function with "
                "a VPC peering connection "
                "ID".format(name)
            )
    try:
        log.debug("Trying to accept vpc peering connection")
        conn.accept_vpc_peering_connection(
            DryRun=dry_run, VpcPeeringConnectionId=conn_id
        )
        return {"msg": "VPC peering connection accepted."}
    except botocore.exceptions.ClientError as err:
        log.error("Got an error while trying to accept vpc peering")
        return {"error": __utils__["boto.get_error"](err)}
def _vpc_peering_conn_id_for_name(name, conn):
    log.debug("Retrieving VPC peering connection id")
    ids = _get_peering_connection_ids(name, conn)
    if not ids:
        ids = [None]  # Let callers handle the case where we have no id
    elif len(ids) &gt; 1:
        raise SaltInvocationError(
            "Found multiple VPC peering connections "
            "with the same name!! "
            "Please make sure you have only "
            "one VPC peering connection named {} "
            "or invoke this function with a VPC "
            "peering connection ID".format(name)
        )
    return ids[0]
def delete_vpc_peering_connection(
    conn_id=None,
    conn_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
    dry_run=False,
):
    if not _exactly_one((conn_id, conn_name)):
        raise SaltInvocationError(
            "Exactly one of conn_id or conn_name must be provided."
        )
    conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
    if conn_name:
        conn_id = _vpc_peering_conn_id_for_name(conn_name, conn)
        if not conn_id:
            raise SaltInvocationError(
                "Couldn't resolve VPC peering connection {} to an ID".format(conn_name)
            )
    try:
        log.debug("Trying to delete vpc peering connection")
        conn.delete_vpc_peering_connection(
            DryRun=dry_run, VpcPeeringConnectionId=conn_id
        )
        return {"msg": "VPC peering connection deleted."}
    except botocore.exceptions.ClientError as err:
        e = __utils__["boto.get_error"](err)
        log.error("Failed to delete VPC peering %s: %s", conn_name or conn_id, e)
        return {"error": e}
def is_peering_connection_pending(
    conn_id=None, conn_name=None, region=None, key=None, keyid=None, profile=None
):
    if not _exactly_one((conn_id, conn_name)):
        raise SaltInvocationError(
            "Exactly one of conn_id or conn_name must be provided."
        )
    conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
    if conn_id:
        vpcs = conn.describe_vpc_peering_connections(
            VpcPeeringConnectionIds=[conn_id]
        ).get("VpcPeeringConnections", [])
    else:
        filters = [
            {"Name": "tag:Name", "Values": [conn_name]},
            {
                "Name": "status-code",
                "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING],
            },
        ]
        vpcs = conn.describe_vpc_peering_connections(Filters=filters).get(
            "VpcPeeringConnections", []
        )
    if not vpcs:
        return False
    elif len(vpcs) &gt; 1:
        raise SaltInvocationError(
            "Found more than one ID for the VPC peering "
            "connection ({}). Please call this function "
            "with an ID instead.".format(conn_id or conn_name)
        )
    else:
        status = vpcs[0]["Status"]["Code"]
    return status == PENDING_ACCEPTANCE
def peering_connection_pending_from_vpc(
    conn_id=None,
    conn_name=None,
    vpc_id=None,
    vpc_name=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((conn_id, conn_name)):
        raise SaltInvocationError(
            "Exactly one of conn_id or conn_name must be provided."
        )
    if not _exactly_one((vpc_id, vpc_name)):
        raise SaltInvocationError("Exactly one of vpc_id or vpc_name must be provided.")
    if vpc_name:
        vpc_id = check_vpc(
            vpc_name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
        )
        if not vpc_id:
            log.warning("Could not resolve VPC name %s to an ID", vpc_name)
            return False
    conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
    filters = [
        {"Name": "requester-vpc-info.vpc-id", "Values": [vpc_id]},
        {"Name": "status-code", "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING]},
    ]
    if conn_id:
        filters += [{"Name": "vpc-peering-connection-id", "Values": [conn_id]}]
    else:
        filters += [{"Name": "tag:Name", "Values": [conn_name]}]
    vpcs = conn.describe_vpc_peering_connections(Filters=filters).get(
        "VpcPeeringConnections", []
    )
    if not vpcs:
        return False
    elif len(vpcs) &gt; 1:
        raise SaltInvocationError(
            "Found more than one ID for the VPC peering "
            "connection ({}). Please call this function "
            "with an ID instead.".format(conn_id or conn_name)
        )
    else:
        status = vpcs[0]["Status"]["Code"]
    return bool(status == PENDING_ACCEPTANCE)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
