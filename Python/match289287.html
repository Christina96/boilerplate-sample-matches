<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for grafana_dashboard.py &amp; boto_vpc_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for grafana_dashboard.py &amp; boto_vpc_1.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>grafana_dashboard.py (1.897019%)<th>boto_vpc_1.py (0.3711559%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-99)<td><a href="#" name="0">(1572-1588)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>grafana_dashboard.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import requests
3 import salt.utils.json
4 from salt.utils.dictdiffer import DictDiffer
5 def __virtual__():
6     if __salt__["config.get"]("grafana_version", 1) == 2:
7         return True
8     return (False, "Not configured for grafana_version 2")
9 _DEFAULT_DASHBOARD_PILLAR = "grafana_dashboards:default"
10 _DEFAULT_PANEL_PILLAR = "grafana_panels:default"
11 _DEFAULT_ROW_PILLAR = "grafana_rows:default"
12 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def present(
13     name,
14     base_dashboards_from_pillar=None,
15     base_panels_from_pillar=None,
16     base_rows_from_pillar=None,
17     dashboard=None,
18     profile="grafana",
19 ):
20     ret = {"name": name, "result": True, "comment": "", "changes": {}}
21     base_dashboards_from_pillar = base_dashboards_from_pillar or []
22     base_panels_from_pillar = base_panels_from_pillar or []
23     base_rows_from_pillar = base_rows_from_pillar or []
24     dashboard = dashboard or {}
25     if isinstance(</b></font>profile, str):
26         profile = __salt__["config.option"](profile)
27     base_dashboards_from_pillar = [
28         _DEFAULT_DASHBOARD_PILLAR
29     ] + base_dashboards_from_pillar
30     base_panels_from_pillar = [_DEFAULT_PANEL_PILLAR] + base_panels_from_pillar
31     base_rows_from_pillar = [_DEFAULT_ROW_PILLAR] + base_rows_from_pillar
32     new_dashboard = _inherited_dashboard(dashboard, base_dashboards_from_pillar, ret)
33     new_dashboard["title"] = name
34     rows = new_dashboard.get("rows", [])
35     for i, row in enumerate(rows):
36         rows[i] = _inherited_row(row, base_rows_from_pillar, ret)
37     for row in rows:
38         panels = row.get("panels", [])
39         for i, panel in enumerate(panels):
40             panels[i] = _inherited_panel(panel, base_panels_from_pillar, ret)
41     _auto_adjust_panel_spans(new_dashboard)
42     _ensure_panel_ids(new_dashboard)
43     _ensure_annotations(new_dashboard)
44     url = "db/{}".format(name)
45     old_dashboard = _get(url, profile)
46     if not old_dashboard:
47         if __opts__["test"]:
48             ret["result"] = None
49             ret["comment"] = "Dashboard {} is set to be created.".format(name)
50             return ret
51         response = _update(new_dashboard, profile)
52         if response.get("status") == "success":
53             ret["comment"] = "Dashboard {} created.".format(name)
54             ret["changes"]["new"] = "Dashboard {} created.".format(name)
55         else:
56             ret["result"] = False
57             ret["comment"] = "Failed to create dashboard {}, response={}".format(
58                 name, response
59             )
60         return ret
61     managed_row_titles = [row.get("title") for row in new_dashboard.get("rows", [])]
62     new_rows = new_dashboard.get("rows", [])
63     for old_row in old_dashboard.get("rows", []):
64         if old_row.get("title") not in managed_row_titles:
65             new_rows.append(copy.deepcopy(old_row))
66     _ensure_pinned_rows(new_dashboard)
67     _ensure_panel_ids(new_dashboard)
68     dashboard_diff = DictDiffer(_cleaned(new_dashboard), _cleaned(old_dashboard))
69     updated_needed = (
70         dashboard_diff.changed() or dashboard_diff.added() or dashboard_diff.removed()
71     )
72     if updated_needed:
73         if __opts__["test"]:
74             ret["result"] = None
75             ret["comment"] = "Dashboard {} is set to be updated, changes={}".format(
76                 name,
77                 salt.utils.json.dumps(
78                     _dashboard_diff(_cleaned(new_dashboard), _cleaned(old_dashboard)),
79                     indent=4,
80                 ),
81             )
82             return ret
83         response = _update(new_dashboard, profile)
84         if response.get("status") == "success":
85             updated_dashboard = _get(url, profile)
86             dashboard_diff = DictDiffer(
87                 _cleaned(updated_dashboard), _cleaned(old_dashboard)
88             )
89             ret["comment"] = "Dashboard {} updated.".format(name)
90             ret["changes"] = _dashboard_diff(
91                 _cleaned(new_dashboard), _cleaned(old_dashboard)
92             )
93         else:
94             ret["result"] = False
95             ret["comment"] = "Failed to update dashboard {}, response={}".format(
96                 name, response
97             )
98         return ret
99     ret["comment"] = "Dashboard present"
100     return ret
101 def absent(name, profile="grafana"):
102     ret = {"name": name, "result": True, "comment": "", "changes": {}}
103     if isinstance(profile, str):
104         profile = __salt__["config.option"](profile)
105     url = "db/{}".format(name)
106     existing_dashboard = _get(url, profile)
107     if existing_dashboard:
108         if __opts__["test"]:
109             ret["result"] = None
110             ret["comment"] = "Dashboard {} is set to be deleted.".format(name)
111             return ret
112         _delete(url, profile)
113         ret["comment"] = "Dashboard {} deleted.".format(name)
114         ret["changes"]["new"] = "Dashboard {} deleted.".format(name)
115         return ret
116     ret["comment"] = "Dashboard absent"
117     return ret
118 _IGNORED_DASHBOARD_FIELDS = [
119     "id",
120     "originalTitle",
121     "version",
122 ]
123 _IGNORED_ROW_FIELDS = []
124 _IGNORED_PANEL_FIELDS = [
125     "grid",
126     "mode",
127     "tooltip",
128 ]
129 _IGNORED_TARGET_FIELDS = [
130     "textEditor",
131 ]
132 def _cleaned(_dashboard):
133     dashboard = copy.deepcopy(_dashboard)
134     for ignored_dashboard_field in _IGNORED_DASHBOARD_FIELDS:
135         dashboard.pop(ignored_dashboard_field, None)
136     for row in dashboard.get("rows", []):
137         for ignored_row_field in _IGNORED_ROW_FIELDS:
138             row.pop(ignored_row_field, None)
139         for i, panel in enumerate(row.get("panels", [])):
140             for ignored_panel_field in _IGNORED_PANEL_FIELDS:
141                 panel.pop(ignored_panel_field, None)
142             for target in panel.get("targets", []):
143                 for ignored_target_field in _IGNORED_TARGET_FIELDS:
144                     target.pop(ignored_target_field, None)
145             row["panels"][i] = _stripped(panel)
146     return dashboard
147 def _inherited_dashboard(dashboard, base_dashboards_from_pillar, ret):
148     base_dashboards = []
149     for base_dashboard_from_pillar in base_dashboards_from_pillar:
150         base_dashboard = __salt__["pillar.get"](base_dashboard_from_pillar)
151         if base_dashboard:
152             base_dashboards.append(base_dashboard)
153         elif base_dashboard_from_pillar != _DEFAULT_DASHBOARD_PILLAR:
154             ret.setdefault("warnings", [])
155             warning_message = 'Cannot find dashboard pillar "{}".'.format(
156                 base_dashboard_from_pillar
157             )
158             if warning_message not in ret["warnings"]:
159                 ret["warnings"].append(warning_message)
160     base_dashboards.append(dashboard)
161     result_dashboard = {}
162     tags = set()
163     for dashboard in base_dashboards:
164         tags.update(dashboard.get("tags", []))
165         result_dashboard.update(dashboard)
166     result_dashboard["tags"] = list(tags)
167     return result_dashboard
168 def _inherited_row(row, base_rows_from_pillar, ret):
169     base_rows = []
170     for base_row_from_pillar in base_rows_from_pillar:
171         base_row = __salt__["pillar.get"](base_row_from_pillar)
172         if base_row:
173             base_rows.append(base_row)
174         elif base_row_from_pillar != _DEFAULT_ROW_PILLAR:
175             ret.setdefault("warnings", [])
176             warning_message = 'Cannot find row pillar "{}".'.format(
177                 base_row_from_pillar
178             )
179             if warning_message not in ret["warnings"]:
180                 ret["warnings"].append(warning_message)
181     base_rows.append(row)
182     result_row = {}
183     for row in base_rows:
184         result_row.update(row)
185     return result_row
186 def _inherited_panel(panel, base_panels_from_pillar, ret):
187     base_panels = []
188     for base_panel_from_pillar in base_panels_from_pillar:
189         base_panel = __salt__["pillar.get"](base_panel_from_pillar)
190         if base_panel:
191             base_panels.append(base_panel)
192         elif base_panel_from_pillar != _DEFAULT_PANEL_PILLAR:
193             ret.setdefault("warnings", [])
194             warning_message = 'Cannot find panel pillar "{}".'.format(
195                 base_panel_from_pillar
196             )
197             if warning_message not in ret["warnings"]:
198                 ret["warnings"].append(warning_message)
199     base_panels.append(panel)
200     result_panel = {}
201     for panel in base_panels:
202         result_panel.update(panel)
203     return result_panel
204 _FULL_LEVEL_SPAN = 12
205 _DEFAULT_PANEL_SPAN = 2.5
206 def _auto_adjust_panel_spans(dashboard):
207     for row in dashboard.get("rows", []):
208         levels = []
209         current_level = []
210         levels.append(current_level)
211         for panel in row.get("panels", []):
212             current_level_span = sum(
213                 panel.get("span", _DEFAULT_PANEL_SPAN) for panel in current_level
214             )
215             span = panel.get("span", _DEFAULT_PANEL_SPAN)
216             if current_level_span + span &gt; _FULL_LEVEL_SPAN:
217                 current_level = [panel]
218                 levels.append(current_level)
219             else:
220                 current_level.append(panel)
221         for level in levels:
222             specified_panels = [panel for panel in level if "span" in panel]
223             unspecified_panels = [panel for panel in level if "span" not in panel]
224             if not unspecified_panels:
225                 continue
226             specified_span = sum(panel["span"] for panel in specified_panels)
227             available_span = _FULL_LEVEL_SPAN - specified_span
228             auto_span = float(available_span) / len(unspecified_panels)
229             for panel in unspecified_panels:
230                 panel["span"] = auto_span
231 def _ensure_pinned_rows(dashboard):
232     pinned_row_titles = __salt__["pillar.get"](_PINNED_ROWS_PILLAR)
233     if not pinned_row_titles:
234         return
235     pinned_row_titles_lower = []
236     for title in pinned_row_titles:
237         pinned_row_titles_lower.append(title.lower())
238     rows = dashboard.get("rows", [])
239     pinned_rows = []
240     for i, row in enumerate(rows):
241         if row.get("title", "").lower() in pinned_row_titles_lower:
242             del rows[i]
243             pinned_rows.append(row)
244     rows = pinned_rows + rows
245 def _ensure_panel_ids(dashboard):
246     panel_id = 1
247     for row in dashboard.get("rows", []):
248         for panel in row.get("panels", []):
249             panel["id"] = panel_id
250             panel_id += 1
251 def _ensure_annotations(dashboard):
252     if "annotation_tags" not in dashboard:
253         return
254     tags = dashboard["annotation_tags"]
255     annotations = {
256         "enable": True,
257         "list": [],
258     }
259     for tag in tags:
260         annotations["list"].append(
261             {
262                 "datasource": "graphite",
263                 "enable": False,
264                 "iconColor": "#C0C6BE",
265                 "iconSize": 13,
266                 "lineColor": "rgba(255, 96, 96, 0.592157)",
267                 "name": tag,
268                 "showLine": True,
269                 "tags": tag,
270             }
271         )
272     del dashboard["annotation_tags"]
273     dashboard["annotations"] = annotations
274 def _get(url, profile):
275     request_url = "{}/api/dashboards/{}".format(profile.get("grafana_url"), url)
276     response = requests.get(
277         request_url,
278         headers={
279             "Accept": "application/json",
280             "Authorization": "Bearer {}".format(profile.get("grafana_token")),
281         },
282         timeout=profile.get("grafana_timeout", 3),
283     )
284     data = response.json()
285     if data.get("message") == "Not found":
286         return None
287     if "dashboard" not in data:
288         return None
289     return data["dashboard"]
290 def _delete(url, profile):
291     request_url = "{}/api/dashboards/{}".format(profile.get("grafana_url"), url)
292     response = requests.delete(
293         request_url,
294         headers={
295             "Accept": "application/json",
296             "Authorization": "Bearer {}".format(profile.get("grafana_token")),
297         },
298         timeout=profile.get("grafana_timeout"),
299     )
300     data = response.json()
301     return data
302 def _update(dashboard, profile):
303     payload = {"dashboard": dashboard, "overwrite": True}
304     request_url = "{}/api/dashboards/db".format(profile.get("grafana_url"))
305     response = requests.post(
306         request_url,
307         headers={"Authorization": "Bearer {}".format(profile.get("grafana_token"))},
308         json=payload,
309     )
310     return response.json()
311 def _dashboard_diff(_new_dashboard, _old_dashboard):
312     diff = {}
313     new_dashboard = copy.deepcopy(_new_dashboard)
314     old_dashboard = copy.deepcopy(_old_dashboard)
315     dashboard_diff = DictDiffer(new_dashboard, old_dashboard)
316     diff["dashboard"] = _stripped(
317         {
318             "changed": list(dashboard_diff.changed()) or None,
319             "added": list(dashboard_diff.added()) or None,
320             "removed": list(dashboard_diff.removed()) or None,
321         }
322     )
323     new_rows = new_dashboard.get("rows", [])
324     old_rows = old_dashboard.get("rows", [])
325     new_rows_by_title = {}
326     old_rows_by_title = {}
327     for row in new_rows:
328         if "title" in row:
329             new_rows_by_title[row["title"]] = row
330     for row in old_rows:
331         if "title" in row:
332             old_rows_by_title[row["title"]] = row
333     rows_diff = DictDiffer(new_rows_by_title, old_rows_by_title)
334     diff["rows"] = _stripped(
335         {
336             "added": list(rows_diff.added()) or None,
337             "removed": list(rows_diff.removed()) or None,
338         }
339     )
340     for changed_row_title in rows_diff.changed():
341         old_row = old_rows_by_title[changed_row_title]
342         new_row = new_rows_by_title[changed_row_title]
343         row_diff = DictDiffer(new_row, old_row)
344         diff["rows"].setdefault("changed", {})
345         diff["rows"]["changed"][changed_row_title] = _stripped(
346             {
347                 "changed": list(row_diff.changed()) or None,
348                 "added": list(row_diff.added()) or None,
349                 "removed": list(row_diff.removed()) or None,
350             }
351         )
352     old_panels_by_id = {}
353     new_panels_by_id = {}
354     for row in old_dashboard.get("rows", []):
355         for panel in row.get("panels", []):
356             if "id" in panel:
357                 old_panels_by_id[panel["id"]] = panel
358     for row in new_dashboard.get("rows", []):
359         for panel in row.get("panels", []):
360             if "id" in panel:
361                 new_panels_by_id[panel["id"]] = panel
362     panels_diff = DictDiffer(new_panels_by_id, old_panels_by_id)
363     diff["panels"] = _stripped(
364         {
365             "added": list(panels_diff.added()) or None,
366             "removed": list(panels_diff.removed()) or None,
367         }
368     )
369     for changed_panel_id in panels_diff.changed():
370         old_panel = old_panels_by_id[changed_panel_id]
371         new_panel = new_panels_by_id[changed_panel_id]
372         panels_diff = DictDiffer(new_panel, old_panel)
373         diff["panels"].setdefault("changed", {})
374         diff["panels"]["changed"][changed_panel_id] = _stripped(
375             {
376                 "changed": list(panels_diff.changed()) or None,
377                 "added": list(panels_diff.added()) or None,
378                 "removed": list(panels_diff.removed()) or None,
379             }
380         )
381     return diff
382 def _stripped(d):
383     ret = {}
384     for k, v in d.items():
385         if v:
386             ret[k] = v
387     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_vpc_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import random
3 import socket
4 import time
5 import salt.utils.compat
6 import salt.utils.versions
7 from salt.exceptions import CommandExecutionError, SaltInvocationError
8 PROVISIONING = "provisioning"
9 PENDING_ACCEPTANCE = "pending-acceptance"
10 ACTIVE = "active"
11 log = logging.getLogger(__name__)
12 try:
13     import boto
14     import botocore
15     import boto.vpc
16     from boto.exception import BotoServerError
17     logging.getLogger("boto").setLevel(logging.CRITICAL)
18     HAS_BOTO = True
19 except ImportError:
20     HAS_BOTO = False
21 try:
22     import boto3
23     logging.getLogger("boto3").setLevel(logging.CRITICAL)
24     HAS_BOTO3 = True
25 except ImportError:
26     HAS_BOTO3 = False
27 def __virtual__():
28     return salt.utils.versions.check_boto_reqs(boto_ver="2.8.0", boto3_ver="1.2.6")
29 def __init__(opts):
30     if HAS_BOTO:
31         __utils__["boto.assign_funcs"](__name__, "vpc", pack=__salt__)
32     if HAS_BOTO3:
33         __utils__["boto3.assign_funcs"](
34             __name__,
35             "ec2",
36             get_conn_funcname="_get_conn3",
37             cache_id_funcname="_cache_id3",
38             exactly_one_funcname=None,
39         )
40 def check_vpc(
41     vpc_id=None,
42     vpc_name=None,
43     region=None,
44     key=None,
45     keyid=None,
46     profile=None,
47 ):
48     if not _exactly_one((vpc_name, vpc_id)):
49         raise SaltInvocationError(
50             "One (but not both) of vpc_id or vpc_name must be provided."
51         )
52     if vpc_name:
53         vpc_id = _get_id(
54             vpc_name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
55         )
56     elif not _find_vpcs(
57         vpc_id=vpc_id, region=region, key=key, keyid=keyid, profile=profile
58     ):
59         log.info("VPC %s does not exist.", vpc_id)
60         return None
61     return vpc_id
62 def _create_resource(
63     resource,
64     name=None,
65     tags=None,
66     region=None,
67     key=None,
68     keyid=None,
69     profile=None,
70     **kwargs
71 ):
72     try:
73         try:
74             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
75             create_resource = getattr(conn, "create_" + resource)
76         except AttributeError:
77             raise AttributeError(
78                 "{} function does not exist for boto VPC connection.".format(
79                     "create_" + resource
80                 )
81             )
82         if name and _get_resource_id(
83             resource, name, region=region, key=key, keyid=keyid, profile=profile
84         ):
85             return {
86                 "created": False,
87                 "error": {
88                     "message": "A {} named {} already exists.".format(resource, name)
89                 },
90             }
91         r = create_resource(**kwargs)
92         if r:
93             if isinstance(r, bool):
94                 return {"created": True}
95             else:
96                 log.info("A %s with id %s was created", resource, r.id)
97                 _maybe_set_name_tag(name, r)
98                 _maybe_set_tags(tags, r)
99                 if name:
100                     _cache_id(
101                         name,
102                         sub_resource=resource,
103                         resource_id=r.id,
104                         region=region,
105                         key=key,
106                         keyid=keyid,
107                         profile=profile,
108                     )
109                 return {"created": True, "id": r.id}
110         else:
111             if name:
112                 e = "{} {} was not created.".format(resource, name)
113             else:
114                 e = "{} was not created.".format(resource)
115             log.warning(e)
116             return {"created": False, "error": {"message": e}}
117     except BotoServerError as e:
118         return {"created": False, "error": __utils__["boto.get_error"](e)}
119 def _delete_resource(
120     resource,
121     name=None,
122     resource_id=None,
123     region=None,
124     key=None,
125     keyid=None,
126     profile=None,
127     **kwargs
128 ):
129     if not _exactly_one((name, resource_id)):
130         raise SaltInvocationError("One (but not both) of name or id must be provided.")
131     try:
132         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
133         try:
134             delete_resource = getattr(conn, "delete_" + resource)
135         except AttributeError:
136             raise AttributeError(
137                 "{} function does not exist for boto VPC connection.".format(
138                     "delete_" + resource
139                 )
140             )
141         if name:
142             resource_id = _get_resource_id(
143                 resource, name, region=region, key=key, keyid=keyid, profile=profile
144             )
145             if not resource_id:
146                 return {
147                     "deleted": False,
148                     "error": {
149                         "message": "{} {} does not exist.".format(resource, name)
150                     },
151                 }
152         if delete_resource(resource_id, **kwargs):
153             _cache_id(
154                 name,
155                 sub_resource=resource,
156                 resource_id=resource_id,
157                 invalidate=True,
158                 region=region,
159                 key=key,
160                 keyid=keyid,
161                 profile=profile,
162             )
163             return {"deleted": True}
164         else:
165             if name:
166                 e = "{} {} was not deleted.".format(resource, name)
167             else:
168                 e = "{} was not deleted.".format(resource)
169             return {"deleted": False, "error": {"message": e}}
170     except BotoServerError as e:
171         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
172 def _get_resource(
173     resource,
174     name=None,
175     resource_id=None,
176     region=None,
177     key=None,
178     keyid=None,
179     profile=None,
180 ):
181     if not _exactly_one((name, resource_id)):
182         raise SaltInvocationError("One (but not both) of name or id must be provided.")
183     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
184     f = "get_all_{}".format(resource)
185     if not f.endswith("s"):
186         f = f + "s"
187     get_resources = getattr(conn, f)
188     filter_parameters = {}
189     if name:
190         filter_parameters["filters"] = {"tag:Name": name}
191     if resource_id:
192         filter_parameters["{}_ids".format(resource)] = resource_id
193     try:
194         r = get_resources(**filter_parameters)
195     except BotoServerError as e:
196         if e.code.endswith(".NotFound"):
197             return None
198         raise
199     if r:
200         if len(r) == 1:
201             if name:
202                 _cache_id(
203                     name,
204                     sub_resource=resource,
205                     resource_id=r[0].id,
206                     region=region,
207                     key=key,
208                     keyid=keyid,
209                     profile=profile,
210                 )
211             return r[0]
212         else:
213             raise CommandExecutionError(
214                 'Found more than one {} named "{}"'.format(resource, name)
215             )
216     else:
217         return None
218 def _find_resources(
219     resource,
220     name=None,
221     resource_id=None,
222     tags=None,
223     region=None,
224     key=None,
225     keyid=None,
226     profile=None,
227 ):
228     if all((resource_id, name)):
229         raise SaltInvocationError("Only one of name or id may be provided.")
230     if not any((resource_id, name, tags)):
231         raise SaltInvocationError(
232             "At least one of the following must be provided: id, name, or tags."
233         )
234     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
235     f = "get_all_{}".format(resource)
236     if not f.endswith("s"):
237         f = f + "s"
238     get_resources = getattr(conn, f)
239     filter_parameters = {}
240     if name:
241         filter_parameters["filters"] = {"tag:Name": name}
242     if resource_id:
243         filter_parameters["{}_ids".format(resource)] = resource_id
244     if tags:
245         for tag_name, tag_value in tags.items():
246             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
247     try:
248         r = get_resources(**filter_parameters)
249     except BotoServerError as e:
250         if e.code.endswith(".NotFound"):
251             return None
252         raise
253     return r
254 def _get_resource_id(resource, name, region=None, key=None, keyid=None, profile=None):
255     _id = _cache_id(
256         name,
257         sub_resource=resource,
258         region=region,
259         key=key,
260         keyid=keyid,
261         profile=profile,
262     )
263     if _id:
264         return _id
265     r = _get_resource(
266         resource, name=name, region=region, key=key, keyid=keyid, profile=profile
267     )
268     if r:
269         return r.id
270 def get_resource_id(
271     resource,
272     name=None,
273     resource_id=None,
274     region=None,
275     key=None,
276     keyid=None,
277     profile=None,
278 ):
279     try:
280         return {
281             "id": _get_resource_id(
282                 resource, name, region=region, key=key, keyid=keyid, profile=profile
283             )
284         }
285     except BotoServerError as e:
286         return {"error": __utils__["boto.get_error"](e)}
287 def resource_exists(
288     resource,
289     name=None,
290     resource_id=None,
291     tags=None,
292     region=None,
293     key=None,
294     keyid=None,
295     profile=None,
296 ):
297     try:
298         return {
299             "exists": bool(
300                 _find_resources(
301                     resource,
302                     name=name,
303                     resource_id=resource_id,
304                     tags=tags,
305                     region=region,
306                     key=key,
307                     keyid=keyid,
308                     profile=profile,
309                 )
310             )
311         }
312     except BotoServerError as e:
313         return {"error": __utils__["boto.get_error"](e)}
314 def _find_vpcs(
315     vpc_id=None,
316     vpc_name=None,
317     cidr=None,
318     tags=None,
319     region=None,
320     key=None,
321     keyid=None,
322     profile=None,
323 ):
324     if all((vpc_id, vpc_name)):
325         raise SaltInvocationError("Only one of vpc_name or vpc_id may be provided.")
326     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
327     filter_parameters = {"filters": {}}
328     if vpc_id:
329         filter_parameters["vpc_ids"] = [vpc_id]
330     if cidr:
331         filter_parameters["filters"]["cidr"] = cidr
332     if vpc_name:
333         filter_parameters["filters"]["tag:Name"] = vpc_name
334     if tags:
335         for tag_name, tag_value in tags.items():
336             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
337     vpcs = conn.get_all_vpcs(**filter_parameters)
338     log.debug(
339         "The filters criteria %s matched the following VPCs:%s", filter_parameters, vpcs
340     )
341     if vpcs:
342         if not any((vpc_id, vpc_name, cidr, tags)):
343             return [vpc.id for vpc in vpcs if vpc.is_default]
344         else:
345             return [vpc.id for vpc in vpcs]
346     else:
347         return []
348 def _get_id(
349     vpc_name=None,
350     cidr=None,
351     tags=None,
352     region=None,
353     key=None,
354     keyid=None,
355     profile=None,
356 ):
357     if not any((vpc_name, tags, cidr)):
358         raise SaltInvocationError(
359             "At least one of the following must be provided: vpc_name, cidr or tags."
360         )
361     if vpc_name and not any((cidr, tags)):
362         vpc_id = _cache_id(
363             vpc_name, region=region, key=key, keyid=keyid, profile=profile
364         )
365         if vpc_id:
366             return vpc_id
367     vpc_ids = _find_vpcs(
368         vpc_name=vpc_name,
369         cidr=cidr,
370         tags=tags,
371         region=region,
372         key=key,
373         keyid=keyid,
374         profile=profile,
375     )
376     if vpc_ids:
377         log.debug("Matching VPC: %s", " ".join(vpc_ids))
378         if len(vpc_ids) == 1:
379             vpc_id = vpc_ids[0]
380             if vpc_name:
381                 _cache_id(
382                     vpc_name,
383                     vpc_id,
384                     region=region,
385                     key=key,
386                     keyid=keyid,
387                     profile=profile,
388                 )
389             return vpc_id
390         else:
391             raise CommandExecutionError(
392                 "Found more than one VPC matching the criteria."
393             )
394     else:
395         log.info("No VPC found.")
396         return None
397 def get_id(
398     name=None,
399     cidr=None,
400     tags=None,
401     region=None,
402     key=None,
403     keyid=None,
404     profile=None,
405 ):
406     try:
407         return {
408             "id": _get_id(
409                 vpc_name=name,
410                 cidr=cidr,
411                 tags=tags,
412                 region=region,
413                 key=key,
414                 keyid=keyid,
415                 profile=profile,
416             )
417         }
418     except BotoServerError as e:
419         return {"error": __utils__["boto.get_error"](e)}
420 def exists(
421     vpc_id=None,
422     name=None,
423     cidr=None,
424     tags=None,
425     region=None,
426     key=None,
427     keyid=None,
428     profile=None,
429 ):
430     if not any((vpc_id, name, tags, cidr)):
431         raise SaltInvocationError(
432             "At least one of the following must be "
433             "provided: vpc_id, vpc_name, cidr or tags."
434         )
435     try:
436         vpc_ids = _find_vpcs(
437             vpc_id=vpc_id,
438             vpc_name=name,
439             cidr=cidr,
440             tags=tags,
441             region=region,
442             key=key,
443             keyid=keyid,
444             profile=profile,
445         )
446     except BotoServerError as err:
447         boto_err = __utils__["boto.get_error"](err)
448         if boto_err.get("aws", {}).get("code") == "InvalidVpcID.NotFound":
449             return {"exists": False}
450         return {"error": boto_err}
451     return {"exists": bool(vpc_ids)}
452 def create(
453     cidr_block,
454     instance_tenancy=None,
455     vpc_name=None,
456     enable_dns_support=None,
457     enable_dns_hostnames=None,
458     tags=None,
459     region=None,
460     key=None,
461     keyid=None,
462     profile=None,
463 ):
464     try:
465         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
466         vpc = conn.create_vpc(cidr_block, instance_tenancy=instance_tenancy)
467         if vpc:
468             log.info("The newly created VPC id is %s", vpc.id)
469             _maybe_set_name_tag(vpc_name, vpc)
470             _maybe_set_tags(tags, vpc)
471             _maybe_set_dns(conn, vpc.id, enable_dns_support, enable_dns_hostnames)
472             _maybe_name_route_table(conn, vpc.id, vpc_name)
473             if vpc_name:
474                 _cache_id(
475                     vpc_name,
476                     vpc.id,
477                     region=region,
478                     key=key,
479                     keyid=keyid,
480                     profile=profile,
481                 )
482             return {"created": True, "id": vpc.id}
483         else:
484             log.warning("VPC was not created")
485             return {"created": False}
486     except BotoServerError as e:
487         return {"created": False, "error": __utils__["boto.get_error"](e)}
488 def delete(
489     vpc_id=None,
490     name=None,
491     vpc_name=None,
492     tags=None,
493     region=None,
494     key=None,
495     keyid=None,
496     profile=None,
497 ):
498     if name:
499         log.warning(
500             "boto_vpc.delete: name parameter is deprecated use vpc_name instead."
501         )
502         vpc_name = name
503     if not _exactly_one((vpc_name, vpc_id)):
504         raise SaltInvocationError(
505             "One (but not both) of vpc_name or vpc_id must be provided."
506         )
507     try:
508         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
509         if not vpc_id:
510             vpc_id = _get_id(
511                 vpc_name=vpc_name,
512                 tags=tags,
513                 region=region,
514                 key=key,
515                 keyid=keyid,
516                 profile=profile,
517             )
518             if not vpc_id:
519                 return {
520                     "deleted": False,
521                     "error": {"message": "VPC {} not found".format(vpc_name)},
522                 }
523         if conn.delete_vpc(vpc_id):
524             log.info("VPC %s was deleted.", vpc_id)
525             if vpc_name:
526                 _cache_id(
527                     vpc_name,
528                     resource_id=vpc_id,
529                     invalidate=True,
530                     region=region,
531                     key=key,
532                     keyid=keyid,
533                     profile=profile,
534                 )
535             return {"deleted": True}
536         else:
537             log.warning("VPC %s was not deleted.", vpc_id)
538             return {"deleted": False}
539     except BotoServerError as e:
540         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
541 def describe(
542     vpc_id=None,
543     vpc_name=None,
544     region=None,
545     key=None,
546     keyid=None,
547     profile=None,
548 ):
549     try:
550         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
551         vpc_id = _find_vpcs(
552             vpc_id=vpc_id,
553             vpc_name=vpc_name,
554             region=region,
555             key=key,
556             keyid=keyid,
557             profile=profile,
558         )
559     except BotoServerError as err:
560         boto_err = __utils__["boto.get_error"](err)
561         if boto_err.get("aws", {}).get("code") == "InvalidVpcID.NotFound":
562             return {"vpc": None}
563         return {"error": boto_err}
564     if not vpc_id:
565         return {"vpc": None}
566     filter_parameters = {"vpc_ids": vpc_id}
567     try:
568         vpcs = conn.get_all_vpcs(**filter_parameters)
569     except BotoServerError as err:
570         return {"error": __utils__["boto.get_error"](err)}
571     if vpcs:
572         vpc = vpcs[0]  # Found!
573         log.debug("Found VPC: %s", vpc.id)
574         keys = (
575             "id",
576             "cidr_block",
577             "is_default",
578             "state",
579             "tags",
580             "dhcp_options_id",
581             "instance_tenancy",
582         )
583         _r = {k: getattr(vpc, k) for k in keys}
584         _r.update({"region": getattr(vpc, "region").name})
585         return {"vpc": _r}
586     else:
587         return {"vpc": None}
588 def describe_vpcs(
589     vpc_id=None,
590     name=None,
591     cidr=None,
592     tags=None,
593     region=None,
594     key=None,
595     keyid=None,
596     profile=None,
597 ):
598     keys = (
599         "id",
600         "cidr_block",
601         "is_default",
602         "state",
603         "tags",
604         "dhcp_options_id",
605         "instance_tenancy",
606     )
607     try:
608         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
609         filter_parameters = {"filters": {}}
610         if vpc_id:
611             filter_parameters["vpc_ids"] = [vpc_id]
612         if cidr:
613             filter_parameters["filters"]["cidr"] = cidr
614         if name:
615             filter_parameters["filters"]["tag:Name"] = name
616         if tags:
617             for tag_name, tag_value in tags.items():
618                 filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
619         vpcs = conn.get_all_vpcs(**filter_parameters)
620         if vpcs:
621             ret = []
622             for vpc in vpcs:
623                 _r = {k: getattr(vpc, k) for k in keys}
624                 _r.update({"region": getattr(vpc, "region").name})
625                 ret.append(_r)
626             return {"vpcs": ret}
627         else:
628             return {"vpcs": []}
629     except BotoServerError as e:
630         return {"error": __utils__["boto.get_error"](e)}
631 def _find_subnets(subnet_name=None, vpc_id=None, cidr=None, tags=None, conn=None):
632     if not any([subnet_name, tags, cidr]):
633         raise SaltInvocationError(
634             "At least one of the following must be "
635             "specified: subnet_name, cidr or tags."
636         )
637     filter_parameters = {"filters": {}}
638     if cidr:
639         filter_parameters["filters"]["cidr"] = cidr
640     if subnet_name:
641         filter_parameters["filters"]["tag:Name"] = subnet_name
642     if vpc_id:
643         filter_parameters["filters"]["VpcId"] = vpc_id
644     if tags:
645         for tag_name, tag_value in tags.items():
646             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
647     subnets = conn.get_all_subnets(**filter_parameters)
648     log.debug(
649         "The filters criteria %s matched the following subnets: %s",
650         filter_parameters,
651         subnets,
652     )
653     if subnets:
654         return [subnet.id for subnet in subnets]
655     else:
656         return False
657 def create_subnet(
658     vpc_id=None,
659     cidr_block=None,
660     vpc_name=None,
661     availability_zone=None,
662     subnet_name=None,
663     tags=None,
664     region=None,
665     key=None,
666     keyid=None,
667     profile=None,
668     auto_assign_public_ipv4=False,
669 ):
670     try:
671         vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
672         if not vpc_id:
673             return {
674                 "created": False,
675                 "error": {
676                     "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
677                 },
678             }
679     except BotoServerError as e:
680         return {"created": False, "error": __utils__["boto.get_error"](e)}
681     subnet_object_dict = _create_resource(
682         "subnet",
683         name=subnet_name,
684         tags=tags,
685         vpc_id=vpc_id,
686         availability_zone=availability_zone,
687         cidr_block=cidr_block,
688         region=region,
689         key=key,
690         keyid=keyid,
691         profile=profile,
692     )
693     if auto_assign_public_ipv4:
694         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
695         conn3.modify_subnet_attribute(
696             MapPublicIpOnLaunch={"Value": True}, SubnetId=subnet_object_dict["id"]
697         )
698     return subnet_object_dict
699 def delete_subnet(
700     subnet_id=None, subnet_name=None, region=None, key=None, keyid=None, profile=None
701 ):
702     return _delete_resource(
703         resource="subnet",
704         name=subnet_name,
705         resource_id=subnet_id,
706         region=region,
707         key=key,
708         keyid=keyid,
709         profile=profile,
710     )
711 def subnet_exists(
712     subnet_id=None,
713     name=None,
714     subnet_name=None,
715     cidr=None,
716     tags=None,
717     zones=None,
718     region=None,
719     key=None,
720     keyid=None,
721     profile=None,
722 ):
723     if name:
724         log.warning(
725             "boto_vpc.subnet_exists: name parameter is deprecated "
726             "use subnet_name instead."
727         )
728         subnet_name = name
729     if not any((subnet_id, subnet_name, cidr, tags, zones)):
730         raise SaltInvocationError(
731             "At least one of the following must be "
732             "specified: subnet id, cidr, subnet_name, "
733             "tags, or zones."
734         )
735     try:
736         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
737     except BotoServerError as err:
738         return {"error": __utils__["boto.get_error"](err)}
739     filter_parameters = {"filters": {}}
740     if subnet_id:
741         filter_parameters["subnet_ids"] = [subnet_id]
742     if subnet_name:
743         filter_parameters["filters"]["tag:Name"] = subnet_name
744     if cidr:
745         filter_parameters["filters"]["cidr"] = cidr
746     if tags:
747         for tag_name, tag_value in tags.items():
748             filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
749     if zones:
750         filter_parameters["filters"]["availability_zone"] = zones
751     try:
752         subnets = conn.get_all_subnets(**filter_parameters)
753     except BotoServerError as err:
754         boto_err = __utils__["boto.get_error"](err)
755         if boto_err.get("aws", {}).get("code") == "InvalidSubnetID.NotFound":
756             return {"exists": False}
757         return {"error": boto_err}
758     log.debug(
759         "The filters criteria %s matched the following subnets:%s",
760         filter_parameters,
761         subnets,
762     )
763     if subnets:
764         log.info("Subnet %s exists.", subnet_name or subnet_id)
765         return {"exists": True}
766     else:
767         log.info("Subnet %s does not exist.", subnet_name or subnet_id)
768         return {"exists": False}
769 def get_subnet_association(subnets, region=None, key=None, keyid=None, profile=None):
770     try:
771         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
772         subnets = conn.get_all_subnets(subnet_ids=subnets)
773     except BotoServerError as e:
774         return {"error": __utils__["boto.get_error"](e)}
775     vpc_ids = set()
776     for subnet in subnets:
777         log.debug("examining subnet id: %s for vpc_id", subnet.id)
778         if subnet in subnets:
779             log.debug(
780                 "subnet id: %s is associated with vpc id: %s", subnet.id, subnet.vpc_id
781             )
782             vpc_ids.add(subnet.vpc_id)
783     if not vpc_ids:
784         return {"vpc_id": None}
785     elif len(vpc_ids) == 1:
786         return {"vpc_id": vpc_ids.pop()}
787     else:
788         return {"vpc_ids": list(vpc_ids)}
789 def describe_subnet(
790     subnet_id=None, subnet_name=None, region=None, key=None, keyid=None, profile=None
791 ):
792     try:
793         subnet = _get_resource(
794             "subnet",
795             name=subnet_name,
796             resource_id=subnet_id,
797             region=region,
798             key=key,
799             keyid=keyid,
800             profile=profile,
801         )
802     except BotoServerError as e:
803         return {"error": __utils__["boto.get_error"](e)}
804     if not subnet:
805         return {"subnet": None}
806     log.debug("Found subnet: %s", subnet.id)
807     keys = ("id", "cidr_block", "availability_zone", "tags", "vpc_id")
808     ret = {"subnet": {k: getattr(subnet, k) for k in keys}}
809     explicit_route_table_assoc = _get_subnet_explicit_route_table(
810         ret["subnet"]["id"],
811         ret["subnet"]["vpc_id"],
812         conn=None,
813         region=region,
814         key=key,
815         keyid=keyid,
816         profile=profile,
817     )
818     if explicit_route_table_assoc:
819         ret["subnet"][
820             "explicit_route_table_association_id"
821         ] = explicit_route_table_assoc
822     return ret
823 def describe_subnets(
824     subnet_ids=None,
825     subnet_names=None,
826     vpc_id=None,
827     cidr=None,
828     region=None,
829     key=None,
830     keyid=None,
831     profile=None,
832 ):
833     try:
834         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
835         filter_parameters = {"filters": {}}
836         if vpc_id:
837             filter_parameters["filters"]["vpcId"] = vpc_id
838         if cidr:
839             filter_parameters["filters"]["cidrBlock"] = cidr
840         if subnet_names:
841             filter_parameters["filters"]["tag:Name"] = subnet_names
842         subnets = conn.get_all_subnets(subnet_ids=subnet_ids, **filter_parameters)
843         log.debug(
844             "The filters criteria %s matched the following subnets: %s",
845             filter_parameters,
846             subnets,
847         )
848         if not subnets:
849             return {"subnets": None}
850         subnets_list = []
851         keys = ("id", "cidr_block", "availability_zone", "tags", "vpc_id")
852         for item in subnets:
853             subnet = {}
854             for key in keys:
855                 if hasattr(item, key):
856                     subnet[key] = getattr(item, key)
857             explicit_route_table_assoc = _get_subnet_explicit_route_table(
858                 subnet["id"], subnet["vpc_id"], conn=conn
859             )
860             if explicit_route_table_assoc:
861                 subnet[
862                     "explicit_route_table_association_id"
863                 ] = explicit_route_table_assoc
864             subnets_list.append(subnet)
865         return {"subnets": subnets_list}
866     except BotoServerError as e:
867         return {"error": __utils__["boto.get_error"](e)}
868 def create_internet_gateway(
869     internet_gateway_name=None,
870     vpc_id=None,
871     vpc_name=None,
872     tags=None,
873     region=None,
874     key=None,
875     keyid=None,
876     profile=None,
877 ):
878     try:
879         if vpc_id or vpc_name:
880             vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
881             if not vpc_id:
882                 return {
883                     "created": False,
884                     "error": {
885                         "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
886                     },
887                 }
888         r = _create_resource(
889             "internet_gateway",
890             name=internet_gateway_name,
891             tags=tags,
892             region=region,
893             key=key,
894             keyid=keyid,
895             profile=profile,
896         )
897         if r.get("created") and vpc_id:
898             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
899             conn.attach_internet_gateway(r["id"], vpc_id)
900             log.info(
901                 "Attached internet gateway %s to VPC %s", r["id"], vpc_name or vpc_id
902             )
903         return r
904     except BotoServerError as e:
905         return {"created": False, "error": __utils__["boto.get_error"](e)}
906 def delete_internet_gateway(
907     internet_gateway_id=None,
908     internet_gateway_name=None,
909     detach=False,
910     region=None,
911     key=None,
912     keyid=None,
913     profile=None,
914 ):
915     try:
916         if internet_gateway_name:
917             internet_gateway_id = _get_resource_id(
918                 "internet_gateway",
919                 internet_gateway_name,
920                 region=region,
921                 key=key,
922                 keyid=keyid,
923                 profile=profile,
924             )
925         if not internet_gateway_id:
926             return {
927                 "deleted": False,
928                 "error": {
929                     "message": "internet gateway {} does not exist.".format(
930                         internet_gateway_name
931                     )
932                 },
933             }
934         if detach:
935             igw = _get_resource(
936                 "internet_gateway",
937                 resource_id=internet_gateway_id,
938                 region=region,
939                 key=key,
940                 keyid=keyid,
941                 profile=profile,
942             )
943             if not igw:
944                 return {
945                     "deleted": False,
946                     "error": {
947                         "message": "internet gateway {} does not exist.".format(
948                             internet_gateway_id
949                         )
950                     },
951                 }
952             if igw.attachments:
953                 conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
954                 conn.detach_internet_gateway(
955                     internet_gateway_id, igw.attachments[0].vpc_id
956                 )
957         return _delete_resource(
958             "internet_gateway",
959             resource_id=internet_gateway_id,
960             region=region,
961             key=key,
962             keyid=keyid,
963             profile=profile,
964         )
965     except BotoServerError as e:
966 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def _find_nat_gateways(
967     nat_gateway_id=None,
968     subnet_id=None,
969     subnet_name=None,
970     vpc_id=None,
971     vpc_name=None,
972     states=("pending", "available"),
973     region=None,
974     key=None,
975     keyid=None,
976     profile=None,
977 ):
978     if not any(</b></font>(nat_gateway_id, subnet_id, subnet_name, vpc_id, vpc_name)):
979         raise SaltInvocationError(
980             "At least one of the following must be "
981             "provided: nat_gateway_id, subnet_id, "
982             "subnet_name, vpc_id, or vpc_name."
983         )
984     filter_parameters = {"Filter": []}
985     if nat_gateway_id:
986         filter_parameters["NatGatewayIds"] = [nat_gateway_id]
987     if subnet_name:
988         subnet_id = _get_resource_id(
989             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
990         )
991         if not subnet_id:
992             return False
993     if subnet_id:
994         filter_parameters["Filter"].append({"Name": "subnet-id", "Values": [subnet_id]})
995     if vpc_name:
996         vpc_id = _get_resource_id(
997             "vpc", vpc_name, region=region, key=key, keyid=keyid, profile=profile
998         )
999         if not vpc_id:
1000             return False
1001     if vpc_id:
1002         filter_parameters["Filter"].append({"Name": "vpc-id", "Values": [vpc_id]})
1003     conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
1004     nat_gateways = []
1005     for ret in __utils__["boto3.paged_call"](
1006         conn3.describe_nat_gateways,
1007         marker_flag="NextToken",
1008         marker_arg="NextToken",
1009         **filter_parameters
1010     ):
1011         for gw in ret.get("NatGateways", []):
1012             if gw.get("State") in states:
1013                 nat_gateways.append(gw)
1014     log.debug(
1015         "The filters criteria %s matched the following nat gateways: %s",
1016         filter_parameters,
1017         nat_gateways,
1018     )
1019     if nat_gateways:
1020         return nat_gateways
1021     else:
1022         return False
1023 def nat_gateway_exists(
1024     nat_gateway_id=None,
1025     subnet_id=None,
1026     subnet_name=None,
1027     vpc_id=None,
1028     vpc_name=None,
1029     states=("pending", "available"),
1030     region=None,
1031     key=None,
1032     keyid=None,
1033     profile=None,
1034 ):
1035     return bool(
1036         _find_nat_gateways(
1037             nat_gateway_id=nat_gateway_id,
1038             subnet_id=subnet_id,
1039             subnet_name=subnet_name,
1040             vpc_id=vpc_id,
1041             vpc_name=vpc_name,
1042             states=states,
1043             region=region,
1044             key=key,
1045             keyid=keyid,
1046             profile=profile,
1047         )
1048     )
1049 def describe_nat_gateways(
1050     nat_gateway_id=None,
1051     subnet_id=None,
1052     subnet_name=None,
1053     vpc_id=None,
1054     vpc_name=None,
1055     states=("pending", "available"),
1056     region=None,
1057     key=None,
1058     keyid=None,
1059     profile=None,
1060 ):
1061     return _find_nat_gateways(
1062         nat_gateway_id=nat_gateway_id,
1063         subnet_id=subnet_id,
1064         subnet_name=subnet_name,
1065         vpc_id=vpc_id,
1066         vpc_name=vpc_name,
1067         states=states,
1068         region=region,
1069         key=key,
1070         keyid=keyid,
1071         profile=profile,
1072     )
1073 def create_nat_gateway(
1074     subnet_id=None,
1075     subnet_name=None,
1076     allocation_id=None,
1077     region=None,
1078     key=None,
1079     keyid=None,
1080     profile=None,
1081 ):
1082     try:
1083         if all((subnet_id, subnet_name)):
1084             raise SaltInvocationError(
1085                 "Only one of subnet_name or subnet_id may be provided."
1086             )
1087         if subnet_name:
1088             subnet_id = _get_resource_id(
1089                 "subnet",
1090                 subnet_name,
1091                 region=region,
1092                 key=key,
1093                 keyid=keyid,
1094                 profile=profile,
1095             )
1096             if not subnet_id:
1097                 return {
1098                     "created": False,
1099                     "error": {
1100                         "message": "Subnet {} does not exist.".format(subnet_name)
1101                     },
1102                 }
1103         else:
1104             if not _get_resource(
1105                 "subnet",
1106                 resource_id=subnet_id,
1107                 region=region,
1108                 key=key,
1109                 keyid=keyid,
1110                 profile=profile,
1111             ):
1112                 return {
1113                     "created": False,
1114                     "error": {"message": "Subnet {} does not exist.".format(subnet_id)},
1115                 }
1116         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
1117         if not allocation_id:
1118             address = conn3.allocate_address(Domain="vpc")
1119             allocation_id = address.get("AllocationId")
1120         r = conn3.create_nat_gateway(SubnetId=subnet_id, AllocationId=allocation_id)
1121         return {"created": True, "id": r.get("NatGateway", {}).get("NatGatewayId")}
1122     except BotoServerError as e:
1123         return {"created": False, "error": __utils__["boto.get_error"](e)}
1124 def delete_nat_gateway(
1125     nat_gateway_id,
1126     release_eips=False,
1127     region=None,
1128     key=None,
1129     keyid=None,
1130     profile=None,
1131     wait_for_delete=False,
1132     wait_for_delete_retries=5,
1133 ):
1134     try:
1135         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
1136         gwinfo = conn3.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])
1137         if gwinfo:
1138             gwinfo = gwinfo.get("NatGateways", [None])[0]
1139         conn3.delete_nat_gateway(NatGatewayId=nat_gateway_id)
1140         if wait_for_delete:
1141             for retry in range(wait_for_delete_retries, 0, -1):
1142                 if gwinfo and gwinfo["State"] not in ["deleted", "failed"]:
1143                     time.sleep(
1144                         (2 ** (wait_for_delete_retries - retry))
1145                         + (random.randint(0, 1000) / 1000.0)
1146                     )
1147                     gwinfo = conn3.describe_nat_gateways(NatGatewayIds=[nat_gateway_id])
1148                     if gwinfo:
1149                         gwinfo = gwinfo.get("NatGateways", [None])[0]
1150                         continue
1151                 break
1152         if release_eips and gwinfo:
1153             for addr in gwinfo.get("NatGatewayAddresses"):
1154                 conn3.release_address(AllocationId=addr.get("AllocationId"))
1155         return {"deleted": True}
1156     except BotoServerError as e:
1157         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
1158 def create_customer_gateway(
1159     vpn_connection_type,
1160     ip_address,
1161     bgp_asn,
1162     customer_gateway_name=None,
1163     tags=None,
1164     region=None,
1165     key=None,
1166     keyid=None,
1167     profile=None,
1168 ):
1169     return _create_resource(
1170         "customer_gateway",
1171         customer_gateway_name,
1172         type=vpn_connection_type,
1173         ip_address=ip_address,
1174         bgp_asn=bgp_asn,
1175         tags=tags,
1176         region=region,
1177         key=key,
1178         keyid=keyid,
1179         profile=profile,
1180     )
1181 def delete_customer_gateway(
1182     customer_gateway_id=None,
1183     customer_gateway_name=None,
1184     region=None,
1185     key=None,
1186     keyid=None,
1187     profile=None,
1188 ):
1189     return _delete_resource(
1190         resource="customer_gateway",
1191         name=customer_gateway_name,
1192         resource_id=customer_gateway_id,
1193         region=region,
1194         key=key,
1195         keyid=keyid,
1196         profile=profile,
1197     )
1198 def customer_gateway_exists(
1199     customer_gateway_id=None,
1200     customer_gateway_name=None,
1201     region=None,
1202     key=None,
1203     keyid=None,
1204     profile=None,
1205 ):
1206     return resource_exists(
1207         "customer_gateway",
1208         name=customer_gateway_name,
1209         resource_id=customer_gateway_id,
1210         region=region,
1211         key=key,
1212         keyid=keyid,
1213         profile=profile,
1214     )
1215 def create_dhcp_options(
1216     domain_name=None,
1217     domain_name_servers=None,
1218     ntp_servers=None,
1219     netbios_name_servers=None,
1220     netbios_node_type=None,
1221     dhcp_options_name=None,
1222     tags=None,
1223     vpc_id=None,
1224     vpc_name=None,
1225     region=None,
1226     key=None,
1227     keyid=None,
1228     profile=None,
1229 ):
1230     try:
1231         if vpc_id or vpc_name:
1232             vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1233             if not vpc_id:
1234                 return {
1235                     "created": False,
1236                     "error": {
1237                         "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
1238                     },
1239                 }
1240         r = _create_resource(
1241             "dhcp_options",
1242             name=dhcp_options_name,
1243             domain_name=domain_name,
1244             domain_name_servers=domain_name_servers,
1245             ntp_servers=ntp_servers,
1246             netbios_name_servers=netbios_name_servers,
1247             netbios_node_type=netbios_node_type,
1248             region=region,
1249             key=key,
1250             keyid=keyid,
1251             profile=profile,
1252         )
1253         if r.get("created") and vpc_id:
1254             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1255             conn.associate_dhcp_options(r["id"], vpc_id)
1256             log.info("Associated options %s to VPC %s", r["id"], vpc_name or vpc_id)
1257         return r
1258     except BotoServerError as e:
1259         return {"created": False, "error": __utils__["boto.get_error"](e)}
1260 def get_dhcp_options(
1261     dhcp_options_name=None,
1262     dhcp_options_id=None,
1263     region=None,
1264     key=None,
1265     keyid=None,
1266     profile=None,
1267 ):
1268     if not any((dhcp_options_name, dhcp_options_id)):
1269         raise SaltInvocationError(
1270             "At least one of the following must be specified: "
1271             "dhcp_options_name, dhcp_options_id."
1272         )
1273     if not dhcp_options_id and dhcp_options_name:
1274         dhcp_options_id = _get_resource_id(
1275             "dhcp_options",
1276             dhcp_options_name,
1277             region=region,
1278             key=key,
1279             keyid=keyid,
1280             profile=profile,
1281         )
1282     if not dhcp_options_id:
1283         return {"dhcp_options": {}}
1284     try:
1285         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1286         r = conn.get_all_dhcp_options(dhcp_options_ids=[dhcp_options_id])
1287     except BotoServerError as e:
1288         return {"error": __utils__["boto.get_error"](e)}
1289     if not r:
1290         return {"dhcp_options": None}
1291     keys = (
1292         "domain_name",
1293         "domain_name_servers",
1294         "ntp_servers",
1295         "netbios_name_servers",
1296         "netbios_node_type",
1297     )
1298     return {"dhcp_options": {k: r[0].options.get(k) for k in keys}}
1299 def delete_dhcp_options(
1300     dhcp_options_id=None,
1301     dhcp_options_name=None,
1302     region=None,
1303     key=None,
1304     keyid=None,
1305     profile=None,
1306 ):
1307     return _delete_resource(
1308         resource="dhcp_options",
1309         name=dhcp_options_name,
1310         resource_id=dhcp_options_id,
1311         region=region,
1312         key=key,
1313         keyid=keyid,
1314         profile=profile,
1315     )
1316 def associate_dhcp_options_to_vpc(
1317     dhcp_options_id,
1318     vpc_id=None,
1319     vpc_name=None,
1320     region=None,
1321     key=None,
1322     keyid=None,
1323     profile=None,
1324 ):
1325     try:
1326         vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1327         if not vpc_id:
1328             return {
1329                 "associated": False,
1330                 "error": {
1331                     "message": "VPC {} does not exist.".format(vpc_name or vpc_id)
1332                 },
1333             }
1334         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1335         if conn.associate_dhcp_options(dhcp_options_id, vpc_id):
1336             log.info(
1337                 "DHCP options with id %s were associated with VPC %s",
1338                 dhcp_options_id,
1339                 vpc_id,
1340             )
1341             return {"associated": True}
1342         else:
1343             log.warning(
1344                 "DHCP options with id %s were not associated with VPC %s",
1345                 dhcp_options_id,
1346                 vpc_id,
1347             )
1348             return {
1349                 "associated": False,
1350                 "error": {"message": "DHCP options could not be associated."},
1351             }
1352     except BotoServerError as e:
1353         return {"associated": False, "error": __utils__["boto.get_error"](e)}
1354 def dhcp_options_exists(
1355     dhcp_options_id=None,
1356     name=None,
1357     dhcp_options_name=None,
1358     tags=None,
1359     region=None,
1360     key=None,
1361     keyid=None,
1362     profile=None,
1363 ):
1364     if name:
1365         log.warning(
1366             "boto_vpc.dhcp_options_exists: name parameter is deprecated "
1367             "use dhcp_options_name instead."
1368         )
1369         dhcp_options_name = name
1370     return resource_exists(
1371         "dhcp_options",
1372         name=dhcp_options_name,
1373         resource_id=dhcp_options_id,
1374         tags=tags,
1375         region=region,
1376         key=key,
1377         keyid=keyid,
1378         profile=profile,
1379     )
1380 def create_network_acl(
1381     vpc_id=None,
1382     vpc_name=None,
1383     network_acl_name=None,
1384     subnet_id=None,
1385     subnet_name=None,
1386     tags=None,
1387     region=None,
1388     key=None,
1389     keyid=None,
1390     profile=None,
1391 ):
1392     _id = vpc_name or vpc_id
1393     try:
1394         vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1395     except BotoServerError as e:
1396         return {"created": False, "error": __utils__["boto.get_error"](e)}
1397     if not vpc_id:
1398         return {
1399             "created": False,
1400             "error": {"message": "VPC {} does not exist.".format(_id)},
1401         }
1402     if all((subnet_id, subnet_name)):
1403         raise SaltInvocationError(
1404             "Only one of subnet_name or subnet_id may be provided."
1405         )
1406     if subnet_name:
1407         subnet_id = _get_resource_id(
1408             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
1409         )
1410         if not subnet_id:
1411             return {
1412                 "created": False,
1413                 "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
1414             }
1415     elif subnet_id:
1416         if not _get_resource(
1417             "subnet",
1418             resource_id=subnet_id,
1419             region=region,
1420             key=key,
1421             keyid=keyid,
1422             profile=profile,
1423         ):
1424             return {
1425                 "created": False,
1426                 "error": {"message": "Subnet {} does not exist.".format(subnet_id)},
1427             }
1428     r = _create_resource(
1429         "network_acl",
1430         name=network_acl_name,
1431         vpc_id=vpc_id,
1432         region=region,
1433         key=key,
1434         keyid=keyid,
1435         profile=profile,
1436     )
1437     if r.get("created") and subnet_id:
1438         try:
1439             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1440             association_id = conn.associate_network_acl(r["id"], subnet_id)
1441         except BotoServerError as e:
1442             return {"created": False, "error": __utils__["boto.get_error"](e)}
1443         r["association_id"] = association_id
1444     return r
1445 def delete_network_acl(
1446     network_acl_id=None,
1447     network_acl_name=None,
1448     disassociate=False,
1449     region=None,
1450     key=None,
1451     keyid=None,
1452     profile=None,
1453 ):
1454     if disassociate:
1455         network_acl = _get_resource(
1456             "network_acl",
1457             name=network_acl_name,
1458             region=region,
1459             key=key,
1460             keyid=keyid,
1461             profile=profile,
1462         )
1463         if network_acl and network_acl.associations:
1464             subnet_id = network_acl.associations[0].subnet_id
1465             try:
1466                 conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1467                 conn.disassociate_network_acl(subnet_id)
1468             except BotoServerError:
1469                 pass
1470     return _delete_resource(
1471         resource="network_acl",
1472         name=network_acl_name,
1473         resource_id=network_acl_id,
1474         region=region,
1475         key=key,
1476         keyid=keyid,
1477         profile=profile,
1478     )
1479 def network_acl_exists(
1480     network_acl_id=None,
1481     name=None,
1482     network_acl_name=None,
1483     tags=None,
1484     region=None,
1485     key=None,
1486     keyid=None,
1487     profile=None,
1488 ):
1489     if name:
1490         log.warning(
1491             "boto_vpc.network_acl_exists: name parameter is deprecated "
1492             "use network_acl_name instead."
1493         )
1494         network_acl_name = name
1495     return resource_exists(
1496         "network_acl",
1497         name=network_acl_name,
1498         resource_id=network_acl_id,
1499         tags=tags,
1500         region=region,
1501         key=key,
1502         keyid=keyid,
1503         profile=profile,
1504     )
1505 def associate_network_acl_to_subnet(
1506     network_acl_id=None,
1507     subnet_id=None,
1508     network_acl_name=None,
1509     subnet_name=None,
1510     region=None,
1511     key=None,
1512     keyid=None,
1513     profile=None,
1514 ):
1515     if network_acl_name:
1516         network_acl_id = _get_resource_id(
1517             "network_acl",
1518             network_acl_name,
1519             region=region,
1520             key=key,
1521             keyid=keyid,
1522             profile=profile,
1523         )
1524         if not network_acl_id:
1525             return {
1526                 "associated": False,
1527                 "error": {
1528                     "message": "Network ACL {} does not exist.".format(network_acl_name)
1529                 },
1530             }
1531     if subnet_name:
1532         subnet_id = _get_resource_id(
1533             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
1534         )
1535         if not subnet_id:
1536             return {
1537                 "associated": False,
1538                 "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
1539             }
1540     try:
1541         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1542         association_id = conn.associate_network_acl(network_acl_id, subnet_id)
1543         if association_id:
1544             log.info(
1545                 "Network ACL with id %s was associated with subnet %s",
1546                 network_acl_id,
1547                 subnet_id,
1548             )
1549             return {"associated": True, "id": association_id}
1550         else:
1551             log.warning(
1552                 "Network ACL with id %s was not associated with subnet %s",
1553                 network_acl_id,
1554                 subnet_id,
1555             )
1556             return {
1557                 "associated": False,
1558                 "error": {"message": "ACL could not be assocaited."},
1559             }
1560     except BotoServerError as e:
1561         return {"associated": False, "error": __utils__["boto.get_error"](e)}
1562 def disassociate_network_acl(
1563     subnet_id=None,
1564     vpc_id=None,
1565     subnet_name=None,
1566     vpc_name=None,
1567     region=None,
1568     key=None,
1569     keyid=None,
1570     profile=None,
1571 ):
1572     if not _exactly_one((subnet_name, subnet_id)):
1573         raise SaltInvocationError(
1574             "One (but not both) of subnet_id or subnet_name must be provided."
1575         )
1576     if all((vpc_name, vpc_id)):
1577         raise SaltInvocationError("Only one of vpc_id or vpc_name may be provided.")
1578     try:
1579         if subnet_name:
1580             subnet_id = _get_resource_id(
1581                 "subnet",
1582                 subnet_name,
1583                 region=region,
1584                 key=key,
1585                 keyid=keyid,
1586                 profile=profile,
1587             )
1588             if not subnet_id:
1589                 return {
1590                     "disassociated": False,
1591                     "error": {
1592                         "message": "Subnet {} does not exist.".format(subnet_name)
1593                     },
1594                 }
1595         if vpc_name or vpc_id:
1596             vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1597         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1598         association_id = conn.disassociate_network_acl(subnet_id, vpc_id=vpc_id)
1599         return {"disassociated": True, "association_id": association_id}
1600     except BotoServerError as e:
1601         return {"disassociated": False, "error": __utils__["boto.get_error"](e)}
1602 def _create_network_acl_entry(
1603     network_acl_id=None,
1604     rule_number=None,
1605     protocol=None,
1606     rule_action=None,
1607     cidr_block=None,
1608     egress=None,
1609     network_acl_name=None,
1610     icmp_code=None,
1611     icmp_type=None,
1612     port_range_from=None,
1613     port_range_to=None,
1614     replace=False,
1615     region=None,
1616     key=None,
1617     keyid=None,
1618     profile=None,
1619 ):
1620     if replace:
1621         rkey = "replaced"
1622     else:
1623         rkey = "created"
1624     if not _exactly_one((network_acl_name, network_acl_id)):
1625         raise SaltInvocationError(
1626             "One (but not both) of network_acl_id or network_acl_name must be provided."
1627         )
1628     for v in ("rule_number", "protocol", "rule_action", "cidr_block"):
1629         if locals()[v] is None:
1630             raise SaltInvocationError("{} is required.".format(v))
1631     if network_acl_name:
1632         network_acl_id = _get_resource_id(
1633             "network_acl",
1634             network_acl_name,
1635             region=region,
1636             key=key,
1637             keyid=keyid,
1638             profile=profile,
1639         )
1640     if not network_acl_id:
1641         return {
1642             rkey: False,
1643             "error": {
1644                 "message": "Network ACL {} does not exist.".format(
1645                     network_acl_name or network_acl_id
1646                 )
1647             },
1648         }
1649     if isinstance(protocol, str):
1650         if protocol == "all":
1651             protocol = -1
1652         else:
1653             try:
1654                 protocol = socket.getprotobyname(protocol)
1655             except OSError as e:
1656                 raise SaltInvocationError(e)
1657     try:
1658         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1659         if replace:
1660             f = conn.replace_network_acl_entry
1661         else:
1662             f = conn.create_network_acl_entry
1663         created = f(
1664             network_acl_id,
1665             rule_number,
1666             protocol,
1667             rule_action,
1668             cidr_block,
1669             egress=egress,
1670             icmp_code=icmp_code,
1671             icmp_type=icmp_type,
1672             port_range_from=port_range_from,
1673             port_range_to=port_range_to,
1674         )
1675         if created:
1676             log.info("Network ACL entry was %s", rkey)
1677         else:
1678             log.warning("Network ACL entry was not %s", rkey)
1679         return {rkey: created}
1680     except BotoServerError as e:
1681         return {rkey: False, "error": __utils__["boto.get_error"](e)}
1682 def create_network_acl_entry(
1683     network_acl_id=None,
1684     rule_number=None,
1685     protocol=None,
1686     rule_action=None,
1687     cidr_block=None,
1688     egress=None,
1689     network_acl_name=None,
1690     icmp_code=None,
1691     icmp_type=None,
1692     port_range_from=None,
1693     port_range_to=None,
1694     region=None,
1695     key=None,
1696     keyid=None,
1697     profile=None,
1698 ):
1699     kwargs = locals()
1700     return _create_network_acl_entry(**kwargs)
1701 def replace_network_acl_entry(
1702     network_acl_id=None,
1703     rule_number=None,
1704     protocol=None,
1705     rule_action=None,
1706     cidr_block=None,
1707     egress=None,
1708     network_acl_name=None,
1709     icmp_code=None,
1710     icmp_type=None,
1711     port_range_from=None,
1712     port_range_to=None,
1713     region=None,
1714     key=None,
1715     keyid=None,
1716     profile=None,
1717 ):
1718     kwargs = locals()
1719     return _create_network_acl_entry(replace=True, **kwargs)
1720 def delete_network_acl_entry(
1721     network_acl_id=None,
1722     rule_number=None,
1723     egress=None,
1724     network_acl_name=None,
1725     region=None,
1726     key=None,
1727     keyid=None,
1728     profile=None,
1729 ):
1730     if not _exactly_one((network_acl_name, network_acl_id)):
1731         raise SaltInvocationError(
1732             "One (but not both) of network_acl_id or network_acl_name must be provided."
1733         )
1734     for v in ("rule_number", "egress"):
1735         if locals()[v] is None:
1736             raise SaltInvocationError("{} is required.".format(v))
1737     if network_acl_name:
1738         network_acl_id = _get_resource_id(
1739             "network_acl",
1740             network_acl_name,
1741             region=region,
1742             key=key,
1743             keyid=keyid,
1744             profile=profile,
1745         )
1746     if not network_acl_id:
1747         return {
1748             "deleted": False,
1749             "error": {
1750                 "message": "Network ACL {} does not exist.".format(
1751                     network_acl_name or network_acl_id
1752                 )
1753             },
1754         }
1755     try:
1756         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1757         deleted = conn.delete_network_acl_entry(
1758             network_acl_id, rule_number, egress=egress
1759         )
1760         if deleted:
1761             log.info("Network ACL entry was deleted")
1762         else:
1763             log.warning("Network ACL was not deleted")
1764         return {"deleted": deleted}
1765     except BotoServerError as e:
1766         return {"deleted": False, "error": __utils__["boto.get_error"](e)}
1767 def create_route_table(
1768     vpc_id=None,
1769     vpc_name=None,
1770     route_table_name=None,
1771     tags=None,
1772     region=None,
1773     key=None,
1774     keyid=None,
1775     profile=None,
1776 ):
1777     vpc_id = check_vpc(vpc_id, vpc_name, region, key, keyid, profile)
1778     if not vpc_id:
1779         return {
1780             "created": False,
1781             "error": {"message": "VPC {} does not exist.".format(vpc_name or vpc_id)},
1782         }
1783     return _create_resource(
1784         "route_table",
1785         route_table_name,
1786         tags=tags,
1787         vpc_id=vpc_id,
1788         region=region,
1789         key=key,
1790         keyid=keyid,
1791         profile=profile,
1792     )
1793 def delete_route_table(
1794     route_table_id=None,
1795     route_table_name=None,
1796     region=None,
1797     key=None,
1798     keyid=None,
1799     profile=None,
1800 ):
1801     return _delete_resource(
1802         resource="route_table",
1803         name=route_table_name,
1804         resource_id=route_table_id,
1805         region=region,
1806         key=key,
1807         keyid=keyid,
1808         profile=profile,
1809     )
1810 def route_table_exists(
1811     route_table_id=None,
1812     name=None,
1813     route_table_name=None,
1814     tags=None,
1815     region=None,
1816     key=None,
1817     keyid=None,
1818     profile=None,
1819 ):
1820     if name:
1821         log.warning(
1822             "boto_vpc.route_table_exists: name parameter is deprecated "
1823             "use route_table_name instead."
1824         )
1825         route_table_name = name
1826     return resource_exists(
1827         "route_table",
1828         name=route_table_name,
1829         resource_id=route_table_id,
1830         tags=tags,
1831         region=region,
1832         key=key,
1833         keyid=keyid,
1834         profile=profile,
1835     )
1836 def route_exists(
1837     destination_cidr_block,
1838     route_table_name=None,
1839     route_table_id=None,
1840     gateway_id=None,
1841     instance_id=None,
1842     interface_id=None,
1843     tags=None,
1844     region=None,
1845     key=None,
1846     keyid=None,
1847     profile=None,
1848     vpc_peering_connection_id=None,
1849 ):
1850     if not any((route_table_name, route_table_id)):
1851         raise SaltInvocationError(
1852             "At least one of the following must be specified: route table name or route"
1853             " table id."
1854         )
1855     if not any((gateway_id, instance_id, interface_id, vpc_peering_connection_id)):
1856         raise SaltInvocationError(
1857             "At least one of the following must be specified: gateway id, instance id, "
1858             "interface id or VPC peering connection id."
1859         )
1860     try:
1861         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1862         filter_parameters = {"filters": {}}
1863         if route_table_id:
1864             filter_parameters["route_table_ids"] = [route_table_id]
1865         if route_table_name:
1866             filter_parameters["filters"]["tag:Name"] = route_table_name
1867         if tags:
1868             for tag_name, tag_value in tags.items():
1869                 filter_parameters["filters"]["tag:{}".format(tag_name)] = tag_value
1870         route_tables = conn.get_all_route_tables(**filter_parameters)
1871         if len(route_tables) != 1:
1872             raise SaltInvocationError("Found more than one route table.")
1873         route_check = {
1874             "destination_cidr_block": destination_cidr_block,
1875             "gateway_id": gateway_id,
1876             "instance_id": instance_id,
1877             "interface_id": interface_id,
1878             "vpc_peering_connection_id": vpc_peering_connection_id,
1879         }
1880         for route_match in route_tables[0].routes:
1881             route_dict = {
1882                 "destination_cidr_block": route_match.destination_cidr_block,
1883                 "gateway_id": route_match.gateway_id,
1884                 "instance_id": route_match.instance_id,
1885                 "interface_id": route_match.interface_id,
1886                 "vpc_peering_connection_id": vpc_peering_connection_id,
1887             }
1888             route_comp = set(route_dict.items()) ^ set(route_check.items())
1889             if not route_comp:
1890                 log.info("Route %s exists.", destination_cidr_block)
1891                 return {"exists": True}
1892         log.warning("Route %s does not exist.", destination_cidr_block)
1893         return {"exists": False}
1894     except BotoServerError as e:
1895         return {"error": __utils__["boto.get_error"](e)}
1896 def associate_route_table(
1897     route_table_id=None,
1898     subnet_id=None,
1899     route_table_name=None,
1900     subnet_name=None,
1901     region=None,
1902     key=None,
1903     keyid=None,
1904     profile=None,
1905 ):
1906     if all((subnet_id, subnet_name)):
1907         raise SaltInvocationError(
1908             "Only one of subnet_name or subnet_id may be provided."
1909         )
1910     if subnet_name:
1911         subnet_id = _get_resource_id(
1912             "subnet", subnet_name, region=region, key=key, keyid=keyid, profile=profile
1913         )
1914         if not subnet_id:
1915             return {
1916                 "associated": False,
1917                 "error": {"message": "Subnet {} does not exist.".format(subnet_name)},
1918             }
1919     if all((route_table_id, route_table_name)):
1920         raise SaltInvocationError(
1921             "Only one of route_table_name or route_table_id may be provided."
1922         )
1923     if route_table_name:
1924         route_table_id = _get_resource_id(
1925             "route_table",
1926             route_table_name,
1927             region=region,
1928             key=key,
1929             keyid=keyid,
1930             profile=profile,
1931         )
1932         if not route_table_id:
1933             return {
1934                 "associated": False,
1935                 "error": {
1936                     "message": "Route table {} does not exist.".format(route_table_name)
1937                 },
1938             }
1939     try:
1940         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1941         association_id = conn.associate_route_table(route_table_id, subnet_id)
1942         log.info(
1943             "Route table %s was associated with subnet %s", route_table_id, subnet_id
1944         )
1945         return {"association_id": association_id}
1946     except BotoServerError as e:
1947         return {"associated": False, "error": __utils__["boto.get_error"](e)}
1948 def disassociate_route_table(
1949     association_id, region=None, key=None, keyid=None, profile=None
1950 ):
1951     try:
1952         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1953         if conn.disassociate_route_table(association_id):
1954             log.info(
1955                 "Route table with association id %s has been disassociated.",
1956                 association_id,
1957             )
1958             return {"disassociated": True}
1959         else:
1960             log.warning(
1961                 "Route table with association id %s has not been disassociated.",
1962                 association_id,
1963             )
1964             return {"disassociated": False}
1965     except BotoServerError as e:
1966         return {"disassociated": False, "error": __utils__["boto.get_error"](e)}
1967 def replace_route_table_association(
1968     association_id, route_table_id, region=None, key=None, keyid=None, profile=None
1969 ):
1970     try:
1971         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
1972         association_id = conn.replace_route_table_association_with_assoc(
1973             association_id, route_table_id
1974         )
1975         log.info(
1976             "Route table %s was reassociated with association id %s",
1977             route_table_id,
1978             association_id,
1979         )
1980         return {"replaced": True, "association_id": association_id}
1981     except BotoServerError as e:
1982         return {"replaced": False, "error": __utils__["boto.get_error"](e)}
1983 def create_route(
1984     route_table_id=None,
1985     destination_cidr_block=None,
1986     route_table_name=None,
1987     gateway_id=None,
1988     internet_gateway_name=None,
1989     instance_id=None,
1990     interface_id=None,
1991     vpc_peering_connection_id=None,
1992     vpc_peering_connection_name=None,
1993     region=None,
1994     key=None,
1995     keyid=None,
1996     profile=None,
1997     nat_gateway_id=None,
1998     nat_gateway_subnet_name=None,
1999     nat_gateway_subnet_id=None,
2000 ):
2001     if not _exactly_one((route_table_name, route_table_id)):
2002         raise SaltInvocationError(
2003             "One (but not both) of route_table_id or route_table_name must be provided."
2004         )
2005     if not _exactly_one(
2006         (
2007             gateway_id,
2008             internet_gateway_name,
2009             instance_id,
2010             interface_id,
2011             vpc_peering_connection_id,
2012             nat_gateway_id,
2013             nat_gateway_subnet_id,
2014             nat_gateway_subnet_name,
2015             vpc_peering_connection_name,
2016         )
2017     ):
2018         raise SaltInvocationError(
2019             "Only one of gateway_id, internet_gateway_name, instance_id, interface_id,"
2020             " vpc_peering_connection_id, nat_gateway_id, nat_gateway_subnet_id,"
2021             " nat_gateway_subnet_name or vpc_peering_connection_name may be provided."
2022         )
2023     if destination_cidr_block is None:
2024         raise SaltInvocationError("destination_cidr_block is required.")
2025     try:
2026         if route_table_name:
2027             route_table_id = _get_resource_id(
2028                 "route_table",
2029                 route_table_name,
2030                 region=region,
2031                 key=key,
2032                 keyid=keyid,
2033                 profile=profile,
2034             )
2035             if not route_table_id:
2036                 return {
2037                     "created": False,
2038                     "error": {
2039                         "message": "route table {} does not exist.".format(
2040                             route_table_name
2041                         )
2042                     },
2043                 }
2044         if internet_gateway_name:
2045             gateway_id = _get_resource_id(
2046                 "internet_gateway",
2047                 internet_gateway_name,
2048                 region=region,
2049                 key=key,
2050                 keyid=keyid,
2051                 profile=profile,
2052             )
2053             if not gateway_id:
2054                 return {
2055                     "created": False,
2056                     "error": {
2057                         "message": "internet gateway {} does not exist.".format(
2058                             internet_gateway_name
2059                         )
2060                     },
2061                 }
2062         if vpc_peering_connection_name:
2063             vpc_peering_connection_id = _get_resource_id(
2064                 "vpc_peering_connection",
2065                 vpc_peering_connection_name,
2066                 region=region,
2067                 key=key,
2068                 keyid=keyid,
2069                 profile=profile,
2070             )
2071             if not vpc_peering_connection_id:
2072                 return {
2073                     "created": False,
2074                     "error": {
2075                         "message": "VPC peering connection {} does not exist.".format(
2076                             vpc_peering_connection_name
2077                         )
2078                     },
2079                 }
2080         if nat_gateway_subnet_name:
2081             gws = describe_nat_gateways(
2082                 subnet_name=nat_gateway_subnet_name,
2083                 region=region,
2084                 key=key,
2085                 keyid=keyid,
2086                 profile=profile,
2087             )
2088             if not gws:
2089                 return {
2090                     "created": False,
2091                     "error": {
2092                         "message": "nat gateway for {} does not exist.".format(
2093                             nat_gateway_subnet_name
2094                         )
2095                     },
2096                 }
2097             nat_gateway_id = gws[0]["NatGatewayId"]
2098         if nat_gateway_subnet_id:
2099             gws = describe_nat_gateways(
2100                 subnet_id=nat_gateway_subnet_id,
2101                 region=region,
2102                 key=key,
2103                 keyid=keyid,
2104                 profile=profile,
2105             )
2106             if not gws:
2107                 return {
2108                     "created": False,
2109                     "error": {
2110                         "message": "nat gateway for {} does not exist.".format(
2111                             nat_gateway_subnet_id
2112                         )
2113                     },
2114                 }
2115             nat_gateway_id = gws[0]["NatGatewayId"]
2116     except BotoServerError as e:
2117         return {"created": False, "error": __utils__["boto.get_error"](e)}
2118     if not nat_gateway_id:
2119         return _create_resource(
2120             "route",
2121             route_table_id=route_table_id,
2122             destination_cidr_block=destination_cidr_block,
2123             gateway_id=gateway_id,
2124             instance_id=instance_id,
2125             interface_id=interface_id,
2126             vpc_peering_connection_id=vpc_peering_connection_id,
2127             region=region,
2128             key=key,
2129             keyid=keyid,
2130             profile=profile,
2131         )
2132     try:
2133         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2134         ret = conn3.create_route(
2135             RouteTableId=route_table_id,
2136             DestinationCidrBlock=destination_cidr_block,
2137             NatGatewayId=nat_gateway_id,
2138         )
2139         return {"created": True, "id": ret.get("NatGatewayId")}
2140     except BotoServerError as e:
2141         return {"created": False, "error": __utils__["boto.get_error"](e)}
2142 def delete_route(
2143     route_table_id=None,
2144     destination_cidr_block=None,
2145     route_table_name=None,
2146     region=None,
2147     key=None,
2148     keyid=None,
2149     profile=None,
2150 ):
2151     if not _exactly_one((route_table_name, route_table_id)):
2152         raise SaltInvocationError(
2153             "One (but not both) of route_table_id or route_table_name must be provided."
2154         )
2155     if destination_cidr_block is None:
2156         raise SaltInvocationError("destination_cidr_block is required.")
2157     try:
2158         if route_table_name:
2159             route_table_id = _get_resource_id(
2160                 "route_table",
2161                 route_table_name,
2162                 region=region,
2163                 key=key,
2164                 keyid=keyid,
2165                 profile=profile,
2166             )
2167             if not route_table_id:
2168                 return {
2169                     "created": False,
2170                     "error": {
2171                         "message": "route table {} does not exist.".format(
2172                             route_table_name
2173                         )
2174                     },
2175                 }
2176     except BotoServerError as e:
2177         return {"created": False, "error": __utils__["boto.get_error"](e)}
2178     return _delete_resource(
2179         resource="route",
2180         resource_id=route_table_id,
2181         destination_cidr_block=destination_cidr_block,
2182         region=region,
2183         key=key,
2184         keyid=keyid,
2185         profile=profile,
2186     )
2187 def replace_route(
2188     route_table_id=None,
2189     destination_cidr_block=None,
2190     route_table_name=None,
2191     gateway_id=None,
2192     instance_id=None,
2193     interface_id=None,
2194     region=None,
2195     key=None,
2196     keyid=None,
2197     profile=None,
2198     vpc_peering_connection_id=None,
2199 ):
2200     if not _exactly_one((route_table_name, route_table_id)):
2201         raise SaltInvocationError(
2202             "One (but not both) of route_table_id or route_table_name must be provided."
2203         )
2204     if destination_cidr_block is None:
2205         raise SaltInvocationError("destination_cidr_block is required.")
2206     try:
2207         if route_table_name:
2208             route_table_id = _get_resource_id(
2209                 "route_table",
2210                 route_table_name,
2211                 region=region,
2212                 key=key,
2213                 keyid=keyid,
2214                 profile=profile,
2215             )
2216             if not route_table_id:
2217                 return {
2218                     "replaced": False,
2219                     "error": {
2220                         "message": "route table {} does not exist.".format(
2221                             route_table_name
2222                         )
2223                     },
2224                 }
2225         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
2226         if conn.replace_route(
2227             route_table_id,
2228             destination_cidr_block,
2229             gateway_id=gateway_id,
2230             instance_id=instance_id,
2231             interface_id=interface_id,
2232             vpc_peering_connection_id=vpc_peering_connection_id,
2233         ):
2234             log.info(
2235                 "Route with cidr block %s on route table %s was replaced",
2236                 route_table_id,
2237                 destination_cidr_block,
2238             )
2239             return {"replaced": True}
2240         else:
2241             log.warning(
2242                 "Route with cidr block %s on route table %s was not replaced",
2243                 route_table_id,
2244                 destination_cidr_block,
2245             )
2246             return {"replaced": False}
2247     except BotoServerError as e:
2248         return {"replaced": False, "error": __utils__["boto.get_error"](e)}
2249 def describe_route_tables(
2250     route_table_id=None,
2251     route_table_name=None,
2252     vpc_id=None,
2253     tags=None,
2254     region=None,
2255     key=None,
2256     keyid=None,
2257     profile=None,
2258 ):
2259     if not any((route_table_id, route_table_name, tags, vpc_id)):
2260         raise SaltInvocationError(
2261             "At least one of the following must be specified: "
2262             "route table id, route table name, vpc_id, or tags."
2263         )
2264     try:
2265         conn3 = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2266         filter_parameters = {"Filters": []}
2267         if route_table_id:
2268             filter_parameters["RouteTableIds"] = [route_table_id]
2269         if vpc_id:
2270             filter_parameters["Filters"].append({"Name": "vpc-id", "Values": [vpc_id]})
2271         if route_table_name:
2272             filter_parameters["Filters"].append(
2273                 {"Name": "tag:Name", "Values": [route_table_name]}
2274             )
2275         if tags:
2276             for tag_name, tag_value in tags.items():
2277                 filter_parameters["Filters"].append(
2278                     {"Name": "tag:{}".format(tag_name), "Values": [tag_value]}
2279                 )
2280         route_tables = conn3.describe_route_tables(**filter_parameters).get(
2281             "RouteTables", []
2282         )
2283         if not route_tables:
2284             return []
2285         tables = []
2286         keys = {
2287             "id": "RouteTableId",
2288             "vpc_id": "VpcId",
2289             "tags": "Tags",
2290             "routes": "Routes",
2291             "associations": "Associations",
2292         }
2293         route_keys = {
2294             "destination_cidr_block": "DestinationCidrBlock",
2295             "gateway_id": "GatewayId",
2296             "instance_id": "Instance",
2297             "interface_id": "NetworkInterfaceId",
2298             "nat_gateway_id": "NatGatewayId",
2299             "vpc_peering_connection_id": "VpcPeeringConnectionId",
2300         }
2301         assoc_keys = {
2302             "id": "RouteTableAssociationId",
2303             "main": "Main",
2304             "route_table_id": "RouteTableId",
2305             "SubnetId": "subnet_id",
2306         }
2307         for item in route_tables:
2308             route_table = {}
2309             for outkey, inkey in keys.items():
2310                 if inkey in item:
2311                     if outkey == "routes":
2312                         route_table[outkey] = _key_remap(inkey, route_keys, item)
2313                     elif outkey == "associations":
2314                         route_table[outkey] = _key_remap(inkey, assoc_keys, item)
2315                     elif outkey == "tags":
2316                         route_table[outkey] = {}
2317                         for tagitem in item.get(inkey, []):
2318                             route_table[outkey][tagitem.get("Key")] = tagitem.get(
2319                                 "Value"
2320                             )
2321                     else:
2322                         route_table[outkey] = item.get(inkey)
2323             tables.append(route_table)
2324         return tables
2325     except BotoServerError as e:
2326         return {"error": __utils__["boto.get_error"](e)}
2327 def _create_dhcp_options(
2328     conn,
2329     domain_name=None,
2330     domain_name_servers=None,
2331     ntp_servers=None,
2332     netbios_name_servers=None,
2333     netbios_node_type=None,
2334 ):
2335     return conn.create_dhcp_options(
2336         domain_name=domain_name,
2337         domain_name_servers=domain_name_servers,
2338         ntp_servers=ntp_servers,
2339         netbios_name_servers=netbios_name_servers,
2340         netbios_node_type=netbios_node_type,
2341     )
2342 def _maybe_set_name_tag(name, obj):
2343     if name:
2344         obj.add_tag("Name", name)
2345         log.debug("%s is now named as %s", obj, name)
2346 def _maybe_set_tags(tags, obj):
2347     if tags:
2348         try:
2349             obj.add_tags(tags)
2350         except AttributeError:
2351             for tag, value in tags.items():
2352                 obj.add_tag(tag, value)
2353         log.debug("The following tags: %s were added to %s", ", ".join(tags), obj)
2354 def _maybe_set_dns(conn, vpcid, dns_support, dns_hostnames):
2355     if dns_support:
2356         conn.modify_vpc_attribute(vpc_id=vpcid, enable_dns_support=dns_support)
2357         log.debug("DNS support was set to: %s on vpc %s", dns_support, vpcid)
2358     if dns_hostnames:
2359         conn.modify_vpc_attribute(vpc_id=vpcid, enable_dns_hostnames=dns_hostnames)
2360         log.debug("DNS hostnames was set to: %s on vpc %s", dns_hostnames, vpcid)
2361 def _maybe_name_route_table(conn, vpcid, vpc_name):
2362     route_tables = conn.get_all_route_tables(filters={"vpc_id": vpcid})
2363     if not route_tables:
2364         log.warning("no default route table found")
2365         return
2366     default_table = None
2367     for table in route_tables:
2368         for association in getattr(table, "associations", {}):
2369             if getattr(association, "main", False):
2370                 default_table = table
2371                 break
2372     if not default_table:
2373         log.warning("no default route table found")
2374         return
2375     name = "{}-default-table".format(vpc_name)
2376     _maybe_set_name_tag(name, default_table)
2377     log.debug("Default route table name was set to: %s on vpc %s", name, vpcid)
2378 def _key_iter(key, keys, item):
2379     elements_list = []
2380     for r_item in getattr(item, key):
2381         element = {}
2382         for r_key in keys:
2383             if hasattr(r_item, r_key):
2384                 element[r_key] = getattr(r_item, r_key)
2385         elements_list.append(element)
2386     return elements_list
2387 def _key_remap(key, keys, item):
2388     elements_list = []
2389     for r_item in item.get(key, []):
2390         element = {}
2391         for r_outkey, r_inkey in keys.items():
2392             if r_inkey in r_item:
2393                 element[r_outkey] = r_item.get(r_inkey)
2394         elements_list.append(element)
2395     return elements_list
2396 def _get_subnet_explicit_route_table(
2397     subnet_id, vpc_id, conn=None, region=None, key=None, keyid=None, profile=None
2398 ):
2399     if not conn:
2400         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
2401     if conn:
2402         vpc_route_tables = conn.get_all_route_tables(filters={"vpc_id": vpc_id})
2403         for vpc_route_table in vpc_route_tables:
2404             for rt_association in vpc_route_table.associations:
2405                 if rt_association.subnet_id == subnet_id and not rt_association.main:
2406                     return rt_association.id
2407     return None
2408 def request_vpc_peering_connection(
2409     requester_vpc_id=None,
2410     requester_vpc_name=None,
2411     peer_vpc_id=None,
2412     peer_vpc_name=None,
2413     name=None,
2414     peer_owner_id=None,
2415     peer_region=None,
2416     region=None,
2417     key=None,
2418     keyid=None,
2419     profile=None,
2420     dry_run=False,
2421 ):
2422     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2423     if name and _vpc_peering_conn_id_for_name(name, conn):
2424         raise SaltInvocationError(
2425             "A VPC peering connection with this name already "
2426             "exists! Please specify a different name."
2427         )
2428     if not _exactly_one((requester_vpc_id, requester_vpc_name)):
2429         raise SaltInvocationError(
2430             "Exactly one of requester_vpc_id or requester_vpc_name is required"
2431         )
2432     if not _exactly_one((peer_vpc_id, peer_vpc_name)):
2433         raise SaltInvocationError(
2434             "Exactly one of peer_vpc_id or peer_vpc_name is required."
2435         )
2436     if requester_vpc_name:
2437         requester_vpc_id = _get_id(
2438             vpc_name=requester_vpc_name,
2439             region=region,
2440             key=key,
2441             keyid=keyid,
2442             profile=profile,
2443         )
2444         if not requester_vpc_id:
2445             return {
2446                 "error": "Could not resolve VPC name {} to an ID".format(
2447                     requester_vpc_name
2448                 )
2449             }
2450     if peer_vpc_name:
2451         peer_vpc_id = _get_id(
2452             vpc_name=peer_vpc_name, region=region, key=key, keyid=keyid, profile=profile
2453         )
2454         if not peer_vpc_id:
2455             return {
2456                 "error": "Could not resolve VPC name {} to an ID".format(peer_vpc_name)
2457             }
2458     peering_params = {
2459         "VpcId": requester_vpc_id,
2460         "PeerVpcId": peer_vpc_id,
2461         "DryRun": dry_run,
2462     }
2463     if peer_owner_id:
2464         peering_params.update({"PeerOwnerId": peer_owner_id})
2465     if peer_region:
2466         peering_params.update({"PeerRegion": peer_region})
2467     try:
2468         log.debug("Trying to request vpc peering connection")
2469         if not peer_owner_id:
2470             vpc_peering = conn.create_vpc_peering_connection(**peering_params)
2471         else:
2472             vpc_peering = conn.create_vpc_peering_connection(**peering_params)
2473         peering = vpc_peering.get("VpcPeeringConnection", {})
2474         peering_conn_id = peering.get("VpcPeeringConnectionId", "ERROR")
2475         msg = "VPC peering {} requested.".format(peering_conn_id)
2476         log.debug(msg)
2477         if name:
2478             log.debug("Adding name tag to vpc peering connection")
2479             conn.create_tags(
2480                 Resources=[peering_conn_id], Tags=[{"Key": "Name", "Value": name}]
2481             )
2482             log.debug("Applied name tag to vpc peering connection")
2483             msg += " With name {}.".format(name)
2484         return {"msg": msg}
2485     except botocore.exceptions.ClientError as err:
2486         log.error("Got an error while trying to request vpc peering")
2487         return {"error": __utils__["boto.get_error"](err)}
2488 def _get_peering_connection_ids(name, conn):
2489     filters = [
2490         {"Name": "tag:Name", "Values": [name]},
2491         {"Name": "status-code", "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING]},
2492     ]
2493     peerings = conn.describe_vpc_peering_connections(Filters=filters).get(
2494         "VpcPeeringConnections", []
2495     )
2496     return [x["VpcPeeringConnectionId"] for x in peerings]
2497 def describe_vpc_peering_connection(
2498     name, region=None, key=None, keyid=None, profile=None
2499 ):
2500     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2501     return {"VPC-Peerings": _get_peering_connection_ids(name, conn)}
2502 def accept_vpc_peering_connection(  # pylint: disable=too-many-arguments
2503     conn_id="", name="", region=None, key=None, keyid=None, profile=None, dry_run=False
2504 ):
2505     if not _exactly_one((conn_id, name)):
2506         raise SaltInvocationError(
2507             "One (but not both) of vpc_peering_connection_id or name must be provided."
2508         )
2509     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2510     if name:
2511         conn_id = _vpc_peering_conn_id_for_name(name, conn)
2512         if not conn_id:
2513             raise SaltInvocationError(
2514                 "No ID found for this "
2515                 "VPC peering connection! ({}) "
2516                 "Please make sure this VPC peering "
2517                 "connection exists "
2518                 "or invoke this function with "
2519                 "a VPC peering connection "
2520                 "ID".format(name)
2521             )
2522     try:
2523         log.debug("Trying to accept vpc peering connection")
2524         conn.accept_vpc_peering_connection(
2525             DryRun=dry_run, VpcPeeringConnectionId=conn_id
2526         )
2527         return {"msg": "VPC peering connection accepted."}
2528     except botocore.exceptions.ClientError as err:
2529         log.error("Got an error while trying to accept vpc peering")
2530         return {"error": __utils__["boto.get_error"](err)}
2531 def _vpc_peering_conn_id_for_name(name, conn):
2532     log.debug("Retrieving VPC peering connection id")
2533     ids = _get_peering_connection_ids(name, conn)
2534     if not ids:
2535         ids = [None]  # Let callers handle the case where we have no id
2536     elif len(ids) &gt; 1:
2537         raise SaltInvocationError(
2538             "Found multiple VPC peering connections "
2539             "with the same name!! "
2540             "Please make sure you have only "
2541             "one VPC peering connection named {} "
2542             "or invoke this function with a VPC "
2543             "peering connection ID".format(name)
2544         )
2545     return ids[0]
2546 def delete_vpc_peering_connection(
2547     conn_id=None,
2548     conn_name=None,
2549     region=None,
2550     key=None,
2551     keyid=None,
2552     profile=None,
2553     dry_run=False,
2554 ):
2555     if not _exactly_one((conn_id, conn_name)):
2556         raise SaltInvocationError(
2557             "Exactly one of conn_id or conn_name must be provided."
2558         )
2559     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2560     if conn_name:
2561         conn_id = _vpc_peering_conn_id_for_name(conn_name, conn)
2562         if not conn_id:
2563             raise SaltInvocationError(
2564                 "Couldn't resolve VPC peering connection {} to an ID".format(conn_name)
2565             )
2566     try:
2567         log.debug("Trying to delete vpc peering connection")
2568         conn.delete_vpc_peering_connection(
2569             DryRun=dry_run, VpcPeeringConnectionId=conn_id
2570         )
2571         return {"msg": "VPC peering connection deleted."}
2572     except botocore.exceptions.ClientError as err:
2573         e = __utils__["boto.get_error"](err)
2574         log.error("Failed to delete VPC peering %s: %s", conn_name or conn_id, e)
2575         return {"error": e}
2576 def is_peering_connection_pending(
2577     conn_id=None, conn_name=None, region=None, key=None, keyid=None, profile=None
2578 ):
2579     if not _exactly_one((conn_id, conn_name)):
2580         raise SaltInvocationError(
2581             "Exactly one of conn_id or conn_name must be provided."
2582         )
2583     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2584     if conn_id:
2585         vpcs = conn.describe_vpc_peering_connections(
2586             VpcPeeringConnectionIds=[conn_id]
2587         ).get("VpcPeeringConnections", [])
2588     else:
2589         filters = [
2590             {"Name": "tag:Name", "Values": [conn_name]},
2591             {
2592                 "Name": "status-code",
2593                 "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING],
2594             },
2595         ]
2596         vpcs = conn.describe_vpc_peering_connections(Filters=filters).get(
2597             "VpcPeeringConnections", []
2598         )
2599     if not vpcs:
2600         return False
2601     elif len(vpcs) &gt; 1:
2602         raise SaltInvocationError(
2603             "Found more than one ID for the VPC peering "
2604             "connection ({}). Please call this function "
2605             "with an ID instead.".format(conn_id or conn_name)
2606         )
2607     else:
2608         status = vpcs[0]["Status"]["Code"]
2609     return status == PENDING_ACCEPTANCE
2610 def peering_connection_pending_from_vpc(
2611     conn_id=None,
2612     conn_name=None,
2613     vpc_id=None,
2614     vpc_name=None,
2615     region=None,
2616     key=None,
2617     keyid=None,
2618     profile=None,
2619 ):
2620     if not _exactly_one((conn_id, conn_name)):
2621         raise SaltInvocationError(
2622             "Exactly one of conn_id or conn_name must be provided."
2623         )
2624     if not _exactly_one((vpc_id, vpc_name)):
2625         raise SaltInvocationError("Exactly one of vpc_id or vpc_name must be provided.")
2626     if vpc_name:
2627         vpc_id = check_vpc(
2628             vpc_name=vpc_name, region=region, key=key, keyid=keyid, profile=profile
2629         )
2630         if not vpc_id:
2631             log.warning("Could not resolve VPC name %s to an ID", vpc_name)
2632             return False
2633     conn = _get_conn3(region=region, key=key, keyid=keyid, profile=profile)
2634     filters = [
2635         {"Name": "requester-vpc-info.vpc-id", "Values": [vpc_id]},
2636         {"Name": "status-code", "Values": [ACTIVE, PENDING_ACCEPTANCE, PROVISIONING]},
2637     ]
2638     if conn_id:
2639         filters += [{"Name": "vpc-peering-connection-id", "Values": [conn_id]}]
2640     else:
2641         filters += [{"Name": "tag:Name", "Values": [conn_name]}]
2642     vpcs = conn.describe_vpc_peering_connections(Filters=filters).get(
2643         "VpcPeeringConnections", []
2644     )
2645     if not vpcs:
2646         return False
2647     elif len(vpcs) &gt; 1:
2648         raise SaltInvocationError(
2649             "Found more than one ID for the VPC peering "
2650             "connection ({}). Please call this function "
2651             "with an ID instead.".format(conn_id or conn_name)
2652         )
2653     else:
2654         status = vpcs[0]["Status"]["Code"]
2655     return bool(status == PENDING_ACCEPTANCE)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
