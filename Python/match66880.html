<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for naver.py &amp; hotstar.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for naver.py &amp; hotstar.py
      </h3>
<h1 align="center">
        10.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>naver.py (12.711864%)<th>hotstar.py (8.67052%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(158-163)<td><a href="#" name="0">(213-219)</a><td align="center"><font color="#ff0000">16</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(110-144)<td><a href="#" name="1">(226-246)</a><td align="center"><font color="#df0000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>naver.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 from .common import InfoExtractor
4 from ..utils import (
5     clean_html,
6     dict_get,
7     ExtractorError,
8     int_or_none,
9     parse_duration,
10     try_get,
11     update_url_query,
12 )
13 class NaverBaseIE(InfoExtractor):
14     _CAPTION_EXT_RE = r'\.(?:ttml|vtt)'
15     def _extract_video_info(self, video_id, vid, key):
16         video_data = self._download_json(
17             'http://play.rmcnmv.naver.com/vod/play/v2.0/' + vid,
18             video_id, query={
19                 'key': key,
20             })
21         meta = video_data['meta']
22         title = meta['subject']
23         formats = []
24         get_list = lambda x: try_get(video_data, lambda y: y[x + 's']['list'], list) or []
25         def extract_formats(streams, stream_type, query={}):
26             for stream in streams:
27                 stream_url = stream.get('source')
28                 if not stream_url:
29                     continue
30                 stream_url = update_url_query(stream_url, query)
31                 encoding_option = stream.get('encodingOption', {})
32                 bitrate = stream.get('bitrate', {})
33                 formats.append({
34                     'format_id': '%s_%s' % (stream.get('type') or stream_type, dict_get(encoding_option, ('name', 'id'))),
35                     'url': stream_url,
36                     'width': int_or_none(encoding_option.get('width')),
37                     'height': int_or_none(encoding_option.get('height')),
38                     'vbr': int_or_none(bitrate.get('video')),
39                     'abr': int_or_none(bitrate.get('audio')),
40                     'filesize': int_or_none(stream.get('size')),
41                     'protocol': 'm3u8_native' if stream_type == 'HLS' else None,
42                 })
43         extract_formats(get_list('video'), 'H264')
44         for stream_set in video_data.get('streams', []):
45             query = {}
46             for param in stream_set.get('keys', []):
47                 query[param['name']] = param['value']
48             stream_type = stream_set.get('type')
49             videos = stream_set.get('videos')
50             if videos:
51                 extract_formats(videos, stream_type, query)
52             elif stream_type == 'HLS':
53                 stream_url = stream_set.get('source')
54                 if not stream_url:
55                     continue
56                 formats.extend(self._extract_m3u8_formats(
57                     update_url_query(stream_url, query), video_id,
58                     'mp4', 'm3u8_native', m3u8_id=stream_type, fatal=False))
59         self._sort_formats(formats)
60         replace_ext = lambda x, y: re.sub(self._CAPTION_EXT_RE, '.' + y, x)
61         def get_subs(caption_url):
62             if re.search(self._CAPTION_EXT_RE, caption_url):
63                 return [{
64                     'url': replace_ext(caption_url, 'ttml'),
65                 }, {
66                     'url': replace_ext(caption_url, 'vtt'),
67                 }]
68             else:
69                 return [{'url': caption_url}]
70         automatic_captions = {}
71         subtitles = {}
72         for caption in get_list('caption'):
73             caption_url = caption.get('source')
74             if not caption_url:
75                 continue
76             sub_dict = automatic_captions if caption.get('type') == 'auto' else subtitles
77             sub_dict.setdefault(dict_get(caption, ('locale', 'language')), []).extend(get_subs(caption_url))
78         user = meta.get('user', {})
79         return {
80             'id': video_id,
81             'title': title,
82             'formats': formats,
83             'subtitles': subtitles,
84             'automatic_captions': automatic_captions,
85             'thumbnail': try_get(meta, lambda x: x['cover']['source']),
86             'view_count': int_or_none(meta.get('count')),
87             'uploader_id': user.get('id'),
88             'uploader': user.get('name'),
89             'uploader_url': user.get('url'),
90         }
91 class NaverIE(NaverBaseIE):
92 <a name="1"></a>    _VALID_URL = r'https?://(?:m\.)?tv(?:cast)?\.naver\.com/(?:v|embed)/(?P&lt;id&gt;\d+)'
93     _GEO_BYPASS = False
94     _TESTS = [{
95         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'url': 'http://tv.naver.com/v/81652',
96         'info_dict': {
97             'id': '81652',
98             'ext': 'mp4',
99             'title': '[9월 모의고사 해설강의][수학_김상희] 수학 A형 16~20번',
100             'description': '메가스터디 수학 김상희 선생님이 9월 모의고사 수학A형 16번에서 20번까지 해설강의를 공개합니다.',
101             'timestamp': 1378200754,
102             'upload_date': '20130903',
103             'uploader': '메가스터디, 합격불변의 법칙',
104             'uploader_id': 'megastudy',
105         },
106     }, {
107         'url': 'http://tv.naver.com/v/395837',
108         'md5': '8a38e35354d26a17f73f4e90094febd3',
109         'info_dict': {
110             'id': '395837',
111             'ext': 'mp4',
112             'title': '9년이 지나도 아픈 기억, 전효성의 아버지',
113             'description': 'md5:eb6aca9d457b922e43860a2a2b1984d3',
114             'timestamp': 1432030253,
115             'upload_date': '20150519',
116             'uploader': '4가지쇼 시즌2',
117             'uploader_id': 'wrappinguser29',
118         },
119         'skip': 'Georestricted',
120     }, {
121         'url': 'http://tvcast.naver.com/v/81652',
122         'only_matching': True,
123     }]
124     def _real_extract(self, url):
125         video_id = self._match_id(url)
126         content = self._download_json(
127             'https://tv.naver.com/api/json/v/' + video_id,
128             video_id, headers=self.</b></font>geo_verification_headers())
129         player_info_json = content.get('playerInfoJson') or {}
130         current_clip = player_info_json.get('currentClip') or {}
131         vid = current_clip.get('videoId')
132         in_key = current_clip.get('inKey')
133         if not vid or not in_key:
134             player_auth = try_get(player_info_json, lambda x: x['playerOption']['auth'])
135             if player_auth == 'notCountry':
136                 self.raise_geo_restricted(countries=['KR'])
137 <a name="0"></a>            elif player_auth == 'notLogin':
138                 self.raise_login_required()
139             raise ExtractorError('couldn\'t extract vid and key')
140         info = self._extract_video_info<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(video_id, vid, in_key)
141         info.update({
142             'description': clean_html(current_clip.get('description')),
143             'timestamp': int_or_none(current_clip.get('firstExposureTime'), 1000),
144             'duration': parse_duration(current_clip.get('displayPlayTime')),
145             'like_count': int_or_none(current_clip.get(</b></font>'recommendPoint')),
146             'age_limit': 19 if current_clip.get('adult') else None,
147         })
148         return info
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>hotstar.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import hashlib
3 import hmac
4 import json
5 import re
6 import time
7 import uuid
8 from .common import InfoExtractor
9 from ..compat import (
10     compat_HTTPError,
11     compat_str,
12 )
13 from ..utils import (
14     determine_ext,
15     ExtractorError,
16     int_or_none,
17     str_or_none,
18     try_get,
19     url_or_none,
20 )
21 class HotStarBaseIE(InfoExtractor):
22     _AKAMAI_ENCRYPTION_KEY = b'\x05\xfc\x1a\x01\xca\xc9\x4b\xc4\x12\xfc\x53\x12\x07\x75\xf9\xee'
23     def _call_api_impl(self, path, video_id, headers, query, data=None):
24         st = int(time.time())
25         exp = st + 6000
26         auth = 'st=%d~exp=%d~acl=/*' % (st, exp)
27         auth += '~hmac=' + hmac.new(self._AKAMAI_ENCRYPTION_KEY, auth.encode(), hashlib.sha256).hexdigest()
28         h = {'hotstarauth': auth}
29         h.update(headers)
30         return self._download_json(
31             'https://api.hotstar.com/' + path,
32             video_id, headers=h, query=query, data=data)
33     def _call_api(self, path, video_id, query_name='contentId'):
34         response = self._call_api_impl(path, video_id, {
35             'x-country-code': 'IN',
36             'x-platform-code': 'JIO',
37         }, {
38             query_name: video_id,
39             'tas': 10000,
40         })
41         if response['statusCode'] != 'OK':
42             raise ExtractorError(
43                 response['body']['message'], expected=True)
44         return response['body']['results']
45     def _call_api_v2(self, path, video_id, headers, query=None, data=None):
46         h = {'X-Request-Id': compat_str(uuid.uuid4())}
47         h.update(headers)
48         try:
49             return self._call_api_impl(
50                 path, video_id, h, query, data)
51         except ExtractorError as e:
52             if isinstance(e.cause, compat_HTTPError):
53                 if e.cause.code == 402:
54                     self.raise_login_required()
55                 message = self._parse_json(e.cause.read().decode(), video_id)['message']
56                 if message in ('Content not available in region', 'Country is not supported'):
57                     raise self.raise_geo_restricted(message)
58                 raise ExtractorError(message)
59             raise e
60 class HotStarIE(HotStarBaseIE):
61     IE_NAME = 'hotstar'
62     _VALID_URL = r'https?://(?:www\.)?hotstar\.com/(?:.+[/-])?(?P&lt;id&gt;\d{10})'
63     _TESTS = [{
64         'url': 'https://www.hotstar.com/can-you-not-spread-rumours/1000076273',
65         'info_dict': {
66             'id': '1000076273',
67             'ext': 'mp4',
68             'title': 'Can You Not Spread Rumours?',
69             'description': 'md5:c957d8868e9bc793ccb813691cc4c434',
70             'timestamp': 1447248600,
71             'upload_date': '20151111',
72             'duration': 381,
73         },
74         'params': {
75             'skip_download': True,
76         }
77     }, {
78         'url': 'https://www.hotstar.com/movies/radha-gopalam/1000057157',
79         'only_matching': True,
80     }, {
81         'url': 'http://www.hotstar.com/sports/cricket/rajitha-sizzles-on-debut-with-329/2001477583',
82         'only_matching': True,
83     }, {
84         'url': 'http://www.hotstar.com/1000000515',
85         'only_matching': True,
86     }, {
87         'url': 'https://www.hotstar.com/tv/ek-bhram-sarvagun-sampanna/s-2116/janhvi-targets-suman/1000234847',
88         'only_matching': True,
89     }, {
90         'url': 'https://www.hotstar.com/in/tv/start-music/1260005217/cooks-vs-comalis/1100039717',
91         'only_matching': True,
92     }]
93     _GEO_BYPASS = False
94     _DEVICE_ID = None
95     _USER_TOKEN = None
96     def _real_extract(self, url):
97         video_id = self._match_id(url)
98         webpage = self._download_webpage(url, video_id)
99         app_state = self._parse_json(self._search_regex(
100             r'&lt;script&gt;window\.APP_STATE\s*=\s*({.+?})&lt;/script&gt;',
101             webpage, 'app state'), video_id)
102         video_data = {}
103         getters = list(
104             lambda x, k=k: x['initialState']['content%s' % k]['content']
105             for k in ('Data', 'Detail')
106         )
107         for v in app_state.values():
108             content = try_get(v, getters, dict)
109             if content and content.get('contentId') == video_id:
110                 video_data = content
111                 break
112         title = video_data['title']
113         if video_data.get('drmProtected'):
114             raise ExtractorError('This video is DRM protected.', expected=True)
115         headers = {'Referer': url}
116         formats = []
117         geo_restricted = False
118         if not self._USER_TOKEN:
119             self._DEVICE_ID = compat_str(uuid.uuid4())
120             self._USER_TOKEN = self._call_api_v2('um/v3/users', video_id, {
121                 'X-HS-Platform': 'PCTV',
122                 'Content-Type': 'application/json',
123             }, data=json.dumps({
124                 'device_ids': [{
125                     'id': self._DEVICE_ID,
126                     'type': 'device_id',
127                 }],
128             }).encode())['user_identity']
129         playback_sets = self._call_api_v2(
130             'play/v2/playback/content/' + video_id, video_id, {
131                 'X-HS-Platform': 'web',
132                 'X-HS-AppVersion': '6.99.1',
133                 'X-HS-UserToken': self._USER_TOKEN,
134             }, query={
135                 'device-id': self._DEVICE_ID,
136                 'desired-config': 'encryption:plain',
137                 'os-name': 'Windows',
138                 'os-version': '10',
139             })['data']['playBackSets']
140         for playback_set in playback_sets:
141             if not isinstance(playback_set, dict):
142                 continue
143             format_url = url_or_none(playback_set.get('playbackUrl'))
144             if not format_url:
145                 continue
146             format_url = re.sub(
147                 r'(?&lt;=//staragvod)(\d)', r'web\1', format_url)
148             tags = str_or_none(playback_set.get('tagsCombination')) or ''
149             if tags and 'encryption:plain' not in tags:
150                 continue
151             ext = determine_ext(format_url)
152             try:
153                 if 'package:hls' in tags or ext == 'm3u8':
154                     formats.extend(self._extract_m3u8_formats(
155                         format_url, video_id, 'mp4',
156                         entry_protocol='m3u8_native',
157                         m3u8_id='hls', headers=headers))
158                 elif 'package:dash' in tags or ext == 'mpd':
159                     formats.extend(self._extract_mpd_formats(
160                         format_url, video_id, mpd_id='dash', headers=headers))
161                 elif ext == 'f4m':
162                     pass
163                 else:
164                     formats.append({
165                         'url': format_url,
166                         'width': int_or_none(playback_set.get('width')),
167                         'height': int_or_none(playback_set.get('height')),
168                     })
169             except ExtractorError as e:
170                 if isinstance(e.cause, compat_HTTPError) and e.cause.code == 403:
171                     geo_restricted = True
172                 continue
173         if not formats and geo_restricted:
174             self.raise_geo_restricted(countries=['IN'])
175         self._sort_formats(formats)
176         for f in formats:
177             f.setdefault('http_headers', {}).update(headers)
178         image = try_get(video_data, lambda x: x['image']['h'], compat_str)
179         return {
180             'id': video_id,
181             'title': title,
182             'thumbnail': 'https://img1.hotstarext.com/image/upload/' + image if image else None,
183             'description': video_data.get('description'),
184             'duration': int_or_none(video_data.get('duration')),
185 <a name="0"></a>            'timestamp': int_or_none(video_data.get('broadcastDate') or video_data.get('startDate')),
186             'formats': formats,
187             'channel': video_data.get('channelName'),
188             'channel_id': str_or_none<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(video_data.get('channelId')),
189             'series': video_data.get('showName'),
190             'season': video_data.get('seasonName'),
191             'season_number': int_or_none(video_data.get('seasonNo')),
192             'season_id': str_or_none(video_data.get('seasonId')),
193             'episode': title,
194             'episode_number': int_or_none(video_data.get(</b></font>'episodeNo')),
195         }
196 <a name="1"></a>class HotStarPlaylistIE(HotStarBaseIE):
197     IE_NAME = 'hotstar:playlist'
198     _VALID_URL = r'https?://(?:www\.)?hotstar\.com/(?:[a-z]{2}/)?tv/[^/]+/s-\w+/list/[^/]+/t-(?P&lt;id&gt;\w+)'
199     _TESTS = [<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
200         'url': 'https://www.hotstar.com/tv/savdhaan-india/s-26/list/popular-clips/t-3_2_26',
201         'info_dict': {
202             'id': '3_2_26',
203         },
204         'playlist_mincount': 20,
205     }, {
206         'url': 'https://www.hotstar.com/tv/savdhaan-india/s-26/list/extras/t-2480',
207         'only_matching': True,
208     }, {
209         'url': 'https://www.hotstar.com/us/tv/masterchef-india/s-830/list/episodes/t-1_2_830',
210         'only_matching': True,
211     }]
212     def _real_extract(self, url):
213         playlist_id = self._match_id(url)
214         collection = self._call_api('o/v1/tray/find', playlist_id, 'uqId')
215         entries = [
216             self</b></font>.url_result(
217                 'https://www.hotstar.com/%s' % video['contentId'],
218                 ie=HotStarIE.ie_key(), video_id=video['contentId'])
219             for video in collection['assets']['items']
220             if video.get('contentId')]
221         return self.playlist_result(entries, playlist_id)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
