<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for archive.py &amp; test_file_selinux.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for archive.py &amp; test_file_selinux.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>archive.py (0.97919214%)<th>test_file_selinux.py (11.111111%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(11-26)<td><a href="#" name="0">(1-16)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>archive.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import errno
2 <a name="0"></a>import logging
3 import os
4 import re
5 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import shlex
6 import stat
7 import string
8 import tarfile
9 from contextlib import closing
10 from urllib.parse import urlparse
11 import salt.utils.args
12 import salt.utils.files
13 import salt.utils.hashutils
14 import salt.utils.path
15 import salt.utils.platform
16 import salt.utils.url
17 from salt.exceptions import CommandExecutionError, CommandNotFoundError
18 log = logging.getLogger(</b></font>__name__)
19 def _path_is_abs(path):
20     if path is None:
21         return True
22     try:
23         return os.path.isabs(path)
24     except AttributeError:
25         return False
26 def _add_explanation(ret, source_hash_trigger, contents_missing):
27     if source_hash_trigger:
28         ret["comment"] += ", due to source_hash update"
29     elif contents_missing:
30         ret["comment"] += ", due to absence of one or more files/dirs"
31 def _gen_checksum(path):
32     return {
33         "hsum": salt.utils.hashutils.get_hash(path, form=__opts__["hash_type"]),
34         "hash_type": __opts__["hash_type"],
35     }
36 def _checksum_file_path(path):
37     try:
38         relpath = ".".join((os.path.relpath(path, __opts__["cachedir"]), "hash"))
39         if re.match(r"..[/\\]", relpath):
40             relpath = salt.utils.path.join(
41                 "local",
42                 os.path.splitdrive(path)[-1].lstrip("/\\"),
43             )
44     except ValueError as exc:
45         if str(exc).startswith("path is on"):
46             drive, path = os.path.splitdrive(path)
47             relpath = salt.utils.path.join(
48                 "local",
49                 drive.rstrip(":"),
50                 path.lstrip("/\\"),
51             )
52         elif str(exc).startswith("Cannot mix UNC"):
53             relpath = salt.utils.path.join("unc", path)
54         else:
55             raise
56     ret = salt.utils.path.join(__opts__["cachedir"], "archive_hash", relpath)
57     log.debug("Using checksum file %s for cached archive file %s", ret, path)
58     return ret
59 def _update_checksum(path):
60     checksum_file = _checksum_file_path(path)
61     checksum_dir = os.path.dirname(checksum_file)
62     if not os.path.isdir(checksum_dir):
63         os.makedirs(checksum_dir)
64     source_sum = _gen_checksum(path)
65     hash_type = source_sum.get("hash_type")
66     hsum = source_sum.get("hsum")
67     if hash_type and hsum:
68         lines = []
69         try:
70             try:
71                 with salt.utils.files.fopen(checksum_file, "r") as fp_:
72                     for line in fp_:
73                         try:
74                             lines.append(line.rstrip("\n").split(":", 1))
75                         except ValueError:
76                             continue
77             except OSError as exc:
78                 if exc.errno != errno.ENOENT:
79                     raise
80             with salt.utils.files.fopen(checksum_file, "w") as fp_:
81                 for line in lines:
82                     if line[0] == hash_type:
83                         line[1] = hsum
84                     fp_.write("{}:{}\n".format(*line))
85                 if hash_type not in [x[0] for x in lines]:
86                     fp_.write("{}:{}\n".format(hash_type, hsum))
87         except OSError as exc:
88             log.warning(
89                 "Failed to update checksum for %s: %s",
90                 path,
91                 exc.__str__(),
92                 exc_info=True,
93             )
94 def _read_cached_checksum(path, form=None):
95     if form is None:
96         form = __opts__["hash_type"]
97     checksum_file = _checksum_file_path(path)
98     try:
99         with salt.utils.files.fopen(checksum_file, "r") as fp_:
100             for line in fp_:
101                 hash_type, hsum = line.rstrip("\n").split(":", 1)
102                 if hash_type == form:
103                     break
104             else:
105                 return None
106     except (OSError, ValueError):
107         return None
108     else:
109         return {"hash_type": hash_type, "hsum": hsum}
110 def _compare_checksum(cached, source_sum):
111     cached_sum = _read_cached_checksum(
112         cached, form=source_sum.get("hash_type", __opts__["hash_type"])
113     )
114     return source_sum == cached_sum
115 def _is_bsdtar():
116     return "bsdtar" in __salt__["cmd.run"](["tar", "--version"], python_shell=False)
117 def _cleanup_destdir(name):
118     try:
119         os.rmdir(name)
120     except OSError:
121         pass
122 def extracted(
123     name,
124     source,
125     source_hash=None,
126     source_hash_name=None,
127     source_hash_update=False,
128     skip_files_list_verify=False,
129     skip_verify=False,
130     password=None,
131     options=None,
132     list_options=None,
133     force=False,
134     overwrite=False,
135     clean=False,
136     clean_parent=False,
137     user=None,
138     group=None,
139     if_missing=None,
140     trim_output=False,
141     use_cmd_unzip=None,
142     extract_perms=True,
143     enforce_toplevel=True,
144     enforce_ownership_on=None,
145     archive_format=None,
146     use_etag=False,
147     **kwargs
148 ):
149     ret = {"name": name, "result": False, "changes": {}, "comment": ""}
150     kwargs = salt.utils.args.clean_kwargs(**kwargs)
151     if skip_files_list_verify and skip_verify:
152         ret[
153             "comment"
154         ] = 'Only one of "skip_files_list_verify" and "skip_verify" can be set to True'
155         return ret
156     if "keep_source" in kwargs and "keep" in kwargs:
157         ret.setdefault("warnings", []).append(
158             "Both 'keep_source' and 'keep' were used. Since these both "
159             "do the same thing, 'keep' was ignored."
160         )
161         keep_source = bool(kwargs.pop("keep_source"))
162         kwargs.pop("keep")
163     elif "keep_source" in kwargs:
164         keep_source = bool(kwargs.pop("keep_source"))
165     elif "keep" in kwargs:
166         keep_source = bool(kwargs.pop("keep"))
167     else:
168         keep_source = True
169     if not _path_is_abs(name):
170         ret["comment"] = "{} is not an absolute path".format(name)
171         return ret
172     else:
173         if not name:
174             ret["comment"] = "Name of the directory path needs to be specified"
175             return ret
176         name = name.rstrip(os.sep)
177         if os.path.isfile(name):
178             ret["comment"] = "{} exists and is not a directory".format(name)
179             return ret
180         name += os.sep
181     if not _path_is_abs(if_missing):
182         ret["comment"] = "Value for 'if_missing' is not an absolute path"
183         return ret
184     if not _path_is_abs(enforce_ownership_on):
185         ret["comment"] = "Value for 'enforce_ownership_on' is not an absolute path"
186         return ret
187     else:
188         if enforce_ownership_on is not None:
189             try:
190                 not_rel = os.path.relpath(enforce_ownership_on, name).startswith(
191                     ".." + os.sep
192                 )
193             except Exception:  # pylint: disable=broad-except
194                 not_rel = True
195             if not_rel:
196                 ret[
197                     "comment"
198                 ] = "Value for 'enforce_ownership_on' must be within {}".format(name)
199                 return ret
200     if if_missing is not None and os.path.exists(if_missing):
201         ret["result"] = True
202         ret["comment"] = "Path {} exists".format(if_missing)
203         return ret
204     if user or group:
205         if salt.utils.platform.is_windows():
206             ret[
207                 "comment"
208             ] = "User/group ownership cannot be enforced on Windows minions"
209             return ret
210         if user:
211             uid = __salt__["file.user_to_uid"](user)
212             if uid == "":
213                 ret["comment"] = "User {} does not exist".format(user)
214                 return ret
215         else:
216             uid = -1
217         if group:
218             gid = __salt__["file.group_to_gid"](group)
219             if gid == "":
220                 ret["comment"] = "Group {} does not exist".format(group)
221                 return ret
222         else:
223             gid = -1
224     else:
225         uid = gid = -1
226     if source_hash_update and not source_hash:
227         ret.setdefault("warnings", []).append(
228             "The 'source_hash_update' argument is ignored when "
229             "'source_hash' is not also specified."
230         )
231     try:
232         source_match = __salt__["file.source_list"](source, source_hash, __env__)[0]
233     except CommandExecutionError as exc:
234         ret["result"] = False
235         ret["comment"] = exc.strerror
236         return ret
237     if not source_match:
238         ret["result"] = False
239         ret["comment"] = 'Invalid source "{}"'.format(source)
240         return ret
241     urlparsed_source = urlparse(source_match)
242     urlparsed_scheme = urlparsed_source.scheme
243     urlparsed_path = os.path.join(
244         urlparsed_source.netloc, urlparsed_source.path
245     ).rstrip(os.sep)
246     if urlparsed_scheme and urlparsed_scheme.lower() in string.ascii_lowercase:
247         urlparsed_path = ":".join([urlparsed_scheme, urlparsed_path])
248         urlparsed_scheme = "file"
249     source_hash_basename = urlparsed_path or urlparsed_source.netloc
250     source_is_local = urlparsed_scheme in salt.utils.files.LOCAL_PROTOS
251     if source_is_local:
252         source_match = os.path.realpath(os.path.expanduser(urlparsed_path))
253         if not os.path.isfile(source_match):
254             ret["comment"] = "Source file '{}' does not exist".format(
255                 salt.utils.url.redact_http_basic_auth(source_match)
256             )
257             return ret
258     valid_archive_formats = ("tar", "rar", "zip")
259     if not archive_format:
260         archive_format = salt.utils.files.guess_archive_type(source_hash_basename)
261         if archive_format is None:
262             ret["comment"] = (
263                 "Could not guess archive_format from the value of the "
264                 "'source' argument. Please set this archive_format to one "
265                 "of the following: {}".format(", ".join(valid_archive_formats))
266             )
267             return ret
268     try:
269         archive_format = archive_format.lower()
270     except AttributeError:
271         pass
272     if archive_format not in valid_archive_formats:
273         ret["comment"] = (
274             "Invalid archive_format '{}'. Either set it to a supported "
275             "value ({}) or remove this argument and the archive format will "
276             "be guessed based on file extension.".format(
277                 archive_format,
278                 ", ".join(valid_archive_formats),
279             )
280         )
281         return ret
282     if options is not None and not isinstance(options, str):
283         options = str(options)
284     strip_components = None
285     if options and archive_format == "tar":
286         try:
287             strip_components = int(
288                 re.search(
289                     r"""--strip(?:-components)?(?:\s+|=)["']?(\d+)["']?""", options
290                 ).group(1)
291             )
292         except (AttributeError, ValueError):
293             pass
294     if archive_format == "zip":
295         if options:
296             if use_cmd_unzip is None:
297                 log.info(
298                     "Presence of CLI options in archive.extracted state for "
299                     "'%s' implies that use_cmd_unzip is set to True.",
300                     name,
301                 )
302                 use_cmd_unzip = True
303             elif not use_cmd_unzip:
304                 ret["comment"] = (
305                     "'use_cmd_unzip' cannot be set to False if CLI options "
306                     "are being specified (via the 'options' argument). "
307                     "Either remove 'use_cmd_unzip', or set it to True."
308                 )
309                 return ret
310             if use_cmd_unzip:
311                 if "archive.cmd_unzip" not in __salt__:
312                     ret["comment"] = (
313                         "archive.cmd_unzip function not available, unzip might "
314                         "not be installed on minion"
315                     )
316                     return ret
317         if password:
318             if use_cmd_unzip is None:
319                 log.info(
320                     "Presence of a password in archive.extracted state for "
321                     "'%s' implies that use_cmd_unzip is set to False.",
322                     name,
323                 )
324                 use_cmd_unzip = False
325             elif use_cmd_unzip:
326                 ret.setdefault("warnings", []).append(
327                     "Using a password in combination with setting "
328                     "'use_cmd_unzip' to True is considered insecure. It is "
329                     "recommended to remove the 'use_cmd_unzip' argument (or "
330                     "set it to False) and allow Salt to extract the archive "
331                     "using Python's built-in ZIP file support."
332                 )
333     else:
334         if password:
335             ret[
336                 "comment"
337             ] = "The 'password' argument is only supported for zip archives"
338             return ret
339     if archive_format == "rar":
340         if "archive.unrar" not in __salt__:
341             ret["comment"] = (
342                 "archive.unrar function not available, rar/unrar might "
343                 "not be installed on minion"
344             )
345             return ret
346     supports_options = ("tar", "zip")
347     if options and archive_format not in supports_options:
348         ret["comment"] = (
349             "The 'options' argument is only compatible with the following "
350             "archive formats: {}".format(", ".join(supports_options))
351         )
352         return ret
353     if trim_output:
354         if trim_output is True:
355             trim_output = 100
356         elif not isinstance(trim_output, (bool, int)):
357             try:
358                 trim_output = int(trim_output)
359             except TypeError:
360                 ret[
361                     "comment"
362                 ] = "Invalid value for trim_output, must be True/False or an integer"
363                 return ret
364     if source_hash:
365         try:
366             source_sum = __salt__["file.get_source_sum"](
367                 source=source_match,
368                 source_hash=source_hash,
369                 source_hash_name=source_hash_name,
370                 saltenv=__env__,
371             )
372         except CommandExecutionError as exc:
373             ret["comment"] = exc.strerror
374             return ret
375     else:
376         source_sum = {}
377     if skip_files_list_verify:
378         if source_is_local:
379             cached = source_match
380         else:
381             cached = __salt__["cp.is_cached"](source_match, saltenv=__env__)
382         if cached:
383             existing_cached_source_sum = _read_cached_checksum(cached)
384             log.debug(
385                 'Existing source sum is: "%s". Expected source sum is "%s"',
386                 existing_cached_source_sum,
387                 source_sum,
388             )
389         else:
390             parsed = urlparse(source_match)
391             expected_cached_path = salt.utils.path.join(
392                 __opts__["cachedir"], "extrn_files", __env__, parsed.netloc, parsed.path
393             )
394             existing_cached_source_sum = _read_cached_checksum(expected_cached_path)
395         if source_sum and existing_cached_source_sum:
396             if existing_cached_source_sum["hsum"] == source_sum["hsum"]:
397                 ret["result"] = None if __opts__["test"] else True
398                 ret["comment"] = (
399                     "Archive {} existing source sum is the same as the "
400                     "expected one and skip_files_list_verify argument was set "
401                     "to True. Extraction is not needed".format(
402                         salt.utils.url.redact_http_basic_auth(source_match)
403                     )
404                 )
405                 return ret
406         else:
407             log.debug("There is no cached source %s available on minion", source_match)
408     if source_is_local:
409         cached = source_match
410     else:
411         if __opts__["test"]:
412             ret["result"] = None
413             ret["comment"] = (
414                 "Archive {} would be cached (if necessary) and checked to "
415                 "discover if extraction is needed".format(
416                     salt.utils.url.redact_http_basic_auth(source_match)
417                 )
418             )
419             return ret
420         if "file.cached" not in __states__:
421             ret[
422                 "comment"
423             ] = "Unable to cache {}, file.cached state not available".format(
424                 salt.utils.url.redact_http_basic_auth(source_match)
425             )
426             return ret
427         try:
428             result = __states__["file.cached"](
429                 source_match,
430                 source_hash=source_hash,
431                 source_hash_name=source_hash_name,
432                 skip_verify=skip_verify,
433                 saltenv=__env__,
434                 use_etag=use_etag,
435             )
436         except Exception as exc:  # pylint: disable=broad-except
437             msg = "Failed to cache {}: {}".format(
438                 salt.utils.url.redact_http_basic_auth(source_match), exc.__str__()
439             )
440             log.exception(msg)
441             ret["comment"] = msg
442             return ret
443         else:
444             log.debug("file.cached: %s", result)
445         if result["result"]:
446             cached = __salt__["cp.is_cached"](source_match, saltenv=__env__)
447         else:
448             log.debug(
449                 "failed to download %s",
450                 salt.utils.url.redact_http_basic_auth(source_match),
451             )
452             return result
453     existing_cached_source_sum = _read_cached_checksum(cached)
454     if source_hash and source_hash_update and not skip_verify:
455         _update_checksum(cached)
456     if archive_format == "zip" and not password:
457         log.debug("Checking %s to see if it is password-protected", source_match)
458         try:
459             encrypted_zip = __salt__["archive.is_encrypted"](
460                 cached, clean=False, saltenv=__env__, use_etag=use_etag
461             )
462         except CommandExecutionError:
463             pass
464         else:
465             if encrypted_zip:
466                 ret["comment"] = (
467                     "Archive {} is password-protected, but no password was "
468                     "specified. Please set the 'password' argument.".format(
469                         salt.utils.url.redact_http_basic_auth(source_match)
470                     )
471                 )
472                 return ret
473     try:
474         contents = __salt__["archive.list"](
475             cached,
476             archive_format=archive_format,
477             options=list_options,
478             strip_components=strip_components,
479             clean=False,
480             verbose=True,
481             use_etag=use_etag,
482         )
483     except CommandExecutionError as exc:
484         contents = None
485         errors = []
486         if not if_missing:
487             errors.append("'if_missing' must be set")
488         if not enforce_ownership_on and (user or group):
489             errors.append(
490                 "Ownership cannot be managed without setting 'enforce_ownership_on'."
491             )
492         msg = exc.strerror
493         if errors:
494             msg += "\n\n"
495             if archive_format == "tar":
496                 msg += (
497                     "If the source archive is a tar archive compressed using "
498                     "a compression type not natively supported by the tar "
499                     "command, then setting the 'list_options' argument may "
500                     "allow the contents to be listed. Otherwise, if Salt is "
501                     "unable to determine the files/directories in the "
502                     "archive, the following workaround(s) would need to be "
503                     "used for this state to proceed"
504                 )
505             else:
506                 msg += (
507                     "The following workarounds must be used for this state to proceed"
508                 )
509             msg += " (assuming the source file is a valid {} archive):\n".format(
510                 archive_format
511             )
512             for error in errors:
513                 msg += "\n- {}".format(error)
514         ret["comment"] = msg
515         return ret
516     if (
517         enforce_toplevel
518         and contents is not None
519         and (
520             len(contents["top_level_dirs"]) &gt; 1 or len(contents["top_level_files"]) &gt; 0
521         )
522     ):
523         ret["comment"] = (
524             "Archive does not have a single top-level directory. "
525             "To allow this archive to be extracted, set "
526             "'enforce_toplevel' to False. To avoid a "
527             "'{}-bomb' it may also be advisable to set a "
528             "top-level directory by adding it to the 'name' "
529             "value (for example, setting 'name' to {} "
530             "instead of {}).".format(
531                 archive_format,
532                 os.path.join(name, "some_dir"),
533                 name,
534             )
535         )
536         return ret
537     if clean and clean_parent:
538         ret["comment"] = "Only one of 'clean' and 'clean_parent' can be set to True"
539         ret["result"] = False
540         return ret
541     extraction_needed = overwrite
542     contents_missing = False
543     try:
544         if_missing_path_exists = os.path.exists(if_missing)
545     except TypeError:
546         if_missing_path_exists = False
547     if not if_missing_path_exists:
548         if contents is None:
549             try:
550                 os.lstat(if_missing)
551                 extraction_needed = False
552             except OSError as exc:
553                 if exc.errno == errno.ENOENT:
554                     extraction_needed = True
555                 else:
556                     ret["comment"] = (
557                         "Failed to check for existence of if_missing path "
558                         "({}): {}".format(if_missing, exc.__str__())
559                     )
560                     return ret
561         else:
562             incorrect_type = []
563             for path_list, func in (
564                 (contents["dirs"], stat.S_ISDIR),
565                 (
566                     contents["files"],
567                     lambda x: not stat.S_ISLNK(x) and not stat.S_ISDIR(x),
568                 ),
569                 (contents["links"], stat.S_ISLNK),
570             ):
571                 for path in path_list:
572                     full_path = salt.utils.path.join(name, path)
573                     try:
574                         path_mode = os.lstat(full_path.rstrip(os.sep)).st_mode
575                         if not func(path_mode):
576                             incorrect_type.append(path)
577                     except OSError as exc:
578                         if exc.errno == errno.ENOENT:
579                             extraction_needed = True
580                             contents_missing = True
581                         elif exc.errno != errno.ENOTDIR:
582                             ret["comment"] = exc.__str__()
583                             return ret
584             if incorrect_type:
585                 incorrect_paths = "\n\n" + "\n".join(
586                     ["- {}".format(x) for x in incorrect_type]
587                 )
588                 ret["comment"] = (
589                     "The below paths (relative to {}) exist, but are the "
590                     "incorrect type (file instead of directory, symlink "
591                     "instead of file, etc.).".format(name)
592                 )
593                 if __opts__["test"] and clean and contents is not None:
594                     ret["result"] = None
595                     ret["comment"] += (
596                         " Since the 'clean' option is enabled, the "
597                         "destination paths would be cleared and the "
598                         "archive would be extracted.{}".format(incorrect_paths)
599                     )
600                     return ret
601                 if __opts__["test"] and clean_parent and contents is not None:
602                     ret["result"] = None
603                     ret["comment"] += (
604                         " Since the 'clean_parent' option is enabled, the "
605                         "destination parent directory would be removed first "
606                         "and then re-created and the archive would be "
607                         "extracted"
608                     )
609                     return ret
610                 if not (clean and contents is not None):
611                     if not force:
612                         ret["comment"] += (
613                             " To proceed with extraction, set 'force' to "
614                             "True. Note that this will remove these paths "
615                             "before extracting.{}".format(incorrect_paths)
616                         )
617                         return ret
618                     else:
619                         errors = []
620                         for path in incorrect_type:
621                             full_path = os.path.join(name, path)
622                             try:
623                                 salt.utils.files.rm_rf(full_path.rstrip(os.sep))
624                                 ret["changes"].setdefault("removed", []).append(
625                                     full_path
626                                 )
627                                 extraction_needed = True
628                             except OSError as exc:
629                                 if exc.errno != errno.ENOENT:
630                                     errors.append(exc.__str__())
631                         if errors:
632                             msg = (
633                                 "One or more paths existed by were the incorrect "
634                                 "type (i.e. file instead of directory or "
635                                 "vice-versa), but could not be removed. The "
636                                 "following errors were observed:\n"
637                             )
638                             for error in errors:
639                                 msg += "\n- {}".format(error)
640                             ret["comment"] = msg
641                             return ret
642     if (
643         not extraction_needed
644         and source_hash_update
645         and existing_cached_source_sum is not None
646         and not _compare_checksum(cached, existing_cached_source_sum)
647     ):
648         extraction_needed = True
649         source_hash_trigger = True
650     else:
651         source_hash_trigger = False
652     created_destdir = False
653     if extraction_needed:
654         if source_is_local and source_hash and not skip_verify:
655             ret["result"] = __salt__["file.check_hash"](
656                 source_match, source_sum["hsum"]
657             )
658             if not ret["result"]:
659                 ret["comment"] = "{} does not match the desired source_hash {}".format(
660                     salt.utils.url.redact_http_basic_auth(source_match),
661                     source_sum["hsum"],
662                 )
663                 return ret
664         if __opts__["test"]:
665             ret["result"] = None
666             ret["comment"] = "Archive {} would be extracted to {}".format(
667                 salt.utils.url.redact_http_basic_auth(source_match), name
668             )
669             if clean and contents is not None:
670                 ret["comment"] += ", after cleaning destination path(s)"
671             _add_explanation(ret, source_hash_trigger, contents_missing)
672             return ret
673         if clean_parent and contents is not None:
674             errors = []
675             log.debug("Removing directory %s due to clean_parent set to True", name)
676             try:
677                 salt.utils.files.rm_rf(name.rstrip(os.sep))
678                 ret["changes"].setdefault(
679                     "removed",
680                     "Directory {} was removed prior to the extraction".format(name),
681                 )
682             except OSError as exc:
683                 if exc.errno != errno.ENOENT:
684                     errors.append(str(exc))
685             if errors:
686                 msg = (
687                     "Unable to remove the directory {}. The following "
688                     "errors were observed:\n".format(name)
689                 )
690                 for error in errors:
691                     msg += "\n- {}".format(error)
692                 ret["comment"] = msg
693                 return ret
694         if clean and contents is not None:
695             errors = []
696             log.debug("Cleaning archive paths from within %s", name)
697             for path in contents["top_level_dirs"] + contents["top_level_files"]:
698                 full_path = os.path.join(name, path)
699                 try:
700                     log.debug("Removing %s", full_path)
701                     salt.utils.files.rm_rf(full_path.rstrip(os.sep))
702                     ret["changes"].setdefault("removed", []).append(full_path)
703                 except OSError as exc:
704                     if exc.errno != errno.ENOENT:
705                         errors.append(exc.__str__())
706             if errors:
707                 msg = (
708                     "One or more paths could not be cleaned. The following "
709                     "errors were observed:\n"
710                 )
711                 for error in errors:
712                     msg += "\n- {}".format(error)
713                 ret["comment"] = msg
714                 return ret
715         if not os.path.isdir(name):
716             __states__["file.directory"](name, user=user, makedirs=True)
717             created_destdir = True
718         log.debug("Extracting %s to %s", cached, name)
719         try:
720             if archive_format == "zip":
721                 if use_cmd_unzip:
722                     try:
723                         files = __salt__["archive.cmd_unzip"](
724                             cached,
725                             name,
726                             options=options,
727                             trim_output=trim_output,
728                             password=password,
729                             **kwargs
730                         )
731                     except (CommandExecutionError, CommandNotFoundError) as exc:
732                         ret["comment"] = exc.strerror
733                         return ret
734                 else:
735                     files = __salt__["archive.unzip"](
736                         cached,
737                         name,
738                         options=options,
739                         trim_output=trim_output,
740                         password=password,
741                         extract_perms=extract_perms,
742                         **kwargs
743                     )
744             elif archive_format == "rar":
745                 try:
746                     files = __salt__["archive.unrar"](
747                         cached, name, trim_output=trim_output, **kwargs
748                     )
749                 except (CommandExecutionError, CommandNotFoundError) as exc:
750                     ret["comment"] = exc.strerror
751                     return ret
752             else:
753                 if options is None:
754                     try:
755                         with closing(tarfile.open(cached, "r")) as tar:
756                             tar.extractall(salt.utils.stringutils.to_str(name))
757                             files = tar.getnames()
758                             if trim_output:
759                                 files = files[:trim_output]
760                     except tarfile.ReadError:
761                         if salt.utils.path.which("xz"):
762                             if (
763                                 __salt__["cmd.retcode"](
764                                     ["xz", "-t", cached],
765                                     python_shell=False,
766                                     ignore_retcode=True,
767                                 )
768                                 == 0
769                             ):
770                                 log.debug(
771                                     "Tar file is XZ-compressed, attempting "
772                                     "decompression and extraction using XZ Utils "
773                                     "and the tar command"
774                                 )
775                                 cmd = "xz --decompress --stdout {0} | tar xvf -"
776                                 results = __salt__["cmd.run_all"](
777                                     cmd.format(shlex.quote(cached)),
778                                     cwd=name,
779                                     python_shell=True,
780                                 )
781                                 if results["retcode"] != 0:
782                                     if created_destdir:
783                                         _cleanup_destdir(name)
784                                     ret["result"] = False
785                                     ret["changes"] = results
786                                     return ret
787                                 if _is_bsdtar():
788                                     files = results["stderr"]
789                                 else:
790                                     files = results["stdout"]
791                             else:
792                                 if created_destdir:
793                                     _cleanup_destdir(name)
794                                 ret["result"] = False
795                                 ret["comment"] = (
796                                     "Failed to read from tar archive using "
797                                     "Python's native tar file support. If "
798                                     "archive is compressed using something "
799                                     "other than gzip or bzip2, the "
800                                     "'options' argument may be required to "
801                                     "pass the correct options to the tar "
802                                     "command in order to extract the archive."
803                                 )
804                                 return ret
805                         else:
806                             if created_destdir:
807                                 _cleanup_destdir(name)
808                             ret["result"] = False
809                             ret["comment"] = (
810                                 "Failed to read from tar archive. If it is "
811                                 "XZ-compressed, install xz-utils to attempt "
812                                 "extraction."
813                             )
814                             return ret
815                 else:
816                     if not salt.utils.path.which("tar"):
817                         ret["comment"] = (
818                             "tar command not available, it might not be "
819                             "installed on minion"
820                         )
821                         return ret
822                     tar_opts = [
823                         x
824                         for x in shlex.split(options)
825                         if x not in ("v", "-v", "--verbose")
826                     ]
827                     tar_cmd = ["tar"]
828                     tar_shortopts = "xv"
829                     tar_longopts = []
830                     for position, opt in enumerate(tar_opts):
831                         if opt.startswith("-"):
832                             tar_longopts.append(opt)
833                         else:
834                             if position &gt; 0:
835                                 tar_longopts.append(opt)
836                             else:
837                                 append_opt = opt
838                                 append_opt = append_opt.replace("x", "")
839                                 append_opt = append_opt.replace("f", "")
840                                 tar_shortopts = tar_shortopts + append_opt
841                     if __grains__["os"].lower() == "openbsd":
842                         tar_shortopts = "-" + tar_shortopts
843                     tar_cmd.append(tar_shortopts)
844                     tar_cmd.extend(tar_longopts)
845                     tar_cmd.extend(["-f", cached])
846                     results = __salt__["cmd.run_all"](
847                         tar_cmd, cwd=name, python_shell=False
848                     )
849                     if results["retcode"] != 0:
850                         ret["result"] = False
851                         ret["changes"] = results
852                         return ret
853                     if _is_bsdtar():
854                         files = results["stderr"].splitlines()
855                         if trim_output:
856                             files = files[:trim_output]
857                     else:
858                         files = results["stdout"].splitlines()
859                         if trim_output:
860                             files = files[:trim_output]
861                     if not files:
862                         files = "no tar output so far"
863         except CommandExecutionError as exc:
864             ret["comment"] = exc.strerror
865             return ret
866     enforce_missing = []
867     enforce_failed = []
868     if user or group:
869         if enforce_ownership_on:
870             if os.path.isdir(enforce_ownership_on):
871                 enforce_dirs = [enforce_ownership_on]
872                 enforce_files = []
873                 enforce_links = []
874             else:
875                 enforce_dirs = []
876                 enforce_files = [enforce_ownership_on]
877                 enforce_links = []
878         else:
879             if contents is not None:
880                 enforce_dirs = contents["top_level_dirs"]
881                 enforce_files = contents["top_level_files"]
882                 enforce_links = contents["top_level_links"]
883         recurse = []
884         if user:
885             recurse.append("user")
886         if group:
887             recurse.append("group")
888         recurse_str = ", ".join(recurse)
889         owner_changes = {x: y for x, y in (("user", user), ("group", group)) if y}
890         for dirname in enforce_dirs:
891             full_path = os.path.join(name, dirname)
892             if not os.path.isdir(full_path):
893                 if not __opts__["test"]:
894                     enforce_missing.append(full_path)
895             else:
896                 log.debug(
897                     "Enforcing %s ownership on %s using a file.directory state%s",
898                     recurse_str,
899                     dirname,
900                     " (dry-run only)" if __opts__["test"] else "",
901                 )
902                 dir_result = __states__["file.directory"](
903                     full_path, user=user, group=group, recurse=recurse
904                 )
905                 log.debug("file.directory: %s", dir_result)
906                 if dir_result.get("changes"):
907                     ret["changes"]["updated ownership"] = True
908                 try:
909                     if not dir_result["result"]:
910                         enforce_failed.append(full_path)
911                 except (KeyError, TypeError):
912                     log.warning(
913                         "Bad state return %s for file.directory state on %s",
914                         dir_result,
915                         dirname,
916                     )
917         for filename in enforce_files + enforce_links:
918             full_path = os.path.join(name, filename)
919             try:
920                 file_stat = os.lstat(full_path)
921             except OSError as exc:
922                 if not __opts__["test"]:
923                     if exc.errno == errno.ENOENT:
924                         enforce_missing.append(full_path)
925                     enforce_failed.append(full_path)
926             else:
927                 if (uid != -1 and uid != file_stat.st_uid) or (
928                     gid != -1 and gid != file_stat.st_gid
929                 ):
930                     if __opts__["test"]:
931                         ret["changes"]["updated ownership"] = True
932                     else:
933                         try:
934                             os.lchown(full_path, uid, gid)
935                             ret["changes"]["updated ownership"] = True
936                         except OSError:
937                             enforce_failed.append(filename)
938     if extraction_needed:
939         if len(files) &gt; 0:
940             if created_destdir:
941                 ret["changes"]["directories_created"] = [name]
942             ret["changes"]["extracted_files"] = files
943             ret["comment"] = "{} extracted to {}".format(
944                 salt.utils.url.redact_http_basic_auth(source_match),
945                 name,
946             )
947             _add_explanation(ret, source_hash_trigger, contents_missing)
948             ret["comment"] += ". Output was trimmed to {} number of lines".format(
949                 trim_output
950             )
951             ret["result"] = True
952         else:
953             ret["result"] = False
954             ret["comment"] = "No files were extracted from {}".format(
955                 salt.utils.url.redact_http_basic_auth(source_match)
956             )
957     else:
958         ret["result"] = True
959         if if_missing_path_exists:
960             ret["comment"] = "{} exists".format(if_missing)
961         else:
962             ret["comment"] = "All files in archive are already present"
963         if __opts__["test"]:
964             if ret["changes"].get("updated ownership"):
965                 ret["result"] = None
966                 ret[
967                     "comment"
968                 ] += ". Ownership would be updated on one or more files/directories."
969     if enforce_missing:
970         if not if_missing:
971             ret["result"] = False
972         ret["comment"] += (
973             "\n\nWhile trying to enforce user/group ownership, the following "
974             "paths were missing:\n"
975         )
976         for item in enforce_missing:
977             ret["comment"] += "\n- {}".format(item)
978     if enforce_failed:
979         ret["result"] = False
980         ret["comment"] += (
981             "\n\nWhile trying to enforce user/group ownership, Salt was "
982             "unable to change ownership on the following paths:\n"
983         )
984         for item in enforce_failed:
985             ret["comment"] += "\n- {}".format(item)
986     if not source_is_local:
987         if keep_source:
988             log.debug("Keeping cached source file %s", cached)
989         else:
990             log.debug("Cleaning cached source file %s", cached)
991             result = __states__["file.not_cached"](source_match, saltenv=__env__)
992             if not result["result"]:
993                 ret.setdefault("warnings", []).append(result["comment"])
994     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_file_selinux.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import logging
2 import os
3 import shutil
4 import pytest
5 import salt.config
6 import salt.loader
7 import salt.modules.cmdmod as cmdmod
8 import salt.modules.file as filemod
9 import salt.utils.data
10 import salt.utils.files
11 import salt.utils.platform
12 import salt.utils.stringutils
13 from tests.support.mock import MagicMock, patch
14 log = logging.getLogger(</b></font>__name__)
15 pytestmark = pytest.mark.skipif(
16     salt.modules.selinux.getenforce() != "Enforcing",
17     reason="Skip if selinux not enabled",
18 )
19 @pytest.fixture
20 def configure_loader_modules():
21     return {
22         filemod: {
23             "__salt__": {
24                 "cmd.run": cmdmod.run,
25                 "cmd.run_all": cmdmod.run_all,
26                 "cmd.retcode": cmdmod.retcode,
27                 "selinux.fcontext_add_policy": MagicMock(
28                     return_value={"retcode": 0, "stdout": ""}
29                 ),
30             },
31             "__opts__": {"test": False},
32         }
33     }
34 @pytest.fixture
35 def subdir(tmp_path):
36     subdir = tmp_path / "file-selinux-test-dir"
37     subdir.mkdir()
38     yield subdir
39     shutil.rmtree(str(subdir))
40 @pytest.fixture
41 def tfile1(subdir):
42     filename = str(subdir / "tfile1")
43     with salt.utils.files.fopen(filename, "w+"):
44         pass
45     yield filename
46     os.remove(filename)
47 @pytest.fixture
48 def tfile2(subdir):
49     filename = str(subdir / "tfile2")
50     with salt.utils.files.fopen(filename, "w+"):
51         pass
52     yield filename
53     os.remove(filename)
54 @pytest.fixture
55 def tfile3(subdir):
56     filename = str(subdir / "tfile3")
57     with salt.utils.files.fopen(filename, "w+"):
58         pass
59     yield filename
60     os.remove(filename)
61 def test_selinux_getcontext(tfile1):
62     result = filemod.get_selinux_context(tfile1)
63     assert result == "unconfined_u:object_r:user_tmp_t:s0"
64 def test_selinux_setcontext(tfile2):
65     result = filemod.set_selinux_context(tfile2, user="system_u")
66     assert result == "system_u:object_r:user_tmp_t:s0"
67 def test_selinux_setcontext_persist(tfile2):
68     result = filemod.set_selinux_context(tfile2, user="system_u", persist=True)
69     assert result == "system_u:object_r:user_tmp_t:s0"
70 def test_file_check_perms(tfile3):
71     expected_result = (
72         {
73             "comment": "The file {} is set to be changed".format(tfile3),
74             "changes": {
75                 "selinux": {"New": "Type: lost_found_t", "Old": "Type: user_tmp_t"},
76                 "mode": "0664",
77             },
78             "name": tfile3,
79             "result": True,
80         },
81         {"luser": "root", "lmode": "0644", "lgroup": "root"},
82     )
83     with patch("salt.utils.path.which") as m_which:
84         m_which.return_value = None
85         result = filemod.check_perms(
86             tfile3,
87             {},
88             "root",
89             "root",
90             664,
91             seuser=None,
92             serole=None,
93             setype="lost_found_t",
94             serange=None,
95         )
96         assert result == expected_result
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
