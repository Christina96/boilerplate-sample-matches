
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.7765567765567765%, Tokens: 10</h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-callbackstuffs.py</h3>
            <pre><code>1  import ast
2  import asyncio
3  import re
4  import sys
5  import time
6  from asyncio.exceptions import TimeoutError as AsyncTimeOut
7  from os import execl, remove
8  from random import choice
9  from bs4 import BeautifulSoup as bs
10  try:
11      from pyUltroid.fns.gDrive import GDriveManager
12  except ImportError:
13      GDriveManager = None
14  from telegraph import upload_file as upl
15  from telethon import Button, events
16  from telethon.tl.types import MessageMediaWebPage
17  from telethon.utils import get_peer_id
18  from pyUltroid.fns.helper import fast_download, progress
19  from pyUltroid.fns.tools import Carbon, async_searcher, get_paste, telegraph_client
20  from pyUltroid.startup.loader import Loader
21  from . import *
22  telegraph = telegraph_client()
23  GDrive = GDriveManager() if GDriveManager else None
24  def text_to_url(event):
25      if isinstance(event.media, MessageMediaWebPage):
26          webpage = event.media.webpage
27          if not isinstance(webpage, types.WebPageEmpty) and webpage.type in ["photo"]:
28              return webpage.display_url
29      return event.text
30  _buttons = {
31      "otvars": {
32          "text": "Other Variables to set for @TeamUltroid:",
33          "buttons": [
34              [
35                  Button.inline("Tᴀɢ Lᴏɢɢᴇʀ", data="taglog"),
36                  Button.inline("SᴜᴘᴇʀFʙᴀɴ", data="cbs_sfban"),
37              ],
38              [
39                  Button.inline("Sᴜᴅᴏ Mᴏᴅᴇ", data="sudo"),
40                  Button.inline("Hᴀɴᴅʟᴇʀ", data="hhndlr"),
41              ],
42              [
43                  Button.inline("Exᴛʀᴀ Pʟᴜɢɪɴs", data="plg"),
44                  Button.inline("Aᴅᴅᴏɴs", data="eaddon"),
45              ],
46              [
47                  Button.inline("Eᴍᴏᴊɪ ɪɴ Hᴇʟᴘ", data="emoj"),
48                  Button.inline("Sᴇᴛ ɢDʀɪᴠᴇ", data="gdrive"),
49              ],
50              [
51                  Button.inline("Iɴʟɪɴᴇ Pɪᴄ", data="inli_pic"),
<span onclick='openModal()' class='match'>52                  Button.inline("Sᴜᴅᴏ HNDLR", data="shndlr"),
53              ],
54              [Button.inline("Dᴜᴀʟ Mᴏᴅᴇ", "cbs_oofdm")],
55              [Button.inline("« Bᴀᴄᴋ", data="setter")],
56          ],
57      },
58      "sfban": {
59          "text": "SuperFban Settings:",
60          "buttons": [
61              [Button.inline("FBᴀɴ Gʀᴏᴜᴘ", data="sfgrp")],
</span>62              [Button.inline("Exᴄʟᴜᴅᴇ Fᴇᴅs", data="abs_sfexf")],
63              [Button.inline("« Bᴀᴄᴋ", data="cbs_otvars")],
64          ],
65      },
66      "apauto": {
67          "text": "This'll auto approve on outgoing messages",
68          "buttons": [
69              [Button.inline("Aᴜᴛᴏ Aᴘᴘʀᴏᴠᴇ ON", data="apon")],
70              [Button.inline("Aᴜᴛᴏ Aᴘᴘʀᴏᴠᴇ OFF", data="apof")],
71              [Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")],
72          ],
73      },
74      "alvcstm": {
75          "text": f"Customise your {HNDLR}alive. Choose from the below options -",
76          "buttons": [
77              [Button.inline("Aʟɪᴠᴇ Tᴇxᴛ", data="abs_alvtx")],
78              [Button.inline("Aʟɪᴠᴇ ᴍᴇᴅɪᴀ", data="alvmed")],
79              [Button.inline("Dᴇʟᴇᴛᴇ Aʟɪᴠᴇ Mᴇᴅɪᴀ", data="delmed")],
80              [Button.inline("« Bᴀᴄᴋ", data="setter")],
81          ],
82      },
83      "pmcstm": {
84          "text": "Customise your PMPERMIT Settings -",
85          "buttons": [
86              [
87                  Button.inline("Pᴍ Tᴇxᴛ", data="pmtxt"),
88                  Button.inline("Pᴍ Mᴇᴅɪᴀ", data="pmmed"),
89              ],
90              [
91                  Button.inline("Aᴜᴛᴏ Aᴘᴘʀᴏᴠᴇ", data="cbs_apauto"),
92                  Button.inline("PMLOGGER", data="pml"),
93              ],
94              [
95                  Button.inline("Sᴇᴛ Wᴀʀɴs", data="swarn"),
96                  Button.inline("Dᴇʟᴇᴛᴇ Pᴍ Mᴇᴅɪᴀ", data="delpmmed"),
97              ],
98              [Button.inline("PMPermit Type", data="cbs_pmtype")],
99              [Button.inline("« Bᴀᴄᴋ", data="cbs_ppmset")],
100          ],
101      },
102      "pmtype": {
103          "text": "Select the type of PMPermit needed.",
104          "buttons": [
105              [Button.inline("Inline", data="inpm_in")],
106              [Button.inline("Normal", data="inpm_no")],
107              [Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")],
108          ],
109      },
110      "ppmset": {
111          "text": "PMPermit Settings:",
112          "buttons": [
113              [Button.inline("Tᴜʀɴ PMPᴇʀᴍɪᴛ Oɴ", data="pmon")],
114              [Button.inline("Tᴜʀɴ PMPᴇʀᴍɪᴛ Oғғ", data="pmoff")],
115              [Button.inline("Cᴜsᴛᴏᴍɪᴢᴇ PMPᴇʀᴍɪᴛ", data="cbs_pmcstm")],
116              [Button.inline("« Bᴀᴄᴋ", data="setter")],
117          ],
118      },
119      "chatbot": {
120          "text": "From This Feature U can chat with ppls Via ur Assistant Bot.\n[More info](https://t.me/UltroidUpdates/2)",
121          "buttons": [
122              [
123                  Button.inline("Cʜᴀᴛ Bᴏᴛ  Oɴ", data="onchbot"),
124                  Button.inline("Cʜᴀᴛ Bᴏᴛ  Oғғ", data="ofchbot"),
125              ],
126              [
127                  Button.inline("Bᴏᴛ Wᴇʟᴄᴏᴍᴇ", data="bwel"),
128                  Button.inline("Bᴏᴛ Wᴇʟᴄᴏᴍᴇ Mᴇᴅɪᴀ", data="botmew"),
129              ],
130              [Button.inline("Bᴏᴛ Iɴғᴏ Tᴇxᴛ", data="botinfe")],
131              [Button.inline("Fᴏʀᴄᴇ Sᴜʙsᴄʀɪʙᴇ", data="pmfs")],
132              [Button.inline("« Bᴀᴄᴋ", data="setter")],
133          ],
134      },
135      "vcb": {
136          "text": "From This Feature U can play songs in group voice chat\n\n[moreinfo](https://t.me/UltroidUpdates/4)",
137          "buttons": [
138              [Button.inline("VC Sᴇssɪᴏɴ", data="abs_vcs")],
139              [Button.inline("« Bᴀᴄᴋ", data="setter")],
140          ],
141      },
142      "oofdm": {
143          "text": "About [Dual Mode](https://t.me/UltroidUpdates/18)",
144          "buttons": [
145              [
146                  Button.inline("Dᴜᴀʟ Mᴏᴅᴇ Oɴ", "dmof"),
147                  Button.inline("Dᴜᴀʟ Mᴏᴅᴇ Oғғ", "dmof"),
148              ],
149              [Button.inline("Dᴜᴀʟ Mᴏᴅᴇ Hɴᴅʟʀ", "dmhn")],
150              [Button.inline("« Back", data="cbs_otvars")],
151          ],
152      },
153      "apiset": {
154          "text": get_string("ast_1"),
155          "buttons": [
156              [Button.inline("Remove.bg API", data="abs_rmbg")],
157              [Button.inline("DEEP API", data="abs_dapi")],
158              [Button.inline("OCR API", data="abs_oapi")],
159              [Button.inline("« Back", data="setter")],
160          ],
161      },
162  }
163  _convo = {
164      "rmbg": {
165          "var": "RMBG_API",
166          "name": "Remove.bg API Key",
167          "text": get_string("ast_2"),
168          "back": "cbs_apiset",
169      },
170      "dapi": {
171          "var": "DEEP_AI",
172          "name": "Deep AI Api Key",
173          "text": "Get Your Deep Api from deepai.org and send here.",
174          "back": "cbs_apiset",
175      },
176      "oapi": {
177          "var": "OCR_API",
178          "name": "Ocr Api Key",
179          "text": "Get Your OCR api from ocr.space and send that Here.",
180          "back": "cbs_apiset",
181      },
182      "pmlgg": {
183          "var": "PMLOGGROUP",
184          "name": "Pm Log Group",
185          "text": "Send chat id of chat which you want to save as Pm log Group.",
186          "back": "pml",
187      },
188      "vcs": {
189          "var": "VC_SESSION",
190          "name": "Vc Session",
191          "text": "**Vc session**\nEnter the New session u generated for vc bot.\n\nUse /cancel to terminate the operation.",
192          "back": "cbs_vcb",
193      },
194      "settag": {
195          "var": "TAG_LOG",
196          "name": "Tag Log Group",
197          "text": f"Make a group, add your assistant and make it admin.\nGet the `{HNDLR}id` of that group and send it here for tag logs.\n\nUse /cancel to cancel.",
198          "back": "taglog",
199      },
200      "alvtx": {
201          "var": "ALIVE_TEXT",
202          "name": "Alive Text",
203          "text": "**Alive Text**\nEnter the new alive text.\n\nUse /cancel to terminate the operation.",
204          "back": "cbs_alvcstm",
205      },
206      "sfexf": {
207          "var": "EXCLUDE_FED",
208          "name": "Excluded Fed",
209          "text": "Send the Fed IDs you want to exclude in the ban. Split by a space.\neg`id1 id2 id3`\nSet is as `None` if you dont want any.\nUse /cancel to go back.",
210          "back": "cbs_sfban",
211      },
212  }
213  TOKEN_FILE = "resources/auths/auth_token.txt"
214  @callback(
215      re.compile(
216          "sndplug_(.*)",
217      ),
218      owner=True,
219  )
220  async def send(eve):
221      key, name = (eve.data_match.group(1)).decode("UTF-8").split("_")
222      thumb = "resources/extras/inline.jpg"
223      await eve.answer("■ Sending ■")
224      data = f"uh_{key}_"
225      index = None
226      if "|" in name:
227          name, index = name.split("|")
228      key = "plugins" if key == "Official" else key.lower()
229      plugin = f"{key}/{name}.py"
230      _ = f"pasta-{plugin}"
231      if index is not None:
232          data += f"|{index}"
233          _ += f"|{index}"
234      buttons = [
235          [
236              Button.inline(
237                  "« Pᴀsᴛᴇ »",
238                  data=_,
239              )
240          ],
241          [
242              Button.inline("« Bᴀᴄᴋ", data=data),
243          ],
244      ]
245      try:
246          await eve.edit(file=plugin, thumb=thumb, buttons=buttons)
247      except Exception as er:
248          await eve.answer(str(er), alert=True)
249  heroku_api, app_name = Var.HEROKU_API, Var.HEROKU_APP_NAME
250  @callback("updatenow", owner=True)
251  async def update(eve):
252      repo = Repo()
253      ac_br = repo.active_branch
254      ups_rem = repo.remote("upstream")
255      if heroku_api:
256          import heroku3
257          try:
258              heroku = heroku3.from_key(heroku_api)
259              heroku_app = None
260              heroku_applications = heroku.apps()
261          except BaseException as er:
262              LOGS.exception(er)
263              return await eve.edit("`Wrong HEROKU_API.`")
264          for app in heroku_applications:
265              if app.name == app_name:
266                  heroku_app = app
267          if not heroku_app:
268              await eve.edit("`Wrong HEROKU_APP_NAME.`")
269              repo.__del__()
270              return
271          await eve.edit(get_string("clst_1"))
272          ups_rem.fetch(ac_br)
273          repo.git.reset("--hard", "FETCH_HEAD")
274          heroku_git_url = heroku_app.git_url.replace(
275              "https://", f"https://api:{heroku_api}@"
276          )
277          if "heroku" in repo.remotes:
278              remote = repo.remote("heroku")
279              remote.set_url(heroku_git_url)
280          else:
281              remote = repo.create_remote("heroku", heroku_git_url)
282          try:
283              remote.push(refspec=f"HEAD:refs/heads/{ac_br}", force=True)
284          except GitCommandError as error:
285              await eve.edit(f"`Here is the error log:\n{error}`")
286              repo.__del__()
287              return
288          await eve.edit("`Successfully Updated!\nRestarting, please wait...`")
289      else:
290          await eve.edit(get_string("clst_1"))
291          call_back()
292          await bash("git pull && pip3 install -r requirements.txt")
293          execl(sys.executable, sys.executable, "-m", "pyUltroid")
294  @callback(re.compile("changes(.*)"), owner=True)
295  async def changes(okk):
296      match = okk.data_match.group(1).decode("utf-8")
297      await okk.answer(get_string("clst_3"))
298      repo = Repo.init()
299      button = [[Button.inline("Update Now", data="updatenow")]]
300      changelog, tl_chnglog = await gen_chlog(
301          repo, f"HEAD..upstream/{repo.active_branch}"
302      )
303      cli = "\n\nClick the below button to update!"
304      if not match:
305          try:
306              if len(tl_chnglog) > 700:
307                  tl_chnglog = f"{tl_chnglog[:700]}..."
308                  button.append([Button.inline("View Complete", "changesall")])
309              await okk.edit("• Writing Changelogs 📝 •")
310              img = await Carbon(
311                  file_name="changelog",
312                  code=tl_chnglog,
313                  backgroundColor=choice(ATRA_COL),
314                  language="md",
315              )
316              return await okk.edit(
317                  f"**• Ultroid Userbot •**{cli}", file=img, buttons=button
318              )
319          except Exception as er:
320              LOGS.exception(er)
321      changelog_str = changelog + cli
322      if len(changelog_str) > 1024:
323          await okk.edit(get_string("upd_4"))
324          await asyncio.sleep(2)
325          with open("ultroid_updates.txt", "w+") as file:
326              file.write(tl_chnglog)
327          await okk.edit(
328              get_string("upd_5"),
329              file="ultroid_updates.txt",
330              buttons=button,
331          )
332          remove("ultroid_updates.txt")
333          return
334      await okk.edit(
335          changelog_str,
336          buttons=button,
337          parse_mode="html",
338      )
339  @callback(
340      re.compile(
341          "pasta-(.*)",
342      ),
343      owner=True,
344  )
345  async def _(e):
346      ok = (e.data_match.group(1)).decode("UTF-8")
347      index = None
348      if "|" in ok:
349          ok, index = ok.split("|")
350      with open(ok, "r") as hmm:
351          _, key = await get_paste(hmm.read())
352      link = f"https://spaceb.in/{key}"
353      raw = f"https://spaceb.in/api/v1/documents/{key}/raw"
354      if not _:
355          return await e.answer(key[:30], alert=True)
356      if ok.startswith("addons"):
357          key = "Addons"
358      elif ok.startswith("vcbot"):
359          key = "VCBot"
360      else:
361          key = "Official"
362      data = f"uh_{key}_"
363      if index is not None:
364          data += f"|{index}"
365      await e.edit(
366          "",
367          buttons=[
368              [Button.url("Lɪɴᴋ", link), Button.url("Rᴀᴡ", raw)],
369              [Button.inline("« Bᴀᴄᴋ", data=data)],
370          ],
371      )
372  @callback(re.compile("cbs_(.*)"), owner=True)
373  async def _edit_to(event):
374      match = event.data_match.group(1).decode("utf-8")
375      data = _buttons.get(match)
376      if not data:
377          return
378      await event.edit(data["text"], buttons=data["buttons"], link_preview=False)
379  @callback(re.compile("abs_(.*)"), owner=True)
380  async def convo_handler(event: events.CallbackQuery):
381      match = event.data_match.group(1).decode("utf-8")
382      if not _convo.get(match):
383          return
384      await event.delete()
385      get_ = _convo[match]
386      back = get_["back"]
387      async with event.client.conversation(event.sender_id) as conv:
388          await conv.send_message(get_["text"])
389          response = await conv.get_response()
390          themssg = response.message
391          try:
392              themssg = ast.literal_eval(themssg)
393          except Exception:
394              pass
395          if themssg == "/cancel":
396              return await conv.send_message(
397                  "Cancelled!!",
398                  buttons=get_back_button(back),
399              )
400          await setit(event, get_["var"], themssg)
401          await conv.send_message(
402              f"{get_['name']} changed to `{themssg}`",
403              buttons=get_back_button(back),
404          )
405  @callback("authorise", owner=True)
406  async def _(e):
407      if not e.is_private:
408          return
409      url = GDrive._create_token_file()
410      await e.edit("Go to the below link and send the code!")
411      async with asst.conversation(e.sender_id) as conv:
412          await conv.send_message(url)
413          code = await conv.get_response()
414          if GDrive._create_token_file(code=code.text):
415              await conv.send_message(
416                  "`Success!\nYou are all set to use Google Drive with Ultroid Userbot.`",
417                  buttons=Button.inline("Main Menu", data="setter"),
418              )
419          else:
420              await conv.send_message("Wrong code! Click authorise again.")
421  @callback("folderid", owner=True, func=lambda x: x.is_private)
422  async def _(e):
423      if not e.is_private:
424          return
425      msg = (
426          "Send your FOLDER ID\n\n"
427          + "For FOLDER ID:\n"
428          + "1. Open Google Drive App.\n"
429          + "2. Create Folder.\n"
430          + "3. Make that folder public.\n"
431          + "4. Send link of that folder."
432      )
433      await e.delete()
434      async with asst.conversation(e.sender_id, timeout=150) as conv:
435          await conv.send_message(msg)
436          repl = await conv.get_response()
437          id = repl.text
438          if id.startswith("https"):
439              id = id.split("?id=")[-1]
440          udB.set_key("GDRIVE_FOLDER_ID", id)
441          await repl.reply(
442              "`Success.`",
443              buttons=get_back_button("gdrive"),
444          )
445  @callback("gdrive", owner=True)
446  async def _(e):
447      if not e.is_private:
448          return
449      await e.edit(
450          "Click Authorise and send the code.\n\nYou can use your own CLIENT ID and SECRET by [this](https://t.me/UltroidUpdates/37)",
451          buttons=[
452              [
453                  Button.inline("Folder ID", data="folderid"),
454                  Button.inline("Authorise", data="authorise"),
455              ],
456              [Button.inline("« Back", data="cbs_otvars")],
457          ],
458          link_preview=False,
459      )
460  @callback("dmof", owner=True)
461  async def rhwhe(e):
462      if udB.get_key("DUAL_MODE"):
463          udB.del_key("DUAL_MODE")
464          key = "Off"
465      else:
466          udB.set_key("DUAL_MODE", "True")
467          key = "On"
468      Msg = f"Dual Mode : {key}"
469      await e.edit(Msg, buttons=get_back_button("cbs_otvars"))
470  @callback("dmhn", owner=True)
471  async def hndlrr(event):
472      await event.delete()
473      pru = event.sender_id
474      var = "DUAL_HNDLR"
475      name = "Dual Handler"
476      CH = udB.get_key(var) or "/"
477      async with event.client.conversation(pru) as conv:
478          await conv.send_message(
479              f"Send The Symbol Which u want as Handler/Trigger to use your Assistant bot\nUr Current Handler is [ `{CH}` ]\n\n use /cancel to cancel.",
480          )
481          response = conv.wait_event(events.NewMessage(chats=pru))
482          response = await response
483          themssg = response.message.message
484          if themssg == "/cancel":
485              await conv.send_message(
486                  "Cancelled!!",
487                  buttons=get_back_button("cbs_otvars"),
488              )
489          elif len(themssg) > 1:
490              await conv.send_message(
491                  "Incorrect Handler",
492                  buttons=get_back_button("cbs_otvars"),
493              )
494          else:
495              await setit(event, var, themssg)
496              await conv.send_message(
497                  f"{name} changed to {themssg}",
498                  buttons=get_back_button("cbs_otvars"),
499              )
500  @callback("emoj", owner=True)
501  async def emoji(event):
502      await event.delete()
503      pru = event.sender_id
504      var = "EMOJI_IN_HELP"
505      name = f"Emoji in `{HNDLR}help` menu"
506      async with event.client.conversation(pru) as conv:
507          await conv.send_message("Send emoji u want to set 🙃.\n\nUse /cancel to cancel.")
508          response = conv.wait_event(events.NewMessage(chats=pru))
509          response = await response
510          themssg = response.message.message
511          if themssg == "/cancel":
512              await conv.send_message(
513                  "Cancelled!!",
514                  buttons=get_back_button("cbs_otvars"),
515              )
516          elif themssg.startswith(("/", HNDLR)):
517              await conv.send_message(
518                  "Incorrect Emoji",
519                  buttons=get_back_button("cbs_otvars"),
520              )
521          else:
522              await setit(event, var, themssg)
523              await conv.send_message(
524                  f"{name} changed to {themssg}\n",
525                  buttons=get_back_button("cbs_otvars"),
526              )
527  @callback("plg", owner=True)
528  async def pluginch(event):
529      await event.delete()
530      pru = event.sender_id
531      var = "PLUGIN_CHANNEL"
532      name = "Plugin Channel"
533      async with event.client.conversation(pru) as conv:
534          await conv.send_message(
535              "Send id or username of a channel from where u want to install all plugins\n\nOur Channel~ @ultroidplugins\n\nUse /cancel to cancel.",
536          )
537          response = conv.wait_event(events.NewMessage(chats=pru))
538          response = await response
539          themssg = response.message.message
540          if themssg == "/cancel":
541              await conv.send_message(
542                  "Cancelled!!",
543                  buttons=get_back_button("cbs_otvars"),
544              )
545          elif themssg.startswith(("/", HNDLR)):
546              await conv.send_message(
547                  "Incorrect channel",
548                  buttons=get_back_button("cbs_otvars"),
549              )
550          else:
551              await setit(event, var, themssg)
552              await conv.send_message(
553                  f"{name} changed to {themssg}\n After Setting All Things Do Restart",
554                  buttons=get_back_button("cbs_otvars"),
555              )
556  @callback("hhndlr", owner=True)
557  async def hndlrr(event):
558      await event.delete()
559      pru = event.sender_id
560      var = "HNDLR"
561      name = "Handler/ Trigger"
562      async with event.client.conversation(pru) as conv:
563          await conv.send_message(
564              f"Send The Symbol Which u want as Handler/Trigger to use bot\nUr Current Handler is [ `{HNDLR}` ]\n\n use /cancel to cancel.",
565          )
566          response = conv.wait_event(events.NewMessage(chats=pru))
567          response = await response
568          themssg = response.message.message
569          if themssg == "/cancel":
570              await conv.send_message(
571                  "Cancelled!!",
572                  buttons=get_back_button("cbs_otvars"),
573              )
574          elif len(themssg) > 1:
575              await conv.send_message(
576                  "Incorrect Handler",
577                  buttons=get_back_button("cbs_otvars"),
578              )
579          elif themssg.startswith(("/", "#", "@")):
580              await conv.send_message(
581                  "This cannot be used as handler",
582                  buttons=get_back_button("cbs_otvars"),
583              )
584          else:
585              await setit(event, var, themssg)
586              await conv.send_message(
587                  f"{name} changed to {themssg}",
588                  buttons=get_back_button("cbs_otvars"),
589              )
590  @callback("shndlr", owner=True)
591  async def hndlrr(event):
592      await event.delete()
593      pru = event.sender_id
594      var = "SUDO_HNDLR"
595      name = "Sudo Handler"
596      async with event.client.conversation(pru) as conv:
597          await conv.send_message(
598              "Send The Symbol Which u want as Sudo Handler/Trigger to use bot\n\n use /cancel to cancel."
599          )
600          response = conv.wait_event(events.NewMessage(chats=pru))
601          response = await response
602          themssg = response.message.message
603          if themssg == "/cancel":
604              await conv.send_message(
605                  "Cancelled!!",
606                  buttons=get_back_button("cbs_otvars"),
607              )
608          elif len(themssg) > 1:
609              await conv.send_message(
610                  "Incorrect Handler",
611                  buttons=get_back_button("cbs_otvars"),
612              )
613          elif themssg.startswith(("/", "#", "@")):
614              await conv.send_message(
615                  "This cannot be used as handler",
616                  buttons=get_back_button("cbs_otvars"),
617              )
618          else:
619              await setit(event, var, themssg)
620              await conv.send_message(
621                  f"{name} changed to {themssg}",
622                  buttons=get_back_button("cbs_otvars"),
623              )
624  @callback("taglog", owner=True)
625  async def tagloggrr(e):
626      BUTTON = [
627          [Button.inline("SET TAG LOG", data="abs_settag")],
628          [Button.inline("DELETE TAG LOG", data="deltag")],
629          get_back_button("cbs_otvars"),
630      ]
631      await e.edit(
632          "Choose Options",
633          buttons=BUTTON,
634      )
635  @callback("deltag", owner=True)
636  async def _(e):
637      udB.del_key("TAG_LOG")
638      await e.answer("Done!!! Tag Logger has been turned Off")
639  @callback("eaddon", owner=True)
640  async def pmset(event):
641      BT = (
642          [Button.inline("Aᴅᴅᴏɴs  Oғғ", data="edof")]
643          if udB.get_key("ADDONS")
644          else [Button.inline("Aᴅᴅᴏɴs  Oɴ", data="edon")]
645      )
646      await event.edit(
647          "ADDONS~ Extra Plugins:",
648          buttons=[
649              BT,
650              [Button.inline("« Bᴀᴄᴋ", data="cbs_otvars")],
651          ],
652      )
653  @callback("edon", owner=True)
654  async def eddon(event):
655      var = "ADDONS"
656      await setit(event, var, "True")
657      await event.edit(
658          "Done! ADDONS has been turned on!!\n\n After Setting All Things Do Restart",
659          buttons=get_back_button("eaddon"),
660      )
661  @callback("edof", owner=True)
662  async def eddof(event):
663      udB.set_key("ADDONS", "False")
664      await event.edit(
665          "Done! ADDONS has been turned off!! After Setting All Things Do Restart",
666          buttons=get_back_button("eaddon"),
667      )
668  @callback("sudo", owner=True)
669  async def pmset(event):
670      BT = (
671          [Button.inline("Sᴜᴅᴏ Mᴏᴅᴇ  Oғғ", data="ofsudo")]
672          if udB.get_key("SUDO")
673          else [Button.inline("Sᴜᴅᴏ Mᴏᴅᴇ  Oɴ", data="onsudo")]
674      )
675      await event.edit(
676          f"SUDO MODE ~ Some peoples can use ur Bot which u selected. To know More use `{HNDLR}help sudo`",
677          buttons=[
678              BT,
679              [Button.inline("« Bᴀᴄᴋ", data="cbs_otvars")],
680          ],
681      )
682  @callback("onsudo", owner=True)
683  async def eddon(event):
684      var = "SUDO"
685      await setit(event, var, "True")
686      await event.edit(
687          "Done! SUDO MODE has been turned on!!\n\n After Setting All Things Do Restart",
688          buttons=get_back_button("sudo"),
689      )
690  @callback("ofsudo", owner=True)
691  async def eddof(event):
692      var = "SUDO"
693      await setit(event, var, "False")
694      await event.edit(
695          "Done! SUDO MODE has been turned off!! After Setting All Things Do Restart",
696          buttons=get_back_button("sudo"),
697      )
698  @callback("sfgrp", owner=True)
699  async def sfgrp(event):
700      await event.delete()
701      name = "FBan Group ID"
702      var = "FBAN_GROUP_ID"
703      pru = event.sender_id
704      async with asst.conversation(pru) as conv:
705          await conv.send_message(
706              f"Make a group, add @MissRose_Bot, send `{HNDLR}id`, copy that and send it here.\nUse /cancel to go back.",
707          )
708          response = conv.wait_event(events.NewMessage(chats=pru))
709          response = await response
710          themssg = response.message.message
711          if themssg == "/cancel":
712              return await conv.send_message(
713                  "Cancelled!!",
714                  buttons=get_back_button("cbs_sfban"),
715              )
716          await setit(event, var, themssg)
717          await conv.send_message(
718              f"{name} changed to {themssg}",
719              buttons=get_back_button("cbs_sfban"),
720          )
721  @callback("alvmed", owner=True)
722  async def media(event):
723      await event.delete()
724      pru = event.sender_id
725      var = "ALIVE_PIC"
726      name = "Alive Media"
727      async with event.client.conversation(pru) as conv:
728          await conv.send_message(
729              "**Alive Media**\nSend me a pic/gif/media to set as alive media.\n\nUse /cancel to terminate the operation.",
730          )
731          response = await conv.get_response()
732          try:
733              themssg = response.message
734              if themssg == "/cancel":
735                  return await conv.send_message(
736                      "Operation cancelled!!",
737                      buttons=get_back_button("cbs_alvcstm"),
738                  )
739          except BaseException as er:
740              LOGS.exception(er)
741          if (
742              not (response.text).startswith("/")
743              and response.text != ""
744              and (not response.media or isinstance(response.media, MessageMediaWebPage))
745          ):
746              url = text_to_url(response)
747          elif response.sticker:
748              url = response.file.id
749          else:
750              media = await event.client.download_media(response, "alvpc")
751              try:
752                  x = upl(media)
753                  url = f"https://graph.org/{x[0]}"
754                  remove(media)
755              except BaseException as er:
756                  LOGS.exception(er)
757                  return await conv.send_message(
758                      "Terminated.",
759                      buttons=get_back_button("cbs_alvcstm"),
760                  )
761          await setit(event, var, url)
762          await conv.send_message(
763              f"{name} has been set.",
764              buttons=get_back_button("cbs_alvcstm"),
765          )
766  @callback("delmed", owner=True)
767  async def dell(event):
768      try:
769          udB.del_key("ALIVE_PIC")
770          return await event.edit(
771              get_string("clst_5"), buttons=get_back_button("cbs_alabs_vcstm")
772          )
773      except BaseException as er:
774          LOGS.exception(er)
775          return await event.edit(
776              get_string("clst_4"),
777              buttons=get_back_button("cbs_alabs_vcstm"),
778          )
779  @callback("inpm_in", owner=True)
780  async def inl_on(event):
781      var = "INLINE_PM"
782      await setit(event, var, "True")
783      await event.edit(
784          "Done!! PMPermit type has been set to inline!",
785          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_pmtype")]],
786      )
787  @callback("inpm_no", owner=True)
788  async def inl_on(event):
789      var = "INLINE_PM"
790      await setit(event, var, "False")
791      await event.edit(
792          "Done!! PMPermit type has been set to normal!",
793          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_pmtype")]],
794      )
795  @callback("pmtxt", owner=True)
796  async def name(event):
797      await event.delete()
798      pru = event.sender_id
799      var = "PM_TEXT"
800      name = "PM Text"
801      async with event.client.conversation(pru) as conv:
802          await conv.send_message(
803              "**PM Text**\nEnter the new Pmpermit text.\n\nu can use `{name}` `{fullname}` `{count}` `{mention}` `{username}` to get this from user Too\n\nUse /cancel to terminate the operation.",
804          )
805          response = conv.wait_event(events.NewMessage(chats=pru))
806          response = await response
807          themssg = response.message.message
808          if themssg == "/cancel":
809              return await conv.send_message(
810                  "Cancelled!!",
811                  buttons=get_back_button("cbs_pmcstm"),
812              )
813          if len(themssg) > 4090:
814              return await conv.send_message(
815                  "Message too long!\nGive a shorter message please!!",
816                  buttons=get_back_button("cbs_pmcstm"),
817              )
818          await setit(event, var, themssg)
819          await conv.send_message(
820              f"{name} changed to {themssg}\n\nAfter Setting All Things Do restart",
821              buttons=get_back_button("cbs_pmcstm"),
822          )
823  @callback("swarn", owner=True)
824  async def name(event):
825      m = range(1, 10)
826      tultd = [Button.inline(f"{x}", data=f"wrns_{x}") for x in m]
827      lst = list(zip(tultd[::3], tultd[1::3], tultd[2::3]))
828      lst.append([Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")])
829      await event.edit(
830          "Select the number of warnings for a user before getting blocked in PMs.",
831          buttons=lst,
832      )
833  @callback(re.compile(b"wrns_(.*)"), owner=True)
834  async def set_wrns(event):
835      value = int(event.data_match.group(1).decode("UTF-8"))
836      if dn := udB.set_key("PMWARNS", value):
837          await event.edit(
838              f"PM Warns Set to {value}.\nNew users will have {value} chances in PMs before getting banned.",
839              buttons=get_back_button("cbs_pmcstm"),
840          )
841      else:
842          await event.edit(
843              f"Something went wrong, please check your {HNDLR}logs!",
844              buttons=get_back_button("cbs_pmcstm"),
845          )
846  @callback("pmmed", owner=True)
847  async def media(event):
848      await event.delete()
849      pru = event.sender_id
850      var = "PMPIC"
851      name = "PM Media"
852      async with event.client.conversation(pru) as conv:
853          await conv.send_message(
854              "**PM Media**\nSend me a pic/gif/sticker/link  to set as pmpermit media.\n\nUse /cancel to terminate the operation.",
855          )
856          response = await conv.get_response()
857          try:
858              themssg = response.message
859              if themssg == "/cancel":
860                  return await conv.send_message(
861                      "Operation cancelled!!",
862                      buttons=get_back_button("cbs_pmcstm"),
863                  )
864          except BaseException as er:
865              LOGS.exception(er)
866          media = await event.client.download_media(response, "pmpc")
867          if (
868              not (response.text).startswith("/")
869              and response.text != ""
870              and (not response.media or isinstance(response.media, MessageMediaWebPage))
871          ):
872              url = text_to_url(response)
873          elif response.sticker:
874              url = response.file.id
875          else:
876              try:
877                  x = upl(media)
878                  url = f"https://graph.org/{x[0]}"
879                  remove(media)
880              except BaseException as er:
881                  LOGS.exception(er)
882                  return await conv.send_message(
883                      "Terminated.",
884                      buttons=get_back_button("cbs_pmcstm"),
885                  )
886          await setit(event, var, url)
887          await conv.send_message(
888              f"{name} has been set.",
889              buttons=get_back_button("cbs_pmcstm"),
890          )
891  @callback("delpmmed", owner=True)
892  async def dell(event):
893      try:
894          udB.del_key("PMPIC")
895          return await event.edit(
896              get_string("clst_5"), buttons=get_back_button("cbs_pmcstm")
897          )
898      except BaseException as er:
899          LOGS.exception(er)
900          return await event.edit(
901              get_string("clst_4"),
902              buttons=[[Button.inline("« Sᴇᴛᴛɪɴɢs", data="setter")]],
903          )
904  @callback("apon", owner=True)
905  async def apon(event):
906      var = "AUTOAPPROVE"
907      await setit(event, var, "True")
908      await event.edit(
909          "Done!! AUTOAPPROVE  Started!!",
910          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_apauto")]],
911      )
912  @callback("apof", owner=True)
913  async def apof(event):
914      try:
915          udB.set_key("AUTOAPPROVE", "False")
916          return await event.edit(
917              "Done! AUTOAPPROVE Stopped!!",
918              buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_apauto")]],
919          )
920      except BaseException as er:
921          LOGS.exception(er)
922          return await event.edit(
923              get_string("clst_4"),
924              buttons=[[Button.inline("« Sᴇᴛᴛɪɴɢs", data="setter")]],
925          )
926  @callback("pml", owner=True)
927  async def l_vcs(event):
928      BT = (
929          [Button.inline("PMLOGGER OFF", data="pmlogof")]
930          if udB.get_key("PMLOG")
931          else [Button.inline("PMLOGGER ON", data="pmlog")]
932      )
933      await event.edit(
934          "PMLOGGER This Will Forward Ur Pm to Ur Private Group -",
935          buttons=[
936              BT,
937              [Button.inline("PᴍLᴏɢɢᴇʀ Gʀᴏᴜᴘ", "abs_pmlgg")],
938              [Button.inline("« Bᴀᴄᴋ", data="cbs_pmcstm")],
939          ],
940      )
941  @callback("pmlog", owner=True)
942  async def pmlog(event):
943      await setit(event, "PMLOG", "True")
944      await event.edit(
945          "Done!! PMLOGGER  Started!!",
946          buttons=[[Button.inline("« Bᴀᴄᴋ", data="pml")]],
947      )
948  @callback("pmlogof", owner=True)
949  async def pmlogof(event):
950      try:
951          udB.del_key("PMLOG")
952          return await event.edit(
953              "Done! PMLOGGER Stopped!!",
954              buttons=[[Button.inline("« Bᴀᴄᴋ", data="pml")]],
955          )
956      except BaseException as er:
957          LOGS.exception(er)
958          return await event.edit(
959              get_string("clst_4"),
960              buttons=[[Button.inline("« Sᴇᴛᴛɪɴɢs", data="setter")]],
961          )
962  @callback("pmon", owner=True)
963  async def pmonn(event):
964      var = "PMSETTING"
965      await setit(event, var, "True")
966      await event.edit(
967          "Done! PMPermit has been turned on!!",
968          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_ppmset")]],
969      )
970  @callback("pmoff", owner=True)
971  async def pmofff(event):
972      var = "PMSETTING"
973      await setit(event, var, "False")
974      await event.edit(
975          "Done! PMPermit has been turned off!!",
976          buttons=[[Button.inline("« Bᴀᴄᴋ", data="cbs_ppmset")]],
977      )
978  @callback("botmew", owner=True)
979  async def hhh(e):
980      async with e.client.conversation(e.chat_id) as conv:
981          await conv.send_message("Send Any Media to keep at your Bot's welcome ")
982          msg = await conv.get_response()
983          if not msg.media or msg.text.startswith("/"):
984              return await conv.send_message(
985                  "Terminated!", buttons=get_back_button("cbs_chatbot")
986              )
987          udB.set_key("STARTMEDIA", msg.file.id)
988          await conv.send_message("Done!", buttons=get_back_button("cbs_chatbot"))
989  @callback("botinfe", owner=True)
990  async def hhh(e):
991      async with e.client.conversation(e.chat_id) as conv:
992          await conv.send_message(
993              "Send message to set to Display, when user Press Info button in Bot Welcome!\n\nsend `False` to completely remove that button.."
994          )
995          msg = await conv.get_response()
996          if msg.media or msg.text.startswith("/"):
997              return await conv.send_message(
998                  "Terminated!", buttons=get_back_button("cbs_chatbot")
999              )
1000          udB.set_key("BOT_INFO_START", msg.text)
1001          await conv.send_message("Done!", buttons=get_back_button("cbs_chatbot"))
1002  @callback("pmfs", owner=True)
1003  async def heheh(event):
1004      Ll = []
1005      err = ""
1006      async with event.client.conversation(event.chat_id) as conv:
1007          await conv.send_message(
1008              "• Send The Chat Id(s), which you want user to Join Before using Chat/Pm Bot\n\n• Send /clear to disable PmBot Force sub..\n• • Send /cancel to stop this process.."
1009          )
1010          await conv.send_message(
1011              "Example : \n`-1001234567\n-100778888`\n\nFor Multiple Chat(s)."
1012          )
1013          try:
1014              msg = await conv.get_response()
1015          except AsyncTimeOut:
1016              return await conv.send_message("**• TimeUp!**\nStart from /start back.")
1017          if not msg.text or msg.text.startswith("/"):
1018              timyork = "Cancelled!"
1019              if msg.text == "/clear":
1020                  udB.del_key("PMBOT_FSUB")
1021                  timyork = "Done! Force Subscribe Stopped\nRestart your Bot!"
1022              return await conv.send_message(
1023                  "Cancelled!", buttons=get_back_button("cbs_chatbot")
1024              )
1025          for chat in msg.message.split("\n"):
1026              if chat.startswith("-") or chat.isdigit():
1027                  chat = int(chat)
1028              try:
1029                  CHSJSHS = await event.client.get_entity(chat)
1030                  Ll.append(get_peer_id(CHSJSHS))
1031              except Exception as er:
1032                  err += f"**{chat}** : {er}\n"
1033          if err:
1034              return await conv.send_message(err)
1035          udB.set_key("PMBOT_FSUB", str(Ll))
1036          await conv.send_message(
1037              "Done!\nRestart Your Bot.", buttons=get_back_button("cbs_chatbot")
1038          )
1039  @callback("bwel", owner=True)
1040  async def name(event):
1041      await event.delete()
1042      pru = event.sender_id
1043      var = "STARTMSG"
1044      name = "Bot Welcome Message:"
1045      async with event.client.conversation(pru) as conv:
1046          await conv.send_message(
1047              "**BOT WELCOME MSG**\nEnter the msg which u want to show when someone start your assistant Bot.\nYou Can use `{me}` , `{mention}` Parameters Too\nUse /cancel to terminate the operation.",
1048          )
1049          response = conv.wait_event(events.NewMessage(chats=pru))
1050          response = await response
1051          themssg = response.message.message
1052          if themssg == "/cancel":
1053              return await conv.send_message(
1054                  "Cancelled!!",
1055                  buttons=get_back_button("cbs_chatbot"),
1056              )
1057          await setit(event, var, themssg)
1058          await conv.send_message(
1059              f"{name} changed to {themssg}",
1060              buttons=get_back_button("cbs_chatbot"),
1061          )
1062  @callback("onchbot", owner=True)
1063  async def chon(event):
1064      var = "PMBOT"
1065      await setit(event, var, "True")
1066      Loader(path="assistant/pmbot.py", key="PM Bot").load()
1067      if AST_PLUGINS.get("pmbot"):
1068          for i, e in AST_PLUGINS["pmbot"]:
1069              event.client.remove_event_handler(i)
1070          for i, e in AST_PLUGINS["pmbot"]:
1071              event.client.add_event_handler(i, events.NewMessage(**e))
1072      await event.edit(
1073          "Done! Now u Can Chat With People Via This Bot",
1074          buttons=[Button.inline("« Bᴀᴄᴋ", data="cbs_chatbot")],
1075      )
1076  @callback("ofchbot", owner=True)
1077  async def chon(event):
1078      var = "PMBOT"
1079      await setit(event, var, "False")
1080      if AST_PLUGINS.get("pmbot"):
1081          for i, e in AST_PLUGINS["pmbot"]:
1082              event.client.remove_event_handler(i)
1083      await event.edit(
1084          "Done! Chat People Via This Bot Stopped.",
1085          buttons=[Button.inline("« Bᴀᴄᴋ", data="cbs_chatbot")],
1086      )
1087  @callback("inli_pic", owner=True)
1088  async def media(event):
1089      await event.delete()
1090      pru = event.sender_id
1091      var = "INLINE_PIC"
1092      name = "Inline Media"
1093      async with event.client.conversation(pru) as conv:
1094          await conv.send_message(
1095              "**Inline Media**\nSend me a pic/gif/ or link  to set as inline media.\n\nUse /cancel to terminate the operation.",
1096          )
1097          response = await conv.get_response()
1098          try:
1099              themssg = response.message
1100              if themssg == "/cancel":
1101                  return await conv.send_message(
1102                      "Operation cancelled!!",
1103                      buttons=get_back_button("setter"),
1104                  )
1105          except BaseException as er:
1106              LOGS.exception(er)
1107          media = await event.client.download_media(response, "inlpic")
1108          if (
1109              not (response.text).startswith("/")
1110              and response.text != ""
1111              and (not response.media or isinstance(response.media, MessageMediaWebPage))
1112          ):
1113              url = text_to_url(response)
1114          else:
1115              try:
1116                  x = upl(media)
1117                  url = f"https://graph.org/{x[0]}"
1118                  remove(media)
1119              except BaseException as er:
1120                  LOGS.exception(er)
1121                  return await conv.send_message(
1122                      "Terminated.",
1123                      buttons=get_back_button("setter"),
1124                  )
1125          await setit(event, var, url)
1126          await conv.send_message(
1127              f"{name} has been set.",
1128              buttons=get_back_button("setter"),
1129          )
1130  FD_MEDIA = {}
1131  @callback(re.compile("fd(.*)"), owner=True)
1132  async def fdroid_dler(event):
1133      uri = event.data_match.group(1).decode("utf-8")
1134      if FD_MEDIA.get(uri):
1135          return await event.edit(file=FD_MEDIA[uri])
1136      await event.answer("• Starting Download •", alert=True)
1137      await event.edit("• Downloading.. •")
1138      URL = f"https://f-droid.org/packages/{uri}"
1139      conte = await async_searcher(URL, re_content=True)
1140      BSC = bs(conte, "html.parser", from_encoding="utf-8")
1141      dl_ = BSC.find("p", "package-version-download").find("a")["href"]
1142      title = BSC.find("h3", "package-name").text.strip()
1143      thumb = BSC.find("img", "package-icon")["src"]
1144      if thumb.startswith("/"):
1145          thumb = f"https://f-droid.org{thumb}"
1146      thumb, _ = await fast_download(thumb, filename=f"{uri}.png")
1147      s_time = time.time()
1148      file, _ = await fast_download(
1149          dl_,
1150          filename=f"{title}.apk",
1151          progress_callback=lambda d, t: asyncio.get_event_loop().create_task(
1152              progress(
1153                  d,
1154                  t,
1155                  event,
1156                  s_time,
1157                  "Downloading...",
1158              )
1159          ),
1160      )
1161      time.time()
1162      n_file = await event.client.fast_uploader(
1163          file, show_progress=True, event=event, message="Uploading...", to_delete=True
1164      )
1165      buttons = Button.switch_inline("Search Back", query="fdroid", same_peer=True)
1166      try:
1167          msg = await event.edit(
1168              f"**• [{title}]({URL}) •**", file=n_file, thumb=thumb, buttons=buttons
1169          )
1170      except Exception as er:
1171          LOGS.exception(er)
1172          try:
1173              msg = await event.client.edit_message(
1174                  await event.get_input_chat(),
1175                  event.message_id,
1176                  f"**• [{title}]({URL}) •**",
1177                  buttons=buttons,
1178                  thumb=thumb,
1179                  file=n_file,
1180              )
1181          except Exception as er:
1182              os.remove(thumb)
1183              LOGS.exception(er)
1184              return await event.edit(f"**ERROR**: `{er}`", buttons=buttons)
1185      if msg and hasattr(msg, "media"):
1186          FD_MEDIA.update({uri: msg.media})
1187      os.remove(thumb)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___48.py</h3>
            <pre><code>1  import argparse
2  import hashlib
3  import operator
4  import os
5  import struct
6  import sys
7  import tempfile
8  import zlib
9  from collections import namedtuple
10  from cryptography import exceptions
11  from cryptography.hazmat.backends import default_backend
12  from cryptography.hazmat.primitives import hashes
13  from cryptography.hazmat.primitives import serialization
14  from cryptography.hazmat.primitives.asymmetric import ec, padding, rsa, utils
15  from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
16  from cryptography.utils import int_to_bytes
17  import ecdsa
18  import esptool
19  SIG_BLOCK_MAGIC = 0xE7
20  SIG_BLOCK_VERSION_RSA = 0x02
21  SIG_BLOCK_VERSION_ECDSA = 0x03
22  CURVE_ID_P192 = 1
23  CURVE_ID_P256 = 2
24  SECTOR_SIZE = 4096
25  SIG_BLOCK_SIZE = (
26      1216  # Refer to secure boot v2 signature block format for more details.
27  )
28  def get_chunks(source, chunk_len):
29      return (source[i : i + chunk_len] for i in range(0, len(source), chunk_len))
30  def endian_swap_words(source):
31      assert len(source) % 4 == 0
32      words = "I" * (len(source) // 4)
33      return struct.pack("<" + words, *struct.unpack(">" + words, source))
34  def swap_word_order(source):
35      assert len(source) % 4 == 0
36      words = "I" * (len(source) // 4)
37      return struct.pack(words, *reversed(struct.unpack(words, source)))
38  def _load_hardware_key(keyfile):
39      key = keyfile.read()
40      if len(key) not in [16, 24, 32, 64]:
41          raise esptool.FatalError(
42              "Key file contains wrong length (%d bytes), 16, 24, 32 or 64 expected."
43              % len(key)
44          )
45      if len(key) == 16:
46          key = _sha256_digest(key)
47          print("Using 128-bit key (extended)")
48      elif len(key) == 24:
49          key = key + key[8:16]
50          assert len(key) == 32
51          print("Using 192-bit key (extended)")
52      elif len(key) == 32:
53          print("Using 256-bit key")
54      else:
55          print("Using 512-bit key")
56      return key
57  def digest_secure_bootloader(args):
58      _check_output_is_not_input(args.keyfile, args.output)
59      _check_output_is_not_input(args.image, args.output)
60      _check_output_is_not_input(args.iv, args.output)
61      if args.iv is not None:
62          print("WARNING: --iv argument is for TESTING PURPOSES ONLY")
63          iv = args.iv.read(128)
64      else:
65          iv = os.urandom(128)
<span onclick='openModal()' class='match'>66      plaintext_image = args.image.read()
67      args.image.seek(0)
68      fw_image = esptool.bin_image.ESP32FirmwareImage(args.image)
</span>69      if fw_image.append_digest:
70          if len(plaintext_image) % 128 <= 32:
71              new_len = len(plaintext_image) - (len(plaintext_image) % 128)
72              plaintext_image = plaintext_image[:new_len]
73      if len(plaintext_image) % 128 != 0:
74          plaintext_image += b"\xFF" * (128 - (len(plaintext_image) % 128))
75      plaintext = iv + plaintext_image
76      key = _load_hardware_key(args.keyfile)
77      backend = default_backend()
78      cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
79      encryptor = cipher.encryptor()
80      digest = hashlib.sha512()
81      for block in get_chunks(plaintext, 16):
82          block = block[::-1]  # reverse each input block
83          cipher_block = encryptor.update(block)
84          cipher_block = cipher_block[::-1]
85          for block in get_chunks(cipher_block, 4):
86              digest.update(block[::-1])
87      if args.output is None:
88          args.output = os.path.splitext(args.image.name)[0] + "-digest-0x0000.bin"
89      with open(args.output, "wb") as f:
90          f.write(iv)
91          digest = digest.digest()
92          for word in get_chunks(digest, 4):
93              f.write(word[::-1])  # swap word order in the result
94          f.write(b"\xFF" * (0x1000 - f.tell()))  # pad to 0x1000
95          f.write(plaintext_image)
96      print("digest+image written to %s" % args.output)
97  def _generate_ecdsa_signing_key(curve_id, keyfile):
98      sk = ecdsa.SigningKey.generate(curve=curve_id)
99      with open(keyfile, "wb") as f:
100          f.write(sk.to_pem())
101  def generate_signing_key(args):
102      if os.path.exists(args.keyfile):
103          raise esptool.FatalError("ERROR: Key file %s already exists" % args.keyfile)
104      if args.version == "1":
105          if hasattr(args, "scheme"):
106              if args.scheme != "ecdsa256" and args.scheme is not None:
107                  raise esptool.FatalError("ERROR: V1 only supports ECDSA256")
108          _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
109          print("ECDSA NIST256p private key in PEM format written to %s" % args.keyfile)
110      elif args.version == "2":
111          if args.scheme == "rsa3072" or args.scheme is None:
112              private_key = rsa.generate_private_key(
113                  public_exponent=65537, key_size=3072, backend=default_backend()
114              ).private_bytes(
115                  encoding=serialization.Encoding.PEM,
116                  format=serialization.PrivateFormat.TraditionalOpenSSL,
117                  encryption_algorithm=serialization.NoEncryption(),
118              )
119              with open(args.keyfile, "wb") as f:
120                  f.write(private_key)
121              print("RSA 3072 private key in PEM format written to %s" % args.keyfile)
122          elif args.scheme == "ecdsa192":
123              _generate_ecdsa_signing_key(ecdsa.NIST192p, args.keyfile)
124              print(
125                  "ECDSA NIST192p private key in PEM format written to %s" % args.keyfile
126              )
127          elif args.scheme == "ecdsa256":
128              _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
129              print(
130                  "ECDSA NIST256p private key in PEM format written to %s" % args.keyfile
131              )
132          else:
133              raise esptool.FatalError(
134                  "ERROR: Unsupported signing scheme (%s)" % args.scheme
135              )
136  def load_ecdsa_signing_key(keyfile):
137      try:
138          sk = ecdsa.SigningKey.from_pem(keyfile.read())
139      except ValueError:
140          raise esptool.FatalError(
141              "Incorrect ECDSA private key specified. "
142              "Please check algorithm and/or format."
143          )
144      if sk.curve not in [ecdsa.NIST192p, ecdsa.NIST256p]:
145          raise esptool.FatalError("Supports NIST192p and NIST256p keys only")
146      return sk
147  def _load_ecdsa_signing_key(keyfile):
148      sk = load_ecdsa_signing_key(keyfile)
149      if sk.curve != ecdsa.NIST256p:
150          raise esptool.FatalError(
151              "Signing key uses incorrect curve. ESP32 Secure Boot only supports "
152              "NIST256p (openssl calls this curve 'prime256v1')"
153          )
154      return sk
155  def _load_ecdsa_verifying_key(keyfile):
156      try:
157          vk = ecdsa.VerifyingKey.from_pem(keyfile.read())
158      except ValueError:
159          raise esptool.FatalError(
160              "Incorrect ECDSA public key specified. "
161              "Please check algorithm and/or format."
162          )
163      if vk.curve != ecdsa.NIST256p:
164          raise esptool.FatalError(
165              "Signing key uses incorrect curve. ESP32 Secure Boot only supports "
166              "NIST256p (openssl calls this curve 'prime256v1')"
167          )
168      return vk
169  def _load_sbv2_signing_key(keydata):
170      sk = serialization.load_pem_private_key(
171          keydata, password=None, backend=default_backend()
172      )
173      if isinstance(sk, rsa.RSAPrivateKey):
174          if sk.key_size != 3072:
175              raise esptool.FatalError(
176                  "Key file has length %d bits. Secure boot v2 only supports RSA-3072."
177                  % sk.key_size
178              )
179          return sk
180      if isinstance(sk, ec.EllipticCurvePrivateKey):
181          if not (
182              isinstance(sk.curve, ec.SECP192R1) or isinstance(sk.curve, ec.SECP256R1)
183          ):
184              raise esptool.FatalError(
185                  "Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports "
186                  "NIST192p, NIST256p (aka prime192v1, prime256v1)"
187              )
188          return sk
189      raise esptool.FatalError("Unsupported signing key for Secure Boot V2")
190  def _load_sbv2_pub_key(keydata):
191      vk = serialization.load_pem_public_key(keydata, backend=default_backend())
192      if isinstance(vk, rsa.RSAPublicKey):
193          if vk.key_size != 3072:
194              raise esptool.FatalError(
195                  "Key file has length %d bits. Secure boot v2 only supports RSA-3072."
196                  % vk.key_size
197              )
198          return vk
199      if isinstance(vk, ec.EllipticCurvePublicKey):
200          if not (
201              isinstance(vk.curve, ec.SECP192R1) or isinstance(vk.curve, ec.SECP256R1)
202          ):
203              raise esptool.FatalError(
204                  "Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports "
205                  "NIST192p, NIST256p (aka prime192v1, prime256v1)"
206              )
207          return vk
208      raise esptool.FatalError("Unsupported public key for Secure Boot V2")
209  def _get_sbv2_pub_key(keyfile):
210      key_data = keyfile.read()
211      if (
212          b"-BEGIN RSA PRIVATE KEY" in key_data
213          or b"-BEGIN EC PRIVATE KEY" in key_data
214          or b"-BEGIN PRIVATE KEY" in key_data
215      ):
216          return _load_sbv2_signing_key(key_data).public_key()
217      elif b"-BEGIN PUBLIC KEY" in key_data:
218          vk = _load_sbv2_pub_key(key_data)
219      else:
220          raise esptool.FatalError(
221              "Verification key does not appear to be an RSA Private or "
222              "Public key in PEM format. Unsupported"
223          )
224      return vk
225  def _get_sbv2_rsa_primitives(public_key):
226      primitives = namedtuple("primitives", ["n", "e", "m", "rinv"])
227      numbers = public_key.public_numbers()
228      primitives.n = numbers.n  #
229      primitives.e = numbers.e  # two public key components
230      primitives.m = -rsa._modinv(primitives.n, 1 << 32)
231      rr = 1 << (public_key.key_size * 2)
232      primitives.rinv = rr % primitives.n
233      return primitives
234  def _microecc_format(a, b, curve_len):
235      byte_len = int(curve_len / 8)
236      ab = int_to_bytes(a, byte_len)[::-1] + int_to_bytes(b, byte_len)[::-1]
237      assert len(ab) == 48 or len(ab) == 64
238      return ab
239  def sign_data(args):
240      if args.keyfile:
241          _check_output_is_not_input(args.keyfile, args.output)
242      _check_output_is_not_input(args.datafile, args.output)
243      if args.version == "1":
244          return sign_secure_boot_v1(args)
245      elif args.version == "2":
246          return sign_secure_boot_v2(args)
247  def sign_secure_boot_v1(args):
248      binary_content = args.datafile.read()
249      if args.hsm:
250          raise esptool.FatalError(
251              "Secure Boot V1 does not support signing using an "
252              "external Hardware Security Module (HSM)"
253          )
254      if args.signature:
255          print("Pre-calculated signatures found")
256          if len(args.pub_key) > 1:
257              raise esptool.FatalError("Secure Boot V1 only supports one signing key")
258          signature = args.signature[0].read()
259          vk = _load_ecdsa_verifying_key(args.pub_key[0])
260      else:
261          if len(args.keyfile) > 1:
262              raise esptool.FatalError("Secure Boot V1 only supports one signing key")
263          sk = _load_ecdsa_signing_key(args.keyfile[0])
264          signature = sk.sign_deterministic(binary_content, hashlib.sha256)
265          vk = sk.get_verifying_key()
266      vk.verify(signature, binary_content, hashlib.sha256)  # throws exception on failure
267      if args.output is None or os.path.abspath(args.output) == os.path.abspath(
268          args.datafile.name
269      ):  # append signature to input file
270          args.datafile.close()
271          outfile = open(args.datafile.name, "ab")
272      else:  # write file & signature to new file
273          outfile = open(args.output, "wb")
274          outfile.write(binary_content)
275      outfile.write(
276          struct.pack("I", 0)
277      )  # Version indicator, allow for different curves/formats later
278      outfile.write(signature)
279      outfile.close()
280      print("Signed %d bytes of data from %s" % (len(binary_content), args.datafile.name))
281  def sign_secure_boot_v2(args):
282      SIG_BLOCK_MAX_COUNT = 3
283      contents = args.datafile.read()
284      sig_block_num = 0
285      signature_sector = b""
286      signature = args.signature
287      pub_key = args.pub_key
288      if len(contents) % SECTOR_SIZE != 0:
289          if args.signature:
290              raise esptool.FatalError(
291                  "Secure Boot V2 requires the signature block to start "
292                  "from a 4KB aligned sector "
293                  "but the datafile supplied is not sector aligned."
294              )
295          else:
296              pad_by = SECTOR_SIZE - (len(contents) % SECTOR_SIZE)
297              print(
298                  f"Padding data contents by {pad_by} bytes "
299                  "so signature sector aligns at sector boundary"
300              )
301              contents += b"\xff" * pad_by
302      elif args.append_signatures:
303          while sig_block_num < SIG_BLOCK_MAX_COUNT:
304              sig_block = validate_signature_block(contents, sig_block_num)
305              if sig_block is None:
306                  break
307              signature_sector += (
308                  sig_block  # Signature sector is populated with already valid blocks
309              )
310              sig_block_num += 1
311          if len(signature_sector) % SIG_BLOCK_SIZE != 0:
312              raise esptool.FatalError("Incorrect signature sector size")
313          if sig_block_num == 0:
314              print(
315                  "No valid signature blocks found. "
316                  "Discarding --append-signature and proceeding to sign the image afresh."
317              )
318          else:
319              print(
320                  f"{sig_block_num} valid signature block(s) already present "
321                  "in the signature sector."
322              )
323              if sig_block_num == SIG_BLOCK_MAX_COUNT:
324                  raise esptool.FatalError(
325                      f"Upto {SIG_BLOCK_MAX_COUNT} signature blocks are supported. "
326                      "(For ESP32-ECO3 only 1 signature block is supported)"
327                  )
328              contents = contents[: len(contents) - SECTOR_SIZE]
329      if args.hsm:
330          if args.hsm_config is None:
331              raise esptool.FatalError(
332                  "Config file is required to generate signature using an external HSM."
333              )
334          import espsecure.esp_hsm_sign as hsm
335          try:
336              config = hsm.read_hsm_config(args.hsm_config)
337          except Exception as e:
338              raise esptool.FatalError(f"Incorrect HSM config file format ({e})")
339          if pub_key is None:
340              pub_key = extract_pubkey_from_hsm(config)
341          signature = generate_signature_using_hsm(config, contents)
342      if signature:
343          print("Pre-calculated signatures found")
344          key_count = len(pub_key)
345          if len(signature) != key_count:
346              raise esptool.FatalError(
347                  f"Number of public keys ({key_count}) not equal to "
348                  f"the number of signatures {len(signature)}."
349              )
350      else:
351          key_count = len(args.keyfile)
352      empty_signature_blocks = SIG_BLOCK_MAX_COUNT - sig_block_num
353      if key_count > empty_signature_blocks:
354          raise esptool.FatalError(
355              f"Number of keys({key_count}) more than the empty signature blocks."
356              f"({empty_signature_blocks})"
357          )
358      print(f"{key_count} signing key(s) found.")
359      digest = hashlib.sha256()
360      digest.update(contents)
361      digest = digest.digest()
362      if signature:
363          signature_block = generate_signature_block_using_pre_calculated_signature(
364              signature, pub_key, digest
365          )
366      else:
367          signature_block = generate_signature_block_using_private_key(
368              args.keyfile, digest
369          )
370      if signature_block is None or len(signature_block) == 0:
371          raise esptool.FatalError("Signature Block generation failed")
372      signature_sector += signature_block
373      if (
374          len(signature_sector) < 0
375          and len(signature_sector) > SIG_BLOCK_SIZE * 3
376          and len(signature_sector) % SIG_BLOCK_SIZE != 0
377      ):
378          raise esptool.FatalError("Incorrect signature sector generation")
379      total_sig_blocks = len(signature_sector) // SIG_BLOCK_SIZE
380      signature_sector = signature_sector + (
381          b"\xff" * (SECTOR_SIZE - len(signature_sector))
382      )
383      if len(signature_sector) != SECTOR_SIZE:
384          raise esptool.FatalError("Incorrect signature sector size")
385      if args.output is None:
386          args.datafile.close()
387          args.output = args.datafile.name
388      with open(args.output, "wb") as f:
389          f.write(contents + signature_sector)
390      print(
391          f"Signed {len(contents)} bytes of data from {args.datafile.name}. "
392          f"Signature sector now has {total_sig_blocks} signature blocks."
393      )
394  def generate_signature_using_hsm(config, contents):
395      import espsecure.esp_hsm_sign as hsm
396      session = hsm.establish_session(config)
397      private_key = hsm.get_privkey_info(session, config)
398      signature = hsm.sign_payload(private_key, contents)
399      hsm.close_connection(session)
400      temp_signature_file = tempfile.TemporaryFile()
401      temp_signature_file.write(signature)
402      temp_signature_file.seek(0)
403      return [temp_signature_file]
404  def generate_signature_block_using_pre_calculated_signature(signature, pub_key, digest):
405      signature_blocks = b""
406      for sig, pk in zip(signature, pub_key):
407          try:
408              public_key = _get_sbv2_pub_key(pk)
409              signature = sig.read()
410              if isinstance(public_key, rsa.RSAPublicKey):
411                  rsa_primitives = _get_sbv2_rsa_primitives(public_key)
412                  public_key.verify(
413                      signature,
414                      digest,
415                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
416                      utils.Prehashed(hashes.SHA256()),
417                  )
418                  signature_block = generate_rsa_signature_block(
419                      digest, rsa_primitives, signature
420                  )
421              else:
422                  numbers = public_key.public_numbers()
423                  if isinstance(numbers.curve, ec.SECP192R1):
424                      curve_len = 192
425                      curve_id = CURVE_ID_P192
426                  elif isinstance(numbers.curve, ec.SECP256R1):
427                      curve_len = 256
428                      curve_id = CURVE_ID_P256
429                  else:
430                      raise esptool.FatalError("Invalid ECDSA curve instance.")
431                  public_key.verify(
432                      signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
433                  )
434                  pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
435                  r, s = utils.decode_dss_signature(signature)
436                  signature_rs = _microecc_format(r, s, curve_len)
437                  signature_block = generate_ecdsa_signature_block(
438                      digest, curve_id, pubkey_point, signature_rs
439                  )
440          except exceptions.InvalidSignature:
441              raise esptool.FatalError(
442                  "Signature verification failed: Invalid Signature\n"
443                  "The pre-calculated signature has not been signed "
444                  "using the given public key"
445              )
446          signature_block += struct.pack("<I", zlib.crc32(signature_block) & 0xFFFFFFFF)
447          signature_block += b"\x00" * 16  # padding
448          if len(signature_block) != SIG_BLOCK_SIZE:
449              raise esptool.FatalError("Incorrect signature block size")
450          signature_blocks += signature_block
451      return signature_blocks
452  def generate_signature_block_using_private_key(keyfiles, digest):
453      signature_blocks = b""
454      for keyfile in keyfiles:
455          private_key = _load_sbv2_signing_key(keyfile.read())
456          if isinstance(private_key, rsa.RSAPrivateKey):
457              signature = private_key.sign(
458                  digest,
459                  padding.PSS(
460                      mgf=padding.MGF1(hashes.SHA256()),
461                      salt_length=32,
462                  ),
463                  utils.Prehashed(hashes.SHA256()),
464              )
465              rsa_primitives = _get_sbv2_rsa_primitives(private_key.public_key())
466              signature_block = generate_rsa_signature_block(
467                  digest, rsa_primitives, signature
468              )
469          else:
470              signature = private_key.sign(
471                  digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
472              )
473              numbers = private_key.public_key().public_numbers()
474              if isinstance(private_key.curve, ec.SECP192R1):
475                  curve_len = 192
476                  curve_id = CURVE_ID_P192
477              elif isinstance(numbers.curve, ec.SECP256R1):
478                  curve_len = 256
479                  curve_id = CURVE_ID_P256
480              else:
481                  raise esptool.FatalError("Invalid ECDSA curve instance.")
482              pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
483              r, s = utils.decode_dss_signature(signature)
484              signature_rs = _microecc_format(r, s, curve_len)
485              signature_block = generate_ecdsa_signature_block(
486                  digest, curve_id, pubkey_point, signature_rs
487              )
488          signature_block += struct.pack("<I", zlib.crc32(signature_block) & 0xFFFFFFFF)
489          signature_block += b"\x00" * 16  # padding
490          if len(signature_block) != SIG_BLOCK_SIZE:
491              raise esptool.FatalError("Incorrect signature block size")
492          signature_blocks += signature_block
493      return signature_blocks
494  def generate_rsa_signature_block(digest, rsa_primitives, signature):
495      signature_block = struct.pack(
496          "<BBxx32s384sI384sI384s",
497          SIG_BLOCK_MAGIC,
498          SIG_BLOCK_VERSION_RSA,
499          digest,
500          int_to_bytes(rsa_primitives.n)[::-1],
501          rsa_primitives.e,
502          int_to_bytes(rsa_primitives.rinv)[::-1],
503          rsa_primitives.m & 0xFFFFFFFF,
504          signature[::-1],
505      )
506      return signature_block
507  def generate_ecdsa_signature_block(digest, curve_id, pubkey_point, signature_rs):
508      signature_block = struct.pack(
509          "<BBxx32sB64s64s1031x",
510          SIG_BLOCK_MAGIC,
511          SIG_BLOCK_VERSION_ECDSA,
512          digest,
513          curve_id,
514          pubkey_point,
515          signature_rs,
516      )
517      return signature_block
518  def verify_signature(args):
519      if args.version == "1":
520          return verify_signature_v1(args)
521      elif args.version == "2":
522          return verify_signature_v2(args)
523  def verify_signature_v1(args):
524      key_data = args.keyfile.read()
525      if b"-BEGIN EC PRIVATE KEY" in key_data:
526          sk = ecdsa.SigningKey.from_pem(key_data)
527          vk = sk.get_verifying_key()
528      elif b"-BEGIN PUBLIC KEY" in key_data:
529          vk = ecdsa.VerifyingKey.from_pem(key_data)
530      elif len(key_data) == 64:
531          vk = ecdsa.VerifyingKey.from_string(key_data, curve=ecdsa.NIST256p)
532      else:
533          raise esptool.FatalError(
534              "Verification key does not appear to be an EC key in PEM format "
535              "or binary EC public key data. Unsupported"
536          )
537      if vk.curve != ecdsa.NIST256p:
538          raise esptool.FatalError(
539              "Public key uses incorrect curve. ESP32 Secure Boot only supports "
540              "NIST256p (openssl calls this curve 'prime256v1"
541          )
542      binary_content = args.datafile.read()
543      data = binary_content[0:-68]
544      sig_version, signature = struct.unpack("I64s", binary_content[-68:])
545      if sig_version != 0:
546          raise esptool.FatalError(
547              "Signature block has version %d. This version of espsecure "
548              "only supports version 0." % sig_version
549          )
550      print("Verifying %d bytes of data" % len(data))
551      try:
552          if vk.verify(signature, data, hashlib.sha256):
553              print("Signature is valid")
554          else:
555              raise esptool.FatalError("Signature is not valid")
556      except ecdsa.keys.BadSignatureError:
557          raise esptool.FatalError("Signature is not valid")
558  def validate_signature_block(image_content, sig_blk_num):
559      offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
560      sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
561      assert len(sig_blk) == SIG_BLOCK_SIZE
562      magic, version, _, _, _, _, _, _, blk_crc = struct.unpack(
563          "<BBxx32s384sI384sI384sI16x", sig_blk
564      )
565      calc_crc = zlib.crc32(sig_blk[:1196])
566      is_invalid_block = magic != SIG_BLOCK_MAGIC
567      is_invalid_block |= version not in [SIG_BLOCK_VERSION_RSA, SIG_BLOCK_VERSION_ECDSA]
568      if is_invalid_block or blk_crc != calc_crc & 0xFFFFFFFF:  # Signature block invalid
569          return None
570      key_type = "RSA" if version == SIG_BLOCK_VERSION_RSA else "ECDSA"
571      print(f"Signature block {sig_blk_num} is valid ({key_type}).")
572      return sig_blk
573  def verify_signature_v2(args):
574      keyfile = args.keyfile
575      if args.hsm:
576          if args.hsm_config is None:
577              raise esptool.FatalError(
578                  "Config file is required to extract public key from an external HSM."
579              )
580          import espsecure.esp_hsm_sign as hsm
581          try:
582              config = hsm.read_hsm_config(args.hsm_config)
583          except Exception as e:
584              raise esptool.FatalError(f"Incorrect HSM config file format ({e})")
585          keyfile = extract_pubkey_from_hsm(config)[0]
586      vk = _get_sbv2_pub_key(keyfile)
587      if isinstance(vk, rsa.RSAPublicKey):
588          SIG_BLOCK_MAX_COUNT = 3
589      elif isinstance(vk, ec.EllipticCurvePublicKey):
590          SIG_BLOCK_MAX_COUNT = 1
591      image_content = args.datafile.read()
592      if len(image_content) < SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
593          raise esptool.FatalError(
594              "Invalid datafile. Data size should be non-zero & a multiple of 4096."
595          )
596      digest = digest = hashlib.sha256()
597      digest.update(image_content[:-SECTOR_SIZE])
598      digest = digest.digest()
599      valid = False
600      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
601          sig_blk = validate_signature_block(image_content, sig_blk_num)
602          if sig_blk is None:
603              print(f"Signature block {sig_blk_num} invalid. Skipping.")
604              continue
605          _, version, blk_digest = struct.unpack("<BBxx32s", sig_blk[:36])
606          if blk_digest != digest:
607              raise esptool.FatalError(
608                  "Signature block image digest does not match "
609                  f"the actual image digest {digest}. Expected {blk_digest}."
610              )
611          try:
612              if isinstance(vk, rsa.RSAPublicKey):
613                  _, _, _, _, signature, _ = struct.unpack(
614                      "<384sI384sI384sI16x", sig_blk[36:]
615                  )
616                  vk.verify(
617                      signature[::-1],
618                      digest,
619                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
620                      utils.Prehashed(hashes.SHA256()),
621                  )
622              else:
623                  curve_id, _pubkey, encoded_rs = struct.unpack(
624                      "B64s64s1031x4x16x", sig_blk[36:]
625                  )
626                  assert curve_id in (CURVE_ID_P192, CURVE_ID_P256)
627                  keylen = (
628                      24 if curve_id == CURVE_ID_P192 else 32
629                  )  # length of each number in the keypair
630                  r = int.from_bytes(encoded_rs[:keylen], "little")
631                  s = int.from_bytes(encoded_rs[keylen : keylen * 2], "little")
632                  signature = utils.encode_dss_signature(r, s)
633                  vk.verify(signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256())))
634              key_type = "RSA" if isinstance(vk, rsa.RSAPublicKey) else "ECDSA"
635              print(
636                  f"Signature block {sig_blk_num} verification successful using "
637                  f"the supplied key ({key_type})."
638              )
639              valid = True
640          except exceptions.InvalidSignature:
641              print(
642                  f"Signature block {sig_blk_num} is not signed by the supplied key. "
643                  "Checking the next block"
644              )
645              continue
646      if not valid:
647          raise esptool.FatalError(
648              "Checked all blocks. Signature could not be verified with the provided key."
649          )
650  def extract_public_key(args):
651      _check_output_is_not_input(args.keyfile, args.public_keyfile)
652      if args.version == "1":
653          sk = _load_ecdsa_signing_key(args.keyfile)
654          vk = sk.get_verifying_key()
655          args.public_keyfile.write(vk.to_string())
656      elif args.version == "2":
657          sk = _load_sbv2_signing_key(args.keyfile.read())
658          vk = sk.public_key().public_bytes(
659              encoding=serialization.Encoding.PEM,
660              format=serialization.PublicFormat.SubjectPublicKeyInfo,
661          )
662          args.public_keyfile.write(vk)
663      print(
664          "%s public key extracted to %s" % (args.keyfile.name, args.public_keyfile.name)
665      )
666  def extract_pubkey_from_hsm(config):
667      import espsecure.esp_hsm_sign as hsm
668      session = hsm.establish_session(config)
669      public_key = hsm.get_pubkey(session, config)
670      hsm.close_connection(session)
671      pem = public_key.public_bytes(
672          encoding=serialization.Encoding.PEM,
673          format=serialization.PublicFormat.SubjectPublicKeyInfo,
674      )
675      temp_pub_key_file = tempfile.TemporaryFile()
676      temp_pub_key_file.write(pem)
677      temp_pub_key_file.seek(0)
678      return [temp_pub_key_file]
679  def _sha256_digest(data):
680      digest = hashlib.sha256()
681      digest.update(data)
682      return digest.digest()
683  def signature_info_v2(args):
684      SIG_BLOCK_MAX_COUNT = 3
685      image_content = args.datafile.read()
686      if len(image_content) < SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
687          raise esptool.FatalError(
688              "Invalid datafile. Data size should be non-zero & a multiple of 4096."
689          )
690      digest = _sha256_digest(image_content[:-SECTOR_SIZE])
691      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
692          sig_blk = validate_signature_block(image_content, sig_blk_num)
693          if sig_blk is None:
694              print(
695                  "Signature block %d absent/invalid. Skipping checking next blocks."
696                  % sig_blk_num
697              )
698              return
699          sig_data = struct.unpack("<BBxx32s384sI384sI384sI16x", sig_blk)
700          if sig_data[2] != digest:
701              raise esptool.FatalError(
702                  "Digest in signature block %d doesn't match the image digest."
703                  % (sig_blk_num)
704              )
705          offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
706          sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
707          if sig_data[1] == SIG_BLOCK_VERSION_RSA:
708              key_digest = _sha256_digest(sig_blk[36:812])
709          elif sig_data[1] == SIG_BLOCK_VERSION_ECDSA:
710              key_digest = _sha256_digest(sig_blk[36:101])
711          else:
712              raise esptool.FatalError(
713                  "Unsupported scheme in signature block %d" % (sig_blk_num)
714              )
715          print(
716              "Public key digest for block %d: %s"
717              % (sig_blk_num, " ".join("{:02x}".format(c) for c in bytearray(key_digest)))
718          )
719  def _digest_sbv2_public_key(keyfile):
720      public_key = _get_sbv2_pub_key(keyfile)
721      if isinstance(public_key, rsa.RSAPublicKey):
722          rsa_primitives = _get_sbv2_rsa_primitives(public_key)
723          binary_format = struct.pack(
724              "<384sI384sI",
725              int_to_bytes(rsa_primitives.n)[::-1],
726              rsa_primitives.e,
727              int_to_bytes(rsa_primitives.rinv)[::-1],
728              rsa_primitives.m & 0xFFFFFFFF,
729          )
730      else:  # ECC public key
731          numbers = public_key.public_numbers()
732          if isinstance(public_key.curve, ec.SECP192R1):
733              curve_len = 192
734              curve_id = CURVE_ID_P192
735          else:
736              curve_len = 256
737              curve_id = CURVE_ID_P256
738          pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
739          binary_format = struct.pack(
740              "<B64s",
741              curve_id,
742              pubkey_point,
743          )
744      return hashlib.sha256(binary_format).digest()
745  def digest_sbv2_public_key(args):
746      _check_output_is_not_input(args.keyfile, args.output)
747      public_key_digest = _digest_sbv2_public_key(args.keyfile)
748      with open(args.output, "wb") as f:
749          print(
750              "Writing the public key digest of %s to %s."
751              % (args.keyfile.name, args.output)
752          )
753          f.write(public_key_digest)
754  def digest_rsa_public_key(args):
755      digest_sbv2_public_key(args)
756  def digest_private_key(args):
757      _check_output_is_not_input(args.keyfile, args.digest_file)
758      sk = _load_ecdsa_signing_key(args.keyfile)
759      repr(sk.to_string())
760      digest = hashlib.sha256()
761      digest.update(sk.to_string())
762      result = digest.digest()
763      if args.keylen == 192:
764          result = result[0:24]
765      args.digest_file.write(result)
766      print(
767          "SHA-256 digest of private key %s%s written to %s"
768          % (
769              args.keyfile.name,
770              "" if args.keylen == 256 else " (truncated to 192 bits)",
771              args.digest_file.name,
772          )
773      )
774  _FLASH_ENCRYPTION_TWEAK_PATTERN = [
775      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
776      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
777      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
778      14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
779      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
780      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
781      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
782      12, 11, 10, 9, 8, 7, 6, 5,
783      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
784      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
785      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
786      10, 9, 8, 7, 6, 5,
787      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
788      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
789      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
790      8, 7, 6, 5
791  ]
792  assert len(_FLASH_ENCRYPTION_TWEAK_PATTERN) == 256
793  def _flash_encryption_tweak_range(flash_crypt_config=0xF):
794      tweak_range = []
795      if (flash_crypt_config & 1) != 0:
796          tweak_range += range(67)
797      if (flash_crypt_config & 2) != 0:
798          tweak_range += range(67, 132)
799      if (flash_crypt_config & 4) != 0:
800          tweak_range += range(132, 195)
801      if (flash_crypt_config & 8) != 0:
802          tweak_range += range(195, 256)
803      return tweak_range
804  def _flash_encryption_tweak_range_bits(flash_crypt_config=0xF):
805      tweak_range = 0
806      if (flash_crypt_config & 1) != 0:
807          tweak_range |= (
808              0xFFFFFFFFFFFFFFFFE00000000000000000000000000000000000000000000000
809          )
810      if (flash_crypt_config & 2) != 0:
811          tweak_range |= (
812              0x00000000000000001FFFFFFFFFFFFFFFF0000000000000000000000000000000
813          )
814      if (flash_crypt_config & 4) != 0:
815          tweak_range |= (
816              0x000000000000000000000000000000000FFFFFFFFFFFFFFFE000000000000000
817          )
818      if (flash_crypt_config & 8) != 0:
819          tweak_range |= (
820              0x0000000000000000000000000000000000000000000000001FFFFFFFFFFFFFFF
821          )
822      return tweak_range
823  mul1 = 0x0000200004000080000004000080001000000200004000080000040000800010
824  mul2 = 0x0000000000000000200000000000000010000000000000002000000000000001
825  mul1_mask = 0xFFFFFFFFFFFFFF801FFFFFFFFFFFFFF00FFFFFFFFFFFFFF81FFFFFFFFFFFFFF0
826  mul2_mask = 0x000000000000007FE00000000000000FF000000000000007E00000000000000F
827  def _flash_encryption_tweak_key(key, offset, tweak_range):
828      addr = offset >> 5
829      key ^= ((mul1 * addr) | ((mul2 * addr) & mul2_mask)) & tweak_range
830      return int.to_bytes(key, length=32, byteorder="big", signed=False)
831  def generate_flash_encryption_key(args):
832      print("Writing %d random bits to key file %s" % (args.keylen, args.key_file.name))
833      args.key_file.write(os.urandom(args.keylen // 8))
834  def _flash_encryption_operation_esp32(
835      output_file, input_file, flash_address, keyfile, flash_crypt_conf, do_decrypt
836  ):
837      key = _load_hardware_key(keyfile)
838      if flash_address % 16 != 0:
839          raise esptool.FatalError(
840              "Starting flash address 0x%x must be a multiple of 16" % flash_address
841          )
842      if flash_crypt_conf == 0:
843          print("WARNING: Setting FLASH_CRYPT_CONF to zero is not recommended")
844      tweak_range = _flash_encryption_tweak_range_bits(flash_crypt_conf)
845      key = int.from_bytes(key, byteorder="big", signed=False)
846      backend = default_backend()
847      cipher = None
848      block_offs = flash_address
849      while True:
850          block = input_file.read(16)
851          if len(block) == 0:
852              break
853          elif len(block) < 16:
854              if do_decrypt:
855                  raise esptool.FatalError("Data length is not a multiple of 16 bytes")
856              pad = 16 - len(block)
857              block = block + os.urandom(pad)
858              print(
859                  "Note: Padding with %d bytes of random data "
860                  "(encrypted data must be multiple of 16 bytes long)" % pad
861              )
862          if block_offs % 32 == 0 or cipher is None:
863              block_key = _flash_encryption_tweak_key(key, block_offs, tweak_range)
864              if cipher is None:  # first pass
865                  cipher = Cipher(algorithms.AES(block_key), modes.ECB(), backend=backend)
866                  actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
867              else:
868                  try:
869                      backend = actor._ctx._backend
870                      res = backend._lib.EVP_CipherInit_ex(
871                          actor._ctx._ctx,
872                          backend._ffi.NULL,
873                          backend._ffi.NULL,
874                          backend._ffi.from_buffer(block_key),
875                          backend._ffi.NULL,
876                          actor._ctx._operation,
877                      )
878                      backend.openssl_assert(res != 0)
879                  except AttributeError:
880                      cipher.algorithm.key = block_key
881                      actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
882          block = block[::-1]  # reverse input block byte order
883          block = actor.update(block)
884          output_file.write(block[::-1])  # reverse output block byte order
885          block_offs += 16
886  def _flash_encryption_operation_aes_xts(
887      output_file, input_file, flash_address, keyfile, do_decrypt
888  ):
889      backend = default_backend()
890      key = _load_hardware_key(keyfile)
891      indata = input_file.read()
892      if flash_address % 16 != 0:
893          raise esptool.FatalError(
894              "Starting flash address 0x%x must be a multiple of 16" % flash_address
895          )
896      if len(indata) % 16 != 0:
897          raise esptool.FatalError(
898              "Input data length (%d) must be a multiple of 16" % len(indata)
899          )
900      if len(indata) == 0:
901          raise esptool.FatalError("Input data must be longer than 0")
902      pad_left = flash_address % 0x80
903      indata = (b"\x00" * pad_left) + indata
904      pad_right = len(indata) % 0x80
905      if pad_right > 0:
906          pad_right = 0x80 - pad_right
907      indata = indata + (b"\x00" * pad_right)
908      inblocks = _split_blocks(indata, 0x80)  # split into 1024 bit blocks
909      output = []
910      for inblock in inblocks:  # for each block
911          tweak = struct.pack("<I", (flash_address & ~0x7F)) + (b"\x00" * 12)
912          flash_address += 0x80  # for next block
913          if len(tweak) != 16:
914              raise esptool.FatalError(
915                  "Length of tweak must be 16, was {}".format(len(tweak))
916              )
917          cipher = Cipher(algorithms.AES(key), modes.XTS(tweak), backend=backend)
918          encryptor = cipher.decryptor() if do_decrypt else cipher.encryptor()
919          inblock = inblock[::-1]  # reverse input
920          outblock = encryptor.update(inblock)  # standard algo
921          output.append(outblock[::-1])  # reverse output
922      output = b"".join(output)
923      if pad_right != 0:
924          output = output[:-pad_right]
925      if pad_left != 0:
926          output = output[pad_left:]
927      if len(output) != len(indata) - pad_left - pad_right:
928          raise esptool.FatalError(
929              "Length of input data ({}) should match the output data ({})".format(
930                  len(indata) - pad_left - pad_right, len(output)
931              )
932          )
933      output_file.write(output)
934  def _split_blocks(text, block_len=16):
935      assert len(text) % block_len == 0
936      pos = 0
937      while pos < len(text):
938          yield text[pos : pos + block_len]
939          pos = pos + block_len
940  def decrypt_flash_data(args):
941      _check_output_is_not_input(args.keyfile, args.output)
942      _check_output_is_not_input(args.encrypted_file, args.output)
943      if args.aes_xts:
944          return _flash_encryption_operation_aes_xts(
945              args.output, args.encrypted_file, args.address, args.keyfile, True
946          )
947      else:
948          return _flash_encryption_operation_esp32(
949              args.output,
950              args.encrypted_file,
951              args.address,
952              args.keyfile,
953              args.flash_crypt_conf,
954              True,
955          )
956  def encrypt_flash_data(args):
957      _check_output_is_not_input(args.keyfile, args.output)
958      _check_output_is_not_input(args.plaintext_file, args.output)
959      if args.aes_xts:
960          return _flash_encryption_operation_aes_xts(
961              args.output, args.plaintext_file, args.address, args.keyfile, False
962          )
963      else:
964          return _flash_encryption_operation_esp32(
965              args.output,
966              args.plaintext_file,
967              args.address,
968              args.keyfile,
969              args.flash_crypt_conf,
970              False,
971          )
972  def _samefile(p1, p2):
973      return os.path.normcase(os.path.normpath(p1)) == os.path.normcase(
974          os.path.normpath(p2)
975      )
976  def _check_output_is_not_input(input_file, output_file):
977      i = getattr(input_file, "name", input_file)
978      o = getattr(output_file, "name", output_file)
979      check_f = _samefile if isinstance(i, str) and isinstance(o, str) else operator.eq
980      if check_f(i, o):
981          raise esptool.FatalError(
982              'The input "{}" and output "{}" should not be the same!'.format(i, o)
983          )
984  class OutFileType(object):
985      def __init__(self):
986          self.path = None
987          self.file_obj = None
988      def __call__(self, path):
989          self.path = path
990          return self
991      def __repr__(self):
992          return "{}({})".format(type(self).__name__, self.path)
993      def write(self, payload):
994          if len(payload) > 0:
995              if not self.file_obj:
996                  self.file_obj = open(self.path, "wb")
997              self.file_obj.write(payload)
998      def close(self):
999          if self.file_obj:
1000              self.file_obj.close()
1001              self.file_obj = None
1002      @property
1003      def name(self):
1004          return self.path
1005  def main(custom_commandline=None):
1006      parser = argparse.ArgumentParser(
1007          description="espsecure.py v%s - ESP32 Secure Boot & Flash Encryption tool"
1008          % esptool.__version__,
1009          prog="espsecure",
1010      )
1011      subparsers = parser.add_subparsers(
1012          dest="operation", help="Run espsecure.py {command} -h for additional help"
1013      )
1014      p = subparsers.add_parser(
1015          "digest_secure_bootloader",
1016          help="Take a bootloader binary image and a secure boot key, "
1017          "and output a combined digest+binary suitable for flashing along "
1018          "with the precalculated secure boot key.",
1019      )
1020      p.add_argument(
1021          "--keyfile",
1022          "-k",
1023          help="256 bit key for secure boot digest.",
1024          type=argparse.FileType("rb"),
1025          required=True,
1026      )
1027      p.add_argument("--output", "-o", help="Output file for signed digest image.")
1028      p.add_argument(
1029          "--iv",
1030          help="128 byte IV file. Supply a file for testing purposes only, "
1031          "if not supplied an IV will be randomly generated.",
1032          type=argparse.FileType("rb"),
1033      )
1034      p.add_argument(
1035          "image",
1036          help="Bootloader image file to calculate digest from",
1037          type=argparse.FileType("rb"),
1038      )
1039      p = subparsers.add_parser(
1040          "generate_signing_key",
1041          help="Generate a private key for signing secure boot images "
1042          "as per the secure boot version. "
1043          "Key file is generated in PEM format, "
1044          "Secure Boot V1 - ECDSA NIST256p private key. "
1045          "Secure Boot V2 - RSA 3072, ECDSA NIST256p, ECDSA NIST192p private key.",
1046      )
1047      p.add_argument(
1048          "--version",
1049          "-v",
1050          help="Version of the secure boot signing scheme to use.",
1051          choices=["1", "2"],
1052          default="1",
1053      )
1054      p.add_argument(
1055          "--scheme",
1056          "-s",
1057          help="Scheme of secure boot signing.",
1058          choices=["rsa3072", "ecdsa192", "ecdsa256"],
1059          required=False,
1060      )
1061      p.add_argument(
1062          "keyfile", help="Filename for private key file (embedded public key)"
1063      )
1064      p = subparsers.add_parser(
1065          "sign_data",
1066          help="Sign a data file for use with secure boot. "
1067          "Signing algorithm is deterministic ECDSA w/ SHA-512 (V1) "
1068          "or either RSA-PSS or ECDSA w/ SHA-256 (V2).",
1069      )
1070      p.add_argument(
1071          "--version",
1072          "-v",
1073          help="Version of the secure boot signing scheme to use.",
1074          choices=["1", "2"],
1075          required=True,
1076      )
1077      p.add_argument(
1078          "--keyfile",
1079          "-k",
1080          help="Private key file for signing. Key is in PEM format.",
1081          type=argparse.FileType("rb"),
1082          nargs="+",
1083      )
1084      p.add_argument(
1085          "--append_signatures",
1086          "-a",
1087          help="Append signature block(s) to already signed image. "
1088          "Valid only for ESP32-S2.",
1089          action="store_true",
1090      )
1091      p.add_argument(
1092          "--hsm",
1093          help="Use an external Hardware Security Module "
1094          "to generate signature using PKCS#11 interface.",
1095          action="store_true",
1096      )
1097      p.add_argument(
1098          "--hsm-config",
1099          help="Config file for the external Hardware Security Module "
1100          "to be used to generate signature.",
1101          default=None,
1102      )
1103      p.add_argument(
1104          "--pub-key",
1105          help="Public key files corresponding to the private key used to generate "
1106          "the pre-calculated signatures. Keys should be in PEM format.",
1107          type=argparse.FileType("rb"),
1108          nargs="+",
1109      )
1110      p.add_argument(
1111          "--signature",
1112          help="Pre-calculated signatures. "
1113          "Signatures generated using external private keys e.g. keys stored in HSM.",
1114          type=argparse.FileType("rb"),
1115          nargs="+",
1116          default=None,
1117      )
1118      p.add_argument(
1119          "--output",
1120          "-o",
1121          help="Output file for signed digest image. Default is to sign the input file.",
1122      )
1123      p.add_argument(
1124          "datafile",
1125          help="File to sign. For version 1, this can be any file. "
1126          "For version 2, this must be a valid app image.",
1127          type=argparse.FileType("rb"),
1128      )
1129      p = subparsers.add_parser(
1130          "verify_signature",
1131          help='Verify a data file previously signed by "sign_data", '
1132          "using the public key.",
1133      )
1134      p.add_argument(
1135          "--version",
1136          "-v",
1137          help="Version of the secure boot scheme to use.",
1138          choices=["1", "2"],
1139          required=True,
1140      )
1141      p.add_argument(
1142          "--hsm",
1143          help="Use an external Hardware Security Module "
1144          "to verify signature using PKCS#11 interface.",
1145          action="store_true",
1146      )
1147      p.add_argument(
1148          "--hsm-config",
1149          help="Config file for the external Hardware Security Module "
1150          "to be used to verify signature.",
1151          default=None,
1152      )
1153      p.add_argument(
1154          "--keyfile",
1155          "-k",
1156          help="Public key file for verification. "
1157          "Can be private or public key in PEM format.",
1158          type=argparse.FileType("rb"),
1159      )
1160      p.add_argument(
1161          "datafile",
1162          help="Signed data file to verify signature.",
1163          type=argparse.FileType("rb"),
1164      )
1165      p = subparsers.add_parser(
1166          "extract_public_key",
1167          help="Extract the public verification key for signatures, "
1168          "save it as a raw binary file.",
1169      )
1170      p.add_argument(
1171          "--version",
1172          "-v",
1173          help="Version of the secure boot signing scheme to use.",
1174          choices=["1", "2"],
1175          default="1",
1176      )
1177      p.add_argument(
1178          "--keyfile",
1179          "-k",
1180          help="Private key file (PEM format) to extract the "
1181          "public verification key from.",
1182          type=argparse.FileType("rb"),
1183          required=True,
1184      )
1185      p.add_argument(
1186          "public_keyfile", help="File to save new public key into", type=OutFileType()
1187      )
1188      p = subparsers.add_parser(
1189          "digest_rsa_public_key",
1190          help="Generate an SHA-256 digest of the RSA public key. "
1191          "This digest is burned into the eFuse and asserts the legitimacy "
1192          "of the public key for Secure boot v2.",
1193      )
1194      p.add_argument(
1195          "--keyfile",
1196          "-k",
1197          help="Public key file for verification. "
1198          "Can be private or public key in PEM format.",
1199          type=argparse.FileType("rb"),
1200          required=True,
1201      )
1202      p.add_argument("--output", "-o", help="Output file for the digest.", required=True)
1203      p = subparsers.add_parser(
1204          "digest_sbv2_public_key",
1205          help="Generate an SHA-256 digest of the public key. "
1206          "This digest is burned into the eFuse and asserts the legitimacy "
1207          "of the public key for Secure boot v2.",
1208      )
1209      p.add_argument(
1210          "--keyfile",
1211          "-k",
1212          help="Public key file for verification. "
1213          "Can be private or public key in PEM format.",
1214          type=argparse.FileType("rb"),
1215          required=True,
1216      )
1217      p.add_argument("--output", "-o", help="Output file for the digest.", required=True)
1218      p = subparsers.add_parser(
1219          "signature_info_v2",
1220          help="Reads the signature block and provides the signature block information.",
1221      )
1222      p.add_argument(
1223          "datafile",
1224          help="Secure boot v2 signed data file.",
1225          type=argparse.FileType("rb"),
1226      )
1227      p = subparsers.add_parser(
1228          "digest_private_key",
1229          help="Generate an SHA-256 digest of the private signing key. "
1230          "This can be used as a reproducible secure bootloader (only secure boot v1) "
1231          "or flash encryption key.",
1232      )
1233      p.add_argument(
1234          "--keyfile",
1235          "-k",
1236          help="Private key file (PEM format) to generate a digest from.",
1237          type=argparse.FileType("rb"),
1238          required=True,
1239      )
1240      p.add_argument(
1241          "--keylen",
1242          "-l",
1243          help="Length of private key digest file to generate (in bits). "
1244          "3/4 Coding Scheme requires 192 bit key.",
1245          choices=[192, 256],
1246          default=256,
1247          type=int,
1248      )
1249      p.add_argument(
1250          "digest_file", help="File to write 32 byte digest into", type=OutFileType()
1251      )
1252      p = subparsers.add_parser(
1253          "generate_flash_encryption_key",
1254          help="Generate a development-use flash encryption key with random data.",
1255      )
1256      p.add_argument(
1257          "--keylen",
1258          "-l",
1259          help="Length of private key digest file to generate (in bits). "
1260          "3/4 Coding Scheme requires 192 bit key.",
1261          choices=[128, 192, 256, 512],
1262          default=256,
1263          type=int,
1264      )
1265      p.add_argument(
1266          "key_file",
1267          help="File to write 16, 24, 32 or 64 byte key into",
1268          type=OutFileType(),
1269      )
1270      p = subparsers.add_parser(
1271          "decrypt_flash_data",
1272          help="Decrypt some data read from encrypted flash (using known key)",
1273      )
1274      p.add_argument(
1275          "encrypted_file",
1276          help="File with encrypted flash contents",
1277          type=argparse.FileType("rb"),
1278      )
1279      p.add_argument(
1280          "--aes_xts",
1281          "-x",
1282          help="Decrypt data using AES-XTS as used on "
1283          "ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6",
1284          action="store_true",
1285      )
1286      p.add_argument(
1287          "--keyfile",
1288          "-k",
1289          help="File with flash encryption key",
1290          type=argparse.FileType("rb"),
1291          required=True,
1292      )
1293      p.add_argument(
1294          "--output",
1295          "-o",
1296          help="Output file for plaintext data.",
1297          type=OutFileType(),
1298          required=True,
1299      )
1300      p.add_argument(
1301          "--address",
1302          "-a",
1303          help="Address offset in flash that file was read from.",
1304          required=True,
1305          type=esptool.arg_auto_int,
1306      )
1307      p.add_argument(
1308          "--flash_crypt_conf",
1309          help="Override FLASH_CRYPT_CONF efuse value (default is 0XF).",
1310          required=False,
1311          default=0xF,
1312          type=esptool.arg_auto_int,
1313      )
1314      p = subparsers.add_parser(
1315          "encrypt_flash_data",
1316          help="Encrypt some data suitable for encrypted flash (using known key)",
1317      )
1318      p.add_argument(
1319          "--aes_xts",
1320          "-x",
1321          help="Encrypt data using AES-XTS as used on "
1322          "ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6",
1323          action="store_true",
1324      )
1325      p.add_argument(
1326          "--keyfile",
1327          "-k",
1328          help="File with flash encryption key",
1329          type=argparse.FileType("rb"),
1330          required=True,
1331      )
1332      p.add_argument(
1333          "--output",
1334          "-o",
1335          help="Output file for encrypted data.",
1336          type=OutFileType(),
1337          required=True,
1338      )
1339      p.add_argument(
1340          "--address",
1341          "-a",
1342          help="Address offset in flash where file will be flashed.",
1343          required=True,
1344          type=esptool.arg_auto_int,
1345      )
1346      p.add_argument(
1347          "--flash_crypt_conf",
1348          help="Override FLASH_CRYPT_CONF efuse value (default is 0XF).",
1349          required=False,
1350          default=0xF,
1351          type=esptool.arg_auto_int,
1352      )
1353      p.add_argument(
1354          "plaintext_file",
1355          help="File with plaintext content for encrypting",
1356          type=argparse.FileType("rb"),
1357      )
1358      args = parser.parse_args(custom_commandline)
1359      print("espsecure.py v%s" % esptool.__version__)
1360      if args.operation is None:
1361          parser.print_help()
1362          parser.exit(1)
1363      try:
1364          operation_func = globals()[args.operation]
1365          operation_func(args)
1366      finally:
1367          for arg_name in vars(args):
1368              obj = getattr(args, arg_name)
1369              if isinstance(obj, OutFileType):
1370                  obj.close()
1371  def _main():
1372      try:
1373          main()
1374      except esptool.FatalError as e:
1375          print("\nA fatal error occurred: %s" % e)
1376          sys.exit(2)
1377      except ValueError as e:
1378          try:
1379              if [arg for arg in e.args if "Could not deserialize key data." in arg]:
1380                  print(
1381                      "Note: This error originates from the cryptography module. "
1382                      "It is likely not a problem with espsecure, "
1383                      "please make sure you are using a compatible OpenSSL backend."
1384                  )
1385          finally:
1386              raise
1387  if __name__ == "__main__":
1388      _main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-callbackstuffs.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___48.py</div>
                </div>
                <div class="column column_space"><pre><code>52                  Button.inline("Sᴜᴅᴏ HNDLR", data="shndlr"),
53              ],
54              [Button.inline("Dᴜᴀʟ Mᴏᴅᴇ", "cbs_oofdm")],
55              [Button.inline("« Bᴀᴄᴋ", data="setter")],
56          ],
57      },
58      "sfban": {
59          "text": "SuperFban Settings:",
60          "buttons": [
61              [Button.inline("FBᴀɴ Gʀᴏᴜᴘ", data="sfgrp")],
</pre></code></div>
                <div class="column column_space"><pre><code>66      plaintext_image = args.image.read()
67      args.image.seek(0)
68      fw_image = esptool.bin_image.ESP32FirmwareImage(args.image)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    