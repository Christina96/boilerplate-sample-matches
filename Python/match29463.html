<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for rediscluster.py &amp; postgres_local_cache.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for rediscluster.py &amp; postgres_local_cache.py
      </h3>
<h1 align="center">
        8.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>rediscluster.py (15.068493%)<th>postgres_local_cache.py (5.5555553%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(17-46)<td><a href="#" name="0">(111-135)</a><td align="center"><font color="#ff0000">22</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rediscluster.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import hashlib
3 import logging
4 import os
5 import salt.payload
6 try:
7     import rediscluster
8     HAS_REDIS = True
9 except ImportError:
10     HAS_REDIS = False
11 log = logging.getLogger(__name__)
12 __virtualname__ = "rediscluster"
13 def __virtual__():
14     if not HAS_REDIS:
15         return (
16             False,
17             "Could not use redis for tokens; "
18             "rediscluster python client is not installed.",
19         )
20     return __virtualname__
21 def</b></font> _redis_client(opts):
22     """
23     Connect to the redis host and return a StrictRedisCluster client object.
24     If connection fails then return None.
25     """
26     redis_host = opts.get("eauth_redis_host", "localhost")
27     redis_port = opts.get("eauth_redis_port", 6379)
28     try:
29         return rediscluster.StrictRedisCluster(
30             host=redis_host, port=redis_port, decode_responses=True
31         )
32     except rediscluster.exceptions.RedisClusterException as err:
33         log.warning(
34             "Failed to connect to redis at %s:%s - %s", redis_host, redis_port, err
35         )
36         return None
37 def mk_token(opts, tdata):
38     """
39     Mint a new token using the config option hash_type and store tdata with 'token' attribute set
40     to the token.
41     This module uses the hash of random 512 bytes as a token.
42     :param opts: Salt master config options
43     :param tdata: Token data to be stored with 'token' attribute of this dict set to the token.
44     :returns: tdata with token if successful. Empty dict if failed.
45     """
46     redis_client = _redis_client(opts)
47     if not redis_client:
48         return {}
49     hash_type = getattr(hashlib, opts.get("hash_type", "md5"))
50     tok = str(hash_type(os.urandom(512)).hexdigest())
51     try:
52         while redis_client.get(tok) is not None:
53             tok = str(hash_type(os.urandom(512)).hexdigest())
54     except Exception as err:  # pylint: disable=broad-except
55         log.warning(
56             "Authentication failure: cannot get token %s from redis: %s", tok, err
57         )
58         return {}
59     tdata["token"] = tok
60     try:
61         redis_client.set(tok, salt.payload.dumps(tdata))
62     except Exception as err:  # pylint: disable=broad-except
63         log.warning(
64             "Authentication failure: cannot save token %s to redis: %s", tok, err
65         )
66         return {}
67     return tdata
68 def get_token(opts, tok):
69     """
70     Fetch the token data from the store.
71     :param opts: Salt master config options
72     :param tok: Token value to get
73     :returns: Token data if successful. Empty dict if failed.
74     """
75     redis_client = _redis_client(opts)
76     if not redis_client:
77         return {}
78     try:
79         tdata = salt.payload.loads(redis_client.get(tok))
80         return tdata
81     except Exception as err:  # pylint: disable=broad-except
82         log.warning(
83             "Authentication failure: cannot get token %s from redis: %s", tok, err
84         )
85         return {}
86 def rm_token(opts, tok):
87     """
88     Remove token from the store.
89     :param opts: Salt master config options
90     :param tok: Token to remove
91     :returns: Empty dict if successful. None if failed.
92     """
93     redis_client = _redis_client(opts)
94     if not redis_client:
95         return
96     try:
97         redis_client.delete(tok)
98         return {}
99     except Exception as err:  # pylint: disable=broad-except
100         log.warning("Could not remove token %s: %s", tok, err)
101 def list_tokens(opts):
102     """
103     List all tokens in the store.
104     :param opts: Salt master config options
105     :returns: List of dicts (token_data)
106     """
107     ret = []
108     redis_client = _redis_client(opts)
109     if not redis_client:
110         return []
111     try:
112         return [k.decode("utf8") for k in redis_client.keys()]
113     except Exception as err:  # pylint: disable=broad-except
114         log.warning("Failed to list keys: %s", err)
115         return []
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_local_cache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Use a postgresql server for the master job cache. This helps the job cache to
3 cope with scale.
4 .. note::
5     There are three PostgreSQL returners.  Any can function as an external
6     :ref:`master job cache &lt;external-job-cache&gt;`. but each has different
7     features.  SaltStack recommends
8     :mod:`returners.pgjsonb &lt;salt.returners.pgjsonb&gt;` if you are working with
9     a version of PostgreSQL that has the appropriate native binary JSON types.
10     Otherwise, review
11     :mod:`returners.postgres &lt;salt.returners.postgres&gt;` and
12     :mod:`returners.postgres_local_cache &lt;salt.returners.postgres_local_cache&gt;`
13     to see which module best suits your particular needs.
14 :maintainer:    gjredelinghuys@gmail.com
15 :maturity:      Stable
16 :depends:       psycopg2
17 :platform:      all
18 To enable this returner the minion will need the psycopg2 installed and
19 the following values configured in the master config:
20 .. code-block:: yaml
21     master_job_cache: postgres_local_cache
22     master_job_cache.postgres.host: 'salt'
23     master_job_cache.postgres.user: 'salt'
24     master_job_cache.postgres.passwd: 'salt'
25     master_job_cache.postgres.db: 'salt'
26     master_job_cache.postgres.port: 5432
27 Running the following command as the postgres user should create the database
28 correctly:
29 .. code-block:: sql
30     psql &lt;&lt; EOF
31     CREATE ROLE salt WITH PASSWORD 'salt';
32     CREATE DATABASE salt WITH OWNER salt;
33     EOF
34 In case the postgres database is a remote host, you'll need this command also:
35 .. code-block:: sql
36    ALTER ROLE salt WITH LOGIN;
37 and then:
38 .. code-block:: sql
39     psql -h localhost -U salt &lt;&lt; EOF
40     --
41     -- Table structure for table 'jids'
42     --
43     DROP TABLE IF EXISTS jids;
44     CREATE TABLE jids (
45       jid   varchar(20) PRIMARY KEY,
46       started TIMESTAMP WITH TIME ZONE DEFAULT now(),
47       tgt_type text NOT NULL,
48       cmd text NOT NULL,
49       tgt text NOT NULL,
50       kwargs text NOT NULL,
51       ret text NOT NULL,
52       username text NOT NULL,
53       arg text NOT NULL,
54       fun text NOT NULL
55     );
56     --
57     -- Table structure for table 'salt_returns'
58     --
59     -- note that 'success' must not have NOT NULL constraint, since
60     -- some functions don't provide it.
61     DROP TABLE IF EXISTS salt_returns;
62     CREATE TABLE salt_returns (
63       added     TIMESTAMP WITH TIME ZONE DEFAULT now(),
64       fun       text NOT NULL,
65       jid       varchar(20) NOT NULL,
66       return    text NOT NULL,
67       id        text NOT NULL,
68       success   boolean
69     );
70     CREATE INDEX ON salt_returns (added);
71     CREATE INDEX ON salt_returns (id);
72     CREATE INDEX ON salt_returns (jid);
73     CREATE INDEX ON salt_returns (fun);
74     DROP TABLE IF EXISTS salt_events;
75     CREATE TABLE salt_events (
76       id SERIAL,
77       tag text NOT NULL,
78       data text NOT NULL,
79       alter_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
80       master_id text NOT NULL
81     );
82     CREATE INDEX ON salt_events (tag);
83     CREATE INDEX ON salt_events (data);
84     CREATE INDEX ON salt_events (id);
85     CREATE INDEX ON salt_events (master_id);
86     EOF
87 Required python modules: psycopg2
88 """
89 import logging
90 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import re
91 import sys
92 import salt.utils.jid
93 import salt.utils.json
94 try:
95     import psycopg2
96     HAS_POSTGRES = True
97 except ImportError:
98     HAS_POSTGRES = False
99 log = logging.getLogger(__name__)
100 __virtualname__ = "postgres_local_cache"
101 def __virtual__():
102     if not HAS_POSTGRES:
103         return (False, "Could not import psycopg2; postges_local_cache disabled")
104     return __virtualname__
105 def</b></font> _get_conn():
106     """
107     Return a postgres connection.
108     """
109     try:
110         conn = psycopg2.connect(
111             host=__opts__["master_job_cache.postgres.host"],
112             user=__opts__["master_job_cache.postgres.user"],
113             password=__opts__["master_job_cache.postgres.passwd"],
114             database=__opts__["master_job_cache.postgres.db"],
115             port=__opts__["master_job_cache.postgres.port"],
116         )
117     except psycopg2.OperationalError:
118         log.error("Could not connect to SQL server: %s", sys.exc_info()[0])
119         return None
120     return conn
121 def _close_conn(conn):
122     """
123     Close the postgres connection.
124     """
125     conn.commit()
126     conn.close()
127 def _format_job_instance(job):
128     """
129     Format the job instance correctly
130     """
131     ret = {
132         "Function": job.get("fun", "unknown-function"),
133         "Arguments": salt.utils.json.loads(job.get("arg", "[]")),
134         "Target": job.get("tgt", "unknown-target"),
135         "Target-type": job.get("tgt_type", "list"),
136         "User": job.get("user", "root"),
137     }
138     return ret
139 def _format_jid_instance(jid, job):
140     """
141     Format the jid correctly
142     """
143     ret = _format_job_instance(job)
144     ret.update({"StartTime": salt.utils.jid.jid_to_time(jid)})
145     return ret
146 def _gen_jid(cur):
147     """
148     Generate an unique job id
149     """
150     jid = salt.utils.jid.gen_jid(__opts__)
151     sql = """SELECT jid FROM jids WHERE jid = %s"""
152     cur.execute(sql, (jid,))
153     data = cur.fetchall()
154     if not data:
155         return jid
156     return None
157 def prep_jid(nocache=False, passed_jid=None):
158     """
159     Return a job id and prepare the job id directory
160     This is the function responsible for making sure jids don't collide
161     (unless its passed a jid). So do what you have to do to make sure that
162     stays the case
163     """
164     conn = _get_conn()
165     if conn is None:
166         return None
167     cur = conn.cursor()
168     if passed_jid is None:
169         jid = _gen_jid(cur)
170     else:
171         jid = passed_jid
172     while not jid:
173         log.info("jid clash, generating a new one")
174         jid = _gen_jid(cur)
175     cur.close()
176     conn.close()
177     return jid
178 def returner(load):
179     """
180     Return data to a postgres server
181     """
182     conn = _get_conn()
183     if conn is None:
184         return None
185     cur = conn.cursor()
186     sql = """INSERT INTO salt_returns
187             (fun, jid, return, id, success)
188             VALUES (%s, %s, %s, %s, %s)"""
189     ret = str(load["return"])
190     job_ret = {"return": ret}
191     if "retcode" in load:
192         job_ret["retcode"] = load["retcode"]
193     if "success" in load:
194         job_ret["success"] = load["success"]
195     cur.execute(
196         sql,
197         (
198             load["fun"],
199             load["jid"],
200             salt.utils.json.dumps(job_ret),
201             load["id"],
202             load.get("success"),
203         ),
204     )
205     _close_conn(conn)
206 def event_return(events):
207     """
208     Return event to a postgres server
209     Require that configuration be enabled via 'event_return'
210     option in master config.
211     """
212     conn = _get_conn()
213     if conn is None:
214         return None
215     cur = conn.cursor()
216     for event in events:
217         tag = event.get("tag", "")
218         data = event.get("data", "")
219         sql = """INSERT INTO salt_events
220                 (tag, data, master_id)
221                 VALUES (%s, %s, %s)"""
222         cur.execute(sql, (tag, salt.utils.json.dumps(data), __opts__["id"]))
223     _close_conn(conn)
224 def save_load(jid, clear_load, minions=None):
225     """
226     Save the load to the specified jid id
227     """
228     jid = _escape_jid(jid)
229     conn = _get_conn()
230     if conn is None:
231         return None
232     cur = conn.cursor()
233     sql = (
234     )
235     cur.execute(
236         sql,
237         (
238             jid,
239             salt.utils.jid.jid_to_time(jid),
240             str(clear_load.get("tgt_type")),
241             str(clear_load.get("cmd")),
242             str(clear_load.get("tgt")),
243             str(clear_load.get("kwargs")),
244             str(clear_load.get("ret")),
245             str(clear_load.get("user")),
246             str(salt.utils.json.dumps(clear_load.get("arg"))),
247             str(clear_load.get("fun")),
248         ),
249     )
250     _close_conn(conn)
251 def save_minions(jid, minions, syndic_id=None):  # pylint: disable=unused-argument
252     """
253     Included for API consistency
254     """
255 def _escape_jid(jid):
256     """
257     Do proper formatting of the jid
258     """
259     jid = str(jid)
260     jid = re.sub(r"'*", "", jid)
261     return jid
262 def _build_dict(data):
263     """
264     Rebuild dict
265     """
266     result = {}
267     result["jid"] = data[0]
268     result["tgt_type"] = data[1]
269     result["cmd"] = data[2]
270     result["tgt"] = data[3]
271     result["kwargs"] = data[4]
272     result["ret"] = data[5]
273     result["user"] = data[6]
274     result["arg"] = data[7]
275     result["fun"] = data[8]
276     return result
277 def get_load(jid):
278     """
279     Return the load data that marks a specified jid
280     """
281     jid = _escape_jid(jid)
282     conn = _get_conn()
283     if conn is None:
284         return None
285     cur = conn.cursor()
286     sql = (
287     )
288     cur.execute(sql, (jid,))
289     data = cur.fetchone()
290     if data:
291         return _build_dict(data)
292     _close_conn(conn)
293     return {}
294 def get_jid(jid):
295     """
296     Return the information returned when the specified job id was executed
297     """
298     jid = _escape_jid(jid)
299     conn = _get_conn()
300     if conn is None:
301         return None
302     cur = conn.cursor()
303     sql = """SELECT id, return FROM salt_returns WHERE jid = %s"""
304     cur.execute(sql, (jid,))
305     data = cur.fetchall()
306     ret = {}
307     if data:
308         for minion, full_ret in data:
309             ret_data = salt.utils.json.loads(full_ret)
310             if not isinstance(ret_data, dict) or "return" not in ret_data:
311                 ret_data = {"return": ret_data}
312             ret[minion] = ret_data
313     _close_conn(conn)
314     return ret
315 def get_jids():
316     """
317     Return a list of all job ids
318     For master job cache this also formats the output and returns a string
319     """
320     conn = _get_conn()
321     cur = conn.cursor()
322     sql = (
323     )
324     if __opts__["keep_jobs"] != 0:
325         sql = (
326             sql
327             + " WHERE started &gt; NOW() - INTERVAL '"
328             + str(__opts__["keep_jobs"])
329             + "' HOUR"
330         )
331     cur.execute(sql)
332     ret = {}
333     data = cur.fetchone()
334     while data:
335         data_dict = _build_dict(data)
336         ret[data_dict["jid"]] = _format_jid_instance(data_dict["jid"], data_dict)
337         data = cur.fetchone()
338     cur.close()
339     conn.close()
340     return ret
341 def clean_old_jobs():
342     """
343     Clean out the old jobs from the job cache
344     """
345     return
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
