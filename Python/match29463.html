<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for rediscluster.py & postgres_local_cache.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for rediscluster.py & postgres_local_cache.py
      </h3>
      <h1 align="center">
        8.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>rediscluster.py (15.068493%)<TH>postgres_local_cache.py (5.5555553%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match29463-0.html#0',2,'match29463-1.html#0',3)" NAME="0">(17-46)<TD><A HREF="javascript:ZweiFrames('match29463-0.html#0',2,'match29463-1.html#0',3)" NAME="0">(111-135)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>rediscluster.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Provide token storage in Redis cluster.

To get started simply start a redis cluster and assign all hashslots to the connected nodes.
Add the redis hostname and port to master configs as eauth_redis_host and eauth_redis_port.
Default values for these configs are as follow:

.. code-block:: yaml

    eauth_redis_host: localhost
    eauth_redis_port: 6379

:depends:   - redis-py-cluster Python package
<A NAME="0"></A>&quot;&quot;&quot;


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match29463-1.html#0',3,'match29463-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import hashlib
import logging
import os

import salt.payload

try:
    import rediscluster

    HAS_REDIS = True
except ImportError:
    HAS_REDIS = False


log = logging.getLogger(__name__)

__virtualname__ = &quot;rediscluster&quot;


def __virtual__():
    if not HAS_REDIS:
        return (
            False,
            &quot;Could not use redis for tokens; &quot;
            &quot;rediscluster python client is not installed.&quot;,
        )
    return __virtualname__


def</B></FONT> _redis_client(opts):
    &quot;&quot;&quot;
    Connect to the redis host and return a StrictRedisCluster client object.
    If connection fails then return None.
    &quot;&quot;&quot;
    redis_host = opts.get(&quot;eauth_redis_host&quot;, &quot;localhost&quot;)
    redis_port = opts.get(&quot;eauth_redis_port&quot;, 6379)
    try:
        return rediscluster.StrictRedisCluster(
            host=redis_host, port=redis_port, decode_responses=True
        )
    except rediscluster.exceptions.RedisClusterException as err:
        log.warning(
            &quot;Failed to connect to redis at %s:%s - %s&quot;, redis_host, redis_port, err
        )
        return None


def mk_token(opts, tdata):
    &quot;&quot;&quot;
    Mint a new token using the config option hash_type and store tdata with 'token' attribute set
    to the token.
    This module uses the hash of random 512 bytes as a token.

    :param opts: Salt master config options
    :param tdata: Token data to be stored with 'token' attribute of this dict set to the token.
    :returns: tdata with token if successful. Empty dict if failed.
    &quot;&quot;&quot;
    redis_client = _redis_client(opts)
    if not redis_client:
        return {}
    hash_type = getattr(hashlib, opts.get(&quot;hash_type&quot;, &quot;md5&quot;))
    tok = str(hash_type(os.urandom(512)).hexdigest())
    try:
        while redis_client.get(tok) is not None:
            tok = str(hash_type(os.urandom(512)).hexdigest())
    except Exception as err:  # pylint: disable=broad-except
        log.warning(
            &quot;Authentication failure: cannot get token %s from redis: %s&quot;, tok, err
        )
        return {}
    tdata[&quot;token&quot;] = tok
    try:
        redis_client.set(tok, salt.payload.dumps(tdata))
    except Exception as err:  # pylint: disable=broad-except
        log.warning(
            &quot;Authentication failure: cannot save token %s to redis: %s&quot;, tok, err
        )
        return {}
    return tdata


def get_token(opts, tok):
    &quot;&quot;&quot;
    Fetch the token data from the store.

    :param opts: Salt master config options
    :param tok: Token value to get
    :returns: Token data if successful. Empty dict if failed.
    &quot;&quot;&quot;
    redis_client = _redis_client(opts)
    if not redis_client:
        return {}
    try:
        tdata = salt.payload.loads(redis_client.get(tok))
        return tdata
    except Exception as err:  # pylint: disable=broad-except
        log.warning(
            &quot;Authentication failure: cannot get token %s from redis: %s&quot;, tok, err
        )
        return {}


def rm_token(opts, tok):
    &quot;&quot;&quot;
    Remove token from the store.

    :param opts: Salt master config options
    :param tok: Token to remove
    :returns: Empty dict if successful. None if failed.
    &quot;&quot;&quot;
    redis_client = _redis_client(opts)
    if not redis_client:
        return
    try:
        redis_client.delete(tok)
        return {}
    except Exception as err:  # pylint: disable=broad-except
        log.warning(&quot;Could not remove token %s: %s&quot;, tok, err)


def list_tokens(opts):
    &quot;&quot;&quot;
    List all tokens in the store.

    :param opts: Salt master config options
    :returns: List of dicts (token_data)
    &quot;&quot;&quot;
    ret = []
    redis_client = _redis_client(opts)
    if not redis_client:
        return []
    try:
        return [k.decode(&quot;utf8&quot;) for k in redis_client.keys()]
    except Exception as err:  # pylint: disable=broad-except
        log.warning(&quot;Failed to list keys: %s&quot;, err)
        return []
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_local_cache.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Use a postgresql server for the master job cache. This helps the job cache to
cope with scale.

.. note::
    There are three PostgreSQL returners.  Any can function as an external
    :ref:`master job cache &lt;external-job-cache&gt;`. but each has different
    features.  SaltStack recommends
    :mod:`returners.pgjsonb &lt;salt.returners.pgjsonb&gt;` if you are working with
    a version of PostgreSQL that has the appropriate native binary JSON types.
    Otherwise, review
    :mod:`returners.postgres &lt;salt.returners.postgres&gt;` and
    :mod:`returners.postgres_local_cache &lt;salt.returners.postgres_local_cache&gt;`
    to see which module best suits your particular needs.

:maintainer:    gjredelinghuys@gmail.com
:maturity:      Stable
:depends:       psycopg2
:platform:      all

To enable this returner the minion will need the psycopg2 installed and
the following values configured in the master config:

.. code-block:: yaml

    master_job_cache: postgres_local_cache
    master_job_cache.postgres.host: 'salt'
    master_job_cache.postgres.user: 'salt'
    master_job_cache.postgres.passwd: 'salt'
    master_job_cache.postgres.db: 'salt'
    master_job_cache.postgres.port: 5432

Running the following command as the postgres user should create the database
correctly:

.. code-block:: sql

    psql &lt;&lt; EOF
    CREATE ROLE salt WITH PASSWORD 'salt';
    CREATE DATABASE salt WITH OWNER salt;
    EOF

In case the postgres database is a remote host, you'll need this command also:

.. code-block:: sql

   ALTER ROLE salt WITH LOGIN;

and then:

.. code-block:: sql

    psql -h localhost -U salt &lt;&lt; EOF
    --
    -- Table structure for table 'jids'
    --

    DROP TABLE IF EXISTS jids;
    CREATE TABLE jids (
      jid   varchar(20) PRIMARY KEY,
      started TIMESTAMP WITH TIME ZONE DEFAULT now(),
      tgt_type text NOT NULL,
      cmd text NOT NULL,
      tgt text NOT NULL,
      kwargs text NOT NULL,
      ret text NOT NULL,
      username text NOT NULL,
      arg text NOT NULL,
      fun text NOT NULL
    );

    --
    -- Table structure for table 'salt_returns'
    --
    -- note that 'success' must not have NOT NULL constraint, since
    -- some functions don't provide it.

    DROP TABLE IF EXISTS salt_returns;
    CREATE TABLE salt_returns (
      added     TIMESTAMP WITH TIME ZONE DEFAULT now(),
      fun       text NOT NULL,
      jid       varchar(20) NOT NULL,
      return    text NOT NULL,
      id        text NOT NULL,
      success   boolean
    );
    CREATE INDEX ON salt_returns (added);
    CREATE INDEX ON salt_returns (id);
    CREATE INDEX ON salt_returns (jid);
    CREATE INDEX ON salt_returns (fun);

    DROP TABLE IF EXISTS salt_events;
    CREATE TABLE salt_events (
      id SERIAL,
      tag text NOT NULL,
      data text NOT NULL,
      alter_time TIMESTAMP WITH TIME ZONE DEFAULT now(),
      master_id text NOT NULL
    );
    CREATE INDEX ON salt_events (tag);
    CREATE INDEX ON salt_events (data);
    CREATE INDEX ON salt_events (id);
    CREATE INDEX ON salt_events (master_id);
    EOF

Required python modules: psycopg2
&quot;&quot;&quot;
<A NAME="0"></A>

import logging
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match29463-0.html#0',2,'match29463-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import re
import sys

import salt.utils.jid
import salt.utils.json

try:
    import psycopg2

    HAS_POSTGRES = True
except ImportError:
    HAS_POSTGRES = False

log = logging.getLogger(__name__)

__virtualname__ = &quot;postgres_local_cache&quot;


def __virtual__():
    if not HAS_POSTGRES:
        return (False, &quot;Could not import psycopg2; postges_local_cache disabled&quot;)
    return __virtualname__


def</B></FONT> _get_conn():
    &quot;&quot;&quot;
    Return a postgres connection.
    &quot;&quot;&quot;
    try:
        conn = psycopg2.connect(
            host=__opts__[&quot;master_job_cache.postgres.host&quot;],
            user=__opts__[&quot;master_job_cache.postgres.user&quot;],
            password=__opts__[&quot;master_job_cache.postgres.passwd&quot;],
            database=__opts__[&quot;master_job_cache.postgres.db&quot;],
            port=__opts__[&quot;master_job_cache.postgres.port&quot;],
        )
    except psycopg2.OperationalError:
        log.error(&quot;Could not connect to SQL server: %s&quot;, sys.exc_info()[0])
        return None
    return conn


def _close_conn(conn):
    &quot;&quot;&quot;
    Close the postgres connection.
    &quot;&quot;&quot;
    conn.commit()
    conn.close()


def _format_job_instance(job):
    &quot;&quot;&quot;
    Format the job instance correctly
    &quot;&quot;&quot;
    ret = {
        &quot;Function&quot;: job.get(&quot;fun&quot;, &quot;unknown-function&quot;),
        &quot;Arguments&quot;: salt.utils.json.loads(job.get(&quot;arg&quot;, &quot;[]&quot;)),
        # unlikely but safeguard from invalid returns
        &quot;Target&quot;: job.get(&quot;tgt&quot;, &quot;unknown-target&quot;),
        &quot;Target-type&quot;: job.get(&quot;tgt_type&quot;, &quot;list&quot;),
        &quot;User&quot;: job.get(&quot;user&quot;, &quot;root&quot;),
    }
    # TODO: Add Metadata support when it is merged from develop
    return ret


def _format_jid_instance(jid, job):
    &quot;&quot;&quot;
    Format the jid correctly
    &quot;&quot;&quot;
    ret = _format_job_instance(job)
    ret.update({&quot;StartTime&quot;: salt.utils.jid.jid_to_time(jid)})
    return ret


def _gen_jid(cur):
    &quot;&quot;&quot;
    Generate an unique job id
    &quot;&quot;&quot;
    jid = salt.utils.jid.gen_jid(__opts__)
    sql = &quot;&quot;&quot;SELECT jid FROM jids WHERE jid = %s&quot;&quot;&quot;
    cur.execute(sql, (jid,))
    data = cur.fetchall()
    if not data:
        return jid
    return None


def prep_jid(nocache=False, passed_jid=None):
    &quot;&quot;&quot;
    Return a job id and prepare the job id directory
    This is the function responsible for making sure jids don't collide
    (unless its passed a jid). So do what you have to do to make sure that
    stays the case
    &quot;&quot;&quot;
    conn = _get_conn()
    if conn is None:
        return None
    cur = conn.cursor()
    if passed_jid is None:
        jid = _gen_jid(cur)
    else:
        jid = passed_jid
    while not jid:
        log.info(&quot;jid clash, generating a new one&quot;)
        jid = _gen_jid(cur)

    cur.close()
    conn.close()
    return jid


def returner(load):
    &quot;&quot;&quot;
    Return data to a postgres server
    &quot;&quot;&quot;
    conn = _get_conn()
    if conn is None:
        return None
    cur = conn.cursor()
    sql = &quot;&quot;&quot;INSERT INTO salt_returns
            (fun, jid, return, id, success)
            VALUES (%s, %s, %s, %s, %s)&quot;&quot;&quot;
    ret = str(load[&quot;return&quot;])
    job_ret = {&quot;return&quot;: ret}
    if &quot;retcode&quot; in load:
        job_ret[&quot;retcode&quot;] = load[&quot;retcode&quot;]
    if &quot;success&quot; in load:
        job_ret[&quot;success&quot;] = load[&quot;success&quot;]
    cur.execute(
        sql,
        (
            load[&quot;fun&quot;],
            load[&quot;jid&quot;],
            salt.utils.json.dumps(job_ret),
            load[&quot;id&quot;],
            load.get(&quot;success&quot;),
        ),
    )
    _close_conn(conn)


def event_return(events):
    &quot;&quot;&quot;
    Return event to a postgres server

    Require that configuration be enabled via 'event_return'
    option in master config.
    &quot;&quot;&quot;
    conn = _get_conn()
    if conn is None:
        return None
    cur = conn.cursor()
    for event in events:
        tag = event.get(&quot;tag&quot;, &quot;&quot;)
        data = event.get(&quot;data&quot;, &quot;&quot;)
        sql = &quot;&quot;&quot;INSERT INTO salt_events
                (tag, data, master_id)
                VALUES (%s, %s, %s)&quot;&quot;&quot;
        cur.execute(sql, (tag, salt.utils.json.dumps(data), __opts__[&quot;id&quot;]))
    _close_conn(conn)


def save_load(jid, clear_load, minions=None):
    &quot;&quot;&quot;
    Save the load to the specified jid id
    &quot;&quot;&quot;
    jid = _escape_jid(jid)
    conn = _get_conn()
    if conn is None:
        return None
    cur = conn.cursor()
    sql = (
        &quot;&quot;&quot;INSERT INTO jids &quot;&quot;&quot;
        &quot;&quot;&quot;(jid, started, tgt_type, cmd, tgt, kwargs, ret, username, arg,&quot;&quot;&quot;
        &quot;&quot;&quot; fun) &quot;&quot;&quot;
        &quot;&quot;&quot;VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)&quot;&quot;&quot;
    )

    cur.execute(
        sql,
        (
            jid,
            salt.utils.jid.jid_to_time(jid),
            str(clear_load.get(&quot;tgt_type&quot;)),
            str(clear_load.get(&quot;cmd&quot;)),
            str(clear_load.get(&quot;tgt&quot;)),
            str(clear_load.get(&quot;kwargs&quot;)),
            str(clear_load.get(&quot;ret&quot;)),
            str(clear_load.get(&quot;user&quot;)),
            str(salt.utils.json.dumps(clear_load.get(&quot;arg&quot;))),
            str(clear_load.get(&quot;fun&quot;)),
        ),
    )
    # TODO: Add Metadata support when it is merged from develop
    _close_conn(conn)


def save_minions(jid, minions, syndic_id=None):  # pylint: disable=unused-argument
    &quot;&quot;&quot;
    Included for API consistency
    &quot;&quot;&quot;


def _escape_jid(jid):
    &quot;&quot;&quot;
    Do proper formatting of the jid
    &quot;&quot;&quot;
    jid = str(jid)
    jid = re.sub(r&quot;'*&quot;, &quot;&quot;, jid)
    return jid


def _build_dict(data):
    &quot;&quot;&quot;
    Rebuild dict
    &quot;&quot;&quot;
    result = {}
    # TODO: Add Metadata support when it is merged from develop
    result[&quot;jid&quot;] = data[0]
    result[&quot;tgt_type&quot;] = data[1]
    result[&quot;cmd&quot;] = data[2]
    result[&quot;tgt&quot;] = data[3]
    result[&quot;kwargs&quot;] = data[4]
    result[&quot;ret&quot;] = data[5]
    result[&quot;user&quot;] = data[6]
    result[&quot;arg&quot;] = data[7]
    result[&quot;fun&quot;] = data[8]
    return result


def get_load(jid):
    &quot;&quot;&quot;
    Return the load data that marks a specified jid
    &quot;&quot;&quot;
    jid = _escape_jid(jid)
    conn = _get_conn()
    if conn is None:
        return None
    cur = conn.cursor()
    sql = (
        &quot;&quot;&quot;SELECT jid, tgt_type, cmd, tgt, kwargs, ret, username, arg,&quot;&quot;&quot;
        &quot;&quot;&quot; fun FROM jids WHERE jid = %s&quot;&quot;&quot;
    )
    cur.execute(sql, (jid,))
    data = cur.fetchone()
    if data:
        return _build_dict(data)
    _close_conn(conn)
    return {}


def get_jid(jid):
    &quot;&quot;&quot;
    Return the information returned when the specified job id was executed
    &quot;&quot;&quot;
    jid = _escape_jid(jid)
    conn = _get_conn()
    if conn is None:
        return None
    cur = conn.cursor()
    sql = &quot;&quot;&quot;SELECT id, return FROM salt_returns WHERE jid = %s&quot;&quot;&quot;

    cur.execute(sql, (jid,))
    data = cur.fetchall()
    ret = {}
    if data:
        for minion, full_ret in data:
            ret_data = salt.utils.json.loads(full_ret)
            if not isinstance(ret_data, dict) or &quot;return&quot; not in ret_data:
                # Convert the old format in which the return contains the only return data to the
                # new that is dict containing 'return' and optionally 'retcode' and 'success'.
                ret_data = {&quot;return&quot;: ret_data}
            ret[minion] = ret_data
    _close_conn(conn)
    return ret


def get_jids():
    &quot;&quot;&quot;
    Return a list of all job ids
    For master job cache this also formats the output and returns a string
    &quot;&quot;&quot;
    conn = _get_conn()
    cur = conn.cursor()
    sql = (
        &quot;&quot;&quot;SELECT &quot;&quot;&quot;
        &quot;&quot;&quot;jid, tgt_type, cmd, tgt, kwargs, ret, username, arg, fun &quot;&quot;&quot;
        &quot;&quot;&quot;FROM jids&quot;&quot;&quot;
    )
    if __opts__[&quot;keep_jobs&quot;] != 0:
        sql = (
            sql
            + &quot; WHERE started &gt; NOW() - INTERVAL '&quot;
            + str(__opts__[&quot;keep_jobs&quot;])
            + &quot;' HOUR&quot;
        )

    cur.execute(sql)
    ret = {}
    data = cur.fetchone()
    while data:
        data_dict = _build_dict(data)
        ret[data_dict[&quot;jid&quot;]] = _format_jid_instance(data_dict[&quot;jid&quot;], data_dict)
        data = cur.fetchone()
    cur.close()
    conn.close()
    return ret


def clean_old_jobs():
    &quot;&quot;&quot;
    Clean out the old jobs from the job cache
    &quot;&quot;&quot;
    return
</PRE>
</div>
  </div>
</body>
</html>
