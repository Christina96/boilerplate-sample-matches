<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for locale.py &amp; aws.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for locale.py &amp; aws.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>locale.py (1.8720748%)<th>aws.py (1.6021361%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(43-57)<td><a href="#" name="0">(11-23)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>locale.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
2 import codecs
3 import csv
4 import datetime
5 from io import BytesIO
6 import numbers
7 import os
8 import re
9 from salt.ext.tornado import escape
10 from salt.ext.tornado.log import gen_log
11 from salt.ext.tornado.util import PY3
12 from</b></font> salt.ext.tornado._locale_data import LOCALE_NAMES
13 _default_locale = "en_US"
14 _translations = {}  # type: dict
15 _supported_locales = frozenset([_default_locale])
16 _use_gettext = False
17 CONTEXT_SEPARATOR = "\x04"
18 def get(*locale_codes):
19     return Locale.get_closest(*locale_codes)
20 def set_default_locale(code):
21     global _default_locale
22     global _supported_locales
23     _default_locale = code
24     _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
25 def load_translations(directory, encoding=None):
26     global _translations
27     global _supported_locales
28     _translations = {}
29     for path in os.listdir(directory):
30         if not path.endswith(".csv"):
31             continue
32         locale, extension = path.split(".")
33         if not re.match("[a-z]+(_[A-Z]+)?$", locale):
34             gen_log.error("Unrecognized locale %r (path: %s)", locale,
35                           os.path.join(directory, path))
36             continue
37         full_path = os.path.join(directory, path)
38         if encoding is None:
39             with open(full_path, 'rb') as f:
40                 data = f.read(len(codecs.BOM_UTF16_LE))
41             if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):
42                 encoding = 'utf-16'
43             else:
44                 encoding = 'utf-8-sig'
45         if PY3:
46             f = open(full_path, "r", encoding=encoding)
47         else:
48             f = BytesIO()
49             with codecs.open(full_path, "r", encoding=encoding) as infile:
50                 f.write(escape.utf8(infile.read()))
51             f.seek(0)
52         _translations[locale] = {}
53         for i, row in enumerate(csv.reader(f)):
54             if not row or len(row) &lt; 2:
55                 continue
56             row = [escape.to_unicode(c).strip() for c in row]
57             english, translation = row[:2]
58             if len(row) &gt; 2:
59                 plural = row[2] or "unknown"
60             else:
61                 plural = "unknown"
62             if plural not in ("plural", "singular", "unknown"):
63                 gen_log.error("Unrecognized plural indicator %r in %s line %d",
64                               plural, path, i + 1)
65                 continue
66             _translations[locale].setdefault(plural, {})[english] = translation
67         f.close()
68     _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
69     gen_log.debug("Supported locales: %s", sorted(_supported_locales))
70 def load_gettext_translations(directory, domain):
71     import gettext
72     global _translations
73     global _supported_locales
74     global _use_gettext
75     _translations = {}
76     for lang in os.listdir(directory):
77         if lang.startswith('.'):
78             continue  # skip .svn, etc
79         if os.path.isfile(os.path.join(directory, lang)):
80             continue
81         try:
82             os.stat(os.path.join(directory, lang, "LC_MESSAGES", domain + ".mo"))
83             _translations[lang] = gettext.translation(domain, directory,
84                                                       languages=[lang])
85         except Exception as e:
86             gen_log.error("Cannot load translation for '%s': %s", lang, str(e))
87             continue
88     _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
89     _use_gettext = True
90     gen_log.debug("Supported locales: %s", sorted(_supported_locales))
91 def get_supported_locales():
92     return _supported_locales
93 class Locale(object):
94     @classmethod
95     def get_closest(cls, *locale_codes):
96         for code in locale_codes:
97             if not code:
98                 continue
99             code = code.replace("-", "_")
100             parts = code.split("_")
101             if len(parts) &gt; 2:
102                 continue
103             elif len(parts) == 2:
104                 code = parts[0].lower() + "_" + parts[1].upper()
105             if code in _supported_locales:
106                 return cls.get(code)
107             if parts[0].lower() in _supported_locales:
108                 return cls.get(parts[0].lower())
109         return cls.get(_default_locale)
110     @classmethod
111     def get(cls, code):
112         if not hasattr(cls, "_cache"):
113             cls._cache = {}
114         if code not in cls._cache:
115             assert code in _supported_locales
116             translations = _translations.get(code, None)
117             if translations is None:
118                 locale = CSVLocale(code, {})
119             elif _use_gettext:
120                 locale = GettextLocale(code, translations)
121             else:
122                 locale = CSVLocale(code, translations)
123             cls._cache[code] = locale
124         return cls._cache[code]
125     def __init__(self, code, translations):
126         self.code = code
127         self.name = LOCALE_NAMES.get(code, {}).get("name", u"Unknown")
128         self.rtl = False
129         for prefix in ["fa", "ar", "he"]:
130             if self.code.startswith(prefix):
131                 self.rtl = True
132                 break
133         self.translations = translations
134         _ = self.translate
135         self._months = [
136             _("January"), _("February"), _("March"), _("April"),
137             _("May"), _("June"), _("July"), _("August"),
138             _("September"), _("October"), _("November"), _("December")]
139         self._weekdays = [
140             _("Monday"), _("Tuesday"), _("Wednesday"), _("Thursday"),
141             _("Friday"), _("Saturday"), _("Sunday")]
142     def translate(self, message, plural_message=None, count=None):
143         raise NotImplementedError()
144     def pgettext(self, context, message, plural_message=None, count=None):
145         raise NotImplementedError()
146     def format_date(self, date, gmt_offset=0, relative=True, shorter=False,
147                     full_format=False):
148         if isinstance(date, numbers.Real):
149             date = datetime.datetime.utcfromtimestamp(date)
150         now = datetime.datetime.utcnow()
151         if date &gt; now:
152             if relative and (date - now).seconds &lt; 60:
153                 date = now
154             else:
155                 full_format = True
156         local_date = date - datetime.timedelta(minutes=gmt_offset)
157         local_now = now - datetime.timedelta(minutes=gmt_offset)
158         local_yesterday = local_now - datetime.timedelta(hours=24)
159         difference = now - date
160         seconds = difference.seconds
161         days = difference.days
162         _ = self.translate
163         format = None
164         if not full_format:
165             if relative and days == 0:
166                 if seconds &lt; 50:
167                     return _("1 second ago", "%(seconds)d seconds ago",
168                              seconds) % {"seconds": seconds}
169                 if seconds &lt; 50 * 60:
170                     minutes = round(seconds / 60.0)
171                     return _("1 minute ago", "%(minutes)d minutes ago",
172                              minutes) % {"minutes": minutes}
173                 hours = round(seconds / (60.0 * 60))
174                 return _("1 hour ago", "%(hours)d hours ago",
175                          hours) % {"hours": hours}
176             if days == 0:
177                 format = _("%(time)s")
178             elif days == 1 and local_date.day == local_yesterday.day and \
179                     relative:
180                 format = _("yesterday") if shorter else \
181                     _("yesterday at %(time)s")
182             elif days &lt; 5:
183                 format = _("%(weekday)s") if shorter else \
184                     _("%(weekday)s at %(time)s")
185             elif days &lt; 334:  # 11mo, since confusing for same month last year
186                 format = _("%(month_name)s %(day)s") if shorter else \
187                     _("%(month_name)s %(day)s at %(time)s")
188         if format is None:
189             format = _("%(month_name)s %(day)s, %(year)s") if shorter else \
190                 _("%(month_name)s %(day)s, %(year)s at %(time)s")
191         tfhour_clock = self.code not in ("en", "en_US", "zh_CN")
192         if tfhour_clock:
193             str_time = "%d:%02d" % (local_date.hour, local_date.minute)
194         elif self.code == "zh_CN":
195             str_time = "%s%d:%02d" % (
196                 (u'\u4e0a\u5348', u'\u4e0b\u5348')[local_date.hour &gt;= 12],
197                 local_date.hour % 12 or 12, local_date.minute)
198         else:
199             str_time = "%d:%02d %s" % (
200                 local_date.hour % 12 or 12, local_date.minute,
201                 ("am", "pm")[local_date.hour &gt;= 12])
202         return format % {
203             "month_name": self._months[local_date.month - 1],
204             "weekday": self._weekdays[local_date.weekday()],
205             "day": str(local_date.day),
206             "year": str(local_date.year),
207             "time": str_time
208         }
209     def format_day(self, date, gmt_offset=0, dow=True):
210         local_date = date - datetime.timedelta(minutes=gmt_offset)
211         _ = self.translate
212         if dow:
213             return _("%(weekday)s, %(month_name)s %(day)s") % {
214                 "month_name": self._months[local_date.month - 1],
215                 "weekday": self._weekdays[local_date.weekday()],
216                 "day": str(local_date.day),
217             }
218         else:
219             return _("%(month_name)s %(day)s") % {
220                 "month_name": self._months[local_date.month - 1],
221                 "day": str(local_date.day),
222             }
223     def list(self, parts):
224         _ = self.translate
225         if len(parts) == 0:
226             return ""
227         if len(parts) == 1:
228             return parts[0]
229         comma = u' \u0648 ' if self.code.startswith("fa") else u", "
230         return _("%(commas)s and %(last)s") % {
231             "commas": comma.join(parts[:-1]),
232             "last": parts[len(parts) - 1],
233         }
234     def friendly_number(self, value):
235         if self.code not in ("en", "en_US"):
236             return str(value)
237         value = str(value)
238         parts = []
239         while value:
240             parts.append(value[-3:])
241             value = value[:-3]
242         return ",".join(reversed(parts))
243 class CSVLocale(Locale):
244     def translate(self, message, plural_message=None, count=None):
245         if plural_message is not None:
246             assert count is not None
247             if count != 1:
248                 message = plural_message
249                 message_dict = self.translations.get("plural", {})
250             else:
251                 message_dict = self.translations.get("singular", {})
252         else:
253             message_dict = self.translations.get("unknown", {})
254         return message_dict.get(message, message)
255     def pgettext(self, context, message, plural_message=None, count=None):
256         if self.translations:
257             gen_log.warning('pgettext is not supported by CSVLocale')
258         return self.translate(message, plural_message, count)
259 class GettextLocale(Locale):
260     def __init__(self, code, translations):
261         try:
262             self.ngettext = translations.ungettext
263             self.gettext = translations.ugettext
264         except AttributeError:
265             self.ngettext = translations.ngettext
266             self.gettext = translations.gettext
267         super(GettextLocale, self).__init__(code, translations)
268     def translate(self, message, plural_message=None, count=None):
269         if plural_message is not None:
270             assert count is not None
271             return self.ngettext(message, plural_message, count)
272         else:
273             return self.gettext(message)
274     def pgettext(self, context, message, plural_message=None, count=None):
275         if plural_message is not None:
276             assert count is not None
277             msgs_with_ctxt = ("%s%s%s" % (context, CONTEXT_SEPARATOR, message),
278                               "%s%s%s" % (context, CONTEXT_SEPARATOR, plural_message),
279                               count)
280             result = self.ngettext(*msgs_with_ctxt)
281             if CONTEXT_SEPARATOR in result:
282                 result = self.ngettext(message, plural_message, count)
283             return result
284         else:
285             msg_with_ctxt = "%s%s%s" % (context, CONTEXT_SEPARATOR, message)
286             result = self.gettext(msg_with_ctxt)
287             if CONTEXT_SEPARATOR in result:
288                 result = message
289             return result
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import binascii
2 import hashlib
3 import hmac
4 import logging
5 import random
6 import re
7 import time
8 import urllib.parse
9 import xml.etree.ElementTree as ET
10 from datetime import datetime
11 import salt.config
12 import</b></font> salt.utils.hashutils
13 import salt.utils.xmlutil as xml
14 try:
15     import requests
16     HAS_REQUESTS = True  # pylint: disable=W0612
17 except ImportError:
18     HAS_REQUESTS = False  # pylint: disable=W0612
19 log = logging.getLogger(__name__)
20 DEFAULT_LOCATION = "us-east-1"
21 DEFAULT_AWS_API_VERSION = "2016-11-15"
22 AWS_RETRY_CODES = [
23     "RequestLimitExceeded",
24     "InsufficientInstanceCapacity",
25     "InternalError",
26     "Unavailable",
27     "InsufficientAddressCapacity",
28     "InsufficientReservedInstanceCapacity",
29 ]
30 AWS_METADATA_TIMEOUT = 3.05
31 AWS_MAX_RETRIES = 7
32 IROLE_CODE = "use-instance-role-credentials"
33 __AccessKeyId__ = ""
34 __SecretAccessKey__ = ""
35 __Token__ = ""
36 __Expiration__ = ""
37 __Location__ = ""
38 __AssumeCache__ = {}
39 def sleep_exponential_backoff(attempts):
40     time.sleep(random.uniform(1, 2 ** attempts))
41 def creds(provider):
42     global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__
43     ret_credentials = ()
44     if provider["id"] == IROLE_CODE or provider["key"] == IROLE_CODE:
45         if __Expiration__ != "":
46             timenow = datetime.utcnow()
47             timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
48             if timestamp &lt; __Expiration__:
49                 return __AccessKeyId__, __SecretAccessKey__, __Token__
50         try:
51             result = requests.get(
52                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
53                 proxies={"http": ""},
54                 timeout=AWS_METADATA_TIMEOUT,
55             )
56             result.raise_for_status()
57             role = result.text
58         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
59             return provider["id"], provider["key"], ""
60         try:
61             result = requests.get(
62                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/{}".format(
63                     role
64                 ),
65                 proxies={"http": ""},
66                 timeout=AWS_METADATA_TIMEOUT,
67             )
68             result.raise_for_status()
69         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
70             return provider["id"], provider["key"], ""
71         data = result.json()
72         __AccessKeyId__ = data["AccessKeyId"]
73         __SecretAccessKey__ = data["SecretAccessKey"]
74         __Token__ = data["Token"]
75         __Expiration__ = data["Expiration"]
76         ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
77     else:
78         ret_credentials = provider["id"], provider["key"], ""
79     if provider.get("role_arn") is not None:
80         provider_shadow = provider.copy()
81         provider_shadow.pop("role_arn", None)
82         log.info("Assuming the role: %s", provider.get("role_arn"))
83         ret_credentials = assumed_creds(
84             provider_shadow, role_arn=provider.get("role_arn"), location="us-east-1"
85         )
86     return ret_credentials
87 def sig2(method, endpoint, params, provider, aws_api_version):
88     timenow = datetime.utcnow()
89     timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
90     access_key_id, secret_access_key, token = creds(provider)
91     params_with_headers = params.copy()
92     params_with_headers["AWSAccessKeyId"] = access_key_id
93     params_with_headers["SignatureVersion"] = "2"
94     params_with_headers["SignatureMethod"] = "HmacSHA256"
95     params_with_headers["Timestamp"] = "{}".format(timestamp)
96     params_with_headers["Version"] = aws_api_version
97     keys = sorted(params_with_headers.keys())
98     values = list(list(map(params_with_headers.get, keys)))
99     querystring = urllib.parse.urlencode(list(zip(keys, values)))
100     canonical = "{}\n{}\n/\n{}".format(
101         method.encode("utf-8"),
102         endpoint.encode("utf-8"),
103         querystring.encode("utf-8"),
104     )
105     hashed = hmac.new(secret_access_key, canonical, hashlib.sha256)
106     sig = binascii.b2a_base64(hashed.digest())
107     params_with_headers["Signature"] = sig.strip()
108     if token != "":
109         params_with_headers["SecurityToken"] = token
110     return params_with_headers
111 def assumed_creds(prov_dict, role_arn, location=None):
112     valid_session_name_re = re.compile("[^a-z0-9A-Z+=,.@-]")
113     now = time.mktime(datetime.utcnow().timetuple())
114     for key, creds in __AssumeCache__.items():
115         if (creds["Expiration"] - now) &lt;= 120:
116             __AssumeCache__.delete(key)
117     if role_arn in __AssumeCache__:
118         c = __AssumeCache__[role_arn]
119         return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]
120     version = "2011-06-15"
121     session_name = valid_session_name_re.sub(
122         "", salt.config.get_id({"root_dir": None})[0]
123     )[0:63]
124     headers, requesturl = sig4(
125         "GET",
126         "sts.amazonaws.com",
127         params={
128             "Version": version,
129             "Action": "AssumeRole",
130             "RoleSessionName": session_name,
131             "RoleArn": role_arn,
132             "Policy": (
133                 '{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1",'
134                 ' "Effect":"Allow","Action":"*","Resource":"*"}]}'
135             ),
136             "DurationSeconds": "3600",
137         },
138         aws_api_version=version,
139         data="",
140         uri="/",
141         prov_dict=prov_dict,
142         product="sts",
143         location=location,
144         requesturl="https://sts.amazonaws.com/",
145     )
146     headers["Accept"] = "application/json"
147     result = requests.request("GET", requesturl, headers=headers, data="", verify=True)
148     if result.status_code &gt;= 400:
149         log.info("AssumeRole response: %s", result.content)
150     result.raise_for_status()
151     resp = result.json()
152     data = resp["AssumeRoleResponse"]["AssumeRoleResult"]["Credentials"]
153     __AssumeCache__[role_arn] = data
154     return data["AccessKeyId"], data["SecretAccessKey"], data["SessionToken"]
155 def sig4(
156     method,
157     endpoint,
158     params,
159     prov_dict,
160     aws_api_version=DEFAULT_AWS_API_VERSION,
161     location=None,
162     product="ec2",
163     uri="/",
164     requesturl=None,
165     data="",
166     headers=None,
167     role_arn=None,
168     payload_hash=None,
169 ):
170     timenow = datetime.utcnow()
171     if role_arn is None:
172         access_key_id, secret_access_key, token = creds(prov_dict)
173     else:
174         access_key_id, secret_access_key, token = assumed_creds(
175             prov_dict, role_arn, location=location
176         )
177     if location is None:
178         location = get_region_from_metadata()
179     if location is None:
180         location = DEFAULT_LOCATION
181     params_with_headers = params.copy()
182     if product not in ("s3", "ssm"):
183         params_with_headers["Version"] = aws_api_version
184     keys = sorted(params_with_headers.keys())
185     values = list(map(params_with_headers.get, keys))
186     querystring = urllib.parse.urlencode(list(zip(keys, values))).replace("+", "%20")
187     amzdate = timenow.strftime("%Y%m%dT%H%M%SZ")
188     datestamp = timenow.strftime("%Y%m%d")
189     new_headers = {}
190     if isinstance(headers, dict):
191         new_headers = headers.copy()
192     if not payload_hash:
193         payload_hash = salt.utils.hashutils.sha256_digest(data)
194     new_headers["X-Amz-date"] = amzdate
195     new_headers["host"] = endpoint
196     new_headers["x-amz-content-sha256"] = payload_hash
197     a_canonical_headers = []
198     a_signed_headers = []
199     if token != "":
200         new_headers["X-Amz-security-token"] = token
201     for header in sorted(new_headers.keys(), key=str.lower):
202         lower_header = header.lower()
203         a_canonical_headers.append(
204             "{}:{}".format(lower_header, new_headers[header].strip())
205         )
206         a_signed_headers.append(lower_header)
207     canonical_headers = "\n".join(a_canonical_headers) + "\n"
208     signed_headers = ";".join(a_signed_headers)
209     algorithm = "AWS4-HMAC-SHA256"
210     canonical_request = "\n".join(
211         (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
212     )
213     credential_scope = "/".join((datestamp, location, product, "aws4_request"))
214     string_to_sign = "\n".join(
215         (
216             algorithm,
217             amzdate,
218             credential_scope,
219             salt.utils.hashutils.sha256_digest(canonical_request),
220         )
221     )
222     signing_key = _sig_key(secret_access_key, datestamp, location, product)
223     signature = hmac.new(
224         signing_key, string_to_sign.encode("utf-8"), hashlib.sha256
225     ).hexdigest()
226     authorization_header = "{} Credential={}/{}, SignedHeaders={}, Signature={}".format(
227         algorithm,
228         access_key_id,
229         credential_scope,
230         signed_headers,
231         signature,
232     )
233     new_headers["Authorization"] = authorization_header
234     requesturl = "{}?{}".format(requesturl, querystring)
235     return new_headers, requesturl
236 def _sign(key, msg):
237     return hmac.new(key, msg.encode("utf-8"), hashlib.sha256).digest()
238 def _sig_key(key, date_stamp, regionName, serviceName):
239     kDate = _sign(("AWS4" + key).encode("utf-8"), date_stamp)
240     if regionName:
241         kRegion = _sign(kDate, regionName)
242         kService = _sign(kRegion, serviceName)
243     else:
244         kService = _sign(kDate, serviceName)
245     kSigning = _sign(kService, "aws4_request")
246     return kSigning
247 def query(
248     params=None,
249     setname=None,
250     requesturl=None,
251     location=None,
252     return_url=False,
253     return_root=False,
254     opts=None,
255     provider=None,
256     endpoint=None,
257     product="ec2",
258     sigver="2",
259 ):
260     if params is None:
261         params = {}
262     if opts is None:
263         opts = {}
264     function = opts.get("function", (None, product))
265     providers = opts.get("providers", {})
266     if provider is None:
267         prov_dict = providers.get(function[1], {}).get(product, {})
268         if prov_dict:
269             driver = list(list(prov_dict.keys()))[0]
270             provider = providers.get(driver, product)
271     else:
272         prov_dict = providers.get(provider, {}).get(product, {})
273     service_url = prov_dict.get("service_url", "amazonaws.com")
274     if not location:
275         location = get_location(opts, prov_dict)
276     if endpoint is None:
277         if not requesturl:
278             endpoint = prov_dict.get(
279                 "endpoint", "{}.{}.{}".format(product, location, service_url)
280             )
281             requesturl = "https://{}/".format(endpoint)
282         else:
283             endpoint = urllib.parse.urlparse(requesturl).netloc
284             if endpoint == "":
285                 endpoint_err = (
286                     "Could not find a valid endpoint in the "
287                     "requesturl: {}. Looking for something "
288                     "like https://some.aws.endpoint/?args".format(requesturl)
289                 )
290                 log.error(endpoint_err)
291                 if return_url is True:
292                     return {"error": endpoint_err}, requesturl
293                 return {"error": endpoint_err}
294     log.debug("Using AWS endpoint: %s", endpoint)
295     method = "GET"
296     aws_api_version = prov_dict.get(
297         "aws_api_version",
298         prov_dict.get("{}_api_version".format(product), DEFAULT_AWS_API_VERSION),
299     )
300     if not prov_dict.get("id", None):
301         prov_dict["id"] = providers.get(provider, {}).get("ec2", {}).get("id", {})
302         prov_dict["key"] = providers.get(provider, {}).get("ec2", {}).get("key", {})
303     if sigver == "4":
304         headers, requesturl = sig4(
305             method,
306             endpoint,
307             params,
308             prov_dict,
309             aws_api_version,
310             location,
311             product,
312             requesturl=requesturl,
313         )
314         params_with_headers = {}
315     else:
316         params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
317         headers = {}
318     attempts = 0
319     while attempts &lt; AWS_MAX_RETRIES:
320         log.debug("AWS Request: %s", requesturl)
321         log.trace("AWS Request Parameters: %s", params_with_headers)
322         try:
323             result = requests.get(
324                 requesturl, headers=headers, params=params_with_headers
325             )
326             log.debug("AWS Response Status Code: %s", result.status_code)
327             log.trace("AWS Response Text: %s", result.text)
328             result.raise_for_status()
329             break
330         except requests.exceptions.HTTPError as exc:
331             root = ET.fromstring(exc.response.content)
332             data = xml.to_dict(root)
333             err_code = data.get("Errors", {}).get("Error", {}).get("Code", "")
334             if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
335                 attempts += 1
336                 log.error(
337                     "AWS Response Status Code and Error: [%s %s] %s; "
338                     "Attempts remaining: %s",
339                     exc.response.status_code,
340                     exc,
341                     data,
342                     attempts,
343                 )
344                 sleep_exponential_backoff(attempts)
345                 continue
346             log.error(
347                 "AWS Response Status Code and Error: [%s %s] %s",
348                 exc.response.status_code,
349                 exc,
350                 data,
351             )
352             if return_url is True:
353                 return {"error": data}, requesturl
354             return {"error": data}
355     else:
356         log.error(
357             "AWS Response Status Code and Error: [%s %s] %s",
358             exc.response.status_code,
359             exc,
360             data,
361         )
362         if return_url is True:
363             return {"error": data}, requesturl
364         return {"error": data}
365     root = ET.fromstring(result.text)
366     items = root[1]
367     if return_root is True:
368         items = root
369     if setname:
370         for idx, item in enumerate(root):
371             comps = item.tag.split("}")
372             if comps[1] == setname:
373                 items = root[idx]
374     ret = []
375     for item in items:
376         ret.append(xml.to_dict(item))
377     if return_url is True:
378         return ret, requesturl
379     return ret
380 def get_region_from_metadata():
381     global __Location__
382     if __Location__ == "do-not-get-from-metadata":
383         log.debug(
384             "Previously failed to get AWS region from metadata. Not trying again."
385         )
386         return None
387     if __Location__ != "":
388         return __Location__
389     try:
390         result = requests.get(
391             "http://169.254.169.254/latest/dynamic/instance-identity/document",
392             proxies={"http": ""},
393             timeout=AWS_METADATA_TIMEOUT,
394         )
395     except requests.exceptions.RequestException:
396         log.warning("Failed to get AWS region from instance metadata.", exc_info=True)
397         __Location__ = "do-not-get-from-metadata"
398         return None
399     try:
400         region = result.json()["region"]
401         __Location__ = region
402         return __Location__
403     except (ValueError, KeyError):
404         log.warning("Failed to decode JSON from instance metadata.")
405         return None
406     return None
407 def get_location(opts=None, provider=None):
408     if opts is None:
409         opts = {}
410     ret = opts.get("location")
411     if ret is None and provider is not None:
412         ret = provider.get("location")
413     if ret is None:
414         ret = get_region_from_metadata()
415     if ret is None:
416         ret = DEFAULT_LOCATION
417     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
