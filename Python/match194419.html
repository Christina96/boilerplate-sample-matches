<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for locale.py & aws.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for locale.py & aws.py
      </h3>
      <h1 align="center">
        1.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>locale.py (1.8720748%)<TH>aws.py (1.6021361%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match194419-0.html#0',2,'match194419-1.html#0',3)" NAME="0">(43-57)<TD><A HREF="javascript:ZweiFrames('match194419-0.html#0',2,'match194419-1.html#0',3)" NAME="0">(11-23)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>locale.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright 2009 Facebook
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

&quot;&quot;&quot;Translation methods for generating localized strings.

To load a locale and generate a translated string::

    user_locale = tornado.locale.get(&quot;es_LA&quot;)
    print(user_locale.translate(&quot;Sign out&quot;))

`tornado.locale.get()` returns the closest matching locale, not necessarily the
specific locale you requested. You can support pluralization with
additional arguments to `~Locale.translate()`, e.g.::

    people = [...]
    message = user_locale.translate(
        &quot;%(list)s is online&quot;, &quot;%(list)s are online&quot;, len(people))
    print(message % {&quot;list&quot;: user_locale.list(people)})

The first string is chosen if ``len(people) == 1``, otherwise the second
string is chosen.

Applications should call one of `load_translations` (which uses a simple
CSV format) or `load_gettext_translations` (which uses the ``.mo`` format
supported by `gettext` and related tools).  If neither method is called,
the `Locale.translate` method will simply return the original string.
<A NAME="0"></A>&quot;&quot;&quot;
# pylint: skip-file

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match194419-1.html#0',3,'match194419-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>from __future__ import absolute_import, division, print_function

import codecs
import csv
import datetime
from io import BytesIO
import numbers
import os
import re

from salt.ext.tornado import escape
from salt.ext.tornado.log import gen_log
from salt.ext.tornado.util import PY3

from</B></FONT> salt.ext.tornado._locale_data import LOCALE_NAMES

_default_locale = &quot;en_US&quot;
_translations = {}  # type: dict
_supported_locales = frozenset([_default_locale])
_use_gettext = False
CONTEXT_SEPARATOR = &quot;\x04&quot;


def get(*locale_codes):
    &quot;&quot;&quot;Returns the closest match for the given locale codes.

    We iterate over all given locale codes in order. If we have a tight
    or a loose match for the code (e.g., &quot;en&quot; for &quot;en_US&quot;), we return
    the locale. Otherwise we move to the next code in the list.

    By default we return ``en_US`` if no translations are found for any of
    the specified locales. You can change the default locale with
    `set_default_locale()`.
    &quot;&quot;&quot;
    return Locale.get_closest(*locale_codes)


def set_default_locale(code):
    &quot;&quot;&quot;Sets the default locale.

    The default locale is assumed to be the language used for all strings
    in the system. The translations loaded from disk are mappings from
    the default locale to the destination locale. Consequently, you don't
    need to create a translation file for the default locale.
    &quot;&quot;&quot;
    global _default_locale
    global _supported_locales
    _default_locale = code
    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])


def load_translations(directory, encoding=None):
    &quot;&quot;&quot;Loads translations from CSV files in a directory.

    Translations are strings with optional Python-style named placeholders
    (e.g., ``My name is %(name)s``) and their associated translations.

    The directory should have translation files of the form ``LOCALE.csv``,
    e.g. ``es_GT.csv``. The CSV files should have two or three columns: string,
    translation, and an optional plural indicator. Plural indicators should
    be one of &quot;plural&quot; or &quot;singular&quot;. A given string can have both singular
    and plural forms. For example ``%(name)s liked this`` may have a
    different verb conjugation depending on whether %(name)s is one
    name or a list of names. There should be two rows in the CSV file for
    that string, one with plural indicator &quot;singular&quot;, and one &quot;plural&quot;.
    For strings with no verbs that would change on translation, simply
    use &quot;unknown&quot; or the empty string (or don't include the column at all).

    The file is read using the `csv` module in the default &quot;excel&quot; dialect.
    In this format there should not be spaces after the commas.

    If no ``encoding`` parameter is given, the encoding will be
    detected automatically (among UTF-8 and UTF-16) if the file
    contains a byte-order marker (BOM), defaulting to UTF-8 if no BOM
    is present.

    Example translation ``es_LA.csv``::

        &quot;I love you&quot;,&quot;Te amo&quot;
        &quot;%(name)s liked this&quot;,&quot;A %(name)s les gustó esto&quot;,&quot;plural&quot;
        &quot;%(name)s liked this&quot;,&quot;A %(name)s le gustó esto&quot;,&quot;singular&quot;

    .. versionchanged:: 4.3
       Added ``encoding`` parameter. Added support for BOM-based encoding
       detection, UTF-16, and UTF-8-with-BOM.
    &quot;&quot;&quot;
    global _translations
    global _supported_locales
    _translations = {}
    for path in os.listdir(directory):
        if not path.endswith(&quot;.csv&quot;):
            continue
        locale, extension = path.split(&quot;.&quot;)
        if not re.match(&quot;[a-z]+(_[A-Z]+)?$&quot;, locale):
            gen_log.error(&quot;Unrecognized locale %r (path: %s)&quot;, locale,
                          os.path.join(directory, path))
            continue
        full_path = os.path.join(directory, path)
        if encoding is None:
            # Try to autodetect encoding based on the BOM.
            with open(full_path, 'rb') as f:
                data = f.read(len(codecs.BOM_UTF16_LE))
            if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):
                encoding = 'utf-16'
            else:
                # utf-8-sig is &quot;utf-8 with optional BOM&quot;. It's discouraged
                # in most cases but is common with CSV files because Excel
                # cannot read utf-8 files without a BOM.
                encoding = 'utf-8-sig'
        if PY3:
            # python 3: csv.reader requires a file open in text mode.
            # Force utf8 to avoid dependence on $LANG environment variable.
            f = open(full_path, &quot;r&quot;, encoding=encoding)
        else:
            # python 2: csv can only handle byte strings (in ascii-compatible
            # encodings), which we decode below. Transcode everything into
            # utf8 before passing it to csv.reader.
            f = BytesIO()
            with codecs.open(full_path, &quot;r&quot;, encoding=encoding) as infile:
                f.write(escape.utf8(infile.read()))
            f.seek(0)
        _translations[locale] = {}
        for i, row in enumerate(csv.reader(f)):
            if not row or len(row) &lt; 2:
                continue
            row = [escape.to_unicode(c).strip() for c in row]
            english, translation = row[:2]
            if len(row) &gt; 2:
                plural = row[2] or &quot;unknown&quot;
            else:
                plural = &quot;unknown&quot;
            if plural not in (&quot;plural&quot;, &quot;singular&quot;, &quot;unknown&quot;):
                gen_log.error(&quot;Unrecognized plural indicator %r in %s line %d&quot;,
                              plural, path, i + 1)
                continue
            _translations[locale].setdefault(plural, {})[english] = translation
        f.close()
    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
    gen_log.debug(&quot;Supported locales: %s&quot;, sorted(_supported_locales))


def load_gettext_translations(directory, domain):
    &quot;&quot;&quot;Loads translations from `gettext`'s locale tree

    Locale tree is similar to system's ``/usr/share/locale``, like::

        {directory}/{lang}/LC_MESSAGES/{domain}.mo

    Three steps are required to have your app translated:

    1. Generate POT translation file::

        xgettext --language=Python --keyword=_:1,2 -d mydomain file1.py file2.html etc

    2. Merge against existing POT file::

        msgmerge old.po mydomain.po &gt; new.po

    3. Compile::

        msgfmt mydomain.po -o {directory}/pt_BR/LC_MESSAGES/mydomain.mo
    &quot;&quot;&quot;
    import gettext
    global _translations
    global _supported_locales
    global _use_gettext
    _translations = {}
    for lang in os.listdir(directory):
        if lang.startswith('.'):
            continue  # skip .svn, etc
        if os.path.isfile(os.path.join(directory, lang)):
            continue
        try:
            os.stat(os.path.join(directory, lang, &quot;LC_MESSAGES&quot;, domain + &quot;.mo&quot;))
            _translations[lang] = gettext.translation(domain, directory,
                                                      languages=[lang])
        except Exception as e:
            gen_log.error(&quot;Cannot load translation for '%s': %s&quot;, lang, str(e))
            continue
    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
    _use_gettext = True
    gen_log.debug(&quot;Supported locales: %s&quot;, sorted(_supported_locales))


def get_supported_locales():
    &quot;&quot;&quot;Returns a list of all the supported locale codes.&quot;&quot;&quot;
    return _supported_locales


class Locale(object):
    &quot;&quot;&quot;Object representing a locale.

    After calling one of `load_translations` or `load_gettext_translations`,
    call `get` or `get_closest` to get a Locale object.
    &quot;&quot;&quot;
    @classmethod
    def get_closest(cls, *locale_codes):
        &quot;&quot;&quot;Returns the closest match for the given locale code.&quot;&quot;&quot;
        for code in locale_codes:
            if not code:
                continue
            code = code.replace(&quot;-&quot;, &quot;_&quot;)
            parts = code.split(&quot;_&quot;)
            if len(parts) &gt; 2:
                continue
            elif len(parts) == 2:
                code = parts[0].lower() + &quot;_&quot; + parts[1].upper()
            if code in _supported_locales:
                return cls.get(code)
            if parts[0].lower() in _supported_locales:
                return cls.get(parts[0].lower())
        return cls.get(_default_locale)

    @classmethod
    def get(cls, code):
        &quot;&quot;&quot;Returns the Locale for the given locale code.

        If it is not supported, we raise an exception.
        &quot;&quot;&quot;
        if not hasattr(cls, &quot;_cache&quot;):
            cls._cache = {}
        if code not in cls._cache:
            assert code in _supported_locales
            translations = _translations.get(code, None)
            if translations is None:
                locale = CSVLocale(code, {})
            elif _use_gettext:
                locale = GettextLocale(code, translations)
            else:
                locale = CSVLocale(code, translations)
            cls._cache[code] = locale
        return cls._cache[code]

    def __init__(self, code, translations):
        self.code = code
        self.name = LOCALE_NAMES.get(code, {}).get(&quot;name&quot;, u&quot;Unknown&quot;)
        self.rtl = False
        for prefix in [&quot;fa&quot;, &quot;ar&quot;, &quot;he&quot;]:
            if self.code.startswith(prefix):
                self.rtl = True
                break
        self.translations = translations

        # Initialize strings for date formatting
        _ = self.translate
        self._months = [
            _(&quot;January&quot;), _(&quot;February&quot;), _(&quot;March&quot;), _(&quot;April&quot;),
            _(&quot;May&quot;), _(&quot;June&quot;), _(&quot;July&quot;), _(&quot;August&quot;),
            _(&quot;September&quot;), _(&quot;October&quot;), _(&quot;November&quot;), _(&quot;December&quot;)]
        self._weekdays = [
            _(&quot;Monday&quot;), _(&quot;Tuesday&quot;), _(&quot;Wednesday&quot;), _(&quot;Thursday&quot;),
            _(&quot;Friday&quot;), _(&quot;Saturday&quot;), _(&quot;Sunday&quot;)]

    def translate(self, message, plural_message=None, count=None):
        &quot;&quot;&quot;Returns the translation for the given message for this locale.

        If ``plural_message`` is given, you must also provide
        ``count``. We return ``plural_message`` when ``count != 1``,
        and we return the singular form for the given message when
        ``count == 1``.
        &quot;&quot;&quot;
        raise NotImplementedError()

    def pgettext(self, context, message, plural_message=None, count=None):
        raise NotImplementedError()

    def format_date(self, date, gmt_offset=0, relative=True, shorter=False,
                    full_format=False):
        &quot;&quot;&quot;Formats the given date (which should be GMT).

        By default, we return a relative time (e.g., &quot;2 minutes ago&quot;). You
        can return an absolute date string with ``relative=False``.

        You can force a full format date (&quot;July 10, 1980&quot;) with
        ``full_format=True``.

        This method is primarily intended for dates in the past.
        For dates in the future, we fall back to full format.
        &quot;&quot;&quot;
        if isinstance(date, numbers.Real):
            date = datetime.datetime.utcfromtimestamp(date)
        now = datetime.datetime.utcnow()
        if date &gt; now:
            if relative and (date - now).seconds &lt; 60:
                # Due to click skew, things are some things slightly
                # in the future. Round timestamps in the immediate
                # future down to now in relative mode.
                date = now
            else:
                # Otherwise, future dates always use the full format.
                full_format = True
        local_date = date - datetime.timedelta(minutes=gmt_offset)
        local_now = now - datetime.timedelta(minutes=gmt_offset)
        local_yesterday = local_now - datetime.timedelta(hours=24)
        difference = now - date
        seconds = difference.seconds
        days = difference.days

        _ = self.translate
        format = None
        if not full_format:
            if relative and days == 0:
                if seconds &lt; 50:
                    return _(&quot;1 second ago&quot;, &quot;%(seconds)d seconds ago&quot;,
                             seconds) % {&quot;seconds&quot;: seconds}

                if seconds &lt; 50 * 60:
                    minutes = round(seconds / 60.0)
                    return _(&quot;1 minute ago&quot;, &quot;%(minutes)d minutes ago&quot;,
                             minutes) % {&quot;minutes&quot;: minutes}

                hours = round(seconds / (60.0 * 60))
                return _(&quot;1 hour ago&quot;, &quot;%(hours)d hours ago&quot;,
                         hours) % {&quot;hours&quot;: hours}

            if days == 0:
                format = _(&quot;%(time)s&quot;)
            elif days == 1 and local_date.day == local_yesterday.day and \
                    relative:
                format = _(&quot;yesterday&quot;) if shorter else \
                    _(&quot;yesterday at %(time)s&quot;)
            elif days &lt; 5:
                format = _(&quot;%(weekday)s&quot;) if shorter else \
                    _(&quot;%(weekday)s at %(time)s&quot;)
            elif days &lt; 334:  # 11mo, since confusing for same month last year
                format = _(&quot;%(month_name)s %(day)s&quot;) if shorter else \
                    _(&quot;%(month_name)s %(day)s at %(time)s&quot;)

        if format is None:
            format = _(&quot;%(month_name)s %(day)s, %(year)s&quot;) if shorter else \
                _(&quot;%(month_name)s %(day)s, %(year)s at %(time)s&quot;)

        tfhour_clock = self.code not in (&quot;en&quot;, &quot;en_US&quot;, &quot;zh_CN&quot;)
        if tfhour_clock:
            str_time = &quot;%d:%02d&quot; % (local_date.hour, local_date.minute)
        elif self.code == &quot;zh_CN&quot;:
            str_time = &quot;%s%d:%02d&quot; % (
                (u'\u4e0a\u5348', u'\u4e0b\u5348')[local_date.hour &gt;= 12],
                local_date.hour % 12 or 12, local_date.minute)
        else:
            str_time = &quot;%d:%02d %s&quot; % (
                local_date.hour % 12 or 12, local_date.minute,
                (&quot;am&quot;, &quot;pm&quot;)[local_date.hour &gt;= 12])

        return format % {
            &quot;month_name&quot;: self._months[local_date.month - 1],
            &quot;weekday&quot;: self._weekdays[local_date.weekday()],
            &quot;day&quot;: str(local_date.day),
            &quot;year&quot;: str(local_date.year),
            &quot;time&quot;: str_time
        }

    def format_day(self, date, gmt_offset=0, dow=True):
        &quot;&quot;&quot;Formats the given date as a day of week.

        Example: &quot;Monday, January 22&quot;. You can remove the day of week with
        ``dow=False``.
        &quot;&quot;&quot;
        local_date = date - datetime.timedelta(minutes=gmt_offset)
        _ = self.translate
        if dow:
            return _(&quot;%(weekday)s, %(month_name)s %(day)s&quot;) % {
                &quot;month_name&quot;: self._months[local_date.month - 1],
                &quot;weekday&quot;: self._weekdays[local_date.weekday()],
                &quot;day&quot;: str(local_date.day),
            }
        else:
            return _(&quot;%(month_name)s %(day)s&quot;) % {
                &quot;month_name&quot;: self._months[local_date.month - 1],
                &quot;day&quot;: str(local_date.day),
            }

    def list(self, parts):
        &quot;&quot;&quot;Returns a comma-separated list for the given list of parts.

        The format is, e.g., &quot;A, B and C&quot;, &quot;A and B&quot; or just &quot;A&quot; for lists
        of size 1.
        &quot;&quot;&quot;
        _ = self.translate
        if len(parts) == 0:
            return &quot;&quot;
        if len(parts) == 1:
            return parts[0]
        comma = u' \u0648 ' if self.code.startswith(&quot;fa&quot;) else u&quot;, &quot;
        return _(&quot;%(commas)s and %(last)s&quot;) % {
            &quot;commas&quot;: comma.join(parts[:-1]),
            &quot;last&quot;: parts[len(parts) - 1],
        }

    def friendly_number(self, value):
        &quot;&quot;&quot;Returns a comma-separated number for the given integer.&quot;&quot;&quot;
        if self.code not in (&quot;en&quot;, &quot;en_US&quot;):
            return str(value)
        value = str(value)
        parts = []
        while value:
            parts.append(value[-3:])
            value = value[:-3]
        return &quot;,&quot;.join(reversed(parts))


class CSVLocale(Locale):
    &quot;&quot;&quot;Locale implementation using tornado's CSV translation format.&quot;&quot;&quot;
    def translate(self, message, plural_message=None, count=None):
        if plural_message is not None:
            assert count is not None
            if count != 1:
                message = plural_message
                message_dict = self.translations.get(&quot;plural&quot;, {})
            else:
                message_dict = self.translations.get(&quot;singular&quot;, {})
        else:
            message_dict = self.translations.get(&quot;unknown&quot;, {})
        return message_dict.get(message, message)

    def pgettext(self, context, message, plural_message=None, count=None):
        if self.translations:
            gen_log.warning('pgettext is not supported by CSVLocale')
        return self.translate(message, plural_message, count)


class GettextLocale(Locale):
    &quot;&quot;&quot;Locale implementation using the `gettext` module.&quot;&quot;&quot;
    def __init__(self, code, translations):
        try:
            # python 2
            self.ngettext = translations.ungettext
            self.gettext = translations.ugettext
        except AttributeError:
            # python 3
            self.ngettext = translations.ngettext
            self.gettext = translations.gettext
        # self.gettext must exist before __init__ is called, since it
        # calls into self.translate
        super(GettextLocale, self).__init__(code, translations)

    def translate(self, message, plural_message=None, count=None):
        if plural_message is not None:
            assert count is not None
            return self.ngettext(message, plural_message, count)
        else:
            return self.gettext(message)

    def pgettext(self, context, message, plural_message=None, count=None):
        &quot;&quot;&quot;Allows to set context for translation, accepts plural forms.

        Usage example::

            pgettext(&quot;law&quot;, &quot;right&quot;)
            pgettext(&quot;good&quot;, &quot;right&quot;)

        Plural message example::

            pgettext(&quot;organization&quot;, &quot;club&quot;, &quot;clubs&quot;, len(clubs))
            pgettext(&quot;stick&quot;, &quot;club&quot;, &quot;clubs&quot;, len(clubs))

        To generate POT file with context, add following options to step 1
        of `load_gettext_translations` sequence::

            xgettext [basic options] --keyword=pgettext:1c,2 --keyword=pgettext:1c,2,3

        .. versionadded:: 4.2
        &quot;&quot;&quot;
        if plural_message is not None:
            assert count is not None
            msgs_with_ctxt = (&quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, message),
                              &quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, plural_message),
                              count)
            result = self.ngettext(*msgs_with_ctxt)
            if CONTEXT_SEPARATOR in result:
                # Translation not found
                result = self.ngettext(message, plural_message, count)
            return result
        else:
            msg_with_ctxt = &quot;%s%s%s&quot; % (context, CONTEXT_SEPARATOR, message)
            result = self.gettext(msg_with_ctxt)
            if CONTEXT_SEPARATOR in result:
                # Translation not found
                result = message
            return result
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Connection library for AWS

.. versionadded:: 2015.5.0

This is a base library used by a number of AWS services.

<A NAME="0"></A>:depends: requests
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match194419-0.html#0',2,'match194419-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import binascii
import hashlib
import hmac
import logging
import random
import re
import time
import urllib.parse
import xml.etree.ElementTree as ET
from datetime import datetime

import salt.config
import</B></FONT> salt.utils.hashutils
import salt.utils.xmlutil as xml

try:
    import requests

    HAS_REQUESTS = True  # pylint: disable=W0612
except ImportError:
    HAS_REQUESTS = False  # pylint: disable=W0612

# pylint: enable=import-error,redefined-builtin,no-name-in-module

log = logging.getLogger(__name__)
DEFAULT_LOCATION = &quot;us-east-1&quot;
DEFAULT_AWS_API_VERSION = &quot;2016-11-15&quot;
AWS_RETRY_CODES = [
    &quot;RequestLimitExceeded&quot;,
    &quot;InsufficientInstanceCapacity&quot;,
    &quot;InternalError&quot;,
    &quot;Unavailable&quot;,
    &quot;InsufficientAddressCapacity&quot;,
    &quot;InsufficientReservedInstanceCapacity&quot;,
]
AWS_METADATA_TIMEOUT = 3.05

AWS_MAX_RETRIES = 7

IROLE_CODE = &quot;use-instance-role-credentials&quot;
__AccessKeyId__ = &quot;&quot;
__SecretAccessKey__ = &quot;&quot;
__Token__ = &quot;&quot;
__Expiration__ = &quot;&quot;
__Location__ = &quot;&quot;
__AssumeCache__ = {}


def sleep_exponential_backoff(attempts):
    &quot;&quot;&quot;
    backoff an exponential amount of time to throttle requests
    during &quot;API Rate Exceeded&quot; failures as suggested by the AWS documentation here:
    https://docs.aws.amazon.com/AWSEC2/latest/APIReference/query-api-troubleshooting.html
    and also here:
    https://docs.aws.amazon.com/general/latest/gr/api-retries.html
    Failure to implement this approach results in a failure rate of &gt;30% when using salt-cloud with
    &quot;--parallel&quot; when creating 50 or more instances with a fixed delay of 2 seconds.
    A failure rate of &gt;10% is observed when using the salt-api with an asynchronous client
    specified (runner_async).
    &quot;&quot;&quot;
    time.sleep(random.uniform(1, 2 ** attempts))


def creds(provider):
    &quot;&quot;&quot;
    Return the credentials for AWS signing.  This could be just the id and key
    specified in the provider configuration, or if the id or key is set to the
    literal string 'use-instance-role-credentials' creds will pull the instance
    role credentials from the meta data, cache them, and provide them instead.
    &quot;&quot;&quot;
    # Declare globals
    global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__

    ret_credentials = ()

    # if id or key is 'use-instance-role-credentials', pull them from meta-data
    ## if needed
    if provider[&quot;id&quot;] == IROLE_CODE or provider[&quot;key&quot;] == IROLE_CODE:
        # Check to see if we have cache credentials that are still good
        if __Expiration__ != &quot;&quot;:
            timenow = datetime.utcnow()
            timestamp = timenow.strftime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)
            if timestamp &lt; __Expiration__:
                # Current timestamp less than expiration fo cached credentials
                return __AccessKeyId__, __SecretAccessKey__, __Token__
        # We don't have any cached credentials, or they are expired, get them

        # Connections to instance meta-data must fail fast and never be proxied
        try:
            result = requests.get(
                &quot;http://169.254.169.254/latest/meta-data/iam/security-credentials/&quot;,
                proxies={&quot;http&quot;: &quot;&quot;},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
            role = result.text
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider[&quot;id&quot;], provider[&quot;key&quot;], &quot;&quot;

        try:
            result = requests.get(
                &quot;http://169.254.169.254/latest/meta-data/iam/security-credentials/{}&quot;.format(
                    role
                ),
                proxies={&quot;http&quot;: &quot;&quot;},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider[&quot;id&quot;], provider[&quot;key&quot;], &quot;&quot;

        data = result.json()
        __AccessKeyId__ = data[&quot;AccessKeyId&quot;]
        __SecretAccessKey__ = data[&quot;SecretAccessKey&quot;]
        __Token__ = data[&quot;Token&quot;]
        __Expiration__ = data[&quot;Expiration&quot;]

        ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
    else:
        ret_credentials = provider[&quot;id&quot;], provider[&quot;key&quot;], &quot;&quot;

    if provider.get(&quot;role_arn&quot;) is not None:
        provider_shadow = provider.copy()
        provider_shadow.pop(&quot;role_arn&quot;, None)
        log.info(&quot;Assuming the role: %s&quot;, provider.get(&quot;role_arn&quot;))
        ret_credentials = assumed_creds(
            provider_shadow, role_arn=provider.get(&quot;role_arn&quot;), location=&quot;us-east-1&quot;
        )

    return ret_credentials


def sig2(method, endpoint, params, provider, aws_api_version):
    &quot;&quot;&quot;
    Sign a query against AWS services using Signature Version 2 Signing
    Process. This is documented at:

    http://docs.aws.amazon.com/general/latest/gr/signature-version-2.html
    &quot;&quot;&quot;
    timenow = datetime.utcnow()
    timestamp = timenow.strftime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;)

    # Retrieve access credentials from meta-data, or use provided
    access_key_id, secret_access_key, token = creds(provider)

    params_with_headers = params.copy()
    params_with_headers[&quot;AWSAccessKeyId&quot;] = access_key_id
    params_with_headers[&quot;SignatureVersion&quot;] = &quot;2&quot;
    params_with_headers[&quot;SignatureMethod&quot;] = &quot;HmacSHA256&quot;
    params_with_headers[&quot;Timestamp&quot;] = &quot;{}&quot;.format(timestamp)
    params_with_headers[&quot;Version&quot;] = aws_api_version
    keys = sorted(params_with_headers.keys())
    values = list(list(map(params_with_headers.get, keys)))
    querystring = urllib.parse.urlencode(list(zip(keys, values)))

    canonical = &quot;{}\n{}\n/\n{}&quot;.format(
        method.encode(&quot;utf-8&quot;),
        endpoint.encode(&quot;utf-8&quot;),
        querystring.encode(&quot;utf-8&quot;),
    )

    hashed = hmac.new(secret_access_key, canonical, hashlib.sha256)
    sig = binascii.b2a_base64(hashed.digest())
    params_with_headers[&quot;Signature&quot;] = sig.strip()

    # Add in security token if we have one
    if token != &quot;&quot;:
        params_with_headers[&quot;SecurityToken&quot;] = token

    return params_with_headers


def assumed_creds(prov_dict, role_arn, location=None):
    valid_session_name_re = re.compile(&quot;[^a-z0-9A-Z+=,.@-]&quot;)

    # current time in epoch seconds
    now = time.mktime(datetime.utcnow().timetuple())

    for key, creds in __AssumeCache__.items():
        if (creds[&quot;Expiration&quot;] - now) &lt;= 120:
            __AssumeCache__.delete(key)

    if role_arn in __AssumeCache__:
        c = __AssumeCache__[role_arn]
        return c[&quot;AccessKeyId&quot;], c[&quot;SecretAccessKey&quot;], c[&quot;SessionToken&quot;]

    version = &quot;2011-06-15&quot;
    session_name = valid_session_name_re.sub(
        &quot;&quot;, salt.config.get_id({&quot;root_dir&quot;: None})[0]
    )[0:63]

    headers, requesturl = sig4(
        &quot;GET&quot;,
        &quot;sts.amazonaws.com&quot;,
        params={
            &quot;Version&quot;: version,
            &quot;Action&quot;: &quot;AssumeRole&quot;,
            &quot;RoleSessionName&quot;: session_name,
            &quot;RoleArn&quot;: role_arn,
            &quot;Policy&quot;: (
                '{&quot;Version&quot;:&quot;2012-10-17&quot;,&quot;Statement&quot;:[{&quot;Sid&quot;:&quot;Stmt1&quot;,'
                ' &quot;Effect&quot;:&quot;Allow&quot;,&quot;Action&quot;:&quot;*&quot;,&quot;Resource&quot;:&quot;*&quot;}]}'
            ),
            &quot;DurationSeconds&quot;: &quot;3600&quot;,
        },
        aws_api_version=version,
        data=&quot;&quot;,
        uri=&quot;/&quot;,
        prov_dict=prov_dict,
        product=&quot;sts&quot;,
        location=location,
        requesturl=&quot;https://sts.amazonaws.com/&quot;,
    )
    headers[&quot;Accept&quot;] = &quot;application/json&quot;
    result = requests.request(&quot;GET&quot;, requesturl, headers=headers, data=&quot;&quot;, verify=True)

    if result.status_code &gt;= 400:
        log.info(&quot;AssumeRole response: %s&quot;, result.content)
    result.raise_for_status()
    resp = result.json()

    data = resp[&quot;AssumeRoleResponse&quot;][&quot;AssumeRoleResult&quot;][&quot;Credentials&quot;]
    __AssumeCache__[role_arn] = data
    return data[&quot;AccessKeyId&quot;], data[&quot;SecretAccessKey&quot;], data[&quot;SessionToken&quot;]


def sig4(
    method,
    endpoint,
    params,
    prov_dict,
    aws_api_version=DEFAULT_AWS_API_VERSION,
    location=None,
    product=&quot;ec2&quot;,
    uri=&quot;/&quot;,
    requesturl=None,
    data=&quot;&quot;,
    headers=None,
    role_arn=None,
    payload_hash=None,
):
    &quot;&quot;&quot;
    Sign a query against AWS services using Signature Version 4 Signing
    Process. This is documented at:

    http://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
    http://docs.aws.amazon.com/general/latest/gr/sigv4-signed-request-examples.html
    http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
    &quot;&quot;&quot;
    timenow = datetime.utcnow()

    # Retrieve access credentials from meta-data, or use provided
    if role_arn is None:
        access_key_id, secret_access_key, token = creds(prov_dict)
    else:
        access_key_id, secret_access_key, token = assumed_creds(
            prov_dict, role_arn, location=location
        )

    if location is None:
        location = get_region_from_metadata()
    if location is None:
        location = DEFAULT_LOCATION

    params_with_headers = params.copy()
    if product not in (&quot;s3&quot;, &quot;ssm&quot;):
        params_with_headers[&quot;Version&quot;] = aws_api_version
    keys = sorted(params_with_headers.keys())
    values = list(map(params_with_headers.get, keys))
    querystring = urllib.parse.urlencode(list(zip(keys, values))).replace(&quot;+&quot;, &quot;%20&quot;)

    amzdate = timenow.strftime(&quot;%Y%m%dT%H%M%SZ&quot;)
    datestamp = timenow.strftime(&quot;%Y%m%d&quot;)
    new_headers = {}
    if isinstance(headers, dict):
        new_headers = headers.copy()

    # Create payload hash (hash of the request body content). For GET
    # requests, the payload is an empty string ('').
    if not payload_hash:
        payload_hash = salt.utils.hashutils.sha256_digest(data)

    new_headers[&quot;X-Amz-date&quot;] = amzdate
    new_headers[&quot;host&quot;] = endpoint
    new_headers[&quot;x-amz-content-sha256&quot;] = payload_hash
    a_canonical_headers = []
    a_signed_headers = []

    if token != &quot;&quot;:
        new_headers[&quot;X-Amz-security-token&quot;] = token

    for header in sorted(new_headers.keys(), key=str.lower):
        lower_header = header.lower()
        a_canonical_headers.append(
            &quot;{}:{}&quot;.format(lower_header, new_headers[header].strip())
        )
        a_signed_headers.append(lower_header)
    canonical_headers = &quot;\n&quot;.join(a_canonical_headers) + &quot;\n&quot;
    signed_headers = &quot;;&quot;.join(a_signed_headers)

    algorithm = &quot;AWS4-HMAC-SHA256&quot;

    # Combine elements to create create canonical request
    canonical_request = &quot;\n&quot;.join(
        (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
    )

    # Create the string to sign
    credential_scope = &quot;/&quot;.join((datestamp, location, product, &quot;aws4_request&quot;))
    string_to_sign = &quot;\n&quot;.join(
        (
            algorithm,
            amzdate,
            credential_scope,
            salt.utils.hashutils.sha256_digest(canonical_request),
        )
    )

    # Create the signing key using the function defined above.
    signing_key = _sig_key(secret_access_key, datestamp, location, product)

    # Sign the string_to_sign using the signing_key
    signature = hmac.new(
        signing_key, string_to_sign.encode(&quot;utf-8&quot;), hashlib.sha256
    ).hexdigest()

    # Add signing information to the request
    authorization_header = &quot;{} Credential={}/{}, SignedHeaders={}, Signature={}&quot;.format(
        algorithm,
        access_key_id,
        credential_scope,
        signed_headers,
        signature,
    )

    new_headers[&quot;Authorization&quot;] = authorization_header

    requesturl = &quot;{}?{}&quot;.format(requesturl, querystring)
    return new_headers, requesturl


def _sign(key, msg):
    &quot;&quot;&quot;
    Key derivation functions. See:

    http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-python
    &quot;&quot;&quot;
    return hmac.new(key, msg.encode(&quot;utf-8&quot;), hashlib.sha256).digest()


def _sig_key(key, date_stamp, regionName, serviceName):
    &quot;&quot;&quot;
    Get a signature key. See:

    http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-python
    &quot;&quot;&quot;
    kDate = _sign((&quot;AWS4&quot; + key).encode(&quot;utf-8&quot;), date_stamp)
    if regionName:
        kRegion = _sign(kDate, regionName)
        kService = _sign(kRegion, serviceName)
    else:
        kService = _sign(kDate, serviceName)
    kSigning = _sign(kService, &quot;aws4_request&quot;)
    return kSigning


def query(
    params=None,
    setname=None,
    requesturl=None,
    location=None,
    return_url=False,
    return_root=False,
    opts=None,
    provider=None,
    endpoint=None,
    product=&quot;ec2&quot;,
    sigver=&quot;2&quot;,
):
    &quot;&quot;&quot;
    Perform a query against AWS services using Signature Version 2 Signing
    Process. This is documented at:

    http://docs.aws.amazon.com/general/latest/gr/signature-version-2.html

    Regions and endpoints are documented at:

    http://docs.aws.amazon.com/general/latest/gr/rande.html

    Default ``product`` is ``ec2``. Valid ``product`` names are:

    .. code-block:: yaml

        - autoscaling (Auto Scaling)
        - cloudformation (CloudFormation)
        - ec2 (Elastic Compute Cloud)
        - elasticache (ElastiCache)
        - elasticbeanstalk (Elastic BeanStalk)
        - elasticloadbalancing (Elastic Load Balancing)
        - elasticmapreduce (Elastic MapReduce)
        - iam (Identity and Access Management)
        - importexport (Import/Export)
        - monitoring (CloudWatch)
        - rds (Relational Database Service)
        - simpledb (SimpleDB)
        - sns (Simple Notification Service)
        - sqs (Simple Queue Service)
    &quot;&quot;&quot;
    if params is None:
        params = {}

    if opts is None:
        opts = {}

    function = opts.get(&quot;function&quot;, (None, product))
    providers = opts.get(&quot;providers&quot;, {})

    if provider is None:
        prov_dict = providers.get(function[1], {}).get(product, {})
        if prov_dict:
            driver = list(list(prov_dict.keys()))[0]
            provider = providers.get(driver, product)
    else:
        prov_dict = providers.get(provider, {}).get(product, {})

    service_url = prov_dict.get(&quot;service_url&quot;, &quot;amazonaws.com&quot;)

    if not location:
        location = get_location(opts, prov_dict)

    if endpoint is None:
        if not requesturl:
            endpoint = prov_dict.get(
                &quot;endpoint&quot;, &quot;{}.{}.{}&quot;.format(product, location, service_url)
            )

            requesturl = &quot;https://{}/&quot;.format(endpoint)
        else:
            endpoint = urllib.parse.urlparse(requesturl).netloc
            if endpoint == &quot;&quot;:
                endpoint_err = (
                    &quot;Could not find a valid endpoint in the &quot;
                    &quot;requesturl: {}. Looking for something &quot;
                    &quot;like https://some.aws.endpoint/?args&quot;.format(requesturl)
                )
                log.error(endpoint_err)
                if return_url is True:
                    return {&quot;error&quot;: endpoint_err}, requesturl
                return {&quot;error&quot;: endpoint_err}

    log.debug(&quot;Using AWS endpoint: %s&quot;, endpoint)
    method = &quot;GET&quot;

    aws_api_version = prov_dict.get(
        &quot;aws_api_version&quot;,
        prov_dict.get(&quot;{}_api_version&quot;.format(product), DEFAULT_AWS_API_VERSION),
    )

    # Fallback to ec2's id &amp; key if none is found, for this component
    if not prov_dict.get(&quot;id&quot;, None):
        prov_dict[&quot;id&quot;] = providers.get(provider, {}).get(&quot;ec2&quot;, {}).get(&quot;id&quot;, {})
        prov_dict[&quot;key&quot;] = providers.get(provider, {}).get(&quot;ec2&quot;, {}).get(&quot;key&quot;, {})

    if sigver == &quot;4&quot;:
        headers, requesturl = sig4(
            method,
            endpoint,
            params,
            prov_dict,
            aws_api_version,
            location,
            product,
            requesturl=requesturl,
        )
        params_with_headers = {}
    else:
        params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
        headers = {}

    attempts = 0
    while attempts &lt; AWS_MAX_RETRIES:
        log.debug(&quot;AWS Request: %s&quot;, requesturl)
        log.trace(&quot;AWS Request Parameters: %s&quot;, params_with_headers)
        try:
            result = requests.get(
                requesturl, headers=headers, params=params_with_headers
            )
            log.debug(&quot;AWS Response Status Code: %s&quot;, result.status_code)
            log.trace(&quot;AWS Response Text: %s&quot;, result.text)
            result.raise_for_status()
            break
        except requests.exceptions.HTTPError as exc:
            root = ET.fromstring(exc.response.content)
            data = xml.to_dict(root)

            # check to see if we should retry the query
            err_code = data.get(&quot;Errors&quot;, {}).get(&quot;Error&quot;, {}).get(&quot;Code&quot;, &quot;&quot;)
            if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
                attempts += 1
                log.error(
                    &quot;AWS Response Status Code and Error: [%s %s] %s; &quot;
                    &quot;Attempts remaining: %s&quot;,
                    exc.response.status_code,
                    exc,
                    data,
                    attempts,
                )
                sleep_exponential_backoff(attempts)
                continue

            log.error(
                &quot;AWS Response Status Code and Error: [%s %s] %s&quot;,
                exc.response.status_code,
                exc,
                data,
            )
            if return_url is True:
                return {&quot;error&quot;: data}, requesturl
            return {&quot;error&quot;: data}
    else:
        log.error(
            &quot;AWS Response Status Code and Error: [%s %s] %s&quot;,
            exc.response.status_code,
            exc,
            data,
        )
        if return_url is True:
            return {&quot;error&quot;: data}, requesturl
        return {&quot;error&quot;: data}

    root = ET.fromstring(result.text)
    items = root[1]
    if return_root is True:
        items = root

    if setname:
        for idx, item in enumerate(root):
            comps = item.tag.split(&quot;}&quot;)
            if comps[1] == setname:
                items = root[idx]

    ret = []
    for item in items:
        ret.append(xml.to_dict(item))

    if return_url is True:
        return ret, requesturl

    return ret


def get_region_from_metadata():
    &quot;&quot;&quot;
    Try to get region from instance identity document and cache it

    .. versionadded:: 2015.5.6
    &quot;&quot;&quot;
    global __Location__

    if __Location__ == &quot;do-not-get-from-metadata&quot;:
        log.debug(
            &quot;Previously failed to get AWS region from metadata. Not trying again.&quot;
        )
        return None

    # Cached region
    if __Location__ != &quot;&quot;:
        return __Location__

    try:
        # Connections to instance meta-data must fail fast and never be proxied
        result = requests.get(
            &quot;http://169.254.169.254/latest/dynamic/instance-identity/document&quot;,
            proxies={&quot;http&quot;: &quot;&quot;},
            timeout=AWS_METADATA_TIMEOUT,
        )
    except requests.exceptions.RequestException:
        log.warning(&quot;Failed to get AWS region from instance metadata.&quot;, exc_info=True)
        # Do not try again
        __Location__ = &quot;do-not-get-from-metadata&quot;
        return None

    try:
        region = result.json()[&quot;region&quot;]
        __Location__ = region
        return __Location__
    except (ValueError, KeyError):
        log.warning(&quot;Failed to decode JSON from instance metadata.&quot;)
        return None

    return None


def get_location(opts=None, provider=None):
    &quot;&quot;&quot;
    Return the region to use, in this order:
        opts['location']
        provider['location']
        get_region_from_metadata()
        DEFAULT_LOCATION
    &quot;&quot;&quot;
    if opts is None:
        opts = {}
    ret = opts.get(&quot;location&quot;)
    if ret is None and provider is not None:
        ret = provider.get(&quot;location&quot;)
    if ret is None:
        ret = get_region_from_metadata()
    if ret is None:
        ret = DEFAULT_LOCATION
    return ret
</PRE>
</div>
  </div>
</body>
</html>
