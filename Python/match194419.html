<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for locale.py &amp; aws.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for locale.py &amp; aws.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>locale.py (1.8720748%)<th>aws.py (1.6021361%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(43-57)<td><a href="#" name="0">(11-23)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>locale.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """Translation methods for generating localized strings.
2 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
3 import codecs
4 import csv
5 import datetime
6 from io import BytesIO
7 import numbers
8 import os
9 import re
10 from salt.ext.tornado import escape
11 from salt.ext.tornado.log import gen_log
12 from salt.ext.tornado.util import PY3
13 from</b></font> salt.ext.tornado._locale_data import LOCALE_NAMES
14 _default_locale = "en_US"
15 _translations = {}  # type: dict
16 _supported_locales = frozenset([_default_locale])
17 _use_gettext = False
18 CONTEXT_SEPARATOR = "\x04"
19 def get(*locale_codes):
20     """Returns the closest match for the given locale codes.
21     We iterate over all given locale codes in order. If we have a tight
22     or a loose match for the code (e.g., "en" for "en_US"), we return
23     the locale. Otherwise we move to the next code in the list.
24     By default we return ``en_US`` if no translations are found for any of
25     the specified locales. You can change the default locale with
26     `set_default_locale()`.
27     """
28     return Locale.get_closest(*locale_codes)
29 def set_default_locale(code):
30     """Sets the default locale.
31     The default locale is assumed to be the language used for all strings
32     in the system. The translations loaded from disk are mappings from
33     the default locale to the destination locale. Consequently, you don't
34     need to create a translation file for the default locale.
35     """
36     global _default_locale
37     global _supported_locales
38     _default_locale = code
39     _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
40 def load_translations(directory, encoding=None):
41     """Loads translations from CSV files in a directory.
42     Translations are strings with optional Python-style named placeholders
43     (e.g., ``My name is %(name)s``) and their associated translations.
44     The directory should have translation files of the form ``LOCALE.csv``,
45     e.g. ``es_GT.csv``. The CSV files should have two or three columns: string,
46     translation, and an optional plural indicator. Plural indicators should
47     be one of "plural" or "singular". A given string can have both singular
48     and plural forms. For example ``%(name)s liked this`` may have a
49     different verb conjugation depending on whether %(name)s is one
50     name or a list of names. There should be two rows in the CSV file for
51     that string, one with plural indicator "singular", and one "plural".
52     For strings with no verbs that would change on translation, simply
53     use "unknown" or the empty string (or don't include the column at all).
54     The file is read using the `csv` module in the default "excel" dialect.
55     In this format there should not be spaces after the commas.
56     If no ``encoding`` parameter is given, the encoding will be
57     detected automatically (among UTF-8 and UTF-16) if the file
58     contains a byte-order marker (BOM), defaulting to UTF-8 if no BOM
59     is present.
60     Example translation ``es_LA.csv``::
61         "I love you","Te amo"
62         "%(name)s liked this","A %(name)s les gustó esto","plural"
63         "%(name)s liked this","A %(name)s le gustó esto","singular"
64     .. versionchanged:: 4.3
65        Added ``encoding`` parameter. Added support for BOM-based encoding
66        detection, UTF-16, and UTF-8-with-BOM.
67     """
68     global _translations
69     global _supported_locales
70     _translations = {}
71     for path in os.listdir(directory):
72         if not path.endswith(".csv"):
73             continue
74         locale, extension = path.split(".")
75         if not re.match("[a-z]+(_[A-Z]+)?$", locale):
76             gen_log.error("Unrecognized locale %r (path: %s)", locale,
77                           os.path.join(directory, path))
78             continue
79         full_path = os.path.join(directory, path)
80         if encoding is None:
81             with open(full_path, 'rb') as f:
82                 data = f.read(len(codecs.BOM_UTF16_LE))
83             if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):
84                 encoding = 'utf-16'
85             else:
86                 encoding = 'utf-8-sig'
87         if PY3:
88             f = open(full_path, "r", encoding=encoding)
89         else:
90             f = BytesIO()
91             with codecs.open(full_path, "r", encoding=encoding) as infile:
92                 f.write(escape.utf8(infile.read()))
93             f.seek(0)
94         _translations[locale] = {}
95         for i, row in enumerate(csv.reader(f)):
96             if not row or len(row) &lt; 2:
97                 continue
98             row = [escape.to_unicode(c).strip() for c in row]
99             english, translation = row[:2]
100             if len(row) &gt; 2:
101                 plural = row[2] or "unknown"
102             else:
103                 plural = "unknown"
104             if plural not in ("plural", "singular", "unknown"):
105                 gen_log.error("Unrecognized plural indicator %r in %s line %d",
106                               plural, path, i + 1)
107                 continue
108             _translations[locale].setdefault(plural, {})[english] = translation
109         f.close()
110     _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
111     gen_log.debug("Supported locales: %s", sorted(_supported_locales))
112 def load_gettext_translations(directory, domain):
113     """Loads translations from `gettext`'s locale tree
114     Locale tree is similar to system's ``/usr/share/locale``, like::
115         {directory}/{lang}/LC_MESSAGES/{domain}.mo
116     Three steps are required to have your app translated:
117     1. Generate POT translation file::
118         xgettext --language=Python --keyword=_:1,2 -d mydomain file1.py file2.html etc
119     2. Merge against existing POT file::
120         msgmerge old.po mydomain.po &gt; new.po
121     3. Compile::
122         msgfmt mydomain.po -o {directory}/pt_BR/LC_MESSAGES/mydomain.mo
123     """
124     import gettext
125     global _translations
126     global _supported_locales
127     global _use_gettext
128     _translations = {}
129     for lang in os.listdir(directory):
130         if lang.startswith('.'):
131             continue  # skip .svn, etc
132         if os.path.isfile(os.path.join(directory, lang)):
133             continue
134         try:
135             os.stat(os.path.join(directory, lang, "LC_MESSAGES", domain + ".mo"))
136             _translations[lang] = gettext.translation(domain, directory,
137                                                       languages=[lang])
138         except Exception as e:
139             gen_log.error("Cannot load translation for '%s': %s", lang, str(e))
140             continue
141     _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
142     _use_gettext = True
143     gen_log.debug("Supported locales: %s", sorted(_supported_locales))
144 def get_supported_locales():
145     return _supported_locales
146 class Locale(object):
147     """Object representing a locale.
148     After calling one of `load_translations` or `load_gettext_translations`,
149     call `get` or `get_closest` to get a Locale object.
150     """
151     @classmethod
152     def get_closest(cls, *locale_codes):
153         for code in locale_codes:
154             if not code:
155                 continue
156             code = code.replace("-", "_")
157             parts = code.split("_")
158             if len(parts) &gt; 2:
159                 continue
160             elif len(parts) == 2:
161                 code = parts[0].lower() + "_" + parts[1].upper()
162             if code in _supported_locales:
163                 return cls.get(code)
164             if parts[0].lower() in _supported_locales:
165                 return cls.get(parts[0].lower())
166         return cls.get(_default_locale)
167     @classmethod
168     def get(cls, code):
169         """Returns the Locale for the given locale code.
170         If it is not supported, we raise an exception.
171         """
172         if not hasattr(cls, "_cache"):
173             cls._cache = {}
174         if code not in cls._cache:
175             assert code in _supported_locales
176             translations = _translations.get(code, None)
177             if translations is None:
178                 locale = CSVLocale(code, {})
179             elif _use_gettext:
180                 locale = GettextLocale(code, translations)
181             else:
182                 locale = CSVLocale(code, translations)
183             cls._cache[code] = locale
184         return cls._cache[code]
185     def __init__(self, code, translations):
186         self.code = code
187         self.name = LOCALE_NAMES.get(code, {}).get("name", u"Unknown")
188         self.rtl = False
189         for prefix in ["fa", "ar", "he"]:
190             if self.code.startswith(prefix):
191                 self.rtl = True
192                 break
193         self.translations = translations
194         _ = self.translate
195         self._months = [
196             _("January"), _("February"), _("March"), _("April"),
197             _("May"), _("June"), _("July"), _("August"),
198             _("September"), _("October"), _("November"), _("December")]
199         self._weekdays = [
200             _("Monday"), _("Tuesday"), _("Wednesday"), _("Thursday"),
201             _("Friday"), _("Saturday"), _("Sunday")]
202     def translate(self, message, plural_message=None, count=None):
203         """Returns the translation for the given message for this locale.
204         If ``plural_message`` is given, you must also provide
205         ``count``. We return ``plural_message`` when ``count != 1``,
206         and we return the singular form for the given message when
207         ``count == 1``.
208         """
209         raise NotImplementedError()
210     def pgettext(self, context, message, plural_message=None, count=None):
211         raise NotImplementedError()
212     def format_date(self, date, gmt_offset=0, relative=True, shorter=False,
213                     full_format=False):
214         """Formats the given date (which should be GMT).
215         By default, we return a relative time (e.g., "2 minutes ago"). You
216         can return an absolute date string with ``relative=False``.
217         You can force a full format date ("July 10, 1980") with
218         ``full_format=True``.
219         This method is primarily intended for dates in the past.
220         For dates in the future, we fall back to full format.
221         """
222         if isinstance(date, numbers.Real):
223             date = datetime.datetime.utcfromtimestamp(date)
224         now = datetime.datetime.utcnow()
225         if date &gt; now:
226             if relative and (date - now).seconds &lt; 60:
227                 date = now
228             else:
229                 full_format = True
230         local_date = date - datetime.timedelta(minutes=gmt_offset)
231         local_now = now - datetime.timedelta(minutes=gmt_offset)
232         local_yesterday = local_now - datetime.timedelta(hours=24)
233         difference = now - date
234         seconds = difference.seconds
235         days = difference.days
236         _ = self.translate
237         format = None
238         if not full_format:
239             if relative and days == 0:
240                 if seconds &lt; 50:
241                     return _("1 second ago", "%(seconds)d seconds ago",
242                              seconds) % {"seconds": seconds}
243                 if seconds &lt; 50 * 60:
244                     minutes = round(seconds / 60.0)
245                     return _("1 minute ago", "%(minutes)d minutes ago",
246                              minutes) % {"minutes": minutes}
247                 hours = round(seconds / (60.0 * 60))
248                 return _("1 hour ago", "%(hours)d hours ago",
249                          hours) % {"hours": hours}
250             if days == 0:
251                 format = _("%(time)s")
252             elif days == 1 and local_date.day == local_yesterday.day and \
253                     relative:
254                 format = _("yesterday") if shorter else \
255                     _("yesterday at %(time)s")
256             elif days &lt; 5:
257                 format = _("%(weekday)s") if shorter else \
258                     _("%(weekday)s at %(time)s")
259             elif days &lt; 334:  # 11mo, since confusing for same month last year
260                 format = _("%(month_name)s %(day)s") if shorter else \
261                     _("%(month_name)s %(day)s at %(time)s")
262         if format is None:
263             format = _("%(month_name)s %(day)s, %(year)s") if shorter else \
264                 _("%(month_name)s %(day)s, %(year)s at %(time)s")
265         tfhour_clock = self.code not in ("en", "en_US", "zh_CN")
266         if tfhour_clock:
267             str_time = "%d:%02d" % (local_date.hour, local_date.minute)
268         elif self.code == "zh_CN":
269             str_time = "%s%d:%02d" % (
270                 (u'\u4e0a\u5348', u'\u4e0b\u5348')[local_date.hour &gt;= 12],
271                 local_date.hour % 12 or 12, local_date.minute)
272         else:
273             str_time = "%d:%02d %s" % (
274                 local_date.hour % 12 or 12, local_date.minute,
275                 ("am", "pm")[local_date.hour &gt;= 12])
276         return format % {
277             "month_name": self._months[local_date.month - 1],
278             "weekday": self._weekdays[local_date.weekday()],
279             "day": str(local_date.day),
280             "year": str(local_date.year),
281             "time": str_time
282         }
283     def format_day(self, date, gmt_offset=0, dow=True):
284         """Formats the given date as a day of week.
285         Example: "Monday, January 22". You can remove the day of week with
286         ``dow=False``.
287         """
288         local_date = date - datetime.timedelta(minutes=gmt_offset)
289         _ = self.translate
290         if dow:
291             return _("%(weekday)s, %(month_name)s %(day)s") % {
292                 "month_name": self._months[local_date.month - 1],
293                 "weekday": self._weekdays[local_date.weekday()],
294                 "day": str(local_date.day),
295             }
296         else:
297             return _("%(month_name)s %(day)s") % {
298                 "month_name": self._months[local_date.month - 1],
299                 "day": str(local_date.day),
300             }
301     def list(self, parts):
302         """Returns a comma-separated list for the given list of parts.
303         The format is, e.g., "A, B and C", "A and B" or just "A" for lists
304         of size 1.
305         """
306         _ = self.translate
307         if len(parts) == 0:
308             return ""
309         if len(parts) == 1:
310             return parts[0]
311         comma = u' \u0648 ' if self.code.startswith("fa") else u", "
312         return _("%(commas)s and %(last)s") % {
313             "commas": comma.join(parts[:-1]),
314             "last": parts[len(parts) - 1],
315         }
316     def friendly_number(self, value):
317         if self.code not in ("en", "en_US"):
318             return str(value)
319         value = str(value)
320         parts = []
321         while value:
322             parts.append(value[-3:])
323             value = value[:-3]
324         return ",".join(reversed(parts))
325 class CSVLocale(Locale):
326     def translate(self, message, plural_message=None, count=None):
327         if plural_message is not None:
328             assert count is not None
329             if count != 1:
330                 message = plural_message
331                 message_dict = self.translations.get("plural", {})
332             else:
333                 message_dict = self.translations.get("singular", {})
334         else:
335             message_dict = self.translations.get("unknown", {})
336         return message_dict.get(message, message)
337     def pgettext(self, context, message, plural_message=None, count=None):
338         if self.translations:
339             gen_log.warning('pgettext is not supported by CSVLocale')
340         return self.translate(message, plural_message, count)
341 class GettextLocale(Locale):
342     def __init__(self, code, translations):
343         try:
344             self.ngettext = translations.ungettext
345             self.gettext = translations.ugettext
346         except AttributeError:
347             self.ngettext = translations.ngettext
348             self.gettext = translations.gettext
349         super(GettextLocale, self).__init__(code, translations)
350     def translate(self, message, plural_message=None, count=None):
351         if plural_message is not None:
352             assert count is not None
353             return self.ngettext(message, plural_message, count)
354         else:
355             return self.gettext(message)
356     def pgettext(self, context, message, plural_message=None, count=None):
357         """Allows to set context for translation, accepts plural forms.
358         Usage example::
359             pgettext("law", "right")
360             pgettext("good", "right")
361         Plural message example::
362             pgettext("organization", "club", "clubs", len(clubs))
363             pgettext("stick", "club", "clubs", len(clubs))
364         To generate POT file with context, add following options to step 1
365         of `load_gettext_translations` sequence::
366             xgettext [basic options] --keyword=pgettext:1c,2 --keyword=pgettext:1c,2,3
367         .. versionadded:: 4.2
368         """
369         if plural_message is not None:
370             assert count is not None
371             msgs_with_ctxt = ("%s%s%s" % (context, CONTEXT_SEPARATOR, message),
372                               "%s%s%s" % (context, CONTEXT_SEPARATOR, plural_message),
373                               count)
374             result = self.ngettext(*msgs_with_ctxt)
375             if CONTEXT_SEPARATOR in result:
376                 result = self.ngettext(message, plural_message, count)
377             return result
378         else:
379             msg_with_ctxt = "%s%s%s" % (context, CONTEXT_SEPARATOR, message)
380             result = self.gettext(msg_with_ctxt)
381             if CONTEXT_SEPARATOR in result:
382                 result = message
383             return result
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Connection library for AWS
3 .. versionadded:: 2015.5.0
4 This is a base library used by a number of AWS services.
5 """
6 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import binascii
7 import hashlib
8 import hmac
9 import logging
10 import random
11 import re
12 import time
13 import urllib.parse
14 import xml.etree.ElementTree as ET
15 from datetime import datetime
16 import salt.config
17 import</b></font> salt.utils.hashutils
18 import salt.utils.xmlutil as xml
19 try:
20     import requests
21     HAS_REQUESTS = True  # pylint: disable=W0612
22 except ImportError:
23     HAS_REQUESTS = False  # pylint: disable=W0612
24 log = logging.getLogger(__name__)
25 DEFAULT_LOCATION = "us-east-1"
26 DEFAULT_AWS_API_VERSION = "2016-11-15"
27 AWS_RETRY_CODES = [
28     "RequestLimitExceeded",
29     "InsufficientInstanceCapacity",
30     "InternalError",
31     "Unavailable",
32     "InsufficientAddressCapacity",
33     "InsufficientReservedInstanceCapacity",
34 ]
35 AWS_METADATA_TIMEOUT = 3.05
36 AWS_MAX_RETRIES = 7
37 IROLE_CODE = "use-instance-role-credentials"
38 __AccessKeyId__ = ""
39 __SecretAccessKey__ = ""
40 __Token__ = ""
41 __Expiration__ = ""
42 __Location__ = ""
43 __AssumeCache__ = {}
44 def sleep_exponential_backoff(attempts):
45     """
46     backoff an exponential amount of time to throttle requests
47     during "API Rate Exceeded" failures as suggested by the AWS documentation here:
48     https://docs.aws.amazon.com/AWSEC2/latest/APIReference/query-api-troubleshooting.html
49     and also here:
50     https://docs.aws.amazon.com/general/latest/gr/api-retries.html
51     Failure to implement this approach results in a failure rate of &gt;30% when using salt-cloud with
52     "--parallel" when creating 50 or more instances with a fixed delay of 2 seconds.
53     A failure rate of &gt;10% is observed when using the salt-api with an asynchronous client
54     specified (runner_async).
55     """
56     time.sleep(random.uniform(1, 2 ** attempts))
57 def creds(provider):
58     """
59     Return the credentials for AWS signing.  This could be just the id and key
60     specified in the provider configuration, or if the id or key is set to the
61     literal string 'use-instance-role-credentials' creds will pull the instance
62     role credentials from the meta data, cache them, and provide them instead.
63     """
64     global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__
65     ret_credentials = ()
66     if provider["id"] == IROLE_CODE or provider["key"] == IROLE_CODE:
67         if __Expiration__ != "":
68             timenow = datetime.utcnow()
69             timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
70             if timestamp &lt; __Expiration__:
71                 return __AccessKeyId__, __SecretAccessKey__, __Token__
72         try:
73             result = requests.get(
74                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
75                 proxies={"http": ""},
76                 timeout=AWS_METADATA_TIMEOUT,
77             )
78             result.raise_for_status()
79             role = result.text
80         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
81             return provider["id"], provider["key"], ""
82         try:
83             result = requests.get(
84                 "http://169.254.169.254/latest/meta-data/iam/security-credentials/{}".format(
85                     role
86                 ),
87                 proxies={"http": ""},
88                 timeout=AWS_METADATA_TIMEOUT,
89             )
90             result.raise_for_status()
91         except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
92             return provider["id"], provider["key"], ""
93         data = result.json()
94         __AccessKeyId__ = data["AccessKeyId"]
95         __SecretAccessKey__ = data["SecretAccessKey"]
96         __Token__ = data["Token"]
97         __Expiration__ = data["Expiration"]
98         ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
99     else:
100         ret_credentials = provider["id"], provider["key"], ""
101     if provider.get("role_arn") is not None:
102         provider_shadow = provider.copy()
103         provider_shadow.pop("role_arn", None)
104         log.info("Assuming the role: %s", provider.get("role_arn"))
105         ret_credentials = assumed_creds(
106             provider_shadow, role_arn=provider.get("role_arn"), location="us-east-1"
107         )
108     return ret_credentials
109 def sig2(method, endpoint, params, provider, aws_api_version):
110     """
111     Sign a query against AWS services using Signature Version 2 Signing
112     Process. This is documented at:
113     http://docs.aws.amazon.com/general/latest/gr/signature-version-2.html
114     """
115     timenow = datetime.utcnow()
116     timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
117     access_key_id, secret_access_key, token = creds(provider)
118     params_with_headers = params.copy()
119     params_with_headers["AWSAccessKeyId"] = access_key_id
120     params_with_headers["SignatureVersion"] = "2"
121     params_with_headers["SignatureMethod"] = "HmacSHA256"
122     params_with_headers["Timestamp"] = "{}".format(timestamp)
123     params_with_headers["Version"] = aws_api_version
124     keys = sorted(params_with_headers.keys())
125     values = list(list(map(params_with_headers.get, keys)))
126     querystring = urllib.parse.urlencode(list(zip(keys, values)))
127     canonical = "{}\n{}\n/\n{}".format(
128         method.encode("utf-8"),
129         endpoint.encode("utf-8"),
130         querystring.encode("utf-8"),
131     )
132     hashed = hmac.new(secret_access_key, canonical, hashlib.sha256)
133     sig = binascii.b2a_base64(hashed.digest())
134     params_with_headers["Signature"] = sig.strip()
135     if token != "":
136         params_with_headers["SecurityToken"] = token
137     return params_with_headers
138 def assumed_creds(prov_dict, role_arn, location=None):
139     valid_session_name_re = re.compile("[^a-z0-9A-Z+=,.@-]")
140     now = time.mktime(datetime.utcnow().timetuple())
141     for key, creds in __AssumeCache__.items():
142         if (creds["Expiration"] - now) &lt;= 120:
143             __AssumeCache__.delete(key)
144     if role_arn in __AssumeCache__:
145         c = __AssumeCache__[role_arn]
146         return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]
147     version = "2011-06-15"
148     session_name = valid_session_name_re.sub(
149         "", salt.config.get_id({"root_dir": None})[0]
150     )[0:63]
151     headers, requesturl = sig4(
152         "GET",
153         "sts.amazonaws.com",
154         params={
155             "Version": version,
156             "Action": "AssumeRole",
157             "RoleSessionName": session_name,
158             "RoleArn": role_arn,
159             "Policy": (
160                 '{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1",'
161                 ' "Effect":"Allow","Action":"*","Resource":"*"}]}'
162             ),
163             "DurationSeconds": "3600",
164         },
165         aws_api_version=version,
166         data="",
167         uri="/",
168         prov_dict=prov_dict,
169         product="sts",
170         location=location,
171         requesturl="https://sts.amazonaws.com/",
172     )
173     headers["Accept"] = "application/json"
174     result = requests.request("GET", requesturl, headers=headers, data="", verify=True)
175     if result.status_code &gt;= 400:
176         log.info("AssumeRole response: %s", result.content)
177     result.raise_for_status()
178     resp = result.json()
179     data = resp["AssumeRoleResponse"]["AssumeRoleResult"]["Credentials"]
180     __AssumeCache__[role_arn] = data
181     return data["AccessKeyId"], data["SecretAccessKey"], data["SessionToken"]
182 def sig4(
183     method,
184     endpoint,
185     params,
186     prov_dict,
187     aws_api_version=DEFAULT_AWS_API_VERSION,
188     location=None,
189     product="ec2",
190     uri="/",
191     requesturl=None,
192     data="",
193     headers=None,
194     role_arn=None,
195     payload_hash=None,
196 ):
197     """
198     Sign a query against AWS services using Signature Version 4 Signing
199     Process. This is documented at:
200     http://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
201     http://docs.aws.amazon.com/general/latest/gr/sigv4-signed-request-examples.html
202     http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
203     """
204     timenow = datetime.utcnow()
205     if role_arn is None:
206         access_key_id, secret_access_key, token = creds(prov_dict)
207     else:
208         access_key_id, secret_access_key, token = assumed_creds(
209             prov_dict, role_arn, location=location
210         )
211     if location is None:
212         location = get_region_from_metadata()
213     if location is None:
214         location = DEFAULT_LOCATION
215     params_with_headers = params.copy()
216     if product not in ("s3", "ssm"):
217         params_with_headers["Version"] = aws_api_version
218     keys = sorted(params_with_headers.keys())
219     values = list(map(params_with_headers.get, keys))
220     querystring = urllib.parse.urlencode(list(zip(keys, values))).replace("+", "%20")
221     amzdate = timenow.strftime("%Y%m%dT%H%M%SZ")
222     datestamp = timenow.strftime("%Y%m%d")
223     new_headers = {}
224     if isinstance(headers, dict):
225         new_headers = headers.copy()
226     if not payload_hash:
227         payload_hash = salt.utils.hashutils.sha256_digest(data)
228     new_headers["X-Amz-date"] = amzdate
229     new_headers["host"] = endpoint
230     new_headers["x-amz-content-sha256"] = payload_hash
231     a_canonical_headers = []
232     a_signed_headers = []
233     if token != "":
234         new_headers["X-Amz-security-token"] = token
235     for header in sorted(new_headers.keys(), key=str.lower):
236         lower_header = header.lower()
237         a_canonical_headers.append(
238             "{}:{}".format(lower_header, new_headers[header].strip())
239         )
240         a_signed_headers.append(lower_header)
241     canonical_headers = "\n".join(a_canonical_headers) + "\n"
242     signed_headers = ";".join(a_signed_headers)
243     algorithm = "AWS4-HMAC-SHA256"
244     canonical_request = "\n".join(
245         (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
246     )
247     credential_scope = "/".join((datestamp, location, product, "aws4_request"))
248     string_to_sign = "\n".join(
249         (
250             algorithm,
251             amzdate,
252             credential_scope,
253             salt.utils.hashutils.sha256_digest(canonical_request),
254         )
255     )
256     signing_key = _sig_key(secret_access_key, datestamp, location, product)
257     signature = hmac.new(
258         signing_key, string_to_sign.encode("utf-8"), hashlib.sha256
259     ).hexdigest()
260     authorization_header = "{} Credential={}/{}, SignedHeaders={}, Signature={}".format(
261         algorithm,
262         access_key_id,
263         credential_scope,
264         signed_headers,
265         signature,
266     )
267     new_headers["Authorization"] = authorization_header
268     requesturl = "{}?{}".format(requesturl, querystring)
269     return new_headers, requesturl
270 def _sign(key, msg):
271     """
272     Key derivation functions. See:
273     http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-python
274     """
275     return hmac.new(key, msg.encode("utf-8"), hashlib.sha256).digest()
276 def _sig_key(key, date_stamp, regionName, serviceName):
277     """
278     Get a signature key. See:
279     http://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html#signature-v4-examples-python
280     """
281     kDate = _sign(("AWS4" + key).encode("utf-8"), date_stamp)
282     if regionName:
283         kRegion = _sign(kDate, regionName)
284         kService = _sign(kRegion, serviceName)
285     else:
286         kService = _sign(kDate, serviceName)
287     kSigning = _sign(kService, "aws4_request")
288     return kSigning
289 def query(
290     params=None,
291     setname=None,
292     requesturl=None,
293     location=None,
294     return_url=False,
295     return_root=False,
296     opts=None,
297     provider=None,
298     endpoint=None,
299     product="ec2",
300     sigver="2",
301 ):
302     """
303     Perform a query against AWS services using Signature Version 2 Signing
304     Process. This is documented at:
305     http://docs.aws.amazon.com/general/latest/gr/signature-version-2.html
306     Regions and endpoints are documented at:
307     http://docs.aws.amazon.com/general/latest/gr/rande.html
308     Default ``product`` is ``ec2``. Valid ``product`` names are:
309     .. code-block:: yaml
310         - autoscaling (Auto Scaling)
311         - cloudformation (CloudFormation)
312         - ec2 (Elastic Compute Cloud)
313         - elasticache (ElastiCache)
314         - elasticbeanstalk (Elastic BeanStalk)
315         - elasticloadbalancing (Elastic Load Balancing)
316         - elasticmapreduce (Elastic MapReduce)
317         - iam (Identity and Access Management)
318         - importexport (Import/Export)
319         - monitoring (CloudWatch)
320         - rds (Relational Database Service)
321         - simpledb (SimpleDB)
322         - sns (Simple Notification Service)
323         - sqs (Simple Queue Service)
324     """
325     if params is None:
326         params = {}
327     if opts is None:
328         opts = {}
329     function = opts.get("function", (None, product))
330     providers = opts.get("providers", {})
331     if provider is None:
332         prov_dict = providers.get(function[1], {}).get(product, {})
333         if prov_dict:
334             driver = list(list(prov_dict.keys()))[0]
335             provider = providers.get(driver, product)
336     else:
337         prov_dict = providers.get(provider, {}).get(product, {})
338     service_url = prov_dict.get("service_url", "amazonaws.com")
339     if not location:
340         location = get_location(opts, prov_dict)
341     if endpoint is None:
342         if not requesturl:
343             endpoint = prov_dict.get(
344                 "endpoint", "{}.{}.{}".format(product, location, service_url)
345             )
346             requesturl = "https://{}/".format(endpoint)
347         else:
348             endpoint = urllib.parse.urlparse(requesturl).netloc
349             if endpoint == "":
350                 endpoint_err = (
351                     "Could not find a valid endpoint in the "
352                     "requesturl: {}. Looking for something "
353                     "like https://some.aws.endpoint/?args".format(requesturl)
354                 )
355                 log.error(endpoint_err)
356                 if return_url is True:
357                     return {"error": endpoint_err}, requesturl
358                 return {"error": endpoint_err}
359     log.debug("Using AWS endpoint: %s", endpoint)
360     method = "GET"
361     aws_api_version = prov_dict.get(
362         "aws_api_version",
363         prov_dict.get("{}_api_version".format(product), DEFAULT_AWS_API_VERSION),
364     )
365     if not prov_dict.get("id", None):
366         prov_dict["id"] = providers.get(provider, {}).get("ec2", {}).get("id", {})
367         prov_dict["key"] = providers.get(provider, {}).get("ec2", {}).get("key", {})
368     if sigver == "4":
369         headers, requesturl = sig4(
370             method,
371             endpoint,
372             params,
373             prov_dict,
374             aws_api_version,
375             location,
376             product,
377             requesturl=requesturl,
378         )
379         params_with_headers = {}
380     else:
381         params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
382         headers = {}
383     attempts = 0
384     while attempts &lt; AWS_MAX_RETRIES:
385         log.debug("AWS Request: %s", requesturl)
386         log.trace("AWS Request Parameters: %s", params_with_headers)
387         try:
388             result = requests.get(
389                 requesturl, headers=headers, params=params_with_headers
390             )
391             log.debug("AWS Response Status Code: %s", result.status_code)
392             log.trace("AWS Response Text: %s", result.text)
393             result.raise_for_status()
394             break
395         except requests.exceptions.HTTPError as exc:
396             root = ET.fromstring(exc.response.content)
397             data = xml.to_dict(root)
398             err_code = data.get("Errors", {}).get("Error", {}).get("Code", "")
399             if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
400                 attempts += 1
401                 log.error(
402                     "AWS Response Status Code and Error: [%s %s] %s; "
403                     "Attempts remaining: %s",
404                     exc.response.status_code,
405                     exc,
406                     data,
407                     attempts,
408                 )
409                 sleep_exponential_backoff(attempts)
410                 continue
411             log.error(
412                 "AWS Response Status Code and Error: [%s %s] %s",
413                 exc.response.status_code,
414                 exc,
415                 data,
416             )
417             if return_url is True:
418                 return {"error": data}, requesturl
419             return {"error": data}
420     else:
421         log.error(
422             "AWS Response Status Code and Error: [%s %s] %s",
423             exc.response.status_code,
424             exc,
425             data,
426         )
427         if return_url is True:
428             return {"error": data}, requesturl
429         return {"error": data}
430     root = ET.fromstring(result.text)
431     items = root[1]
432     if return_root is True:
433         items = root
434     if setname:
435         for idx, item in enumerate(root):
436             comps = item.tag.split("}")
437             if comps[1] == setname:
438                 items = root[idx]
439     ret = []
440     for item in items:
441         ret.append(xml.to_dict(item))
442     if return_url is True:
443         return ret, requesturl
444     return ret
445 def get_region_from_metadata():
446     """
447     Try to get region from instance identity document and cache it
448     .. versionadded:: 2015.5.6
449     """
450     global __Location__
451     if __Location__ == "do-not-get-from-metadata":
452         log.debug(
453             "Previously failed to get AWS region from metadata. Not trying again."
454         )
455         return None
456     if __Location__ != "":
457         return __Location__
458     try:
459         result = requests.get(
460             "http://169.254.169.254/latest/dynamic/instance-identity/document",
461             proxies={"http": ""},
462             timeout=AWS_METADATA_TIMEOUT,
463         )
464     except requests.exceptions.RequestException:
465         log.warning("Failed to get AWS region from instance metadata.", exc_info=True)
466         __Location__ = "do-not-get-from-metadata"
467         return None
468     try:
469         region = result.json()["region"]
470         __Location__ = region
471         return __Location__
472     except (ValueError, KeyError):
473         log.warning("Failed to decode JSON from instance metadata.")
474         return None
475     return None
476 def get_location(opts=None, provider=None):
477     """
478     Return the region to use, in this order:
479         opts['location']
480         provider['location']
481         get_region_from_metadata()
482         DEFAULT_LOCATION
483     """
484     if opts is None:
485         opts = {}
486     ret = opts.get("location")
487     if ret is None and provider is not None:
488         ret = provider.get("location")
489     if ret is None:
490         ret = get_region_from_metadata()
491     if ret is None:
492         ret = DEFAULT_LOCATION
493     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
