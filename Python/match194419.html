<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for locale.py &amp; aws.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for locale.py &amp; aws.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>locale.py (1.8720748%)<th>aws.py (1.6021361%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(43-57)<td><a href="#" name="0">(11-23)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>locale.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
import codecs
import csv
import datetime
from io import BytesIO
import numbers
import os
import re
from salt.ext.tornado import escape
from salt.ext.tornado.log import gen_log
from salt.ext.tornado.util import PY3
from</b></font> salt.ext.tornado._locale_data import LOCALE_NAMES
_default_locale = "en_US"
_translations = {}  # type: dict
_supported_locales = frozenset([_default_locale])
_use_gettext = False
CONTEXT_SEPARATOR = "\x04"
def get(*locale_codes):
    return Locale.get_closest(*locale_codes)
def set_default_locale(code):
    global _default_locale
    global _supported_locales
    _default_locale = code
    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
def load_translations(directory, encoding=None):
    global _translations
    global _supported_locales
    _translations = {}
    for path in os.listdir(directory):
        if not path.endswith(".csv"):
            continue
        locale, extension = path.split(".")
        if not re.match("[a-z]+(_[A-Z]+)?$", locale):
            gen_log.error("Unrecognized locale %r (path: %s)", locale,
                          os.path.join(directory, path))
            continue
        full_path = os.path.join(directory, path)
        if encoding is None:
            with open(full_path, 'rb') as f:
                data = f.read(len(codecs.BOM_UTF16_LE))
            if data in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):
                encoding = 'utf-16'
            else:
                encoding = 'utf-8-sig'
        if PY3:
            f = open(full_path, "r", encoding=encoding)
        else:
            f = BytesIO()
            with codecs.open(full_path, "r", encoding=encoding) as infile:
                f.write(escape.utf8(infile.read()))
            f.seek(0)
        _translations[locale] = {}
        for i, row in enumerate(csv.reader(f)):
            if not row or len(row) &lt; 2:
                continue
            row = [escape.to_unicode(c).strip() for c in row]
            english, translation = row[:2]
            if len(row) &gt; 2:
                plural = row[2] or "unknown"
            else:
                plural = "unknown"
            if plural not in ("plural", "singular", "unknown"):
                gen_log.error("Unrecognized plural indicator %r in %s line %d",
                              plural, path, i + 1)
                continue
            _translations[locale].setdefault(plural, {})[english] = translation
        f.close()
    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
    gen_log.debug("Supported locales: %s", sorted(_supported_locales))
def load_gettext_translations(directory, domain):
    import gettext
    global _translations
    global _supported_locales
    global _use_gettext
    _translations = {}
    for lang in os.listdir(directory):
        if lang.startswith('.'):
            continue  # skip .svn, etc
        if os.path.isfile(os.path.join(directory, lang)):
            continue
        try:
            os.stat(os.path.join(directory, lang, "LC_MESSAGES", domain + ".mo"))
            _translations[lang] = gettext.translation(domain, directory,
                                                      languages=[lang])
        except Exception as e:
            gen_log.error("Cannot load translation for '%s': %s", lang, str(e))
            continue
    _supported_locales = frozenset(list(_translations.keys()) + [_default_locale])
    _use_gettext = True
    gen_log.debug("Supported locales: %s", sorted(_supported_locales))
def get_supported_locales():
    return _supported_locales
class Locale(object):
    @classmethod
    def get_closest(cls, *locale_codes):
        for code in locale_codes:
            if not code:
                continue
            code = code.replace("-", "_")
            parts = code.split("_")
            if len(parts) &gt; 2:
                continue
            elif len(parts) == 2:
                code = parts[0].lower() + "_" + parts[1].upper()
            if code in _supported_locales:
                return cls.get(code)
            if parts[0].lower() in _supported_locales:
                return cls.get(parts[0].lower())
        return cls.get(_default_locale)
    @classmethod
    def get(cls, code):
        if not hasattr(cls, "_cache"):
            cls._cache = {}
        if code not in cls._cache:
            assert code in _supported_locales
            translations = _translations.get(code, None)
            if translations is None:
                locale = CSVLocale(code, {})
            elif _use_gettext:
                locale = GettextLocale(code, translations)
            else:
                locale = CSVLocale(code, translations)
            cls._cache[code] = locale
        return cls._cache[code]
    def __init__(self, code, translations):
        self.code = code
        self.name = LOCALE_NAMES.get(code, {}).get("name", u"Unknown")
        self.rtl = False
        for prefix in ["fa", "ar", "he"]:
            if self.code.startswith(prefix):
                self.rtl = True
                break
        self.translations = translations
        _ = self.translate
        self._months = [
            _("January"), _("February"), _("March"), _("April"),
            _("May"), _("June"), _("July"), _("August"),
            _("September"), _("October"), _("November"), _("December")]
        self._weekdays = [
            _("Monday"), _("Tuesday"), _("Wednesday"), _("Thursday"),
            _("Friday"), _("Saturday"), _("Sunday")]
    def translate(self, message, plural_message=None, count=None):
        raise NotImplementedError()
    def pgettext(self, context, message, plural_message=None, count=None):
        raise NotImplementedError()
    def format_date(self, date, gmt_offset=0, relative=True, shorter=False,
                    full_format=False):
        if isinstance(date, numbers.Real):
            date = datetime.datetime.utcfromtimestamp(date)
        now = datetime.datetime.utcnow()
        if date &gt; now:
            if relative and (date - now).seconds &lt; 60:
                date = now
            else:
                full_format = True
        local_date = date - datetime.timedelta(minutes=gmt_offset)
        local_now = now - datetime.timedelta(minutes=gmt_offset)
        local_yesterday = local_now - datetime.timedelta(hours=24)
        difference = now - date
        seconds = difference.seconds
        days = difference.days
        _ = self.translate
        format = None
        if not full_format:
            if relative and days == 0:
                if seconds &lt; 50:
                    return _("1 second ago", "%(seconds)d seconds ago",
                             seconds) % {"seconds": seconds}
                if seconds &lt; 50 * 60:
                    minutes = round(seconds / 60.0)
                    return _("1 minute ago", "%(minutes)d minutes ago",
                             minutes) % {"minutes": minutes}
                hours = round(seconds / (60.0 * 60))
                return _("1 hour ago", "%(hours)d hours ago",
                         hours) % {"hours": hours}
            if days == 0:
                format = _("%(time)s")
            elif days == 1 and local_date.day == local_yesterday.day and \
                    relative:
                format = _("yesterday") if shorter else \
                    _("yesterday at %(time)s")
            elif days &lt; 5:
                format = _("%(weekday)s") if shorter else \
                    _("%(weekday)s at %(time)s")
            elif days &lt; 334:  # 11mo, since confusing for same month last year
                format = _("%(month_name)s %(day)s") if shorter else \
                    _("%(month_name)s %(day)s at %(time)s")
        if format is None:
            format = _("%(month_name)s %(day)s, %(year)s") if shorter else \
                _("%(month_name)s %(day)s, %(year)s at %(time)s")
        tfhour_clock = self.code not in ("en", "en_US", "zh_CN")
        if tfhour_clock:
            str_time = "%d:%02d" % (local_date.hour, local_date.minute)
        elif self.code == "zh_CN":
            str_time = "%s%d:%02d" % (
                (u'\u4e0a\u5348', u'\u4e0b\u5348')[local_date.hour &gt;= 12],
                local_date.hour % 12 or 12, local_date.minute)
        else:
            str_time = "%d:%02d %s" % (
                local_date.hour % 12 or 12, local_date.minute,
                ("am", "pm")[local_date.hour &gt;= 12])
        return format % {
            "month_name": self._months[local_date.month - 1],
            "weekday": self._weekdays[local_date.weekday()],
            "day": str(local_date.day),
            "year": str(local_date.year),
            "time": str_time
        }
    def format_day(self, date, gmt_offset=0, dow=True):
        local_date = date - datetime.timedelta(minutes=gmt_offset)
        _ = self.translate
        if dow:
            return _("%(weekday)s, %(month_name)s %(day)s") % {
                "month_name": self._months[local_date.month - 1],
                "weekday": self._weekdays[local_date.weekday()],
                "day": str(local_date.day),
            }
        else:
            return _("%(month_name)s %(day)s") % {
                "month_name": self._months[local_date.month - 1],
                "day": str(local_date.day),
            }
    def list(self, parts):
        _ = self.translate
        if len(parts) == 0:
            return ""
        if len(parts) == 1:
            return parts[0]
        comma = u' \u0648 ' if self.code.startswith("fa") else u", "
        return _("%(commas)s and %(last)s") % {
            "commas": comma.join(parts[:-1]),
            "last": parts[len(parts) - 1],
        }
    def friendly_number(self, value):
        if self.code not in ("en", "en_US"):
            return str(value)
        value = str(value)
        parts = []
        while value:
            parts.append(value[-3:])
            value = value[:-3]
        return ",".join(reversed(parts))
class CSVLocale(Locale):
    def translate(self, message, plural_message=None, count=None):
        if plural_message is not None:
            assert count is not None
            if count != 1:
                message = plural_message
                message_dict = self.translations.get("plural", {})
            else:
                message_dict = self.translations.get("singular", {})
        else:
            message_dict = self.translations.get("unknown", {})
        return message_dict.get(message, message)
    def pgettext(self, context, message, plural_message=None, count=None):
        if self.translations:
            gen_log.warning('pgettext is not supported by CSVLocale')
        return self.translate(message, plural_message, count)
class GettextLocale(Locale):
    def __init__(self, code, translations):
        try:
            self.ngettext = translations.ungettext
            self.gettext = translations.ugettext
        except AttributeError:
            self.ngettext = translations.ngettext
            self.gettext = translations.gettext
        super(GettextLocale, self).__init__(code, translations)
    def translate(self, message, plural_message=None, count=None):
        if plural_message is not None:
            assert count is not None
            return self.ngettext(message, plural_message, count)
        else:
            return self.gettext(message)
    def pgettext(self, context, message, plural_message=None, count=None):
        if plural_message is not None:
            assert count is not None
            msgs_with_ctxt = ("%s%s%s" % (context, CONTEXT_SEPARATOR, message),
                              "%s%s%s" % (context, CONTEXT_SEPARATOR, plural_message),
                              count)
            result = self.ngettext(*msgs_with_ctxt)
            if CONTEXT_SEPARATOR in result:
                result = self.ngettext(message, plural_message, count)
            return result
        else:
            msg_with_ctxt = "%s%s%s" % (context, CONTEXT_SEPARATOR, message)
            result = self.gettext(msg_with_ctxt)
            if CONTEXT_SEPARATOR in result:
                result = message
            return result
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>aws.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import binascii
import hashlib
import hmac
import logging
import random
import re
import time
import urllib.parse
import xml.etree.ElementTree as ET
from datetime import datetime
import salt.config
import</b></font> salt.utils.hashutils
import salt.utils.xmlutil as xml
try:
    import requests
    HAS_REQUESTS = True  # pylint: disable=W0612
except ImportError:
    HAS_REQUESTS = False  # pylint: disable=W0612
log = logging.getLogger(__name__)
DEFAULT_LOCATION = "us-east-1"
DEFAULT_AWS_API_VERSION = "2016-11-15"
AWS_RETRY_CODES = [
    "RequestLimitExceeded",
    "InsufficientInstanceCapacity",
    "InternalError",
    "Unavailable",
    "InsufficientAddressCapacity",
    "InsufficientReservedInstanceCapacity",
]
AWS_METADATA_TIMEOUT = 3.05
AWS_MAX_RETRIES = 7
IROLE_CODE = "use-instance-role-credentials"
__AccessKeyId__ = ""
__SecretAccessKey__ = ""
__Token__ = ""
__Expiration__ = ""
__Location__ = ""
__AssumeCache__ = {}
def sleep_exponential_backoff(attempts):
    time.sleep(random.uniform(1, 2 ** attempts))
def creds(provider):
    global __AccessKeyId__, __SecretAccessKey__, __Token__, __Expiration__
    ret_credentials = ()
    if provider["id"] == IROLE_CODE or provider["key"] == IROLE_CODE:
        if __Expiration__ != "":
            timenow = datetime.utcnow()
            timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
            if timestamp &lt; __Expiration__:
                return __AccessKeyId__, __SecretAccessKey__, __Token__
        try:
            result = requests.get(
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
                proxies={"http": ""},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
            role = result.text
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider["id"], provider["key"], ""
        try:
            result = requests.get(
                "http://169.254.169.254/latest/meta-data/iam/security-credentials/{}".format(
                    role
                ),
                proxies={"http": ""},
                timeout=AWS_METADATA_TIMEOUT,
            )
            result.raise_for_status()
        except (requests.exceptions.HTTPError, requests.exceptions.ConnectionError):
            return provider["id"], provider["key"], ""
        data = result.json()
        __AccessKeyId__ = data["AccessKeyId"]
        __SecretAccessKey__ = data["SecretAccessKey"]
        __Token__ = data["Token"]
        __Expiration__ = data["Expiration"]
        ret_credentials = __AccessKeyId__, __SecretAccessKey__, __Token__
    else:
        ret_credentials = provider["id"], provider["key"], ""
    if provider.get("role_arn") is not None:
        provider_shadow = provider.copy()
        provider_shadow.pop("role_arn", None)
        log.info("Assuming the role: %s", provider.get("role_arn"))
        ret_credentials = assumed_creds(
            provider_shadow, role_arn=provider.get("role_arn"), location="us-east-1"
        )
    return ret_credentials
def sig2(method, endpoint, params, provider, aws_api_version):
    timenow = datetime.utcnow()
    timestamp = timenow.strftime("%Y-%m-%dT%H:%M:%SZ")
    access_key_id, secret_access_key, token = creds(provider)
    params_with_headers = params.copy()
    params_with_headers["AWSAccessKeyId"] = access_key_id
    params_with_headers["SignatureVersion"] = "2"
    params_with_headers["SignatureMethod"] = "HmacSHA256"
    params_with_headers["Timestamp"] = "{}".format(timestamp)
    params_with_headers["Version"] = aws_api_version
    keys = sorted(params_with_headers.keys())
    values = list(list(map(params_with_headers.get, keys)))
    querystring = urllib.parse.urlencode(list(zip(keys, values)))
    canonical = "{}\n{}\n/\n{}".format(
        method.encode("utf-8"),
        endpoint.encode("utf-8"),
        querystring.encode("utf-8"),
    )
    hashed = hmac.new(secret_access_key, canonical, hashlib.sha256)
    sig = binascii.b2a_base64(hashed.digest())
    params_with_headers["Signature"] = sig.strip()
    if token != "":
        params_with_headers["SecurityToken"] = token
    return params_with_headers
def assumed_creds(prov_dict, role_arn, location=None):
    valid_session_name_re = re.compile("[^a-z0-9A-Z+=,.@-]")
    now = time.mktime(datetime.utcnow().timetuple())
    for key, creds in __AssumeCache__.items():
        if (creds["Expiration"] - now) &lt;= 120:
            __AssumeCache__.delete(key)
    if role_arn in __AssumeCache__:
        c = __AssumeCache__[role_arn]
        return c["AccessKeyId"], c["SecretAccessKey"], c["SessionToken"]
    version = "2011-06-15"
    session_name = valid_session_name_re.sub(
        "", salt.config.get_id({"root_dir": None})[0]
    )[0:63]
    headers, requesturl = sig4(
        "GET",
        "sts.amazonaws.com",
        params={
            "Version": version,
            "Action": "AssumeRole",
            "RoleSessionName": session_name,
            "RoleArn": role_arn,
            "Policy": (
                '{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1",'
                ' "Effect":"Allow","Action":"*","Resource":"*"}]}'
            ),
            "DurationSeconds": "3600",
        },
        aws_api_version=version,
        data="",
        uri="/",
        prov_dict=prov_dict,
        product="sts",
        location=location,
        requesturl="https://sts.amazonaws.com/",
    )
    headers["Accept"] = "application/json"
    result = requests.request("GET", requesturl, headers=headers, data="", verify=True)
    if result.status_code &gt;= 400:
        log.info("AssumeRole response: %s", result.content)
    result.raise_for_status()
    resp = result.json()
    data = resp["AssumeRoleResponse"]["AssumeRoleResult"]["Credentials"]
    __AssumeCache__[role_arn] = data
    return data["AccessKeyId"], data["SecretAccessKey"], data["SessionToken"]
def sig4(
    method,
    endpoint,
    params,
    prov_dict,
    aws_api_version=DEFAULT_AWS_API_VERSION,
    location=None,
    product="ec2",
    uri="/",
    requesturl=None,
    data="",
    headers=None,
    role_arn=None,
    payload_hash=None,
):
    timenow = datetime.utcnow()
    if role_arn is None:
        access_key_id, secret_access_key, token = creds(prov_dict)
    else:
        access_key_id, secret_access_key, token = assumed_creds(
            prov_dict, role_arn, location=location
        )
    if location is None:
        location = get_region_from_metadata()
    if location is None:
        location = DEFAULT_LOCATION
    params_with_headers = params.copy()
    if product not in ("s3", "ssm"):
        params_with_headers["Version"] = aws_api_version
    keys = sorted(params_with_headers.keys())
    values = list(map(params_with_headers.get, keys))
    querystring = urllib.parse.urlencode(list(zip(keys, values))).replace("+", "%20")
    amzdate = timenow.strftime("%Y%m%dT%H%M%SZ")
    datestamp = timenow.strftime("%Y%m%d")
    new_headers = {}
    if isinstance(headers, dict):
        new_headers = headers.copy()
    if not payload_hash:
        payload_hash = salt.utils.hashutils.sha256_digest(data)
    new_headers["X-Amz-date"] = amzdate
    new_headers["host"] = endpoint
    new_headers["x-amz-content-sha256"] = payload_hash
    a_canonical_headers = []
    a_signed_headers = []
    if token != "":
        new_headers["X-Amz-security-token"] = token
    for header in sorted(new_headers.keys(), key=str.lower):
        lower_header = header.lower()
        a_canonical_headers.append(
            "{}:{}".format(lower_header, new_headers[header].strip())
        )
        a_signed_headers.append(lower_header)
    canonical_headers = "\n".join(a_canonical_headers) + "\n"
    signed_headers = ";".join(a_signed_headers)
    algorithm = "AWS4-HMAC-SHA256"
    canonical_request = "\n".join(
        (method, uri, querystring, canonical_headers, signed_headers, payload_hash)
    )
    credential_scope = "/".join((datestamp, location, product, "aws4_request"))
    string_to_sign = "\n".join(
        (
            algorithm,
            amzdate,
            credential_scope,
            salt.utils.hashutils.sha256_digest(canonical_request),
        )
    )
    signing_key = _sig_key(secret_access_key, datestamp, location, product)
    signature = hmac.new(
        signing_key, string_to_sign.encode("utf-8"), hashlib.sha256
    ).hexdigest()
    authorization_header = "{} Credential={}/{}, SignedHeaders={}, Signature={}".format(
        algorithm,
        access_key_id,
        credential_scope,
        signed_headers,
        signature,
    )
    new_headers["Authorization"] = authorization_header
    requesturl = "{}?{}".format(requesturl, querystring)
    return new_headers, requesturl
def _sign(key, msg):
    return hmac.new(key, msg.encode("utf-8"), hashlib.sha256).digest()
def _sig_key(key, date_stamp, regionName, serviceName):
    kDate = _sign(("AWS4" + key).encode("utf-8"), date_stamp)
    if regionName:
        kRegion = _sign(kDate, regionName)
        kService = _sign(kRegion, serviceName)
    else:
        kService = _sign(kDate, serviceName)
    kSigning = _sign(kService, "aws4_request")
    return kSigning
def query(
    params=None,
    setname=None,
    requesturl=None,
    location=None,
    return_url=False,
    return_root=False,
    opts=None,
    provider=None,
    endpoint=None,
    product="ec2",
    sigver="2",
):
    if params is None:
        params = {}
    if opts is None:
        opts = {}
    function = opts.get("function", (None, product))
    providers = opts.get("providers", {})
    if provider is None:
        prov_dict = providers.get(function[1], {}).get(product, {})
        if prov_dict:
            driver = list(list(prov_dict.keys()))[0]
            provider = providers.get(driver, product)
    else:
        prov_dict = providers.get(provider, {}).get(product, {})
    service_url = prov_dict.get("service_url", "amazonaws.com")
    if not location:
        location = get_location(opts, prov_dict)
    if endpoint is None:
        if not requesturl:
            endpoint = prov_dict.get(
                "endpoint", "{}.{}.{}".format(product, location, service_url)
            )
            requesturl = "https://{}/".format(endpoint)
        else:
            endpoint = urllib.parse.urlparse(requesturl).netloc
            if endpoint == "":
                endpoint_err = (
                    "Could not find a valid endpoint in the "
                    "requesturl: {}. Looking for something "
                    "like https://some.aws.endpoint/?args".format(requesturl)
                )
                log.error(endpoint_err)
                if return_url is True:
                    return {"error": endpoint_err}, requesturl
                return {"error": endpoint_err}
    log.debug("Using AWS endpoint: %s", endpoint)
    method = "GET"
    aws_api_version = prov_dict.get(
        "aws_api_version",
        prov_dict.get("{}_api_version".format(product), DEFAULT_AWS_API_VERSION),
    )
    if not prov_dict.get("id", None):
        prov_dict["id"] = providers.get(provider, {}).get("ec2", {}).get("id", {})
        prov_dict["key"] = providers.get(provider, {}).get("ec2", {}).get("key", {})
    if sigver == "4":
        headers, requesturl = sig4(
            method,
            endpoint,
            params,
            prov_dict,
            aws_api_version,
            location,
            product,
            requesturl=requesturl,
        )
        params_with_headers = {}
    else:
        params_with_headers = sig2(method, endpoint, params, prov_dict, aws_api_version)
        headers = {}
    attempts = 0
    while attempts &lt; AWS_MAX_RETRIES:
        log.debug("AWS Request: %s", requesturl)
        log.trace("AWS Request Parameters: %s", params_with_headers)
        try:
            result = requests.get(
                requesturl, headers=headers, params=params_with_headers
            )
            log.debug("AWS Response Status Code: %s", result.status_code)
            log.trace("AWS Response Text: %s", result.text)
            result.raise_for_status()
            break
        except requests.exceptions.HTTPError as exc:
            root = ET.fromstring(exc.response.content)
            data = xml.to_dict(root)
            err_code = data.get("Errors", {}).get("Error", {}).get("Code", "")
            if attempts &lt; AWS_MAX_RETRIES and err_code and err_code in AWS_RETRY_CODES:
                attempts += 1
                log.error(
                    "AWS Response Status Code and Error: [%s %s] %s; "
                    "Attempts remaining: %s",
                    exc.response.status_code,
                    exc,
                    data,
                    attempts,
                )
                sleep_exponential_backoff(attempts)
                continue
            log.error(
                "AWS Response Status Code and Error: [%s %s] %s",
                exc.response.status_code,
                exc,
                data,
            )
            if return_url is True:
                return {"error": data}, requesturl
            return {"error": data}
    else:
        log.error(
            "AWS Response Status Code and Error: [%s %s] %s",
            exc.response.status_code,
            exc,
            data,
        )
        if return_url is True:
            return {"error": data}, requesturl
        return {"error": data}
    root = ET.fromstring(result.text)
    items = root[1]
    if return_root is True:
        items = root
    if setname:
        for idx, item in enumerate(root):
            comps = item.tag.split("}")
            if comps[1] == setname:
                items = root[idx]
    ret = []
    for item in items:
        ret.append(xml.to_dict(item))
    if return_url is True:
        return ret, requesturl
    return ret
def get_region_from_metadata():
    global __Location__
    if __Location__ == "do-not-get-from-metadata":
        log.debug(
            "Previously failed to get AWS region from metadata. Not trying again."
        )
        return None
    if __Location__ != "":
        return __Location__
    try:
        result = requests.get(
            "http://169.254.169.254/latest/dynamic/instance-identity/document",
            proxies={"http": ""},
            timeout=AWS_METADATA_TIMEOUT,
        )
    except requests.exceptions.RequestException:
        log.warning("Failed to get AWS region from instance metadata.", exc_info=True)
        __Location__ = "do-not-get-from-metadata"
        return None
    try:
        region = result.json()["region"]
        __Location__ = region
        return __Location__
    except (ValueError, KeyError):
        log.warning("Failed to decode JSON from instance metadata.")
        return None
    return None
def get_location(opts=None, provider=None):
    if opts is None:
        opts = {}
    ret = opts.get("location")
    if ret is None and provider is not None:
        ret = provider.get("location")
    if ret is None:
        ret = get_region_from_metadata()
    if ret is None:
        ret = DEFAULT_LOCATION
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
