
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 12, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</h3>
            <pre><code>1  __all__ = [
2      "chip_id",
3      "detect_chip",
4      "dump_mem",
5      "elf2image",
6      "erase_flash",
7      "erase_region",
8      "flash_id",
9      "get_security_info",
10      "image_info",
11      "load_ram",
12      "make_image",
13      "merge_bin",
14      "read_flash",
15      "read_flash_status",
16      "read_mac",
17      "read_mem",
18      "run",
19      "verify_flash",
20      "version",
21      "write_flash",
22      "write_flash_status",
23      "write_mem",
24  ]
25  __version__ = "4.7-dev"
26  import argparse
27  import inspect
28  import os
29  import shlex
30  import sys
31  import time
32  import traceback
33  from esptool.cmds import (
34      DETECTED_FLASH_SIZES,
35      chip_id,
36      detect_chip,
37      detect_flash_size,
38      dump_mem,
39      elf2image,
40      erase_flash,
41      erase_region,
42      flash_id,
43      get_security_info,
44      image_info,
45      load_ram,
46      make_image,
47      merge_bin,
48      read_flash,
49      read_flash_status,
50      read_mac,
51      read_mem,
52      run,
53      verify_flash,
54      version,
55      write_flash,
56      write_flash_status,
57      write_mem,
58  )
59  from esptool.config import load_config_file
60  from esptool.loader import DEFAULT_CONNECT_ATTEMPTS, ESPLoader, list_ports
61  from esptool.targets import CHIP_DEFS, CHIP_LIST, ESP32ROM
62  from esptool.util import (
63      FatalError,
64      NotImplementedInROMError,
65      flash_size_bytes,
66      strip_chip_name,
67  )
68  import serial
69  def main(argv=None, esp=None):
70      external_esp = esp is not None
71      parser = argparse.ArgumentParser(
72          description="esptool.py v%s - Espressif chips ROM Bootloader Utility"
73          % __version__,
74          prog="esptool",
75      )
76      parser.add_argument(
77          "--chip",
78          "-c",
79          help="Target chip type",
80          type=strip_chip_name,
81          choices=["auto"] + CHIP_LIST,
82          default=os.environ.get("ESPTOOL_CHIP", "auto"),
83      )
84      parser.add_argument(
85          "--port",
86          "-p",
87          help="Serial port device",
88          default=os.environ.get("ESPTOOL_PORT", None),
89      )
90      parser.add_argument(
91          "--baud",
92          "-b",
93          help="Serial port baud rate used when flashing/reading",
94          type=arg_auto_int,
95          default=os.environ.get("ESPTOOL_BAUD", ESPLoader.ESP_ROM_BAUD),
96      )
97      parser.add_argument(
98          "--before",
99          help="What to do before connecting to the chip",
100          choices=["default_reset", "usb_reset", "no_reset", "no_reset_no_sync"],
101          default=os.environ.get("ESPTOOL_BEFORE", "default_reset"),
102      )
103      parser.add_argument(
104          "--after",
105          "-a",
106          help="What to do after esptool.py is finished",
107          choices=["hard_reset", "soft_reset", "no_reset", "no_reset_stub"],
108          default=os.environ.get("ESPTOOL_AFTER", "hard_reset"),
109      )
110      parser.add_argument(
111          "--no-stub",
112          help="Disable launching the flasher stub, only talk to ROM bootloader. "
113          "Some features will not be available.",
114          action="store_true",
115      )
116      parser.add_argument(
117          "--trace",
118          "-t",
119          help="Enable trace-level output of esptool.py interactions.",
120          action="store_true",
121      )
122      parser.add_argument(
123          "--override-vddsdio",
124          help="Override ESP32 VDDSDIO internal voltage regulator (use with care)",
125          choices=ESP32ROM.OVERRIDE_VDDSDIO_CHOICES,
126          nargs="?",
127      )
128      parser.add_argument(
129          "--connect-attempts",
130          help=(
131              "Number of attempts to connect, negative or 0 for infinite. "
132              "Default: %d." % DEFAULT_CONNECT_ATTEMPTS
133          ),
134          type=int,
135          default=os.environ.get("ESPTOOL_CONNECT_ATTEMPTS", DEFAULT_CONNECT_ATTEMPTS),
136      )
137      subparsers = parser.add_subparsers(
138          dest="operation", help="Run esptool.py {command} -h for additional help"
139      )
140      def add_spi_connection_arg(parent):
141          parent.add_argument(
142              "--spi-connection",
143              "-sc",
144              help="ESP32-only argument. Override default SPI Flash connection. "
145              "Value can be SPI, HSPI or a comma-separated list of 5 I/O numbers "
146              "to use for SPI flash (CLK,Q,D,HD,CS).",
147              action=SpiConnectionAction,
148          )
149      parser_load_ram = subparsers.add_parser(
150          "load_ram", help="Download an image to RAM and execute"
151      )
152      parser_load_ram.add_argument("filename", help="Firmware image")
153      parser_dump_mem = subparsers.add_parser(
154          "dump_mem", help="Dump arbitrary memory to disk"
155      )
156      parser_dump_mem.add_argument("address", help="Base address", type=arg_auto_int)
157      parser_dump_mem.add_argument(
158          "size", help="Size of region to dump", type=arg_auto_int
159      )
160      parser_dump_mem.add_argument("filename", help="Name of binary dump")
161      parser_read_mem = subparsers.add_parser(
162          "read_mem", help="Read arbitrary memory location"
163      )
164      parser_read_mem.add_argument("address", help="Address to read", type=arg_auto_int)
165      parser_write_mem = subparsers.add_parser(
166          "write_mem", help="Read-modify-write to arbitrary memory location"
167      )
168      parser_write_mem.add_argument("address", help="Address to write", type=arg_auto_int)
169      parser_write_mem.add_argument("value", help="Value", type=arg_auto_int)
170      parser_write_mem.add_argument(
171          "mask",
172          help="Mask of bits to write",
173          type=arg_auto_int,
174          nargs="?",
175          default="0xFFFFFFFF",
176      )
177      def add_spi_flash_subparsers(parent, allow_keep, auto_detect):
178          extra_keep_args = ["keep"] if allow_keep else []
179          if auto_detect and allow_keep:
180              extra_fs_message = ", detect, or keep"
181              flash_sizes = ["detect", "keep"]
182          elif auto_detect:
183              extra_fs_message = ", or detect"
184              flash_sizes = ["detect"]
185          elif allow_keep:
186              extra_fs_message = ", or keep"
187              flash_sizes = ["keep"]
188          else:
189              extra_fs_message = ""
190              flash_sizes = []
191          parent.add_argument(
192              "--flash_freq",
193              "-ff",
194              help="SPI Flash frequency",
195              choices=extra_keep_args
196              + [
197                  "80m",
198                  "60m",
199                  "48m",
200                  "40m",
201                  "30m",
202                  "26m",
203                  "24m",
204                  "20m",
205                  "16m",
206                  "15m",
207                  "12m",
208              ],
209              default=os.environ.get("ESPTOOL_FF", "keep" if allow_keep else None),
210          )
211          parent.add_argument(
212              "--flash_mode",
213              "-fm",
214              help="SPI Flash mode",
215              choices=extra_keep_args + ["qio", "qout", "dio", "dout"],
216              default=os.environ.get("ESPTOOL_FM", "keep" if allow_keep else "qio"),
217          )
218          parent.add_argument(
219              "--flash_size",
220              "-fs",
221              help="SPI Flash size in MegaBytes "
222              "(1MB, 2MB, 4MB, 8MB, 16MB, 32MB, 64MB, 128MB) "
223              "plus ESP8266-only (256KB, 512KB, 2MB-c1, 4MB-c1)" + extra_fs_message,
224              choices=flash_sizes
225              + [
226                  "256KB",
227                  "512KB",
228                  "1MB",
229                  "2MB",
230                  "2MB-c1",
231                  "4MB",
232                  "4MB-c1",
233                  "8MB",
234                  "16MB",
235                  "32MB",
236                  "64MB",
237                  "128MB",
238              ],
239              default=os.environ.get("ESPTOOL_FS", "keep" if allow_keep else "1MB"),
240          )
241          add_spi_connection_arg(parent)
242      parser_write_flash = subparsers.add_parser(
243          "write_flash", help="Write a binary blob to flash"
244      )
245      parser_write_flash.add_argument(
246          "addr_filename",
247          metavar="<address> <filename>",
248          help="Address followed by binary filename, separated by space",
249          action=AddrFilenamePairAction,
250      )
251      parser_write_flash.add_argument(
252          "--erase-all",
253          "-e",
254          help="Erase all regions of flash (not just write areas) before programming",
255          action="store_true",
256      )
257      add_spi_flash_subparsers(parser_write_flash, allow_keep=True, auto_detect=True)
258      parser_write_flash.add_argument(
259          "--no-progress", "-p", help="Suppress progress output", action="store_true"
260      )
261      parser_write_flash.add_argument(
262          "--verify",
263          help="Verify just-written data on flash "
264          "(mostly superfluous, data is read back during flashing)",
265          action="store_true",
266      )
267      parser_write_flash.add_argument(
268          "--encrypt",
269          help="Apply flash encryption when writing data "
270          "(required correct efuse settings)",
271          action="store_true",
272      )
273      parser_write_flash.add_argument(
274          "--encrypt-files",
275          metavar="<address> <filename>",
276          help="Files to be encrypted on the flash. "
277          "Address followed by binary filename, separated by space.",
278          action=AddrFilenamePairAction,
279      )
280      parser_write_flash.add_argument(
281          "--ignore-flash-encryption-efuse-setting",
282          help="Ignore flash encryption efuse settings ",
283          action="store_true",
284      )
285      parser_write_flash.add_argument(
286          "--force",
287          help="Force write, skip security and compatibility checks. Use with caution!",
288          action="store_true",
289      )
290      compress_args = parser_write_flash.add_mutually_exclusive_group(required=False)
291      compress_args.add_argument(
292          "--compress",
293          "-z",
294          help="Compress data in transfer (default unless --no-stub is specified)",
295          action="store_true",
296          default=None,
297      )
298      compress_args.add_argument(
299          "--no-compress",
300          "-u",
301          help="Disable data compression during transfer "
302          "(default if --no-stub is specified)",
303          action="store_true",
304      )
305      subparsers.add_parser("run", help="Run application code in flash")
306      parser_image_info = subparsers.add_parser(
307          "image_info", help="Dump headers from a binary file (bootloader or application)"
308      )
309      parser_image_info.add_argument("filename", help="Image file to parse")
310      parser_image_info.add_argument(
311          "--version",
312          "-v",
313          help="Output format version (1 - legacy, 2 - extended)",
314          choices=["1", "2"],
315          default="1",
316      )
317      parser_make_image = subparsers.add_parser(
318          "make_image", help="Create an application image from binary files"
319      )
320      parser_make_image.add_argument("output", help="Output image file")
321      parser_make_image.add_argument(
322          "--segfile", "-f", action="append", help="Segment input file"
323      )
324      parser_make_image.add_argument(
325          "--segaddr",
326          "-a",
327          action="append",
328          help="Segment base address",
329          type=arg_auto_int,
330      )
331      parser_make_image.add_argument(
332          "--entrypoint",
333          "-e",
334          help="Address of entry point",
335          type=arg_auto_int,
336          default=0,
337      )
338      parser_elf2image = subparsers.add_parser(
339          "elf2image", help="Create an application image from ELF file"
340      )
341      parser_elf2image.add_argument("input", help="Input ELF file")
342      parser_elf2image.add_argument(
343          "--output",
<span onclick='openModal()' class='match'>344          "-o",
345          help="Output filename prefix (for version 1 image), "
346          "or filename (for version 2 single image)",
347          type=str,
348      )
349      parser_elf2image.add_argument(
</span>350          "--version",
351          "-e",
352          help="Output image version",
353          choices=["1", "2", "3"],
354          default="1",
355      )
356      parser_elf2image.add_argument(
357          "--min-rev",
358          "-r",
359          help=argparse.SUPPRESS,
360          type=int,
361          choices=range(256),
362          metavar="{0, ... 255}",
363          default=0,
364      )
365      parser_elf2image.add_argument(
366          "--min-rev-full",
367          help="Minimal chip revision (in format: major * 100 + minor)",
368          type=int,
369          choices=range(65536),
370          metavar="{0, ... 65535}",
371          default=0,
372      )
373      parser_elf2image.add_argument(
374          "--max-rev-full",
375          help="Maximal chip revision (in format: major * 100 + minor)",
376          type=int,
377          choices=range(65536),
378          metavar="{0, ... 65535}",
379          default=65535,
380      )
381      parser_elf2image.add_argument(
382          "--secure-pad",
383          action="store_true",
384          help="Pad image so once signed it will end on a 64KB boundary. "
385          "For Secure Boot v1 images only.",
386      )
387      parser_elf2image.add_argument(
388          "--secure-pad-v2",
389          action="store_true",
390          help="Pad image to 64KB, so once signed its signature sector will"
391          "start at the next 64K block. For Secure Boot v2 images only.",
392      )
393      parser_elf2image.add_argument(
394          "--elf-sha256-offset",
395          help="If set, insert SHA256 hash (32 bytes) of the input ELF file "
396          "at specified offset in the binary.",
397          type=arg_auto_int,
398          default=None,
399      )
400      parser_elf2image.add_argument(
401          "--dont-append-digest",
402          dest="append_digest",
403          help="Don't append a SHA256 digest of the entire image after the checksum. "
404          "This argument is not supported and ignored for ESP8266.",
405          action="store_false",
406          default=True,
407      )
408      parser_elf2image.add_argument(
409          "--use_segments",
410          help="If set, ELF segments will be used instead of ELF sections "
411          "to genereate the image.",
412          action="store_true",
413      )
414      parser_elf2image.add_argument(
415          "--flash-mmu-page-size",
416          help="Change flash MMU page size.",
417          choices=["64KB", "32KB", "16KB", "8KB"],
418      )
419      parser_elf2image.add_argument(
420          "--pad-to-size",
421          help="The block size with which the final binary image after padding "
422          "must be aligned to. Value 0xFF is used for padding, similar to erase_flash",
423          default=None,
424      )
425      add_spi_flash_subparsers(parser_elf2image, allow_keep=False, auto_detect=False)
426      subparsers.add_parser("read_mac", help="Read MAC address from OTP ROM")
427      subparsers.add_parser("chip_id", help="Read Chip ID from OTP ROM")
428      parser_flash_id = subparsers.add_parser(
429          "flash_id", help="Read SPI flash manufacturer and device ID"
430      )
431      add_spi_connection_arg(parser_flash_id)
432      parser_read_status = subparsers.add_parser(
433          "read_flash_status", help="Read SPI flash status register"
434      )
435      add_spi_connection_arg(parser_read_status)
436      parser_read_status.add_argument(
437          "--bytes",
438          help="Number of bytes to read (1-3)",
439          type=int,
440          choices=[1, 2, 3],
441          default=2,
442      )
443      parser_write_status = subparsers.add_parser(
444          "write_flash_status", help="Write SPI flash status register"
445      )
446      add_spi_connection_arg(parser_write_status)
447      parser_write_status.add_argument(
448          "--non-volatile",
449          help="Write non-volatile bits (use with caution)",
450          action="store_true",
451      )
452      parser_write_status.add_argument(
453          "--bytes",
454          help="Number of status bytes to write (1-3)",
455          type=int,
456          choices=[1, 2, 3],
457          default=2,
458      )
459      parser_write_status.add_argument("value", help="New value", type=arg_auto_int)
460      parser_read_flash = subparsers.add_parser(
461          "read_flash", help="Read SPI flash content"
462      )
463      add_spi_connection_arg(parser_read_flash)
464      parser_read_flash.add_argument("address", help="Start address", type=arg_auto_int)
465      parser_read_flash.add_argument(
466          "size",
467          help="Size of region to dump. Use `ALL` to read to the end of flash.",
468          type=arg_auto_size,
469      )
470      parser_read_flash.add_argument("filename", help="Name of binary dump")
471      parser_read_flash.add_argument(
472          "--no-progress", "-p", help="Suppress progress output", action="store_true"
473      )
474      parser_verify_flash = subparsers.add_parser(
475          "verify_flash", help="Verify a binary blob against flash"
476      )
477      parser_verify_flash.add_argument(
478          "addr_filename",
479          help="Address and binary file to verify there, separated by space",
480          action=AddrFilenamePairAction,
481      )
482      parser_verify_flash.add_argument(
483          "--diff", "-d", help="Show differences", choices=["no", "yes"], default="no"
484      )
485      add_spi_flash_subparsers(parser_verify_flash, allow_keep=True, auto_detect=True)
486      parser_erase_flash = subparsers.add_parser(
487          "erase_flash", help="Perform Chip Erase on SPI flash"
488      )
489      parser_erase_flash.add_argument(
490          "--force",
491          help="Erase flash even if security features are enabled. Use with caution!",
492          action="store_true",
493      )
494      add_spi_connection_arg(parser_erase_flash)
495      parser_erase_region = subparsers.add_parser(
496          "erase_region", help="Erase a region of the flash"
497      )
498      parser_erase_region.add_argument(
499          "--force",
500          help="Erase region even if security features are enabled. Use with caution!",
501          action="store_true",
502      )
503      add_spi_connection_arg(parser_erase_region)
504      parser_erase_region.add_argument(
505          "address", help="Start address (must be multiple of 4096)", type=arg_auto_int
506      )
507      parser_erase_region.add_argument(
508          "size",
509          help="Size of region to erase (must be multiple of 4096). "
510          "Use `ALL` to erase to the end of flash.",
511          type=arg_auto_size,
512      )
513      parser_merge_bin = subparsers.add_parser(
514          "merge_bin",
515          help="Merge multiple raw binary files into a single file for later flashing",
516      )
517      parser_merge_bin.add_argument(
518          "--output", "-o", help="Output filename", type=str, required=True
519      )
520      parser_merge_bin.add_argument(
521          "--format", "-f", help="Format of the output file", choices="raw", default="raw"
522      )  # for future expansion
523      add_spi_flash_subparsers(parser_merge_bin, allow_keep=True, auto_detect=False)
524      parser_merge_bin.add_argument(
525          "--target-offset",
526          "-t",
527          help="Target offset where the output file will be flashed",
528          type=arg_auto_int,
529          default=0,
530      )
531      parser_merge_bin.add_argument(
532          "--fill-flash-size",
533          help="If set, the final binary file will be padded with FF "
534          "bytes up to this flash size.",
535          choices=[
536              "256KB",
537              "512KB",
538              "1MB",
539              "2MB",
540              "4MB",
541              "8MB",
542              "16MB",
543              "32MB",
544              "64MB",
545              "128MB",
546          ],
547      )
548      parser_merge_bin.add_argument(
549          "addr_filename",
550          metavar="<address> <filename>",
551          help="Address followed by binary filename, separated by space",
552          action=AddrFilenamePairAction,
553      )
554      subparsers.add_parser("get_security_info", help="Get some security-related data")
555      subparsers.add_parser("version", help="Print esptool version")
556      for operation in subparsers.choices.keys():
557          assert operation in globals(), "%s should be a module function" % operation
558      argv = expand_file_arguments(argv or sys.argv[1:])
559      args = parser.parse_args(argv)
560      print("esptool.py v%s" % __version__)
561      load_config_file(verbose=True)
562      if args.operation is None:
563          parser.print_help()
564          sys.exit(1)
565      if (
566          args.operation == "write_flash"
567          and args.encrypt
568          and args.encrypt_files is not None
569      ):
570          raise FatalError(
571              "Options --encrypt and --encrypt-files "
572              "must not be specified at the same time."
573          )
574      operation_func = globals()[args.operation]
575      operation_args = inspect.getfullargspec(operation_func).args
576      if (
577          operation_args[0] == "esp"
578      ):  # operation function takes an ESPLoader connection object
579          if args.before != "no_reset_no_sync":
580              initial_baud = min(
581                  ESPLoader.ESP_ROM_BAUD, args.baud
582              )  # don't sync faster than the default baud rate
583          else:
584              initial_baud = args.baud
585          if args.port is None:
586              ser_list = get_port_list()
587              print("Found %d serial ports" % len(ser_list))
588          else:
589              ser_list = [args.port]
590          esp = esp or get_default_connected_device(
591              ser_list,
592              port=args.port,
593              connect_attempts=args.connect_attempts,
594              initial_baud=initial_baud,
595              chip=args.chip,
596              trace=args.trace,
597              before=args.before,
598          )
599          if esp is None:
600              raise FatalError(
601                  "Could not connect to an Espressif device "
602                  "on any of the %d available serial ports." % len(ser_list)
603              )
604          if esp.secure_download_mode:
605              print("Chip is %s in Secure Download Mode" % esp.CHIP_NAME)
606          else:
607              print("Chip is %s" % (esp.get_chip_description()))
608              print("Features: %s" % ", ".join(esp.get_chip_features()))
609              print("Crystal is %dMHz" % esp.get_crystal_freq())
610              read_mac(esp, args)
611          if not args.no_stub:
612              if esp.secure_download_mode:
613                  print(
614                      "WARNING: Stub loader is not supported in Secure Download Mode, "
615                      "setting --no-stub"
616                  )
617                  args.no_stub = True
618              elif not esp.IS_STUB and esp.stub_is_disabled:
619                  print(
620                      "WARNING: Stub loader has been disabled for compatibility, "
621                      "setting --no-stub"
622                  )
623                  args.no_stub = True
624              else:
625                  try:
626                      esp = esp.run_stub()
627                  except Exception:
628                      if sys.platform == "darwin" and esp._get_pid() == 0x55D4:
629                          print(
630                              "\nNote: If issues persist, "
631                              "try installing the WCH USB-to-Serial MacOS driver."
632                          )
633                      raise
634          if args.override_vddsdio:
635              esp.override_vddsdio(args.override_vddsdio)
636          if args.baud > initial_baud:
637              try:
638                  esp.change_baud(args.baud)
639              except NotImplementedInROMError:
640                  print(
641                      "WARNING: ROM doesn't support changing baud rate. "
642                      "Keeping initial baud rate %d" % initial_baud
643                  )
644          if hasattr(args, "spi_connection") and args.spi_connection is not None:
645              if esp.CHIP_NAME != "ESP32":
646                  raise FatalError(
647                      "Chip %s does not support --spi-connection option." % esp.CHIP_NAME
648                  )
649              print("Configuring SPI flash mode...")
650              esp.flash_spi_attach(args.spi_connection)
651          elif args.no_stub:
652              print("Enabling default SPI flash mode...")
653              esp.flash_spi_attach(0)
654          XMC_VENDOR_ID = 0x20
655          def is_xmc_chip_strict():
656              id = esp.flash_id()
657              rdid = ((id & 0xFF) << 16) | ((id >> 16) & 0xFF) | (id & 0xFF00)
658              vendor_id = (rdid >> 16) & 0xFF
659              mfid = (rdid >> 8) & 0xFF
660              cpid = rdid & 0xFF
661              if vendor_id != XMC_VENDOR_ID:
662                  return False
663              matched = False
664              if mfid == 0x40:
665                  if cpid >= 0x13 and cpid <= 0x20:
666                      matched = True
667              elif mfid == 0x41:
668                  if cpid >= 0x17 and cpid <= 0x20:
669                      matched = True
670              elif mfid == 0x50:
671                  if cpid >= 0x15 and cpid <= 0x16:
672                      matched = True
673              return matched
674          def flash_xmc_startup():
675              fast_check = True
676              if fast_check and is_xmc_chip_strict():
677                  return  # Successful XMC flash chip boot-up detected by RDID, skipping.
678              sfdp_mfid_addr = 0x10
679              mf_id = esp.read_spiflash_sfdp(sfdp_mfid_addr, 8)
680              if mf_id != XMC_VENDOR_ID:  # Non-XMC chip detected by SFDP Read, skipping.
681                  return
682              print(
683                  "WARNING: XMC flash chip boot-up failure detected! "
684                  "Running XMC25QHxxC startup flow"
685              )
686              esp.run_spiflash_command(0xB9)  # Enter DPD
687              esp.run_spiflash_command(0x79)  # Enter UDPD
688              esp.run_spiflash_command(0xFF)  # Exit UDPD
689              time.sleep(0.002)  # Delay tXUDPD
690              esp.run_spiflash_command(0xAB)  # Release Power-Down
691              time.sleep(0.00002)
692              if not is_xmc_chip_strict():
693                  print("WARNING: XMC flash boot-up fix failed.")
694              print("XMC flash chip boot-up fix successful!")
695          if not esp.secure_download_mode:
696              try:
697                  flash_id = esp.flash_id()
698                  if flash_id in (0xFFFFFF, 0x000000):
699                      print(
700                          "WARNING: Failed to communicate with the flash chip, "
701                          "read/write operations will fail. "
702                          "Try checking the chip connections or removing "
703                          "any other hardware connected to IOs."
704                      )
705              except FatalError as e:
706                  raise FatalError(f"Unable to verify flash chip connection ({e}).")
707          if not esp.secure_download_mode:
708              try:
709                  flash_xmc_startup()
710              except FatalError as e:
711                  esp.trace(f"Unable to perform XMC flash chip startup sequence ({e}).")
712          if hasattr(args, "flash_size"):
713              print("Configuring flash size...")
714              if args.flash_size == "detect":
715                  flash_size = detect_flash_size(esp, args)
716              elif args.flash_size == "keep":
717                  flash_size = detect_flash_size(esp, args=None)
718              else:
719                  flash_size = args.flash_size
720              if flash_size is not None:  # Secure download mode
721                  esp.flash_set_parameters(flash_size_bytes(flash_size))
722                  if esp.IS_STUB and flash_size in ("32MB", "64MB", "128MB"):
723                      print(
724                          "WARNING: Flasher stub doesn't fully support flash size larger "
725                          "than 16MB, in case of failure use --no-stub."
726                      )
727          if getattr(args, "size", "") == "all":
728              if esp.secure_download_mode:
729                  raise FatalError(
730                      "Detecting flash size is not supported in secure download mode. "
731                      "Set an exact size value."
732                  )
733              flash_id = esp.flash_id()
734              size_id = flash_id >> 16
735              size_str = DETECTED_FLASH_SIZES.get(size_id)
736              if size_str is None:
737                  raise FatalError(
738                      "Detecting flash size failed. Set an exact size value."
739                  )
740              print(f"Detected flash size: {size_str}")
741              args.size = flash_size_bytes(size_str)
742          if esp.IS_STUB and hasattr(args, "address") and hasattr(args, "size"):
743              if args.address + args.size > 0x1000000:
744                  print(
745                      "WARNING: Flasher stub doesn't fully support flash size larger "
746                      "than 16MB, in case of failure use --no-stub."
747                  )
748          try:
749              operation_func(esp, args)
750          finally:
751              try:  # Clean up AddrFilenamePairAction files
752                  for address, argfile in args.addr_filename:
753                      argfile.close()
754              except AttributeError:
755                  pass
756          if operation_func == load_ram:
757              print("Exiting immediately.")
758          elif args.after == "hard_reset":
759              esp.hard_reset()
760          elif args.after == "soft_reset":
761              print("Soft resetting...")
762              esp.soft_reset(False)
763          elif args.after == "no_reset_stub":
764              print("Staying in flasher stub.")
765          else:  # args.after == 'no_reset'
766              print("Staying in bootloader.")
767              if esp.IS_STUB:
768                  esp.soft_reset(True)  # exit stub back to ROM loader
769          if not external_esp:
770              esp._port.close()
771      else:
772          operation_func(args)
773  def arg_auto_int(x):
774      return int(x, 0)
775  def arg_auto_size(x):
776      x = x.lower()
777      return x if x == "all" else arg_auto_int(x)
778  def get_port_list():
779      if list_ports is None:
780          raise FatalError(
781              "Listing all serial ports is currently not available. "
782              "Please try to specify the port when running esptool.py or update "
783              "the pyserial package to the latest version"
784          )
785      return sorted(ports.device for ports in list_ports.comports())
786  def expand_file_arguments(argv):
787      new_args = []
788      expanded = False
789      for arg in argv:
790          if arg.startswith("@"):
791              expanded = True
792              with open(arg[1:], "r") as f:
793                  for line in f.readlines():
794                      new_args += shlex.split(line)
795          else:
796              new_args.append(arg)
797      if expanded:
798          print("esptool %s" % (" ".join(new_args[1:])))
799          return new_args
800      return argv
801  def get_default_connected_device(
802      serial_list,
803      port,
804      connect_attempts,
805      initial_baud,
806      chip="auto",
807      trace=False,
808      before="default_reset",
809  ):
810      _esp = None
811      for each_port in reversed(serial_list):
812          print("Serial port %s" % each_port)
813          try:
814              if chip == "auto":
815                  _esp = detect_chip(
816                      each_port, initial_baud, before, trace, connect_attempts
817                  )
818              else:
819                  chip_class = CHIP_DEFS[chip]
820                  _esp = chip_class(each_port, initial_baud, trace)
821                  _esp.connect(before, connect_attempts)
822              break
823          except (FatalError, OSError) as err:
824              if port is not None:
825                  raise
826              print("%s failed to connect: %s" % (each_port, err))
827              if _esp and _esp._port:
828                  _esp._port.close()
829              _esp = None
830      return _esp
831  class SpiConnectionAction(argparse.Action):
832      def __call__(self, parser, namespace, value, option_string=None):
833          if value.upper() == "SPI":
834              value = 0
835          elif value.upper() == "HSPI":
836              value = 1
837          elif "," in value:
838              values = value.split(",")
839              if len(values) != 5:
840                  raise argparse.ArgumentError(
841                      self,
842                      "%s is not a valid list of comma-separate pin numbers. "
843                      "Must be 5 numbers - CLK,Q,D,HD,CS." % value,
844                  )
845              try:
846                  values = tuple(int(v, 0) for v in values)
847              except ValueError:
848                  raise argparse.ArgumentError(
849                      self,
850                      "%s is not a valid argument. All pins must be numeric values"
851                      % values,
852                  )
853              if any([v for v in values if v > 33 or v < 0]):
854                  raise argparse.ArgumentError(
855                      self, "Pin numbers must be in the range 0-33."
856                  )
857              clk, q, d, hd, cs = values
858              value = (hd << 24) | (cs << 18) | (d << 12) | (q << 6) | clk
859          else:
860              raise argparse.ArgumentError(
861                  self,
862                  "%s is not a valid spi-connection value. "
863                  "Values are SPI, HSPI, or a sequence of 5 pin numbers CLK,Q,D,HD,CS)."
864                  % value,
865              )
866          setattr(namespace, self.dest, value)
867  class AddrFilenamePairAction(argparse.Action):
868      def __init__(self, option_strings, dest, nargs="+", **kwargs):
869          super(AddrFilenamePairAction, self).__init__(
870              option_strings, dest, nargs, **kwargs
871          )
872      def __call__(self, parser, namespace, values, option_string=None):
873          pairs = []
874          for i in range(0, len(values), 2):
875              try:
876                  address = int(values[i], 0)
877              except ValueError:
878                  raise argparse.ArgumentError(
879                      self, 'Address "%s" must be a number' % values[i]
880                  )
881              try:
882                  argfile = open(values[i + 1], "rb")
883              except IOError as e:
884                  raise argparse.ArgumentError(self, e)
885              except IndexError:
886                  raise argparse.ArgumentError(
887                      self,
888                      "Must be pairs of an address "
889                      "and the binary filename to write there",
890                  )
891              pairs.append((address, argfile))
892          end = 0
893          for address, argfile in sorted(pairs, key=lambda x: x[0]):
894              argfile.seek(0, 2)  # seek to end
895              size = argfile.tell()
896              argfile.seek(0)
897              sector_start = address & ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
898              sector_end = (
899                  (address + size + ESPLoader.FLASH_SECTOR_SIZE - 1)
900                  & ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
901              ) - 1
902              if sector_start < end:
903                  message = "Detected overlap at address: 0x%x for file: %s" % (
904                      address,
905                      argfile.name,
906                  )
907                  raise argparse.ArgumentError(self, message)
908              end = sector_end
909          setattr(namespace, self.dest, pairs)
910  def _main():
911      try:
912          main()
913      except FatalError as e:
914          print(f"\nA fatal error occurred: {e}")
915          sys.exit(2)
916      except serial.serialutil.SerialException as e:
917          print(f"\nA serial exception error occurred: {e}")
918          print(
919              "Note: This error originates from pySerial. "
920              "It is likely not a problem with esptool, "
921              "but with the hardware connection or drivers."
922          )
923          print(
924              "For troubleshooting steps visit: "
925              "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html"
926          )
927          sys.exit(1)
928      except StopIteration:
929          print(traceback.format_exc())
930          print("A fatal error occurred: The chip stopped responding.")
931          sys.exit(2)
932  if __name__ == "__main__":
933      _main()
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</h3>
            <pre><code>1  __all__ = [
2      "chip_id",
3      "detect_chip",
4      "dump_mem",
5      "elf2image",
6      "erase_flash",
7      "erase_region",
8      "flash_id",
9      "get_security_info",
10      "image_info",
11      "load_ram",
12      "make_image",
13      "merge_bin",
14      "read_flash",
15      "read_flash_status",
16      "read_mac",
17      "read_mem",
18      "run",
19      "verify_flash",
20      "version",
21      "write_flash",
22      "write_flash_status",
23      "write_mem",
24  ]
25  __version__ = "4.7-dev"
26  import argparse
27  import inspect
28  import os
29  import shlex
30  import sys
31  import time
32  import traceback
33  from esptool.cmds import (
34      DETECTED_FLASH_SIZES,
35      chip_id,
36      detect_chip,
37      detect_flash_size,
38      dump_mem,
39      elf2image,
40      erase_flash,
41      erase_region,
42      flash_id,
43      get_security_info,
44      image_info,
45      load_ram,
46      make_image,
47      merge_bin,
48      read_flash,
49      read_flash_status,
50      read_mac,
51      read_mem,
52      run,
53      verify_flash,
54      version,
55      write_flash,
56      write_flash_status,
57      write_mem,
58  )
59  from esptool.config import load_config_file
60  from esptool.loader import DEFAULT_CONNECT_ATTEMPTS, ESPLoader, list_ports
61  from esptool.targets import CHIP_DEFS, CHIP_LIST, ESP32ROM
62  from esptool.util import (
63      FatalError,
64      NotImplementedInROMError,
65      flash_size_bytes,
66      strip_chip_name,
67  )
68  import serial
69  def main(argv=None, esp=None):
70      external_esp = esp is not None
71      parser = argparse.ArgumentParser(
72          description="esptool.py v%s - Espressif chips ROM Bootloader Utility"
73          % __version__,
74          prog="esptool",
75      )
76      parser.add_argument(
77          "--chip",
78          "-c",
79          help="Target chip type",
80          type=strip_chip_name,
81          choices=["auto"] + CHIP_LIST,
82          default=os.environ.get("ESPTOOL_CHIP", "auto"),
83      )
84      parser.add_argument(
85          "--port",
86          "-p",
87          help="Serial port device",
88          default=os.environ.get("ESPTOOL_PORT", None),
89      )
90      parser.add_argument(
91          "--baud",
92          "-b",
93          help="Serial port baud rate used when flashing/reading",
94          type=arg_auto_int,
95          default=os.environ.get("ESPTOOL_BAUD", ESPLoader.ESP_ROM_BAUD),
96      )
97      parser.add_argument(
98          "--before",
99          help="What to do before connecting to the chip",
100          choices=["default_reset", "usb_reset", "no_reset", "no_reset_no_sync"],
101          default=os.environ.get("ESPTOOL_BEFORE", "default_reset"),
102      )
103      parser.add_argument(
104          "--after",
105          "-a",
106          help="What to do after esptool.py is finished",
107          choices=["hard_reset", "soft_reset", "no_reset", "no_reset_stub"],
108          default=os.environ.get("ESPTOOL_AFTER", "hard_reset"),
109      )
110      parser.add_argument(
111          "--no-stub",
112          help="Disable launching the flasher stub, only talk to ROM bootloader. "
113          "Some features will not be available.",
114          action="store_true",
115      )
116      parser.add_argument(
117          "--trace",
118          "-t",
119          help="Enable trace-level output of esptool.py interactions.",
120          action="store_true",
121      )
122      parser.add_argument(
123          "--override-vddsdio",
124          help="Override ESP32 VDDSDIO internal voltage regulator (use with care)",
125          choices=ESP32ROM.OVERRIDE_VDDSDIO_CHOICES,
126          nargs="?",
127      )
128      parser.add_argument(
129          "--connect-attempts",
130          help=(
131              "Number of attempts to connect, negative or 0 for infinite. "
132              "Default: %d." % DEFAULT_CONNECT_ATTEMPTS
133          ),
134          type=int,
135          default=os.environ.get("ESPTOOL_CONNECT_ATTEMPTS", DEFAULT_CONNECT_ATTEMPTS),
136      )
137      subparsers = parser.add_subparsers(
138          dest="operation", help="Run esptool.py {command} -h for additional help"
139      )
140      def add_spi_connection_arg(parent):
141          parent.add_argument(
142              "--spi-connection",
143              "-sc",
144              help="ESP32-only argument. Override default SPI Flash connection. "
145              "Value can be SPI, HSPI or a comma-separated list of 5 I/O numbers "
146              "to use for SPI flash (CLK,Q,D,HD,CS).",
147              action=SpiConnectionAction,
148          )
149      parser_load_ram = subparsers.add_parser(
150          "load_ram", help="Download an image to RAM and execute"
151      )
152      parser_load_ram.add_argument("filename", help="Firmware image")
153      parser_dump_mem = subparsers.add_parser(
154          "dump_mem", help="Dump arbitrary memory to disk"
155      )
156      parser_dump_mem.add_argument("address", help="Base address", type=arg_auto_int)
157      parser_dump_mem.add_argument(
158          "size", help="Size of region to dump", type=arg_auto_int
159      )
160      parser_dump_mem.add_argument("filename", help="Name of binary dump")
161      parser_read_mem = subparsers.add_parser(
162          "read_mem", help="Read arbitrary memory location"
163      )
164      parser_read_mem.add_argument("address", help="Address to read", type=arg_auto_int)
165      parser_write_mem = subparsers.add_parser(
166          "write_mem", help="Read-modify-write to arbitrary memory location"
167      )
168      parser_write_mem.add_argument("address", help="Address to write", type=arg_auto_int)
169      parser_write_mem.add_argument("value", help="Value", type=arg_auto_int)
170      parser_write_mem.add_argument(
171          "mask",
172          help="Mask of bits to write",
173          type=arg_auto_int,
174          nargs="?",
175          default="0xFFFFFFFF",
176      )
177      def add_spi_flash_subparsers(parent, allow_keep, auto_detect):
178          extra_keep_args = ["keep"] if allow_keep else []
179          if auto_detect and allow_keep:
180              extra_fs_message = ", detect, or keep"
181              flash_sizes = ["detect", "keep"]
182          elif auto_detect:
183              extra_fs_message = ", or detect"
184              flash_sizes = ["detect"]
185          elif allow_keep:
186              extra_fs_message = ", or keep"
187              flash_sizes = ["keep"]
188          else:
189              extra_fs_message = ""
190              flash_sizes = []
191          parent.add_argument(
192              "--flash_freq",
193              "-ff",
194              help="SPI Flash frequency",
195              choices=extra_keep_args
196              + [
197                  "80m",
198                  "60m",
199                  "48m",
200                  "40m",
201                  "30m",
202                  "26m",
203                  "24m",
204                  "20m",
205                  "16m",
206                  "15m",
207                  "12m",
208              ],
209              default=os.environ.get("ESPTOOL_FF", "keep" if allow_keep else None),
210          )
211          parent.add_argument(
212              "--flash_mode",
213              "-fm",
214              help="SPI Flash mode",
215              choices=extra_keep_args + ["qio", "qout", "dio", "dout"],
216              default=os.environ.get("ESPTOOL_FM", "keep" if allow_keep else "qio"),
217          )
218          parent.add_argument(
219              "--flash_size",
220              "-fs",
221              help="SPI Flash size in MegaBytes "
222              "(1MB, 2MB, 4MB, 8MB, 16MB, 32MB, 64MB, 128MB) "
223              "plus ESP8266-only (256KB, 512KB, 2MB-c1, 4MB-c1)" + extra_fs_message,
224              choices=flash_sizes
225              + [
226                  "256KB",
227                  "512KB",
228                  "1MB",
229                  "2MB",
230                  "2MB-c1",
231                  "4MB",
232                  "4MB-c1",
233                  "8MB",
234                  "16MB",
235                  "32MB",
236                  "64MB",
237                  "128MB",
238              ],
239              default=os.environ.get("ESPTOOL_FS", "keep" if allow_keep else "1MB"),
240          )
241          add_spi_connection_arg(parent)
242      parser_write_flash = subparsers.add_parser(
243          "write_flash", help="Write a binary blob to flash"
244      )
245      parser_write_flash.add_argument(
246          "addr_filename",
247          metavar="<address> <filename>",
248          help="Address followed by binary filename, separated by space",
249          action=AddrFilenamePairAction,
250      )
251      parser_write_flash.add_argument(
252          "--erase-all",
253          "-e",
254          help="Erase all regions of flash (not just write areas) before programming",
255          action="store_true",
256      )
257      add_spi_flash_subparsers(parser_write_flash, allow_keep=True, auto_detect=True)
258      parser_write_flash.add_argument(
259          "--no-progress", "-p", help="Suppress progress output", action="store_true"
260      )
261      parser_write_flash.add_argument(
262          "--verify",
263          help="Verify just-written data on flash "
264          "(mostly superfluous, data is read back during flashing)",
265          action="store_true",
266      )
267      parser_write_flash.add_argument(
268          "--encrypt",
269          help="Apply flash encryption when writing data "
270          "(required correct efuse settings)",
271          action="store_true",
272      )
273      parser_write_flash.add_argument(
274          "--encrypt-files",
275          metavar="<address> <filename>",
276          help="Files to be encrypted on the flash. "
277          "Address followed by binary filename, separated by space.",
278          action=AddrFilenamePairAction,
279      )
280      parser_write_flash.add_argument(
281          "--ignore-flash-encryption-efuse-setting",
282          help="Ignore flash encryption efuse settings ",
283          action="store_true",
284      )
285      parser_write_flash.add_argument(
286          "--force",
287          help="Force write, skip security and compatibility checks. Use with caution!",
288          action="store_true",
289      )
290      compress_args = parser_write_flash.add_mutually_exclusive_group(required=False)
291      compress_args.add_argument(
292          "--compress",
293          "-z",
294          help="Compress data in transfer (default unless --no-stub is specified)",
295          action="store_true",
296          default=None,
297      )
298      compress_args.add_argument(
299          "--no-compress",
300          "-u",
301          help="Disable data compression during transfer "
302          "(default if --no-stub is specified)",
303          action="store_true",
304      )
305      subparsers.add_parser("run", help="Run application code in flash")
306      parser_image_info = subparsers.add_parser(
307          "image_info", help="Dump headers from a binary file (bootloader or application)"
308      )
309      parser_image_info.add_argument("filename", help="Image file to parse")
310      parser_image_info.add_argument(
311          "--version",
312          "-v",
313          help="Output format version (1 - legacy, 2 - extended)",
314          choices=["1", "2"],
315          default="1",
316      )
317      parser_make_image = subparsers.add_parser(
318          "make_image", help="Create an application image from binary files"
319      )
320      parser_make_image.add_argument("output", help="Output image file")
321      parser_make_image.add_argument(
322          "--segfile", "-f", action="append", help="Segment input file"
323      )
324      parser_make_image.add_argument(
325          "--segaddr",
326          "-a",
327          action="append",
328          help="Segment base address",
329          type=arg_auto_int,
330      )
331      parser_make_image.add_argument(
332          "--entrypoint",
333          "-e",
334          help="Address of entry point",
335          type=arg_auto_int,
336          default=0,
337      )
338      parser_elf2image = subparsers.add_parser(
339          "elf2image", help="Create an application image from ELF file"
340      )
341      parser_elf2image.add_argument("input", help="Input ELF file")
342      parser_elf2image.add_argument(
343          "--output",
344          "-o",
345          help="Output filename prefix (for version 1 image), "
346          "or filename (for version 2 single image)",
347          type=str,
348      )
349      parser_elf2image.add_argument(
350          "--version",
351          "-e",
352          help="Output image version",
353          choices=["1", "2", "3"],
354          default="1",
355      )
356      parser_elf2image.add_argument(
357          "--min-rev",
358          "-r",
359          help=argparse.SUPPRESS,
360          type=int,
361          choices=range(256),
362          metavar="{0, ... 255}",
363          default=0,
364      )
365      parser_elf2image.add_argument(
366          "--min-rev-full",
367          help="Minimal chip revision (in format: major * 100 + minor)",
368          type=int,
369          choices=range(65536),
370          metavar="{0, ... 65535}",
371          default=0,
372      )
373      parser_elf2image.add_argument(
374          "--max-rev-full",
375          help="Maximal chip revision (in format: major * 100 + minor)",
376          type=int,
377          choices=range(65536),
378          metavar="{0, ... 65535}",
379          default=65535,
380      )
381      parser_elf2image.add_argument(
382          "--secure-pad",
383          action="store_true",
384          help="Pad image so once signed it will end on a 64KB boundary. "
385          "For Secure Boot v1 images only.",
386      )
387      parser_elf2image.add_argument(
388          "--secure-pad-v2",
389          action="store_true",
390          help="Pad image to 64KB, so once signed its signature sector will"
391          "start at the next 64K block. For Secure Boot v2 images only.",
392      )
393      parser_elf2image.add_argument(
394          "--elf-sha256-offset",
395          help="If set, insert SHA256 hash (32 bytes) of the input ELF file "
396          "at specified offset in the binary.",
397          type=arg_auto_int,
398          default=None,
399      )
400      parser_elf2image.add_argument(
401          "--dont-append-digest",
402          dest="append_digest",
403          help="Don't append a SHA256 digest of the entire image after the checksum. "
404          "This argument is not supported and ignored for ESP8266.",
405          action="store_false",
406          default=True,
407      )
408      parser_elf2image.add_argument(
409          "--use_segments",
410          help="If set, ELF segments will be used instead of ELF sections "
411          "to genereate the image.",
412          action="store_true",
413      )
414      parser_elf2image.add_argument(
415          "--flash-mmu-page-size",
416          help="Change flash MMU page size.",
417          choices=["64KB", "32KB", "16KB", "8KB"],
418      )
419      parser_elf2image.add_argument(
420          "--pad-to-size",
421          help="The block size with which the final binary image after padding "
422          "must be aligned to. Value 0xFF is used for padding, similar to erase_flash",
423          default=None,
424      )
425      add_spi_flash_subparsers(parser_elf2image, allow_keep=False, auto_detect=False)
426      subparsers.add_parser("read_mac", help="Read MAC address from OTP ROM")
427      subparsers.add_parser("chip_id", help="Read Chip ID from OTP ROM")
428      parser_flash_id = subparsers.add_parser(
429          "flash_id", help="Read SPI flash manufacturer and device ID"
430      )
431      add_spi_connection_arg(parser_flash_id)
432      parser_read_status = subparsers.add_parser(
433          "read_flash_status", help="Read SPI flash status register"
434      )
435      add_spi_connection_arg(parser_read_status)
436      parser_read_status.add_argument(
437          "--bytes",
438          help="Number of bytes to read (1-3)",
439          type=int,
440          choices=[1, 2, 3],
441          default=2,
442      )
443      parser_write_status = subparsers.add_parser(
444          "write_flash_status", help="Write SPI flash status register"
445      )
446      add_spi_connection_arg(parser_write_status)
447      parser_write_status.add_argument(
448          "--non-volatile",
449          help="Write non-volatile bits (use with caution)",
450          action="store_true",
451      )
452      parser_write_status.add_argument(
453          "--bytes",
454          help="Number of status bytes to write (1-3)",
455          type=int,
456          choices=[1, 2, 3],
457          default=2,
458      )
459      parser_write_status.add_argument("value", help="New value", type=arg_auto_int)
460      parser_read_flash = subparsers.add_parser(
461          "read_flash", help="Read SPI flash content"
462      )
463      add_spi_connection_arg(parser_read_flash)
464      parser_read_flash.add_argument("address", help="Start address", type=arg_auto_int)
465      parser_read_flash.add_argument(
466          "size",
467          help="Size of region to dump. Use `ALL` to read to the end of flash.",
468          type=arg_auto_size,
469      )
470      parser_read_flash.add_argument("filename", help="Name of binary dump")
471      parser_read_flash.add_argument(
472          "--no-progress", "-p", help="Suppress progress output", action="store_true"
473      )
474      parser_verify_flash = subparsers.add_parser(
475          "verify_flash", help="Verify a binary blob against flash"
476      )
477      parser_verify_flash.add_argument(
478          "addr_filename",
479          help="Address and binary file to verify there, separated by space",
480          action=AddrFilenamePairAction,
481      )
482      parser_verify_flash.add_argument(
483          "--diff", "-d", help="Show differences", choices=["no", "yes"], default="no"
484      )
485      add_spi_flash_subparsers(parser_verify_flash, allow_keep=True, auto_detect=True)
486      parser_erase_flash = subparsers.add_parser(
487          "erase_flash", help="Perform Chip Erase on SPI flash"
488      )
489      parser_erase_flash.add_argument(
490          "--force",
491          help="Erase flash even if security features are enabled. Use with caution!",
492          action="store_true",
493      )
494      add_spi_connection_arg(parser_erase_flash)
495      parser_erase_region = subparsers.add_parser(
496          "erase_region", help="Erase a region of the flash"
497      )
498      parser_erase_region.add_argument(
499          "--force",
500          help="Erase region even if security features are enabled. Use with caution!",
501          action="store_true",
502      )
503      add_spi_connection_arg(parser_erase_region)
504      parser_erase_region.add_argument(
505          "address", help="Start address (must be multiple of 4096)", type=arg_auto_int
506      )
507      parser_erase_region.add_argument(
<span onclick='openModal()' class='match'>508          "size",
509          help="Size of region to erase (must be multiple of 4096). "
510          "Use `ALL` to erase to the end of flash.",
511          type=arg_auto_size,
512      )
513      parser_merge_bin = subparsers.add_parser(
</span>514          "merge_bin",
515          help="Merge multiple raw binary files into a single file for later flashing",
516      )
517      parser_merge_bin.add_argument(
518          "--output", "-o", help="Output filename", type=str, required=True
519      )
520      parser_merge_bin.add_argument(
521          "--format", "-f", help="Format of the output file", choices="raw", default="raw"
522      )  # for future expansion
523      add_spi_flash_subparsers(parser_merge_bin, allow_keep=True, auto_detect=False)
524      parser_merge_bin.add_argument(
525          "--target-offset",
526          "-t",
527          help="Target offset where the output file will be flashed",
528          type=arg_auto_int,
529          default=0,
530      )
531      parser_merge_bin.add_argument(
532          "--fill-flash-size",
533          help="If set, the final binary file will be padded with FF "
534          "bytes up to this flash size.",
535          choices=[
536              "256KB",
537              "512KB",
538              "1MB",
539              "2MB",
540              "4MB",
541              "8MB",
542              "16MB",
543              "32MB",
544              "64MB",
545              "128MB",
546          ],
547      )
548      parser_merge_bin.add_argument(
549          "addr_filename",
550          metavar="<address> <filename>",
551          help="Address followed by binary filename, separated by space",
552          action=AddrFilenamePairAction,
553      )
554      subparsers.add_parser("get_security_info", help="Get some security-related data")
555      subparsers.add_parser("version", help="Print esptool version")
556      for operation in subparsers.choices.keys():
557          assert operation in globals(), "%s should be a module function" % operation
558      argv = expand_file_arguments(argv or sys.argv[1:])
559      args = parser.parse_args(argv)
560      print("esptool.py v%s" % __version__)
561      load_config_file(verbose=True)
562      if args.operation is None:
563          parser.print_help()
564          sys.exit(1)
565      if (
566          args.operation == "write_flash"
567          and args.encrypt
568          and args.encrypt_files is not None
569      ):
570          raise FatalError(
571              "Options --encrypt and --encrypt-files "
572              "must not be specified at the same time."
573          )
574      operation_func = globals()[args.operation]
575      operation_args = inspect.getfullargspec(operation_func).args
576      if (
577          operation_args[0] == "esp"
578      ):  # operation function takes an ESPLoader connection object
579          if args.before != "no_reset_no_sync":
580              initial_baud = min(
581                  ESPLoader.ESP_ROM_BAUD, args.baud
582              )  # don't sync faster than the default baud rate
583          else:
584              initial_baud = args.baud
585          if args.port is None:
586              ser_list = get_port_list()
587              print("Found %d serial ports" % len(ser_list))
588          else:
589              ser_list = [args.port]
590          esp = esp or get_default_connected_device(
591              ser_list,
592              port=args.port,
593              connect_attempts=args.connect_attempts,
594              initial_baud=initial_baud,
595              chip=args.chip,
596              trace=args.trace,
597              before=args.before,
598          )
599          if esp is None:
600              raise FatalError(
601                  "Could not connect to an Espressif device "
602                  "on any of the %d available serial ports." % len(ser_list)
603              )
604          if esp.secure_download_mode:
605              print("Chip is %s in Secure Download Mode" % esp.CHIP_NAME)
606          else:
607              print("Chip is %s" % (esp.get_chip_description()))
608              print("Features: %s" % ", ".join(esp.get_chip_features()))
609              print("Crystal is %dMHz" % esp.get_crystal_freq())
610              read_mac(esp, args)
611          if not args.no_stub:
612              if esp.secure_download_mode:
613                  print(
614                      "WARNING: Stub loader is not supported in Secure Download Mode, "
615                      "setting --no-stub"
616                  )
617                  args.no_stub = True
618              elif not esp.IS_STUB and esp.stub_is_disabled:
619                  print(
620                      "WARNING: Stub loader has been disabled for compatibility, "
621                      "setting --no-stub"
622                  )
623                  args.no_stub = True
624              else:
625                  try:
626                      esp = esp.run_stub()
627                  except Exception:
628                      if sys.platform == "darwin" and esp._get_pid() == 0x55D4:
629                          print(
630                              "\nNote: If issues persist, "
631                              "try installing the WCH USB-to-Serial MacOS driver."
632                          )
633                      raise
634          if args.override_vddsdio:
635              esp.override_vddsdio(args.override_vddsdio)
636          if args.baud > initial_baud:
637              try:
638                  esp.change_baud(args.baud)
639              except NotImplementedInROMError:
640                  print(
641                      "WARNING: ROM doesn't support changing baud rate. "
642                      "Keeping initial baud rate %d" % initial_baud
643                  )
644          if hasattr(args, "spi_connection") and args.spi_connection is not None:
645              if esp.CHIP_NAME != "ESP32":
646                  raise FatalError(
647                      "Chip %s does not support --spi-connection option." % esp.CHIP_NAME
648                  )
649              print("Configuring SPI flash mode...")
650              esp.flash_spi_attach(args.spi_connection)
651          elif args.no_stub:
652              print("Enabling default SPI flash mode...")
653              esp.flash_spi_attach(0)
654          XMC_VENDOR_ID = 0x20
655          def is_xmc_chip_strict():
656              id = esp.flash_id()
657              rdid = ((id & 0xFF) << 16) | ((id >> 16) & 0xFF) | (id & 0xFF00)
658              vendor_id = (rdid >> 16) & 0xFF
659              mfid = (rdid >> 8) & 0xFF
660              cpid = rdid & 0xFF
661              if vendor_id != XMC_VENDOR_ID:
662                  return False
663              matched = False
664              if mfid == 0x40:
665                  if cpid >= 0x13 and cpid <= 0x20:
666                      matched = True
667              elif mfid == 0x41:
668                  if cpid >= 0x17 and cpid <= 0x20:
669                      matched = True
670              elif mfid == 0x50:
671                  if cpid >= 0x15 and cpid <= 0x16:
672                      matched = True
673              return matched
674          def flash_xmc_startup():
675              fast_check = True
676              if fast_check and is_xmc_chip_strict():
677                  return  # Successful XMC flash chip boot-up detected by RDID, skipping.
678              sfdp_mfid_addr = 0x10
679              mf_id = esp.read_spiflash_sfdp(sfdp_mfid_addr, 8)
680              if mf_id != XMC_VENDOR_ID:  # Non-XMC chip detected by SFDP Read, skipping.
681                  return
682              print(
683                  "WARNING: XMC flash chip boot-up failure detected! "
684                  "Running XMC25QHxxC startup flow"
685              )
686              esp.run_spiflash_command(0xB9)  # Enter DPD
687              esp.run_spiflash_command(0x79)  # Enter UDPD
688              esp.run_spiflash_command(0xFF)  # Exit UDPD
689              time.sleep(0.002)  # Delay tXUDPD
690              esp.run_spiflash_command(0xAB)  # Release Power-Down
691              time.sleep(0.00002)
692              if not is_xmc_chip_strict():
693                  print("WARNING: XMC flash boot-up fix failed.")
694              print("XMC flash chip boot-up fix successful!")
695          if not esp.secure_download_mode:
696              try:
697                  flash_id = esp.flash_id()
698                  if flash_id in (0xFFFFFF, 0x000000):
699                      print(
700                          "WARNING: Failed to communicate with the flash chip, "
701                          "read/write operations will fail. "
702                          "Try checking the chip connections or removing "
703                          "any other hardware connected to IOs."
704                      )
705              except FatalError as e:
706                  raise FatalError(f"Unable to verify flash chip connection ({e}).")
707          if not esp.secure_download_mode:
708              try:
709                  flash_xmc_startup()
710              except FatalError as e:
711                  esp.trace(f"Unable to perform XMC flash chip startup sequence ({e}).")
712          if hasattr(args, "flash_size"):
713              print("Configuring flash size...")
714              if args.flash_size == "detect":
715                  flash_size = detect_flash_size(esp, args)
716              elif args.flash_size == "keep":
717                  flash_size = detect_flash_size(esp, args=None)
718              else:
719                  flash_size = args.flash_size
720              if flash_size is not None:  # Secure download mode
721                  esp.flash_set_parameters(flash_size_bytes(flash_size))
722                  if esp.IS_STUB and flash_size in ("32MB", "64MB", "128MB"):
723                      print(
724                          "WARNING: Flasher stub doesn't fully support flash size larger "
725                          "than 16MB, in case of failure use --no-stub."
726                      )
727          if getattr(args, "size", "") == "all":
728              if esp.secure_download_mode:
729                  raise FatalError(
730                      "Detecting flash size is not supported in secure download mode. "
731                      "Set an exact size value."
732                  )
733              flash_id = esp.flash_id()
734              size_id = flash_id >> 16
735              size_str = DETECTED_FLASH_SIZES.get(size_id)
736              if size_str is None:
737                  raise FatalError(
738                      "Detecting flash size failed. Set an exact size value."
739                  )
740              print(f"Detected flash size: {size_str}")
741              args.size = flash_size_bytes(size_str)
742          if esp.IS_STUB and hasattr(args, "address") and hasattr(args, "size"):
743              if args.address + args.size > 0x1000000:
744                  print(
745                      "WARNING: Flasher stub doesn't fully support flash size larger "
746                      "than 16MB, in case of failure use --no-stub."
747                  )
748          try:
749              operation_func(esp, args)
750          finally:
751              try:  # Clean up AddrFilenamePairAction files
752                  for address, argfile in args.addr_filename:
753                      argfile.close()
754              except AttributeError:
755                  pass
756          if operation_func == load_ram:
757              print("Exiting immediately.")
758          elif args.after == "hard_reset":
759              esp.hard_reset()
760          elif args.after == "soft_reset":
761              print("Soft resetting...")
762              esp.soft_reset(False)
763          elif args.after == "no_reset_stub":
764              print("Staying in flasher stub.")
765          else:  # args.after == 'no_reset'
766              print("Staying in bootloader.")
767              if esp.IS_STUB:
768                  esp.soft_reset(True)  # exit stub back to ROM loader
769          if not external_esp:
770              esp._port.close()
771      else:
772          operation_func(args)
773  def arg_auto_int(x):
774      return int(x, 0)
775  def arg_auto_size(x):
776      x = x.lower()
777      return x if x == "all" else arg_auto_int(x)
778  def get_port_list():
779      if list_ports is None:
780          raise FatalError(
781              "Listing all serial ports is currently not available. "
782              "Please try to specify the port when running esptool.py or update "
783              "the pyserial package to the latest version"
784          )
785      return sorted(ports.device for ports in list_ports.comports())
786  def expand_file_arguments(argv):
787      new_args = []
788      expanded = False
789      for arg in argv:
790          if arg.startswith("@"):
791              expanded = True
792              with open(arg[1:], "r") as f:
793                  for line in f.readlines():
794                      new_args += shlex.split(line)
795          else:
796              new_args.append(arg)
797      if expanded:
798          print("esptool %s" % (" ".join(new_args[1:])))
799          return new_args
800      return argv
801  def get_default_connected_device(
802      serial_list,
803      port,
804      connect_attempts,
805      initial_baud,
806      chip="auto",
807      trace=False,
808      before="default_reset",
809  ):
810      _esp = None
811      for each_port in reversed(serial_list):
812          print("Serial port %s" % each_port)
813          try:
814              if chip == "auto":
815                  _esp = detect_chip(
816                      each_port, initial_baud, before, trace, connect_attempts
817                  )
818              else:
819                  chip_class = CHIP_DEFS[chip]
820                  _esp = chip_class(each_port, initial_baud, trace)
821                  _esp.connect(before, connect_attempts)
822              break
823          except (FatalError, OSError) as err:
824              if port is not None:
825                  raise
826              print("%s failed to connect: %s" % (each_port, err))
827              if _esp and _esp._port:
828                  _esp._port.close()
829              _esp = None
830      return _esp
831  class SpiConnectionAction(argparse.Action):
832      def __call__(self, parser, namespace, value, option_string=None):
833          if value.upper() == "SPI":
834              value = 0
835          elif value.upper() == "HSPI":
836              value = 1
837          elif "," in value:
838              values = value.split(",")
839              if len(values) != 5:
840                  raise argparse.ArgumentError(
841                      self,
842                      "%s is not a valid list of comma-separate pin numbers. "
843                      "Must be 5 numbers - CLK,Q,D,HD,CS." % value,
844                  )
845              try:
846                  values = tuple(int(v, 0) for v in values)
847              except ValueError:
848                  raise argparse.ArgumentError(
849                      self,
850                      "%s is not a valid argument. All pins must be numeric values"
851                      % values,
852                  )
853              if any([v for v in values if v > 33 or v < 0]):
854                  raise argparse.ArgumentError(
855                      self, "Pin numbers must be in the range 0-33."
856                  )
857              clk, q, d, hd, cs = values
858              value = (hd << 24) | (cs << 18) | (d << 12) | (q << 6) | clk
859          else:
860              raise argparse.ArgumentError(
861                  self,
862                  "%s is not a valid spi-connection value. "
863                  "Values are SPI, HSPI, or a sequence of 5 pin numbers CLK,Q,D,HD,CS)."
864                  % value,
865              )
866          setattr(namespace, self.dest, value)
867  class AddrFilenamePairAction(argparse.Action):
868      def __init__(self, option_strings, dest, nargs="+", **kwargs):
869          super(AddrFilenamePairAction, self).__init__(
870              option_strings, dest, nargs, **kwargs
871          )
872      def __call__(self, parser, namespace, values, option_string=None):
873          pairs = []
874          for i in range(0, len(values), 2):
875              try:
876                  address = int(values[i], 0)
877              except ValueError:
878                  raise argparse.ArgumentError(
879                      self, 'Address "%s" must be a number' % values[i]
880                  )
881              try:
882                  argfile = open(values[i + 1], "rb")
883              except IOError as e:
884                  raise argparse.ArgumentError(self, e)
885              except IndexError:
886                  raise argparse.ArgumentError(
887                      self,
888                      "Must be pairs of an address "
889                      "and the binary filename to write there",
890                  )
891              pairs.append((address, argfile))
892          end = 0
893          for address, argfile in sorted(pairs, key=lambda x: x[0]):
894              argfile.seek(0, 2)  # seek to end
895              size = argfile.tell()
896              argfile.seek(0)
897              sector_start = address & ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
898              sector_end = (
899                  (address + size + ESPLoader.FLASH_SECTOR_SIZE - 1)
900                  & ~(ESPLoader.FLASH_SECTOR_SIZE - 1)
901              ) - 1
902              if sector_start < end:
903                  message = "Detected overlap at address: 0x%x for file: %s" % (
904                      address,
905                      argfile.name,
906                  )
907                  raise argparse.ArgumentError(self, message)
908              end = sector_end
909          setattr(namespace, self.dest, pairs)
910  def _main():
911      try:
912          main()
913      except FatalError as e:
914          print(f"\nA fatal error occurred: {e}")
915          sys.exit(2)
916      except serial.serialutil.SerialException as e:
917          print(f"\nA serial exception error occurred: {e}")
918          print(
919              "Note: This error originates from pySerial. "
920              "It is likely not a problem with esptool, "
921              "but with the hardware connection or drivers."
922          )
923          print(
924              "For troubleshooting steps visit: "
925              "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html"
926          )
927          sys.exit(1)
928      except StopIteration:
929          print(traceback.format_exc())
930          print("A fatal error occurred: The chip stopped responding.")
931          sys.exit(2)
932  if __name__ == "__main__":
933      _main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___49.py</div>
                </div>
                <div class="column column_space"><pre><code>344          "-o",
345          help="Output filename prefix (for version 1 image), "
346          "or filename (for version 2 single image)",
347          type=str,
348      )
349      parser_elf2image.add_argument(
</pre></code></div>
                <div class="column column_space"><pre><code>508          "size",
509          help="Size of region to erase (must be multiple of 4096). "
510          "Use `ALL` to erase to the end of flash.",
511          type=arg_auto_size,
512      )
513      parser_merge_bin = subparsers.add_parser(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    