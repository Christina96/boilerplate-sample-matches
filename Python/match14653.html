<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for connection_15.py &amp; test_layer2_domain.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for connection_15.py &amp; test_layer2_domain.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>connection_15.py (1.1494253%)<th>test_layer2_domain.py (8.648648%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(34-57)<td><a href="#" name="0">(21-43)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>connection_15.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import xml.sax
import hashlib
import string
import collections
from boto.connection import AWSQueryConnection
from boto.exception import BotoServerError
import boto.mws.exception
import boto.mws.response
from boto.handler import XmlHandler
from boto.compat import filter, map, six, encodebytes
<a name="0"></a>
__all__ = ['MWSConnection']
api_version_path <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
    'Feeds':             ('2009-01-01', 'Merchant', '/'),
    'Reports':           ('2009-01-01', 'Merchant', '/'),
    'Orders':            ('2013-09-01', 'SellerId', '/Orders/2013-09-01'),
    'Products':          ('2011-10-01', 'SellerId', '/Products/2011-10-01'),
    'Sellers':           ('2011-07-01', 'SellerId', '/Sellers/2011-07-01'),
    'Inbound':           ('2010-10-01', 'SellerId',
                          '/FulfillmentInboundShipment/2010-10-01'),
    'Outbound':          ('2010-10-01', 'SellerId',
                          '/FulfillmentOutboundShipment/2010-10-01'),
    'Inventory':         ('2010-10-01', 'SellerId',
                          '/FulfillmentInventory/2010-10-01'),
    'Recommendations':   ('2013-04-01', 'SellerId',
                          '/Recommendations/2013-04-01'),
    'CustomerInfo':      ('2014-03-01', 'SellerId',
                          '/CustomerInformation/2014-03-01'),
    'CartInfo':          ('2014-03-01', 'SellerId',
                          '/CartInformation/2014-03-01'),
    'Subscriptions':     ('2013-07-01', 'SellerId',
                          '/Subscriptions/2013-07-01'),
    'OffAmazonPayments': ('2013-01-01', 'SellerId',
                          '/OffAmazonPayments/2013-01-01'),
}
content_md5 =</b></font> lambda c: encodebytes(hashlib.md5(c).digest()).strip()
decorated_attrs = ('action', 'response', 'section',
                   'quota', 'restore', 'version')
api_call_map = {}
def add_attrs_from(func, to):
    for attr in decorated_attrs:
        setattr(to, attr, getattr(func, attr, None))
    to.__wrapped__ = func
    return to
def structured_lists(*fields):
    def decorator(func):
        def wrapper(self, *args, **kw):
            for key, acc in [f.split('.') for f in fields]:
                if key in kw:
                    newkey = key + '.' + acc + (acc and '.' or '')
                    for i in range(len(kw[key])):
                        kw[newkey + str(i + 1)] = kw[key][i]
                    kw.pop(key)
            return func(self, *args, **kw)
        wrapper.__doc__ = "{0}\nLists: {1}".format(func.__doc__,
                                                   ', '.join(fields))
        return add_attrs_from(func, to=wrapper)
    return decorator
def http_body(field):
    def decorator(func):
        def wrapper(*args, **kw):
            if any([f not in kw for f in (field, 'content_type')]):
                message = "{0} requires {1} and content_type arguments for " \
                          "building HTTP body".format(func.action, field)
                raise KeyError(message)
            kw['body'] = kw.pop(field)
            kw['headers'] = {
                'Content-Type': kw.pop('content_type'),
                'Content-MD5':  content_md5(kw['body']),
            }
            return func(*args, **kw)
        wrapper.__doc__ = "{0}\nRequired HTTP Body: " \
                          "{1}".format(func.__doc__, field)
        return add_attrs_from(func, to=wrapper)
    return decorator
def destructure_object(value, into, prefix, members=False):
    if isinstance(value, boto.mws.response.ResponseElement):
        destructure_object(value.__dict__, into, prefix, members=members)
    elif isinstance(value, collections.Mapping):
        for name in value:
            if name.startswith('_'):
                continue
            destructure_object(value[name], into, prefix + '.' + name,
                               members=members)
    elif isinstance(value, six.string_types):
        into[prefix] = value
    elif isinstance(value, collections.Iterable):
        for index, element in enumerate(value):
            suffix = (members and '.member.' or '.') + str(index + 1)
            destructure_object(element, into, prefix + suffix,
                               members=members)
    elif isinstance(value, bool):
        into[prefix] = str(value).lower()
    else:
        into[prefix] = value
def structured_objects(*fields, **kwargs):
    def decorator(func):
        def wrapper(*args, **kw):
            members = kwargs.get('members', False)
            for field in filter(lambda i: i in kw, fields):
                destructure_object(kw.pop(field), kw, field, members=members)
            return func(*args, **kw)
        wrapper.__doc__ = "{0}\nElement|Iter|Map: {1}\n" \
                          "(ResponseElement or anything iterable/dict-like)" \
                          .format(func.__doc__, ', '.join(fields))
        return add_attrs_from(func, to=wrapper)
    return decorator
def requires(*groups):
    def decorator(func):
        def requires(*args, **kw):
            hasgroup = lambda group: all(key in kw for key in group)
            if 1 != len(list(filter(hasgroup, groups))):
                message = ' OR '.join(['+'.join(g) for g in groups])
                message = "{0} requires {1} argument(s)" \
                          "".format(func.action, message)
                raise KeyError(message)
            return func(*args, **kw)
        message = ' OR '.join(['+'.join(g) for g in groups])
        requires.__doc__ = "{0}\nRequired: {1}".format(func.__doc__,
                                                       message)
        return add_attrs_from(func, to=requires)
    return decorator
def exclusive(*groups):
    def decorator(func):
        def wrapper(*args, **kw):
            hasgroup = lambda group: all(key in kw for key in group)
            if len(list(filter(hasgroup, groups))) not in (0, 1):
                message = ' OR '.join(['+'.join(g) for g in groups])
                message = "{0} requires either {1}" \
                          "".format(func.action, message)
                raise KeyError(message)
            return func(*args, **kw)
        message = ' OR '.join(['+'.join(g) for g in groups])
        wrapper.__doc__ = "{0}\nEither: {1}".format(func.__doc__,
                                                    message)
        return add_attrs_from(func, to=wrapper)
    return decorator
def dependent(field, *groups):
    def decorator(func):
        def wrapper(*args, **kw):
            hasgroup = lambda group: all(key in kw for key in group)
            if field in kw and not any(hasgroup(g) for g in groups):
                message = ' OR '.join(['+'.join(g) for g in groups])
                message = "{0} argument {1} requires {2}" \
                          "".format(func.action, field, message)
                raise KeyError(message)
            return func(*args, **kw)
        message = ' OR '.join(['+'.join(g) for g in groups])
        wrapper.__doc__ = "{0}\n{1} requires: {2}".format(func.__doc__,
                                                          field,
                                                          message)
        return add_attrs_from(func, to=wrapper)
    return decorator
def requires_some_of(*fields):
    def decorator(func):
        def requires(*args, **kw):
            if not any(i in kw for i in fields):
                message = "{0} requires at least one of {1} argument(s)" \
                          "".format(func.action, ', '.join(fields))
                raise KeyError(message)
            return func(*args, **kw)
        requires.__doc__ = "{0}\nSome Required: {1}".format(func.__doc__,
                                                            ', '.join(fields))
        return add_attrs_from(func, to=requires)
    return decorator
def boolean_arguments(*fields):
    def decorator(func):
        def wrapper(*args, **kw):
            for field in [f for f in fields if isinstance(kw.get(f), bool)]:
                kw[field] = str(kw[field]).lower()
            return func(*args, **kw)
        wrapper.__doc__ = "{0}\nBooleans: {1}".format(func.__doc__,
                                                      ', '.join(fields))
        return add_attrs_from(func, to=wrapper)
    return decorator
def api_action(section, quota, restore, *api):
    def decorator(func, quota=int(quota), restore=float(restore)):
        version, accesskey, path = api_version_path[section]
        action = ''.join(api or map(str.capitalize, func.__name__.split('_')))
        def wrapper(self, *args, **kw):
            kw.setdefault(accesskey, getattr(self, accesskey, None))
            if kw[accesskey] is None:
                message = "{0} requires {1} argument. Set the " \
                          "MWSConnection.{2} attribute?" \
                          "".format(action, accesskey, accesskey)
                raise KeyError(message)
            kw['Action'] = action
            kw['Version'] = version
            response = self._response_factory(action, connection=self)
            request = dict(path=path, quota=quota, restore=restore)
            return func(self, request, response, *args, **kw)
        for attr in decorated_attrs:
            setattr(wrapper, attr, locals().get(attr))
        wrapper.__doc__ = "MWS {0}/{1} API call; quota={2} restore={3:.2f}\n" \
                          "{4}".format(action, version, quota, restore,
                                       func.__doc__)
        api_call_map[action] = func.__name__
        return wrapper
    return decorator
class MWSConnection(AWSQueryConnection):
    ResponseFactory = boto.mws.response.ResponseFactory
    ResponseErrorFactory = boto.mws.exception.ResponseErrorFactory
    def __init__(self, *args, **kw):
        kw.setdefault('host', 'mws.amazonservices.com')
        self._sandboxed = kw.pop('sandbox', False)
        self.Merchant = kw.pop('Merchant', None) or kw.get('SellerId')
        self.SellerId = kw.pop('SellerId', None) or self.Merchant
        kw = self._setup_factories(kw.pop('factory_scopes', []), **kw)
        super(MWSConnection, self).__init__(*args, **kw)
    def _setup_factories(self, extrascopes, **kw):
        for factory, (scope, Default) in {
            'response_factory':
                (boto.mws.response, self.ResponseFactory),
            'response_error_factory':
                (boto.mws.exception, self.ResponseErrorFactory),
        }.items():
            if factory in kw:
                setattr(self, '_' + factory, kw.pop(factory))
            else:
                scopes = extrascopes + [scope]
                setattr(self, '_' + factory, Default(scopes=scopes))
        return kw
    def _sandboxify(self, path):
        if not self._sandboxed:
            return path
        splat = path.split('/')
        splat[-2] += '_Sandbox'
        return '/'.join(splat)
    def _required_auth_capability(self):
        return ['mws']
    def _post_request(self, request, params, parser, body='', headers=None):
        headers = headers or {}
        path = self._sandboxify(request['path'])
        request = self.build_base_http_request('POST', path, None, data=body,
                                               params=params, headers=headers,
                                               host=self.host)
        try:
            response = self._mexe(request, override_num_retries=None)
        except BotoServerError as bs:
            raise self._response_error_factory(bs.status, bs.reason, bs.body)
        body = response.read()
        boto.log.debug(body)
        if not body:
            boto.log.error('Null body %s' % body)
            raise self._response_error_factory(response.status,
                                               response.reason, body)
        if response.status != 200:
            boto.log.error('%s %s' % (response.status, response.reason))
            boto.log.error('%s' % body)
            raise self._response_error_factory(response.status,
                                               response.reason, body)
        digest = response.getheader('Content-MD5')
        if digest is not None:
            assert content_md5(body) == digest
        contenttype = response.getheader('Content-Type')
        return self._parse_response(parser, contenttype, body)
    def _parse_response(self, parser, contenttype, body):
        if not contenttype.startswith('text/xml'):
            return body
        handler = XmlHandler(parser, self)
        xml.sax.parseString(body, handler)
        return parser
    def method_for(self, name):
        action = '_' in name and string.capwords(name, '_') or name
        if action in api_call_map:
            return getattr(self, api_call_map[action])
        return None
    def iter_call(self, call, *args, **kw):
        method = self.method_for(call)
        assert method, 'No call named "{0}"'.format(call)
        return self.iter_response(method(*args, **kw))
    def iter_response(self, response):
        yield response
        more = self.method_for(response._action + 'ByNextToken')
        while more and response._result.HasNext == 'true':
            response = more(NextToken=response._result.NextToken)
            yield response
    @requires(['FeedType'])
    @boolean_arguments('PurgeAndReplace')
    @http_body('FeedContent')
    @structured_lists('MarketplaceIdList.Id')
    @api_action('Feeds', 15, 120)
    def submit_feed(self, request, response, headers=None, body='', **kw):
        headers = headers or {}
        return self._post_request(request, kw, response, body=body,
                                  headers=headers)
    @structured_lists('FeedSubmissionIdList.Id', 'FeedTypeList.Type',
                      'FeedProcessingStatusList.Status')
    @api_action('Feeds', 10, 45)
    def get_feed_submission_list(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Feeds', 0, 0)
    def get_feed_submission_list_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @structured_lists('FeedTypeList.Type', 'FeedProcessingStatusList.Status')
    @api_action('Feeds', 10, 45)
    def get_feed_submission_count(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @structured_lists('FeedSubmissionIdList.Id', 'FeedTypeList.Type')
    @api_action('Feeds', 10, 45)
    def cancel_feed_submissions(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['FeedSubmissionId'])
    @api_action('Feeds', 15, 60)
    def get_feed_submission_result(self, request, response, **kw):
        return self._post_request(request, kw, response)
    def get_service_status(self, **kw):
        sections = ', '.join(map(str.lower, api_version_path.keys()))
        message = "Use {0}.get_(section)_service_status(), " \
                  "where (section) is one of the following: " \
                  "{1}".format(self.__class__.__name__, sections)
        raise AttributeError(message)
    @requires(['ReportType'])
    @structured_lists('MarketplaceIdList.Id')
    @boolean_arguments('ReportOptions=ShowSalesChannel')
    @api_action('Reports', 15, 60)
    def request_report(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @structured_lists('ReportRequestIdList.Id', 'ReportTypeList.Type',
                      'ReportProcessingStatusList.Status')
    @api_action('Reports', 10, 45)
    def get_report_request_list(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Reports', 0, 0)
    def get_report_request_list_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @structured_lists('ReportTypeList.Type',
                      'ReportProcessingStatusList.Status')
    @api_action('Reports', 10, 45)
    def get_report_request_count(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Reports', 10, 45)
    def cancel_report_requests(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @boolean_arguments('Acknowledged')
    @structured_lists('ReportRequestIdList.Id', 'ReportTypeList.Type')
    @api_action('Reports', 10, 60)
    def get_report_list(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Reports', 0, 0)
    def get_report_list_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @boolean_arguments('Acknowledged')
    @structured_lists('ReportTypeList.Type')
    @api_action('Reports', 10, 45)
    def get_report_count(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['ReportId'])
    @api_action('Reports', 15, 60)
    def get_report(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['ReportType', 'Schedule'])
    @api_action('Reports', 10, 45)
    def manage_report_schedule(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @structured_lists('ReportTypeList.Type')
    @api_action('Reports', 10, 45)
    def get_report_schedule_list(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Reports', 0, 0)
    def get_report_schedule_list_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @structured_lists('ReportTypeList.Type')
    @api_action('Reports', 10, 45)
    def get_report_schedule_count(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['ReportIdList'])
    @boolean_arguments('Acknowledged')
    @structured_lists('ReportIdList.Id')
    @api_action('Reports', 10, 45)
    def update_report_acknowledgements(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['ShipFromAddress', 'InboundShipmentPlanRequestItems'])
    @structured_objects('ShipFromAddress', 'InboundShipmentPlanRequestItems')
    @api_action('Inbound', 30, 0.5)
    def create_inbound_shipment_plan(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['ShipmentId', 'InboundShipmentHeader', 'InboundShipmentItems'])
    @structured_objects('InboundShipmentHeader', 'InboundShipmentItems')
    @api_action('Inbound', 30, 0.5)
    def create_inbound_shipment(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['ShipmentId'])
    @structured_objects('InboundShipmentHeader', 'InboundShipmentItems')
    @api_action('Inbound', 30, 0.5)
    def update_inbound_shipment(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires_some_of('ShipmentIdList', 'ShipmentStatusList')
    @structured_lists('ShipmentIdList.Id', 'ShipmentStatusList.Status')
    @api_action('Inbound', 30, 0.5)
    def list_inbound_shipments(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Inbound', 30, 0.5)
    def list_inbound_shipments_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['ShipmentId'], ['LastUpdatedAfter', 'LastUpdatedBefore'])
    @api_action('Inbound', 30, 0.5)
    def list_inbound_shipment_items(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Inbound', 30, 0.5)
    def list_inbound_shipment_items_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Inbound', 2, 300, 'GetServiceStatus')
    def get_inbound_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['SellerSkus'], ['QueryStartDateTime'])
    @structured_lists('SellerSkus.member')
    @api_action('Inventory', 30, 0.5)
    def list_inventory_supply(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Inventory', 30, 0.5)
    def list_inventory_supply_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Inventory', 2, 300, 'GetServiceStatus')
    def get_inventory_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['PackageNumber'])
    @api_action('Outbound', 30, 0.5)
    def get_package_tracking_details(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['Address', 'Items'])
    @structured_objects('Address', 'Items')
    @api_action('Outbound', 30, 0.5)
    def get_fulfillment_preview(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['SellerFulfillmentOrderId', 'DisplayableOrderId',
               'ShippingSpeedCategory',    'DisplayableOrderDateTime',
               'DestinationAddress',       'DisplayableOrderComment',
               'Items'])
    @structured_objects('DestinationAddress', 'Items')
    @api_action('Outbound', 30, 0.5)
    def create_fulfillment_order(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['SellerFulfillmentOrderId'])
    @api_action('Outbound', 30, 0.5)
    def get_fulfillment_order(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Outbound', 30, 0.5)
    def list_all_fulfillment_orders(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Outbound', 30, 0.5)
    def list_all_fulfillment_orders_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['SellerFulfillmentOrderId'])
    @api_action('Outbound', 30, 0.5)
    def cancel_fulfillment_order(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Outbound', 2, 300, 'GetServiceStatus')
    def get_outbound_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['CreatedAfter'], ['LastUpdatedAfter'])
    @requires(['MarketplaceId'])
    @exclusive(['CreatedAfter'], ['LastUpdatedAfter'])
    @dependent('CreatedBefore', ['CreatedAfter'])
    @exclusive(['LastUpdatedAfter'], ['BuyerEmail'], ['SellerOrderId'])
    @dependent('LastUpdatedBefore', ['LastUpdatedAfter'])
    @exclusive(['CreatedAfter'], ['LastUpdatedBefore'])
    @structured_objects('OrderTotal', 'ShippingAddress',
                        'PaymentExecutionDetail')
    @structured_lists('MarketplaceId.Id', 'OrderStatus.Status',
                      'FulfillmentChannel.Channel', 'PaymentMethod.')
    @api_action('Orders', 6, 60)
    def list_orders(self, request, response, **kw):
        toggle = set(('FulfillmentChannel.Channel.1',
                      'OrderStatus.Status.1', 'PaymentMethod.1',
                      'LastUpdatedAfter', 'LastUpdatedBefore'))
        for do, dont in {
            'BuyerEmail': toggle.union(['SellerOrderId']),
            'SellerOrderId': toggle.union(['BuyerEmail']),
        }.items():
            if do in kw and any(i in dont for i in kw):
                message = "Don't include {0} when specifying " \
                          "{1}".format(' or '.join(dont), do)
                raise AssertionError(message)
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Orders', 6, 60)
    def list_orders_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderId'])
    @structured_lists('AmazonOrderId.Id')
    @api_action('Orders', 6, 60)
    def get_order(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderId'])
    @api_action('Orders', 30, 2)
    def list_order_items(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Orders', 30, 2)
    def list_order_items_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Orders', 2, 300, 'GetServiceStatus')
    def get_orders_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'Query'])
    @api_action('Products', 20, 20)
    def list_matching_products(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'ASINList'])
    @structured_lists('ASINList.ASIN')
    @api_action('Products', 20, 20)
    def get_matching_product(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'IdType', 'IdList'])
    @structured_lists('IdList.Id')
    @api_action('Products', 20, 20)
    def get_matching_product_for_id(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'SellerSKUList'])
    @structured_lists('SellerSKUList.SellerSKU')
    @api_action('Products', 20, 10, 'GetCompetitivePricingForSKU')
    def get_competitive_pricing_for_sku(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'ASINList'])
    @structured_lists('ASINList.ASIN')
    @api_action('Products', 20, 10, 'GetCompetitivePricingForASIN')
    def get_competitive_pricing_for_asin(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'SellerSKUList'])
    @structured_lists('SellerSKUList.SellerSKU')
    @api_action('Products', 20, 5, 'GetLowestOfferListingsForSKU')
    def get_lowest_offer_listings_for_sku(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'ASINList'])
    @structured_lists('ASINList.ASIN')
    @api_action('Products', 20, 5, 'GetLowestOfferListingsForASIN')
    def get_lowest_offer_listings_for_asin(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'SellerSKU'])
    @api_action('Products', 20, 20, 'GetProductCategoriesForSKU')
    def get_product_categories_for_sku(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'ASIN'])
    @api_action('Products', 20, 20, 'GetProductCategoriesForASIN')
    def get_product_categories_for_asin(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Products', 2, 300, 'GetServiceStatus')
    def get_products_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'SellerSKUList'])
    @structured_lists('SellerSKUList.SellerSKU')
    @api_action('Products', 20, 10, 'GetMyPriceForSKU')
    def get_my_price_for_sku(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'ASINList'])
    @structured_lists('ASINList.ASIN')
    @api_action('Products', 20, 10, 'GetMyPriceForASIN')
    def get_my_price_for_asin(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Sellers', 15, 60)
    def list_marketplace_participations(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Sellers', 15, 60)
    def list_marketplace_participations_by_next_token(self, request, response,
                                                      **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId'])
    @api_action('Recommendations', 5, 2)
    def get_last_updated_time_for_recommendations(self, request, response,
                                                  **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId'])
    @structured_lists('CategoryQueryList.CategoryQuery')
    @api_action('Recommendations', 5, 2)
    def list_recommendations(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('Recommendations', 5, 2)
    def list_recommendations_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Recommendations', 2, 300, 'GetServiceStatus')
    def get_recommendations_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('CustomerInfo', 15, 12)
    def list_customers(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('CustomerInfo', 50, 3)
    def list_customers_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['CustomerIdList'])
    @structured_lists('CustomerIdList.CustomerId')
    @api_action('CustomerInfo', 15, 12)
    def get_customers_for_customer_id(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('CustomerInfo', 2, 300, 'GetServiceStatus')
    def get_customerinfo_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['DateRangeStart'])
    @api_action('CartInfo', 15, 12)
    def list_carts(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['NextToken'])
    @api_action('CartInfo', 50, 3)
    def list_carts_by_next_token(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['CartIdList'])
    @structured_lists('CartIdList.CartId')
    @api_action('CartInfo', 15, 12)
    def get_carts(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('CartInfo', 2, 300, 'GetServiceStatus')
    def get_cartinfo_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'Destination'])
    @structured_objects('Destination', members=True)
    @api_action('Subscriptions', 25, 0.5)
    def register_destination(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'Destination'])
    @structured_objects('Destination', members=True)
    @api_action('Subscriptions', 25, 0.5)
    def deregister_destination(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId'])
    @api_action('Subscriptions', 25, 0.5)
    def list_registered_destinations(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'Destination'])
    @structured_objects('Destination', members=True)
    @api_action('Subscriptions', 25, 0.5)
    def send_test_notification_to_destination(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'Subscription'])
    @structured_objects('Subscription', members=True)
    @api_action('Subscriptions', 25, 0.5)
    def create_subscription(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'NotificationType', 'Destination'])
    @structured_objects('Destination', members=True)
    @api_action('Subscriptions', 25, 0.5)
    def get_subscription(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'NotificationType', 'Destination'])
    @structured_objects('Destination', members=True)
    @api_action('Subscriptions', 25, 0.5)
    def delete_subscription(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId'])
    @api_action('Subscriptions', 25, 0.5)
    def list_subscriptions(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['MarketplaceId', 'Subscription'])
    @structured_objects('Subscription', members=True)
    @api_action('Subscriptions', 25, 0.5)
    def update_subscription(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('Subscriptions', 2, 300, 'GetServiceStatus')
    def get_subscriptions_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderReferenceId', 'OrderReferenceAttributes'])
    @structured_objects('OrderReferenceAttributes')
    @api_action('OffAmazonPayments', 10, 1)
    def set_order_reference_details(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderReferenceId'])
    @api_action('OffAmazonPayments', 20, 2)
    def get_order_reference_details(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderReferenceId'])
    @api_action('OffAmazonPayments', 10, 1)
    def confirm_order_reference(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderReferenceId'])
    @api_action('OffAmazonPayments', 10, 1)
    def cancel_order_reference(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderReferenceId'])
    @api_action('OffAmazonPayments', 10, 1)
    def close_order_reference(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonOrderReferenceId', 'AuthorizationReferenceId',
               'AuthorizationAmount'])
    @structured_objects('AuthorizationAmount')
    @api_action('OffAmazonPayments', 10, 1)
    def authorize(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonAuthorizationId'])
    @api_action('OffAmazonPayments', 20, 2)
    def get_authorization_details(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonAuthorizationId', 'CaptureReferenceId', 'CaptureAmount'])
    @structured_objects('CaptureAmount')
    @api_action('OffAmazonPayments', 10, 1)
    def capture(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonCaptureId'])
    @api_action('OffAmazonPayments', 20, 2)
    def get_capture_details(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonAuthorizationId'])
    @api_action('OffAmazonPayments', 10, 1)
    def close_authorization(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonCaptureId', 'RefundReferenceId', 'RefundAmount'])
    @structured_objects('RefundAmount')
    @api_action('OffAmazonPayments', 10, 1)
    def refund(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @requires(['AmazonRefundId'])
    @api_action('OffAmazonPayments', 20, 2)
    def get_refund_details(self, request, response, **kw):
        return self._post_request(request, kw, response)
    @api_action('OffAmazonPayments', 2, 300, 'GetServiceStatus')
    def get_offamazonpayments_service_status(self, request, response, **kw):
        return self._post_request(request, kw, response)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_layer2_domain.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import boto.swf.layer2
from boto.swf.layer2 import Domain, ActivityType, WorkflowType, WorkflowExecution
from tests.unit import unittest
from mock import Mock
class TestDomain(unittest.TestCase):
    def setUp(self):
        boto.swf.layer2.Layer1 = Mock()
        self.domain = Domain(name='test-domain', description='My test domain')
        self.domain.aws_access_key_id = 'inheritable access key'
        self.domain.aws_secret_access_key = 'inheritable secret key'
        self.domain.region = 'test-region'
    def test_domain_instantiation(self):
        self.assertEquals('test-domain', self.domain.name)
<a name="0"></a>        self.assertEquals('My test domain', self.domain.description)
    def test_domain_list_activities(self):
        self.domain._swf.list_activity_types.return_value <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= {
            'typeInfos': [{'activityType': {'name': 'DeleteLocalFile',
                             'version': '1.0'},
            'creationDate': 1332853651.235,
            'status': 'REGISTERED'},
           {'activityType': {'name': 'DoUpdate', 'version': 'test'},
            'creationDate': 1333463734.528,
            'status': 'REGISTERED'},
           {'activityType': {'name': 'GrayscaleTransform',
                             'version': '1.0'},
            'creationDate': 1332853651.18,
            'status': 'REGISTERED'},
           {'activityType': {'name': 'S3Download', 'version': '1.0'},
            'creationDate': 1332853651.264,
            'status': 'REGISTERED'},
           {'activityType': {'name': 'S3Upload', 'version': '1.0'},
            'creationDate': 1332853651.314,
            'status': 'REGISTERED'},
           {'activityType': {'name': 'SepiaTransform', 'version': '1.1'},
            'creationDate': 1333373797.734,
            'status': 'REGISTERED'}]} 
        expected_names =</b></font> ('DeleteLocalFile', 'GrayscaleTransform', 'S3Download', 
                          'S3Upload', 'SepiaTransform', 'DoUpdate')
        activity_types = self.domain.activities()
        self.assertEquals(6, len(activity_types))
        for activity_type in activity_types:
            self.assertIsInstance(activity_type, ActivityType)
            self.assertTrue(activity_type.name in expected_names)
            self.assertEquals(self.domain.region, activity_type.region)
    def test_domain_list_workflows(self):
        self.domain._swf.list_workflow_types.return_value = {
            'typeInfos': [{'creationDate': 1332853651.136,
                'description': 'Image processing sample workflow type',
                'status': 'REGISTERED',
                'workflowType': {'name': 'ProcessFile', 'version': '1.0'}},
               {'creationDate': 1333551719.89,
                'status': 'REGISTERED',
                'workflowType': {'name': 'test_workflow_name',
                                 'version': 'v1'}}]}
        expected_names = ('ProcessFile', 'test_workflow_name') 
        workflow_types = self.domain.workflows()
        self.assertEquals(2, len(workflow_types))
        for workflow_type in workflow_types:
            self.assertIsInstance(workflow_type, WorkflowType)
            self.assertTrue(workflow_type.name in expected_names)
            self.assertEquals(self.domain.aws_access_key_id, workflow_type.aws_access_key_id)
            self.assertEquals(self.domain.aws_secret_access_key, workflow_type.aws_secret_access_key)
            self.assertEquals(self.domain.name, workflow_type.domain)
            self.assertEquals(self.domain.region, workflow_type.region)
    def test_domain_list_executions(self):
        self.domain._swf.list_open_workflow_executions.return_value = {
            'executionInfos': [{'cancelRequested': False,
                     'execution': {'runId': '12OeDTyoD27TDaafViz/QIlCHrYzspZmDgj0coIfjm868=',
                                   'workflowId': 'ProcessFile-1.0-1378933928'},
                     'executionStatus': 'OPEN',
                     'startTimestamp': 1378933928.676,
                     'workflowType': {'name': 'ProcessFile',
                                      'version': '1.0'}},
                    {'cancelRequested': False,
                     'execution': {'runId': '12GwBkx4hH6t2yaIh8LYxy5HyCM6HcyhDKePJCg0/ciJk=',
                                   'workflowId': 'ProcessFile-1.0-1378933927'},
                     'executionStatus': 'OPEN',
                     'startTimestamp': 1378933927.919,
                     'workflowType': {'name': 'ProcessFile',
                                      'version': '1.0'}},
                    {'cancelRequested': False,
                     'execution': {'runId': '12oRG3vEWrQ7oYBV+Bqi33Fht+ZRCYTt+tOdn5kLVcwKI=',
                                   'workflowId': 'ProcessFile-1.0-1378933926'},
                     'executionStatus': 'OPEN',
                     'startTimestamp': 1378933927.04,
                     'workflowType': {'name': 'ProcessFile',
                                      'version': '1.0'}},
                    {'cancelRequested': False,
                     'execution': {'runId': '12qrdcpYmad2cjnqJcM4Njm3qrCGvmRFR1wwQEt+a2ako=',
                                   'workflowId': 'ProcessFile-1.0-1378933874'},
                     'executionStatus': 'OPEN',
                     'startTimestamp': 1378933874.956,
                     'workflowType': {'name': 'ProcessFile',
                                      'version': '1.0'}}]}
        executions = self.domain.executions()
        self.assertEquals(4, len(executions))
        for wf_execution in executions:
            self.assertIsInstance(wf_execution, WorkflowExecution)
            self.assertEquals(self.domain.aws_access_key_id, wf_execution.aws_access_key_id)
            self.assertEquals(self.domain.aws_secret_access_key, wf_execution.aws_secret_access_key)
            self.assertEquals(self.domain.name, wf_execution.domain)
            self.assertEquals(self.domain.region, wf_execution.region)
if __name__ == '__main__':
    unittest.main()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
