
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 31.899641577060933%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-axis_norm.py</h3>
            <pre><code>1  import collections.abc
2  from typing import Optional
3  from sonnet.src import base
4  from sonnet.src import initializers
5  from sonnet.src import once
6  from sonnet.src import types
7  from sonnet.src import utils
8  import tensorflow as tf
9  class LayerNorm(base.Module):
10    r
11    def __init__(self,
12                 axis: types.Axis,
13                 create_scale: bool,
14                 create_offset: bool,
15                 eps: types.FloatLike = 1e-5,
16                 scale_init: Optional[initializers.Initializer] = None,
17                 offset_init: Optional[initializers.Initializer] = None,
18                 data_format: str = "channels_last",
19                 name: Optional[str] = None):
20      r
21      super().__init__(name=name)
22      if isinstance(axis, slice):
23        self._axis = axis
24      elif isinstance(axis, int):
25        self._axis = (axis,)
26      elif (isinstance(axis, collections.abc.Iterable) and
27            all(isinstance(ax, int) for ax in axis)):
28        self._axis = axis
29      else:
30        raise ValueError("`axis` should be an int, slice or iterable of ints.")
31      self._eps = eps
<span onclick='openModal()' class='match'>32      self._data_format = data_format
33      self._channel_index = utils.get_channel_index(data_format)
34      self._rank = None
35      self._create_scale = create_scale
</span>36      self._create_offset = create_offset
37      if self._create_scale:
38        self._scale_init = (
39            scale_init if scale_init is not None else initializers.Ones())
40      elif scale_init is not None:
41        raise ValueError("Cannot set `scale_init` if `create_scale=False`.")
42      if self._create_offset:
43        self._offset_init = (
44            offset_init if offset_init is not None else initializers.Zeros())
45      elif offset_init is not None:
46        raise ValueError("Cannot set `offset_init` if `create_offset=False`.")
47    def __call__(self,
48                 inputs: tf.Tensor,
49                 scale: Optional[tf.Tensor] = None,
50                 offset: Optional[tf.Tensor] = None) -> tf.Tensor:
51      self._initialize(inputs)
52      if self._create_scale:
53        if scale is not None:
54          raise ValueError(
55              "Cannot pass `scale` at call time if `create_scale=True`.")
56        scale = self.scale
57      if self._create_offset:
58        if offset is not None:
59          raise ValueError(
60              "Cannot pass `offset` at call time if `create_offset=True`.")
61        offset = self.offset
62      if len(inputs.shape) != self._rank:
63        raise ValueError(
64            "The rank of the inputs cannot change between calls, the"
65            " original call was rank={} but this call was rank={}.".format(
66                self._rank, len(inputs.shape)))
67      mean, var = tf.nn.moments(inputs, self._axis, keepdims=True)
68      normalized = tf.nn.batch_normalization(
69          inputs,
70          mean=mean,
71          variance=var,
72          scale=scale,
73          offset=offset,
74          variance_epsilon=self._eps)
75      return normalized
76    @once.once
77    def _initialize(self, inputs: tf.Tensor):
78      self._rank = len(inputs.shape)
79      if isinstance(self._axis, slice):
80        axes = tuple(range(self._rank))
81        self._axis = axes[self._axis]
82      dtype = inputs.dtype
83      if self._channel_index == -1:
84        params_shape = [inputs.shape[-1]]
85      else:  # self._channel_index == 1
86        params_shape = [inputs.shape[1]] + [1] * (self._rank - 2)
87      if self._create_scale:
88        self.scale = tf.Variable(
89            self._scale_init(params_shape, dtype), name="scale")
90      else:
91        self.scale = None
92      if self._create_offset:
93        self.offset = tf.Variable(
94            self._offset_init(params_shape, dtype), name="offset")
95      else:
96        self.offset = None
97  class InstanceNorm(LayerNorm):
98    def __init__(self,
99                 create_scale: bool,
100                 create_offset: bool,
101                 eps: types.FloatLike = 1e-5,
102                 scale_init: Optional[initializers.Initializer] = None,
103                 offset_init: Optional[initializers.Initializer] = None,
104                 data_format: str = "channels_last",
105                 name: Optional[str] = None):
106      if utils.get_channel_index(data_format) == 1:
107        axis = slice(2, None)
108      else:  # channel_index = -1
109        axis = slice(1, -1)
110      super().__init__(
111          axis=axis,
112          create_scale=create_scale,
113          create_offset=create_offset,
114          eps=eps,
115          scale_init=scale_init,
116          offset_init=offset_init,
117          data_format=data_format,
118          name=name)
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv.py</h3>
            <pre><code>1  from typing import Optional, Sequence, Union
2  import numpy as np
3  from sonnet.src import base
4  from sonnet.src import initializers
5  from sonnet.src import once
6  from sonnet.src import pad
7  from sonnet.src import utils
8  import tensorflow as tf
9  class ConvND(base.Module):
10    def __init__(self,
11                 num_spatial_dims: int,
12                 output_channels: int,
13                 kernel_shape: Union[int, Sequence[int]],
14                 stride: Union[int, Sequence[int]] = 1,
15                 rate: Union[int, Sequence[int]] = 1,
16                 padding: Union[str, pad.Paddings] = "SAME",
17                 with_bias: bool = True,
18                 w_init: Optional[initializers.Initializer] = None,
19                 b_init: Optional[initializers.Initializer] = None,
20                 data_format: Optional[str] = None,
21                 name: Optional[str] = None):
22      super().__init__(name=name)
23      if not 1 <= num_spatial_dims <= 3:
24        raise ValueError(
25            "We only support convoltion operations for num_spatial_dims=1, 2 or "
26            "3, received num_spatial_dims={}.".format(num_spatial_dims))
27      self._num_spatial_dims = num_spatial_dims
28      self.output_channels = output_channels
29      self.kernel_shape = kernel_shape
30      self.stride = stride
31      self.rate = rate
32      if isinstance(padding, str):
33        self.conv_padding = padding.upper()
34        self.padding_func = None
35      else:
36        self.conv_padding = "VALID"
37        self.padding_func = padding
<span onclick='openModal()' class='match'>38      self.data_format = data_format
39      self._channel_index = utils.get_channel_index(data_format)
40      self.with_bias = with_bias
41      self.w_init = w_init
</span>42      if with_bias:
43        self.b_init = b_init if b_init is not None else initializers.Zeros()
44      elif b_init is not None:
45        raise ValueError("When not using a bias the b_init must be None.")
46    def __call__(self, inputs: tf.Tensor) -> tf.Tensor:
47      self._initialize(inputs)
48      if self.padding_func:
49        inputs = tf.pad(inputs, self._padding)
50      outputs = tf.nn.convolution(
51          inputs,
52          self.w,
53          strides=self.stride,
54          padding=self.conv_padding,
55          dilations=self.rate,
56          data_format=self.data_format)
57      if self.with_bias:
58        outputs = tf.nn.bias_add(outputs, self.b, data_format=self.data_format)
59      return outputs
60    @once.once
61    def _initialize(self, inputs: tf.Tensor):
62      utils.assert_rank(inputs, self._num_spatial_dims + 2)
63      self.input_channels = inputs.shape[self._channel_index]
64      if self.input_channels is None:
65        raise ValueError("The number of input channels must be known.")
66      self._dtype = inputs.dtype
67      self.w = self._make_w()
68      if self.with_bias:
69        self.b = tf.Variable(
70            self.b_init((self.output_channels,), self._dtype), name="b")
71      if self.padding_func:
72        self._padding = pad.create(
73            padding=self.padding_func,
74            kernel=self.kernel_shape,
75            rate=self.rate,
76            n=self._num_spatial_dims,
77            channel_index=self._channel_index)
78    def _make_w(self):
79      weight_shape = utils.replicate(self.kernel_shape, self._num_spatial_dims,
80                                     "kernel_shape")
81      weight_shape = weight_shape + (self.input_channels, self.output_channels)
82      if self.w_init is None:
83        fan_in_shape = weight_shape[:-1]
84        stddev = 1 / np.sqrt(np.prod(fan_in_shape))
85        self.w_init = initializers.TruncatedNormal(stddev=stddev)
86      return tf.Variable(self.w_init(weight_shape, self._dtype), name="w")
87  class Conv1D(ConvND):
88    def __init__(self,
89                 output_channels: int,
90                 kernel_shape: Union[int, Sequence[int]],
91                 stride: Union[int, Sequence[int]] = 1,
92                 rate: Union[int, Sequence[int]] = 1,
93                 padding: Union[str, pad.Paddings] = "SAME",
94                 with_bias: bool = True,
95                 w_init: Optional[initializers.Initializer] = None,
96                 b_init: Optional[initializers.Initializer] = None,
97                 data_format: str = "NWC",
98                 name: Optional[str] = None):
99      super().__init__(
100          num_spatial_dims=1,
101          output_channels=output_channels,
102          kernel_shape=kernel_shape,
103          stride=stride,
104          rate=rate,
105          padding=padding,
106          with_bias=with_bias,
107          w_init=w_init,
108          b_init=b_init,
109          data_format=data_format,
110          name=name)
111  class Conv2D(ConvND):
112    def __init__(self,
113                 output_channels: int,
114                 kernel_shape: Union[int, Sequence[int]],
115                 stride: Union[int, Sequence[int]] = 1,
116                 rate: Union[int, Sequence[int]] = 1,
117                 padding: Union[str, pad.Paddings] = "SAME",
118                 with_bias: bool = True,
119                 w_init: Optional[initializers.Initializer] = None,
120                 b_init: Optional[initializers.Initializer] = None,
121                 data_format: str = "NHWC",
122                 name: Optional[str] = None):
123      super().__init__(
124          num_spatial_dims=2,
125          output_channels=output_channels,
126          kernel_shape=kernel_shape,
127          stride=stride,
128          rate=rate,
129          padding=padding,
130          with_bias=with_bias,
131          w_init=w_init,
132          b_init=b_init,
133          data_format=data_format,
134          name=name)
135  class Conv3D(ConvND):
136    def __init__(self,
137                 output_channels: int,
138                 kernel_shape: Union[int, Sequence[int]],
139                 stride: Union[int, Sequence[int]] = 1,
140                 rate: Union[int, Sequence[int]] = 1,
141                 padding: Union[str, pad.Paddings] = "SAME",
142                 with_bias: bool = True,
143                 w_init: Optional[initializers.Initializer] = None,
144                 b_init: Optional[initializers.Initializer] = None,
145                 data_format: str = "NDHWC",
146                 name: Optional[str] = None):
147      super().__init__(
148          num_spatial_dims=3,
149          output_channels=output_channels,
150          kernel_shape=kernel_shape,
151          stride=stride,
152          rate=rate,
153          padding=padding,
154          with_bias=with_bias,
155          w_init=w_init,
156          b_init=b_init,
157          data_format=data_format,
158          name=name)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-axis_norm.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-conv.py</div>
                </div>
                <div class="column column_space"><pre><code>32      self._data_format = data_format
33      self._channel_index = utils.get_channel_index(data_format)
34      self._rank = None
35      self._create_scale = create_scale
</pre></code></div>
                <div class="column column_space"><pre><code>38      self.data_format = data_format
39      self._channel_index = utils.get_channel_index(data_format)
40      self.with_bias = with_bias
41      self.w_init = w_init
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    