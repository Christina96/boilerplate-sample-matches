<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_nilrt_ip_1.py &amp; boto_s3_bucket.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_nilrt_ip_1.py &amp; boto_s3_bucket.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_nilrt_ip_1.py (1.7391304%)<th>boto_s3_bucket.py (1.734104%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(222-226)<td><a href="#" name="0">(533-551)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_nilrt_ip_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import configparser
2 import re
3 import shutil
4 import time
5 import pytest
6 import salt.modules.nilrt_ip as ip
7 import salt.utils.files
8 import salt.utils.platform
9 from tests.support.case import ModuleCase
10 from tests.support.helpers import requires_system_grains, runs_on
11 from tests.support.unit import skipIf
12 try:
13     import pyiface
14     from pyiface.ifreqioctls import IFF_LOOPBACK, IFF_RUNNING
15 except ImportError:
16     pyiface = None
17 try:
18     from requests.structures import CaseInsensitiveDict
19 except ImportError:
20     CaseInsensitiveDict = None
21 INTERFACE_FOR_TEST = "eth1"
22 @pytest.mark.skip_if_not_root
23 @skipIf(not pyiface, "The python pyiface package is not installed")
24 @skipIf(not CaseInsensitiveDict, "The python package requests is not installed")
25 @runs_on(os_family="NILinuxRT", reason="Tests applicable only to NILinuxRT")
26 @pytest.mark.destructive_test
27 class NilrtIpModuleTest(ModuleCase):
28     @requires_system_grains
29     @classmethod
30     def setUpClass(cls, grains):  # pylint: disable=arguments-differ
31         cls.initialState = {}
32         cls.grains = grains
33     @classmethod
34     def tearDownClass(cls):
35         cls.initialState = cls.grains = None
36     @staticmethod
37     def setup_loader_modules():
38         return {ip: {}}
39     def setUp(self):
40         super().setUp()
41         if self.grains["lsb_distrib_id"] == "nilrt":
42             shutil.move("/etc/natinst/share/ni-rt.ini", "/tmp/ni-rt.ini")
43         else:
44             shutil.move("/var/lib/connman", "/tmp/connman")
45     def tearDown(self):
46         if self.grains["lsb_distrib_id"] == "nilrt":
47             shutil.move("/tmp/ni-rt.ini", "/etc/natinst/share/ni-rt.ini")
48             self.run_function("cmd.run", ["/etc/init.d/networking restart"])
49         else:
50             shutil.move("/tmp/connman", "/var/lib/connman")
51             self.run_function("service.restart", ["connman"])
52         time.sleep(10)  # wait 10 seconds for connman to be fully loaded
53         interfaces = self.__interfaces()
54         for interface in interfaces:
55             self.run_function("ip.up", [interface.name])
56     @staticmethod
57     def __connected(interface):
58         return interface.flags &amp; IFF_RUNNING != 0
59     @staticmethod
60     def __interfaces():
61         return [
62             interface
63             for interface in pyiface.getIfaces()
64             if interface.flags &amp; IFF_LOOPBACK == 0
65         ]
66     def __check_ethercat(self):
67         if self.grains["lsb_distrib_id"] != "nilrt":
68             return False
69         with salt.utils.files.fopen("/etc/natinst/share/ni-rt.ini", "r") as config_file:
70             config_parser = configparser.RawConfigParser(dict_type=CaseInsensitiveDict)
71             config_parser.readfp(config_file)
72             return (
73                 "ethercat"
74                 in config_parser.get(
75                     "lvrt", "AdditionalNetworkProtocols", fallback=""
76                 ).lower()
77             )
78     def test_down(self):
79         interfaces = self.__interfaces()
80         for interface in interfaces:
81             result = self.run_function("ip.down", [interface.name])
82             self.assertTrue(result)
83         info = self.run_function("ip.get_interfaces_details", timeout=300)
84         for interface in info["interfaces"]:
85             if self.grains["lsb_distrib_id"] == "nilrt":
86                 self.assertEqual(interface["adapter_mode"], "disabled")
87             self.assertFalse(
88                 self.__connected(pyiface.Interface(name=interface["connectionid"]))
89             )
90     def test_up(self):
91         interfaces = self.__interfaces()
92         for interface in interfaces:
93             self.run_function("ip.down", [interface.name])
94             self.assertFalse(self.__connected(interface))
95         for interface in interfaces:
96             result = self.run_function("ip.up", [interface.name])
97             self.assertTrue(result)
98         if self.grains["lsb_distrib_id"] == "nilrt":
99             info = self.run_function("ip.get_interfaces_details", timeout=300)
100             for interface in info["interfaces"]:
101                 self.assertEqual(interface["adapter_mode"], "tcpip")
102     def test_set_dhcp_linklocal_all(self):
103         interfaces = self.__interfaces()
104         for interface in interfaces:
105             result = self.run_function("ip.set_dhcp_linklocal_all", [interface.name])
106             self.assertTrue(result)
107         info = self.run_function("ip.get_interfaces_details", timeout=300)
108         for interface in info["interfaces"]:
109             self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
110             if self.grains["lsb_distrib_id"] == "nilrt":
111                 self.assertEqual(interface["adapter_mode"], "tcpip")
112     def test_set_dhcp_only_all(self):
113         if self.grains["lsb_distrib_id"] != "nilrt":
114             self.skipTest("Test not applicable to newer nilrt")
115         interfaces = self.__interfaces()
116         for interface in interfaces:
117             result = self.run_function("ip.set_dhcp_only_all", [interface.name])
118             self.assertTrue(result)
119         info = self.run_function("ip.get_interfaces_details", timeout=300)
120         for interface in info["interfaces"]:
121             self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_only")
122             self.assertEqual(interface["adapter_mode"], "tcpip")
123     def test_set_linklocal_only_all(self):
124         if self.grains["lsb_distrib_id"] != "nilrt":
125             self.skipTest("Test not applicable to newer nilrt")
126         interfaces = self.__interfaces()
127         for interface in interfaces:
128             result = self.run_function("ip.set_linklocal_only_all", [interface.name])
129             self.assertTrue(result)
130         info = self.run_function("ip.get_interfaces_details", timeout=300)
131         for interface in info["interfaces"]:
132             self.assertEqual(interface["ipv4"]["requestmode"], "linklocal_only")
133             self.assertEqual(interface["adapter_mode"], "tcpip")
134     def test_static_all(self):
135         interfaces = self.__interfaces()
136         for interface in interfaces:
137             result = self.run_function(
138                 "ip.set_static_all",
139                 [
140                     interface.name,
141                     "192.168.10.4",
142                     "255.255.255.0",
143                     "192.168.10.1",
144                     "8.8.4.4 8.8.8.8",
145                 ],
146             )
147             self.assertTrue(result)
148 <a name="0"></a>
149         info = self.run_function("ip.get_interfaces_details", timeout=300)
150         for interface in info["interfaces"]:
151             if self.grains<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["lsb_distrib_id"] != "nilrt":
152                 self.assertIn("8.8.4.4", interface["ipv4"]["dns"])
153                 self.assertIn("8.8.8.8", interface["ipv4"]["dns"])
154             else:
155                 self.assertEqual(interface[</b></font>"ipv4"]["dns"], ["8.8.4.4"])
156                 self.assertEqual(interface["adapter_mode"], "tcpip")
157             self.assertEqual(interface["ipv4"]["requestmode"], "static")
158             self.assertEqual(interface["ipv4"]["address"], "192.168.10.4")
159             self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
160             self.assertEqual(interface["ipv4"]["gateway"], "192.168.10.1")
161     def test_supported_adapter_modes(self):
162         if self.grains["lsb_distrib_id"] != "nilrt":
163             self.skipTest("Test is just for older nilrt distros")
164         interface_pattern = re.compile("^eth[0-9]+$")
165         info = self.run_function("ip.get_interfaces_details", timeout=300)
166         for interface in info["interfaces"]:
167             if interface["connectionid"] == "eth0":
168                 self.assertEqual(interface["supported_adapter_modes"], ["tcpip"])
169             else:
170                 self.assertIn("tcpip", interface["supported_adapter_modes"])
171                 if not interface_pattern.match(interface["connectionid"]):
172                     self.assertNotIn("ethercat", interface["supported_adapter_modes"])
173                 elif self.__check_ethercat():
174                     self.assertIn("ethercat", interface["supported_adapter_modes"])
175     def test_ethercat(self):
176         if not self.__check_ethercat():
177             self.skipTest("Test is just for systems with Ethercat")
178         self.assertTrue(self.run_function("ip.set_ethercat", [INTERFACE_FOR_TEST, 19]))
179         info = self.run_function("ip.get_interfaces_details", timeout=300)
180         for interface in info["interfaces"]:
181             if interface["connectionid"] == INTERFACE_FOR_TEST:
182                 self.assertEqual(interface["adapter_mode"], "ethercat")
183                 self.assertEqual(int(interface["ethercat"]["masterid"]), 19)
184                 break
185         self.assertTrue(
186             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
187         )
188         info = self.run_function("ip.get_interfaces_details", timeout=300)
189         for interface in info["interfaces"]:
190             if interface["connectionid"] == INTERFACE_FOR_TEST:
191                 self.assertEqual(interface["adapter_mode"], "tcpip")
192                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
193                 break
194     @pytest.mark.destructive_test
195     def test_dhcp_disable(self):
196         if self.grains["lsb_distrib_id"] == "nilrt":
197             self.skipTest("Test is just for newer nilrt distros")
198         self.assertTrue(
199             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
200         )
201         info = self.run_function("ip.get_interfaces_details", timeout=300)
202         for interface in info["interfaces"]:
203             if interface["connectionid"] == INTERFACE_FOR_TEST:
204                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
205                 break
206         self.assertTrue(self.run_function("ip.disable", [INTERFACE_FOR_TEST]))
207         info = self.run_function("ip.get_interfaces_details", timeout=300)
208         for interface in info["interfaces"]:
209             if interface["connectionid"] == INTERFACE_FOR_TEST:
210                 self.assertEqual(interface["ipv4"]["requestmode"], "disabled")
211                 break
212         self.assertTrue(
213             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
214         )
215         info = self.run_function("ip.get_interfaces_details", timeout=300)
216         for interface in info["interfaces"]:
217             if interface["connectionid"] == INTERFACE_FOR_TEST:
218                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
219                 break
220     @pytest.mark.destructive_test
221     def test_dhcp_static(self):
222         if self.grains["lsb_distrib_id"] == "nilrt":
223             self.skipTest("Test is just for newer nilrt distros")
224         self.assertTrue(
225             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
226         )
227         info = self.run_function("ip.get_interfaces_details", timeout=300)
228         for interface in info["interfaces"]:
229             if interface["connectionid"] == INTERFACE_FOR_TEST:
230                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
231                 break
232         self.assertTrue(
233             self.run_function(
234                 "ip.set_static_all",
235                 [
236                     INTERFACE_FOR_TEST,
237                     "192.168.1.125",
238                     "255.255.255.0",
239                     "192.168.1.1",
240                     "8.8.8.8 8.8.8.4",
241                 ],
242             )
243         )
244         info = self.run_function("ip.get_interfaces_details", timeout=300)
245         for interface in info["interfaces"]:
246             if interface["connectionid"] == INTERFACE_FOR_TEST:
247                 self.assertEqual(interface["ipv4"]["requestmode"], "static")
248                 self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
249                 self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
250                 self.assertIn("8.8.8.4", interface["ipv4"]["dns"])
251                 self.assertIn("8.8.8.8", interface["ipv4"]["dns"])
252                 break
253         self.assertTrue(
254             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
255         )
256         info = self.run_function("ip.get_interfaces_details", timeout=300)
257         for interface in info["interfaces"]:
258             if interface["connectionid"] == INTERFACE_FOR_TEST:
259                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
260                 break
261     @pytest.mark.destructive_test
262     def test_static_disable(self):
263         if self.grains["lsb_distrib_id"] == "nilrt":
264             self.skipTest("Test is just for newer nilrt distros")
265         self.assertTrue(
266             self.run_function(
267                 "ip.set_static_all",
268                 [
269                     INTERFACE_FOR_TEST,
270                     "192.168.1.125",
271                     "255.255.255.0",
272                     "192.168.1.1",
273                     "8.8.8.8",
274                 ],
275             )
276         )
277         info = self.run_function("ip.get_interfaces_details", timeout=300)
278         for interface in info["interfaces"]:
279             if interface["connectionid"] == INTERFACE_FOR_TEST:
280                 self.assertEqual(interface["ipv4"]["requestmode"], "static")
281                 self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
282                 self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
283                 self.assertEqual(interface["ipv4"]["dns"], ["8.8.8.8"])
284                 break
285         self.assertTrue(self.run_function("ip.disable", [INTERFACE_FOR_TEST]))
286         info = self.run_function("ip.get_interfaces_details", timeout=300)
287         for interface in info["interfaces"]:
288             if interface["connectionid"] == INTERFACE_FOR_TEST:
289                 self.assertEqual(interface["ipv4"]["requestmode"], "disabled")
290                 break
291         self.assertTrue(
292             self.run_function(
293                 "ip.set_static_all",
294                 [INTERFACE_FOR_TEST, "192.168.1.125", "255.255.255.0", "192.168.1.1"],
295             )
296         )
297         info = self.run_function("ip.get_interfaces_details", timeout=300)
298         for interface in info["interfaces"]:
299             if interface["connectionid"] == INTERFACE_FOR_TEST:
300                 self.assertEqual(interface["ipv4"]["requestmode"], "static")
301                 self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
302                 self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
303                 self.assertEqual(interface["ipv4"]["dns"], [])
304                 break
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_s3_bucket.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import salt.utils.json
4 log = logging.getLogger(__name__)
5 def __virtual__():
6     if "boto_s3_bucket.exists" in __salt__:
7         return "boto_s3_bucket"
8     return (False, "boto_s3_bucket module could not be loaded")
9 def _normalize_user(user_dict):
10     ret = copy.deepcopy(user_dict)
11     if "Type" in ret:
12         del ret["Type"]
13     return ret
14 def _get_canonical_id(region, key, keyid, profile):
15     ret = __salt__["boto_s3_bucket.list"](
16         region=region, key=key, keyid=keyid, profile=profile
17     ).get("Owner")
18     return _normalize_user(ret)
19 def _prep_acl_for_compare(ACL):
20     ret = copy.deepcopy(ACL)
21     ret["Owner"] = _normalize_user(ret["Owner"])
22     for item in ret.get("Grants", ()):
23         item["Grantee"] = _normalize_user(item.get("Grantee"))
24     return ret
25 def _acl_to_grant(ACL, owner_canonical_id):
26     if "AccessControlPolicy" in ACL:
27         ret = copy.deepcopy(ACL["AccessControlPolicy"])
28         ret["Owner"] = _normalize_user(ret["Owner"])
29         for item in ACL.get("Grants", ()):
30             item["Grantee"] = _normalize_user(item.get("Grantee"))
31         return ret
32     owner_canonical_grant = copy.deepcopy(owner_canonical_id)
33     owner_canonical_grant.update({"Type": "CanonicalUser"})
34     ret = {"Grants": [], "Owner": owner_canonical_id}
35     if "ACL" in ACL:
36         acl = ACL["ACL"]
37         if acl in ("public-read", "public-read-write"):
38             ret["Grants"].append(
39                 {
40                     "Grantee": {
41                         "Type": "Group",
42                         "URI": "http://acs.amazonaws.com/groups/global/AllUsers",
43                     },
44                     "Permission": "READ",
45                 }
46             )
47         if acl == "public-read-write":
48             ret["Grants"].append(
49                 {
50                     "Grantee": {
51                         "Type": "Group",
52                         "URI": "http://acs.amazonaws.com/groups/global/AllUsers",
53                     },
54                     "Permission": "WRITE",
55                 }
56             )
57         if acl == "aws-exec-read":
58             ret["Grants"].append(
59                 {
60                     "Grantee": {
61                         "Type": "CanonicalUser",
62                         "DisplayName": "za-team",
63                         "ID": "6aa5a366c34c1cbe25dc49211496e913e0351eb0e8c37aa3477e40942ec6b97c",
64                     },
65                     "Permission": "READ",
66                 }
67             )
68         if acl == "authenticated-read":
69             ret["Grants"].append(
70                 {
71                     "Grantee": {
72                         "Type": "Group",
73                         "URI": (
74                             "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
75                         ),
76                     },
77                     "Permission": "READ",
78                 }
79             )
80         if acl == "log-delivery-write":
81             for permission in ("WRITE", "READ_ACP"):
82                 ret["Grants"].append(
83                     {
84                         "Grantee": {
85                             "Type": "Group",
86                             "URI": "http://acs.amazonaws.com/groups/s3/LogDelivery",
87                         },
88                         "Permission": permission,
89                     }
90                 )
91     for key, permission in (
92         ("GrantFullControl", "FULL_CONTROL"),
93         ("GrantRead", "READ"),
94         ("GrantReadACP", "READ_ACP"),
95         ("GrantWrite", "WRITE"),
96         ("GrantWriteACP", "WRITE_ACP"),
97     ):
98         if key in ACL:
99             for item in ACL[key].split(","):
100                 kind, val = item.split("=")
101                 if kind == "uri":
102                     grantee = {"Type": "Group", "URI": val}
103                 elif kind == "id":
104                     grantee = {
105                         "Type": "CanonicalUser",
106                         "ID": val,
107                     }
108                 else:
109                     grantee = {
110                     }
111                 ret["Grants"].append({"Grantee": grantee, "Permission": permission})
112     if not ret["Grants"]:
113         ret["Grants"] = [
114             {"Grantee": owner_canonical_grant, "Permission": "FULL_CONTROL"}
115         ]
116     return ret
117 def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
118     if name.startswith("arn:aws:iam:"):
119         return name
120     account_id = __salt__["boto_iam.get_account_id"](
121         region=region, key=key, keyid=keyid, profile=profile
122     )
123     if profile and "region" in profile:
124         region = profile["region"]
125     if region is None:
126         region = "us-east-1"
127     return "arn:aws:iam::{}:role/{}".format(account_id, name)
128 def _compare_json(current, desired, region, key, keyid, profile):
129     return __utils__["boto3.json_objs_equal"](current, desired)
130 def _compare_acl(current, desired, region, key, keyid, profile):
131     ocid = _get_canonical_id(region, key, keyid, profile)
132     return __utils__["boto3.json_objs_equal"](current, _acl_to_grant(desired, ocid))
133 def _compare_policy(current, desired, region, key, keyid, profile):
134     return current == desired
135 def _compare_replication(current, desired, region, key, keyid, profile):
136     if desired is not None and desired.get("Role"):
137         desired = copy.deepcopy(desired)
138         desired["Role"] = _get_role_arn(
139             desired["Role"], region=region, key=key, keyid=keyid, profile=profile
140         )
141     return __utils__["boto3.json_objs_equal"](current, desired)
142 def present(
143     name,
144     Bucket,
145     LocationConstraint=None,
146     ACL=None,
147     CORSRules=None,
148     LifecycleConfiguration=None,
149     Logging=None,
150     NotificationConfiguration=None,
151     Policy=None,
152     Replication=None,
153     RequestPayment=None,
154     Tagging=None,
155     Versioning=None,
156     Website=None,
157     region=None,
158     key=None,
159     keyid=None,
160     profile=None,
161 ):
162     ret = {"name": Bucket, "result": True, "comment": "", "changes": {}}
163     if ACL is None:
164         ACL = {"ACL": "private"}
165     if NotificationConfiguration is None:
166         NotificationConfiguration = {}
167     if RequestPayment is None:
168         RequestPayment = {"Payer": "BucketOwner"}
169     if Policy:
170         if isinstance(Policy, str):
171             Policy = salt.utils.json.loads(Policy)
172         Policy = __utils__["boto3.ordered"](Policy)
173     r = __salt__["boto_s3_bucket.exists"](
174         Bucket=Bucket, region=region, key=key, keyid=keyid, profile=profile
175     )
176     if "error" in r:
177         ret["result"] = False
178         ret["comment"] = "Failed to create bucket: {}.".format(r["error"]["message"])
179         return ret
180     if not r.get("exists"):
181         if __opts__["test"]:
182             ret["comment"] = "S3 bucket {} is set to be created.".format(Bucket)
183             ret["result"] = None
184             return ret
185         r = __salt__["boto_s3_bucket.create"](
186             Bucket=Bucket,
187             LocationConstraint=LocationConstraint,
188             region=region,
189             key=key,
190             keyid=keyid,
191             profile=profile,
192         )
193         if not r.get("created"):
194             ret["result"] = False
195             ret["comment"] = "Failed to create bucket: {}.".format(
196                 r["error"]["message"]
197             )
198             return ret
199         for setter, testval, funcargs in (
200             ("put_acl", ACL, ACL),
201             ("put_cors", CORSRules, {"CORSRules": CORSRules}),
202             (
203                 "put_lifecycle_configuration",
204                 LifecycleConfiguration,
205                 {"Rules": LifecycleConfiguration},
206             ),
207             ("put_logging", Logging, Logging),
208             (
209                 "put_notification_configuration",
210                 NotificationConfiguration,
211                 NotificationConfiguration,
212             ),
213             ("put_policy", Policy, {"Policy": Policy}),
214             ("put_versioning", Versioning, Versioning),
215             ("put_replication", Replication, Replication),
216             ("put_request_payment", RequestPayment, RequestPayment),
217             ("put_tagging", Tagging, Tagging),
218             ("put_website", Website, Website),
219         ):
220             if testval is not None:
221                 r = __salt__["boto_s3_bucket.{}".format(setter)](
222                     Bucket=Bucket,
223                     region=region,
224                     key=key,
225                     keyid=keyid,
226                     profile=profile,
227                     **funcargs
228                 )
229                 if not r.get("updated"):
230                     ret["result"] = False
231                     ret["comment"] = "Failed to create bucket: {}.".format(
232                         r["error"]["message"]
233                     )
234                     return ret
235         _describe = __salt__["boto_s3_bucket.describe"](
236             Bucket, region=region, key=key, keyid=keyid, profile=profile
237         )
238         ret["changes"]["old"] = {"bucket": None}
239         ret["changes"]["new"] = _describe
240         ret["comment"] = "S3 bucket {} created.".format(Bucket)
241         return ret
242     ret["comment"] = " ".join(
243         [ret["comment"], "S3 bucket {} is present.".format(Bucket)]
244     )
245     ret["changes"] = {}
246     _describe = __salt__["boto_s3_bucket.describe"](
247         Bucket=Bucket, region=region, key=key, keyid=keyid, profile=profile
248     )
249     if "error" in _describe:
250         ret["result"] = False
251         ret["comment"] = "Failed to update bucket: {}.".format(
252             _describe["error"]["message"]
253         )
254         ret["changes"] = {}
255         return ret
256     _describe = _describe["bucket"]
257     if not bool(Versioning) and bool(_describe.get("Versioning")):
258         Versioning = {"Status": "Suspended"}
259 <a name="0"></a>    config_items = [
260         ("ACL", "put_acl", _describe.get("ACL"), _compare_acl, ACL, None),
261         (
262             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"CORS",
263             "put_cors",
264             _describe.get("CORS"),
265             _compare_json,
266             {"CORSRules": CORSRules} if CORSRules else None,
267             "delete_cors",
268         ),
269         (
270             "LifecycleConfiguration",
271             "put_lifecycle_configuration",
272             _describe.get("LifecycleConfiguration"),
273             _compare_json,
274             {"Rules": LifecycleConfiguration} if LifecycleConfiguration else None,
275             "delete_lifecycle_configuration",
276         ),
277         (
278             "Logging",
279             "put_logging",
280             _describe.get("Logging", {}).</b></font>get("LoggingEnabled"),
281             _compare_json,
282             Logging,
283             None,
284         ),
285         (
286             "NotificationConfiguration",
287             "put_notification_configuration",
288             _describe.get("NotificationConfiguration"),
289             _compare_json,
290             NotificationConfiguration,
291             None,
292         ),
293         (
294             "Policy",
295             "put_policy",
296             _describe.get("Policy"),
297             _compare_policy,
298             {"Policy": Policy} if Policy else None,
299             "delete_policy",
300         ),
301         (
302             "RequestPayment",
303             "put_request_payment",
304             _describe.get("RequestPayment"),
305             _compare_json,
306             RequestPayment,
307             None,
308         ),
309         (
310             "Tagging",
311             "put_tagging",
312             _describe.get("Tagging"),
313             _compare_json,
314             Tagging,
315             "delete_tagging",
316         ),
317         (
318             "Website",
319             "put_website",
320             _describe.get("Website"),
321             _compare_json,
322             Website,
323             "delete_website",
324         ),
325     ]
326     versioning_item = (
327         "Versioning",
328         "put_versioning",
329         _describe.get("Versioning"),
330         _compare_json,
331         Versioning or {},
332         None,
333     )
334     replication_item = (
335         "Replication",
336         "put_replication",
337         _describe.get("Replication", {}).get("ReplicationConfiguration"),
338         _compare_replication,
339         Replication,
340         "delete_replication",
341     )
342     if Replication is not None:
343         config_items.append(versioning_item)
344         config_items.append(replication_item)
345     else:
346         config_items.append(replication_item)
347         config_items.append(versioning_item)
348     update = False
349     for varname, setter, current, comparator, desired, deleter in config_items:
350         if varname == "Policy":
351             if current is not None:
352                 temp = current.get("Policy")
353                 if isinstance(temp, str):
354                     current = __utils__["boto3.ordered"](
355                         {"Policy": salt.utils.json.loads(temp)}
356                     )
357         if not comparator(current, desired, region, key, keyid, profile):
358             update = True
359             if varname == "ACL":
360                 ret["changes"].setdefault("new", {})[varname] = _acl_to_grant(
361                     desired, _get_canonical_id(region, key, keyid, profile)
362                 )
363             else:
364                 ret["changes"].setdefault("new", {})[varname] = desired
365             ret["changes"].setdefault("old", {})[varname] = current
366             if not __opts__["test"]:
367                 if deleter and desired is None:
368                     r = __salt__["boto_s3_bucket.{}".format(deleter)](
369                         Bucket=Bucket,
370                         region=region,
371                         key=key,
372                         keyid=keyid,
373                         profile=profile,
374                     )
375                     if not r.get("deleted"):
376                         ret["result"] = False
377                         ret["comment"] = "Failed to update bucket: {}.".format(
378                             r["error"]["message"]
379                         )
380                         ret["changes"] = {}
381                         return ret
382                 else:
383                     r = __salt__["boto_s3_bucket.{}".format(setter)](
384                         Bucket=Bucket,
385                         region=region,
386                         key=key,
387                         keyid=keyid,
388                         profile=profile,
389                         **(desired or {})
390                     )
391                     if not r.get("updated"):
392                         ret["result"] = False
393                         ret["comment"] = "Failed to update bucket: {}.".format(
394                             r["error"]["message"]
395                         )
396                         ret["changes"] = {}
397                         return ret
398     if update and __opts__["test"]:
399         msg = "S3 bucket {} set to be modified.".format(Bucket)
400         ret["comment"] = msg
401         ret["result"] = None
402         return ret
403     if _describe.get("Location", {}).get("LocationConstraint") != LocationConstraint:
404         msg = (
405             "Bucket {} location does not match desired configuration, but cannot be"
406             " changed".format(LocationConstraint)
407         )
408         log.warning(msg)
409         ret["result"] = False
410         ret["comment"] = "Failed to update bucket: {}.".format(msg)
411         return ret
412     return ret
413 def absent(name, Bucket, Force=False, region=None, key=None, keyid=None, profile=None):
414     ret = {"name": Bucket, "result": True, "comment": "", "changes": {}}
415     r = __salt__["boto_s3_bucket.exists"](
416         Bucket, region=region, key=key, keyid=keyid, profile=profile
417     )
418     if "error" in r:
419         ret["result"] = False
420         ret["comment"] = "Failed to delete bucket: {}.".format(r["error"]["message"])
421         return ret
422     if r and not r["exists"]:
423         ret["comment"] = "S3 bucket {} does not exist.".format(Bucket)
424         return ret
425     if __opts__["test"]:
426         ret["comment"] = "S3 bucket {} is set to be removed.".format(Bucket)
427         ret["result"] = None
428         return ret
429     r = __salt__["boto_s3_bucket.delete"](
430         Bucket, Force=Force, region=region, key=key, keyid=keyid, profile=profile
431     )
432     if not r["deleted"]:
433         ret["result"] = False
434         ret["comment"] = "Failed to delete bucket: {}.".format(r["error"]["message"])
435         return ret
436     ret["changes"]["old"] = {"bucket": Bucket}
437     ret["changes"]["new"] = {"bucket": None}
438     ret["comment"] = "S3 bucket {} deleted.".format(Bucket)
439     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
