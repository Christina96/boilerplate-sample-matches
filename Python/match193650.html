<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_nilrt_ip_1.py &amp; boto_s3_bucket.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_nilrt_ip_1.py &amp; boto_s3_bucket.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_nilrt_ip_1.py (1.7391304%)<th>boto_s3_bucket.py (1.734104%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(222-226)<td><a href="#" name="0">(533-551)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_nilrt_ip_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import configparser
2 import re
3 import shutil
4 import time
5 import pytest
6 import salt.modules.nilrt_ip as ip
7 import salt.utils.files
8 import salt.utils.platform
9 from tests.support.case import ModuleCase
10 from tests.support.helpers import requires_system_grains, runs_on
11 from tests.support.unit import skipIf
12 try:
13     import pyiface
14     from pyiface.ifreqioctls import IFF_LOOPBACK, IFF_RUNNING
15 except ImportError:
16     pyiface = None
17 try:
18     from requests.structures import CaseInsensitiveDict
19 except ImportError:
20     CaseInsensitiveDict = None
21 INTERFACE_FOR_TEST = "eth1"
22 @pytest.mark.skip_if_not_root
23 @skipIf(not pyiface, "The python pyiface package is not installed")
24 @skipIf(not CaseInsensitiveDict, "The python package requests is not installed")
25 @runs_on(os_family="NILinuxRT", reason="Tests applicable only to NILinuxRT")
26 @pytest.mark.destructive_test
27 class NilrtIpModuleTest(ModuleCase):
28     @requires_system_grains
29     @classmethod
30     def setUpClass(cls, grains):  # pylint: disable=arguments-differ
31         cls.initialState = {}
32         cls.grains = grains
33     @classmethod
34     def tearDownClass(cls):
35         cls.initialState = cls.grains = None
36     @staticmethod
37     def setup_loader_modules():
38         return {ip: {}}
39     def setUp(self):
40         super().setUp()
41         if self.grains["lsb_distrib_id"] == "nilrt":
42             shutil.move("/etc/natinst/share/ni-rt.ini", "/tmp/ni-rt.ini")
43         else:
44             shutil.move("/var/lib/connman", "/tmp/connman")
45     def tearDown(self):
46         if self.grains["lsb_distrib_id"] == "nilrt":
47             shutil.move("/tmp/ni-rt.ini", "/etc/natinst/share/ni-rt.ini")
48             self.run_function("cmd.run", ["/etc/init.d/networking restart"])
49         else:
50             shutil.move("/tmp/connman", "/var/lib/connman")
51             self.run_function("service.restart", ["connman"])
52         time.sleep(10)  # wait 10 seconds for connman to be fully loaded
53         interfaces = self.__interfaces()
54         for interface in interfaces:
55             self.run_function("ip.up", [interface.name])
56     @staticmethod
57     def __connected(interface):
58         return interface.flags &amp; IFF_RUNNING != 0
59     @staticmethod
60     def __interfaces():
61         return [
62             interface
63             for interface in pyiface.getIfaces()
64             if interface.flags &amp; IFF_LOOPBACK == 0
65         ]
66     def __check_ethercat(self):
67         if self.grains["lsb_distrib_id"] != "nilrt":
68             return False
69         with salt.utils.files.fopen("/etc/natinst/share/ni-rt.ini", "r") as config_file:
70             config_parser = configparser.RawConfigParser(dict_type=CaseInsensitiveDict)
71             config_parser.readfp(config_file)
72             return (
73                 "ethercat"
74                 in config_parser.get(
75                     "lvrt", "AdditionalNetworkProtocols", fallback=""
76                 ).lower()
77             )
78     def test_down(self):
79         interfaces = self.__interfaces()
80         for interface in interfaces:
81             result = self.run_function("ip.down", [interface.name])
82             self.assertTrue(result)
83         info = self.run_function("ip.get_interfaces_details", timeout=300)
84         for interface in info["interfaces"]:
85             if self.grains["lsb_distrib_id"] == "nilrt":
86                 self.assertEqual(interface["adapter_mode"], "disabled")
87             self.assertFalse(
88                 self.__connected(pyiface.Interface(name=interface["connectionid"]))
89             )
90     def test_up(self):
91         interfaces = self.__interfaces()
92         for interface in interfaces:
93             self.run_function("ip.down", [interface.name])
94             self.assertFalse(self.__connected(interface))
95         for interface in interfaces:
96             result = self.run_function("ip.up", [interface.name])
97             self.assertTrue(result)
98         if self.grains["lsb_distrib_id"] == "nilrt":
99             info = self.run_function("ip.get_interfaces_details", timeout=300)
100             for interface in info["interfaces"]:
101                 self.assertEqual(interface["adapter_mode"], "tcpip")
102     def test_set_dhcp_linklocal_all(self):
103         interfaces = self.__interfaces()
104         for interface in interfaces:
105             result = self.run_function("ip.set_dhcp_linklocal_all", [interface.name])
106             self.assertTrue(result)
107         info = self.run_function("ip.get_interfaces_details", timeout=300)
108         for interface in info["interfaces"]:
109             self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
110             if self.grains["lsb_distrib_id"] == "nilrt":
111                 self.assertEqual(interface["adapter_mode"], "tcpip")
112     def test_set_dhcp_only_all(self):
113         if self.grains["lsb_distrib_id"] != "nilrt":
114             self.skipTest("Test not applicable to newer nilrt")
115         interfaces = self.__interfaces()
116         for interface in interfaces:
117             result = self.run_function("ip.set_dhcp_only_all", [interface.name])
118             self.assertTrue(result)
119         info = self.run_function("ip.get_interfaces_details", timeout=300)
120         for interface in info["interfaces"]:
121             self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_only")
122             self.assertEqual(interface["adapter_mode"], "tcpip")
123     def test_set_linklocal_only_all(self):
124         if self.grains["lsb_distrib_id"] != "nilrt":
125             self.skipTest("Test not applicable to newer nilrt")
126         interfaces = self.__interfaces()
127         for interface in interfaces:
128             result = self.run_function("ip.set_linklocal_only_all", [interface.name])
129             self.assertTrue(result)
130         info = self.run_function("ip.get_interfaces_details", timeout=300)
131         for interface in info["interfaces"]:
132             self.assertEqual(interface["ipv4"]["requestmode"], "linklocal_only")
133             self.assertEqual(interface["adapter_mode"], "tcpip")
134     def test_static_all(self):
135         interfaces = self.__interfaces()
136         for interface in interfaces:
137             result = self.run_function(
138                 "ip.set_static_all",
139                 [
140                     interface.name,
141                     "192.168.10.4",
142                     "255.255.255.0",
143                     "192.168.10.1",
144                     "8.8.4.4 8.8.8.8",
145                 ],
146             )
147             self.assertTrue(result)
148         info = self.run_function("ip.get_interfaces_details", timeout=300)
149         for interface in info["interfaces"]:
150             if self.grains<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["lsb_distrib_id"] != "nilrt":
151                 self.assertIn("8.8.4.4", interface["ipv4"]["dns"])
152                 self.assertIn("8.8.8.8", interface["ipv4"]["dns"])
153             else:
154                 self.assertEqual(interface[</b></font>"ipv4"]["dns"], ["8.8.4.4"])
155                 self.assertEqual(interface["adapter_mode"], "tcpip")
156             self.assertEqual(interface["ipv4"]["requestmode"], "static")
157             self.assertEqual(interface["ipv4"]["address"], "192.168.10.4")
158             self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
159             self.assertEqual(interface["ipv4"]["gateway"], "192.168.10.1")
160     def test_supported_adapter_modes(self):
161         if self.grains["lsb_distrib_id"] != "nilrt":
162             self.skipTest("Test is just for older nilrt distros")
163         interface_pattern = re.compile("^eth[0-9]+$")
164         info = self.run_function("ip.get_interfaces_details", timeout=300)
165         for interface in info["interfaces"]:
166             if interface["connectionid"] == "eth0":
167                 self.assertEqual(interface["supported_adapter_modes"], ["tcpip"])
168             else:
169                 self.assertIn("tcpip", interface["supported_adapter_modes"])
170                 if not interface_pattern.match(interface["connectionid"]):
171                     self.assertNotIn("ethercat", interface["supported_adapter_modes"])
172                 elif self.__check_ethercat():
173                     self.assertIn("ethercat", interface["supported_adapter_modes"])
174     def test_ethercat(self):
175         if not self.__check_ethercat():
176             self.skipTest("Test is just for systems with Ethercat")
177         self.assertTrue(self.run_function("ip.set_ethercat", [INTERFACE_FOR_TEST, 19]))
178         info = self.run_function("ip.get_interfaces_details", timeout=300)
179         for interface in info["interfaces"]:
180             if interface["connectionid"] == INTERFACE_FOR_TEST:
181                 self.assertEqual(interface["adapter_mode"], "ethercat")
182                 self.assertEqual(int(interface["ethercat"]["masterid"]), 19)
183                 break
184         self.assertTrue(
185             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
186         )
187         info = self.run_function("ip.get_interfaces_details", timeout=300)
188         for interface in info["interfaces"]:
189             if interface["connectionid"] == INTERFACE_FOR_TEST:
190                 self.assertEqual(interface["adapter_mode"], "tcpip")
191                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
192                 break
193     @pytest.mark.destructive_test
194     def test_dhcp_disable(self):
195         if self.grains["lsb_distrib_id"] == "nilrt":
196             self.skipTest("Test is just for newer nilrt distros")
197         self.assertTrue(
198             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
199         )
200         info = self.run_function("ip.get_interfaces_details", timeout=300)
201         for interface in info["interfaces"]:
202             if interface["connectionid"] == INTERFACE_FOR_TEST:
203                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
204                 break
205         self.assertTrue(self.run_function("ip.disable", [INTERFACE_FOR_TEST]))
206         info = self.run_function("ip.get_interfaces_details", timeout=300)
207         for interface in info["interfaces"]:
208             if interface["connectionid"] == INTERFACE_FOR_TEST:
209                 self.assertEqual(interface["ipv4"]["requestmode"], "disabled")
210                 break
211         self.assertTrue(
212             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
213         )
214         info = self.run_function("ip.get_interfaces_details", timeout=300)
215         for interface in info["interfaces"]:
216             if interface["connectionid"] == INTERFACE_FOR_TEST:
217                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
218                 break
219     @pytest.mark.destructive_test
220     def test_dhcp_static(self):
221         if self.grains["lsb_distrib_id"] == "nilrt":
222             self.skipTest("Test is just for newer nilrt distros")
223         self.assertTrue(
224             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
225         )
226         info = self.run_function("ip.get_interfaces_details", timeout=300)
227         for interface in info["interfaces"]:
228             if interface["connectionid"] == INTERFACE_FOR_TEST:
229                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
230                 break
231         self.assertTrue(
232             self.run_function(
233                 "ip.set_static_all",
234                 [
235                     INTERFACE_FOR_TEST,
236                     "192.168.1.125",
237                     "255.255.255.0",
238                     "192.168.1.1",
239                     "8.8.8.8 8.8.8.4",
240                 ],
241             )
242         )
243         info = self.run_function("ip.get_interfaces_details", timeout=300)
244         for interface in info["interfaces"]:
245             if interface["connectionid"] == INTERFACE_FOR_TEST:
246                 self.assertEqual(interface["ipv4"]["requestmode"], "static")
247                 self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
248                 self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
249                 self.assertIn("8.8.8.4", interface["ipv4"]["dns"])
250                 self.assertIn("8.8.8.8", interface["ipv4"]["dns"])
251                 break
252         self.assertTrue(
253             self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
254         )
255         info = self.run_function("ip.get_interfaces_details", timeout=300)
256         for interface in info["interfaces"]:
257             if interface["connectionid"] == INTERFACE_FOR_TEST:
258                 self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
259                 break
260     @pytest.mark.destructive_test
261     def test_static_disable(self):
262         if self.grains["lsb_distrib_id"] == "nilrt":
263             self.skipTest("Test is just for newer nilrt distros")
264         self.assertTrue(
265             self.run_function(
266                 "ip.set_static_all",
267                 [
268                     INTERFACE_FOR_TEST,
269                     "192.168.1.125",
270                     "255.255.255.0",
271                     "192.168.1.1",
272                     "8.8.8.8",
273                 ],
274             )
275         )
276         info = self.run_function("ip.get_interfaces_details", timeout=300)
277         for interface in info["interfaces"]:
278             if interface["connectionid"] == INTERFACE_FOR_TEST:
279                 self.assertEqual(interface["ipv4"]["requestmode"], "static")
280                 self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
281                 self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
282                 self.assertEqual(interface["ipv4"]["dns"], ["8.8.8.8"])
283                 break
284         self.assertTrue(self.run_function("ip.disable", [INTERFACE_FOR_TEST]))
285         info = self.run_function("ip.get_interfaces_details", timeout=300)
286         for interface in info["interfaces"]:
287             if interface["connectionid"] == INTERFACE_FOR_TEST:
288                 self.assertEqual(interface["ipv4"]["requestmode"], "disabled")
289                 break
290         self.assertTrue(
291             self.run_function(
292                 "ip.set_static_all",
293                 [INTERFACE_FOR_TEST, "192.168.1.125", "255.255.255.0", "192.168.1.1"],
294             )
295         )
296         info = self.run_function("ip.get_interfaces_details", timeout=300)
297         for interface in info["interfaces"]:
298             if interface["connectionid"] == INTERFACE_FOR_TEST:
299                 self.assertEqual(interface["ipv4"]["requestmode"], "static")
300                 self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
301                 self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
302                 self.assertEqual(interface["ipv4"]["dns"], [])
303                 break
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_s3_bucket.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import salt.utils.json
4 log = logging.getLogger(__name__)
5 def __virtual__():
6     if "boto_s3_bucket.exists" in __salt__:
7         return "boto_s3_bucket"
8     return (False, "boto_s3_bucket module could not be loaded")
9 def _normalize_user(user_dict):
10     ret = copy.deepcopy(user_dict)
11     if "Type" in ret:
12         del ret["Type"]
13     return ret
14 def _get_canonical_id(region, key, keyid, profile):
15     ret = __salt__["boto_s3_bucket.list"](
16         region=region, key=key, keyid=keyid, profile=profile
17     ).get("Owner")
18     return _normalize_user(ret)
19 def _prep_acl_for_compare(ACL):
20     ret = copy.deepcopy(ACL)
21     ret["Owner"] = _normalize_user(ret["Owner"])
22     for item in ret.get("Grants", ()):
23         item["Grantee"] = _normalize_user(item.get("Grantee"))
24     return ret
25 def _acl_to_grant(ACL, owner_canonical_id):
26     if "AccessControlPolicy" in ACL:
27         ret = copy.deepcopy(ACL["AccessControlPolicy"])
28         ret["Owner"] = _normalize_user(ret["Owner"])
29         for item in ACL.get("Grants", ()):
30             item["Grantee"] = _normalize_user(item.get("Grantee"))
31         return ret
32     owner_canonical_grant = copy.deepcopy(owner_canonical_id)
33     owner_canonical_grant.update({"Type": "CanonicalUser"})
34     ret = {"Grants": [], "Owner": owner_canonical_id}
35     if "ACL" in ACL:
36         acl = ACL["ACL"]
37         if acl in ("public-read", "public-read-write"):
38             ret["Grants"].append(
39                 {
40                     "Grantee": {
41                         "Type": "Group",
42                         "URI": "http://acs.amazonaws.com/groups/global/AllUsers",
43                     },
44                     "Permission": "READ",
45                 }
46             )
47         if acl == "public-read-write":
48             ret["Grants"].append(
49                 {
50                     "Grantee": {
51                         "Type": "Group",
52                         "URI": "http://acs.amazonaws.com/groups/global/AllUsers",
53                     },
54                     "Permission": "WRITE",
55                 }
56             )
57         if acl == "aws-exec-read":
58             ret["Grants"].append(
59                 {
60                     "Grantee": {
61                         "Type": "CanonicalUser",
62                         "DisplayName": "za-team",
63                         "ID": "6aa5a366c34c1cbe25dc49211496e913e0351eb0e8c37aa3477e40942ec6b97c",
64                     },
65                     "Permission": "READ",
66                 }
67             )
68         if acl == "authenticated-read":
69             ret["Grants"].append(
70                 {
71                     "Grantee": {
72                         "Type": "Group",
73                         "URI": (
74                             "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
75                         ),
76                     },
77                     "Permission": "READ",
78                 }
79             )
80         if acl == "log-delivery-write":
81             for permission in ("WRITE", "READ_ACP"):
82                 ret["Grants"].append(
83                     {
84                         "Grantee": {
85                             "Type": "Group",
86                             "URI": "http://acs.amazonaws.com/groups/s3/LogDelivery",
87                         },
88                         "Permission": permission,
89                     }
90                 )
91     for key, permission in (
92         ("GrantFullControl", "FULL_CONTROL"),
93         ("GrantRead", "READ"),
94         ("GrantReadACP", "READ_ACP"),
95         ("GrantWrite", "WRITE"),
96         ("GrantWriteACP", "WRITE_ACP"),
97     ):
98         if key in ACL:
99             for item in ACL[key].split(","):
100                 kind, val = item.split("=")
101                 if kind == "uri":
102                     grantee = {"Type": "Group", "URI": val}
103                 elif kind == "id":
104                     grantee = {
105                         "Type": "CanonicalUser",
106                         "ID": val,
107                     }
108                 else:
109                     grantee = {
110                     }
111                 ret["Grants"].append({"Grantee": grantee, "Permission": permission})
112     if not ret["Grants"]:
113         ret["Grants"] = [
114             {"Grantee": owner_canonical_grant, "Permission": "FULL_CONTROL"}
115         ]
116     return ret
117 def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
118     if name.startswith("arn:aws:iam:"):
119         return name
120     account_id = __salt__["boto_iam.get_account_id"](
121         region=region, key=key, keyid=keyid, profile=profile
122     )
123     if profile and "region" in profile:
124         region = profile["region"]
125     if region is None:
126         region = "us-east-1"
127     return "arn:aws:iam::{}:role/{}".format(account_id, name)
128 def _compare_json(current, desired, region, key, keyid, profile):
129     return __utils__["boto3.json_objs_equal"](current, desired)
130 def _compare_acl(current, desired, region, key, keyid, profile):
131     ocid = _get_canonical_id(region, key, keyid, profile)
132     return __utils__["boto3.json_objs_equal"](current, _acl_to_grant(desired, ocid))
133 def _compare_policy(current, desired, region, key, keyid, profile):
134     return current == desired
135 def _compare_replication(current, desired, region, key, keyid, profile):
136     if desired is not None and desired.get("Role"):
137         desired = copy.deepcopy(desired)
138         desired["Role"] = _get_role_arn(
139             desired["Role"], region=region, key=key, keyid=keyid, profile=profile
140         )
141     return __utils__["boto3.json_objs_equal"](current, desired)
142 def present(
143     name,
144     Bucket,
145     LocationConstraint=None,
146     ACL=None,
147     CORSRules=None,
148     LifecycleConfiguration=None,
149     Logging=None,
150     NotificationConfiguration=None,
151     Policy=None,
152     Replication=None,
153     RequestPayment=None,
154     Tagging=None,
155     Versioning=None,
156     Website=None,
157     region=None,
158     key=None,
159     keyid=None,
160     profile=None,
161 ):
162     ret = {"name": Bucket, "result": True, "comment": "", "changes": {}}
163     if ACL is None:
164         ACL = {"ACL": "private"}
165     if NotificationConfiguration is None:
166         NotificationConfiguration = {}
167     if RequestPayment is None:
168         RequestPayment = {"Payer": "BucketOwner"}
169     if Policy:
170         if isinstance(Policy, str):
171             Policy = salt.utils.json.loads(Policy)
172         Policy = __utils__["boto3.ordered"](Policy)
173     r = __salt__["boto_s3_bucket.exists"](
174         Bucket=Bucket, region=region, key=key, keyid=keyid, profile=profile
175     )
176     if "error" in r:
177         ret["result"] = False
178         ret["comment"] = "Failed to create bucket: {}.".format(r["error"]["message"])
179         return ret
180     if not r.get("exists"):
181         if __opts__["test"]:
182             ret["comment"] = "S3 bucket {} is set to be created.".format(Bucket)
183             ret["result"] = None
184             return ret
185         r = __salt__["boto_s3_bucket.create"](
186             Bucket=Bucket,
187             LocationConstraint=LocationConstraint,
188             region=region,
189             key=key,
190             keyid=keyid,
191             profile=profile,
192         )
193         if not r.get("created"):
194             ret["result"] = False
195             ret["comment"] = "Failed to create bucket: {}.".format(
196                 r["error"]["message"]
197             )
198             return ret
199         for setter, testval, funcargs in (
200             ("put_acl", ACL, ACL),
201             ("put_cors", CORSRules, {"CORSRules": CORSRules}),
202             (
203                 "put_lifecycle_configuration",
204                 LifecycleConfiguration,
205                 {"Rules": LifecycleConfiguration},
206             ),
207             ("put_logging", Logging, Logging),
208             (
209                 "put_notification_configuration",
210                 NotificationConfiguration,
211                 NotificationConfiguration,
212             ),
213             ("put_policy", Policy, {"Policy": Policy}),
214             ("put_versioning", Versioning, Versioning),
215             ("put_replication", Replication, Replication),
216             ("put_request_payment", RequestPayment, RequestPayment),
217             ("put_tagging", Tagging, Tagging),
218             ("put_website", Website, Website),
219         ):
220             if testval is not None:
221                 r = __salt__["boto_s3_bucket.{}".format(setter)](
222                     Bucket=Bucket,
223                     region=region,
224                     key=key,
225                     keyid=keyid,
226                     profile=profile,
227                     **funcargs
228                 )
229                 if not r.get("updated"):
230                     ret["result"] = False
231                     ret["comment"] = "Failed to create bucket: {}.".format(
232                         r["error"]["message"]
233                     )
234                     return ret
235         _describe = __salt__["boto_s3_bucket.describe"](
236             Bucket, region=region, key=key, keyid=keyid, profile=profile
237         )
238         ret["changes"]["old"] = {"bucket": None}
239         ret["changes"]["new"] = _describe
240         ret["comment"] = "S3 bucket {} created.".format(Bucket)
241         return ret
242     ret["comment"] = " ".join(
243         [ret["comment"], "S3 bucket {} is present.".format(Bucket)]
244     )
245     ret["changes"] = {}
246     _describe = __salt__["boto_s3_bucket.describe"](
247         Bucket=Bucket, region=region, key=key, keyid=keyid, profile=profile
248     )
249     if "error" in _describe:
250         ret["result"] = False
251         ret["comment"] = "Failed to update bucket: {}.".format(
252             _describe["error"]["message"]
253         )
254         ret["changes"] = {}
255         return ret
256     _describe = _describe["bucket"]
257     if not bool(Versioning) and bool(_describe.get("Versioning")):
258         Versioning = {"Status": "Suspended"}
259         ("ACL", "put_acl", _describe.get("ACL"), _compare_acl, ACL, None),
260         (
261             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"CORS",
262             "put_cors",
263             _describe.get("CORS"),
264             _compare_json,
265             {"CORSRules": CORSRules} if CORSRules else None,
266             "delete_cors",
267         ),
268         (
269             "LifecycleConfiguration",
270             "put_lifecycle_configuration",
271             _describe.get("LifecycleConfiguration"),
272             _compare_json,
273             {"Rules": LifecycleConfiguration} if LifecycleConfiguration else None,
274             "delete_lifecycle_configuration",
275         ),
276         (
277             "Logging",
278             "put_logging",
279             _describe.get("Logging", {}).</b></font>get("LoggingEnabled"),
280             _compare_json,
281             Logging,
282             None,
283         ),
284         (
285             "NotificationConfiguration",
286             "put_notification_configuration",
287             _describe.get("NotificationConfiguration"),
288             _compare_json,
289             NotificationConfiguration,
290             None,
291         ),
292         (
293             "Policy",
294             "put_policy",
295             _describe.get("Policy"),
296             _compare_policy,
297             {"Policy": Policy} if Policy else None,
298             "delete_policy",
299         ),
300         (
301             "RequestPayment",
302             "put_request_payment",
303             _describe.get("RequestPayment"),
304             _compare_json,
305             RequestPayment,
306             None,
307         ),
308         (
309             "Tagging",
310             "put_tagging",
311             _describe.get("Tagging"),
312             _compare_json,
313             Tagging,
314             "delete_tagging",
315         ),
316         (
317             "Website",
318             "put_website",
319             _describe.get("Website"),
320             _compare_json,
321             Website,
322             "delete_website",
323         ),
324     ]
325     versioning_item = (
326         "Versioning",
327         "put_versioning",
328         _describe.get("Versioning"),
329         _compare_json,
330         Versioning or {},
331         None,
332     )
333     replication_item = (
334         "Replication",
335         "put_replication",
336         _describe.get("Replication", {}).get("ReplicationConfiguration"),
337         _compare_replication,
338         Replication,
339         "delete_replication",
340     )
341     if Replication is not None:
342         config_items.append(versioning_item)
343         config_items.append(replication_item)
344     else:
345         config_items.append(replication_item)
346         config_items.append(versioning_item)
347     update = False
348     for varname, setter, current, comparator, desired, deleter in config_items:
349         if varname == "Policy":
350             if current is not None:
351                 temp = current.get("Policy")
352                 if isinstance(temp, str):
353                     current = __utils__["boto3.ordered"](
354                         {"Policy": salt.utils.json.loads(temp)}
355                     )
356         if not comparator(current, desired, region, key, keyid, profile):
357             update = True
358             if varname == "ACL":
359                 ret["changes"].setdefault("new", {})[varname] = _acl_to_grant(
360                     desired, _get_canonical_id(region, key, keyid, profile)
361                 )
362             else:
363                 ret["changes"].setdefault("new", {})[varname] = desired
364             ret["changes"].setdefault("old", {})[varname] = current
365             if not __opts__["test"]:
366                 if deleter and desired is None:
367                     r = __salt__["boto_s3_bucket.{}".format(deleter)](
368                         Bucket=Bucket,
369                         region=region,
370                         key=key,
371                         keyid=keyid,
372                         profile=profile,
373                     )
374                     if not r.get("deleted"):
375                         ret["result"] = False
376                         ret["comment"] = "Failed to update bucket: {}.".format(
377                             r["error"]["message"]
378                         )
379                         ret["changes"] = {}
380                         return ret
381                 else:
382                     r = __salt__["boto_s3_bucket.{}".format(setter)](
383                         Bucket=Bucket,
384                         region=region,
385                         key=key,
386                         keyid=keyid,
387                         profile=profile,
388                         **(desired or {})
389                     )
390                     if not r.get("updated"):
391                         ret["result"] = False
392                         ret["comment"] = "Failed to update bucket: {}.".format(
393                             r["error"]["message"]
394                         )
395                         ret["changes"] = {}
396                         return ret
397     if update and __opts__["test"]:
398         msg = "S3 bucket {} set to be modified.".format(Bucket)
399         ret["comment"] = msg
400         ret["result"] = None
401         return ret
402     if _describe.get("Location", {}).get("LocationConstraint") != LocationConstraint:
403         msg = (
404             "Bucket {} location does not match desired configuration, but cannot be"
405             " changed".format(LocationConstraint)
406         )
407         log.warning(msg)
408         ret["result"] = False
409         ret["comment"] = "Failed to update bucket: {}.".format(msg)
410         return ret
411     return ret
412 def absent(name, Bucket, Force=False, region=None, key=None, keyid=None, profile=None):
413     ret = {"name": Bucket, "result": True, "comment": "", "changes": {}}
414     r = __salt__["boto_s3_bucket.exists"](
415         Bucket, region=region, key=key, keyid=keyid, profile=profile
416     )
417     if "error" in r:
418         ret["result"] = False
419         ret["comment"] = "Failed to delete bucket: {}.".format(r["error"]["message"])
420         return ret
421     if r and not r["exists"]:
422         ret["comment"] = "S3 bucket {} does not exist.".format(Bucket)
423         return ret
424     if __opts__["test"]:
425         ret["comment"] = "S3 bucket {} is set to be removed.".format(Bucket)
426         ret["result"] = None
427         return ret
428     r = __salt__["boto_s3_bucket.delete"](
429         Bucket, Force=Force, region=region, key=key, keyid=keyid, profile=profile
430     )
431     if not r["deleted"]:
432         ret["result"] = False
433         ret["comment"] = "Failed to delete bucket: {}.".format(r["error"]["message"])
434         return ret
435     ret["changes"]["old"] = {"bucket": Bucket}
436     ret["changes"]["new"] = {"bucket": None}
437     ret["comment"] = "S3 bucket {} deleted.".format(Bucket)
438     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
