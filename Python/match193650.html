<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_nilrt_ip_1.py &amp; boto_s3_bucket.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_nilrt_ip_1.py &amp; boto_s3_bucket.py
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_nilrt_ip_1.py (1.7391304%)<th>boto_s3_bucket.py (1.734104%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(222-226)<td><a href="#" name="0">(533-551)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_nilrt_ip_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import configparser
import re
import shutil
import time
import pytest
import salt.modules.nilrt_ip as ip
import salt.utils.files
import salt.utils.platform
from tests.support.case import ModuleCase
from tests.support.helpers import requires_system_grains, runs_on
from tests.support.unit import skipIf
try:
    import pyiface
    from pyiface.ifreqioctls import IFF_LOOPBACK, IFF_RUNNING
except ImportError:
    pyiface = None
try:
    from requests.structures import CaseInsensitiveDict
except ImportError:
    CaseInsensitiveDict = None
INTERFACE_FOR_TEST = "eth1"
@pytest.mark.skip_if_not_root
@skipIf(not pyiface, "The python pyiface package is not installed")
@skipIf(not CaseInsensitiveDict, "The python package requests is not installed")
@runs_on(os_family="NILinuxRT", reason="Tests applicable only to NILinuxRT")
@pytest.mark.destructive_test
class NilrtIpModuleTest(ModuleCase):
    @requires_system_grains
    @classmethod
    def setUpClass(cls, grains):  # pylint: disable=arguments-differ
        cls.initialState = {}
        cls.grains = grains
    @classmethod
    def tearDownClass(cls):
        cls.initialState = cls.grains = None
    @staticmethod
    def setup_loader_modules():
        return {ip: {}}
    def setUp(self):
        super().setUp()
        if self.grains["lsb_distrib_id"] == "nilrt":
            shutil.move("/etc/natinst/share/ni-rt.ini", "/tmp/ni-rt.ini")
        else:
            shutil.move("/var/lib/connman", "/tmp/connman")
    def tearDown(self):
        if self.grains["lsb_distrib_id"] == "nilrt":
            shutil.move("/tmp/ni-rt.ini", "/etc/natinst/share/ni-rt.ini")
            self.run_function("cmd.run", ["/etc/init.d/networking restart"])
        else:
            shutil.move("/tmp/connman", "/var/lib/connman")
            self.run_function("service.restart", ["connman"])
        time.sleep(10)  # wait 10 seconds for connman to be fully loaded
        interfaces = self.__interfaces()
        for interface in interfaces:
            self.run_function("ip.up", [interface.name])
    @staticmethod
    def __connected(interface):
        return interface.flags &amp; IFF_RUNNING != 0
    @staticmethod
    def __interfaces():
        return [
            interface
            for interface in pyiface.getIfaces()
            if interface.flags &amp; IFF_LOOPBACK == 0
        ]
    def __check_ethercat(self):
        if self.grains["lsb_distrib_id"] != "nilrt":
            return False
        with salt.utils.files.fopen("/etc/natinst/share/ni-rt.ini", "r") as config_file:
            config_parser = configparser.RawConfigParser(dict_type=CaseInsensitiveDict)
            config_parser.readfp(config_file)
            return (
                "ethercat"
                in config_parser.get(
                    "lvrt", "AdditionalNetworkProtocols", fallback=""
                ).lower()
            )
    def test_down(self):
        interfaces = self.__interfaces()
        for interface in interfaces:
            result = self.run_function("ip.down", [interface.name])
            self.assertTrue(result)
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if self.grains["lsb_distrib_id"] == "nilrt":
                self.assertEqual(interface["adapter_mode"], "disabled")
            self.assertFalse(
                self.__connected(pyiface.Interface(name=interface["connectionid"]))
            )
    def test_up(self):
        interfaces = self.__interfaces()
        for interface in interfaces:
            self.run_function("ip.down", [interface.name])
            self.assertFalse(self.__connected(interface))
        for interface in interfaces:
            result = self.run_function("ip.up", [interface.name])
            self.assertTrue(result)
        if self.grains["lsb_distrib_id"] == "nilrt":
            info = self.run_function("ip.get_interfaces_details", timeout=300)
            for interface in info["interfaces"]:
                self.assertEqual(interface["adapter_mode"], "tcpip")
    def test_set_dhcp_linklocal_all(self):
        interfaces = self.__interfaces()
        for interface in interfaces:
            result = self.run_function("ip.set_dhcp_linklocal_all", [interface.name])
            self.assertTrue(result)
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
            if self.grains["lsb_distrib_id"] == "nilrt":
                self.assertEqual(interface["adapter_mode"], "tcpip")
    def test_set_dhcp_only_all(self):
        if self.grains["lsb_distrib_id"] != "nilrt":
            self.skipTest("Test not applicable to newer nilrt")
        interfaces = self.__interfaces()
        for interface in interfaces:
            result = self.run_function("ip.set_dhcp_only_all", [interface.name])
            self.assertTrue(result)
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_only")
            self.assertEqual(interface["adapter_mode"], "tcpip")
    def test_set_linklocal_only_all(self):
        if self.grains["lsb_distrib_id"] != "nilrt":
            self.skipTest("Test not applicable to newer nilrt")
        interfaces = self.__interfaces()
        for interface in interfaces:
            result = self.run_function("ip.set_linklocal_only_all", [interface.name])
            self.assertTrue(result)
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            self.assertEqual(interface["ipv4"]["requestmode"], "linklocal_only")
            self.assertEqual(interface["adapter_mode"], "tcpip")
    def test_static_all(self):
        interfaces = self.__interfaces()
        for interface in interfaces:
            result = self.run_function(
                "ip.set_static_all",
                [
                    interface.name,
                    "192.168.10.4",
                    "255.255.255.0",
                    "192.168.10.1",
                    "8.8.4.4 8.8.8.8",
                ],
            )
            self.assertTrue(result)
<a name="0"></a>
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if self.grains<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["lsb_distrib_id"] != "nilrt":
                self.assertIn("8.8.4.4", interface["ipv4"]["dns"])
                self.assertIn("8.8.8.8", interface["ipv4"]["dns"])
            else:
                self.assertEqual(interface[</b></font>"ipv4"]["dns"], ["8.8.4.4"])
                self.assertEqual(interface["adapter_mode"], "tcpip")
            self.assertEqual(interface["ipv4"]["requestmode"], "static")
            self.assertEqual(interface["ipv4"]["address"], "192.168.10.4")
            self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
            self.assertEqual(interface["ipv4"]["gateway"], "192.168.10.1")
    def test_supported_adapter_modes(self):
        if self.grains["lsb_distrib_id"] != "nilrt":
            self.skipTest("Test is just for older nilrt distros")
        interface_pattern = re.compile("^eth[0-9]+$")
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == "eth0":
                self.assertEqual(interface["supported_adapter_modes"], ["tcpip"])
            else:
                self.assertIn("tcpip", interface["supported_adapter_modes"])
                if not interface_pattern.match(interface["connectionid"]):
                    self.assertNotIn("ethercat", interface["supported_adapter_modes"])
                elif self.__check_ethercat():
                    self.assertIn("ethercat", interface["supported_adapter_modes"])
    def test_ethercat(self):
        if not self.__check_ethercat():
            self.skipTest("Test is just for systems with Ethercat")
        self.assertTrue(self.run_function("ip.set_ethercat", [INTERFACE_FOR_TEST, 19]))
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["adapter_mode"], "ethercat")
                self.assertEqual(int(interface["ethercat"]["masterid"]), 19)
                break
        self.assertTrue(
            self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["adapter_mode"], "tcpip")
                self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
                break
    @pytest.mark.destructive_test
    def test_dhcp_disable(self):
        if self.grains["lsb_distrib_id"] == "nilrt":
            self.skipTest("Test is just for newer nilrt distros")
        self.assertTrue(
            self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
                break
        self.assertTrue(self.run_function("ip.disable", [INTERFACE_FOR_TEST]))
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "disabled")
                break
        self.assertTrue(
            self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
                break
    @pytest.mark.destructive_test
    def test_dhcp_static(self):
        if self.grains["lsb_distrib_id"] == "nilrt":
            self.skipTest("Test is just for newer nilrt distros")
        self.assertTrue(
            self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
                break
        self.assertTrue(
            self.run_function(
                "ip.set_static_all",
                [
                    INTERFACE_FOR_TEST,
                    "192.168.1.125",
                    "255.255.255.0",
                    "192.168.1.1",
                    "8.8.8.8 8.8.8.4",
                ],
            )
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "static")
                self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
                self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
                self.assertIn("8.8.8.4", interface["ipv4"]["dns"])
                self.assertIn("8.8.8.8", interface["ipv4"]["dns"])
                break
        self.assertTrue(
            self.run_function("ip.set_dhcp_linklocal_all", [INTERFACE_FOR_TEST])
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "dhcp_linklocal")
                break
    @pytest.mark.destructive_test
    def test_static_disable(self):
        if self.grains["lsb_distrib_id"] == "nilrt":
            self.skipTest("Test is just for newer nilrt distros")
        self.assertTrue(
            self.run_function(
                "ip.set_static_all",
                [
                    INTERFACE_FOR_TEST,
                    "192.168.1.125",
                    "255.255.255.0",
                    "192.168.1.1",
                    "8.8.8.8",
                ],
            )
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "static")
                self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
                self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
                self.assertEqual(interface["ipv4"]["dns"], ["8.8.8.8"])
                break
        self.assertTrue(self.run_function("ip.disable", [INTERFACE_FOR_TEST]))
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "disabled")
                break
        self.assertTrue(
            self.run_function(
                "ip.set_static_all",
                [INTERFACE_FOR_TEST, "192.168.1.125", "255.255.255.0", "192.168.1.1"],
            )
        )
        info = self.run_function("ip.get_interfaces_details", timeout=300)
        for interface in info["interfaces"]:
            if interface["connectionid"] == INTERFACE_FOR_TEST:
                self.assertEqual(interface["ipv4"]["requestmode"], "static")
                self.assertEqual(interface["ipv4"]["address"], "192.168.1.125")
                self.assertEqual(interface["ipv4"]["netmask"], "255.255.255.0")
                self.assertEqual(interface["ipv4"]["dns"], [])
                break
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_s3_bucket.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import logging
import salt.utils.json
log = logging.getLogger(__name__)
def __virtual__():
    if "boto_s3_bucket.exists" in __salt__:
        return "boto_s3_bucket"
    return (False, "boto_s3_bucket module could not be loaded")
def _normalize_user(user_dict):
    ret = copy.deepcopy(user_dict)
    if "Type" in ret:
        del ret["Type"]
    return ret
def _get_canonical_id(region, key, keyid, profile):
    ret = __salt__["boto_s3_bucket.list"](
        region=region, key=key, keyid=keyid, profile=profile
    ).get("Owner")
    return _normalize_user(ret)
def _prep_acl_for_compare(ACL):
    ret = copy.deepcopy(ACL)
    ret["Owner"] = _normalize_user(ret["Owner"])
    for item in ret.get("Grants", ()):
        item["Grantee"] = _normalize_user(item.get("Grantee"))
    return ret
def _acl_to_grant(ACL, owner_canonical_id):
    if "AccessControlPolicy" in ACL:
        ret = copy.deepcopy(ACL["AccessControlPolicy"])
        ret["Owner"] = _normalize_user(ret["Owner"])
        for item in ACL.get("Grants", ()):
            item["Grantee"] = _normalize_user(item.get("Grantee"))
        return ret
    owner_canonical_grant = copy.deepcopy(owner_canonical_id)
    owner_canonical_grant.update({"Type": "CanonicalUser"})
    ret = {"Grants": [], "Owner": owner_canonical_id}
    if "ACL" in ACL:
        acl = ACL["ACL"]
        if acl in ("public-read", "public-read-write"):
            ret["Grants"].append(
                {
                    "Grantee": {
                        "Type": "Group",
                        "URI": "http://acs.amazonaws.com/groups/global/AllUsers",
                    },
                    "Permission": "READ",
                }
            )
        if acl == "public-read-write":
            ret["Grants"].append(
                {
                    "Grantee": {
                        "Type": "Group",
                        "URI": "http://acs.amazonaws.com/groups/global/AllUsers",
                    },
                    "Permission": "WRITE",
                }
            )
        if acl == "aws-exec-read":
            ret["Grants"].append(
                {
                    "Grantee": {
                        "Type": "CanonicalUser",
                        "DisplayName": "za-team",
                        "ID": "6aa5a366c34c1cbe25dc49211496e913e0351eb0e8c37aa3477e40942ec6b97c",
                    },
                    "Permission": "READ",
                }
            )
        if acl == "authenticated-read":
            ret["Grants"].append(
                {
                    "Grantee": {
                        "Type": "Group",
                        "URI": (
                            "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
                        ),
                    },
                    "Permission": "READ",
                }
            )
        if acl == "log-delivery-write":
            for permission in ("WRITE", "READ_ACP"):
                ret["Grants"].append(
                    {
                        "Grantee": {
                            "Type": "Group",
                            "URI": "http://acs.amazonaws.com/groups/s3/LogDelivery",
                        },
                        "Permission": permission,
                    }
                )
    for key, permission in (
        ("GrantFullControl", "FULL_CONTROL"),
        ("GrantRead", "READ"),
        ("GrantReadACP", "READ_ACP"),
        ("GrantWrite", "WRITE"),
        ("GrantWriteACP", "WRITE_ACP"),
    ):
        if key in ACL:
            for item in ACL[key].split(","):
                kind, val = item.split("=")
                if kind == "uri":
                    grantee = {"Type": "Group", "URI": val}
                elif kind == "id":
                    grantee = {
                        "Type": "CanonicalUser",
                        "ID": val,
                    }
                else:
                    grantee = {
                    }
                ret["Grants"].append({"Grantee": grantee, "Permission": permission})
    if not ret["Grants"]:
        ret["Grants"] = [
            {"Grantee": owner_canonical_grant, "Permission": "FULL_CONTROL"}
        ]
    return ret
def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
    if name.startswith("arn:aws:iam:"):
        return name
    account_id = __salt__["boto_iam.get_account_id"](
        region=region, key=key, keyid=keyid, profile=profile
    )
    if profile and "region" in profile:
        region = profile["region"]
    if region is None:
        region = "us-east-1"
    return "arn:aws:iam::{}:role/{}".format(account_id, name)
def _compare_json(current, desired, region, key, keyid, profile):
    return __utils__["boto3.json_objs_equal"](current, desired)
def _compare_acl(current, desired, region, key, keyid, profile):
    ocid = _get_canonical_id(region, key, keyid, profile)
    return __utils__["boto3.json_objs_equal"](current, _acl_to_grant(desired, ocid))
def _compare_policy(current, desired, region, key, keyid, profile):
    return current == desired
def _compare_replication(current, desired, region, key, keyid, profile):
    if desired is not None and desired.get("Role"):
        desired = copy.deepcopy(desired)
        desired["Role"] = _get_role_arn(
            desired["Role"], region=region, key=key, keyid=keyid, profile=profile
        )
    return __utils__["boto3.json_objs_equal"](current, desired)
def present(
    name,
    Bucket,
    LocationConstraint=None,
    ACL=None,
    CORSRules=None,
    LifecycleConfiguration=None,
    Logging=None,
    NotificationConfiguration=None,
    Policy=None,
    Replication=None,
    RequestPayment=None,
    Tagging=None,
    Versioning=None,
    Website=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    ret = {"name": Bucket, "result": True, "comment": "", "changes": {}}
    if ACL is None:
        ACL = {"ACL": "private"}
    if NotificationConfiguration is None:
        NotificationConfiguration = {}
    if RequestPayment is None:
        RequestPayment = {"Payer": "BucketOwner"}
    if Policy:
        if isinstance(Policy, str):
            Policy = salt.utils.json.loads(Policy)
        Policy = __utils__["boto3.ordered"](Policy)
    r = __salt__["boto_s3_bucket.exists"](
        Bucket=Bucket, region=region, key=key, keyid=keyid, profile=profile
    )
    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to create bucket: {}.".format(r["error"]["message"])
        return ret
    if not r.get("exists"):
        if __opts__["test"]:
            ret["comment"] = "S3 bucket {} is set to be created.".format(Bucket)
            ret["result"] = None
            return ret
        r = __salt__["boto_s3_bucket.create"](
            Bucket=Bucket,
            LocationConstraint=LocationConstraint,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        if not r.get("created"):
            ret["result"] = False
            ret["comment"] = "Failed to create bucket: {}.".format(
                r["error"]["message"]
            )
            return ret
        for setter, testval, funcargs in (
            ("put_acl", ACL, ACL),
            ("put_cors", CORSRules, {"CORSRules": CORSRules}),
            (
                "put_lifecycle_configuration",
                LifecycleConfiguration,
                {"Rules": LifecycleConfiguration},
            ),
            ("put_logging", Logging, Logging),
            (
                "put_notification_configuration",
                NotificationConfiguration,
                NotificationConfiguration,
            ),
            ("put_policy", Policy, {"Policy": Policy}),
            ("put_versioning", Versioning, Versioning),
            ("put_replication", Replication, Replication),
            ("put_request_payment", RequestPayment, RequestPayment),
            ("put_tagging", Tagging, Tagging),
            ("put_website", Website, Website),
        ):
            if testval is not None:
                r = __salt__["boto_s3_bucket.{}".format(setter)](
                    Bucket=Bucket,
                    region=region,
                    key=key,
                    keyid=keyid,
                    profile=profile,
                    **funcargs
                )
                if not r.get("updated"):
                    ret["result"] = False
                    ret["comment"] = "Failed to create bucket: {}.".format(
                        r["error"]["message"]
                    )
                    return ret
        _describe = __salt__["boto_s3_bucket.describe"](
            Bucket, region=region, key=key, keyid=keyid, profile=profile
        )
        ret["changes"]["old"] = {"bucket": None}
        ret["changes"]["new"] = _describe
        ret["comment"] = "S3 bucket {} created.".format(Bucket)
        return ret
    ret["comment"] = " ".join(
        [ret["comment"], "S3 bucket {} is present.".format(Bucket)]
    )
    ret["changes"] = {}
    _describe = __salt__["boto_s3_bucket.describe"](
        Bucket=Bucket, region=region, key=key, keyid=keyid, profile=profile
    )
    if "error" in _describe:
        ret["result"] = False
        ret["comment"] = "Failed to update bucket: {}.".format(
            _describe["error"]["message"]
        )
        ret["changes"] = {}
        return ret
    _describe = _describe["bucket"]
    if not bool(Versioning) and bool(_describe.get("Versioning")):
        Versioning = {"Status": "Suspended"}
<a name="0"></a>    config_items = [
        ("ACL", "put_acl", _describe.get("ACL"), _compare_acl, ACL, None),
        (
            <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"CORS",
            "put_cors",
            _describe.get("CORS"),
            _compare_json,
            {"CORSRules": CORSRules} if CORSRules else None,
            "delete_cors",
        ),
        (
            "LifecycleConfiguration",
            "put_lifecycle_configuration",
            _describe.get("LifecycleConfiguration"),
            _compare_json,
            {"Rules": LifecycleConfiguration} if LifecycleConfiguration else None,
            "delete_lifecycle_configuration",
        ),
        (
            "Logging",
            "put_logging",
            _describe.get("Logging", {}).</b></font>get("LoggingEnabled"),
            _compare_json,
            Logging,
            None,
        ),
        (
            "NotificationConfiguration",
            "put_notification_configuration",
            _describe.get("NotificationConfiguration"),
            _compare_json,
            NotificationConfiguration,
            None,
        ),
        (
            "Policy",
            "put_policy",
            _describe.get("Policy"),
            _compare_policy,
            {"Policy": Policy} if Policy else None,
            "delete_policy",
        ),
        (
            "RequestPayment",
            "put_request_payment",
            _describe.get("RequestPayment"),
            _compare_json,
            RequestPayment,
            None,
        ),
        (
            "Tagging",
            "put_tagging",
            _describe.get("Tagging"),
            _compare_json,
            Tagging,
            "delete_tagging",
        ),
        (
            "Website",
            "put_website",
            _describe.get("Website"),
            _compare_json,
            Website,
            "delete_website",
        ),
    ]
    versioning_item = (
        "Versioning",
        "put_versioning",
        _describe.get("Versioning"),
        _compare_json,
        Versioning or {},
        None,
    )
    replication_item = (
        "Replication",
        "put_replication",
        _describe.get("Replication", {}).get("ReplicationConfiguration"),
        _compare_replication,
        Replication,
        "delete_replication",
    )
    if Replication is not None:
        config_items.append(versioning_item)
        config_items.append(replication_item)
    else:
        config_items.append(replication_item)
        config_items.append(versioning_item)
    update = False
    for varname, setter, current, comparator, desired, deleter in config_items:
        if varname == "Policy":
            if current is not None:
                temp = current.get("Policy")
                if isinstance(temp, str):
                    current = __utils__["boto3.ordered"](
                        {"Policy": salt.utils.json.loads(temp)}
                    )
        if not comparator(current, desired, region, key, keyid, profile):
            update = True
            if varname == "ACL":
                ret["changes"].setdefault("new", {})[varname] = _acl_to_grant(
                    desired, _get_canonical_id(region, key, keyid, profile)
                )
            else:
                ret["changes"].setdefault("new", {})[varname] = desired
            ret["changes"].setdefault("old", {})[varname] = current
            if not __opts__["test"]:
                if deleter and desired is None:
                    r = __salt__["boto_s3_bucket.{}".format(deleter)](
                        Bucket=Bucket,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                    )
                    if not r.get("deleted"):
                        ret["result"] = False
                        ret["comment"] = "Failed to update bucket: {}.".format(
                            r["error"]["message"]
                        )
                        ret["changes"] = {}
                        return ret
                else:
                    r = __salt__["boto_s3_bucket.{}".format(setter)](
                        Bucket=Bucket,
                        region=region,
                        key=key,
                        keyid=keyid,
                        profile=profile,
                        **(desired or {})
                    )
                    if not r.get("updated"):
                        ret["result"] = False
                        ret["comment"] = "Failed to update bucket: {}.".format(
                            r["error"]["message"]
                        )
                        ret["changes"] = {}
                        return ret
    if update and __opts__["test"]:
        msg = "S3 bucket {} set to be modified.".format(Bucket)
        ret["comment"] = msg
        ret["result"] = None
        return ret
    if _describe.get("Location", {}).get("LocationConstraint") != LocationConstraint:
        msg = (
            "Bucket {} location does not match desired configuration, but cannot be"
            " changed".format(LocationConstraint)
        )
        log.warning(msg)
        ret["result"] = False
        ret["comment"] = "Failed to update bucket: {}.".format(msg)
        return ret
    return ret
def absent(name, Bucket, Force=False, region=None, key=None, keyid=None, profile=None):
    ret = {"name": Bucket, "result": True, "comment": "", "changes": {}}
    r = __salt__["boto_s3_bucket.exists"](
        Bucket, region=region, key=key, keyid=keyid, profile=profile
    )
    if "error" in r:
        ret["result"] = False
        ret["comment"] = "Failed to delete bucket: {}.".format(r["error"]["message"])
        return ret
    if r and not r["exists"]:
        ret["comment"] = "S3 bucket {} does not exist.".format(Bucket)
        return ret
    if __opts__["test"]:
        ret["comment"] = "S3 bucket {} is set to be removed.".format(Bucket)
        ret["result"] = None
        return ret
    r = __salt__["boto_s3_bucket.delete"](
        Bucket, Force=Force, region=region, key=key, keyid=keyid, profile=profile
    )
    if not r["deleted"]:
        ret["result"] = False
        ret["comment"] = "Failed to delete bucket: {}.".format(r["error"]["message"])
        return ret
    ret["changes"]["old"] = {"bucket": Bucket}
    ret["changes"]["new"] = {"bucket": None}
    ret["comment"] = "S3 bucket {} deleted.".format(Bucket)
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
