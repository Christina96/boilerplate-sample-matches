<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_biconnected.py &amp; test_graphmatrix.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_biconnected.py &amp; test_graphmatrix.py
      </h3>
<h1 align="center">
        8.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_biconnected.py (11.111111%)<th>test_graphmatrix.py (7.191781%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(202-219)<td><a href="#" name="0">(55-69)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(98-109)<td><a href="#" name="1">(14-15)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(26-38)<td><a href="#" name="2">(32-42)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_biconnected.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 from networkx import NetworkXNotImplemented
4 def assert_components_edges_equal(x, y):
5     sx = {frozenset(frozenset(e) for e in c) for c in x}
6     sy = {frozenset(frozenset(e) for e in c) for c in y}
7     assert sx == sy
8 def assert_components_equal(x, y):
9     sx = {frozenset(c) for c in x}
10     sy = {frozenset(c) for c in y}
11     assert sx == sy
12 def test_barbell():
13     G = nx.barbell_graph(8, 4)
14     nx.add_path(G, [7, 20, 21, 22])
15     nx.add_cycle(G, [22, 23, 24, 25])
16     pts = set(nx.articulation_points(G))
17     answer = [
18         {<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>12, 13, 14, 15, 16, 17, 18, 19},
19         {0, 1, 2, 3, 4, 5, 6, 7},
20         {22, 23, 24, 25},
21         {11, 12},
22         {10, 11},
23         {9, 10},
24         {8, 9},
25         {7, 8},
26         {21, 22},
27         {20, 21},
28         {7, 20},
29     ]
30     assert_components_equal(</b></font>list(nx.biconnected_components(G)), answer)
31     G.add_edge(2, 17)
32     pts = set(nx.articulation_points(G))
33     assert pts == {7, 20, 21, 22}
34 def test_articulation_points_repetitions():
35     G = nx.Graph()
36     G.add_edges_from([(0, 1), (1, 2), (1, 3)])
37     assert list(nx.articulation_points(G)) == [1]
38 def test_articulation_points_cycle():
39     G = nx.cycle_graph(3)
40     nx.add_cycle(G, [1, 3, 4])
41     pts = set(nx.articulation_points(G))
42     assert pts == {1}
43 def test_is_biconnected():
44     G = nx.cycle_graph(3)
45     assert nx.is_biconnected(G)
46     nx.add_cycle(G, [1, 3, 4])
47     assert not nx.is_biconnected(G)
48 def test_empty_is_biconnected():
49     G = nx.empty_graph(5)
50     assert not nx.is_biconnected(G)
51     G.add_edge(0, 1)
52     assert not nx.is_biconnected(G)
53 def test_biconnected_components_cycle():
54     G = nx.cycle_graph(3)
55     nx.add_cycle(G, [1, 3, 4])
56     answer = [{0, 1, 2}, {1, 3, 4}]
57     assert_components_equal(list(nx.biconnected_components(G)), answer)
58 def test_biconnected_components1():
59     edges = [
60         (0, 1),
61         (0, 5),
62         (0, 6),
63         (0, 14),
64         (1, 5),
65         (1, 6),
66         (1, 14),
67         (2, 4),
68         (2, 10),
69         (3, 4),
70         (3, 15),
71         (4, 6),
72         (4, 10),
73         (5, 14),
74         (<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>6, 14),
75         (7, 9),
76         (8, 9),
77         (8, 12),
78         (8, 13),
79         (10, 15),
80         (11, 12),
81         (11, 13),
82         (12, 13),
83     ]
84     G = nx.Graph(edges)
85     pts =</b></font> set(nx.articulation_points(G))
86     assert pts == {4, 6, 7, 8, 9}
87     comps = list(nx.biconnected_component_edges(G))
88     answer = [
89         [(3, 4), (15, 3), (10, 15), (10, 4), (2, 10), (4, 2)],
90         [(13, 12), (13, 8), (11, 13), (12, 11), (8, 12)],
91         [(9, 8)],
92         [(7, 9)],
93         [(4, 7)],
94         [(6, 4)],
95         [(14, 0), (5, 1), (5, 0), (14, 5), (14, 1), (6, 14), (6, 0), (1, 6), (0, 1)],
96     ]
97     assert_components_edges_equal(comps, answer)
98 def test_biconnected_components2():
99     G = nx.Graph()
100     nx.add_cycle(G, "ABC")
101     nx.add_cycle(G, "CDE")
102     nx.add_cycle(G, "FIJHG")
103     nx.add_cycle(G, "GIJ")
104     G.add_edge("E", "G")
105     comps = list(nx.biconnected_component_edges(G))
106     answer = [
107         [
108             tuple("GF"),
109             tuple("FI"),
110             tuple("IG"),
111             tuple("IJ"),
112             tuple("JG"),
113             tuple("JH"),
114             tuple("HG"),
115         ],
116         [tuple("EG")],
117         [tuple("CD"), tuple("DE"), tuple("CE")],
118         [tuple("AB"), tuple("BC"), tuple("AC")],
119     ]
120     assert_components_edges_equal(comps, answer)
121 def test_biconnected_davis():
122     D = nx.davis_southern_women_graph()
123     bcc = list(nx.biconnected_components(D))[0]
124     assert set(D) == bcc  # All nodes in a giant bicomponent
125     assert len(list(nx.articulation_points(D))) == 0
126 def test_biconnected_karate():
127     K = nx.karate_club_graph()
128     answer = [
129         {
130             0,
131             1,
132             2,
133             3,
134             7,
135             8,
136             9,
137             12,
138             13,
139             14,
140             15,
141             17,
142             18,
143             19,
144             20,
145             21,
146             22,
147             23,
148             24,
149             25,
150             26,
151             27,
152             28,
153             29,
154             30,
155             31,
156             32,
157             33,
158         },
159         {0, 4, 5, 6, 10, 16},
160         {0, 11},
161     ]
162     bcc = list(nx.biconnected_components(K))
163     assert_components_equal(bcc, answer)
164     assert set(nx.articulation_points(K)) == {0}
165 def test_biconnected_eppstein():
166     G1 = nx.Graph(
167         {
168             0: [<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>1, 2, 5],
169             1: [0, 5],
170             2: [0, 3, 4],
171             3: [2, 4, 5, 6],
172             4: [2, 3, 5, 6],
173             5: [0, 1, 3, 4],
174             6: [3, 4],
175         }
176     )
177     G2 = nx.Graph(
178         {
179             0: [2, 5],
180             1: [3, 8],
181             2: [0, 3, 5],
182             3: [1, 2, 6, 8],
183             4: [7],
184             5: [0, 2],
185             6: [3</b></font>, 8],
186             7: [4],
187             8: [1, 3, 6],
188         }
189     )
190     assert nx.is_biconnected(G1)
191     assert not nx.is_biconnected(G2)
192     answer_G2 = [{1, 3, 6, 8}, {0, 2, 5}, {2, 3}, {4, 7}]
193     bcc = list(nx.biconnected_components(G2))
194     assert_components_equal(bcc, answer_G2)
195 def test_null_graph():
196     G = nx.Graph()
197     assert not nx.is_biconnected(G)
198     assert list(nx.biconnected_components(G)) == []
199     assert list(nx.biconnected_component_edges(G)) == []
200     assert list(nx.articulation_points(G)) == []
201 def test_connected_raise():
202     DG = nx.DiGraph()
203     with pytest.raises(NetworkXNotImplemented):
204         next(nx.biconnected_components(DG))
205     with pytest.raises(NetworkXNotImplemented):
206         next(nx.biconnected_component_edges(DG))
207     with pytest.raises(NetworkXNotImplemented):
208         next(nx.articulation_points(DG))
209     pytest.raises(NetworkXNotImplemented, nx.is_biconnected, DG)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_graphmatrix.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 np = pytest.importorskip("numpy")
3 pytest.importorskip("scipy")
4 import networkx as nx
5 from networkx.generators.degree_seq import havel_hakimi_graph
6 from networkx.exception import NetworkXError
7     deg = [3, 2, 2, 1, 0]
8     G = havel_hakimi_graph(deg)
9     deg = [<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(1, 0), (1, 0), (1, 0), (2, 0), (1, 0), (2, 1), (0, 1), (0, 1)]
10     MG = nx.random_clustered_graph(deg, seed=</b></font>42)
11     I = nx.incidence_matrix(G).todense().astype(int)
12     expected = np.array(
13         [[1, 1, 1, 0],
14          [0, 1, 0, 1],
15          [1, 0, 0, 1],
16          [0, 0, 1, 0],
17          [0, 0, 0, 0]]
18     )
19     np.testing.assert_equal(I, expected)
20     expected = np.array(
21         [<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[1, 0, 0, 0, 0, 0, 0],
22          [1, 0, 0, 0, 0, 0, 0],
23          [0, 1, 0, 0, 0, 0, 0],
24          [0, 0, 0, 0, 0, 0, 0],
25          [0, 1, 0, 0, 0, 0, 0],
26          [0, 0, 0, 0, 1, 1, 0],
27          [0, 0, 0, 0, 0, 1, 1],
28          [0, 0, 0, 0, 1, 0, 1]]
29     )
30     np.testing.assert_equal(</b></font>I, expected)
31     with pytest.raises(NetworkXError):
32         nx.incidence_matrix(G, nodelist=[0, 1])
33 class TestGraphMatrix:
34     @classmethod
35     def setup_class(cls):
36         deg = [3, 2, 2, 1, 0]
37         cls.OI = np.array(
38             [<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[-1, -1, -1, 0],
39              [1, 0, 0, -1],
40              [0, 1, 0, 1],
41              [0, 0, 1, 0],
42              [0, 0, 0, 0]]
43         )
44         cls.A = np.array(
45             [[0, 1, 1, 1, 0],
46              [1, 0, 1, 0, 0],
47              [1, 1, 0, 0, 0],
48              [1, 0, 0, 0, 0],
49              [0, 0, 0, 0, 0]]
50         )
51         cls.</b></font>WG = havel_hakimi_graph(deg)
52         cls.WG.add_edges_from(
53             (u, v, {"weight": 0.5, "other": 0.3}) for (u, v) in cls.G.edges()
54         )
55         cls.WA = np.array(
56             [[0, 0.5, 0.5, 0.5, 0],
57              [0.5, 0, 0.5, 0, 0],
58              [0.5, 0.5, 0, 0, 0],
59              [0.5, 0, 0, 0, 0],
60              [0, 0, 0, 0, 0]]
61         )
62         cls.MG = nx.MultiGraph(cls.G)
63         cls.MG2 = cls.MG.copy()
64         cls.MG2.add_edge(0, 1)
65         cls.MG2A = np.array(
66             [[0, 2, 1, 1, 0],
67              [2, 0, 1, 0, 0],
68              [1, 1, 0, 0, 0],
69              [1, 0, 0, 0, 0],
70              [0, 0, 0, 0, 0]]
71         )
72         cls.MGOI = np.array(
73             [[-1, -1, -1, -1, 0],
74              [1, 1, 0, 0, -1],
75              [0, 0, 1, 0, 1],
76              [0, 0, 0, 1, 0],
77              [0, 0, 0, 0, 0]]
78         )
79         cls.no_edges_G = nx.Graph([(1, 2), (3, 2, {"weight": 8})])
80         cls.no_edges_A = np.array([[0, 0], [0, 0]])
81     def test_incidence_matrix(self):
82         "Conversion to incidence matrix"
83         I = (
84             nx.incidence_matrix(
85                 self.G,
86                 nodelist=sorted(self.G),
87                 edgelist=sorted(self.G.edges()),
88                 oriented=True,
89             )
90             .todense()
91             .astype(int)
92         )
93         np.testing.assert_equal(I, self.OI)
94         I = (
95             nx.incidence_matrix(
96                 self.G,
97                 nodelist=sorted(self.G),
98                 edgelist=sorted(self.G.edges()),
99                 oriented=False,
100             )
101             .todense()
102             .astype(int)
103         )
104         np.testing.assert_equal(I, np.abs(self.OI))
105         I = (
106             nx.incidence_matrix(
107                 self.MG,
108                 nodelist=sorted(self.MG),
109                 edgelist=sorted(self.MG.edges()),
110                 oriented=True,
111             )
112             .todense()
113             .astype(int)
114         )
115         np.testing.assert_equal(I, self.OI)
116         I = (
117             nx.incidence_matrix(
118                 self.MG,
119                 nodelist=sorted(self.MG),
120                 edgelist=sorted(self.MG.edges()),
121                 oriented=False,
122             )
123             .todense()
124             .astype(int)
125         )
126         np.testing.assert_equal(I, np.abs(self.OI))
127         I = (
128             nx.incidence_matrix(
129                 self.MG2,
130                 nodelist=sorted(self.MG2),
131                 edgelist=sorted(self.MG2.edges()),
132                 oriented=True,
133             )
134             .todense()
135             .astype(int)
136         )
137         np.testing.assert_equal(I, self.MGOI)
138         I = (
139             nx.incidence_matrix(
140                 self.MG2,
141                 nodelist=sorted(self.MG),
142                 edgelist=sorted(self.MG2.edges()),
143                 oriented=False,
144             )
145             .todense()
146             .astype(int)
147         )
148         np.testing.assert_equal(I, np.abs(self.MGOI))
149     def test_weighted_incidence_matrix(self):
150         I = (
151             nx.incidence_matrix(
152                 self.WG,
153                 nodelist=sorted(self.WG),
154                 edgelist=sorted(self.WG.edges()),
155                 oriented=True,
156             )
157             .todense()
158             .astype(int)
159         )
160         np.testing.assert_equal(I, self.OI)
161         I = (
162             nx.incidence_matrix(
163                 self.WG,
164                 nodelist=sorted(self.WG),
165                 edgelist=sorted(self.WG.edges()),
166                 oriented=False,
167             )
168             .todense()
169             .astype(int)
170         )
171         np.testing.assert_equal(I, np.abs(self.OI))
172         I = nx.incidence_matrix(
173             self.WG,
174             nodelist=sorted(self.WG),
175             edgelist=sorted(self.WG.edges()),
176             oriented=True,
177             weight="weight",
178         ).todense()
179         np.testing.assert_equal(I, 0.5 * self.OI)
180         I = nx.incidence_matrix(
181             self.WG,
182             nodelist=sorted(self.WG),
183             edgelist=sorted(self.WG.edges()),
184             oriented=False,
185             weight="weight",
186         ).todense()
187         np.testing.assert_equal(I, np.abs(0.5 * self.OI))
188         I = nx.incidence_matrix(
189             self.WG,
190             nodelist=sorted(self.WG),
191             edgelist=sorted(self.WG.edges()),
192             oriented=True,
193             weight="other",
194         ).todense()
195         np.testing.assert_equal(I, 0.3 * self.OI)
196         WMG = nx.MultiGraph(self.WG)
197         WMG.add_edge(0, 1, weight=0.5, other=0.3)
198         I = nx.incidence_matrix(
199             WMG,
200             nodelist=sorted(WMG),
201             edgelist=sorted(WMG.edges(keys=True)),
202             oriented=True,
203             weight="weight",
204         ).todense()
205         np.testing.assert_equal(I, 0.5 * self.MGOI)
206         I = nx.incidence_matrix(
207             WMG,
208             nodelist=sorted(WMG),
209             edgelist=sorted(WMG.edges(keys=True)),
210             oriented=False,
211             weight="weight",
212         ).todense()
213         np.testing.assert_equal(I, np.abs(0.5 * self.MGOI))
214         I = nx.incidence_matrix(
215             WMG,
216             nodelist=sorted(WMG),
217             edgelist=sorted(WMG.edges(keys=True)),
218             oriented=True,
219             weight="other",
220         ).todense()
221         np.testing.assert_equal(I, 0.3 * self.MGOI)
222     def test_adjacency_matrix(self):
223         "Conversion to adjacency matrix"
224         np.testing.assert_equal(nx.adjacency_matrix(self.G).todense(), self.A)
225         np.testing.assert_equal(nx.adjacency_matrix(self.MG).todense(), self.A)
226         np.testing.assert_equal(nx.adjacency_matrix(self.MG2).todense(), self.MG2A)
227         np.testing.assert_equal(
228             nx.adjacency_matrix(self.G, nodelist=[0, 1]).todense(), self.A[:2, :2]
229         )
230         np.testing.assert_equal(nx.adjacency_matrix(self.WG).todense(), self.WA)
231         np.testing.assert_equal(
232             nx.adjacency_matrix(self.WG, weight=None).todense(), self.A
233         )
234         np.testing.assert_equal(
235             nx.adjacency_matrix(self.MG2, weight=None).todense(), self.MG2A
236         )
237         np.testing.assert_equal(
238             nx.adjacency_matrix(self.WG, weight="other").todense(), 0.6 * self.WA
239         )
240         np.testing.assert_equal(
241             nx.adjacency_matrix(self.no_edges_G, nodelist=[1, 3]).todense(),
242             self.no_edges_A,
243         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
