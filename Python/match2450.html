<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_biconnected.py & test_graphmatrix.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_biconnected.py & test_graphmatrix.py
      </h3>
      <h1 align="center">
        8.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_biconnected.py (11.111111%)<TH>test_graphmatrix.py (7.191781%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2450-0.html#0',2,'match2450-1.html#0',3)" NAME="0">(202-219)<TD><A HREF="javascript:ZweiFrames('match2450-0.html#0',2,'match2450-1.html#0',3)" NAME="0">(55-69)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2450-0.html#1',2,'match2450-1.html#1',3)" NAME="1">(98-109)<TD><A HREF="javascript:ZweiFrames('match2450-0.html#1',2,'match2450-1.html#1',3)" NAME="1">(14-15)</A><TD ALIGN=center><FONT COLOR="#c30000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2450-0.html#2',2,'match2450-1.html#2',3)" NAME="2">(26-38)<TD><A HREF="javascript:ZweiFrames('match2450-0.html#2',2,'match2450-1.html#2',3)" NAME="2">(32-42)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_biconnected.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest
import networkx as nx
from networkx import NetworkXNotImplemented


def assert_components_edges_equal(x, y):
    sx = {frozenset(frozenset(e) for e in c) for c in x}
    sy = {frozenset(frozenset(e) for e in c) for c in y}
    assert sx == sy


def assert_components_equal(x, y):
    sx = {frozenset(c) for c in x}
    sy = {frozenset(c) for c in y}
    assert sx == sy


def test_barbell():
    G = nx.barbell_graph(8, 4)
    nx.add_path(G, [7, 20, 21, 22])
    nx.add_cycle(G, [22, 23, 24, 25])
    pts = set(nx.articulation_points(G))
<A NAME="2"></A>    assert pts == {7, 8, 9, 10, 11, 12, 20, 21, 22}

    answer = [
        {<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2450-1.html#2',3,'match2450-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>12, 13, 14, 15, 16, 17, 18, 19},
        {0, 1, 2, 3, 4, 5, 6, 7},
        {22, 23, 24, 25},
        {11, 12},
        {10, 11},
        {9, 10},
        {8, 9},
        {7, 8},
        {21, 22},
        {20, 21},
        {7, 20},
    ]
    assert_components_equal(</B></FONT>list(nx.biconnected_components(G)), answer)

    G.add_edge(2, 17)
    pts = set(nx.articulation_points(G))
    assert pts == {7, 20, 21, 22}


def test_articulation_points_repetitions():
    G = nx.Graph()
    G.add_edges_from([(0, 1), (1, 2), (1, 3)])
    assert list(nx.articulation_points(G)) == [1]


def test_articulation_points_cycle():
    G = nx.cycle_graph(3)
    nx.add_cycle(G, [1, 3, 4])
    pts = set(nx.articulation_points(G))
    assert pts == {1}


def test_is_biconnected():
    G = nx.cycle_graph(3)
    assert nx.is_biconnected(G)
    nx.add_cycle(G, [1, 3, 4])
    assert not nx.is_biconnected(G)


def test_empty_is_biconnected():
    G = nx.empty_graph(5)
    assert not nx.is_biconnected(G)
    G.add_edge(0, 1)
    assert not nx.is_biconnected(G)


def test_biconnected_components_cycle():
    G = nx.cycle_graph(3)
    nx.add_cycle(G, [1, 3, 4])
    answer = [{0, 1, 2}, {1, 3, 4}]
    assert_components_equal(list(nx.biconnected_components(G)), answer)


def test_biconnected_components1():
    # graph example from
    # https://web.archive.org/web/20121229123447/http://www.ibluemojo.com/school/articul_algorithm.html
    edges = [
        (0, 1),
        (0, 5),
        (0, 6),
        (0, 14),
        (1, 5),
        (1, 6),
        (1, 14),
        (2, 4),
        (2, 10),
        (3, 4),
        (3, 15),
        (4, 6),
<A NAME="1"></A>        (4, 7),
        (4, 10),
        (5, 14),
        (<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2450-1.html#1',3,'match2450-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>6, 14),
        (7, 9),
        (8, 9),
        (8, 12),
        (8, 13),
        (10, 15),
        (11, 12),
        (11, 13),
        (12, 13),
    ]
    G = nx.Graph(edges)
    pts =</B></FONT> set(nx.articulation_points(G))
    assert pts == {4, 6, 7, 8, 9}
    comps = list(nx.biconnected_component_edges(G))
    answer = [
        [(3, 4), (15, 3), (10, 15), (10, 4), (2, 10), (4, 2)],
        [(13, 12), (13, 8), (11, 13), (12, 11), (8, 12)],
        [(9, 8)],
        [(7, 9)],
        [(4, 7)],
        [(6, 4)],
        [(14, 0), (5, 1), (5, 0), (14, 5), (14, 1), (6, 14), (6, 0), (1, 6), (0, 1)],
    ]
    assert_components_edges_equal(comps, answer)


def test_biconnected_components2():
    G = nx.Graph()
    nx.add_cycle(G, &quot;ABC&quot;)
    nx.add_cycle(G, &quot;CDE&quot;)
    nx.add_cycle(G, &quot;FIJHG&quot;)
    nx.add_cycle(G, &quot;GIJ&quot;)
    G.add_edge(&quot;E&quot;, &quot;G&quot;)
    comps = list(nx.biconnected_component_edges(G))
    answer = [
        [
            tuple(&quot;GF&quot;),
            tuple(&quot;FI&quot;),
            tuple(&quot;IG&quot;),
            tuple(&quot;IJ&quot;),
            tuple(&quot;JG&quot;),
            tuple(&quot;JH&quot;),
            tuple(&quot;HG&quot;),
        ],
        [tuple(&quot;EG&quot;)],
        [tuple(&quot;CD&quot;), tuple(&quot;DE&quot;), tuple(&quot;CE&quot;)],
        [tuple(&quot;AB&quot;), tuple(&quot;BC&quot;), tuple(&quot;AC&quot;)],
    ]
    assert_components_edges_equal(comps, answer)


def test_biconnected_davis():
    D = nx.davis_southern_women_graph()
    bcc = list(nx.biconnected_components(D))[0]
    assert set(D) == bcc  # All nodes in a giant bicomponent
    # So no articulation points
    assert len(list(nx.articulation_points(D))) == 0


def test_biconnected_karate():
    K = nx.karate_club_graph()
    answer = [
        {
            0,
            1,
            2,
            3,
            7,
            8,
            9,
            12,
            13,
            14,
            15,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
        },
        {0, 4, 5, 6, 10, 16},
        {0, 11},
    ]
    bcc = list(nx.biconnected_components(K))
    assert_components_equal(bcc, answer)
    assert set(nx.articulation_points(K)) == {0}


def test_biconnected_eppstein():
<A NAME="0"></A>    # tests from http://www.ics.uci.edu/~eppstein/PADS/Biconnectivity.py
    G1 = nx.Graph(
        {
            0: [<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2450-1.html#0',3,'match2450-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>1, 2, 5],
            1: [0, 5],
            2: [0, 3, 4],
            3: [2, 4, 5, 6],
            4: [2, 3, 5, 6],
            5: [0, 1, 3, 4],
            6: [3, 4],
        }
    )
    G2 = nx.Graph(
        {
            0: [2, 5],
            1: [3, 8],
            2: [0, 3, 5],
            3: [1, 2, 6, 8],
            4: [7],
            5: [0, 2],
            6: [3</B></FONT>, 8],
            7: [4],
            8: [1, 3, 6],
        }
    )
    assert nx.is_biconnected(G1)
    assert not nx.is_biconnected(G2)
    answer_G2 = [{1, 3, 6, 8}, {0, 2, 5}, {2, 3}, {4, 7}]
    bcc = list(nx.biconnected_components(G2))
    assert_components_equal(bcc, answer_G2)


def test_null_graph():
    G = nx.Graph()
    assert not nx.is_biconnected(G)
    assert list(nx.biconnected_components(G)) == []
    assert list(nx.biconnected_component_edges(G)) == []
    assert list(nx.articulation_points(G)) == []


def test_connected_raise():
    DG = nx.DiGraph()
    with pytest.raises(NetworkXNotImplemented):
        next(nx.biconnected_components(DG))
    with pytest.raises(NetworkXNotImplemented):
        next(nx.biconnected_component_edges(DG))
    with pytest.raises(NetworkXNotImplemented):
        next(nx.articulation_points(DG))
    pytest.raises(NetworkXNotImplemented, nx.is_biconnected, DG)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_graphmatrix.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest

np = pytest.importorskip(&quot;numpy&quot;)
pytest.importorskip(&quot;scipy&quot;)

import networkx as nx
from networkx.generators.degree_seq import havel_hakimi_graph
from networkx.exception import NetworkXError


<A NAME="1"></A>def test_incidence_matrix_simple():
    deg = [3, 2, 2, 1, 0]
    G = havel_hakimi_graph(deg)
    deg = [<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2450-0.html#1',2,'match2450-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(1, 0), (1, 0), (1, 0), (2, 0), (1, 0), (2, 1), (0, 1), (0, 1)]
    MG = nx.random_clustered_graph(deg, seed=</B></FONT>42)

    I = nx.incidence_matrix(G).todense().astype(int)
    # fmt: off
    expected = np.array(
        [[1, 1, 1, 0],
         [0, 1, 0, 1],
         [1, 0, 0, 1],
         [0, 0, 1, 0],
         [0, 0, 0, 0]]
    )
    # fmt: on
    np.testing.assert_equal(I, expected)

<A NAME="2"></A>    I = nx.incidence_matrix(MG).todense().astype(int)
    # fmt: off
    expected = np.array(
        [<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2450-0.html#2',2,'match2450-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[1, 0, 0, 0, 0, 0, 0],
         [1, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 1, 1, 0],
         [0, 0, 0, 0, 0, 1, 1],
         [0, 0, 0, 0, 1, 0, 1]]
    )
    # fmt: on
    np.testing.assert_equal(</B></FONT>I, expected)

    with pytest.raises(NetworkXError):
        nx.incidence_matrix(G, nodelist=[0, 1])


class TestGraphMatrix:
    @classmethod
    def setup_class(cls):
        deg = [3, 2, 2, 1, 0]
<A NAME="0"></A>        cls.G = havel_hakimi_graph(deg)
        # fmt: off
        cls.OI = np.array(
            [<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2450-0.html#0',2,'match2450-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[-1, -1, -1, 0],
             [1, 0, 0, -1],
             [0, 1, 0, 1],
             [0, 0, 1, 0],
             [0, 0, 0, 0]]
        )
        cls.A = np.array(
            [[0, 1, 1, 1, 0],
             [1, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.</B></FONT>WG = havel_hakimi_graph(deg)
        cls.WG.add_edges_from(
            (u, v, {&quot;weight&quot;: 0.5, &quot;other&quot;: 0.3}) for (u, v) in cls.G.edges()
        )
        # fmt: off
        cls.WA = np.array(
            [[0, 0.5, 0.5, 0.5, 0],
             [0.5, 0, 0.5, 0, 0],
             [0.5, 0.5, 0, 0, 0],
             [0.5, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.MG = nx.MultiGraph(cls.G)
        cls.MG2 = cls.MG.copy()
        cls.MG2.add_edge(0, 1)
        # fmt: off
        cls.MG2A = np.array(
            [[0, 2, 1, 1, 0],
             [2, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        cls.MGOI = np.array(
            [[-1, -1, -1, -1, 0],
             [1, 1, 0, 0, -1],
             [0, 0, 1, 0, 1],
             [0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.no_edges_G = nx.Graph([(1, 2), (3, 2, {&quot;weight&quot;: 8})])
        cls.no_edges_A = np.array([[0, 0], [0, 0]])

    def test_incidence_matrix(self):
        &quot;Conversion to incidence matrix&quot;
        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG2),
                edgelist=sorted(self.MG2.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.MGOI)

        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG2.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.MGOI))

    def test_weighted_incidence_matrix(self):
        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        # np.testing.assert_equal(nx.incidence_matrix(self.WG,oriented=True,
        #                                  weight='weight').todense(),0.5*self.OI)
        # np.testing.assert_equal(nx.incidence_matrix(self.WG,weight='weight').todense(),
        #              np.abs(0.5*self.OI))
        # np.testing.assert_equal(nx.incidence_matrix(self.WG,oriented=True,weight='other').todense(),
        #              0.3*self.OI)

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.OI)

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=False,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.OI))

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight=&quot;other&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.OI)

        # WMG=nx.MultiGraph(self.WG)
        # WMG.add_edge(0,1,weight=0.5,other=0.3)
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='weight').todense(),
        #              np.abs(0.5*self.MGOI))
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='weight',oriented=True).todense(),
        #              0.5*self.MGOI)
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='other',oriented=True).todense(),
        #              0.3*self.MGOI)

        WMG = nx.MultiGraph(self.WG)
        WMG.add_edge(0, 1, weight=0.5, other=0.3)

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.MGOI)

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=False,
            weight=&quot;weight&quot;,
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.MGOI))

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight=&quot;other&quot;,
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.MGOI)

    def test_adjacency_matrix(self):
        &quot;Conversion to adjacency matrix&quot;
        np.testing.assert_equal(nx.adjacency_matrix(self.G).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG2).todense(), self.MG2A)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.G, nodelist=[0, 1]).todense(), self.A[:2, :2]
        )
        np.testing.assert_equal(nx.adjacency_matrix(self.WG).todense(), self.WA)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight=None).todense(), self.A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.MG2, weight=None).todense(), self.MG2A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight=&quot;other&quot;).todense(), 0.6 * self.WA
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.no_edges_G, nodelist=[1, 3]).todense(),
            self.no_edges_A,
        )
</PRE>
</div>
  </div>
</body>
</html>
