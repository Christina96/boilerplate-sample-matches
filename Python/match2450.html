<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for test_biconnected.py &amp; test_graphmatrix.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_biconnected.py &amp; test_graphmatrix.py
      </h3>
<h1 align="center">
        8.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_biconnected.py (11.111111%)<th>test_graphmatrix.py (7.191781%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(202-219)<td><a href="#" name="0">(55-69)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(98-109)<td><a href="#" name="1">(14-15)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(26-38)<td><a href="#" name="2">(32-42)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_biconnected.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import pytest
import networkx as nx
from networkx import NetworkXNotImplemented


def assert_components_edges_equal(x, y):
    sx = {frozenset(frozenset(e) for e in c) for c in x}
    sy = {frozenset(frozenset(e) for e in c) for c in y}
    assert sx == sy


def assert_components_equal(x, y):
    sx = {frozenset(c) for c in x}
    sy = {frozenset(c) for c in y}
    assert sx == sy


def test_barbell():
    G = nx.barbell_graph(8, 4)
    nx.add_path(G, [7, 20, 21, 22])
    nx.add_cycle(G, [22, 23, 24, 25])
    pts = set(nx.articulation_points(G))
<a name="2"></a>    assert pts == {7, 8, 9, 10, 11, 12, 20, 21, 22}

    answer = [
        {<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>12, 13, 14, 15, 16, 17, 18, 19},
        {0, 1, 2, 3, 4, 5, 6, 7},
        {22, 23, 24, 25},
        {11, 12},
        {10, 11},
        {9, 10},
        {8, 9},
        {7, 8},
        {21, 22},
        {20, 21},
        {7, 20},
    ]
    assert_components_equal(</b></font>list(nx.biconnected_components(G)), answer)

    G.add_edge(2, 17)
    pts = set(nx.articulation_points(G))
    assert pts == {7, 20, 21, 22}


def test_articulation_points_repetitions():
    G = nx.Graph()
    G.add_edges_from([(0, 1), (1, 2), (1, 3)])
    assert list(nx.articulation_points(G)) == [1]


def test_articulation_points_cycle():
    G = nx.cycle_graph(3)
    nx.add_cycle(G, [1, 3, 4])
    pts = set(nx.articulation_points(G))
    assert pts == {1}


def test_is_biconnected():
    G = nx.cycle_graph(3)
    assert nx.is_biconnected(G)
    nx.add_cycle(G, [1, 3, 4])
    assert not nx.is_biconnected(G)


def test_empty_is_biconnected():
    G = nx.empty_graph(5)
    assert not nx.is_biconnected(G)
    G.add_edge(0, 1)
    assert not nx.is_biconnected(G)


def test_biconnected_components_cycle():
    G = nx.cycle_graph(3)
    nx.add_cycle(G, [1, 3, 4])
    answer = [{0, 1, 2}, {1, 3, 4}]
    assert_components_equal(list(nx.biconnected_components(G)), answer)


def test_biconnected_components1():
    # graph example from
    # https://web.archive.org/web/20121229123447/http://www.ibluemojo.com/school/articul_algorithm.html
    edges = [
        (0, 1),
        (0, 5),
        (0, 6),
        (0, 14),
        (1, 5),
        (1, 6),
        (1, 14),
        (2, 4),
        (2, 10),
        (3, 4),
        (3, 15),
        (4, 6),
<a name="1"></a>        (4, 7),
        (4, 10),
        (5, 14),
        (<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>6, 14),
        (7, 9),
        (8, 9),
        (8, 12),
        (8, 13),
        (10, 15),
        (11, 12),
        (11, 13),
        (12, 13),
    ]
    G = nx.Graph(edges)
    pts =</b></font> set(nx.articulation_points(G))
    assert pts == {4, 6, 7, 8, 9}
    comps = list(nx.biconnected_component_edges(G))
    answer = [
        [(3, 4), (15, 3), (10, 15), (10, 4), (2, 10), (4, 2)],
        [(13, 12), (13, 8), (11, 13), (12, 11), (8, 12)],
        [(9, 8)],
        [(7, 9)],
        [(4, 7)],
        [(6, 4)],
        [(14, 0), (5, 1), (5, 0), (14, 5), (14, 1), (6, 14), (6, 0), (1, 6), (0, 1)],
    ]
    assert_components_edges_equal(comps, answer)


def test_biconnected_components2():
    G = nx.Graph()
    nx.add_cycle(G, "ABC")
    nx.add_cycle(G, "CDE")
    nx.add_cycle(G, "FIJHG")
    nx.add_cycle(G, "GIJ")
    G.add_edge("E", "G")
    comps = list(nx.biconnected_component_edges(G))
    answer = [
        [
            tuple("GF"),
            tuple("FI"),
            tuple("IG"),
            tuple("IJ"),
            tuple("JG"),
            tuple("JH"),
            tuple("HG"),
        ],
        [tuple("EG")],
        [tuple("CD"), tuple("DE"), tuple("CE")],
        [tuple("AB"), tuple("BC"), tuple("AC")],
    ]
    assert_components_edges_equal(comps, answer)


def test_biconnected_davis():
    D = nx.davis_southern_women_graph()
    bcc = list(nx.biconnected_components(D))[0]
    assert set(D) == bcc  # All nodes in a giant bicomponent
    # So no articulation points
    assert len(list(nx.articulation_points(D))) == 0


def test_biconnected_karate():
    K = nx.karate_club_graph()
    answer = [
        {
            0,
            1,
            2,
            3,
            7,
            8,
            9,
            12,
            13,
            14,
            15,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
        },
        {0, 4, 5, 6, 10, 16},
        {0, 11},
    ]
    bcc = list(nx.biconnected_components(K))
    assert_components_equal(bcc, answer)
    assert set(nx.articulation_points(K)) == {0}


def test_biconnected_eppstein():
<a name="0"></a>    # tests from http://www.ics.uci.edu/~eppstein/PADS/Biconnectivity.py
    G1 = nx.Graph(
        {
            0: [<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>1, 2, 5],
            1: [0, 5],
            2: [0, 3, 4],
            3: [2, 4, 5, 6],
            4: [2, 3, 5, 6],
            5: [0, 1, 3, 4],
            6: [3, 4],
        }
    )
    G2 = nx.Graph(
        {
            0: [2, 5],
            1: [3, 8],
            2: [0, 3, 5],
            3: [1, 2, 6, 8],
            4: [7],
            5: [0, 2],
            6: [3</b></font>, 8],
            7: [4],
            8: [1, 3, 6],
        }
    )
    assert nx.is_biconnected(G1)
    assert not nx.is_biconnected(G2)
    answer_G2 = [{1, 3, 6, 8}, {0, 2, 5}, {2, 3}, {4, 7}]
    bcc = list(nx.biconnected_components(G2))
    assert_components_equal(bcc, answer_G2)


def test_null_graph():
    G = nx.Graph()
    assert not nx.is_biconnected(G)
    assert list(nx.biconnected_components(G)) == []
    assert list(nx.biconnected_component_edges(G)) == []
    assert list(nx.articulation_points(G)) == []


def test_connected_raise():
    DG = nx.DiGraph()
    with pytest.raises(NetworkXNotImplemented):
        next(nx.biconnected_components(DG))
    with pytest.raises(NetworkXNotImplemented):
        next(nx.biconnected_component_edges(DG))
    with pytest.raises(NetworkXNotImplemented):
        next(nx.articulation_points(DG))
    pytest.raises(NetworkXNotImplemented, nx.is_biconnected, DG)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_graphmatrix.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import pytest

np = pytest.importorskip("numpy")
pytest.importorskip("scipy")

import networkx as nx
from networkx.generators.degree_seq import havel_hakimi_graph
from networkx.exception import NetworkXError


<a name="1"></a>def test_incidence_matrix_simple():
    deg = [3, 2, 2, 1, 0]
    G = havel_hakimi_graph(deg)
    deg = [<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(1, 0), (1, 0), (1, 0), (2, 0), (1, 0), (2, 1), (0, 1), (0, 1)]
    MG = nx.random_clustered_graph(deg, seed=</b></font>42)

    I = nx.incidence_matrix(G).todense().astype(int)
    # fmt: off
    expected = np.array(
        [[1, 1, 1, 0],
         [0, 1, 0, 1],
         [1, 0, 0, 1],
         [0, 0, 1, 0],
         [0, 0, 0, 0]]
    )
    # fmt: on
    np.testing.assert_equal(I, expected)

<a name="2"></a>    I = nx.incidence_matrix(MG).todense().astype(int)
    # fmt: off
    expected = np.array(
        [<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[1, 0, 0, 0, 0, 0, 0],
         [1, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 0, 0, 0],
         [0, 1, 0, 0, 0, 0, 0],
         [0, 0, 0, 0, 1, 1, 0],
         [0, 0, 0, 0, 0, 1, 1],
         [0, 0, 0, 0, 1, 0, 1]]
    )
    # fmt: on
    np.testing.assert_equal(</b></font>I, expected)

    with pytest.raises(NetworkXError):
        nx.incidence_matrix(G, nodelist=[0, 1])


class TestGraphMatrix:
    @classmethod
    def setup_class(cls):
        deg = [3, 2, 2, 1, 0]
<a name="0"></a>        cls.G = havel_hakimi_graph(deg)
        # fmt: off
        cls.OI = np.array(
            [<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[-1, -1, -1, 0],
             [1, 0, 0, -1],
             [0, 1, 0, 1],
             [0, 0, 1, 0],
             [0, 0, 0, 0]]
        )
        cls.A = np.array(
            [[0, 1, 1, 1, 0],
             [1, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.</b></font>WG = havel_hakimi_graph(deg)
        cls.WG.add_edges_from(
            (u, v, {"weight": 0.5, "other": 0.3}) for (u, v) in cls.G.edges()
        )
        # fmt: off
        cls.WA = np.array(
            [[0, 0.5, 0.5, 0.5, 0],
             [0.5, 0, 0.5, 0, 0],
             [0.5, 0.5, 0, 0, 0],
             [0.5, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.MG = nx.MultiGraph(cls.G)
        cls.MG2 = cls.MG.copy()
        cls.MG2.add_edge(0, 1)
        # fmt: off
        cls.MG2A = np.array(
            [[0, 2, 1, 1, 0],
             [2, 0, 1, 0, 0],
             [1, 1, 0, 0, 0],
             [1, 0, 0, 0, 0],
             [0, 0, 0, 0, 0]]
        )
        cls.MGOI = np.array(
            [[-1, -1, -1, -1, 0],
             [1, 1, 0, 0, -1],
             [0, 0, 1, 0, 1],
             [0, 0, 0, 1, 0],
             [0, 0, 0, 0, 0]]
        )
        # fmt: on
        cls.no_edges_G = nx.Graph([(1, 2), (3, 2, {"weight": 8})])
        cls.no_edges_A = np.array([[0, 0], [0, 0]])

    def test_incidence_matrix(self):
        "Conversion to incidence matrix"
        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.G,
                nodelist=sorted(self.G),
                edgelist=sorted(self.G.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.MG,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG2),
                edgelist=sorted(self.MG2.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.MGOI)

        I = (
            nx.incidence_matrix(
                self.MG2,
                nodelist=sorted(self.MG),
                edgelist=sorted(self.MG2.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.MGOI))

    def test_weighted_incidence_matrix(self):
        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=True,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, self.OI)

        I = (
            nx.incidence_matrix(
                self.WG,
                nodelist=sorted(self.WG),
                edgelist=sorted(self.WG.edges()),
                oriented=False,
            )
            .todense()
            .astype(int)
        )
        np.testing.assert_equal(I, np.abs(self.OI))

        # np.testing.assert_equal(nx.incidence_matrix(self.WG,oriented=True,
        #                                  weight='weight').todense(),0.5*self.OI)
        # np.testing.assert_equal(nx.incidence_matrix(self.WG,weight='weight').todense(),
        #              np.abs(0.5*self.OI))
        # np.testing.assert_equal(nx.incidence_matrix(self.WG,oriented=True,weight='other').todense(),
        #              0.3*self.OI)

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.OI)

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=False,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.OI))

        I = nx.incidence_matrix(
            self.WG,
            nodelist=sorted(self.WG),
            edgelist=sorted(self.WG.edges()),
            oriented=True,
            weight="other",
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.OI)

        # WMG=nx.MultiGraph(self.WG)
        # WMG.add_edge(0,1,weight=0.5,other=0.3)
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='weight').todense(),
        #              np.abs(0.5*self.MGOI))
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='weight',oriented=True).todense(),
        #              0.5*self.MGOI)
        # np.testing.assert_equal(nx.incidence_matrix(WMG,weight='other',oriented=True).todense(),
        #              0.3*self.MGOI)

        WMG = nx.MultiGraph(self.WG)
        WMG.add_edge(0, 1, weight=0.5, other=0.3)

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, 0.5 * self.MGOI)

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=False,
            weight="weight",
        ).todense()
        np.testing.assert_equal(I, np.abs(0.5 * self.MGOI))

        I = nx.incidence_matrix(
            WMG,
            nodelist=sorted(WMG),
            edgelist=sorted(WMG.edges(keys=True)),
            oriented=True,
            weight="other",
        ).todense()
        np.testing.assert_equal(I, 0.3 * self.MGOI)

    def test_adjacency_matrix(self):
        "Conversion to adjacency matrix"
        np.testing.assert_equal(nx.adjacency_matrix(self.G).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG).todense(), self.A)
        np.testing.assert_equal(nx.adjacency_matrix(self.MG2).todense(), self.MG2A)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.G, nodelist=[0, 1]).todense(), self.A[:2, :2]
        )
        np.testing.assert_equal(nx.adjacency_matrix(self.WG).todense(), self.WA)
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight=None).todense(), self.A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.MG2, weight=None).todense(), self.MG2A
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.WG, weight="other").todense(), 0.6 * self.WA
        )
        np.testing.assert_equal(
            nx.adjacency_matrix(self.no_edges_G, nodelist=[1, 3]).todense(),
            self.no_edges_A,
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
