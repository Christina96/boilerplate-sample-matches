<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_betweenness_centrality.py &amp; test_weighted.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_betweenness_centrality.py &amp; test_weighted.py
      </h3>
<h1 align="center">
        9.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_betweenness_centrality.py (11.3672495%)<th>test_weighted.py (8.069978%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(525-542)<td><a href="#" name="0">(286-304)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(705-719)<td><a href="#" name="1">(48-60)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(5-10)<td><a href="#" name="2">(526-531)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(235-240)<td><a href="#" name="3">(867-881)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(642-653)<td><a href="#" name="4">(83-93)</a><td align="center"><font color="#bb0000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(672-683)<td><a href="#" name="5">(65-76)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(491-502)<td><a href="#" name="6">(893-898)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(472-477)<td><a href="#" name="7">(850-856)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(749-759)<td><a href="#" name="8">(77-81)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(11-14)<td><a href="#" name="9">(844-847)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_betweenness_centrality.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def weighted_G():
3     G = nx.Graph()
4     G.add_edge(0, 1, weight=3)
5     G.add_edge(0, 3, weight=6)
6     G.add_edge(0, 4, weight=</b></font>4)
7     G<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_edge(1, 3, weight=5)
8     G.add_edge(1, 5, weight=5)
9     G.add_edge(2, 4, weight=1)
10     G.add_edge(3, 4, weight=</b></font>2)
11     G.add_edge(3, 5, weight=1)
12     G.add_edge(4, 5, weight=4)
13     return G
14 class TestBetweennessCentrality:
15     def test_K5(self):
16         G = nx.complete_graph(5)
17         b = nx.betweenness_centrality(G, weight=None, normalized=False)
18         b_answer = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.0}
19         for n in sorted(G):
20             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
21     def test_K5_endpoints(self):
22         G = nx.complete_graph(5)
23         b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
24         b_answer = {0: 4.0, 1: 4.0, 2: 4.0, 3: 4.0, 4: 4.0}
25         for n in sorted(G):
26             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
27         b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
28         b_answer = {0: 0.4, 1: 0.4, 2: 0.4, 3: 0.4, 4: 0.4}
29         for n in sorted(G):
30             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
31     def test_P3_normalized(self):
32         G = nx.path_graph(3)
33         b = nx.betweenness_centrality(G, weight=None, normalized=True)
34         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
35         for n in sorted(G):
36             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
37     def test_P3(self):
38         G = nx.path_graph(3)
39         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
40         b = nx.betweenness_centrality(G, weight=None, normalized=False)
41         for n in sorted(G):
42             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
43     def test_sample_from_P3(self):
44         G = nx.path_graph(3)
45         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
46         b = nx.betweenness_centrality(G, k=3, weight=None, normalized=False, seed=1)
47         for n in sorted(G):
48             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
49         b = nx.betweenness_centrality(G, k=2, weight=None, normalized=False, seed=1)
50         b_approx1 = {0: 0.0, 1: 1.5, 2: 0.0}
51         b_approx2 = {0: 0.0, 1: 0.75, 2: 0.0}
52         for n in sorted(G):
53             assert b[n] in (b_approx1[n], b_approx2[n])
54     def test_P3_endpoints(self):
55         G = nx.path_graph(3)
56         b_answer = {0: 2.0, 1: 3.0, 2: 2.0}
57         b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
58         for n in sorted(G):
59             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
60         b_answer = {0: 2 / 3, 1: 1.0, 2: 2 / 3}
61         b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
62         for n in sorted(G):
63             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
64     def test_krackhardt_kite_graph(self):
65         G = nx.krackhardt_kite_graph()
66         b_answer = {
67             0: 1.667,
68             1: 1.667,
69             2: 0.000,
70             3: 7.333,
71             4: 0.000,
72             5: 16.667,
73             6: 16.667,
74             7: 28.000,
75             8: 16.000,
76             9: 0.000,
77         }
78         for b in b_answer:
79             b_answer[b] /= 2
80         b = nx.betweenness_centrality(G, weight=None, normalized=False)
81         for n in sorted(G):
82             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
83     def test_krackhardt_kite_graph_normalized(self):
84         G = nx.krackhardt_kite_graph()
85         b_answer = {
86             0: 0.023,
87             1: 0.023,
88             2: 0.000,
89             3: 0.102,
90             4: 0.000,
91             5: 0.231,
92             6: 0.231,
93             7: 0.389,
94             8: 0.222,
95             9: 0.000,
96         }
97         b = nx.betweenness_centrality(G, weight=None, normalized=True)
98         for n in sorted(G):
99             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
100     def test_florentine_families_graph(self):
101         G = nx.florentine_families_graph()
102         b_answer = {
103             "Acciaiuoli": 0.000,
104             "Albizzi": 0.212,
105             "Barbadori": 0.093,
106             "Bischeri": 0.104,
107             "Castellani": 0.055,
108             "Ginori": 0.000,
109             "Guadagni": 0.255,
110             "Lamberteschi": 0.000,
111             "Medici": 0.522,
112             "Pazzi": 0.000,
113             "Peruzzi": 0.022,
114             "Ridolfi": 0.114,
115             "Salviati": 0.143,
116             "Strozzi": 0.103,
117             "Tornabuoni": 0.092,
118         }
119         b = nx.betweenness_centrality(G, weight=None, normalized=True)
120         for n in sorted(G):
121             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
122     def test_les_miserables_graph(self):
123         G = nx.les_miserables_graph()
124         b_answer = {
125             "Napoleon": 0.000,
126             "Myriel": 0.177,
127             "MlleBaptistine": 0.000,
128             "MmeMagloire": 0.000,
129             "CountessDeLo": 0.000,
130             "Geborand": 0.000,
131             "Champtercier": 0.000,
132             "Cravatte": 0.000,
133             "Count": 0.000,
134             "OldMan": 0.000,
135             "Valjean": 0.570,
136             "Labarre": 0.000,
137             "Marguerite": 0.000,
138             "MmeDeR": 0.000,
139             "Isabeau": 0.000,
140             "Gervais": 0.000,
141             "Listolier": 0.000,
142             "Tholomyes": 0.041,
143             "Fameuil": 0.000,
144             "Blacheville": 0.000,
145             "Favourite": 0.000,
146             "Dahlia": 0.000,
147             "Zephine": 0.000,
148             "Fantine": 0.130,
149             "MmeThenardier": 0.029,
150             "Thenardier": 0.075,
151             "Cosette": 0.024,
152             "Javert": 0.054,
153             "Fauchelevent": 0.026,
154             "Bamatabois": 0.008,
155             "Perpetue": 0.000,
156             "Simplice": 0.009,
157             "Scaufflaire": 0.000,
158             "Woman1": 0.000,
159             "Judge": 0.000,
160             "Champmathieu": 0.000,
161             "Brevet": 0.000,
162             "Chenildieu": 0.000,
163             "Cochepaille": 0.000,
164             "Pontmercy": 0.007,
165             "Boulatruelle": 0.000,
166             "Eponine": 0.011,
167             "Anzelma": 0.000,
168             "Woman2": 0.000,
169             "MotherInnocent": 0.000,
170             "Gribier": 0.000,
171             "MmeBurgon": 0.026,
172             "Jondrette": 0.000,
173             "Gavroche": 0.165,
174             "Gillenormand": 0.020,
175             "Magnon": 0.000,
176             "MlleGillenormand": 0.048,
177             "MmePontmercy": 0.000,
178             "MlleVaubois": 0.000,
179             "LtGillenormand": 0.000,
180             "Marius": 0.132,
181             "BaronessT": 0.000,
182             "Mabeuf": 0.028,
183             "Enjolras": 0.043,
184             "Combeferre": 0.001,
185             "Prouvaire": 0.000,
186             "Feuilly": 0.001,
187             "Courfeyrac": 0.005,
188             "Bahorel": 0.002,
189             "Bossuet": 0.031,
190             "Joly": 0.002,
191             "Grantaire": 0.000,
192             "MotherPlutarch": 0.000,
193             "Gueulemer": 0.005,
194             "Babet": 0.005,
195             "Claquesous": 0.005,
196             "Montparnasse": 0.004,
197             "Toussaint": 0.000,
198             "Child1": 0.000,
199             "Child2": 0.000,
200             "Brujon": 0.000,
201             "MmeHucheloup": 0.000,
202         }
203         b = nx.betweenness_centrality(G, weight=None, normalized=True)
204         for n in sorted(G):
205             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-3)
206     def test_ladder_graph(self):
207         G = nx.Graph()  # ladder_graph(3)
208         G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3), (2, 4), (4, 5), (3</b></font>, 5)])
209         b_answer = {0: 1.667, 1: 1.667, 2: 6.667, 3: 6.667, 4: 1.667, 5: 1.667}
210         for b in b_answer:
211             b_answer[b] /= 2
212         b = nx.betweenness_centrality(G, weight=None, normalized=False)
213         for n in sorted(G):
214             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
215     def test_disconnected_path(self):
216         G = nx.Graph()
217         nx.add_path(G, [0, 1, 2])
218         nx.add_path(G, [3, 4, 5, 6])
219         b_answer = {0: 0, 1: 1, 2: 0, 3: 0, 4: 2, 5: 2, 6: 0}
220         b = nx.betweenness_centrality(G, weight=None, normalized=False)
221         for n in sorted(G):
222             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
223     def test_disconnected_path_endpoints(self):
224         G = nx.Graph()
225         nx.add_path(G, [0, 1, 2])
226         nx.add_path(G, [3, 4, 5, 6])
227         b_answer = {0: 2, 1: 3, 2: 2, 3: 3, 4: 5, 5: 5, 6: 3}
228         b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
229         for n in sorted(G):
230             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
231         b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
232         for n in sorted(G):
233             assert b[n] == pytest.approx(b_answer[n] / 21, abs=1e-7)
234     def test_directed_path(self):
235         G = nx.DiGraph()
236         nx.add_path(G, [0, 1, 2])
237         b = nx.betweenness_centrality(G, weight=None, normalized=False)
238         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
239         for n in sorted(G):
240             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
241     def test_directed_path_normalized(self):
242         G = nx.DiGraph()
243         nx.add_path(G, [0, 1, 2])
244         b = nx.betweenness_centrality(G, weight=None, normalized=True)
245         b_answer = {0: 0.0, 1: 0.5, 2: 0.0}
246         for n in sorted(G):
247             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
248 class TestWeightedBetweennessCentrality:
249     def test_K5(self):
250         G = nx.complete_graph(5)
251         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
252         b_answer = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.0}
253         for n in sorted(G):
254             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
255     def test_P3_normalized(self):
256         G = nx.path_graph(3)
257         b = nx.betweenness_centrality(G, weight="weight", normalized=True)
258         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
259         for n in sorted(G):
260             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
261     def test_P3(self):
262         G = nx.path_graph(3)
263         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
264         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
265         for n in sorted(G):
266             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
267     def test_krackhardt_kite_graph(self):
268         G = nx.krackhardt_kite_graph()
269         b_answer = {
270             0: 1.667,
271             1: 1.667,
272             2: 0.000,
273             3: 7.333,
274             4: 0.000,
275             5: 16.667,
276             6: 16.667,
277             7: 28.000,
278             8: 16.000,
279             9: 0.000,
280         }
281         for b in b_answer:
282             b_answer[b] /= 2
283         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
284         for n in sorted(G):
285             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
286     def test_krackhardt_kite_graph_normalized(self):
287         G = nx.krackhardt_kite_graph()
288         b_answer = {
289             0: 0.023,
290             1: 0.023,
291             2: 0.000,
292             3: 0.102,
293             4: 0.000,
294             5: 0.231,
295             6: 0.231,
296             7: 0.389,
297             8: 0.222,
298             9: 0.000,
299         }
300         b = nx.betweenness_centrality(G, weight="weight", normalized=True)
301         for n in sorted(G):
302             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
303     def test_florentine_families_graph(self):
304         """Weighted betweenness centrality:
305             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-3)
306     def test_ladder_graph(self):
307         G = nx.Graph()  # ladder_graph(3)
308         G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3), (2</b></font>, 4), (4, 5), (3, 5)])
309         b_answer = {0: 1.667, 1: 1.667, 2: 6.667, 3: 6.667, 4: 1.667, 5: 1.667}
310         for b in b_answer:
311             b_answer[b] /= 2
312         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
313         for n in sorted(G):
314             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
315     def test_G(self):
316         G = weighted_G()
317         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
318         for n in sorted(G):
319             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-7)
320     def test_G2(self):
321         G = nx.DiGraph()
322         G.add_weighted_edges_from(
323             [
324                 ("s", "u", 10),
325                 ("s", "x", 5),
326                 ("u", "v", 1),
327                 ("u", "x", 2),
328                 ("v"</b></font>, "y", 1),
329                 ("x", "u", 3),
330                 ("x", "v", 5),
331                 ("x", "y", 2),
332                 ("y", "s", 7),
333                 ("y", "v", 6),
334             ]
335         )
336         b_answer = {"y": 5.0, "x": 5.0, "s": 4.0, "u": 2.0, "v": 2.0}
337         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
338         for n in sorted(G):
339             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
340     def test_G3(self):
341         G = nx.MultiGraph(weighted_G())
342         es = list(G.edges(data=True))[::2]  # duplicate every other edge
343         G.add_edges_from(es)
344         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
345         for n in sorted(G):
346             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-7)
347     def test_G4(self):
348         G = nx.MultiDiGraph()
349         G.add_weighted_edges_from(
350             [
351                 ("s", "u", 10),
352                 ("s", "x", 5),
353                 ("s", "x", 6),
354                 ("u", "v", 1),
355                 ("u", "x", 2),
356                 ("v", "y", 1),
357                 ("v", "y", 1),
358                 ("x", "u", 3),
359                 ("x", "v", 5),
360                 ("x", "y", 2),
361                 ("x"</b></font>, "y", 3),
362                 ("y", "s", 7),
363                 ("y", "v", 6),
364                 ("y", "v", 6),
365             ]
366         )
367         b_answer = {"y": 5.0, "x": 5.0, "s": 4.0, "u": 2.0, "v": 2.0}
368         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
369         for n in sorted(G):
370             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
371 class TestEdgeBetweennessCentrality:
372     def test_K5(self):
373         G = nx.complete_graph(5)
374         b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
375         b_answer = dict.fromkeys(G.edges(), 1)
376         for n in sorted(G.edges()):
377             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
378     def test_normalized_K5(self):
379         G = nx.complete_graph(5)
380         b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
381         b_answer = dict.fromkeys(G.edges(), 1 / 10)
382         for n in sorted(G.edges()):
383             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
384     def test_C4(self):
385         G = nx.cycle_graph(4)
386         b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
387         b_answer = {(0, 1): 2, (0, 3): 2, (1, 2): 2, (2, 3): 2}
388         for n in sorted(G.edges()):
389             assert b[n] == pytest.approx(b_answer[n] / 6, abs=1e-7)
390     def test_P4(self):
391         G = nx.path_graph(4)
392         b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
393         b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
394         for n in sorted(G.edges()):
395             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
396     def test_normalized_P4(self):
397         G = nx.path_graph(4)
398         b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
399         b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
400         for n in sorted(G.edges()):
401             assert b[n] == pytest.approx(b_answer[n] / 6, abs=1e-7)
402     def test_balanced_tree(self):
403         G = nx.balanced_tree(r=2, h=2)
404         b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
405         b_answer = {(0, 1): 12, (0, 2): 12, (1, 3): 6, (1, 4): 6, (2, 5): 6, (2, 6): 6}
406         for n in sorted(G.edges()):
407             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
408 class TestWeightedEdgeBetweennessCentrality:
409     def test_K5(self):
410         G = nx.complete_graph(5)
411         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
412         b_answer = dict.fromkeys(G.edges(), 1)
413         for n in sorted(G.edges()):
414             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
415     def test_C4(self):
416         G = nx.cycle_graph(4)
417         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
418         b_answer = {(0, 1): 2, (0, 3): 2, (1, 2): 2, (2, 3): 2}
419         for n in sorted(G.edges()):
420             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
421     def test_P4(self):
422         G = nx.path_graph(4)
423         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
424         b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
425         for n in sorted(G.edges()):
426             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
427     def test_balanced_tree(self):
428         G = nx.balanced_tree(r=2, h=2)
429         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
430         b_answer = {(0, 1): 12, (0, 2): 12, (1, 3): 6, (1, 4): 6, (2, 5): 6, (2, 6): 6}
431         for n in sorted(G.edges()):
432             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
433         eList = [
434             <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(0, 1, 5),
435             (0, 2, 4),
436             (0, 3, 3),
437             (0, 4, 2),
438             (1, 2, 4),
439             (1, 3, 1),
440             (1, 4, 3),
441             (2, 4, 5),
442             (3, 4, 4),
443         ]
444         G = nx.Graph()
445         G.</b></font>add_weighted_edges_from(eList)
446         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
447         b_answer = {
448             (0, 1): 0.0,
449             (0, 2): 1.0,
450             (0, 3): 2.0,
451             (0, 4): 1.0,
452             (1, 2): 2.0,
453             (1, 3): 3.5,
454             (1, 4): 1.5,
455             (2, 4): 1.0,
456             (3, 4): 0.5,
457         }
458         for n in sorted(G.edges()):
459             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
460         eList = [
461             (<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 1, 5),
462             (0, 2, 4),
463             (0, 3, 3),
464             (0, 4, 2),
465             (1, 2, 4),
466             (1, 3, 1),
467             (1, 4, 3),
468             (2, 4, 5),
469             (3, 4, 4),
470         ]
471         G = nx.Graph()
472         G.</b></font>add_weighted_edges_from(eList)
473         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=True)
474         b_answer = {
475             (0, 1): 0.0,
476             (0, 2): 1.0,
477             (0, 3): 2.0,
478             (0, 4): 1.0,
479             (1, 2): 2.0,
480             (1, 3): 3.5,
481             (1, 4): 1.5,
482             (2, 4): 1.0,
483             (3, 4): 0.5,
484         }
485         norm = len(G) * (len(G) - 1) / 2
486         for n in sorted(G.edges()):
487             assert b[n] == pytest.approx(b_answer[n] / norm, abs=1e-7)
488     def test_weighted_multigraph(self):
489             (0, 1, 5),
490             (0, 1, 4),
491             (<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 2, 4),
492             (0, 3, 3),
493             (0, 3, 3),
494             (0, 4, 2),
495             (1, 2, 4),
496             (1, 3, 1),
497             (1, 3, 2),
498             (1, 4, 3),
499             (1, 4, 4),
500             (2, 4, 5),
501             (3, 4, 4),
502             (3, 4, 4),
503         ]
504         G = nx.MultiGraph()
505         G.</b></font>add_weighted_edges_from(eList)
506         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
507         b_answer = {
508             (0, 1, 0): 0.0,
509             (0, 1, 1): 0.5,
510             (0, 2, 0): 1.0,
511             (0, 3, 0): 0.75,
512             (0, 3, 1): 0.75,
513             (0, 4, 0): 1.0,
514             (1, 2, 0): 2.0,
515             (1, 3, 0): 3.0,
516             (1, 3, 1): 0.0,
517             (1, 4, 0): 1.5,
518             (1, 4, 1): 0.0,
519             (2, 4, 0): 1.0,
520             (3, 4, 0): 0.25,
521             (3, 4, 1): 0.25,
522         }
523         for n in sorted(G.edges(keys=True)):
524             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
525     def test_normalized_weighted_multigraph(self):
526         eList = [
527             (0, 1, 5),
528             (0, 1, 4),
529             (0, 2, 4),
530             (0, 3, 3),
531             (0, 4, 2),
532             (<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>1, 2, 4),
533             (1, 3, 1),
534             (1, 3, 2),
535             (1, 4, 3),
536             (1, 4, 4),
537             (2, 4, 5),
538             (3, 4, 4),
539             (3, 4, 4),
540         ]
541         G = nx.MultiGraph()
542         G.</b></font>add_weighted_edges_from(eList)
543         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=True)
544         b_answer = {
545             (0, 1, 0): 0.0,
546             (0, 1, 1): 0.5,
547             (0, 2, 0): 1.0,
548             (0, 3, 0): 0.75,
549             (0, 3, 1): 0.75,
550             (0, 4, 0): 1.0,
551             (1, 2, 0): 2.0,
552             (1, 3, 0): 3.0,
553             (1, 3, 1): 0.0,
554             (1, 4, 0): 1.5,
555             (1, 4, 1): 0.0,
556             (2, 4, 0): 1.0,
557             (3, 4, 0): 0.25,
558             (3, 4, 1): 0.25,
559         }
560         norm = len(G) * (len(G) - 1) / 2
561         for n in sorted(G.edges(keys=True)):
562             assert b[n] == pytest.approx(b_answer[n] / norm, abs=1e-7)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_weighted.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 from networkx.utils import pairwise
4 def validate_path(G, s, t, soln_len, path, weight="weight"):
5     assert path[0] == s
6     assert path[-1] == t
7     if callable(weight):
8         weight_f = weight
9     else:
10         if G.is_multigraph():
11             def weight_f(u, v, d):
12                 return min(e.get(weight, 1) for e in d.values())
13         else:
14             def weight_f(u, v, d):
15                 return d.get(weight, 1)
16     computed = sum(weight_f(u, v, G[u][v]) for u, v in pairwise(path))
17     assert soln_len == computed
18 def validate_length_path(G, s, t, soln_len, length, path, weight="weight"):
19     assert soln_len == length
20     validate_path(G, s, t, length, path, weight=weight)
21 class WeightedTestBase:
22     """Base class for test classes that test functions for computing
23     shortest paths in weighted graphs.
24     """
25     def setup(self):
26         cnlti = nx.convert_node_labels_to_integers
27         self.grid = cnlti(nx.grid_2d_graph(4, 4), first_label=1, ordering="sorted")
28         self.cycle = nx.cycle_graph(7)
29         self.directed_cycle = nx.cycle_graph(7, create_using=nx.DiGraph())
30         self.XG.add_weighted_edges_from(
31             [
32                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("s", "u", 10),
33                 ("s", "x", 5),
34                 ("u", "v", 1),
35                 ("u", "x", 2),
36                 ("v", "y", 1),
37                 ("x", "u", 3),
38                 ("x", "v", 5),
39                 ("x", "y", 2),
40                 ("y", "s", 7),
41                 ("y", "v", 6),
42             ]
43         )
44         self.MXG = nx.MultiDiGraph(self.</b></font>XG)
45         self.MXG.add_edge("s", "u", weight=15)
46         self.XG2.add_weighted_edges_from(
47             [
48                 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[1, 4, 1],
49                 [4, 5, 1],
50                 [5, 6, 1],
51                 [6, 3, 1],
52                 [1, 3, 50],
53                 [1, 2, 100],
54                 [2, 3, 100],
55             ]
56         )
57         self.XG3 = nx.Graph()
58         self.</b></font>XG3.add_weighted_edges_from(
59             [<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0, 1, 2], [1, 2, 12], [2, 3, 1], [3, 4, 5], [4, 5, 1], [5, 0, 10]]
60         )
61         self.</b></font>XG4.add_weighted_edges_from(
62             [
63                 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0, 1, 2],
64                 [1, 2, 2],
65                 [2, 3, 1],
66                 [3, 4, 1],
67                 [4, 5, 1],
68                 [5, 6, 1],
69                 [6, 7, 1],
70                 [7, 0, 1],
71             ]
72         )
73         self.MXG4 = nx.MultiGraph(self.</b></font>XG4)
74         self.MXG4.add_edge(0, 1, weight=3)
75         self.G = nx.DiGraph()  # no weights
76         self.G.add_edges_from(
77             [
78                 ("s", "u"),
79                 ("s", "x"),
80                 ("u", "v"),
81                 ("u", "x"),
82                 ("v", "y"),
83                 ("x", "u"),
84                 ("x", "v"),
85                 ("x", "y"),
86                 ("y", "s"),
87                 ("y", "v"),
88             ]
89         )
90 class TestWeightedPath(WeightedTestBase):
91     def test_dijkstra(self):
92         (D, P) = nx.single_source_dijkstra(self.XG, "s")
93         validate_path(self.XG, "s", "v", 9, P["v"])
94         assert D["v"] == 9
95         validate_path(
96             self.XG, "s", "v", 9, nx.single_source_dijkstra_path(self.XG, "s")["v"]
97         )
98         assert dict(nx.single_source_dijkstra_path_length(self.XG, "s"))["v"] == 9
99         validate_path(
100             self.XG, "s", "v", 9, nx.single_source_dijkstra(self.XG, "s")[1]["v"]
101         )
102         validate_path(
103             self.MXG, "s", "v", 9, nx.single_source_dijkstra_path(self.MXG, "s")["v"]
104         )
105         GG = self.XG.to_undirected()
106         GG["u"]["x"]["weight"] = 2
107         (D, P) = nx.single_source_dijkstra(GG, "s")
108         validate_path(GG, "s", "v", 8, P["v"])
109         assert D["v"] == 8  # uses lower weight of 2 on u&lt;-&gt;x edge
110         validate_path(GG, "s", "v", 8, nx.dijkstra_path(GG, "s", "v"))
111         assert nx.dijkstra_path_length(GG, "s", "v") == 8
112         validate_path(self.XG2, 1, 3, 4, nx.dijkstra_path(self.XG2, 1, 3))
113         validate_path(self.XG3, 0, 3, 15, nx.dijkstra_path(self.XG3, 0, 3))
114         assert nx.dijkstra_path_length(self.XG3, 0, 3) == 15
115         validate_path(self.XG4, 0, 2, 4, nx.dijkstra_path(self.XG4, 0, 2))
116         assert nx.dijkstra_path_length(self.XG4, 0, 2) == 4
117         validate_path(self.MXG4, 0, 2, 4, nx.dijkstra_path(self.MXG4, 0, 2))
118         validate_path(
119             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s", "v")[1]
120         )
121         validate_path(
122             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s")[1]["v"]
123         )
124         validate_path(self.G, "s", "v", 2, nx.dijkstra_path(self.G, "s", "v"))
125         assert nx.dijkstra_path_length(self.G, "s", "v") == 2
126         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path, self.G, "s", "moon")
127         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path_length, self.G, "s", "moon")
128         validate_path(self.cycle, 0, 3, 3, nx.dijkstra_path(self.cycle, 0, 3))
129         validate_path(self.cycle, 0, 4, 3, nx.dijkstra_path(self.cycle, 0, 4))
130         assert nx.single_source_dijkstra(self.cycle, 0, 0) == (0, [0])
131     def test_bidirectional_dijkstra(self):
132         validate_length_path(
133             self.XG, "s", "v", 9, *nx.bidirectional_dijkstra(self.XG, "s", "v")
134         )
135         validate_length_path(
136             self.G, "s", "v", 2, *nx.bidirectional_dijkstra(self.G, "s", "v")
137         )
138         validate_length_path(
139             self.cycle, 0, 3, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 3)
140         )
141         validate_length_path(
142             self.cycle, 0, 4, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 4)
143         )
144         validate_length_path(
145             self.XG3, 0, 3, 15, *nx.bidirectional_dijkstra(self.XG3, 0, 3)
146         )
147         validate_length_path(
148             self.XG4, 0, 2, 4, *nx.bidirectional_dijkstra(self.XG4, 0, 2)
149         )
150         P = nx.single_source_dijkstra_path(self.XG, "s")["v"]
151         validate_path(
152             self.XG,
153             "s",
154             "v",
155             sum(self.XG[u][v]["weight"] for u, v in zip(P[:-1], P[1:])),
156             nx.dijkstra_path(self.XG, "s", "v"),
157         )
158         G = nx.path_graph(2)
159         pytest.raises(nx.NodeNotFound, nx.bidirectional_dijkstra, G, 3, 0)
160     def test_weight_functions(self):
161         def heuristic(*z):
162             return sum(val ** 2 for val in z)
163         def getpath(pred, v, s):
164             return [v] if v == s else getpath(pred, pred[v], s) + [v]
165         def goldberg_radzik(g, s, t, weight="weight"):
166             pred, dist = nx.goldberg_radzik(g, s, weight=weight)
167             dist = dist[t]
168             return dist, getpath(pred, t, s)
169         def astar(g, s, t, weight="weight"):
170             path = nx.astar_path(g, s, t, heuristic, weight=weight)
171             dist = nx.astar_path_length(g, s, t, heuristic, weight=weight)
172             return dist, path
173         def vlp(G, s, t, l, F, w):
174             res = F(G, s, t, weight=w)
175             validate_length_path(G, s, t, l, *res, weight=w)
176         G = self.cycle
177         s = 6
178         t = 4
179         path = [6] + list(range(t + 1))
180         def weight(u, v, _):
181             return 1 + v ** 2
182         length = sum(weight(u, v, None) for u, v in pairwise(path))
183         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
184         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
185         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
186         vlp(G, s, t, length, goldberg_radzik, weight)
187         vlp(G, s, t, length, astar, weight)
188         def weight(u, v, _):
189             return 2 ** (u * v)
190         length = sum(weight(u, v, None) for u, v in pairwise(path))
191         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
192         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
193         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
194         vlp(G, s, t, length, goldberg_radzik, weight)
195         vlp(G, s, t, length, astar, weight)
196     def test_bidirectional_dijkstra_no_path(self):
197         with pytest.raises(nx.NetworkXNoPath):
198             G = nx.Graph()
199             nx.add_path(G, [1, 2, 3])
200             nx.add_path(G, [4, 5, 6])
201             path = nx.bidirectional_dijkstra(G, 1, 6)
202     @pytest.mark.parametrize(
203         "fn",
204         (
205             nx.dijkstra_path,
206             nx.dijkstra_path_length,
207             nx.single_source_dijkstra_path,
208             nx.single_source_dijkstra_path_length,
209             nx.single_source_dijkstra,
210             nx.dijkstra_predecessor_and_distance,
211         ),
212     )
213     def test_absent_source(self, fn):
214         G = nx.path_graph(2)
215         with pytest.raises(nx.NodeNotFound):
216             fn(G, 3, 0)
217         with pytest.raises(nx.NodeNotFound):
218             fn(G, 3, 3)
219     def test_dijkstra_predecessor1(self):
220         G = nx.path_graph(4)
221         assert nx.dijkstra_predecessor_and_distance(G, 0) == (
222             {0: [], 1: [0], 2: [1], 3: [2]},
223             {0: 0, 1: 1, 2: 2, 3: 3},
224         )
225     def test_dijkstra_predecessor2(self):
226         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
227         pred, dist = nx.dijkstra_predecessor_and_distance(G, (0))
228         assert pred[0] == []
229         assert pred[2] in [[1, 3], [3, 1]]
230         assert pred[3] == [0]
231         assert dist == {0<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>: 0, 1: 1, 2: 2, 3: 1}
232     def test_dijkstra_predecessor3(self):
233         XG = nx.DiGraph()
234         XG.add_weighted_edges_from(
235             [
236                 ("s", "u", 10),
237                 ("s", "x", 5),
238                 ("u", "v", 1),
239                 ("u", "x", 2),
240                 ("v", "y", 1),
241                 ("x", "u", 3),
242                 ("x", "v", 5),
243                 ("x", "y", 2),
244                 ("y", "s", 7),
245                 ("y", "v", 6),
246             ]
247         )
248         (P</b></font>, D) = nx.dijkstra_predecessor_and_distance(XG, "s")
249         assert P["v"] == ["u"]
250         assert D["v"] == 9
251         (P, D) = nx.dijkstra_predecessor_and_distance(XG, "s", cutoff=8)
252         assert "v" not in D
253     def test_single_source_dijkstra_path_length(self):
254         pl = nx.single_source_dijkstra_path_length
255         assert dict(pl(self.MXG4, 0))[2] == 4
256         spl = pl(self.MXG4, 0, cutoff=2)
257         assert 2 not in spl
258     def test_bidirectional_dijkstra_multigraph(self):
259         G = nx.MultiGraph()
260         G.add_edge("a", "b", weight=10)
261         G.add_edge("a", "b", weight=100)
262         dp = nx.bidirectional_dijkstra(G, "a", "b")
263         assert dp == (10, ["a", "b"])
264     def test_dijkstra_pred_distance_multigraph(self):
265         G = nx.MultiGraph()
266         G.add_edge("a", "b", key="short", foo=5, weight=100)
267         G.add_edge("a", "b", key="long", bar=1, weight=110)
268         p, d = nx.dijkstra_predecessor_and_distance(G, "a")
269         assert p == {"a": [], "b": ["a"]}
270         assert d == {"a": 0, "b": 100}
271     def test_negative_edge_cycle(self):
272         G = nx.cycle_graph(5, create_using=nx.DiGraph())
273         assert not nx.negative_edge_cycle(G)
274         G.add_edge(8, 9, weight=-7)
275         G.add_edge(9, 8, weight=3)
276         graph_size = len(G)
277         assert nx.negative_edge_cycle(G)
278         assert graph_size == len(G)
279         pytest.raises(ValueError, nx.single_source_dijkstra_path_length, G, 8)
280         pytest.raises(ValueError, nx.single_source_dijkstra, G, 8)
281         pytest.raises(ValueError, nx.dijkstra_predecessor_and_distance, G, 8)
282         G.add_edge(9, 10)
283         pytest.raises(ValueError, nx.bidirectional_dijkstra, G, 8, 10)
284     def test_negative_edge_cycle_custom_weight_key(self):
285         d = nx.DiGraph()
286         d.add_edge("a", "b", w=-2)
287         d.add_edge("b", "a", w=-1)
288         assert nx.negative_edge_cycle(d, weight="w")
289     def test_weight_function(self):
290         """Tests that a callable weight is interpreted as a weight
291         function instead of an edge attribute.
292         """
293         G = nx.complete_graph(3)
294         G.adj[0][2]["weight"] = 10
295         G.adj[0][1]["weight"] = 1
296         G.adj[1][2]["weight"] = 1
297         def weight(u, v, d):
298             return 1 / d["weight"]
299         distance, path = nx.single_source_dijkstra(G, 0, 2)
300         assert distance == 2
301         assert path == [0, 1, 2]
302         distance, path = nx.single_source_dijkstra(G, 0, 2, weight=weight)
303         assert distance == 1 / 10
304         assert path == [0, 2]
305     def test_all_pairs_dijkstra_path(self):
306         cycle = nx.cycle_graph(7)
307         p = dict(nx.all_pairs_dijkstra_path(cycle))
308         assert p[0][3] == [0, 1, 2, 3]
309         cycle[1][2]["weight"] = 10
310         p = dict(nx.all_pairs_dijkstra_path(cycle))
311         assert p[0][3] == [0, 6, 5, 4, 3]
312     def test_all_pairs_dijkstra_path_length(self):
313         cycle = nx.cycle_graph(7)
314         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
315         assert pl[0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
316         cycle[1][2]["weight"] = 10
317         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
318         assert pl[0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
319     def test_all_pairs_dijkstra(self):
320         cycle = nx.cycle_graph(7)
321         out = dict(nx.all_pairs_dijkstra(cycle))
322         assert out[0][0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
323         assert out[0][1][3] == [0, 1, 2, 3]
324         cycle[1][2]["weight"] = 10
325         out = dict(nx.all_pairs_dijkstra(cycle))
326         assert out[0][0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
327         assert out[0][1][3] == [0, 6, 5, 4, 3]
328 class TestDijkstraPathLength:
329     """Unit tests for the :func:`networkx.dijkstra_path_length`
330     function.
331     """
332     def test_weight_function(self):
333         """Tests for computing the length of the shortest path using
334         Dijkstra's algorithm with a user-defined weight function.
335         """
336         G = nx.complete_graph(3)
337         G.adj[0][2]["weight"] = 10
338         G.adj[0][1]["weight"] = 1
339         G.adj[1][2]["weight"] = 1
340         def weight(u, v, d):
341             return 1 / d["weight"]
342         length = nx.dijkstra_path_length(G, 0, 2, weight=weight)
343         assert length == 1 / 10
344 class TestMultiSourceDijkstra:
345     """Unit tests for the multi-source dialect of Dijkstra's shortest
346     path algorithms.
347     """
348     def test_no_sources(self):
349         with pytest.raises(ValueError):
350             nx.multi_source_dijkstra(nx.Graph(), {})
351     def test_path_no_sources(self):
352         with pytest.raises(ValueError):
353             nx.multi_source_dijkstra_path(nx.Graph(), {})
354     def test_path_length_no_sources(self):
355         with pytest.raises(ValueError):
356             nx.multi_source_dijkstra_path_length(nx.Graph(), {})
357     @pytest.mark.parametrize(
358         "fn",
359         (
360             nx.multi_source_dijkstra_path,
361             nx.multi_source_dijkstra_path_length,
362             nx.multi_source_dijkstra,
363         ),
364     )
365     def test_absent_source(self, fn):
366         G = nx.path_graph(2)
367         with pytest.raises(nx.NodeNotFound):
368             fn(G, [3], 0)
369         with pytest.raises(nx.NodeNotFound):
370             fn(G, [3], 3)
371     def test_two_sources(self):
372         edges = [(0, 1, 1), (1, 2, 1), (2, 3, 10), (3, 4, 1)]
373         G = nx.Graph()
374         G.add_weighted_edges_from(edges)
375         sources = {0, 4}
376         distances, paths = nx.multi_source_dijkstra(G, sources)
377         expected_distances = {0: 0, 1: 1, 2: 2, 3: 1, 4: 0}
378         expected_paths = {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [4, 3], 4: [4]}
379         assert distances == expected_distances
380         assert paths == expected_paths
381     def test_simple_paths(self):
382         G = nx.path_graph(4)
383         lengths = nx.multi_source_dijkstra_path_length(G, [0])
384         assert lengths == {n: n for n in G}
385         paths = nx.multi_source_dijkstra_path(G, [0])
386         assert paths == {n: list(range(n + 1)) for n in G}
387 class TestBellmanFordAndGoldbergRadzik(WeightedTestBase):
388     def test_single_node_graph(self):
389         G = nx.DiGraph()
390         G.add_node(0)
391         assert nx.single_source_bellman_ford_path(G, 0) == {0: [0]}
392         assert nx.single_source_bellman_ford_path_length(G, 0) == {0: 0}
393         assert nx.single_source_bellman_ford(G, 0) == ({0: 0}, {0: [0]})
394         assert nx.bellman_ford_predecessor_and_distance(G, 0) == ({0: []}, {0: 0})
395         assert nx.goldberg_radzik(G, 0) == ({0: None}, {0: 0})
396     def test_absent_source_bellman_ford(self):
397         G = nx.path_graph(2)
398         for fn in (
399             nx.bellman_ford_predecessor_and_distance,
400             nx.bellman_ford_path,
401             nx.bellman_ford_path_length,
402             nx.single_source_bellman_ford_path,
403             nx.single_source_bellman_ford_path_length,
404             nx.single_source_bellman_ford,
405         ):
406             pytest.raises(nx.NodeNotFound, fn, G, 3, 0)
407             pytest.raises(nx.NodeNotFound, fn, G, 3, 3)
408     def test_absent_source_goldberg_radzik(self):
409         with pytest.raises(nx.NodeNotFound):
410             nx.goldberg_radzik(G, 3, 0)
411     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def test_negative_cycle_heuristic(self):
412         G = nx.DiGraph()
413         G.add_edge(0, 1, weight=-1)
414         G.add_edge(1, 2, weight=-1)
415         G.add_edge(2, 3, weight=-1)
416         G.add_edge(3, 0, weight=</b></font>3)
417         assert not nx.negative_edge_cycle(G, heuristic=True)
418         G.add_edge(2, 0, weight=1.999)
419         assert nx.negative_edge_cycle(G, heuristic=True)
420         G.edges[2, 0]["weight"] = 2
421         assert not nx.negative_edge_cycle(G, heuristic=True)
422     def test_negative_cycle_consistency(self):
423         import random
424         unif = random.uniform
425         for random_seed in range(2):  # range(20):
426             random.seed(random_seed)
427             for density in [0.1, 0.9]:  # .3, .7, .9]:
428                 for N in [1, 10, 20]:  # range(1, 60 - int(30 * density)):
429                     for max_cost in [1, 90]:  # [1, 10, 40, 90]:
430                         G = nx.binomial_graph(N, density, seed=4, directed=True)
431                         edges = ((u, v, unif(-1, max_cost)) for u, v in G.edges)
432                         G.add_weighted_edges_from(edges)
433                         no_heuristic = nx.negative_edge_cycle(G, heuristic=False)
434                         with_heuristic = nx.negative_edge_cycle(G, heuristic=True)
435                         assert no_heuristic == with_heuristic
436     def test_negative_cycle(self):
437         G = nx.cycle_graph(5, create_using=nx.DiGraph())
438         G.add_edge(1, 2, weight=-7)
439         for i in range(5):
440             pytest.raises(
441                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
442             )
443             pytest.raises(
444                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
445             )
446             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
447             pytest.raises(
448                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
449             )
450             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
451         G = nx.cycle_graph(5)  # undirected Graph
452         G.add_edge(1, 2, weight=-3)
453         for i in range(5):
454             pytest.raises(
455                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
456             )
457             pytest.raises(
458                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
459             )
460             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
461             pytest.raises(
462                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
463             )
464             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
465         G = nx.DiGraph([(1, 1, {"weight": -1})])
466         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, 1)
467         pytest.raises(
468             nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, 1
469         )
470         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, 1)
471         pytest.raises(
472             nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, 1
473         )
474         pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, 1)
475     def test_find_negative_cycle_longer_cycle(self):
476         G = nx.cycle_graph(5, create_using=nx.DiGraph())
477         nx.add_cycle(G, [3, 5, 6, 7, 8, 9])
478         G.add_edge(1, 2, weight=-30)
479         assert nx.find_negative_cycle(G, 1) == [0, 1, 2, 3, 4, 0]
480         assert nx.find_negative_cycle(G, 7) == [2, 3, 4, 0, 1, 2]
481     def test_find_negative_cycle_no_cycle(self):
482         G = nx.path_graph(5, create_using=nx.DiGraph())
483         pytest.raises(nx.NetworkXError, nx.find_negative_cycle, G, 3)
484     def test_find_negative_cycle_single_edge(self):
485         G = nx.Graph()
486         G.add_edge(0, 1, weight=-1)
487         assert nx.find_negative_cycle(G, 1) == [1, 0, 1]
488     def test_negative_weight(self):
489         G = nx.cycle_graph(5, create_using=nx.DiGraph())
490         G.add_edge(1, 2, weight=-3)
491         assert nx.single_source_bellman_ford_path(G, 0) == {
492             0: [0],
493             1: [0, 1],
494             2: [0, 1, 2],
495             3: [0, 1, 2, 3],
496             4: [0, 1, 2, 3, 4],
497         }
498         assert nx.single_source_bellman_ford_path_length(G, 0) == {
499             0: 0,
500             1: 1,
501             2: -2,
502             3: -1,
503             4: 0,
504         }
505         assert nx.single_source_bellman_ford(G, 0) == (
506             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
507             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3, 4]},
508         )
509         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
510             {0: [], 1: [0], 2: [1], 3: [2], 4: [3]},
511             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
512         )
513         assert nx.goldberg_radzik(G, 0) == (
514             {0: None, 1: 0, 2: 1, 3: 2, 4: 3},
515             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
516         )
517     def test_not_connected(self):
518         G = nx.complete_graph(6)
519         G.add_edge(10, 11)
520         G.add_edge(10, 12)
521         assert nx.single_source_bellman_ford_path(G, 0) == {
522             0: [0],
523             1: [0, 1],
524             2: [0, 2],
525             3: [0, 3],
526             4: [0, 4],
527             5: [0, 5],
528         }
529         assert nx.single_source_bellman_ford_path_length(G, 0) == {
530             0: 0,
531             1: 1,
532             2: 1,
533             3: 1,
534             4: 1,
535             5: 1,
536         }
537         assert nx.single_source_bellman_ford(G, 0) == (
538             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
539             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
540         )
541         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
542             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
543             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
544         )
545         assert nx.goldberg_radzik(G, 0) == (
546             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
547             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
548         )
549         G = nx.complete_graph(6)
550         G.add_edges_from(
551             [
552                 ("A", "B", {"load": 3}),
553                 ("B", "C", {"load": -10}),
554                 ("C", "A", {"load": 2}),
555             ]
556         )
557         assert nx.single_source_bellman_ford_path(G, 0, weight="load") == {
558             0: [0],
559             1: [0, 1],
560             2: [0, 2],
561             3: [0, 3],
562             4: [0, 4],
563             5: [0, 5],
564         }
565         assert nx.single_source_bellman_ford_path_length(G, 0, weight="load") == {
566             0: 0,
567             1: 1,
568             2: 1,
569             3: 1,
570             4: 1,
571             5: 1,
572         }
573         assert nx.single_source_bellman_ford(G, 0, weight="load") == (
574             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
575             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
576         )
577         assert nx.bellman_ford_predecessor_and_distance(G, 0, weight="load") == (
578             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
579             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
580         )
581         assert nx.goldberg_radzik(G, 0, weight="load") == (
582             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
583             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
584         )
585     def test_multigraph(self):
586         assert nx.bellman_ford_path(self.MXG, "s", "v") == ["s", "x", "u", "v"]
587         assert nx.bellman_ford_path_length(self.MXG, "s", "v") == 9
588         assert nx.single_source_bellman_ford_path(self.MXG, "s")["v"] == [
589             "s",
590             "x",
591             "u",
592             "v",
593         ]
594         assert nx.single_source_bellman_ford_path_length(self.MXG, "s")["v"] == 9
595         D, P = nx.single_source_bellman_ford(self.MXG, "s", target="v")
596         assert D == 9
597         assert P == ["s", "x", "u", "v"]
598         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG, "s")
599         assert P["v"] == ["u"]
600         assert D["v"] == 9
601         P, D = nx.goldberg_radzik(self.MXG, "s")
602         assert P["v"] == "u"
603         assert D["v"] == 9
604         assert nx.bellman_ford_path(self.MXG4, 0, 2) == [0, 1, 2]
605         assert nx.bellman_ford_path_length(self.MXG4, 0, 2) == 4
606         assert nx.single_source_bellman_ford_path(self.MXG4, 0)[2] == [0, 1, 2]
607         assert nx.single_source_bellman_ford_path_length(self.MXG4, 0)[2] == 4
608         D, P = nx.single_source_bellman_ford(self.MXG4, 0, target=2)
609         assert D == 4
610         assert P == [0, 1, 2]
611         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG4, 0)
612         assert P[2] == [1]
613         assert D[2] == 4
614         P, D = nx.goldberg_radzik(self.MXG4, 0)
615         assert P[2] == 1
616         assert D[2] == 4
617     def test_others(self):
618         assert nx.bellman_ford_path(self.XG, "s", "v") == ["s", "x", "u", "v"]
619         assert nx.bellman_ford_path_length(self.XG, "s", "v") == 9
620         assert nx.single_source_bellman_ford_path(self.XG, "s")["v"] == [
621             "s",
622             "x",
623             "u",
624             "v",
625         ]
626         assert nx.single_source_bellman_ford_path_length(self.XG, "s")["v"] == 9
627         D, P = nx.single_source_bellman_ford(self.XG, "s", target="v")
628         assert D == 9
629         assert P == ["s", "x", "u", "v"]
630         (P, D) = nx.bellman_ford_predecessor_and_distance(self.XG, "s")
631         assert P["v"] == ["u"]
632         assert D["v"] == 9
633         (P, D) = nx.goldberg_radzik(self.XG, "s")
634         assert P["v"] == "u"
635         assert D["v"] == 9
636     def test_path_graph(self):
637         G = nx.path_graph(4)
638         assert nx.single_source_bellman_ford_path(G, 0) == {
639             0: [0],
640             1: [0, 1],
641             2: [0, 1, 2],
642             3: [0, 1, 2, 3],
643         }
644         assert nx.single_source_bellman_ford_path_length(G, 0) == {
645             0: 0,
646             1: 1,
647             2: 2,
648             3: 3,
649         }
650         assert nx.single_source_bellman_ford(G, 0) == (
651             {0: 0, 1: 1, 2: 2, 3: 3},
652             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3]},
653         )
654         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
655             {0: [], 1: [0], 2: [1], 3: [2]},
656             {0: 0, 1: 1, 2: 2, 3: 3},
657         )
658         assert nx.goldberg_radzik(G, 0) == (
659             {0: None, 1: 0, 2: 1, 3: 2},
660             {0: 0, 1: 1, 2: 2, 3: 3},
661         )
662         assert nx.single_source_bellman_ford_path(G, 3) == {
663             0: [3, 2, 1, 0],
664             1: [3, 2, 1],
665             2: [3, 2],
666             3: [3],
667         }
668         assert nx.single_source_bellman_ford_path_length(G, 3) == {
669             0: 3,
670             1: 2,
671             2: 1,
672             3: 0,
673         }
674         assert nx.single_source_bellman_ford(G, 3) == (
675             {0: 3, 1: 2, 2: 1, 3: 0},
676             {0: [3, 2, 1, 0], 1: [3, 2, 1], 2: [3, 2], 3: [3]},
677         )
678         assert nx.bellman_ford_predecessor_and_distance(G, 3) == (
679             {0: [1], 1: [2], 2: [3], 3: []},
680             {0: 3, 1: 2, 2: 1, 3: 0},
681         )
682         assert nx.goldberg_radzik(G, 3) == (
683             {0: 1, 1: 2, 2: 3, 3: None},
684             {0: 3, 1: 2, 2: 1, 3: 0},
685         )
686     def test_4_cycle(self):
687         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
688         dist, path = nx.single_source_bellman_ford(G, 0)
689         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
690         assert path[0] == [0]
691         assert path[1] == [0, 1]
692         assert path[2] in [[0, 1, 2], [0, 3, 2]]
693         assert path[3] == [0, 3]
694         pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)
695         assert pred[0] == []
696         assert pred[1] == [0]
697         assert pred[2] in [[1, 3], [3, 1]]
698         assert pred[3] == [0]
699         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
700         pred, dist = nx.goldberg_radzik(G, 0)
701         assert pred[0] is None
702         assert pred[1] == 0
703         assert pred[2] in [1, 3]
704         assert pred[3] == 0
705         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
706         G = nx.DiGraph()
707         G.add_nodes_from("abcd")
708         G<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.add_edge("a", "d", weight=0)
709         G.add_edge("a", "b", weight=1)
710         G.add_edge("b", "c", weight=-3)
711         assert nx.bellman_ford_path(G, "a", "d") == ["a", "b", "c", "d"]
712         assert nx.bellman_ford_path_length(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>G, "a", "d") == -1
713     def test_zero_cycle_smoke(self):
714         D = nx.DiGraph()
715         D.add_weighted_edges_from([(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 1, -2)])
716         nx.</b></font>bellman_ford_path(D, 1, 3)
717         nx.dijkstra_path(D, 1, 3)
718         nx.bidirectional_dijkstra(D, 1, 3)
719 class TestJohnsonAlgorithm(WeightedTestBase):
720     def test_single_node_graph(self):
721             G = nx.DiGraph()
722             G.add_node(0)
723             nx.johnson(G<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>)
724     def test_negative_cycle(self):
725         G = nx.DiGraph()
726         G.add_weighted_edges_from(
727             [
728                 ("0", "3", 3),
729                 ("0", "1", -5),
730                 ("1", "0", -5),
731                 ("0", "2", 2),
732                 ("1", "2", 4),
733                 ("2", "3", 1),
734             ]
735         )
736         pytest.</b></font>raises(nx.NetworkXUnbounded, nx.johnson, G)
737         G = nx.Graph()
738         G.add_weighted_edges_from(
739             [
740                 ("0", "3", 3),
741                 ("0", "1", -5),
742                 ("1", "0", -5),
743                 ("0", "2", 2),
744                 ("1", "2", 4),
745             ]
746         )
747         pytest.raises(nx.NetworkXUnbounded, nx.<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>johnson, G)
748     def test_negative_weights(self):
749         G = nx.DiGraph()
750         G.add_weighted_edges_from(
751             [("0", "3", 3), ("0", "1", -5), ("0", "2", 2), ("1", "2", 4), ("2"</b></font>, "3", 1)]
752         )
753         paths = nx.johnson(G)
754         assert paths == {
755             "1": {"1": ["1"], "3": ["1", "2", "3"], "2": ["1", "2"]},
756             "0": {
757                 "1": ["0", "1"],
758                 "0": ["0"],
759                 "3": ["0", "1", "2", "3"],
760                 "2": ["0", "1", "2"],
761             },
762             "3": {"3": ["3"]},
763             "2": {"3": ["2", "3"], "2": ["2"]},
764         }
765     def test_unweighted_graph(self):
766         with pytest.raises(nx.NetworkXError):
767             G = nx.path_graph(5)
768             nx.johnson(G)
769     def test_graphs(self):
770         validate_path(self.XG, "s", "v", 9, nx.johnson(self.XG)["s"]["v"])
771         validate_path(self.MXG, "s", "v", 9, nx.johnson(self.MXG)["s"]["v"])
772         validate_path(self.XG2, 1, 3, 4, nx.johnson(self.XG2)[1][3])
773         validate_path(self.XG3, 0, 3, 15, nx.johnson(self.XG3)[0][3])
774         validate_path(self.XG4, 0, 2, 4, nx.johnson(self.XG4)[0][2])
775         validate_path(self.MXG4, 0, 2, 4, nx.johnson(self.MXG4)[0][2])
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
