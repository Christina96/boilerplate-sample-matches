<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_betweenness_centrality.py & test_weighted.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_betweenness_centrality.py & test_weighted.py
      </h3>
      <h1 align="center">
        9.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_betweenness_centrality.py (11.3672495%)<TH>test_weighted.py (8.069978%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#0',2,'match2095-1.html#0',3)" NAME="0">(525-542)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#0',2,'match2095-1.html#0',3)" NAME="0">(286-304)</A><TD ALIGN=center><FONT COLOR="#ff0000">19</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#1',2,'match2095-1.html#1',3)" NAME="1">(705-719)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#1',2,'match2095-1.html#1',3)" NAME="1">(48-60)</A><TD ALIGN=center><FONT COLOR="#d60000">16</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#2',2,'match2095-1.html#2',3)" NAME="2">(5-10)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#2',2,'match2095-1.html#2',3)" NAME="2">(526-531)</A><TD ALIGN=center><FONT COLOR="#d60000">16</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#3',2,'match2095-1.html#3',3)" NAME="3">(235-240)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#3',2,'match2095-1.html#3',3)" NAME="3">(867-881)</A><TD ALIGN=center><FONT COLOR="#c90000">15</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#4',2,'match2095-1.html#4',3)" NAME="4">(642-653)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#4',2,'match2095-1.html#4',3)" NAME="4">(83-93)</A><TD ALIGN=center><FONT COLOR="#bb0000">14</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#5',2,'match2095-1.html#5',3)" NAME="5">(672-683)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#5',2,'match2095-1.html#5',3)" NAME="5">(65-76)</A><TD ALIGN=center><FONT COLOR="#ae0000">13</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#6',2,'match2095-1.html#6',3)" NAME="6">(491-502)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#6',2,'match2095-1.html#6',3)" NAME="6">(893-898)</A><TD ALIGN=center><FONT COLOR="#ae0000">13</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#7',2,'match2095-1.html#7',3)" NAME="7">(472-477)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#7',2,'match2095-1.html#7',3)" NAME="7">(850-856)</A><TD ALIGN=center><FONT COLOR="#ae0000">13</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#8',2,'match2095-1.html#8',3)" NAME="8">(749-759)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#8',2,'match2095-1.html#8',3)" NAME="8">(77-81)</A><TD ALIGN=center><FONT COLOR="#a10000">12</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match2095-0.html#9',2,'match2095-1.html#9',3)" NAME="9">(11-14)<TD><A HREF="javascript:ZweiFrames('match2095-0.html#9',2,'match2095-1.html#9',3)" NAME="9">(844-847)</A><TD ALIGN=center><FONT COLOR="#a10000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_betweenness_centrality.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest
<A NAME="2"></A>import networkx as nx


<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2095-1.html#2',3,'match2095-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>def weighted_G():
    G = nx.Graph()
    G.add_edge(0, 1, weight=3)
<A NAME="9"></A>    G.add_edge(0, 2, weight=2)
    G.add_edge(0, 3, weight=6)
    G.add_edge(0, 4, weight=</B></FONT>4)
    G<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match2095-1.html#9',3,'match2095-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.add_edge(1, 3, weight=5)
    G.add_edge(1, 5, weight=5)
    G.add_edge(2, 4, weight=1)
    G.add_edge(3, 4, weight=</B></FONT>2)
    G.add_edge(3, 5, weight=1)
    G.add_edge(4, 5, weight=4)
    return G


class TestBetweennessCentrality:
    def test_K5(self):
        &quot;&quot;&quot;Betweenness centrality: K5&quot;&quot;&quot;
        G = nx.complete_graph(5)
        b = nx.betweenness_centrality(G, weight=None, normalized=False)
        b_answer = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.0}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_K5_endpoints(self):
        &quot;&quot;&quot;Betweenness centrality: K5 endpoints&quot;&quot;&quot;
        G = nx.complete_graph(5)
        b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
        b_answer = {0: 4.0, 1: 4.0, 2: 4.0, 3: 4.0, 4: 4.0}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
        # normalized = True case
        b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
        b_answer = {0: 0.4, 1: 0.4, 2: 0.4, 3: 0.4, 4: 0.4}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_P3_normalized(self):
        &quot;&quot;&quot;Betweenness centrality: P3 normalized&quot;&quot;&quot;
        G = nx.path_graph(3)
        b = nx.betweenness_centrality(G, weight=None, normalized=True)
        b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_P3(self):
        &quot;&quot;&quot;Betweenness centrality: P3&quot;&quot;&quot;
        G = nx.path_graph(3)
        b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
        b = nx.betweenness_centrality(G, weight=None, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_sample_from_P3(self):
        &quot;&quot;&quot;Betweenness centrality: P3 sample&quot;&quot;&quot;
        G = nx.path_graph(3)
        b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
        b = nx.betweenness_centrality(G, k=3, weight=None, normalized=False, seed=1)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
        b = nx.betweenness_centrality(G, k=2, weight=None, normalized=False, seed=1)
        # python versions give different results with same seed
        b_approx1 = {0: 0.0, 1: 1.5, 2: 0.0}
        b_approx2 = {0: 0.0, 1: 0.75, 2: 0.0}
        for n in sorted(G):
            assert b[n] in (b_approx1[n], b_approx2[n])

    def test_P3_endpoints(self):
        &quot;&quot;&quot;Betweenness centrality: P3 endpoints&quot;&quot;&quot;
        G = nx.path_graph(3)
        b_answer = {0: 2.0, 1: 3.0, 2: 2.0}
        b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
        # normalized = True case
        b_answer = {0: 2 / 3, 1: 1.0, 2: 2 / 3}
        b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_krackhardt_kite_graph(self):
        &quot;&quot;&quot;Betweenness centrality: Krackhardt kite graph&quot;&quot;&quot;
        G = nx.krackhardt_kite_graph()
        b_answer = {
            0: 1.667,
            1: 1.667,
            2: 0.000,
            3: 7.333,
            4: 0.000,
            5: 16.667,
            6: 16.667,
            7: 28.000,
            8: 16.000,
            9: 0.000,
        }
        for b in b_answer:
            b_answer[b] /= 2
        b = nx.betweenness_centrality(G, weight=None, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_krackhardt_kite_graph_normalized(self):
        &quot;&quot;&quot;Betweenness centrality: Krackhardt kite graph normalized&quot;&quot;&quot;
        G = nx.krackhardt_kite_graph()
        b_answer = {
            0: 0.023,
            1: 0.023,
            2: 0.000,
            3: 0.102,
            4: 0.000,
            5: 0.231,
            6: 0.231,
            7: 0.389,
            8: 0.222,
            9: 0.000,
        }
        b = nx.betweenness_centrality(G, weight=None, normalized=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_florentine_families_graph(self):
        &quot;&quot;&quot;Betweenness centrality: Florentine families graph&quot;&quot;&quot;
        G = nx.florentine_families_graph()
        b_answer = {
            &quot;Acciaiuoli&quot;: 0.000,
            &quot;Albizzi&quot;: 0.212,
            &quot;Barbadori&quot;: 0.093,
            &quot;Bischeri&quot;: 0.104,
            &quot;Castellani&quot;: 0.055,
            &quot;Ginori&quot;: 0.000,
            &quot;Guadagni&quot;: 0.255,
            &quot;Lamberteschi&quot;: 0.000,
            &quot;Medici&quot;: 0.522,
            &quot;Pazzi&quot;: 0.000,
            &quot;Peruzzi&quot;: 0.022,
            &quot;Ridolfi&quot;: 0.114,
            &quot;Salviati&quot;: 0.143,
            &quot;Strozzi&quot;: 0.103,
            &quot;Tornabuoni&quot;: 0.092,
        }

        b = nx.betweenness_centrality(G, weight=None, normalized=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_les_miserables_graph(self):
        &quot;&quot;&quot;Betweenness centrality: Les Miserables graph&quot;&quot;&quot;
        G = nx.les_miserables_graph()
        b_answer = {
            &quot;Napoleon&quot;: 0.000,
            &quot;Myriel&quot;: 0.177,
            &quot;MlleBaptistine&quot;: 0.000,
            &quot;MmeMagloire&quot;: 0.000,
            &quot;CountessDeLo&quot;: 0.000,
            &quot;Geborand&quot;: 0.000,
            &quot;Champtercier&quot;: 0.000,
            &quot;Cravatte&quot;: 0.000,
            &quot;Count&quot;: 0.000,
            &quot;OldMan&quot;: 0.000,
            &quot;Valjean&quot;: 0.570,
            &quot;Labarre&quot;: 0.000,
            &quot;Marguerite&quot;: 0.000,
            &quot;MmeDeR&quot;: 0.000,
            &quot;Isabeau&quot;: 0.000,
            &quot;Gervais&quot;: 0.000,
            &quot;Listolier&quot;: 0.000,
            &quot;Tholomyes&quot;: 0.041,
            &quot;Fameuil&quot;: 0.000,
            &quot;Blacheville&quot;: 0.000,
            &quot;Favourite&quot;: 0.000,
            &quot;Dahlia&quot;: 0.000,
            &quot;Zephine&quot;: 0.000,
            &quot;Fantine&quot;: 0.130,
            &quot;MmeThenardier&quot;: 0.029,
            &quot;Thenardier&quot;: 0.075,
            &quot;Cosette&quot;: 0.024,
            &quot;Javert&quot;: 0.054,
            &quot;Fauchelevent&quot;: 0.026,
            &quot;Bamatabois&quot;: 0.008,
            &quot;Perpetue&quot;: 0.000,
            &quot;Simplice&quot;: 0.009,
            &quot;Scaufflaire&quot;: 0.000,
            &quot;Woman1&quot;: 0.000,
            &quot;Judge&quot;: 0.000,
            &quot;Champmathieu&quot;: 0.000,
            &quot;Brevet&quot;: 0.000,
            &quot;Chenildieu&quot;: 0.000,
            &quot;Cochepaille&quot;: 0.000,
            &quot;Pontmercy&quot;: 0.007,
            &quot;Boulatruelle&quot;: 0.000,
            &quot;Eponine&quot;: 0.011,
            &quot;Anzelma&quot;: 0.000,
            &quot;Woman2&quot;: 0.000,
            &quot;MotherInnocent&quot;: 0.000,
            &quot;Gribier&quot;: 0.000,
            &quot;MmeBurgon&quot;: 0.026,
            &quot;Jondrette&quot;: 0.000,
            &quot;Gavroche&quot;: 0.165,
            &quot;Gillenormand&quot;: 0.020,
            &quot;Magnon&quot;: 0.000,
            &quot;MlleGillenormand&quot;: 0.048,
            &quot;MmePontmercy&quot;: 0.000,
            &quot;MlleVaubois&quot;: 0.000,
            &quot;LtGillenormand&quot;: 0.000,
            &quot;Marius&quot;: 0.132,
            &quot;BaronessT&quot;: 0.000,
            &quot;Mabeuf&quot;: 0.028,
            &quot;Enjolras&quot;: 0.043,
            &quot;Combeferre&quot;: 0.001,
            &quot;Prouvaire&quot;: 0.000,
            &quot;Feuilly&quot;: 0.001,
            &quot;Courfeyrac&quot;: 0.005,
            &quot;Bahorel&quot;: 0.002,
            &quot;Bossuet&quot;: 0.031,
            &quot;Joly&quot;: 0.002,
            &quot;Grantaire&quot;: 0.000,
            &quot;MotherPlutarch&quot;: 0.000,
            &quot;Gueulemer&quot;: 0.005,
            &quot;Babet&quot;: 0.005,
            &quot;Claquesous&quot;: 0.005,
            &quot;Montparnasse&quot;: 0.004,
            &quot;Toussaint&quot;: 0.000,
            &quot;Child1&quot;: 0.000,
            &quot;Child2&quot;: 0.000,
            &quot;Brujon&quot;: 0.000,
            &quot;MmeHucheloup&quot;: 0.000,
        }
<A NAME="3"></A>
        b = nx.betweenness_centrality(G, weight=None, normalized=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2095-1.html#3',3,'match2095-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>e-3)

    def test_ladder_graph(self):
        &quot;&quot;&quot;Betweenness centrality: Ladder graph&quot;&quot;&quot;
        G = nx.Graph()  # ladder_graph(3)
        G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3), (2, 4), (4, 5), (3</B></FONT>, 5)])
        b_answer = {0: 1.667, 1: 1.667, 2: 6.667, 3: 6.667, 4: 1.667, 5: 1.667}
        for b in b_answer:
            b_answer[b] /= 2
        b = nx.betweenness_centrality(G, weight=None, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_disconnected_path(self):
        &quot;&quot;&quot;Betweenness centrality: disconnected path&quot;&quot;&quot;
        G = nx.Graph()
        nx.add_path(G, [0, 1, 2])
        nx.add_path(G, [3, 4, 5, 6])
        b_answer = {0: 0, 1: 1, 2: 0, 3: 0, 4: 2, 5: 2, 6: 0}
        b = nx.betweenness_centrality(G, weight=None, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_disconnected_path_endpoints(self):
        &quot;&quot;&quot;Betweenness centrality: disconnected path endpoints&quot;&quot;&quot;
        G = nx.Graph()
        nx.add_path(G, [0, 1, 2])
        nx.add_path(G, [3, 4, 5, 6])
        b_answer = {0: 2, 1: 3, 2: 2, 3: 3, 4: 5, 5: 5, 6: 3}
        b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
        # normalized = True case
        b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n] / 21, abs=1e-7)

    def test_directed_path(self):
        &quot;&quot;&quot;Betweenness centrality: directed path&quot;&quot;&quot;
        G = nx.DiGraph()
        nx.add_path(G, [0, 1, 2])
        b = nx.betweenness_centrality(G, weight=None, normalized=False)
        b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_directed_path_normalized(self):
        &quot;&quot;&quot;Betweenness centrality: directed path normalized&quot;&quot;&quot;
        G = nx.DiGraph()
        nx.add_path(G, [0, 1, 2])
        b = nx.betweenness_centrality(G, weight=None, normalized=True)
        b_answer = {0: 0.0, 1: 0.5, 2: 0.0}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)


class TestWeightedBetweennessCentrality:
    def test_K5(self):
        &quot;&quot;&quot;Weighted betweenness centrality: K5&quot;&quot;&quot;
        G = nx.complete_graph(5)
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        b_answer = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.0}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_P3_normalized(self):
        &quot;&quot;&quot;Weighted betweenness centrality: P3 normalized&quot;&quot;&quot;
        G = nx.path_graph(3)
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=True)
        b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_P3(self):
        &quot;&quot;&quot;Weighted betweenness centrality: P3&quot;&quot;&quot;
        G = nx.path_graph(3)
        b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_krackhardt_kite_graph(self):
        &quot;&quot;&quot;Weighted betweenness centrality: Krackhardt kite graph&quot;&quot;&quot;
        G = nx.krackhardt_kite_graph()
        b_answer = {
            0: 1.667,
            1: 1.667,
            2: 0.000,
            3: 7.333,
            4: 0.000,
            5: 16.667,
            6: 16.667,
            7: 28.000,
            8: 16.000,
            9: 0.000,
        }
        for b in b_answer:
            b_answer[b] /= 2

        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)

        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_krackhardt_kite_graph_normalized(self):
        &quot;&quot;&quot;Weighted betweenness centrality:
        Krackhardt kite graph normalized
        &quot;&quot;&quot;
        G = nx.krackhardt_kite_graph()
        b_answer = {
            0: 0.023,
            1: 0.023,
            2: 0.000,
            3: 0.102,
            4: 0.000,
            5: 0.231,
            6: 0.231,
            7: 0.389,
            8: 0.222,
            9: 0.000,
        }
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=True)

        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_florentine_families_graph(self):
        &quot;&quot;&quot;Weighted betweenness centrality:
        Florentine families graph&quot;&quot;&quot;
        G = nx.florentine_families_graph()
        b_answer = {
            &quot;Acciaiuoli&quot;: 0.000,
            &quot;Albizzi&quot;: 0.212,
            &quot;Barbadori&quot;: 0.093,
            &quot;Bischeri&quot;: 0.104,
            &quot;Castellani&quot;: 0.055,
            &quot;Ginori&quot;: 0.000,
            &quot;Guadagni&quot;: 0.255,
            &quot;Lamberteschi&quot;: 0.000,
            &quot;Medici&quot;: 0.522,
            &quot;Pazzi&quot;: 0.000,
            &quot;Peruzzi&quot;: 0.022,
            &quot;Ridolfi&quot;: 0.114,
            &quot;Salviati&quot;: 0.143,
            &quot;Strozzi&quot;: 0.103,
            &quot;Tornabuoni&quot;: 0.092,
        }

        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_les_miserables_graph(self):
        &quot;&quot;&quot;Weighted betweenness centrality: Les Miserables graph&quot;&quot;&quot;
        G = nx.les_miserables_graph()
        b_answer = {
            &quot;Napoleon&quot;: 0.000,
            &quot;Myriel&quot;: 0.177,
            &quot;MlleBaptistine&quot;: 0.000,
            &quot;MmeMagloire&quot;: 0.000,
            &quot;CountessDeLo&quot;: 0.000,
            &quot;Geborand&quot;: 0.000,
            &quot;Champtercier&quot;: 0.000,
            &quot;Cravatte&quot;: 0.000,
            &quot;Count&quot;: 0.000,
            &quot;OldMan&quot;: 0.000,
            &quot;Valjean&quot;: 0.454,
            &quot;Labarre&quot;: 0.000,
            &quot;Marguerite&quot;: 0.009,
            &quot;MmeDeR&quot;: 0.000,
            &quot;Isabeau&quot;: 0.000,
            &quot;Gervais&quot;: 0.000,
            &quot;Listolier&quot;: 0.000,
            &quot;Tholomyes&quot;: 0.066,
            &quot;Fameuil&quot;: 0.000,
            &quot;Blacheville&quot;: 0.000,
            &quot;Favourite&quot;: 0.000,
            &quot;Dahlia&quot;: 0.000,
            &quot;Zephine&quot;: 0.000,
            &quot;Fantine&quot;: 0.114,
            &quot;MmeThenardier&quot;: 0.046,
            &quot;Thenardier&quot;: 0.129,
            &quot;Cosette&quot;: 0.075,
            &quot;Javert&quot;: 0.193,
            &quot;Fauchelevent&quot;: 0.026,
            &quot;Bamatabois&quot;: 0.080,
            &quot;Perpetue&quot;: 0.000,
            &quot;Simplice&quot;: 0.001,
            &quot;Scaufflaire&quot;: 0.000,
            &quot;Woman1&quot;: 0.000,
            &quot;Judge&quot;: 0.000,
            &quot;Champmathieu&quot;: 0.000,
            &quot;Brevet&quot;: 0.000,
            &quot;Chenildieu&quot;: 0.000,
            &quot;Cochepaille&quot;: 0.000,
            &quot;Pontmercy&quot;: 0.023,
            &quot;Boulatruelle&quot;: 0.000,
            &quot;Eponine&quot;: 0.023,
            &quot;Anzelma&quot;: 0.000,
            &quot;Woman2&quot;: 0.000,
            &quot;MotherInnocent&quot;: 0.000,
            &quot;Gribier&quot;: 0.000,
            &quot;MmeBurgon&quot;: 0.026,
            &quot;Jondrette&quot;: 0.000,
            &quot;Gavroche&quot;: 0.285,
            &quot;Gillenormand&quot;: 0.024,
            &quot;Magnon&quot;: 0.005,
            &quot;MlleGillenormand&quot;: 0.036,
            &quot;MmePontmercy&quot;: 0.005,
            &quot;MlleVaubois&quot;: 0.000,
            &quot;LtGillenormand&quot;: 0.015,
            &quot;Marius&quot;: 0.072,
            &quot;BaronessT&quot;: 0.004,
            &quot;Mabeuf&quot;: 0.089,
            &quot;Enjolras&quot;: 0.003,
            &quot;Combeferre&quot;: 0.000,
            &quot;Prouvaire&quot;: 0.000,
            &quot;Feuilly&quot;: 0.004,
            &quot;Courfeyrac&quot;: 0.001,
            &quot;Bahorel&quot;: 0.007,
            &quot;Bossuet&quot;: 0.028,
            &quot;Joly&quot;: 0.000,
            &quot;Grantaire&quot;: 0.036,
            &quot;MotherPlutarch&quot;: 0.000,
            &quot;Gueulemer&quot;: 0.025,
            &quot;Babet&quot;: 0.015,
            &quot;Claquesous&quot;: 0.042,
            &quot;Montparnasse&quot;: 0.050,
            &quot;Toussaint&quot;: 0.011,
            &quot;Child1&quot;: 0.000,
            &quot;Child2&quot;: 0.000,
            &quot;Brujon&quot;: 0.002,
            &quot;MmeHucheloup&quot;: 0.034,
        }
<A NAME="7"></A>
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=True)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match2095-1.html#7',3,'match2095-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>e-3)

    def test_ladder_graph(self):
        &quot;&quot;&quot;Weighted betweenness centrality: Ladder graph&quot;&quot;&quot;
        G = nx.Graph()  # ladder_graph(3)
        G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3), (2</B></FONT>, 4), (4, 5), (3, 5)])
        b_answer = {0: 1.667, 1: 1.667, 2: 6.667, 3: 6.667, 4: 1.667, 5: 1.667}
        for b in b_answer:
            b_answer[b] /= 2
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-3)

    def test_G(self):
        &quot;&quot;&quot;Weighted betweenness centrality: G&quot;&quot;&quot;
        G = weighted_G()
<A NAME="6"></A>        b_answer = {0: 2.0, 1: 0.0, 2: 4.0, 3: 3.0, 4: 4.0, 5: 0.0}
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match2095-1.html#6',3,'match2095-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>e-7)

    def test_G2(self):
        &quot;&quot;&quot;Weighted betweenness centrality: G2&quot;&quot;&quot;
        G = nx.DiGraph()
        G.add_weighted_edges_from(
            [
                (&quot;s&quot;, &quot;u&quot;, 10),
                (&quot;s&quot;, &quot;x&quot;, 5),
                (&quot;u&quot;, &quot;v&quot;, 1),
                (&quot;u&quot;, &quot;x&quot;, 2),
                (&quot;v&quot;</B></FONT>, &quot;y&quot;, 1),
                (&quot;x&quot;, &quot;u&quot;, 3),
                (&quot;x&quot;, &quot;v&quot;, 5),
                (&quot;x&quot;, &quot;y&quot;, 2),
                (&quot;y&quot;, &quot;s&quot;, 7),
                (&quot;y&quot;, &quot;v&quot;, 6),
            ]
        )

        b_answer = {&quot;y&quot;: 5.0, &quot;x&quot;: 5.0, &quot;s&quot;: 4.0, &quot;u&quot;: 2.0, &quot;v&quot;: 2.0}

        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_G3(self):
        &quot;&quot;&quot;Weighted betweenness centrality: G3&quot;&quot;&quot;
        G = nx.MultiGraph(weighted_G())
        es = list(G.edges(data=True))[::2]  # duplicate every other edge
        G.add_edges_from(es)
<A NAME="0"></A>        b_answer = {0: 2.0, 1: 0.0, 2: 4.0, 3: 3.0, 4: 4.0, 5: 0.0}
        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2095-1.html#0',3,'match2095-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>e-7)

    def test_G4(self):
        &quot;&quot;&quot;Weighted betweenness centrality: G4&quot;&quot;&quot;
        G = nx.MultiDiGraph()
        G.add_weighted_edges_from(
            [
                (&quot;s&quot;, &quot;u&quot;, 10),
                (&quot;s&quot;, &quot;x&quot;, 5),
                (&quot;s&quot;, &quot;x&quot;, 6),
                (&quot;u&quot;, &quot;v&quot;, 1),
                (&quot;u&quot;, &quot;x&quot;, 2),
                (&quot;v&quot;, &quot;y&quot;, 1),
                (&quot;v&quot;, &quot;y&quot;, 1),
                (&quot;x&quot;, &quot;u&quot;, 3),
                (&quot;x&quot;, &quot;v&quot;, 5),
                (&quot;x&quot;, &quot;y&quot;, 2),
                (&quot;x&quot;</B></FONT>, &quot;y&quot;, 3),
                (&quot;y&quot;, &quot;s&quot;, 7),
                (&quot;y&quot;, &quot;v&quot;, 6),
                (&quot;y&quot;, &quot;v&quot;, 6),
            ]
        )

        b_answer = {&quot;y&quot;: 5.0, &quot;x&quot;: 5.0, &quot;s&quot;: 4.0, &quot;u&quot;: 2.0, &quot;v&quot;: 2.0}

        b = nx.betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        for n in sorted(G):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)


class TestEdgeBetweennessCentrality:
    def test_K5(self):
        &quot;&quot;&quot;Edge betweenness centrality: K5&quot;&quot;&quot;
        G = nx.complete_graph(5)
        b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
        b_answer = dict.fromkeys(G.edges(), 1)
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_normalized_K5(self):
        &quot;&quot;&quot;Edge betweenness centrality: K5&quot;&quot;&quot;
        G = nx.complete_graph(5)
        b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
        b_answer = dict.fromkeys(G.edges(), 1 / 10)
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_C4(self):
        &quot;&quot;&quot;Edge betweenness centrality: C4&quot;&quot;&quot;
        G = nx.cycle_graph(4)
        b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
        b_answer = {(0, 1): 2, (0, 3): 2, (1, 2): 2, (2, 3): 2}
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n] / 6, abs=1e-7)

    def test_P4(self):
        &quot;&quot;&quot;Edge betweenness centrality: P4&quot;&quot;&quot;
        G = nx.path_graph(4)
        b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
        b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_normalized_P4(self):
        &quot;&quot;&quot;Edge betweenness centrality: P4&quot;&quot;&quot;
        G = nx.path_graph(4)
        b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
        b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n] / 6, abs=1e-7)

    def test_balanced_tree(self):
        &quot;&quot;&quot;Edge betweenness centrality: balanced tree&quot;&quot;&quot;
        G = nx.balanced_tree(r=2, h=2)
        b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
        b_answer = {(0, 1): 12, (0, 2): 12, (1, 3): 6, (1, 4): 6, (2, 5): 6, (2, 6): 6}
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)


class TestWeightedEdgeBetweennessCentrality:
    def test_K5(self):
        &quot;&quot;&quot;Edge betweenness centrality: K5&quot;&quot;&quot;
        G = nx.complete_graph(5)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        b_answer = dict.fromkeys(G.edges(), 1)
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_C4(self):
        &quot;&quot;&quot;Edge betweenness centrality: C4&quot;&quot;&quot;
        G = nx.cycle_graph(4)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        b_answer = {(0, 1): 2, (0, 3): 2, (1, 2): 2, (2, 3): 2}
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_P4(self):
        &quot;&quot;&quot;Edge betweenness centrality: P4&quot;&quot;&quot;
        G = nx.path_graph(4)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_balanced_tree(self):
        &quot;&quot;&quot;Edge betweenness centrality: balanced tree&quot;&quot;&quot;
        G = nx.balanced_tree(r=2, h=2)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        b_answer = {(0, 1): 12, (0, 2): 12, (1, 3): 6, (1, 4): 6, (2, 5): 6, (2, 6): 6}
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

<A NAME="4"></A>    def test_weighted_graph(self):
        &quot;&quot;&quot;Edge betweenness centrality: weighted&quot;&quot;&quot;
        eList = [
            <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match2095-1.html#4',3,'match2095-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(0, 1, 5),
            (0, 2, 4),
            (0, 3, 3),
            (0, 4, 2),
            (1, 2, 4),
            (1, 3, 1),
            (1, 4, 3),
            (2, 4, 5),
            (3, 4, 4),
        ]
        G = nx.Graph()
        G.</B></FONT>add_weighted_edges_from(eList)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        b_answer = {
            (0, 1): 0.0,
            (0, 2): 1.0,
            (0, 3): 2.0,
            (0, 4): 1.0,
            (1, 2): 2.0,
            (1, 3): 3.5,
            (1, 4): 1.5,
            (2, 4): 1.0,
            (3, 4): 0.5,
        }
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

<A NAME="5"></A>    def test_normalized_weighted_graph(self):
        &quot;&quot;&quot;Edge betweenness centrality: normalized weighted&quot;&quot;&quot;
        eList = [
            (<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match2095-1.html#5',3,'match2095-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>0, 1, 5),
            (0, 2, 4),
            (0, 3, 3),
            (0, 4, 2),
            (1, 2, 4),
            (1, 3, 1),
            (1, 4, 3),
            (2, 4, 5),
            (3, 4, 4),
        ]
        G = nx.Graph()
        G.</B></FONT>add_weighted_edges_from(eList)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=True)
        b_answer = {
            (0, 1): 0.0,
            (0, 2): 1.0,
            (0, 3): 2.0,
            (0, 4): 1.0,
            (1, 2): 2.0,
            (1, 3): 3.5,
            (1, 4): 1.5,
            (2, 4): 1.0,
            (3, 4): 0.5,
        }
        norm = len(G) * (len(G) - 1) / 2
        for n in sorted(G.edges()):
            assert b[n] == pytest.approx(b_answer[n] / norm, abs=1e-7)

    def test_weighted_multigraph(self):
        &quot;&quot;&quot;Edge betweenness centrality: weighted multigraph&quot;&quot;&quot;
<A NAME="1"></A>        eList = [
            (0, 1, 5),
            (0, 1, 4),
            (<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2095-1.html#1',3,'match2095-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>0, 2, 4),
            (0, 3, 3),
            (0, 3, 3),
            (0, 4, 2),
            (1, 2, 4),
            (1, 3, 1),
            (1, 3, 2),
            (1, 4, 3),
            (1, 4, 4),
            (2, 4, 5),
            (3, 4, 4),
            (3, 4, 4),
        ]
        G = nx.MultiGraph()
        G.</B></FONT>add_weighted_edges_from(eList)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=False)
        b_answer = {
            (0, 1, 0): 0.0,
            (0, 1, 1): 0.5,
            (0, 2, 0): 1.0,
            (0, 3, 0): 0.75,
            (0, 3, 1): 0.75,
            (0, 4, 0): 1.0,
            (1, 2, 0): 2.0,
            (1, 3, 0): 3.0,
            (1, 3, 1): 0.0,
            (1, 4, 0): 1.5,
            (1, 4, 1): 0.0,
            (2, 4, 0): 1.0,
            (3, 4, 0): 0.25,
            (3, 4, 1): 0.25,
        }
        for n in sorted(G.edges(keys=True)):
            assert b[n] == pytest.approx(b_answer[n], abs=1e-7)

    def test_normalized_weighted_multigraph(self):
        &quot;&quot;&quot;Edge betweenness centrality: normalized weighted multigraph&quot;&quot;&quot;
        eList = [
            (0, 1, 5),
            (0, 1, 4),
            (0, 2, 4),
<A NAME="8"></A>            (0, 3, 3),
            (0, 3, 3),
            (0, 4, 2),
            (<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match2095-1.html#8',3,'match2095-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>1, 2, 4),
            (1, 3, 1),
            (1, 3, 2),
            (1, 4, 3),
            (1, 4, 4),
            (2, 4, 5),
            (3, 4, 4),
            (3, 4, 4),
        ]
        G = nx.MultiGraph()
        G.</B></FONT>add_weighted_edges_from(eList)
        b = nx.edge_betweenness_centrality(G, weight=&quot;weight&quot;, normalized=True)
        b_answer = {
            (0, 1, 0): 0.0,
            (0, 1, 1): 0.5,
            (0, 2, 0): 1.0,
            (0, 3, 0): 0.75,
            (0, 3, 1): 0.75,
            (0, 4, 0): 1.0,
            (1, 2, 0): 2.0,
            (1, 3, 0): 3.0,
            (1, 3, 1): 0.0,
            (1, 4, 0): 1.5,
            (1, 4, 1): 0.0,
            (2, 4, 0): 1.0,
            (3, 4, 0): 0.25,
            (3, 4, 1): 0.25,
        }
        norm = len(G) * (len(G) - 1) / 2
        for n in sorted(G.edges(keys=True)):
            assert b[n] == pytest.approx(b_answer[n] / norm, abs=1e-7)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_weighted.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest

import networkx as nx
from networkx.utils import pairwise


def validate_path(G, s, t, soln_len, path, weight=&quot;weight&quot;):
    assert path[0] == s
    assert path[-1] == t

    if callable(weight):
        weight_f = weight
    else:
        if G.is_multigraph():

            def weight_f(u, v, d):
                return min(e.get(weight, 1) for e in d.values())

        else:

            def weight_f(u, v, d):
                return d.get(weight, 1)

    computed = sum(weight_f(u, v, G[u][v]) for u, v in pairwise(path))
    assert soln_len == computed


def validate_length_path(G, s, t, soln_len, length, path, weight=&quot;weight&quot;):
    assert soln_len == length
    validate_path(G, s, t, length, path, weight=weight)


class WeightedTestBase:
    &quot;&quot;&quot;Base class for test classes that test functions for computing
    shortest paths in weighted graphs.

    &quot;&quot;&quot;

    def setup(self):
        &quot;&quot;&quot;Creates some graphs for use in the unit tests.&quot;&quot;&quot;
        cnlti = nx.convert_node_labels_to_integers
        self.grid = cnlti(nx.grid_2d_graph(4, 4), first_label=1, ordering=&quot;sorted&quot;)
        self.cycle = nx.cycle_graph(7)
        self.directed_cycle = nx.cycle_graph(7, create_using=nx.DiGraph())
<A NAME="1"></A>        self.XG = nx.DiGraph()
        self.XG.add_weighted_edges_from(
            [
                <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#1',2,'match2095-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(&quot;s&quot;, &quot;u&quot;, 10),
                (&quot;s&quot;, &quot;x&quot;, 5),
                (&quot;u&quot;, &quot;v&quot;, 1),
                (&quot;u&quot;, &quot;x&quot;, 2),
                (&quot;v&quot;, &quot;y&quot;, 1),
                (&quot;x&quot;, &quot;u&quot;, 3),
                (&quot;x&quot;, &quot;v&quot;, 5),
                (&quot;x&quot;, &quot;y&quot;, 2),
                (&quot;y&quot;, &quot;s&quot;, 7),
                (&quot;y&quot;, &quot;v&quot;, 6),
            ]
        )
        self.MXG = nx.MultiDiGraph(self.</B></FONT>XG)
        self.MXG.add_edge(&quot;s&quot;, &quot;u&quot;, weight=15)
<A NAME="5"></A>        self.XG2 = nx.DiGraph()
        self.XG2.add_weighted_edges_from(
            [
                <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#5',2,'match2095-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[1, 4, 1],
                [4, 5, 1],
                [5, 6, 1],
                [6, 3, 1],
                [1, 3, 50],
                [1, 2, 100],
                [2, 3, 100],
            ]
        )
<A NAME="8"></A>
        self.XG3 = nx.Graph()
        self.</B></FONT>XG3.add_weighted_edges_from(
            [<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#8',2,'match2095-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[0, 1, 2], [1, 2, 12], [2, 3, 1], [3, 4, 5], [4, 5, 1], [5, 0, 10]]
        )

<A NAME="4"></A>        self.XG4 = nx.Graph()
        self.</B></FONT>XG4.add_weighted_edges_from(
            [
                <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#4',2,'match2095-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[0, 1, 2],
                [1, 2, 2],
                [2, 3, 1],
                [3, 4, 1],
                [4, 5, 1],
                [5, 6, 1],
                [6, 7, 1],
                [7, 0, 1],
            ]
        )
        self.MXG4 = nx.MultiGraph(self.</B></FONT>XG4)
        self.MXG4.add_edge(0, 1, weight=3)
        self.G = nx.DiGraph()  # no weights
        self.G.add_edges_from(
            [
                (&quot;s&quot;, &quot;u&quot;),
                (&quot;s&quot;, &quot;x&quot;),
                (&quot;u&quot;, &quot;v&quot;),
                (&quot;u&quot;, &quot;x&quot;),
                (&quot;v&quot;, &quot;y&quot;),
                (&quot;x&quot;, &quot;u&quot;),
                (&quot;x&quot;, &quot;v&quot;),
                (&quot;x&quot;, &quot;y&quot;),
                (&quot;y&quot;, &quot;s&quot;),
                (&quot;y&quot;, &quot;v&quot;),
            ]
        )


class TestWeightedPath(WeightedTestBase):
    def test_dijkstra(self):
        (D, P) = nx.single_source_dijkstra(self.XG, &quot;s&quot;)
        validate_path(self.XG, &quot;s&quot;, &quot;v&quot;, 9, P[&quot;v&quot;])
        assert D[&quot;v&quot;] == 9

        validate_path(
            self.XG, &quot;s&quot;, &quot;v&quot;, 9, nx.single_source_dijkstra_path(self.XG, &quot;s&quot;)[&quot;v&quot;]
        )
        assert dict(nx.single_source_dijkstra_path_length(self.XG, &quot;s&quot;))[&quot;v&quot;] == 9

        validate_path(
            self.XG, &quot;s&quot;, &quot;v&quot;, 9, nx.single_source_dijkstra(self.XG, &quot;s&quot;)[1][&quot;v&quot;]
        )
        validate_path(
            self.MXG, &quot;s&quot;, &quot;v&quot;, 9, nx.single_source_dijkstra_path(self.MXG, &quot;s&quot;)[&quot;v&quot;]
        )

        GG = self.XG.to_undirected()
        # make sure we get lower weight
        # to_undirected might choose either edge with weight 2 or weight 3
        GG[&quot;u&quot;][&quot;x&quot;][&quot;weight&quot;] = 2
        (D, P) = nx.single_source_dijkstra(GG, &quot;s&quot;)
        validate_path(GG, &quot;s&quot;, &quot;v&quot;, 8, P[&quot;v&quot;])
        assert D[&quot;v&quot;] == 8  # uses lower weight of 2 on u&lt;-&gt;x edge
        validate_path(GG, &quot;s&quot;, &quot;v&quot;, 8, nx.dijkstra_path(GG, &quot;s&quot;, &quot;v&quot;))
        assert nx.dijkstra_path_length(GG, &quot;s&quot;, &quot;v&quot;) == 8

        validate_path(self.XG2, 1, 3, 4, nx.dijkstra_path(self.XG2, 1, 3))
        validate_path(self.XG3, 0, 3, 15, nx.dijkstra_path(self.XG3, 0, 3))
        assert nx.dijkstra_path_length(self.XG3, 0, 3) == 15
        validate_path(self.XG4, 0, 2, 4, nx.dijkstra_path(self.XG4, 0, 2))
        assert nx.dijkstra_path_length(self.XG4, 0, 2) == 4
        validate_path(self.MXG4, 0, 2, 4, nx.dijkstra_path(self.MXG4, 0, 2))
        validate_path(
            self.G, &quot;s&quot;, &quot;v&quot;, 2, nx.single_source_dijkstra(self.G, &quot;s&quot;, &quot;v&quot;)[1]
        )
        validate_path(
            self.G, &quot;s&quot;, &quot;v&quot;, 2, nx.single_source_dijkstra(self.G, &quot;s&quot;)[1][&quot;v&quot;]
        )

        validate_path(self.G, &quot;s&quot;, &quot;v&quot;, 2, nx.dijkstra_path(self.G, &quot;s&quot;, &quot;v&quot;))
        assert nx.dijkstra_path_length(self.G, &quot;s&quot;, &quot;v&quot;) == 2

        # NetworkXError: node s not reachable from moon
        pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path, self.G, &quot;s&quot;, &quot;moon&quot;)
        pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path_length, self.G, &quot;s&quot;, &quot;moon&quot;)

        validate_path(self.cycle, 0, 3, 3, nx.dijkstra_path(self.cycle, 0, 3))
        validate_path(self.cycle, 0, 4, 3, nx.dijkstra_path(self.cycle, 0, 4))

        assert nx.single_source_dijkstra(self.cycle, 0, 0) == (0, [0])

    def test_bidirectional_dijkstra(self):
        validate_length_path(
            self.XG, &quot;s&quot;, &quot;v&quot;, 9, *nx.bidirectional_dijkstra(self.XG, &quot;s&quot;, &quot;v&quot;)
        )
        validate_length_path(
            self.G, &quot;s&quot;, &quot;v&quot;, 2, *nx.bidirectional_dijkstra(self.G, &quot;s&quot;, &quot;v&quot;)
        )
        validate_length_path(
            self.cycle, 0, 3, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 3)
        )
        validate_length_path(
            self.cycle, 0, 4, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 4)
        )
        validate_length_path(
            self.XG3, 0, 3, 15, *nx.bidirectional_dijkstra(self.XG3, 0, 3)
        )
        validate_length_path(
            self.XG4, 0, 2, 4, *nx.bidirectional_dijkstra(self.XG4, 0, 2)
        )

        # need more tests here
        P = nx.single_source_dijkstra_path(self.XG, &quot;s&quot;)[&quot;v&quot;]
        validate_path(
            self.XG,
            &quot;s&quot;,
            &quot;v&quot;,
            sum(self.XG[u][v][&quot;weight&quot;] for u, v in zip(P[:-1], P[1:])),
            nx.dijkstra_path(self.XG, &quot;s&quot;, &quot;v&quot;),
        )

        # check absent source
        G = nx.path_graph(2)
        pytest.raises(nx.NodeNotFound, nx.bidirectional_dijkstra, G, 3, 0)

    def test_weight_functions(self):
        def heuristic(*z):
            return sum(val ** 2 for val in z)

        def getpath(pred, v, s):
            return [v] if v == s else getpath(pred, pred[v], s) + [v]

        def goldberg_radzik(g, s, t, weight=&quot;weight&quot;):
            pred, dist = nx.goldberg_radzik(g, s, weight=weight)
            dist = dist[t]
            return dist, getpath(pred, t, s)

        def astar(g, s, t, weight=&quot;weight&quot;):
            path = nx.astar_path(g, s, t, heuristic, weight=weight)
            dist = nx.astar_path_length(g, s, t, heuristic, weight=weight)
            return dist, path

        def vlp(G, s, t, l, F, w):
            res = F(G, s, t, weight=w)
            validate_length_path(G, s, t, l, *res, weight=w)

        G = self.cycle
        s = 6
        t = 4
        path = [6] + list(range(t + 1))

        def weight(u, v, _):
            return 1 + v ** 2

        length = sum(weight(u, v, None) for u, v in pairwise(path))
        vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
        vlp(G, s, t, length, nx.single_source_dijkstra, weight)
        vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
        vlp(G, s, t, length, goldberg_radzik, weight)
        vlp(G, s, t, length, astar, weight)

        def weight(u, v, _):
            return 2 ** (u * v)

        length = sum(weight(u, v, None) for u, v in pairwise(path))
        vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
        vlp(G, s, t, length, nx.single_source_dijkstra, weight)
        vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
        vlp(G, s, t, length, goldberg_radzik, weight)
        vlp(G, s, t, length, astar, weight)

    def test_bidirectional_dijkstra_no_path(self):
        with pytest.raises(nx.NetworkXNoPath):
            G = nx.Graph()
            nx.add_path(G, [1, 2, 3])
            nx.add_path(G, [4, 5, 6])
            path = nx.bidirectional_dijkstra(G, 1, 6)

    @pytest.mark.parametrize(
        &quot;fn&quot;,
        (
            nx.dijkstra_path,
            nx.dijkstra_path_length,
            nx.single_source_dijkstra_path,
            nx.single_source_dijkstra_path_length,
            nx.single_source_dijkstra,
            nx.dijkstra_predecessor_and_distance,
        ),
    )
    def test_absent_source(self, fn):
        G = nx.path_graph(2)
        with pytest.raises(nx.NodeNotFound):
            fn(G, 3, 0)
        # Test when source == target, which is handled specially by some functions
        with pytest.raises(nx.NodeNotFound):
            fn(G, 3, 3)

    def test_dijkstra_predecessor1(self):
        G = nx.path_graph(4)
        assert nx.dijkstra_predecessor_and_distance(G, 0) == (
            {0: [], 1: [0], 2: [1], 3: [2]},
            {0: 0, 1: 1, 2: 2, 3: 3},
        )

    def test_dijkstra_predecessor2(self):
        # 4-cycle
        G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
        pred, dist = nx.dijkstra_predecessor_and_distance(G, (0))
        assert pred[0] == []
<A NAME="0"></A>        assert pred[1] == [0]
        assert pred[2] in [[1, 3], [3, 1]]
        assert pred[3] == [0]
        assert dist == {0<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#0',2,'match2095-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>: 0, 1: 1, 2: 2, 3: 1}

    def test_dijkstra_predecessor3(self):
        XG = nx.DiGraph()
        XG.add_weighted_edges_from(
            [
                (&quot;s&quot;, &quot;u&quot;, 10),
                (&quot;s&quot;, &quot;x&quot;, 5),
                (&quot;u&quot;, &quot;v&quot;, 1),
                (&quot;u&quot;, &quot;x&quot;, 2),
                (&quot;v&quot;, &quot;y&quot;, 1),
                (&quot;x&quot;, &quot;u&quot;, 3),
                (&quot;x&quot;, &quot;v&quot;, 5),
                (&quot;x&quot;, &quot;y&quot;, 2),
                (&quot;y&quot;, &quot;s&quot;, 7),
                (&quot;y&quot;, &quot;v&quot;, 6),
            ]
        )
        (P</B></FONT>, D) = nx.dijkstra_predecessor_and_distance(XG, &quot;s&quot;)
        assert P[&quot;v&quot;] == [&quot;u&quot;]
        assert D[&quot;v&quot;] == 9
        (P, D) = nx.dijkstra_predecessor_and_distance(XG, &quot;s&quot;, cutoff=8)
        assert &quot;v&quot; not in D

    def test_single_source_dijkstra_path_length(self):
        pl = nx.single_source_dijkstra_path_length
        assert dict(pl(self.MXG4, 0))[2] == 4
        spl = pl(self.MXG4, 0, cutoff=2)
        assert 2 not in spl

    def test_bidirectional_dijkstra_multigraph(self):
        G = nx.MultiGraph()
        G.add_edge(&quot;a&quot;, &quot;b&quot;, weight=10)
        G.add_edge(&quot;a&quot;, &quot;b&quot;, weight=100)
        dp = nx.bidirectional_dijkstra(G, &quot;a&quot;, &quot;b&quot;)
        assert dp == (10, [&quot;a&quot;, &quot;b&quot;])

    def test_dijkstra_pred_distance_multigraph(self):
        G = nx.MultiGraph()
        G.add_edge(&quot;a&quot;, &quot;b&quot;, key=&quot;short&quot;, foo=5, weight=100)
        G.add_edge(&quot;a&quot;, &quot;b&quot;, key=&quot;long&quot;, bar=1, weight=110)
        p, d = nx.dijkstra_predecessor_and_distance(G, &quot;a&quot;)
        assert p == {&quot;a&quot;: [], &quot;b&quot;: [&quot;a&quot;]}
        assert d == {&quot;a&quot;: 0, &quot;b&quot;: 100}

    def test_negative_edge_cycle(self):
        G = nx.cycle_graph(5, create_using=nx.DiGraph())
        assert not nx.negative_edge_cycle(G)
        G.add_edge(8, 9, weight=-7)
        G.add_edge(9, 8, weight=3)
        graph_size = len(G)
        assert nx.negative_edge_cycle(G)
        assert graph_size == len(G)
        pytest.raises(ValueError, nx.single_source_dijkstra_path_length, G, 8)
        pytest.raises(ValueError, nx.single_source_dijkstra, G, 8)
        pytest.raises(ValueError, nx.dijkstra_predecessor_and_distance, G, 8)
        G.add_edge(9, 10)
        pytest.raises(ValueError, nx.bidirectional_dijkstra, G, 8, 10)

    def test_negative_edge_cycle_custom_weight_key(self):
        d = nx.DiGraph()
        d.add_edge(&quot;a&quot;, &quot;b&quot;, w=-2)
        d.add_edge(&quot;b&quot;, &quot;a&quot;, w=-1)
        assert nx.negative_edge_cycle(d, weight=&quot;w&quot;)

    def test_weight_function(self):
        &quot;&quot;&quot;Tests that a callable weight is interpreted as a weight
        function instead of an edge attribute.

        &quot;&quot;&quot;
        # Create a triangle in which the edge from node 0 to node 2 has
        # a large weight and the other two edges have a small weight.
        G = nx.complete_graph(3)
        G.adj[0][2][&quot;weight&quot;] = 10
        G.adj[0][1][&quot;weight&quot;] = 1
        G.adj[1][2][&quot;weight&quot;] = 1

        # The weight function will take the multiplicative inverse of
        # the weights on the edges. This way, weights that were large
        # before now become small and vice versa.

        def weight(u, v, d):
            return 1 / d[&quot;weight&quot;]

        # The shortest path from 0 to 2 using the actual weights on the
        # edges should be [0, 1, 2].
        distance, path = nx.single_source_dijkstra(G, 0, 2)
        assert distance == 2
        assert path == [0, 1, 2]
        # However, with the above weight function, the shortest path
        # should be [0, 2], since that has a very small weight.
        distance, path = nx.single_source_dijkstra(G, 0, 2, weight=weight)
        assert distance == 1 / 10
        assert path == [0, 2]

    def test_all_pairs_dijkstra_path(self):
        cycle = nx.cycle_graph(7)
        p = dict(nx.all_pairs_dijkstra_path(cycle))
        assert p[0][3] == [0, 1, 2, 3]

        cycle[1][2][&quot;weight&quot;] = 10
        p = dict(nx.all_pairs_dijkstra_path(cycle))
        assert p[0][3] == [0, 6, 5, 4, 3]

    def test_all_pairs_dijkstra_path_length(self):
        cycle = nx.cycle_graph(7)
        pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
        assert pl[0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}

        cycle[1][2][&quot;weight&quot;] = 10
        pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
        assert pl[0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}

    def test_all_pairs_dijkstra(self):
        cycle = nx.cycle_graph(7)
        out = dict(nx.all_pairs_dijkstra(cycle))
        assert out[0][0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
        assert out[0][1][3] == [0, 1, 2, 3]

        cycle[1][2][&quot;weight&quot;] = 10
        out = dict(nx.all_pairs_dijkstra(cycle))
        assert out[0][0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
        assert out[0][1][3] == [0, 6, 5, 4, 3]


class TestDijkstraPathLength:
    &quot;&quot;&quot;Unit tests for the :func:`networkx.dijkstra_path_length`
    function.

    &quot;&quot;&quot;

    def test_weight_function(self):
        &quot;&quot;&quot;Tests for computing the length of the shortest path using
        Dijkstra's algorithm with a user-defined weight function.

        &quot;&quot;&quot;
        # Create a triangle in which the edge from node 0 to node 2 has
        # a large weight and the other two edges have a small weight.
        G = nx.complete_graph(3)
        G.adj[0][2][&quot;weight&quot;] = 10
        G.adj[0][1][&quot;weight&quot;] = 1
        G.adj[1][2][&quot;weight&quot;] = 1

        # The weight function will take the multiplicative inverse of
        # the weights on the edges. This way, weights that were large
        # before now become small and vice versa.

        def weight(u, v, d):
            return 1 / d[&quot;weight&quot;]

        # The shortest path from 0 to 2 using the actual weights on the
        # edges should be [0, 1, 2]. However, with the above weight
        # function, the shortest path should be [0, 2], since that has a
        # very small weight.
        length = nx.dijkstra_path_length(G, 0, 2, weight=weight)
        assert length == 1 / 10


class TestMultiSourceDijkstra:
    &quot;&quot;&quot;Unit tests for the multi-source dialect of Dijkstra's shortest
    path algorithms.

    &quot;&quot;&quot;

    def test_no_sources(self):
        with pytest.raises(ValueError):
            nx.multi_source_dijkstra(nx.Graph(), {})

    def test_path_no_sources(self):
        with pytest.raises(ValueError):
            nx.multi_source_dijkstra_path(nx.Graph(), {})

    def test_path_length_no_sources(self):
        with pytest.raises(ValueError):
            nx.multi_source_dijkstra_path_length(nx.Graph(), {})

    @pytest.mark.parametrize(
        &quot;fn&quot;,
        (
            nx.multi_source_dijkstra_path,
            nx.multi_source_dijkstra_path_length,
            nx.multi_source_dijkstra,
        ),
    )
    def test_absent_source(self, fn):
        G = nx.path_graph(2)
        with pytest.raises(nx.NodeNotFound):
            fn(G, [3], 0)
        with pytest.raises(nx.NodeNotFound):
            fn(G, [3], 3)

    def test_two_sources(self):
        edges = [(0, 1, 1), (1, 2, 1), (2, 3, 10), (3, 4, 1)]
        G = nx.Graph()
        G.add_weighted_edges_from(edges)
        sources = {0, 4}
        distances, paths = nx.multi_source_dijkstra(G, sources)
        expected_distances = {0: 0, 1: 1, 2: 2, 3: 1, 4: 0}
        expected_paths = {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [4, 3], 4: [4]}
        assert distances == expected_distances
        assert paths == expected_paths

    def test_simple_paths(self):
        G = nx.path_graph(4)
        lengths = nx.multi_source_dijkstra_path_length(G, [0])
        assert lengths == {n: n for n in G}
        paths = nx.multi_source_dijkstra_path(G, [0])
        assert paths == {n: list(range(n + 1)) for n in G}


class TestBellmanFordAndGoldbergRadzik(WeightedTestBase):
    def test_single_node_graph(self):
        G = nx.DiGraph()
        G.add_node(0)
        assert nx.single_source_bellman_ford_path(G, 0) == {0: [0]}
        assert nx.single_source_bellman_ford_path_length(G, 0) == {0: 0}
        assert nx.single_source_bellman_ford(G, 0) == ({0: 0}, {0: [0]})
        assert nx.bellman_ford_predecessor_and_distance(G, 0) == ({0: []}, {0: 0})
        assert nx.goldberg_radzik(G, 0) == ({0: None}, {0: 0})

    def test_absent_source_bellman_ford(self):
        # the check is in _bellman_ford; this provides regression testing
        # against later changes to &quot;client&quot; Bellman-Ford functions
        G = nx.path_graph(2)
        for fn in (
            nx.bellman_ford_predecessor_and_distance,
            nx.bellman_ford_path,
            nx.bellman_ford_path_length,
            nx.single_source_bellman_ford_path,
            nx.single_source_bellman_ford_path_length,
            nx.single_source_bellman_ford,
        ):
            pytest.raises(nx.NodeNotFound, fn, G, 3, 0)
            pytest.raises(nx.NodeNotFound, fn, G, 3, 3)

    def test_absent_source_goldberg_radzik(self):
        with pytest.raises(nx.NodeNotFound):
<A NAME="2"></A>            G = nx.path_graph(2)
            nx.goldberg_radzik(G, 3, 0)

    <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#2',2,'match2095-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>def test_negative_cycle_heuristic(self):
        G = nx.DiGraph()
        G.add_edge(0, 1, weight=-1)
        G.add_edge(1, 2, weight=-1)
        G.add_edge(2, 3, weight=-1)
        G.add_edge(3, 0, weight=</B></FONT>3)
        assert not nx.negative_edge_cycle(G, heuristic=True)
        G.add_edge(2, 0, weight=1.999)
        assert nx.negative_edge_cycle(G, heuristic=True)
        G.edges[2, 0][&quot;weight&quot;] = 2
        assert not nx.negative_edge_cycle(G, heuristic=True)

    def test_negative_cycle_consistency(self):
        import random

        unif = random.uniform
        for random_seed in range(2):  # range(20):
            random.seed(random_seed)
            for density in [0.1, 0.9]:  # .3, .7, .9]:
                for N in [1, 10, 20]:  # range(1, 60 - int(30 * density)):
                    for max_cost in [1, 90]:  # [1, 10, 40, 90]:
                        G = nx.binomial_graph(N, density, seed=4, directed=True)
                        edges = ((u, v, unif(-1, max_cost)) for u, v in G.edges)
                        G.add_weighted_edges_from(edges)

                        no_heuristic = nx.negative_edge_cycle(G, heuristic=False)
                        with_heuristic = nx.negative_edge_cycle(G, heuristic=True)
                        assert no_heuristic == with_heuristic

    def test_negative_cycle(self):
        G = nx.cycle_graph(5, create_using=nx.DiGraph())
        G.add_edge(1, 2, weight=-7)
        for i in range(5):
            pytest.raises(
                nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
            )
            pytest.raises(
                nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
            )
            pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
            pytest.raises(
                nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
            )
            pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
        G = nx.cycle_graph(5)  # undirected Graph
        G.add_edge(1, 2, weight=-3)
        for i in range(5):
            pytest.raises(
                nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
            )
            pytest.raises(
                nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
            )
            pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
            pytest.raises(
                nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
            )
            pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
        G = nx.DiGraph([(1, 1, {&quot;weight&quot;: -1})])
        pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, 1)
        pytest.raises(
            nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, 1
        )
        pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, 1)
        pytest.raises(
            nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, 1
        )
        pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, 1)

    def test_find_negative_cycle_longer_cycle(self):
        G = nx.cycle_graph(5, create_using=nx.DiGraph())
        nx.add_cycle(G, [3, 5, 6, 7, 8, 9])
        G.add_edge(1, 2, weight=-30)
        assert nx.find_negative_cycle(G, 1) == [0, 1, 2, 3, 4, 0]
        assert nx.find_negative_cycle(G, 7) == [2, 3, 4, 0, 1, 2]

    def test_find_negative_cycle_no_cycle(self):
        G = nx.path_graph(5, create_using=nx.DiGraph())
        pytest.raises(nx.NetworkXError, nx.find_negative_cycle, G, 3)

    def test_find_negative_cycle_single_edge(self):
        G = nx.Graph()
        G.add_edge(0, 1, weight=-1)
        assert nx.find_negative_cycle(G, 1) == [1, 0, 1]

    def test_negative_weight(self):
        G = nx.cycle_graph(5, create_using=nx.DiGraph())
        G.add_edge(1, 2, weight=-3)
        assert nx.single_source_bellman_ford_path(G, 0) == {
            0: [0],
            1: [0, 1],
            2: [0, 1, 2],
            3: [0, 1, 2, 3],
            4: [0, 1, 2, 3, 4],
        }
        assert nx.single_source_bellman_ford_path_length(G, 0) == {
            0: 0,
            1: 1,
            2: -2,
            3: -1,
            4: 0,
        }
        assert nx.single_source_bellman_ford(G, 0) == (
            {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
            {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3, 4]},
        )
        assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
            {0: [], 1: [0], 2: [1], 3: [2], 4: [3]},
            {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
        )
        assert nx.goldberg_radzik(G, 0) == (
            {0: None, 1: 0, 2: 1, 3: 2, 4: 3},
            {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
        )

    def test_not_connected(self):
        G = nx.complete_graph(6)
        G.add_edge(10, 11)
        G.add_edge(10, 12)
        assert nx.single_source_bellman_ford_path(G, 0) == {
            0: [0],
            1: [0, 1],
            2: [0, 2],
            3: [0, 3],
            4: [0, 4],
            5: [0, 5],
        }
        assert nx.single_source_bellman_ford_path_length(G, 0) == {
            0: 0,
            1: 1,
            2: 1,
            3: 1,
            4: 1,
            5: 1,
        }
        assert nx.single_source_bellman_ford(G, 0) == (
            {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
            {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
        )
        assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
            {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
            {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
        )
        assert nx.goldberg_radzik(G, 0) == (
            {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
            {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
        )

        # not connected, with a component not containing the source that
        # contains a negative cycle.
        G = nx.complete_graph(6)
        G.add_edges_from(
            [
                (&quot;A&quot;, &quot;B&quot;, {&quot;load&quot;: 3}),
                (&quot;B&quot;, &quot;C&quot;, {&quot;load&quot;: -10}),
                (&quot;C&quot;, &quot;A&quot;, {&quot;load&quot;: 2}),
            ]
        )
        assert nx.single_source_bellman_ford_path(G, 0, weight=&quot;load&quot;) == {
            0: [0],
            1: [0, 1],
            2: [0, 2],
            3: [0, 3],
            4: [0, 4],
            5: [0, 5],
        }
        assert nx.single_source_bellman_ford_path_length(G, 0, weight=&quot;load&quot;) == {
            0: 0,
            1: 1,
            2: 1,
            3: 1,
            4: 1,
            5: 1,
        }
        assert nx.single_source_bellman_ford(G, 0, weight=&quot;load&quot;) == (
            {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
            {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
        )
        assert nx.bellman_ford_predecessor_and_distance(G, 0, weight=&quot;load&quot;) == (
            {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
            {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
        )
        assert nx.goldberg_radzik(G, 0, weight=&quot;load&quot;) == (
            {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
            {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
        )

    def test_multigraph(self):
        assert nx.bellman_ford_path(self.MXG, &quot;s&quot;, &quot;v&quot;) == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
        assert nx.bellman_ford_path_length(self.MXG, &quot;s&quot;, &quot;v&quot;) == 9
        assert nx.single_source_bellman_ford_path(self.MXG, &quot;s&quot;)[&quot;v&quot;] == [
            &quot;s&quot;,
            &quot;x&quot;,
            &quot;u&quot;,
            &quot;v&quot;,
        ]
        assert nx.single_source_bellman_ford_path_length(self.MXG, &quot;s&quot;)[&quot;v&quot;] == 9
        D, P = nx.single_source_bellman_ford(self.MXG, &quot;s&quot;, target=&quot;v&quot;)
        assert D == 9
        assert P == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
        P, D = nx.bellman_ford_predecessor_and_distance(self.MXG, &quot;s&quot;)
        assert P[&quot;v&quot;] == [&quot;u&quot;]
        assert D[&quot;v&quot;] == 9
        P, D = nx.goldberg_radzik(self.MXG, &quot;s&quot;)
        assert P[&quot;v&quot;] == &quot;u&quot;
        assert D[&quot;v&quot;] == 9
        assert nx.bellman_ford_path(self.MXG4, 0, 2) == [0, 1, 2]
        assert nx.bellman_ford_path_length(self.MXG4, 0, 2) == 4
        assert nx.single_source_bellman_ford_path(self.MXG4, 0)[2] == [0, 1, 2]
        assert nx.single_source_bellman_ford_path_length(self.MXG4, 0)[2] == 4
        D, P = nx.single_source_bellman_ford(self.MXG4, 0, target=2)
        assert D == 4
        assert P == [0, 1, 2]
        P, D = nx.bellman_ford_predecessor_and_distance(self.MXG4, 0)
        assert P[2] == [1]
        assert D[2] == 4
        P, D = nx.goldberg_radzik(self.MXG4, 0)
        assert P[2] == 1
        assert D[2] == 4

    def test_others(self):
        assert nx.bellman_ford_path(self.XG, &quot;s&quot;, &quot;v&quot;) == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
        assert nx.bellman_ford_path_length(self.XG, &quot;s&quot;, &quot;v&quot;) == 9
        assert nx.single_source_bellman_ford_path(self.XG, &quot;s&quot;)[&quot;v&quot;] == [
            &quot;s&quot;,
            &quot;x&quot;,
            &quot;u&quot;,
            &quot;v&quot;,
        ]
        assert nx.single_source_bellman_ford_path_length(self.XG, &quot;s&quot;)[&quot;v&quot;] == 9
        D, P = nx.single_source_bellman_ford(self.XG, &quot;s&quot;, target=&quot;v&quot;)
        assert D == 9
        assert P == [&quot;s&quot;, &quot;x&quot;, &quot;u&quot;, &quot;v&quot;]
        (P, D) = nx.bellman_ford_predecessor_and_distance(self.XG, &quot;s&quot;)
        assert P[&quot;v&quot;] == [&quot;u&quot;]
        assert D[&quot;v&quot;] == 9
        (P, D) = nx.goldberg_radzik(self.XG, &quot;s&quot;)
        assert P[&quot;v&quot;] == &quot;u&quot;
        assert D[&quot;v&quot;] == 9

    def test_path_graph(self):
        G = nx.path_graph(4)
        assert nx.single_source_bellman_ford_path(G, 0) == {
            0: [0],
            1: [0, 1],
            2: [0, 1, 2],
            3: [0, 1, 2, 3],
        }
        assert nx.single_source_bellman_ford_path_length(G, 0) == {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
        }
        assert nx.single_source_bellman_ford(G, 0) == (
            {0: 0, 1: 1, 2: 2, 3: 3},
            {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3]},
        )
        assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
            {0: [], 1: [0], 2: [1], 3: [2]},
            {0: 0, 1: 1, 2: 2, 3: 3},
        )
        assert nx.goldberg_radzik(G, 0) == (
            {0: None, 1: 0, 2: 1, 3: 2},
            {0: 0, 1: 1, 2: 2, 3: 3},
        )
        assert nx.single_source_bellman_ford_path(G, 3) == {
            0: [3, 2, 1, 0],
            1: [3, 2, 1],
            2: [3, 2],
            3: [3],
        }
        assert nx.single_source_bellman_ford_path_length(G, 3) == {
            0: 3,
            1: 2,
            2: 1,
            3: 0,
        }
        assert nx.single_source_bellman_ford(G, 3) == (
            {0: 3, 1: 2, 2: 1, 3: 0},
            {0: [3, 2, 1, 0], 1: [3, 2, 1], 2: [3, 2], 3: [3]},
        )
        assert nx.bellman_ford_predecessor_and_distance(G, 3) == (
            {0: [1], 1: [2], 2: [3], 3: []},
            {0: 3, 1: 2, 2: 1, 3: 0},
        )
        assert nx.goldberg_radzik(G, 3) == (
            {0: 1, 1: 2, 2: 3, 3: None},
            {0: 3, 1: 2, 2: 1, 3: 0},
        )

    def test_4_cycle(self):
        # 4-cycle
        G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
        dist, path = nx.single_source_bellman_ford(G, 0)
        assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
        assert path[0] == [0]
        assert path[1] == [0, 1]
        assert path[2] in [[0, 1, 2], [0, 3, 2]]
        assert path[3] == [0, 3]

        pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)
        assert pred[0] == []
        assert pred[1] == [0]
        assert pred[2] in [[1, 3], [3, 1]]
        assert pred[3] == [0]
        assert dist == {0: 0, 1: 1, 2: 2, 3: 1}

        pred, dist = nx.goldberg_radzik(G, 0)
        assert pred[0] is None
        assert pred[1] == 0
        assert pred[2] in [1, 3]
        assert pred[3] == 0
        assert dist == {0: 0, 1: 1, 2: 2, 3: 1}

<A NAME="9"></A>    def test_negative_weight_bf_path(self):
        G = nx.DiGraph()
        G.add_nodes_from(&quot;abcd&quot;)
        G<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#9',2,'match2095-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.add_edge(&quot;a&quot;, &quot;d&quot;, weight=0)
        G.add_edge(&quot;a&quot;, &quot;b&quot;, weight=1)
        G.add_edge(&quot;b&quot;, &quot;c&quot;, weight=-3)
<A NAME="7"></A>        G.add_edge(&quot;c&quot;, &quot;d&quot;, weight=</B></FONT>1)

        assert nx.bellman_ford_path(G, &quot;a&quot;, &quot;d&quot;) == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
        assert nx.bellman_ford_path_length(<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#7',2,'match2095-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>G, &quot;a&quot;, &quot;d&quot;) == -1

    def test_zero_cycle_smoke(self):
        D = nx.DiGraph()
        D.add_weighted_edges_from([(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 1, -2)])

        nx.</B></FONT>bellman_ford_path(D, 1, 3)
        nx.dijkstra_path(D, 1, 3)
        nx.bidirectional_dijkstra(D, 1, 3)
        # FIXME nx.goldberg_radzik(D, 1)


class TestJohnsonAlgorithm(WeightedTestBase):
    def test_single_node_graph(self):
<A NAME="3"></A>        with pytest.raises(nx.NetworkXError):
            G = nx.DiGraph()
            G.add_node(0)
            nx.johnson(G<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#3',2,'match2095-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>)

    def test_negative_cycle(self):
        G = nx.DiGraph()
        G.add_weighted_edges_from(
            [
                (&quot;0&quot;, &quot;3&quot;, 3),
                (&quot;0&quot;, &quot;1&quot;, -5),
                (&quot;1&quot;, &quot;0&quot;, -5),
                (&quot;0&quot;, &quot;2&quot;, 2),
                (&quot;1&quot;, &quot;2&quot;, 4),
                (&quot;2&quot;, &quot;3&quot;, 1),
            ]
        )
        pytest.</B></FONT>raises(nx.NetworkXUnbounded, nx.johnson, G)
        G = nx.Graph()
        G.add_weighted_edges_from(
            [
                (&quot;0&quot;, &quot;3&quot;, 3),
                (&quot;0&quot;, &quot;1&quot;, -5),
                (&quot;1&quot;, &quot;0&quot;, -5),
                (&quot;0&quot;, &quot;2&quot;, 2),
                (&quot;1&quot;, &quot;2&quot;, 4),
<A NAME="6"></A>                (&quot;2&quot;, &quot;3&quot;, 1),
            ]
        )
        pytest.raises(nx.NetworkXUnbounded, nx.<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2095-0.html#6',2,'match2095-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>johnson, G)

    def test_negative_weights(self):
        G = nx.DiGraph()
        G.add_weighted_edges_from(
            [(&quot;0&quot;, &quot;3&quot;, 3), (&quot;0&quot;, &quot;1&quot;, -5), (&quot;0&quot;, &quot;2&quot;, 2), (&quot;1&quot;, &quot;2&quot;, 4), (&quot;2&quot;</B></FONT>, &quot;3&quot;, 1)]
        )
        paths = nx.johnson(G)
        assert paths == {
            &quot;1&quot;: {&quot;1&quot;: [&quot;1&quot;], &quot;3&quot;: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], &quot;2&quot;: [&quot;1&quot;, &quot;2&quot;]},
            &quot;0&quot;: {
                &quot;1&quot;: [&quot;0&quot;, &quot;1&quot;],
                &quot;0&quot;: [&quot;0&quot;],
                &quot;3&quot;: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;],
                &quot;2&quot;: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;],
            },
            &quot;3&quot;: {&quot;3&quot;: [&quot;3&quot;]},
            &quot;2&quot;: {&quot;3&quot;: [&quot;2&quot;, &quot;3&quot;], &quot;2&quot;: [&quot;2&quot;]},
        }

    def test_unweighted_graph(self):
        with pytest.raises(nx.NetworkXError):
            G = nx.path_graph(5)
            nx.johnson(G)

    def test_graphs(self):
        validate_path(self.XG, &quot;s&quot;, &quot;v&quot;, 9, nx.johnson(self.XG)[&quot;s&quot;][&quot;v&quot;])
        validate_path(self.MXG, &quot;s&quot;, &quot;v&quot;, 9, nx.johnson(self.MXG)[&quot;s&quot;][&quot;v&quot;])
        validate_path(self.XG2, 1, 3, 4, nx.johnson(self.XG2)[1][3])
        validate_path(self.XG3, 0, 3, 15, nx.johnson(self.XG3)[0][3])
        validate_path(self.XG4, 0, 2, 4, nx.johnson(self.XG4)[0][2])
        validate_path(self.MXG4, 0, 2, 4, nx.johnson(self.MXG4)[0][2])
</PRE>
</div>
  </div>
</body>
</html>
