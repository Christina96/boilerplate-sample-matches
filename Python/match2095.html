<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_betweenness_centrality.py &amp; test_weighted.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_betweenness_centrality.py &amp; test_weighted.py
      </h3>
<h1 align="center">
        9.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_betweenness_centrality.py (11.3672495%)<th>test_weighted.py (8.069978%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(525-542)<td><a href="#" name="0">(286-304)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(705-719)<td><a href="#" name="1">(48-60)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(5-10)<td><a href="#" name="2">(526-531)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(235-240)<td><a href="#" name="3">(867-881)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(642-653)<td><a href="#" name="4">(83-93)</a><td align="center"><font color="#bb0000">14</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(672-683)<td><a href="#" name="5">(65-76)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(491-502)<td><a href="#" name="6">(893-898)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(472-477)<td><a href="#" name="7">(850-856)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(749-759)<td><a href="#" name="8">(77-81)</a><td align="center"><font color="#a10000">12</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(11-14)<td><a href="#" name="9">(844-847)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_betweenness_centrality.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 <a name="2"></a>import networkx as nx
3 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>def weighted_G():
4     G = nx.Graph()
5     G.add_edge(0, 1, weight=3)
6 <a name="9"></a>    G.add_edge(0, 2, weight=2)
7     G.add_edge(0, 3, weight=6)
8     G.add_edge(0, 4, weight=</b></font>4)
9     G<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_edge(1, 3, weight=5)
10     G.add_edge(1, 5, weight=5)
11     G.add_edge(2, 4, weight=1)
12     G.add_edge(3, 4, weight=</b></font>2)
13     G.add_edge(3, 5, weight=1)
14     G.add_edge(4, 5, weight=4)
15     return G
16 class TestBetweennessCentrality:
17     def test_K5(self):
18         G = nx.complete_graph(5)
19         b = nx.betweenness_centrality(G, weight=None, normalized=False)
20         b_answer = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.0}
21         for n in sorted(G):
22             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
23     def test_K5_endpoints(self):
24         G = nx.complete_graph(5)
25         b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
26         b_answer = {0: 4.0, 1: 4.0, 2: 4.0, 3: 4.0, 4: 4.0}
27         for n in sorted(G):
28             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
29         b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
30         b_answer = {0: 0.4, 1: 0.4, 2: 0.4, 3: 0.4, 4: 0.4}
31         for n in sorted(G):
32             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
33     def test_P3_normalized(self):
34         G = nx.path_graph(3)
35         b = nx.betweenness_centrality(G, weight=None, normalized=True)
36         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
37         for n in sorted(G):
38             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
39     def test_P3(self):
40         G = nx.path_graph(3)
41         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
42         b = nx.betweenness_centrality(G, weight=None, normalized=False)
43         for n in sorted(G):
44             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
45     def test_sample_from_P3(self):
46         G = nx.path_graph(3)
47         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
48         b = nx.betweenness_centrality(G, k=3, weight=None, normalized=False, seed=1)
49         for n in sorted(G):
50             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
51         b = nx.betweenness_centrality(G, k=2, weight=None, normalized=False, seed=1)
52         b_approx1 = {0: 0.0, 1: 1.5, 2: 0.0}
53         b_approx2 = {0: 0.0, 1: 0.75, 2: 0.0}
54         for n in sorted(G):
55             assert b[n] in (b_approx1[n], b_approx2[n])
56     def test_P3_endpoints(self):
57         G = nx.path_graph(3)
58         b_answer = {0: 2.0, 1: 3.0, 2: 2.0}
59         b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
60         for n in sorted(G):
61             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
62         b_answer = {0: 2 / 3, 1: 1.0, 2: 2 / 3}
63         b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
64         for n in sorted(G):
65             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
66     def test_krackhardt_kite_graph(self):
67         G = nx.krackhardt_kite_graph()
68         b_answer = {
69             0: 1.667,
70             1: 1.667,
71             2: 0.000,
72             3: 7.333,
73             4: 0.000,
74             5: 16.667,
75             6: 16.667,
76             7: 28.000,
77             8: 16.000,
78             9: 0.000,
79         }
80         for b in b_answer:
81             b_answer[b] /= 2
82         b = nx.betweenness_centrality(G, weight=None, normalized=False)
83         for n in sorted(G):
84             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
85     def test_krackhardt_kite_graph_normalized(self):
86         G = nx.krackhardt_kite_graph()
87         b_answer = {
88             0: 0.023,
89             1: 0.023,
90             2: 0.000,
91             3: 0.102,
92             4: 0.000,
93             5: 0.231,
94             6: 0.231,
95             7: 0.389,
96             8: 0.222,
97             9: 0.000,
98         }
99         b = nx.betweenness_centrality(G, weight=None, normalized=True)
100         for n in sorted(G):
101             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
102     def test_florentine_families_graph(self):
103         G = nx.florentine_families_graph()
104         b_answer = {
105             "Acciaiuoli": 0.000,
106             "Albizzi": 0.212,
107             "Barbadori": 0.093,
108             "Bischeri": 0.104,
109             "Castellani": 0.055,
110             "Ginori": 0.000,
111             "Guadagni": 0.255,
112             "Lamberteschi": 0.000,
113             "Medici": 0.522,
114             "Pazzi": 0.000,
115             "Peruzzi": 0.022,
116             "Ridolfi": 0.114,
117             "Salviati": 0.143,
118             "Strozzi": 0.103,
119             "Tornabuoni": 0.092,
120         }
121         b = nx.betweenness_centrality(G, weight=None, normalized=True)
122         for n in sorted(G):
123             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
124     def test_les_miserables_graph(self):
125         G = nx.les_miserables_graph()
126         b_answer = {
127             "Napoleon": 0.000,
128             "Myriel": 0.177,
129             "MlleBaptistine": 0.000,
130             "MmeMagloire": 0.000,
131             "CountessDeLo": 0.000,
132             "Geborand": 0.000,
133             "Champtercier": 0.000,
134             "Cravatte": 0.000,
135             "Count": 0.000,
136             "OldMan": 0.000,
137             "Valjean": 0.570,
138             "Labarre": 0.000,
139             "Marguerite": 0.000,
140             "MmeDeR": 0.000,
141             "Isabeau": 0.000,
142             "Gervais": 0.000,
143             "Listolier": 0.000,
144             "Tholomyes": 0.041,
145             "Fameuil": 0.000,
146             "Blacheville": 0.000,
147             "Favourite": 0.000,
148             "Dahlia": 0.000,
149             "Zephine": 0.000,
150             "Fantine": 0.130,
151             "MmeThenardier": 0.029,
152             "Thenardier": 0.075,
153             "Cosette": 0.024,
154             "Javert": 0.054,
155             "Fauchelevent": 0.026,
156             "Bamatabois": 0.008,
157             "Perpetue": 0.000,
158             "Simplice": 0.009,
159             "Scaufflaire": 0.000,
160             "Woman1": 0.000,
161             "Judge": 0.000,
162             "Champmathieu": 0.000,
163             "Brevet": 0.000,
164             "Chenildieu": 0.000,
165             "Cochepaille": 0.000,
166             "Pontmercy": 0.007,
167             "Boulatruelle": 0.000,
168             "Eponine": 0.011,
169             "Anzelma": 0.000,
170             "Woman2": 0.000,
171             "MotherInnocent": 0.000,
172             "Gribier": 0.000,
173             "MmeBurgon": 0.026,
174             "Jondrette": 0.000,
175             "Gavroche": 0.165,
176             "Gillenormand": 0.020,
177             "Magnon": 0.000,
178             "MlleGillenormand": 0.048,
179             "MmePontmercy": 0.000,
180             "MlleVaubois": 0.000,
181             "LtGillenormand": 0.000,
182             "Marius": 0.132,
183             "BaronessT": 0.000,
184             "Mabeuf": 0.028,
185             "Enjolras": 0.043,
186             "Combeferre": 0.001,
187             "Prouvaire": 0.000,
188             "Feuilly": 0.001,
189             "Courfeyrac": 0.005,
190             "Bahorel": 0.002,
191             "Bossuet": 0.031,
192             "Joly": 0.002,
193             "Grantaire": 0.000,
194             "MotherPlutarch": 0.000,
195             "Gueulemer": 0.005,
196             "Babet": 0.005,
197             "Claquesous": 0.005,
198             "Montparnasse": 0.004,
199             "Toussaint": 0.000,
200             "Child1": 0.000,
201             "Child2": 0.000,
202             "Brujon": 0.000,
203             "MmeHucheloup": 0.000,
204         }
205 <a name="3"></a>
206         b = nx.betweenness_centrality(G, weight=None, normalized=True)
207         for n in sorted(G):
208             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-3)
209     def test_ladder_graph(self):
210         G = nx.Graph()  # ladder_graph(3)
211         G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3), (2, 4), (4, 5), (3</b></font>, 5)])
212         b_answer = {0: 1.667, 1: 1.667, 2: 6.667, 3: 6.667, 4: 1.667, 5: 1.667}
213         for b in b_answer:
214             b_answer[b] /= 2
215         b = nx.betweenness_centrality(G, weight=None, normalized=False)
216         for n in sorted(G):
217             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
218     def test_disconnected_path(self):
219         G = nx.Graph()
220         nx.add_path(G, [0, 1, 2])
221         nx.add_path(G, [3, 4, 5, 6])
222         b_answer = {0: 0, 1: 1, 2: 0, 3: 0, 4: 2, 5: 2, 6: 0}
223         b = nx.betweenness_centrality(G, weight=None, normalized=False)
224         for n in sorted(G):
225             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
226     def test_disconnected_path_endpoints(self):
227         G = nx.Graph()
228         nx.add_path(G, [0, 1, 2])
229         nx.add_path(G, [3, 4, 5, 6])
230         b_answer = {0: 2, 1: 3, 2: 2, 3: 3, 4: 5, 5: 5, 6: 3}
231         b = nx.betweenness_centrality(G, weight=None, normalized=False, endpoints=True)
232         for n in sorted(G):
233             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
234         b = nx.betweenness_centrality(G, weight=None, normalized=True, endpoints=True)
235         for n in sorted(G):
236             assert b[n] == pytest.approx(b_answer[n] / 21, abs=1e-7)
237     def test_directed_path(self):
238         G = nx.DiGraph()
239         nx.add_path(G, [0, 1, 2])
240         b = nx.betweenness_centrality(G, weight=None, normalized=False)
241         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
242         for n in sorted(G):
243             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
244     def test_directed_path_normalized(self):
245         G = nx.DiGraph()
246         nx.add_path(G, [0, 1, 2])
247         b = nx.betweenness_centrality(G, weight=None, normalized=True)
248         b_answer = {0: 0.0, 1: 0.5, 2: 0.0}
249         for n in sorted(G):
250             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
251 class TestWeightedBetweennessCentrality:
252     def test_K5(self):
253         G = nx.complete_graph(5)
254         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
255         b_answer = {0: 0.0, 1: 0.0, 2: 0.0, 3: 0.0, 4: 0.0}
256         for n in sorted(G):
257             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
258     def test_P3_normalized(self):
259         G = nx.path_graph(3)
260         b = nx.betweenness_centrality(G, weight="weight", normalized=True)
261         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
262         for n in sorted(G):
263             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
264     def test_P3(self):
265         G = nx.path_graph(3)
266         b_answer = {0: 0.0, 1: 1.0, 2: 0.0}
267         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
268         for n in sorted(G):
269             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
270     def test_krackhardt_kite_graph(self):
271         G = nx.krackhardt_kite_graph()
272         b_answer = {
273             0: 1.667,
274             1: 1.667,
275             2: 0.000,
276             3: 7.333,
277             4: 0.000,
278             5: 16.667,
279             6: 16.667,
280             7: 28.000,
281             8: 16.000,
282             9: 0.000,
283         }
284         for b in b_answer:
285             b_answer[b] /= 2
286         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
287         for n in sorted(G):
288             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
289     def test_krackhardt_kite_graph_normalized(self):
290         G = nx.krackhardt_kite_graph()
291         b_answer = {
292             0: 0.023,
293             1: 0.023,
294             2: 0.000,
295             3: 0.102,
296             4: 0.000,
297             5: 0.231,
298             6: 0.231,
299             7: 0.389,
300             8: 0.222,
301             9: 0.000,
302         }
303         b = nx.betweenness_centrality(G, weight="weight", normalized=True)
304         for n in sorted(G):
305             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
306     def test_florentine_families_graph(self):
307             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-3)
308     def test_ladder_graph(self):
309         G = nx.Graph()  # ladder_graph(3)
310         G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3), (2</b></font>, 4), (4, 5), (3, 5)])
311         b_answer = {0: 1.667, 1: 1.667, 2: 6.667, 3: 6.667, 4: 1.667, 5: 1.667}
312         for b in b_answer:
313             b_answer[b] /= 2
314         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
315         for n in sorted(G):
316             assert b[n] == pytest.approx(b_answer[n], abs=1e-3)
317     def test_G(self):
318         G = weighted_G()
319 <a name="6"></a>        b_answer = {0: 2.0, 1: 0.0, 2: 4.0, 3: 3.0, 4: 4.0, 5: 0.0}
320         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
321         for n in sorted(G):
322             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-7)
323     def test_G2(self):
324         G = nx.DiGraph()
325         G.add_weighted_edges_from(
326             [
327                 ("s", "u", 10),
328                 ("s", "x", 5),
329                 ("u", "v", 1),
330                 ("u", "x", 2),
331                 ("v"</b></font>, "y", 1),
332                 ("x", "u", 3),
333                 ("x", "v", 5),
334                 ("x", "y", 2),
335                 ("y", "s", 7),
336                 ("y", "v", 6),
337             ]
338         )
339         b_answer = {"y": 5.0, "x": 5.0, "s": 4.0, "u": 2.0, "v": 2.0}
340         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
341         for n in sorted(G):
342             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
343     def test_G3(self):
344         G = nx.MultiGraph(weighted_G())
345         es = list(G.edges(data=True))[::2]  # duplicate every other edge
346         G.add_edges_from(es)
347 <a name="0"></a>        b_answer = {0: 2.0, 1: 0.0, 2: 4.0, 3: 3.0, 4: 4.0, 5: 0.0}
348         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
349         for n in sorted(G):
350             assert b[n] == pytest.approx(b_answer[n], abs=1<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>e-7)
351     def test_G4(self):
352         G = nx.MultiDiGraph()
353         G.add_weighted_edges_from(
354             [
355                 ("s", "u", 10),
356                 ("s", "x", 5),
357                 ("s", "x", 6),
358                 ("u", "v", 1),
359                 ("u", "x", 2),
360                 ("v", "y", 1),
361                 ("v", "y", 1),
362                 ("x", "u", 3),
363                 ("x", "v", 5),
364                 ("x", "y", 2),
365                 ("x"</b></font>, "y", 3),
366                 ("y", "s", 7),
367                 ("y", "v", 6),
368                 ("y", "v", 6),
369             ]
370         )
371         b_answer = {"y": 5.0, "x": 5.0, "s": 4.0, "u": 2.0, "v": 2.0}
372         b = nx.betweenness_centrality(G, weight="weight", normalized=False)
373         for n in sorted(G):
374             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
375 class TestEdgeBetweennessCentrality:
376     def test_K5(self):
377         G = nx.complete_graph(5)
378         b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
379         b_answer = dict.fromkeys(G.edges(), 1)
380         for n in sorted(G.edges()):
381             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
382     def test_normalized_K5(self):
383         G = nx.complete_graph(5)
384         b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
385         b_answer = dict.fromkeys(G.edges(), 1 / 10)
386         for n in sorted(G.edges()):
387             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
388     def test_C4(self):
389         G = nx.cycle_graph(4)
390         b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
391         b_answer = {(0, 1): 2, (0, 3): 2, (1, 2): 2, (2, 3): 2}
392         for n in sorted(G.edges()):
393             assert b[n] == pytest.approx(b_answer[n] / 6, abs=1e-7)
394     def test_P4(self):
395         G = nx.path_graph(4)
396         b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
397         b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
398         for n in sorted(G.edges()):
399             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
400     def test_normalized_P4(self):
401         G = nx.path_graph(4)
402         b = nx.edge_betweenness_centrality(G, weight=None, normalized=True)
403         b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
404         for n in sorted(G.edges()):
405             assert b[n] == pytest.approx(b_answer[n] / 6, abs=1e-7)
406     def test_balanced_tree(self):
407         G = nx.balanced_tree(r=2, h=2)
408         b = nx.edge_betweenness_centrality(G, weight=None, normalized=False)
409         b_answer = {(0, 1): 12, (0, 2): 12, (1, 3): 6, (1, 4): 6, (2, 5): 6, (2, 6): 6}
410         for n in sorted(G.edges()):
411             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
412 class TestWeightedEdgeBetweennessCentrality:
413     def test_K5(self):
414         G = nx.complete_graph(5)
415         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
416         b_answer = dict.fromkeys(G.edges(), 1)
417         for n in sorted(G.edges()):
418             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
419     def test_C4(self):
420         G = nx.cycle_graph(4)
421         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
422         b_answer = {(0, 1): 2, (0, 3): 2, (1, 2): 2, (2, 3): 2}
423         for n in sorted(G.edges()):
424             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
425     def test_P4(self):
426         G = nx.path_graph(4)
427         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
428         b_answer = {(0, 1): 3, (1, 2): 4, (2, 3): 3}
429         for n in sorted(G.edges()):
430             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
431     def test_balanced_tree(self):
432         G = nx.balanced_tree(r=2, h=2)
433         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
434         b_answer = {(0, 1): 12, (0, 2): 12, (1, 3): 6, (1, 4): 6, (2, 5): 6, (2, 6): 6}
435         for n in sorted(G.edges()):
436             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
437 <a name="4"></a>    def test_weighted_graph(self):
438         eList = [
439             <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(0, 1, 5),
440             (0, 2, 4),
441             (0, 3, 3),
442             (0, 4, 2),
443             (1, 2, 4),
444             (1, 3, 1),
445             (1, 4, 3),
446             (2, 4, 5),
447             (3, 4, 4),
448         ]
449         G = nx.Graph()
450         G.</b></font>add_weighted_edges_from(eList)
451         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
452         b_answer = {
453             (0, 1): 0.0,
454             (0, 2): 1.0,
455             (0, 3): 2.0,
456             (0, 4): 1.0,
457             (1, 2): 2.0,
458             (1, 3): 3.5,
459             (1, 4): 1.5,
460             (2, 4): 1.0,
461             (3, 4): 0.5,
462         }
463         for n in sorted(G.edges()):
464             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
465 <a name="5"></a>    def test_normalized_weighted_graph(self):
466         eList = [
467             (<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 1, 5),
468             (0, 2, 4),
469             (0, 3, 3),
470             (0, 4, 2),
471             (1, 2, 4),
472             (1, 3, 1),
473             (1, 4, 3),
474             (2, 4, 5),
475             (3, 4, 4),
476         ]
477         G = nx.Graph()
478         G.</b></font>add_weighted_edges_from(eList)
479         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=True)
480         b_answer = {
481             (0, 1): 0.0,
482             (0, 2): 1.0,
483             (0, 3): 2.0,
484             (0, 4): 1.0,
485             (1, 2): 2.0,
486             (1, 3): 3.5,
487             (1, 4): 1.5,
488             (2, 4): 1.0,
489             (3, 4): 0.5,
490         }
491         norm = len(G) * (len(G) - 1) / 2
492         for n in sorted(G.edges()):
493             assert b[n] == pytest.approx(b_answer[n] / norm, abs=1e-7)
494     def test_weighted_multigraph(self):
495 <a name="1"></a>        eList = [
496             (0, 1, 5),
497             (0, 1, 4),
498             (<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>0, 2, 4),
499             (0, 3, 3),
500             (0, 3, 3),
501             (0, 4, 2),
502             (1, 2, 4),
503             (1, 3, 1),
504             (1, 3, 2),
505             (1, 4, 3),
506             (1, 4, 4),
507             (2, 4, 5),
508             (3, 4, 4),
509             (3, 4, 4),
510         ]
511         G = nx.MultiGraph()
512         G.</b></font>add_weighted_edges_from(eList)
513         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=False)
514         b_answer = {
515             (0, 1, 0): 0.0,
516             (0, 1, 1): 0.5,
517             (0, 2, 0): 1.0,
518             (0, 3, 0): 0.75,
519             (0, 3, 1): 0.75,
520             (0, 4, 0): 1.0,
521             (1, 2, 0): 2.0,
522             (1, 3, 0): 3.0,
523             (1, 3, 1): 0.0,
524             (1, 4, 0): 1.5,
525             (1, 4, 1): 0.0,
526             (2, 4, 0): 1.0,
527             (3, 4, 0): 0.25,
528             (3, 4, 1): 0.25,
529         }
530         for n in sorted(G.edges(keys=True)):
531             assert b[n] == pytest.approx(b_answer[n], abs=1e-7)
532     def test_normalized_weighted_multigraph(self):
533         eList = [
534             (0, 1, 5),
535             (0, 1, 4),
536             (0, 2, 4),
537 <a name="8"></a>            (0, 3, 3),
538             (0, 3, 3),
539             (0, 4, 2),
540             (<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>1, 2, 4),
541             (1, 3, 1),
542             (1, 3, 2),
543             (1, 4, 3),
544             (1, 4, 4),
545             (2, 4, 5),
546             (3, 4, 4),
547             (3, 4, 4),
548         ]
549         G = nx.MultiGraph()
550         G.</b></font>add_weighted_edges_from(eList)
551         b = nx.edge_betweenness_centrality(G, weight="weight", normalized=True)
552         b_answer = {
553             (0, 1, 0): 0.0,
554             (0, 1, 1): 0.5,
555             (0, 2, 0): 1.0,
556             (0, 3, 0): 0.75,
557             (0, 3, 1): 0.75,
558             (0, 4, 0): 1.0,
559             (1, 2, 0): 2.0,
560             (1, 3, 0): 3.0,
561             (1, 3, 1): 0.0,
562             (1, 4, 0): 1.5,
563             (1, 4, 1): 0.0,
564             (2, 4, 0): 1.0,
565             (3, 4, 0): 0.25,
566             (3, 4, 1): 0.25,
567         }
568         norm = len(G) * (len(G) - 1) / 2
569         for n in sorted(G.edges(keys=True)):
570             assert b[n] == pytest.approx(b_answer[n] / norm, abs=1e-7)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_weighted.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 from networkx.utils import pairwise
4 def validate_path(G, s, t, soln_len, path, weight="weight"):
5     assert path[0] == s
6     assert path[-1] == t
7     if callable(weight):
8         weight_f = weight
9     else:
10         if G.is_multigraph():
11             def weight_f(u, v, d):
12                 return min(e.get(weight, 1) for e in d.values())
13         else:
14             def weight_f(u, v, d):
15                 return d.get(weight, 1)
16     computed = sum(weight_f(u, v, G[u][v]) for u, v in pairwise(path))
17     assert soln_len == computed
18 def validate_length_path(G, s, t, soln_len, length, path, weight="weight"):
19     assert soln_len == length
20     validate_path(G, s, t, length, path, weight=weight)
21 class WeightedTestBase:
22     def setup(self):
23         cnlti = nx.convert_node_labels_to_integers
24         self.grid = cnlti(nx.grid_2d_graph(4, 4), first_label=1, ordering="sorted")
25         self.cycle = nx.cycle_graph(7)
26         self.directed_cycle = nx.cycle_graph(7, create_using=nx.DiGraph())
27 <a name="1"></a>        self.XG = nx.DiGraph()
28         self.XG.add_weighted_edges_from(
29             [
30                 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("s", "u", 10),
31                 ("s", "x", 5),
32                 ("u", "v", 1),
33                 ("u", "x", 2),
34                 ("v", "y", 1),
35                 ("x", "u", 3),
36                 ("x", "v", 5),
37                 ("x", "y", 2),
38                 ("y", "s", 7),
39                 ("y", "v", 6),
40             ]
41         )
42         self.MXG = nx.MultiDiGraph(self.</b></font>XG)
43         self.MXG.add_edge("s", "u", weight=15)
44 <a name="5"></a>        self.XG2 = nx.DiGraph()
45         self.XG2.add_weighted_edges_from(
46             [
47                 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[1, 4, 1],
48                 [4, 5, 1],
49                 [5, 6, 1],
50                 [6, 3, 1],
51                 [1, 3, 50],
52                 [1, 2, 100],
53                 [2, 3, 100],
54             ]
55         )
56 <a name="8"></a>
57         self.XG3 = nx.Graph()
58         self.</b></font>XG3.add_weighted_edges_from(
59             [<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0, 1, 2], [1, 2, 12], [2, 3, 1], [3, 4, 5], [4, 5, 1], [5, 0, 10]]
60         )
61 <a name="4"></a>        self.XG4 = nx.Graph()
62         self.</b></font>XG4.add_weighted_edges_from(
63             [
64                 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>[0, 1, 2],
65                 [1, 2, 2],
66                 [2, 3, 1],
67                 [3, 4, 1],
68                 [4, 5, 1],
69                 [5, 6, 1],
70                 [6, 7, 1],
71                 [7, 0, 1],
72             ]
73         )
74         self.MXG4 = nx.MultiGraph(self.</b></font>XG4)
75         self.MXG4.add_edge(0, 1, weight=3)
76         self.G = nx.DiGraph()  # no weights
77         self.G.add_edges_from(
78             [
79                 ("s", "u"),
80                 ("s", "x"),
81                 ("u", "v"),
82                 ("u", "x"),
83                 ("v", "y"),
84                 ("x", "u"),
85                 ("x", "v"),
86                 ("x", "y"),
87                 ("y", "s"),
88                 ("y", "v"),
89             ]
90         )
91 class TestWeightedPath(WeightedTestBase):
92     def test_dijkstra(self):
93         (D, P) = nx.single_source_dijkstra(self.XG, "s")
94         validate_path(self.XG, "s", "v", 9, P["v"])
95         assert D["v"] == 9
96         validate_path(
97             self.XG, "s", "v", 9, nx.single_source_dijkstra_path(self.XG, "s")["v"]
98         )
99         assert dict(nx.single_source_dijkstra_path_length(self.XG, "s"))["v"] == 9
100         validate_path(
101             self.XG, "s", "v", 9, nx.single_source_dijkstra(self.XG, "s")[1]["v"]
102         )
103         validate_path(
104             self.MXG, "s", "v", 9, nx.single_source_dijkstra_path(self.MXG, "s")["v"]
105         )
106         GG = self.XG.to_undirected()
107         GG["u"]["x"]["weight"] = 2
108         (D, P) = nx.single_source_dijkstra(GG, "s")
109         validate_path(GG, "s", "v", 8, P["v"])
110         assert D["v"] == 8  # uses lower weight of 2 on u&lt;-&gt;x edge
111         validate_path(GG, "s", "v", 8, nx.dijkstra_path(GG, "s", "v"))
112         assert nx.dijkstra_path_length(GG, "s", "v") == 8
113         validate_path(self.XG2, 1, 3, 4, nx.dijkstra_path(self.XG2, 1, 3))
114         validate_path(self.XG3, 0, 3, 15, nx.dijkstra_path(self.XG3, 0, 3))
115         assert nx.dijkstra_path_length(self.XG3, 0, 3) == 15
116         validate_path(self.XG4, 0, 2, 4, nx.dijkstra_path(self.XG4, 0, 2))
117         assert nx.dijkstra_path_length(self.XG4, 0, 2) == 4
118         validate_path(self.MXG4, 0, 2, 4, nx.dijkstra_path(self.MXG4, 0, 2))
119         validate_path(
120             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s", "v")[1]
121         )
122         validate_path(
123             self.G, "s", "v", 2, nx.single_source_dijkstra(self.G, "s")[1]["v"]
124         )
125         validate_path(self.G, "s", "v", 2, nx.dijkstra_path(self.G, "s", "v"))
126         assert nx.dijkstra_path_length(self.G, "s", "v") == 2
127         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path, self.G, "s", "moon")
128         pytest.raises(nx.NetworkXNoPath, nx.dijkstra_path_length, self.G, "s", "moon")
129         validate_path(self.cycle, 0, 3, 3, nx.dijkstra_path(self.cycle, 0, 3))
130         validate_path(self.cycle, 0, 4, 3, nx.dijkstra_path(self.cycle, 0, 4))
131         assert nx.single_source_dijkstra(self.cycle, 0, 0) == (0, [0])
132     def test_bidirectional_dijkstra(self):
133         validate_length_path(
134             self.XG, "s", "v", 9, *nx.bidirectional_dijkstra(self.XG, "s", "v")
135         )
136         validate_length_path(
137             self.G, "s", "v", 2, *nx.bidirectional_dijkstra(self.G, "s", "v")
138         )
139         validate_length_path(
140             self.cycle, 0, 3, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 3)
141         )
142         validate_length_path(
143             self.cycle, 0, 4, 3, *nx.bidirectional_dijkstra(self.cycle, 0, 4)
144         )
145         validate_length_path(
146             self.XG3, 0, 3, 15, *nx.bidirectional_dijkstra(self.XG3, 0, 3)
147         )
148         validate_length_path(
149             self.XG4, 0, 2, 4, *nx.bidirectional_dijkstra(self.XG4, 0, 2)
150         )
151         P = nx.single_source_dijkstra_path(self.XG, "s")["v"]
152         validate_path(
153             self.XG,
154             "s",
155             "v",
156             sum(self.XG[u][v]["weight"] for u, v in zip(P[:-1], P[1:])),
157             nx.dijkstra_path(self.XG, "s", "v"),
158         )
159         G = nx.path_graph(2)
160         pytest.raises(nx.NodeNotFound, nx.bidirectional_dijkstra, G, 3, 0)
161     def test_weight_functions(self):
162         def heuristic(*z):
163             return sum(val ** 2 for val in z)
164         def getpath(pred, v, s):
165             return [v] if v == s else getpath(pred, pred[v], s) + [v]
166         def goldberg_radzik(g, s, t, weight="weight"):
167             pred, dist = nx.goldberg_radzik(g, s, weight=weight)
168             dist = dist[t]
169             return dist, getpath(pred, t, s)
170         def astar(g, s, t, weight="weight"):
171             path = nx.astar_path(g, s, t, heuristic, weight=weight)
172             dist = nx.astar_path_length(g, s, t, heuristic, weight=weight)
173             return dist, path
174         def vlp(G, s, t, l, F, w):
175             res = F(G, s, t, weight=w)
176             validate_length_path(G, s, t, l, *res, weight=w)
177         G = self.cycle
178         s = 6
179         t = 4
180         path = [6] + list(range(t + 1))
181         def weight(u, v, _):
182             return 1 + v ** 2
183         length = sum(weight(u, v, None) for u, v in pairwise(path))
184         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
185         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
186         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
187         vlp(G, s, t, length, goldberg_radzik, weight)
188         vlp(G, s, t, length, astar, weight)
189         def weight(u, v, _):
190             return 2 ** (u * v)
191         length = sum(weight(u, v, None) for u, v in pairwise(path))
192         vlp(G, s, t, length, nx.bidirectional_dijkstra, weight)
193         vlp(G, s, t, length, nx.single_source_dijkstra, weight)
194         vlp(G, s, t, length, nx.single_source_bellman_ford, weight)
195         vlp(G, s, t, length, goldberg_radzik, weight)
196         vlp(G, s, t, length, astar, weight)
197     def test_bidirectional_dijkstra_no_path(self):
198         with pytest.raises(nx.NetworkXNoPath):
199             G = nx.Graph()
200             nx.add_path(G, [1, 2, 3])
201             nx.add_path(G, [4, 5, 6])
202             path = nx.bidirectional_dijkstra(G, 1, 6)
203     @pytest.mark.parametrize(
204         "fn",
205         (
206             nx.dijkstra_path,
207             nx.dijkstra_path_length,
208             nx.single_source_dijkstra_path,
209             nx.single_source_dijkstra_path_length,
210             nx.single_source_dijkstra,
211             nx.dijkstra_predecessor_and_distance,
212         ),
213     )
214     def test_absent_source(self, fn):
215         G = nx.path_graph(2)
216         with pytest.raises(nx.NodeNotFound):
217             fn(G, 3, 0)
218         with pytest.raises(nx.NodeNotFound):
219             fn(G, 3, 3)
220     def test_dijkstra_predecessor1(self):
221         G = nx.path_graph(4)
222         assert nx.dijkstra_predecessor_and_distance(G, 0) == (
223             {0: [], 1: [0], 2: [1], 3: [2]},
224             {0: 0, 1: 1, 2: 2, 3: 3},
225         )
226     def test_dijkstra_predecessor2(self):
227         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
228         pred, dist = nx.dijkstra_predecessor_and_distance(G, (0))
229         assert pred[0] == []
230 <a name="0"></a>        assert pred[1] == [0]
231         assert pred[2] in [[1, 3], [3, 1]]
232         assert pred[3] == [0]
233         assert dist == {0<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>: 0, 1: 1, 2: 2, 3: 1}
234     def test_dijkstra_predecessor3(self):
235         XG = nx.DiGraph()
236         XG.add_weighted_edges_from(
237             [
238                 ("s", "u", 10),
239                 ("s", "x", 5),
240                 ("u", "v", 1),
241                 ("u", "x", 2),
242                 ("v", "y", 1),
243                 ("x", "u", 3),
244                 ("x", "v", 5),
245                 ("x", "y", 2),
246                 ("y", "s", 7),
247                 ("y", "v", 6),
248             ]
249         )
250         (P</b></font>, D) = nx.dijkstra_predecessor_and_distance(XG, "s")
251         assert P["v"] == ["u"]
252         assert D["v"] == 9
253         (P, D) = nx.dijkstra_predecessor_and_distance(XG, "s", cutoff=8)
254         assert "v" not in D
255     def test_single_source_dijkstra_path_length(self):
256         pl = nx.single_source_dijkstra_path_length
257         assert dict(pl(self.MXG4, 0))[2] == 4
258         spl = pl(self.MXG4, 0, cutoff=2)
259         assert 2 not in spl
260     def test_bidirectional_dijkstra_multigraph(self):
261         G = nx.MultiGraph()
262         G.add_edge("a", "b", weight=10)
263         G.add_edge("a", "b", weight=100)
264         dp = nx.bidirectional_dijkstra(G, "a", "b")
265         assert dp == (10, ["a", "b"])
266     def test_dijkstra_pred_distance_multigraph(self):
267         G = nx.MultiGraph()
268         G.add_edge("a", "b", key="short", foo=5, weight=100)
269         G.add_edge("a", "b", key="long", bar=1, weight=110)
270         p, d = nx.dijkstra_predecessor_and_distance(G, "a")
271         assert p == {"a": [], "b": ["a"]}
272         assert d == {"a": 0, "b": 100}
273     def test_negative_edge_cycle(self):
274         G = nx.cycle_graph(5, create_using=nx.DiGraph())
275         assert not nx.negative_edge_cycle(G)
276         G.add_edge(8, 9, weight=-7)
277         G.add_edge(9, 8, weight=3)
278         graph_size = len(G)
279         assert nx.negative_edge_cycle(G)
280         assert graph_size == len(G)
281         pytest.raises(ValueError, nx.single_source_dijkstra_path_length, G, 8)
282         pytest.raises(ValueError, nx.single_source_dijkstra, G, 8)
283         pytest.raises(ValueError, nx.dijkstra_predecessor_and_distance, G, 8)
284         G.add_edge(9, 10)
285         pytest.raises(ValueError, nx.bidirectional_dijkstra, G, 8, 10)
286     def test_negative_edge_cycle_custom_weight_key(self):
287         d = nx.DiGraph()
288         d.add_edge("a", "b", w=-2)
289         d.add_edge("b", "a", w=-1)
290         assert nx.negative_edge_cycle(d, weight="w")
291     def test_weight_function(self):
292         G = nx.complete_graph(3)
293         G.adj[0][2]["weight"] = 10
294         G.adj[0][1]["weight"] = 1
295         G.adj[1][2]["weight"] = 1
296         def weight(u, v, d):
297             return 1 / d["weight"]
298         distance, path = nx.single_source_dijkstra(G, 0, 2)
299         assert distance == 2
300         assert path == [0, 1, 2]
301         distance, path = nx.single_source_dijkstra(G, 0, 2, weight=weight)
302         assert distance == 1 / 10
303         assert path == [0, 2]
304     def test_all_pairs_dijkstra_path(self):
305         cycle = nx.cycle_graph(7)
306         p = dict(nx.all_pairs_dijkstra_path(cycle))
307         assert p[0][3] == [0, 1, 2, 3]
308         cycle[1][2]["weight"] = 10
309         p = dict(nx.all_pairs_dijkstra_path(cycle))
310         assert p[0][3] == [0, 6, 5, 4, 3]
311     def test_all_pairs_dijkstra_path_length(self):
312         cycle = nx.cycle_graph(7)
313         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
314         assert pl[0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
315         cycle[1][2]["weight"] = 10
316         pl = dict(nx.all_pairs_dijkstra_path_length(cycle))
317         assert pl[0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
318     def test_all_pairs_dijkstra(self):
319         cycle = nx.cycle_graph(7)
320         out = dict(nx.all_pairs_dijkstra(cycle))
321         assert out[0][0] == {0: 0, 1: 1, 2: 2, 3: 3, 4: 3, 5: 2, 6: 1}
322         assert out[0][1][3] == [0, 1, 2, 3]
323         cycle[1][2]["weight"] = 10
324         out = dict(nx.all_pairs_dijkstra(cycle))
325         assert out[0][0] == {0: 0, 1: 1, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}
326         assert out[0][1][3] == [0, 6, 5, 4, 3]
327 class TestDijkstraPathLength:
328     def test_weight_function(self):
329         G = nx.complete_graph(3)
330         G.adj[0][2]["weight"] = 10
331         G.adj[0][1]["weight"] = 1
332         G.adj[1][2]["weight"] = 1
333         def weight(u, v, d):
334             return 1 / d["weight"]
335         length = nx.dijkstra_path_length(G, 0, 2, weight=weight)
336         assert length == 1 / 10
337 class TestMultiSourceDijkstra:
338     def test_no_sources(self):
339         with pytest.raises(ValueError):
340             nx.multi_source_dijkstra(nx.Graph(), {})
341     def test_path_no_sources(self):
342         with pytest.raises(ValueError):
343             nx.multi_source_dijkstra_path(nx.Graph(), {})
344     def test_path_length_no_sources(self):
345         with pytest.raises(ValueError):
346             nx.multi_source_dijkstra_path_length(nx.Graph(), {})
347     @pytest.mark.parametrize(
348         "fn",
349         (
350             nx.multi_source_dijkstra_path,
351             nx.multi_source_dijkstra_path_length,
352             nx.multi_source_dijkstra,
353         ),
354     )
355     def test_absent_source(self, fn):
356         G = nx.path_graph(2)
357         with pytest.raises(nx.NodeNotFound):
358             fn(G, [3], 0)
359         with pytest.raises(nx.NodeNotFound):
360             fn(G, [3], 3)
361     def test_two_sources(self):
362         edges = [(0, 1, 1), (1, 2, 1), (2, 3, 10), (3, 4, 1)]
363         G = nx.Graph()
364         G.add_weighted_edges_from(edges)
365         sources = {0, 4}
366         distances, paths = nx.multi_source_dijkstra(G, sources)
367         expected_distances = {0: 0, 1: 1, 2: 2, 3: 1, 4: 0}
368         expected_paths = {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [4, 3], 4: [4]}
369         assert distances == expected_distances
370         assert paths == expected_paths
371     def test_simple_paths(self):
372         G = nx.path_graph(4)
373         lengths = nx.multi_source_dijkstra_path_length(G, [0])
374         assert lengths == {n: n for n in G}
375         paths = nx.multi_source_dijkstra_path(G, [0])
376         assert paths == {n: list(range(n + 1)) for n in G}
377 class TestBellmanFordAndGoldbergRadzik(WeightedTestBase):
378     def test_single_node_graph(self):
379         G = nx.DiGraph()
380         G.add_node(0)
381         assert nx.single_source_bellman_ford_path(G, 0) == {0: [0]}
382         assert nx.single_source_bellman_ford_path_length(G, 0) == {0: 0}
383         assert nx.single_source_bellman_ford(G, 0) == ({0: 0}, {0: [0]})
384         assert nx.bellman_ford_predecessor_and_distance(G, 0) == ({0: []}, {0: 0})
385         assert nx.goldberg_radzik(G, 0) == ({0: None}, {0: 0})
386     def test_absent_source_bellman_ford(self):
387         G = nx.path_graph(2)
388         for fn in (
389             nx.bellman_ford_predecessor_and_distance,
390             nx.bellman_ford_path,
391             nx.bellman_ford_path_length,
392             nx.single_source_bellman_ford_path,
393             nx.single_source_bellman_ford_path_length,
394             nx.single_source_bellman_ford,
395         ):
396             pytest.raises(nx.NodeNotFound, fn, G, 3, 0)
397             pytest.raises(nx.NodeNotFound, fn, G, 3, 3)
398     def test_absent_source_goldberg_radzik(self):
399         with pytest.raises(nx.NodeNotFound):
400 <a name="2"></a>            G = nx.path_graph(2)
401             nx.goldberg_radzik(G, 3, 0)
402     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>def test_negative_cycle_heuristic(self):
403         G = nx.DiGraph()
404         G.add_edge(0, 1, weight=-1)
405         G.add_edge(1, 2, weight=-1)
406         G.add_edge(2, 3, weight=-1)
407         G.add_edge(3, 0, weight=</b></font>3)
408         assert not nx.negative_edge_cycle(G, heuristic=True)
409         G.add_edge(2, 0, weight=1.999)
410         assert nx.negative_edge_cycle(G, heuristic=True)
411         G.edges[2, 0]["weight"] = 2
412         assert not nx.negative_edge_cycle(G, heuristic=True)
413     def test_negative_cycle_consistency(self):
414         import random
415         unif = random.uniform
416         for random_seed in range(2):  # range(20):
417             random.seed(random_seed)
418             for density in [0.1, 0.9]:  # .3, .7, .9]:
419                 for N in [1, 10, 20]:  # range(1, 60 - int(30 * density)):
420                     for max_cost in [1, 90]:  # [1, 10, 40, 90]:
421                         G = nx.binomial_graph(N, density, seed=4, directed=True)
422                         edges = ((u, v, unif(-1, max_cost)) for u, v in G.edges)
423                         G.add_weighted_edges_from(edges)
424                         no_heuristic = nx.negative_edge_cycle(G, heuristic=False)
425                         with_heuristic = nx.negative_edge_cycle(G, heuristic=True)
426                         assert no_heuristic == with_heuristic
427     def test_negative_cycle(self):
428         G = nx.cycle_graph(5, create_using=nx.DiGraph())
429         G.add_edge(1, 2, weight=-7)
430         for i in range(5):
431             pytest.raises(
432                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
433             )
434             pytest.raises(
435                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
436             )
437             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
438             pytest.raises(
439                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
440             )
441             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
442         G = nx.cycle_graph(5)  # undirected Graph
443         G.add_edge(1, 2, weight=-3)
444         for i in range(5):
445             pytest.raises(
446                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, i
447             )
448             pytest.raises(
449                 nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, i
450             )
451             pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, i)
452             pytest.raises(
453                 nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, i
454             )
455             pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, i)
456         G = nx.DiGraph([(1, 1, {"weight": -1})])
457         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford_path, G, 1)
458         pytest.raises(
459             nx.NetworkXUnbounded, nx.single_source_bellman_ford_path_length, G, 1
460         )
461         pytest.raises(nx.NetworkXUnbounded, nx.single_source_bellman_ford, G, 1)
462         pytest.raises(
463             nx.NetworkXUnbounded, nx.bellman_ford_predecessor_and_distance, G, 1
464         )
465         pytest.raises(nx.NetworkXUnbounded, nx.goldberg_radzik, G, 1)
466     def test_find_negative_cycle_longer_cycle(self):
467         G = nx.cycle_graph(5, create_using=nx.DiGraph())
468         nx.add_cycle(G, [3, 5, 6, 7, 8, 9])
469         G.add_edge(1, 2, weight=-30)
470         assert nx.find_negative_cycle(G, 1) == [0, 1, 2, 3, 4, 0]
471         assert nx.find_negative_cycle(G, 7) == [2, 3, 4, 0, 1, 2]
472     def test_find_negative_cycle_no_cycle(self):
473         G = nx.path_graph(5, create_using=nx.DiGraph())
474         pytest.raises(nx.NetworkXError, nx.find_negative_cycle, G, 3)
475     def test_find_negative_cycle_single_edge(self):
476         G = nx.Graph()
477         G.add_edge(0, 1, weight=-1)
478         assert nx.find_negative_cycle(G, 1) == [1, 0, 1]
479     def test_negative_weight(self):
480         G = nx.cycle_graph(5, create_using=nx.DiGraph())
481         G.add_edge(1, 2, weight=-3)
482         assert nx.single_source_bellman_ford_path(G, 0) == {
483             0: [0],
484             1: [0, 1],
485             2: [0, 1, 2],
486             3: [0, 1, 2, 3],
487             4: [0, 1, 2, 3, 4],
488         }
489         assert nx.single_source_bellman_ford_path_length(G, 0) == {
490             0: 0,
491             1: 1,
492             2: -2,
493             3: -1,
494             4: 0,
495         }
496         assert nx.single_source_bellman_ford(G, 0) == (
497             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
498             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3], 4: [0, 1, 2, 3, 4]},
499         )
500         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
501             {0: [], 1: [0], 2: [1], 3: [2], 4: [3]},
502             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
503         )
504         assert nx.goldberg_radzik(G, 0) == (
505             {0: None, 1: 0, 2: 1, 3: 2, 4: 3},
506             {0: 0, 1: 1, 2: -2, 3: -1, 4: 0},
507         )
508     def test_not_connected(self):
509         G = nx.complete_graph(6)
510         G.add_edge(10, 11)
511         G.add_edge(10, 12)
512         assert nx.single_source_bellman_ford_path(G, 0) == {
513             0: [0],
514             1: [0, 1],
515             2: [0, 2],
516             3: [0, 3],
517             4: [0, 4],
518             5: [0, 5],
519         }
520         assert nx.single_source_bellman_ford_path_length(G, 0) == {
521             0: 0,
522             1: 1,
523             2: 1,
524             3: 1,
525             4: 1,
526             5: 1,
527         }
528         assert nx.single_source_bellman_ford(G, 0) == (
529             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
530             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
531         )
532         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
533             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
534             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
535         )
536         assert nx.goldberg_radzik(G, 0) == (
537             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
538             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
539         )
540         G = nx.complete_graph(6)
541         G.add_edges_from(
542             [
543                 ("A", "B", {"load": 3}),
544                 ("B", "C", {"load": -10}),
545                 ("C", "A", {"load": 2}),
546             ]
547         )
548         assert nx.single_source_bellman_ford_path(G, 0, weight="load") == {
549             0: [0],
550             1: [0, 1],
551             2: [0, 2],
552             3: [0, 3],
553             4: [0, 4],
554             5: [0, 5],
555         }
556         assert nx.single_source_bellman_ford_path_length(G, 0, weight="load") == {
557             0: 0,
558             1: 1,
559             2: 1,
560             3: 1,
561             4: 1,
562             5: 1,
563         }
564         assert nx.single_source_bellman_ford(G, 0, weight="load") == (
565             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
566             {0: [0], 1: [0, 1], 2: [0, 2], 3: [0, 3], 4: [0, 4], 5: [0, 5]},
567         )
568         assert nx.bellman_ford_predecessor_and_distance(G, 0, weight="load") == (
569             {0: [], 1: [0], 2: [0], 3: [0], 4: [0], 5: [0]},
570             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
571         )
572         assert nx.goldberg_radzik(G, 0, weight="load") == (
573             {0: None, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0},
574             {0: 0, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1},
575         )
576     def test_multigraph(self):
577         assert nx.bellman_ford_path(self.MXG, "s", "v") == ["s", "x", "u", "v"]
578         assert nx.bellman_ford_path_length(self.MXG, "s", "v") == 9
579         assert nx.single_source_bellman_ford_path(self.MXG, "s")["v"] == [
580             "s",
581             "x",
582             "u",
583             "v",
584         ]
585         assert nx.single_source_bellman_ford_path_length(self.MXG, "s")["v"] == 9
586         D, P = nx.single_source_bellman_ford(self.MXG, "s", target="v")
587         assert D == 9
588         assert P == ["s", "x", "u", "v"]
589         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG, "s")
590         assert P["v"] == ["u"]
591         assert D["v"] == 9
592         P, D = nx.goldberg_radzik(self.MXG, "s")
593         assert P["v"] == "u"
594         assert D["v"] == 9
595         assert nx.bellman_ford_path(self.MXG4, 0, 2) == [0, 1, 2]
596         assert nx.bellman_ford_path_length(self.MXG4, 0, 2) == 4
597         assert nx.single_source_bellman_ford_path(self.MXG4, 0)[2] == [0, 1, 2]
598         assert nx.single_source_bellman_ford_path_length(self.MXG4, 0)[2] == 4
599         D, P = nx.single_source_bellman_ford(self.MXG4, 0, target=2)
600         assert D == 4
601         assert P == [0, 1, 2]
602         P, D = nx.bellman_ford_predecessor_and_distance(self.MXG4, 0)
603         assert P[2] == [1]
604         assert D[2] == 4
605         P, D = nx.goldberg_radzik(self.MXG4, 0)
606         assert P[2] == 1
607         assert D[2] == 4
608     def test_others(self):
609         assert nx.bellman_ford_path(self.XG, "s", "v") == ["s", "x", "u", "v"]
610         assert nx.bellman_ford_path_length(self.XG, "s", "v") == 9
611         assert nx.single_source_bellman_ford_path(self.XG, "s")["v"] == [
612             "s",
613             "x",
614             "u",
615             "v",
616         ]
617         assert nx.single_source_bellman_ford_path_length(self.XG, "s")["v"] == 9
618         D, P = nx.single_source_bellman_ford(self.XG, "s", target="v")
619         assert D == 9
620         assert P == ["s", "x", "u", "v"]
621         (P, D) = nx.bellman_ford_predecessor_and_distance(self.XG, "s")
622         assert P["v"] == ["u"]
623         assert D["v"] == 9
624         (P, D) = nx.goldberg_radzik(self.XG, "s")
625         assert P["v"] == "u"
626         assert D["v"] == 9
627     def test_path_graph(self):
628         G = nx.path_graph(4)
629         assert nx.single_source_bellman_ford_path(G, 0) == {
630             0: [0],
631             1: [0, 1],
632             2: [0, 1, 2],
633             3: [0, 1, 2, 3],
634         }
635         assert nx.single_source_bellman_ford_path_length(G, 0) == {
636             0: 0,
637             1: 1,
638             2: 2,
639             3: 3,
640         }
641         assert nx.single_source_bellman_ford(G, 0) == (
642             {0: 0, 1: 1, 2: 2, 3: 3},
643             {0: [0], 1: [0, 1], 2: [0, 1, 2], 3: [0, 1, 2, 3]},
644         )
645         assert nx.bellman_ford_predecessor_and_distance(G, 0) == (
646             {0: [], 1: [0], 2: [1], 3: [2]},
647             {0: 0, 1: 1, 2: 2, 3: 3},
648         )
649         assert nx.goldberg_radzik(G, 0) == (
650             {0: None, 1: 0, 2: 1, 3: 2},
651             {0: 0, 1: 1, 2: 2, 3: 3},
652         )
653         assert nx.single_source_bellman_ford_path(G, 3) == {
654             0: [3, 2, 1, 0],
655             1: [3, 2, 1],
656             2: [3, 2],
657             3: [3],
658         }
659         assert nx.single_source_bellman_ford_path_length(G, 3) == {
660             0: 3,
661             1: 2,
662             2: 1,
663             3: 0,
664         }
665         assert nx.single_source_bellman_ford(G, 3) == (
666             {0: 3, 1: 2, 2: 1, 3: 0},
667             {0: [3, 2, 1, 0], 1: [3, 2, 1], 2: [3, 2], 3: [3]},
668         )
669         assert nx.bellman_ford_predecessor_and_distance(G, 3) == (
670             {0: [1], 1: [2], 2: [3], 3: []},
671             {0: 3, 1: 2, 2: 1, 3: 0},
672         )
673         assert nx.goldberg_radzik(G, 3) == (
674             {0: 1, 1: 2, 2: 3, 3: None},
675             {0: 3, 1: 2, 2: 1, 3: 0},
676         )
677     def test_4_cycle(self):
678         G = nx.Graph([(0, 1), (1, 2), (2, 3), (3, 0)])
679         dist, path = nx.single_source_bellman_ford(G, 0)
680         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
681         assert path[0] == [0]
682         assert path[1] == [0, 1]
683         assert path[2] in [[0, 1, 2], [0, 3, 2]]
684         assert path[3] == [0, 3]
685         pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)
686         assert pred[0] == []
687         assert pred[1] == [0]
688         assert pred[2] in [[1, 3], [3, 1]]
689         assert pred[3] == [0]
690         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
691         pred, dist = nx.goldberg_radzik(G, 0)
692         assert pred[0] is None
693         assert pred[1] == 0
694         assert pred[2] in [1, 3]
695         assert pred[3] == 0
696         assert dist == {0: 0, 1: 1, 2: 2, 3: 1}
697 <a name="9"></a>    def test_negative_weight_bf_path(self):
698         G = nx.DiGraph()
699         G.add_nodes_from("abcd")
700         G<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.add_edge("a", "d", weight=0)
701         G.add_edge("a", "b", weight=1)
702         G.add_edge("b", "c", weight=-3)
703 <a name="7"></a>        G.add_edge("c", "d", weight=</b></font>1)
704         assert nx.bellman_ford_path(G, "a", "d") == ["a", "b", "c", "d"]
705         assert nx.bellman_ford_path_length(<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>G, "a", "d") == -1
706     def test_zero_cycle_smoke(self):
707         D = nx.DiGraph()
708         D.add_weighted_edges_from([(0, 1, 1), (1, 2, 1), (2, 3, 1), (3, 1, -2)])
709         nx.</b></font>bellman_ford_path(D, 1, 3)
710         nx.dijkstra_path(D, 1, 3)
711         nx.bidirectional_dijkstra(D, 1, 3)
712 class TestJohnsonAlgorithm(WeightedTestBase):
713     def test_single_node_graph(self):
714 <a name="3"></a>        with pytest.raises(nx.NetworkXError):
715             G = nx.DiGraph()
716             G.add_node(0)
717             nx.johnson(G<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>)
718     def test_negative_cycle(self):
719         G = nx.DiGraph()
720         G.add_weighted_edges_from(
721             [
722                 ("0", "3", 3),
723                 ("0", "1", -5),
724                 ("1", "0", -5),
725                 ("0", "2", 2),
726                 ("1", "2", 4),
727                 ("2", "3", 1),
728             ]
729         )
730         pytest.</b></font>raises(nx.NetworkXUnbounded, nx.johnson, G)
731         G = nx.Graph()
732         G.add_weighted_edges_from(
733             [
734                 ("0", "3", 3),
735                 ("0", "1", -5),
736                 ("1", "0", -5),
737                 ("0", "2", 2),
738                 ("1", "2", 4),
739 <a name="6"></a>                ("2", "3", 1),
740             ]
741         )
742         pytest.raises(nx.NetworkXUnbounded, nx.<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>johnson, G)
743     def test_negative_weights(self):
744         G = nx.DiGraph()
745         G.add_weighted_edges_from(
746             [("0", "3", 3), ("0", "1", -5), ("0", "2", 2), ("1", "2", 4), ("2"</b></font>, "3", 1)]
747         )
748         paths = nx.johnson(G)
749         assert paths == {
750             "1": {"1": ["1"], "3": ["1", "2", "3"], "2": ["1", "2"]},
751             "0": {
752                 "1": ["0", "1"],
753                 "0": ["0"],
754                 "3": ["0", "1", "2", "3"],
755                 "2": ["0", "1", "2"],
756             },
757             "3": {"3": ["3"]},
758             "2": {"3": ["2", "3"], "2": ["2"]},
759         }
760     def test_unweighted_graph(self):
761         with pytest.raises(nx.NetworkXError):
762             G = nx.path_graph(5)
763             nx.johnson(G)
764     def test_graphs(self):
765         validate_path(self.XG, "s", "v", 9, nx.johnson(self.XG)["s"]["v"])
766         validate_path(self.MXG, "s", "v", 9, nx.johnson(self.MXG)["s"]["v"])
767         validate_path(self.XG2, 1, 3, 4, nx.johnson(self.XG2)[1][3])
768         validate_path(self.XG3, 0, 3, 15, nx.johnson(self.XG3)[0][3])
769         validate_path(self.XG4, 0, 2, 4, nx.johnson(self.XG4)[0][2])
770         validate_path(self.MXG4, 0, 2, 4, nx.johnson(self.MXG4)[0][2])
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
