<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for vgtv.py & nba.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for vgtv.py & nba.py
      </h3>
      <h1 align="center">
        6.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>vgtv.py (10.416667%)<TH>nba.py (5.0%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match93302-0.html#0',2,'match93302-1.html#0',3)" NAME="0">(129-168)<TD><A HREF="javascript:ZweiFrames('match93302-0.html#0',2,'match93302-1.html#0',3)" NAME="0">(127-167)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match93302-0.html#1',2,'match93302-1.html#1',3)" NAME="1">(223-226)<TD><A HREF="javascript:ZweiFrames('match93302-0.html#1',2,'match93302-1.html#1',3)" NAME="1">(208-212)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vgtv.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# coding: utf-8
from __future__ import unicode_literals

import re

from .common import InfoExtractor
from .xstream import XstreamIE
from ..utils import (
    ExtractorError,
    float_or_none,
    try_get,
)


class VGTVIE(XstreamIE):
    IE_DESC = 'VGTV, BTTV, FTV, Aftenposten and Aftonbladet'
    _GEO_BYPASS = False

    _HOST_TO_APPNAME = {
        'vgtv.no': 'vgtv',
        'bt.no/tv': 'bttv',
        'aftenbladet.no/tv': 'satv',
        'fvn.no/fvntv': 'fvntv',
        'aftenposten.no/webtv': 'aptv',
        'ap.vgtv.no/webtv': 'aptv',
        'tv.aftonbladet.se': 'abtv',
        # obsolete URL schemas, kept in order to save one HTTP redirect
        'tv.aftonbladet.se/abtv': 'abtv',
        'www.aftonbladet.se/tv': 'abtv',
    }

    _APP_NAME_TO_VENDOR = {
        'vgtv': 'vgtv',
        'bttv': 'bt',
        'satv': 'sa',
        'fvntv': 'fvn',
        'aptv': 'ap',
        'abtv': 'ab',
    }

    _VALID_URL = r'''(?x)
                    (?:https?://(?:www\.)?
                    (?P&lt;host&gt;
                        %s
                    )
                    /?
                    (?:
                        (?:\#!/)?(?:video|live)/|
                        embed?.*id=|
                        a(?:rticles)?/
                    )|
                    (?P&lt;appname&gt;
                        %s
                    ):)
                    (?P&lt;id&gt;\d+)
                    ''' % ('|'.join(_HOST_TO_APPNAME.keys()), '|'.join(_APP_NAME_TO_VENDOR.keys()))

    _TESTS = [
        {
            # streamType: vod
            'url': 'http://www.vgtv.no/#!/video/84196/hevnen-er-soet-episode-10-abu',
            'md5': 'b8be7a234cebb840c0d512c78013e02f',
            'info_dict': {
                'id': '84196',
                'ext': 'mp4',
                'title': 'Hevnen er søt: Episode 10 - Abu',
                'description': 'md5:e25e4badb5f544b04341e14abdc72234',
                'thumbnail': r're:^https?://.*\.jpg',
                'duration': 648.000,
                'timestamp': 1404626400,
                'upload_date': '20140706',
                'view_count': int,
            },
        },
        {
            # streamType: wasLive
            'url': 'http://www.vgtv.no/#!/live/100764/opptak-vgtv-foelger-em-kvalifiseringen',
            'info_dict': {
                'id': '100764',
                'ext': 'flv',
                'title': 'OPPTAK: VGTV følger EM-kvalifiseringen',
                'description': 'md5:3772d9c0dc2dff92a886b60039a7d4d3',
                'thumbnail': r're:^https?://.*\.jpg',
                'duration': 9103.0,
                'timestamp': 1410113864,
                'upload_date': '20140907',
                'view_count': int,
            },
            'params': {
                # m3u8 download
                'skip_download': True,
            },
            'skip': 'Video is no longer available',
        },
        {
            # streamType: wasLive
            'url': 'http://www.vgtv.no/#!/live/113063/direkte-v75-fra-solvalla',
            'info_dict': {
                'id': '113063',
                'ext': 'mp4',
                'title': 'V75 fra Solvalla 30.05.15',
                'description': 'md5:b3743425765355855f88e096acc93231',
                'thumbnail': r're:^https?://.*\.jpg',
                'duration': 25966,
                'timestamp': 1432975582,
                'upload_date': '20150530',
                'view_count': int,
            },
            'params': {
                # m3u8 download
                'skip_download': True,
            },
        },
        {
            'url': 'http://www.aftenposten.no/webtv/#!/video/21039/trailer-sweatshop-i-can-t-take-any-more',
            'md5': 'fd828cd29774a729bf4d4425fe192972',
            'info_dict': {
                'id': '21039',
                'ext': 'mp4',
                'title': 'TRAILER: «SWEATSHOP» - I can´t take any more',
                'description': 'md5:21891f2b0dd7ec2f78d84a50e54f8238',
                'duration': 66,
                'timestamp': 1417002452,
                'upload_date': '20141126',
                'view_count': int,
<A NAME="0"></A>            },
            'params': {
                # m3u8 download
                <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match93302-1.html#0',3,'match93302-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>'skip_download': True,
            },
        },
        {
            'url': 'http://www.bt.no/tv/#!/video/100250/norling-dette-er-forskjellen-paa-1-divisjon-og-eliteserien',
            'only_matching': True,
        },
        {
            'url': 'http://ap.vgtv.no/webtv#!/video/111084/de-nye-bysyklene-lettere-bedre-gir-stoerre-hjul-og-feste-til-mobil',
            'only_matching': True,
        },
        {
            # geoblocked
            'url': 'http://www.vgtv.no/#!/video/127205/inside-the-mind-of-favela-funk',
            'only_matching': True,
        },
        {
            'url': 'https://tv.aftonbladet.se/video/36015/vulkanutbrott-i-rymden-nu-slapper-nasa-bilderna',
            'only_matching': True,
        },
        {
            'url': 'http://tv.aftonbladet.se/abtv/articles/36015',
            'only_matching': True,
        },
        {
            'url': 'https://www.aftonbladet.se/tv/a/36015',
            'only_matching': True,
        },
        {
            'url': 'abtv:140026',
            'only_matching': True,
        },
        {
            'url': 'http://www.vgtv.no/video/84196/hevnen-er-soet-episode-10-abu',
            'only_matching': True,
        },
    ]

    def _real_extract(self, url):
        mobj = re.match(</B></FONT>self._VALID_URL, url)
        video_id = mobj.group('id')
        host = mobj.group('host')
        appname = self._HOST_TO_APPNAME[host] if host else mobj.group('appname')
        vendor = self._APP_NAME_TO_VENDOR[appname]

        data = self._download_json(
            'http://svp.vg.no/svp/api/v1/%s/assets/%s?appName=%s-website'
            % (vendor, video_id, appname),
            video_id, 'Downloading media JSON')

        if data.get('status') == 'inactive':
            raise ExtractorError(
                'Video %s is no longer available' % video_id, expected=True)

        info = {
            'formats': [],
        }
        if len(video_id) == 5:
            if appname == 'bttv':
                info = self._extract_video_info('btno', video_id)

        streams = data['streamUrls']
        stream_type = data.get('streamType')
        is_live = stream_type == 'live'
        formats = []

        hls_url = streams.get('hls')
        if hls_url:
            formats.extend(self._extract_m3u8_formats(
                hls_url, video_id, 'mp4',
                entry_protocol='m3u8' if is_live else 'm3u8_native',
                m3u8_id='hls', fatal=False))

        hds_url = streams.get('hds')
        if hds_url:
            hdcore_sign = 'hdcore=3.7.0'
            f4m_formats = self._extract_f4m_formats(
                hds_url + '?%s' % hdcore_sign, video_id, f4m_id='hds', fatal=False)
            if f4m_formats:
                for entry in f4m_formats:
                    # URLs without the extra param induce an 404 error
                    entry.update({'extra_param_to_segment_url': hdcore_sign})
                    formats.append(entry)

        mp4_urls = streams.get('pseudostreaming') or []
        mp4_url = streams.get('mp4')
        if mp4_url:
            mp4_urls.append(mp4_url)
        for mp4_url in mp4_urls:
            format_info = {
                'url': mp4_url,
<A NAME="1"></A>            }
            mobj = re.search(r'(\d+)_(\d+)_(\d+)', mp4_url)
            if mobj:
                tbr = int<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match93302-1.html#1',3,'match93302-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(mobj.group(3))
                format_info.update({
                    'width': int(mobj.group(1)),
                    'height': int(mobj.group(</B></FONT>2)),
                    'tbr': tbr,
                    'format_id': 'mp4-%s' % tbr,
                })
            formats.append(format_info)

        info['formats'].extend(formats)

        if not info['formats']:
            properties = try_get(
                data, lambda x: x['streamConfiguration']['properties'], list)
            if properties and 'geoblocked' in properties:
                raise self.raise_geo_restricted(
                    countries=[host.rpartition('.')[-1].partition('/')[0].upper()])

        self._sort_formats(info['formats'])

        info.update({
            'id': video_id,
            'title': self._live_title(data['title']) if is_live else data['title'],
            'description': data['description'],
            'thumbnail': data['images']['main'] + '?t[]=900x506q80',
            'timestamp': data['published'],
            'duration': float_or_none(data['duration'], 1000),
            'view_count': data['displays'],
            'is_live': is_live,
        })
        return info


class BTArticleIE(InfoExtractor):
    IE_NAME = 'bt:article'
    IE_DESC = 'Bergens Tidende Articles'
    _VALID_URL = r'https?://(?:www\.)?bt\.no/(?:[^/]+/)+(?P&lt;id&gt;[^/]+)-\d+\.html'
    _TEST = {
        'url': 'http://www.bt.no/nyheter/lokalt/Kjemper-for-internatet-1788214.html',
        'md5': '2acbe8ad129b3469d5ae51b1158878df',
        'info_dict': {
            'id': '23199',
            'ext': 'mp4',
            'title': 'Alrekstad internat',
            'description': 'md5:dc81a9056c874fedb62fc48a300dac58',
            'thumbnail': r're:^https?://.*\.jpg',
            'duration': 191,
            'timestamp': 1289991323,
            'upload_date': '20101117',
            'view_count': int,
        },
    }

    def _real_extract(self, url):
        webpage = self._download_webpage(url, self._match_id(url))
        video_id = self._search_regex(
            r'&lt;video[^&gt;]+data-id=&quot;(\d+)&quot;', webpage, 'video id')
        return self.url_result('bttv:%s' % video_id, 'VGTV')


class BTVestlendingenIE(InfoExtractor):
    IE_NAME = 'bt:vestlendingen'
    IE_DESC = 'Bergens Tidende - Vestlendingen'
    _VALID_URL = r'https?://(?:www\.)?bt\.no/spesial/vestlendingen/#!/(?P&lt;id&gt;\d+)'
    _TESTS = [{
        'url': 'http://www.bt.no/spesial/vestlendingen/#!/86588',
        'md5': 'd7d17e3337dc80de6d3a540aefbe441b',
        'info_dict': {
            'id': '86588',
            'ext': 'mov',
            'title': 'Otto Wollertsen',
            'description': 'Vestlendingen Otto Fredrik Wollertsen',
            'timestamp': 1430473209,
            'upload_date': '20150501',
        },
        'skip': '404 Error',
    }, {
        'url': 'http://www.bt.no/spesial/vestlendingen/#!/86255',
        'md5': 'a2893f8632e96389f4bdf36aa9463ceb',
        'info_dict': {
            'id': '86255',
            'ext': 'mov',
            'title': 'Du må tåle å fryse og være sulten',
            'description': 'md5:b8046f4d022d5830ddab04865791d063',
            'upload_date': '20150321',
            'timestamp': 1426942023,
        },
    }]

    def _real_extract(self, url):
        return self.url_result('bttv:%s' % self._match_id(url), 'VGTV')
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>nba.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
from __future__ import unicode_literals

import functools
import re

from .turner import TurnerBaseIE
from ..compat import (
    compat_parse_qs,
    compat_str,
    compat_urllib_parse_unquote,
    compat_urllib_parse_urlparse,
)
from ..utils import (
    int_or_none,
    merge_dicts,
    OnDemandPagedList,
    parse_duration,
    parse_iso8601,
    try_get,
    update_url_query,
    urljoin,
)


class NBACVPBaseIE(TurnerBaseIE):
    def _extract_nba_cvp_info(self, path, video_id, fatal=False):
        return self._extract_cvp_info(
            'http://secure.nba.com/%s' % path, video_id, {
                'default': {
                    'media_src': 'http://nba.cdn.turner.com/nba/big',
                },
                'm3u8': {
                    'media_src': 'http://nbavod-f.akamaihd.net',
                },
            }, fatal=fatal)


class NBAWatchBaseIE(NBACVPBaseIE):
    _VALID_URL_BASE = r'https?://(?:(?:www\.)?nba\.com(?:/watch)?|watch\.nba\.com)/'

    def _extract_video(self, filter_key, filter_value):
        video = self._download_json(
            'https://neulionscnbav2-a.akamaihd.net/solr/nbad_program/usersearch',
            filter_value, query={
                'fl': 'description,image,name,pid,releaseDate,runtime,tags,seoName',
                'q': filter_key + ':' + filter_value,
                'wt': 'json',
            })['response']['docs'][0]

        video_id = str(video['pid'])
        title = video['name']

        formats = []
        m3u8_url = (self._download_json(
            'https://watch.nba.com/service/publishpoint', video_id, query={
                'type': 'video',
                'format': 'json',
                'id': video_id,
            }, headers={
                'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0_1 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A402 Safari/604.1',
            }, fatal=False) or {}).get('path')
        if m3u8_url:
            m3u8_formats = self._extract_m3u8_formats(
                re.sub(r'_(?:pc|iphone)\.', '.', m3u8_url), video_id, 'mp4',
                'm3u8_native', m3u8_id='hls', fatal=False)
            formats.extend(m3u8_formats)
            for f in m3u8_formats:
                http_f = f.copy()
                http_f.update({
                    'format_id': http_f['format_id'].replace('hls-', 'http-'),
                    'protocol': 'http',
                    'url': http_f['url'].replace('.m3u8', ''),
                })
                formats.append(http_f)

        info = {
            'id': video_id,
            'title': title,
            'thumbnail': urljoin('https://nbadsdmt.akamaized.net/media/nba/nba/thumbs/', video.get('image')),
            'description': video.get('description'),
            'duration': int_or_none(video.get('runtime')),
            'timestamp': parse_iso8601(video.get('releaseDate')),
            'tags': video.get('tags'),
        }

        seo_name = video.get('seoName')
        if seo_name and re.search(r'\d{4}/\d{2}/\d{2}/', seo_name):
            base_path = ''
            if seo_name.startswith('teams/'):
                base_path += seo_name.split('/')[1] + '/'
            base_path += 'video/'
            cvp_info = self._extract_nba_cvp_info(
                base_path + seo_name + '.xml', video_id, False)
            if cvp_info:
                formats.extend(cvp_info['formats'])
                info = merge_dicts(info, cvp_info)

        self._sort_formats(formats)
        info['formats'] = formats
        return info


class NBAWatchEmbedIE(NBAWatchBaseIE):
    IENAME = 'nba:watch:embed'
    _VALID_URL = NBAWatchBaseIE._VALID_URL_BASE + r'embed\?.*?\bid=(?P&lt;id&gt;\d+)'
    _TESTS = [{
        'url': 'http://watch.nba.com/embed?id=659395',
        'md5': 'b7e3f9946595f4ca0a13903ce5edd120',
        'info_dict': {
            'id': '659395',
            'ext': 'mp4',
            'title': 'Mix clip: More than 7 points of  Joe Ingles, Luc Mbah a Moute, Blake Griffin and 6 more in Utah Jazz vs. the Clippers, 4/15/2017',
            'description': 'Mix clip: More than 7 points of  Joe Ingles, Luc Mbah a Moute, Blake Griffin and 6 more in Utah Jazz vs. the Clippers, 4/15/2017',
            'timestamp': 1492228800,
            'upload_date': '20170415',
        },
    }]

    def _real_extract(self, url):
        video_id = self._match_id(url)
        return self._extract_video('pid', video_id)


<A NAME="0"></A>class NBAWatchIE(NBAWatchBaseIE):
    IE_NAME = 'nba:watch'
    _VALID_URL = NBAWatchBaseIE._VALID_URL_BASE + r'(?:nba/)?video/(?P&lt;id&gt;.+?(?=/index\.html)|(?:[^/]+/)*[^/?#&amp;]+)'
    _TESTS = [<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match93302-0.html#0',2,'match93302-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
        'url': 'http://www.nba.com/video/games/nets/2012/12/04/0021200253-okc-bkn-recap.nba/index.html',
        'md5': '9d902940d2a127af3f7f9d2f3dc79c96',
        'info_dict': {
            'id': '70946',
            'ext': 'mp4',
            'title': 'Thunder vs. Nets',
            'description': 'Kevin Durant scores 32 points and dishes out six assists as the Thunder beat the Nets in Brooklyn.',
            'duration': 181,
            'timestamp': 1354597200,
            'upload_date': '20121204',
        },
    }, {
        'url': 'http://www.nba.com/video/games/hornets/2014/12/05/0021400276-nyk-cha-play5.nba/',
        'only_matching': True,
    }, {
        'url': 'http://watch.nba.com/video/channels/playoffs/2015/05/20/0041400301-cle-atl-recap.nba',
        'md5': 'b2b39b81cf28615ae0c3360a3f9668c4',
        'info_dict': {
            'id': '330865',
            'ext': 'mp4',
            'title': 'Hawks vs. Cavaliers Game 1',
            'description': 'md5:8094c3498d35a9bd6b1a8c396a071b4d',
            'duration': 228,
            'timestamp': 1432094400,
            'upload_date': '20150521',
        },
    }, {
        'url': 'http://watch.nba.com/nba/video/channels/nba_tv/2015/06/11/YT_go_big_go_home_Game4_061115',
        'only_matching': True,
    }, {
        # only CVP mp4 format available
        'url': 'https://watch.nba.com/video/teams/cavaliers/2012/10/15/sloan121015mov-2249106',
        'only_matching': True,
    }, {
        'url': 'https://watch.nba.com/video/top-100-dunks-from-the-2019-20-season?plsrc=nba&amp;collection=2019-20-season-highlights',
        'only_matching': True,
    }]

    def _real_extract(self, url):
        display_id = self._match_id(</B></FONT>url)
        collection_id = compat_parse_qs(compat_urllib_parse_urlparse(url).query).get('collection', [None])[0]
        if collection_id:
            if self._downloader.params.get('noplaylist'):
                self.to_screen('Downloading just video %s because of --no-playlist' % display_id)
            else:
                self.to_screen('Downloading playlist %s - add --no-playlist to just download video' % collection_id)
                return self.url_result(
                    'https://www.nba.com/watch/list/collection/' + collection_id,
                    NBAWatchCollectionIE.ie_key(), collection_id)
        return self._extract_video('seoName', display_id)


class NBAWatchCollectionIE(NBAWatchBaseIE):
    IE_NAME = 'nba:watch:collection'
    _VALID_URL = NBAWatchBaseIE._VALID_URL_BASE + r'list/collection/(?P&lt;id&gt;[^/?#&amp;]+)'
    _TESTS = [{
        'url': 'https://watch.nba.com/list/collection/season-preview-2020',
        'info_dict': {
            'id': 'season-preview-2020',
        },
        'playlist_mincount': 43,
    }]
    _PAGE_SIZE = 100

    def _fetch_page(self, collection_id, page):
        page += 1
        videos = self._download_json(
            'https://content-api-prod.nba.com/public/1/endeavor/video-list/collection/' + collection_id,
            collection_id, 'Downloading page %d JSON metadata' % page, query={
                'count': self._PAGE_SIZE,
                'page': page,
            })['results']['videos']
        for video in videos:
            program = video.get('program') or {}
            seo_name = program.get('seoName') or program.get('slug')
            if not seo_name:
                continue
<A NAME="1"></A>            yield {
                '_type': 'url',
                'id': program.get('id'),
                'title': program.get<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match93302-0.html#1',2,'match93302-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>('title') or video.get('title'),
                'url': 'https://www.nba.com/watch/video/' + seo_name,
                'thumbnail': video.get('image'),
                'description': program.get('description') or video.get('description'),
                'duration': parse_duration(program.get(</B></FONT>'runtimeHours')),
                'timestamp': parse_iso8601(video.get('releaseDate')),
            }

    def _real_extract(self, url):
        collection_id = self._match_id(url)
        entries = OnDemandPagedList(
            functools.partial(self._fetch_page, collection_id),
            self._PAGE_SIZE)
        return self.playlist_result(entries, collection_id)


class NBABaseIE(NBACVPBaseIE):
    _VALID_URL_BASE = r'''(?x)
        https?://(?:www\.)?nba\.com/
            (?P&lt;team&gt;
                blazers|
                bucks|
                bulls|
                cavaliers|
                celtics|
                clippers|
                grizzlies|
                hawks|
                heat|
                hornets|
                jazz|
                kings|
                knicks|
                lakers|
                magic|
                mavericks|
                nets|
                nuggets|
                pacers|
                pelicans|
                pistons|
                raptors|
                rockets|
                sixers|
                spurs|
                suns|
                thunder|
                timberwolves|
                warriors|
                wizards
            )
        (?:/play\#)?/'''
    _CHANNEL_PATH_REGEX = r'video/channel|series'

    def _embed_url_result(self, team, content_id):
        return self.url_result(update_url_query(
            'https://secure.nba.com/assets/amp/include/video/iframe.html', {
                'contentId': content_id,
                'team': team,
            }), NBAEmbedIE.ie_key())

    def _call_api(self, team, content_id, query, resource):
        return self._download_json(
            'https://api.nba.net/2/%s/video,imported_video,wsc/' % team,
            content_id, 'Download %s JSON metadata' % resource,
            query=query, headers={
                'accessToken': 'internal|bb88df6b4c2244e78822812cecf1ee1b',
            })['response']['result']

    def _extract_video(self, video, team, extract_all=True):
        video_id = compat_str(video['nid'])
        team = video['brand']

        info = {
            'id': video_id,
            'title': video.get('title') or video.get('headline') or video['shortHeadline'],
            'description': video.get('description'),
            'timestamp': parse_iso8601(video.get('published')),
        }

        subtitles = {}
        captions = try_get(video, lambda x: x['videoCaptions']['sidecars'], dict) or {}
        for caption_url in captions.values():
            subtitles.setdefault('en', []).append({'url': caption_url})

        formats = []
        mp4_url = video.get('mp4')
        if mp4_url:
            formats.append({
                'url': mp4_url,
            })

        if extract_all:
            source_url = video.get('videoSource')
            if source_url and not source_url.startswith('s3://') and self._is_valid_url(source_url, video_id, 'source'):
                formats.append({
                    'format_id': 'source',
                    'url': source_url,
                    'preference': 1,
                })

            m3u8_url = video.get('m3u8')
            if m3u8_url:
                if '.akamaihd.net/i/' in m3u8_url:
                    formats.extend(self._extract_akamai_formats(
                        m3u8_url, video_id, {'http': 'pmd.cdn.turner.com'}))
                else:
                    formats.extend(self._extract_m3u8_formats(
                        m3u8_url, video_id, 'mp4',
                        'm3u8_native', m3u8_id='hls', fatal=False))

            content_xml = video.get('contentXml')
            if team and content_xml:
                cvp_info = self._extract_nba_cvp_info(
                    team + content_xml, video_id, fatal=False)
                if cvp_info:
                    formats.extend(cvp_info['formats'])
                    subtitles = self._merge_subtitles(subtitles, cvp_info['subtitles'])
                    info = merge_dicts(info, cvp_info)

            self._sort_formats(formats)
        else:
            info.update(self._embed_url_result(team, video['videoId']))

        info.update({
            'formats': formats,
            'subtitles': subtitles,
        })

        return info

    def _real_extract(self, url):
        team, display_id = re.match(self._VALID_URL, url).groups()
        if '/play#/' in url:
            display_id = compat_urllib_parse_unquote(display_id)
        else:
            webpage = self._download_webpage(url, display_id)
            display_id = self._search_regex(
                self._CONTENT_ID_REGEX + r'\s*:\s*&quot;([^&quot;]+)&quot;', webpage, 'video id')
        return self._extract_url_results(team, display_id)


class NBAEmbedIE(NBABaseIE):
    IENAME = 'nba:embed'
    _VALID_URL = r'https?://secure\.nba\.com/assets/amp/include/video/(?:topI|i)frame\.html\?.*?\bcontentId=(?P&lt;id&gt;[^?#&amp;]+)'
    _TESTS = [{
        'url': 'https://secure.nba.com/assets/amp/include/video/topIframe.html?contentId=teams/bulls/2020/12/04/3478774/1607105587854-20201204_SCHEDULE_RELEASE_FINAL_DRUPAL-3478774&amp;team=bulls&amp;adFree=false&amp;profile=71&amp;videoPlayerName=TAMPCVP&amp;baseUrl=&amp;videoAdsection=nba.com_mobile_web_teamsites_chicagobulls&amp;ampEnv=',
        'only_matching': True,
    }, {
        'url': 'https://secure.nba.com/assets/amp/include/video/iframe.html?contentId=2016/10/29/0021600027boschaplay7&amp;adFree=false&amp;profile=71&amp;team=&amp;videoPlayerName=LAMPCVP',
        'only_matching': True,
    }]

    def _real_extract(self, url):
        qs = compat_parse_qs(compat_urllib_parse_urlparse(url).query)
        content_id = qs['contentId'][0]
        team = qs.get('team', [None])[0]
        if not team:
            return self.url_result(
                'https://watch.nba.com/video/' + content_id, NBAWatchIE.ie_key())
        video = self._call_api(team, content_id, {'videoid': content_id}, 'video')[0]
        return self._extract_video(video, team)


class NBAIE(NBABaseIE):
    IENAME = 'nba'
    _VALID_URL = NBABaseIE._VALID_URL_BASE + '(?!%s)video/(?P&lt;id&gt;(?:[^/]+/)*[^/?#&amp;]+)' % NBABaseIE._CHANNEL_PATH_REGEX
    _TESTS = [{
        'url': 'https://www.nba.com/bulls/video/teams/bulls/2020/12/04/3478774/1607105587854-20201204schedulereleasefinaldrupal-3478774',
        'info_dict': {
            'id': '45039',
            'ext': 'mp4',
            'title': 'AND WE BACK.',
            'description': 'Part 1 of our 2020-21 schedule is here! Watch our games on NBC Sports Chicago.',
            'duration': 94,
            'timestamp': 1607112000,
            'upload_date': '20201218',
        },
    }, {
        'url': 'https://www.nba.com/bucks/play#/video/teams%2Fbucks%2F2020%2F12%2F17%2F64860%2F1608252863446-Op_Dream_16x9-64860',
        'only_matching': True,
    }, {
        'url': 'https://www.nba.com/bucks/play#/video/wsc%2Fteams%2F2787C911AA1ACD154B5377F7577CCC7134B2A4B0',
        'only_matching': True,
    }]
    _CONTENT_ID_REGEX = r'videoID'

    def _extract_url_results(self, team, content_id):
        return self._embed_url_result(team, content_id)


class NBAChannelIE(NBABaseIE):
    IENAME = 'nba:channel'
    _VALID_URL = NBABaseIE._VALID_URL_BASE + '(?:%s)/(?P&lt;id&gt;[^/?#&amp;]+)' % NBABaseIE._CHANNEL_PATH_REGEX
    _TESTS = [{
        'url': 'https://www.nba.com/blazers/video/channel/summer_league',
        'info_dict': {
            'title': 'Summer League',
        },
        'playlist_mincount': 138,
    }, {
        'url': 'https://www.nba.com/bucks/play#/series/On%20This%20Date',
        'only_matching': True,
    }]
    _CONTENT_ID_REGEX = r'videoSubCategory'
    _PAGE_SIZE = 100

    def _fetch_page(self, team, channel, page):
        results = self._call_api(team, channel, {
            'channels': channel,
            'count': self._PAGE_SIZE,
            'offset': page * self._PAGE_SIZE,
        }, 'page %d' % (page + 1))
        for video in results:
            yield self._extract_video(video, team, False)

    def _extract_url_results(self, team, content_id):
        entries = OnDemandPagedList(
            functools.partial(self._fetch_page, team, content_id),
            self._PAGE_SIZE)
        return self.playlist_result(entries, playlist_title=content_id)
</PRE>
</div>
  </div>
</body>
</html>
