<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_pkg.py &amp; win_lgpo_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_pkg.py &amp; win_lgpo_1.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_pkg.py (3.1806617%)<th>win_lgpo_1.py (0.8430755%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(43-73)<td><a href="#" name="0">(39-63)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1584-1590)<td><a href="#" name="1">(5392-5405)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2145-2154)<td><a href="#" name="2">(7456-7462)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(2024-2026)<td><a href="#" name="3">(5469-5471)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1033-1038)<td><a href="#" name="4">(6912-6917)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_pkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a>import collections
2 import datetime
3 import errno
4 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
5 import os
6 import re
7 import sys
8 import time
9 import urllib.parse
10 from functools import cmp_to_key
11 import salt.payload
12 import salt.syspaths
13 import salt.utils.args
14 import salt.utils.data
15 import salt.utils.files
16 import salt.utils.hashutils
17 import salt.utils.path
18 import salt.utils.pkg
19 import salt.utils.platform
20 import salt.utils.versions
21 import salt.utils.win_functions
22 from salt.exceptions import (
23     CommandExecutionError,
24     MinionError,
25     SaltInvocationError,
26     SaltRenderError,
27 )
28 from salt.utils.versions import LooseVersion
29 log = logging.getLogger(__name__)
30 __virtualname__ =</b></font> "pkg"
31 def __virtual__():
32     if salt.utils.platform.is_windows():
33         return __virtualname__
34     return (False, "Module win_pkg: module only works on Windows systems")
35 def latest_version(*names, **kwargs):
36     if not names:
37         return ""
38     ret = {}
39     for name in names:
40         ret[name] = ""
41     saltenv = kwargs.get("saltenv", "base")
42     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
43     installed_pkgs = list_pkgs(versions_as_list=True, saltenv=saltenv, refresh=refresh)
44     log.trace("List of installed packages: %s", installed_pkgs)
45     for name in names:
46         latest_installed = "0"
47         if name in installed_pkgs:
48             log.trace("Determining latest installed version of %s", name)
49             try:
50                 latest_installed = sorted(
51                     installed_pkgs[name], key=cmp_to_key(_reverse_cmp_pkg_versions)
52                 ).pop()
53             except IndexError:
54                 log.warning(
55                     "%s was empty in pkg.list_pkgs return data, this is "
56                     "probably a bug in list_pkgs",
57                     name,
58                 )
59             else:
60                 log.debug(
61                     "Latest installed version of %s is %s", name, latest_installed
62                 )
63         pkg_info = _get_package_info(name, saltenv=saltenv)
64         log.trace("Raw winrepo pkg_info for %s is %s", name, pkg_info)
65         latest_available = _get_latest_pkg_version(pkg_info)
66         if latest_available:
67             log.debug(
68                 "Latest available version of package %s is %s", name, latest_available
69             )
70             if compare_versions(
71                 ver1=str(latest_available),
72                 oper="&gt;",
73                 ver2=str(latest_installed),
74             ):
75                 log.debug(
76                     "Upgrade of %s from %s to %s is available",
77                     name,
78                     latest_installed,
79                     latest_available,
80                 )
81                 ret[name] = latest_available
82             else:
83                 log.debug(
84                     "No newer version than %s of %s is available",
85                     latest_installed,
86                     name,
87                 )
88     if len(names) == 1:
89         return ret[names[0]]
90     return ret
91 def upgrade_available(name, **kwargs):
92     saltenv = kwargs.get("saltenv", "base")
93     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
94     return latest_version(name, saltenv=saltenv, refresh=refresh) != ""
95 def list_upgrades(refresh=True, **kwargs):
96     saltenv = kwargs.get("saltenv", "base")
97     refresh = salt.utils.data.is_true(refresh)
98     _refresh_db_conditional(saltenv, force=refresh)
99     installed_pkgs = list_pkgs(refresh=False, saltenv=saltenv)
100     available_pkgs = get_repo_data(saltenv).get("repo")
101     pkgs = {}
102     for pkg in installed_pkgs:
103         if pkg in available_pkgs:
104             latest_ver = latest_version(pkg, refresh=False, saltenv=saltenv)
105             if latest_ver:
106                 pkgs[pkg] = latest_ver
107     return pkgs
108 def list_available(*names, **kwargs):
109     if not names:
110         return ""
111     saltenv = kwargs.get("saltenv", "base")
112     refresh = salt.utils.data.is_true(kwargs.get("refresh", False))
113     _refresh_db_conditional(saltenv, force=refresh)
114     return_dict_always = salt.utils.data.is_true(
115         kwargs.get("return_dict_always", False)
116     )
117     if len(names) == 1 and not return_dict_always:
118         pkginfo = _get_package_info(names[0], saltenv=saltenv)
119         if not pkginfo:
120             return ""
121         versions = sorted(
122             list(pkginfo.keys()), key=cmp_to_key(_reverse_cmp_pkg_versions)
123         )
124     else:
125         versions = {}
126         for name in names:
127             pkginfo = _get_package_info(name, saltenv=saltenv)
128             if not pkginfo:
129                 continue
130             verlist = sorted(
131                 list(pkginfo.keys()) if pkginfo else [],
132                 key=cmp_to_key(_reverse_cmp_pkg_versions),
133             )
134             versions[name] = verlist
135     return versions
136 def version(*names, **kwargs):
137     saltenv = kwargs.get("saltenv", "base")
138     installed_pkgs = list_pkgs(saltenv=saltenv, refresh=kwargs.get("refresh", False))
139     if len(names) == 1:
140         return installed_pkgs.get(names[0], "")
141     ret = {}
142     for name in names:
143         ret[name] = installed_pkgs.get(name, "")
144     return ret
145 def list_pkgs(
146     versions_as_list=False, include_components=True, include_updates=True, **kwargs
147 ):
148     versions_as_list = salt.utils.data.is_true(versions_as_list)
149     if any(
150         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
151     ):
152         return {}
153     saltenv = kwargs.get("saltenv", "base")
154     refresh = salt.utils.data.is_true(kwargs.get("refresh", False))
155     _refresh_db_conditional(saltenv, force=refresh)
156     ret = {}
157     name_map = _get_name_map(saltenv)
158     for pkg_name, val_list in _get_reg_software(
159         include_components=include_components, include_updates=include_updates
160     ).items():
161         if pkg_name in name_map:
162             key = name_map[pkg_name]
163             for val in val_list:
164                 if val == "Not Found":
165                     pkg_info = _get_package_info(key, saltenv=saltenv)
166                     if not pkg_info:
167                         continue
168                     for pkg_ver in pkg_info.keys():
169                         if pkg_info[pkg_ver]["full_name"] == pkg_name:
170                             val = pkg_ver
171                 __salt__["pkg_resource.add_pkg"](ret, key, val)
172         else:
173             key = pkg_name
174             for val in val_list:
175                 __salt__["pkg_resource.add_pkg"](ret, key, val)
176     __salt__["pkg_resource.sort_pkglist"](ret)
177     if not versions_as_list:
178         __salt__["pkg_resource.stringify"](ret)
179     return ret
180 def _get_reg_software(include_components=True, include_updates=True):
181     reg_software = {}
182     def skip_component(hive, key, sub_key, use_32bit_registry):
183         if include_components:
184             return False
185         if __utils__["reg.value_exists"](
186             hive=hive,
187             key="{}\\{}".format(key, sub_key),
188             vname="SystemComponent",
189             use_32bit_registry=use_32bit_registry,
190         ):
191             if (
192                 __utils__["reg.read_value"](
193                     hive=hive,
194                     key="{}\\{}".format(key, sub_key),
195                     vname="SystemComponent",
196                     use_32bit_registry=use_32bit_registry,
197                 )["vdata"]
198                 &gt; 0
199             ):
200                 return True
201         return False
202     def skip_win_installer(hive, key, sub_key, use_32bit_registry):
203         products_key = "Software\\Classes\\Installer\\Products\\{0}"
204         if __utils__["reg.value_exists"](
205             hive=hive,
206             key="{}\\{}".format(key, sub_key),
207             vname="WindowsInstaller",
208             use_32bit_registry=use_32bit_registry,
209         ):
210             if (
211                 __utils__["reg.read_value"](
212                     hive=hive,
213                     key="{}\\{}".format(key, sub_key),
214                     vname="WindowsInstaller",
215                     use_32bit_registry=use_32bit_registry,
216                 )["vdata"]
217                 &gt; 0
218             ):
219                 squid = salt.utils.win_functions.guid_to_squid(sub_key)
220                 if not __utils__["reg.key_exists"](
221                     hive="HKLM",
222                     key=products_key.format(squid),
223                     use_32bit_registry=use_32bit_registry,
224                 ):
225                     return True
226         return False
227     def skip_uninstall_string(hive, key, sub_key, use_32bit_registry):
228         if not __utils__["reg.value_exists"](
229             hive=hive,
230             key="{}\\{}".format(key, sub_key),
231             vname="UninstallString",
232             use_32bit_registry=use_32bit_registry,
233         ):
234             return True
235         return False
236     def skip_release_type(hive, key, sub_key, use_32bit_registry):
237         if include_updates:
238             return False
239         skip_types = ["Hotfix", "Security Update", "Update Rollup"]
240         if __utils__["reg.value_exists"](
241             hive=hive,
242             key="{}\\{}".format(key, sub_key),
243             vname="ReleaseType",
244             use_32bit_registry=use_32bit_registry,
245         ):
246             if (
247                 __utils__["reg.read_value"](
248                     hive=hive,
249                     key="{}\\{}".format(key, sub_key),
250                     vname="ReleaseType",
251                     use_32bit_registry=use_32bit_registry,
252                 )["vdata"]
253                 in skip_types
254             ):
255                 return True
256         return False
257     def skip_parent_key(hive, key, sub_key, use_32bit_registry):
258         if __utils__["reg.value_exists"](
259             hive=hive,
260             key="{}\\{}".format(key, sub_key),
261             vname="ParentKeyName",
262             use_32bit_registry=use_32bit_registry,
263         ):
264             return True
265         return False
266     def add_software(hive, key, sub_key, use_32bit_registry):
267         d_name_regdata = __utils__["reg.read_value"](
268             hive=hive,
269             key="{}\\{}".format(key, sub_key),
270             vname="DisplayName",
271             use_32bit_registry=use_32bit_registry,
272         )
273         if (
274             not d_name_regdata["success"]
275             or d_name_regdata["vtype"] not in ["REG_SZ", "REG_EXPAND_SZ"]
276             or d_name_regdata["vdata"] in ["(value not set)", None, False]
277         ):
278             return
279         d_name = d_name_regdata["vdata"]
280         if not include_updates:
281             if re.match(r"^KB[0-9]{6}", d_name):
282                 return
283         d_vers_regdata = __utils__["reg.read_value"](
284             hive=hive,
285             key="{}\\{}".format(key, sub_key),
286             vname="DisplayVersion",
287             use_32bit_registry=use_32bit_registry,
288         )
289         d_vers = "Not Found"
290         if d_vers_regdata["success"] and d_vers_regdata["vtype"] in [
291             "REG_SZ",
292             "REG_EXPAND_SZ",
293             "REG_DWORD",
294         ]:
295             if isinstance(d_vers_regdata["vdata"], int):
296                 d_vers = str(d_vers_regdata["vdata"])
297             elif (
298                 d_vers_regdata["vdata"] and d_vers_regdata["vdata"] != "(value not set)"
299             ):  # Check for blank values
300                 d_vers = d_vers_regdata["vdata"]
301         reg_software.setdefault(d_name, []).append(d_vers)
302     kwargs = {
303         "hive": "HKLM",
304         "key": "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall",
305         "use_32bit_registry": False,
306     }
307     for sub_key in __utils__["reg.list_keys"](**kwargs):
308         kwargs["sub_key"] = sub_key
309         if skip_component(**kwargs):
310             continue
311         if skip_win_installer(**kwargs):
312             continue
313         if skip_uninstall_string(**kwargs):
314             continue
315         if skip_release_type(**kwargs):
316             continue
317         if skip_parent_key(**kwargs):
318             continue
319         add_software(**kwargs)
320     kwargs["use_32bit_registry"] = True
321     kwargs.pop("sub_key", False)
322     for sub_key in __utils__["reg.list_keys"](**kwargs):
323         kwargs["sub_key"] = sub_key
324         if skip_component(**kwargs):
325             continue
326         if skip_win_installer(**kwargs):
327             continue
328         if skip_uninstall_string(**kwargs):
329             continue
330         if skip_release_type(**kwargs):
331             continue
332         if skip_parent_key(**kwargs):
333             continue
334         add_software(**kwargs)
335     kwargs = {
336         "hive": "HKLM",
337         "key": "Software\\Classes\\Installer\\Products",
338         "use_32bit_registry": False,
339     }
340     userdata_key = (
341         "Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\"
342         "UserData\\S-1-5-18\\Products"
343     )
344     for sub_key in __utils__["reg.list_keys"](**kwargs):
345         if not __utils__["reg.key_exists"](
346             hive=kwargs["hive"], key="{}\\{}".format(userdata_key, sub_key)
347         ):
348             continue
349         kwargs["sub_key"] = sub_key
350         if skip_component(**kwargs):
351             continue
352         if skip_win_installer(**kwargs):
353             continue
354         add_software(**kwargs)
355     hive_hku = "HKU"
356     uninstall_key = "{0}\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
357     product_key = "{0}\\Software\\Microsoft\\Installer\\Products"
358     user_data_key = (
359         "Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\"
360         "UserData\\{0}\\Products\\{1}"
361     )
362     for user_guid in __utils__["reg.list_keys"](hive=hive_hku):
363         kwargs = {
364             "hive": hive_hku,
365             "key": uninstall_key.format(user_guid),
366             "use_32bit_registry": False,
367         }
368         if __utils__["reg.key_exists"](**kwargs):
369             for sub_key in __utils__["reg.list_keys"](**kwargs):
370                 kwargs["sub_key"] = sub_key
371                 if skip_component(**kwargs):
372                     continue
373                 if skip_win_installer(**kwargs):
374                     continue
375                 if skip_uninstall_string(**kwargs):
376                     continue
377                 if skip_release_type(**kwargs):
378                     continue
379                 if skip_parent_key(**kwargs):
380                     continue
381                 add_software(**kwargs)
382         kwargs = {
383             "hive": hive_hku,
384             "key": product_key.format(user_guid),
385             "use_32bit_registry": False,
386         }
387         if __utils__["reg.key_exists"](**kwargs):
388             for sub_key in __utils__["reg.list_keys"](**kwargs):
389                 kwargs = {
390                     "hive": "HKLM",
391                     "key": user_data_key.format(user_guid, sub_key),
392                     "use_32bit_registry": False,
393                 }
394                 if __utils__["reg.key_exists"](**kwargs):
395                     kwargs["sub_key"] = "InstallProperties"
396                     if skip_component(**kwargs):
397                         continue
398                     add_software(**kwargs)
399     for user_guid in __utils__["reg.list_keys"](hive=hive_hku, use_32bit_registry=True):
400         kwargs = {
401             "hive": hive_hku,
402             "key": uninstall_key.format(user_guid),
403             "use_32bit_registry": True,
404         }
405         if __utils__["reg.key_exists"](**kwargs):
406             for sub_key in __utils__["reg.list_keys"](**kwargs):
407                 kwargs["sub_key"] = sub_key
408                 if skip_component(**kwargs):
409                     continue
410                 if skip_win_installer(**kwargs):
411                     continue
412                 if skip_uninstall_string(**kwargs):
413                     continue
414                 if skip_release_type(**kwargs):
415                     continue
416                 if skip_parent_key(**kwargs):
417                     continue
418                 add_software(**kwargs)
419         kwargs = {
420             "hive": hive_hku,
421             "key": product_key.format(user_guid),
422             "use_32bit_registry": True,
423         }
424         if __utils__["reg.key_exists"](**kwargs):
425             for sub_key_2 in __utils__["reg.list_keys"](**kwargs):
426                 kwargs = {
427                     "hive": "HKLM",
428                     "key": user_data_key.format(user_guid, sub_key_2),
429                     "use_32bit_registry": True,
430                 }
431                 if __utils__["reg.key_exists"](**kwargs):
432                     kwargs["sub_key"] = "InstallProperties"
433                     if skip_component(**kwargs):
434                         continue
435                     add_software(**kwargs)
436     return reg_software
437 def _refresh_db_conditional(saltenv, **kwargs):
438     force = salt.utils.data.is_true(kwargs.pop("force", False))
439     failhard = salt.utils.data.is_true(kwargs.pop("failhard", False))
440     expired_max = __opts__["winrepo_cache_expire_max"]
441     expired_min = __opts__["winrepo_cache_expire_min"]
442     repo_details = _get_repo_details(saltenv)
443     if force and expired_min &gt; 0 and repo_details.winrepo_age &lt; expired_min:
444         log.info(
445             "Refresh skipped, age of winrepo metadata in seconds (%s) is less "
446             "than winrepo_cache_expire_min (%s)",
447             repo_details.winrepo_age,
448             expired_min,
449         )
450         force = False
451     refresh = (
452         True
453         if force
454         or repo_details.winrepo_age == -1
455         or repo_details.winrepo_age &gt; expired_max
456         else False
457     )
458     if not refresh:
459         log.debug(
460             "Using existing pkg metadata db for saltenv '%s' (age is %s)",
461             saltenv,
462             datetime.timedelta(seconds=repo_details.winrepo_age),
463         )
464         return True
465     if repo_details.winrepo_age == -1:
466         log.debug("No winrepo.p cache file for saltenv '%s', creating one now", saltenv)
467     results = refresh_db(saltenv=saltenv, verbose=False, failhard=failhard)
468     try:
469         return not bool(results.get("failed", 0))
470     except AttributeError:
471         return False
472 def refresh_db(**kwargs):
473     r"""
474     Generates the local software metadata database (`winrepo.p`) on the minion.
475     The database is stored in a serialized format located by default at the
476     following location:
477     ``C:\salt\var\cache\salt\minion\files\base\win\repo-ng\winrepo.p``
478     This module performs the following steps to generate the software metadata
479     database:
480     - Fetch the package definition files (.sls) from `winrepo_source_dir`
481       (default `salt://win/repo-ng`) and cache them in
482       `&lt;cachedir&gt;\files\&lt;saltenv&gt;\&lt;winrepo_source_dir&gt;`
483       (default: ``C:\salt\var\cache\salt\minion\files\base\win\repo-ng``)
484     - Call :py:func:`pkg.genrepo &lt;salt.modules.win_pkg.genrepo&gt;` to parse the
485       package definition files and generate the repository metadata database
486       file (`winrepo.p`)
487     - Return the report received from
488       :py:func:`pkg.genrepo &lt;salt.modules.win_pkg.genrepo&gt;`
489     The default winrepo directory on the master is `/srv/salt/win/repo-ng`. All
490     files that end with `.sls` in this and all subdirectories will be used to
491     generate the repository metadata database (`winrepo.p`).
492     .. note::
493         - Hidden directories (directories beginning with '`.`', such as
494           '`.git`') will be ignored.
495     .. note::
496         There is no need to call `pkg.refresh_db` every time you work with the
497         pkg module. Automatic refresh will occur based on the following minion
498         configuration settings:
499         - `winrepo_cache_expire_min`
500         - `winrepo_cache_expire_max`
501         However, if the package definition files have changed, as would be the
502         case if you are developing a new package definition, this function
503         should be called to ensure the minion has the latest information about
504         packages available to it.
505     .. warning::
506         Directories and files fetched from &lt;winrepo_source_dir&gt;
507         (`/srv/salt/win/repo-ng`) will be processed in alphabetical order. If
508         two or more software definition files contain the same name, the last
509         one processed replaces all data from the files processed before it.
510     For more information see
511     :ref:`Windows Software Repository &lt;windows-package-manager&gt;`
512     Arguments:
513     saltenv (str): Salt environment. Default: ``base``
514     verbose (bool):
515         Return a verbose data structure which includes 'success_list', a
516         list of all sls files and the package names contained within.
517         Default is 'False'
518     failhard (bool):
519         If ``True``, an error will be raised if any repo SLS files fails to
520         process. If ``False``, no error will be raised, and a dictionary
521         containing the full results will be returned.
522     Returns:
523         dict: A dictionary containing the results of the database refresh.
524     .. note::
525         A result with a `total: 0` generally means that the files are in the
526         wrong location on the master. Try running the following command on the
527         minion: `salt-call -l debug pkg.refresh saltenv=base`
528     .. warning::
529         When calling this command from a state using `module.run` be sure to
530         pass `failhard: False`. Otherwise the state will report failure if it
531         encounters a bad software definition file.
532     CLI Example:
533     .. code-block:: bash
534         salt '*' pkg.refresh_db
535         salt '*' pkg.refresh_db saltenv=base
536     Return repo details for the specified saltenv as a namedtuple
537         local_dest <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= os.sep.join(dirs)
538         winrepo_file = os.path.join(local_dest, "winrepo.p")  # Default
539         if not re.search(
540             r'[\/:*?"&lt;&gt;|]', __opts__[</b></font>"winrepo_cachefile"], flags=re.IGNORECASE
541         ):
542             winrepo_file = os.path.join(local_dest, __opts__["winrepo_cachefile"])
543         else:
544             log.error(
545                 "minion configuration option 'winrepo_cachefile' has been "
546                 "ignored as its value (%s) is invalid. Please ensure this "
547                 "option is set to a valid filename.",
548                 __opts__["winrepo_cachefile"],
549             )
550         system_root = os.environ.get("SystemRoot", r"C:\Windows")
551         if not salt.utils.path.safe_path(
552             path=local_dest, allow_path="\\".join([system_root, "TEMP"])
553         ):
554             raise CommandExecutionError(
555                 "Attempting to delete files from a possibly unsafe location: {}".format(
556                     local_dest
557                 )
558             )
559         __context__[contextkey] = (winrepo_source_dir, local_dest, winrepo_file)
560     try:
561         os.makedirs(local_dest)
562     except OSError as exc:
563         if exc.errno != errno.EEXIST:
564             raise CommandExecutionError(
565                 "Failed to create {}: {}".format(local_dest, exc)
566             )
567     winrepo_age = -1
568     try:
569         stat_result = os.stat(winrepo_file)
570         mtime = stat_result.st_mtime
571         winrepo_age = time.time() - mtime
572     except OSError as exc:
573         if exc.errno != errno.ENOENT:
574             raise CommandExecutionError(
575                 "Failed to get age of {}: {}".format(winrepo_file, exc)
576             )
577     except AttributeError:
578         log.warning("st_mtime missing from stat result %s", stat_result)
579     except TypeError:
580         log.warning("mtime of %s (%s) is an invalid type", winrepo_file, mtime)
581     repo_details = collections.namedtuple(
582         "RepoDetails",
583         ("winrepo_source_dir", "local_dest", "winrepo_file", "winrepo_age"),
584     )
585     return repo_details(winrepo_source_dir, local_dest, winrepo_file, winrepo_age)
586 def genrepo(**kwargs):
587     saltenv = kwargs.pop("saltenv", "base")
588     verbose = salt.utils.data.is_true(kwargs.pop("verbose", False))
589     failhard = salt.utils.data.is_true(kwargs.pop("failhard", True))
590     ret = {}
591     successful_verbose = {}
592     total_files_processed = 0
593     ret["repo"] = {}
594     ret["errors"] = {}
595     repo_details = _get_repo_details(saltenv)
596     for root, _, files in salt.utils.path.os_walk(
597         repo_details.local_dest, followlinks=False
598     ):
599         if re.search(r"[\\/]\..*", root):
600             log.debug("Skipping files in directory: %s", root)
601             continue
602         short_path = os.path.relpath(root, repo_details.local_dest)
603         if short_path == ".":
604             short_path = ""
605         for name in files:
606             if name.endswith(".sls"):
607                 total_files_processed += 1
608                 _repo_process_pkg_sls(
609                     os.path.join(root, name),
610                     os.path.join(short_path, name),
611                     ret,
612                     successful_verbose,
613                 )
614     with salt.utils.files.fopen(repo_details.winrepo_file, "wb") as repo_cache:
615         repo_cache.write(salt.payload.dumps(ret))
616     successful_count = len(successful_verbose)
617     error_count = len(ret["errors"])
618     if verbose:
619         results = {
620             "total": total_files_processed,
621             "success": successful_count,
622             "failed": error_count,
623             "success_list": successful_verbose,
624             "failed_list": ret["errors"],
625         }
626     else:
627         if error_count &gt; 0:
628             results = {
629                 "total": total_files_processed,
630                 "success": successful_count,
631                 "failed": error_count,
632                 "failed_list": ret["errors"],
633             }
634         else:
635             results = {
636                 "total": total_files_processed,
637                 "success": successful_count,
638                 "failed": error_count,
639             }
640     if error_count &gt; 0 and failhard:
641         raise CommandExecutionError(
642             "Error occurred while generating repo db", info=results
643         )
644     else:
645         return results
646 def _repo_process_pkg_sls(filename, short_path_name, ret, successful_verbose):
647     renderers = salt.loader.render(__opts__, __salt__)
648     def _failed_compile(prefix_msg, error_msg):
649         log.error("%s '%s': %s", prefix_msg, short_path_name, error_msg)
650         ret.setdefault("errors", {})[short_path_name] = [
651             "{}, {} ".format(prefix_msg, error_msg)
652         ]
653         return False
654     try:
655         config = salt.template.compile_template(
656             filename,
657             renderers,
658             __opts__["renderer"],
659             __opts__.get("renderer_blacklist", ""),
660             __opts__.get("renderer_whitelist", ""),
661         )
662     except SaltRenderError as exc:
663         return _failed_compile("Failed to compile", exc)
664     except Exception as exc:  # pylint: disable=broad-except
665         return _failed_compile("Failed to read", exc)
666     if config and isinstance(config, dict):
667         revmap = {}
668         errors = []
669         for pkgname, version_list in config.items():
670             if pkgname in ret["repo"]:
671                 log.error(
672                     "package '%s' within '%s' already defined, skipping",
673                     pkgname,
674                     short_path_name,
675                 )
676                 errors.append("package '{}' already defined".format(pkgname))
677                 break
678             for version_str, repodata in version_list.items():
679                 if not isinstance(version_str, str):
680                     log.error(
681                         "package '%s' within '%s', version number %s' is not a string",
682                         pkgname,
683                         short_path_name,
684                         version_str,
685                     )
686                     errors.append(
687                         "package '{}', version number {} is not a string".format(
688                             pkgname, version_str
689                         )
690                     )
691                     continue
692                 if not isinstance(repodata, dict):
693                     log.error(
694                         "package '%s' within '%s', repo data for "
695                         "version number %s is not defined as a dictionary",
696                         pkgname,
697                         short_path_name,
698                         version_str,
699                     )
700                     errors.append(
701                         "package '{}', repo data for "
702                         "version number {} is not defined as a dictionary".format(
703                             pkgname, version_str
704                         )
705                     )
706                     continue
707                 revmap[repodata["full_name"]] = pkgname
708         if errors:
709             ret.setdefault("errors", {})[short_path_name] = errors
710         else:
711             ret.setdefault("repo", {}).update(config)
712             ret.setdefault("name_map", {}).update(revmap)
713             successful_verbose[short_path_name] = list(config.keys())
714     elif config:
715         return _failed_compile("Compiled contents", "not a dictionary/hash")
716     else:
717         log.debug("No data within '%s' after processing", short_path_name)
718         successful_verbose[short_path_name] = []
719 def _get_source_sum(source_hash, file_path, saltenv):
720     ret = dict()
721     schemes = ("salt", "http", "https", "ftp", "swift", "s3", "file")
722     invalid_hash_msg = (
723         "Source hash '{}' format is invalid. It must be in "
724         "the format &lt;hash type&gt;=&lt;hash&gt;".format(source_hash)
725     )
726     source_hash = str(source_hash)
727     source_hash_scheme = urllib.parse.urlparse(source_hash).scheme
728     if source_hash_scheme in schemes:
729         try:
730             cached_hash_file = __salt__["cp.cache_file"](source_hash, saltenv)
731         except MinionError as exc:
732             log.exception("Failed to cache %s", source_hash, exc_info=exc)
733             raise
734         if not cached_hash_file:
735             raise CommandExecutionError(
736                 "Source hash file {} not found".format(source_hash)
737             )
738         ret = __salt__["file.extract_hash"](cached_hash_file, "", file_path)
739         if ret is None:
740             raise SaltInvocationError(invalid_hash_msg)
741     else:
742         items = source_hash.split("=", 1)
743         if len(items) != 2:
744             invalid_hash_msg = "{}, or it must be a supported protocol: {}".format(
745                 invalid_hash_msg, ", ".join(schemes)
746             )
747             raise SaltInvocationError(invalid_hash_msg)
748         ret["hash_type"], ret["hsum"] = (item.strip().lower() for item in items)
749     return ret
750 def _get_msiexec(use_msiexec):
751     if use_msiexec is False:
752         return False, ""
753     if isinstance(use_msiexec, str):
754         if os.path.isfile(use_msiexec):
755             return True, use_msiexec
756         else:
757             log.warning(
758                 "msiexec path '%s' not found. Using system registered msiexec instead",
759                 use_msiexec,
760             )
761             use_msiexec = True
762     if use_msiexec is True:
763         return True, "msiexec"
764 def install(name=None, refresh=False, pkgs=None, **kwargs):
765     r"""
766     Install the passed package(s) on the system using winrepo
767     Args:
768         name (str):
769             The name of a single package, or a comma-separated list of packages
770             to install. (no spaces after the commas)
771         refresh (bool):
772             Boolean value representing whether or not to refresh the winrepo db.
773             Default ``False``.
774         pkgs (list):
775             A list of packages to install from a software repository. All
776             packages listed under ``pkgs`` will be installed via a single
777             command.
778             You can specify a version by passing the item as a dict:
779             CLI Example:
780             .. code-block:: bash
781                 salt '*' pkg.install pkgs='["foo", "bar"]'
782                 salt '*' pkg.install pkgs='["foo", {"bar": "1.2.3"}]'
783     Kwargs:
784         version (str):
785             The specific version to install. If omitted, the latest version will
786             be installed. Recommend for use when installing a single package.
787             If passed with a list of packages in the ``pkgs`` parameter, the
788             version will be ignored.
789             CLI Example:
790              .. code-block:: bash
791                 salt '*' pkg.install pkgs="['foo', 'bar']" version=1.2.3
792             If passed with a comma separated list in the ``name`` parameter, the
793             version will apply to all packages in the list.
794             CLI Example:
795              .. code-block:: bash
796                 salt '*' pkg.install foo,bar version=1.2.3
797         extra_install_flags (str):
798             Additional install flags that will be appended to the
799             ``install_flags`` defined in the software definition file. Only
800             applies when single package is passed.
801         saltenv (str):
802             Salt environment. Default 'base'
803         report_reboot_exit_codes (bool):
804             If the installer exits with a recognized exit code indicating that
805             a reboot is required, the module function
806                *win_system.set_reboot_required_witnessed*
807             will be called, preserving the knowledge of this event for the
808             remainder of the current boot session. For the time being, 3010 is
809             the only recognized exit code. The value of this param defaults to
810             True.
811             .. versionadded:: 2016.11.0
812     Returns:
813         dict: Return a dict containing the new package names and versions. If
814         the package is already installed, an empty dict is returned.
815         If the package is installed by ``pkg.install``:
816         .. code-block:: cfg
817             {'&lt;package&gt;': {'old': '&lt;old-version&gt;',
818                            'new': '&lt;new-version&gt;'}}
819     The following example will refresh the winrepo and install a single
820     package, 7zip.
821     CLI Example:
822     .. code-block:: bash
823         salt '*' pkg.install 7zip refresh=True
824     CLI Example:
825     .. code-block:: bash
826         salt '*' pkg.install 7zip
827         salt '*' pkg.install 7zip,filezilla
828         salt '*' pkg.install pkgs='["7zip","filezilla"]'
829     WinRepo Definition File Examples:
830     The following example demonstrates the use of ``cache_file``. This would be
831     used if you have multiple installers in the same directory that use the
832     same ``install.ini`` file and you don't want to download the additional
833     installers.
834     .. code-block:: bash
835         ntp:
836           4.2.8:
837             installer: 'salt://win/repo/ntp/ntp-4.2.8-win32-setup.exe'
838             full_name: Meinberg NTP Windows Client
839             locale: en_US
840             reboot: False
841             cache_file: 'salt://win/repo/ntp/install.ini'
842             install_flags: '/USEFILE=C:\salt\var\cache\salt\minion\files\base\win\repo\ntp\install.ini'
843             uninstaller: 'NTP/uninst.exe'
844     The following example demonstrates the use of ``cache_dir``. It assumes a
845     file named ``install.ini`` resides in the same directory as the installer.
846     .. code-block:: bash
847         ntp:
848           4.2.8:
849             installer: 'salt://win/repo/ntp/ntp-4.2.8-win32-setup.exe'
850             full_name: Meinberg NTP Windows Client
851             locale: en_US
852             reboot: False
853             cache_dir: True
854             install_flags: '/USEFILE=C:\salt\var\cache\salt\minion\files\base\win\repo\ntp\install.ini'
855             uninstaller: 'NTP/uninst.exe'
856         installer <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= pkginfo[version_num].get("installer", "")
857         cache_dir = pkginfo[version_num].get("cache_dir", False)
858         cache_file = pkginfo[version_num].get("cache_file", "")
859         if not installer:
860             log.error(</b></font>
861                 "No installer configured for version %s of package %s",
862                 version_num,
863                 pkg_name,
864             )
865             ret[pkg_name] = {"no installer": version_num}
866             continue
867         if __salt__["config.valid_fileproto"](installer):
868             if cache_dir and installer.startswith("salt:"):
869                 path, _ = os.path.split(installer)
870                 try:
871                     __salt__["cp.cache_dir"](
872                         path=path,
873                         saltenv=saltenv,
874                         include_empty=False,
875                         include_pat=None,
876                         exclude_pat="E@init.sls$",
877                     )
878                 except MinionError as exc:
879                     msg = "Failed to cache {}".format(path)
880                     log.exception(msg, exc_info=exc)
881                     return "{}\n{}".format(msg, exc)
882             if cache_file and cache_file.startswith("salt:"):
883                 cached_file = __salt__["cp.is_cached"](cache_file, saltenv)
884                 if not cached_file:
885                     try:
886                         cached_file = __salt__["cp.cache_file"](cache_file, saltenv)
887                     except MinionError as exc:
888                         msg = "Failed to cache {}".format(cache_file)
889                         log.exception(msg, exc_info=exc)
890                         return "{}\n{}".format(msg, exc)
891                 if __salt__["cp.hash_file"](cache_file, saltenv) != __salt__[
892                     "cp.hash_file"
893                 ](cached_file):
894                     try:
895                         cached_file = __salt__["cp.cache_file"](cache_file, saltenv)
896                     except MinionError as exc:
897                         msg = "Failed to cache {}".format(cache_file)
898                         log.exception(msg, exc_info=exc)
899                         return "{}\n{}".format(msg, exc)
900                     if not cached_file:
901                         log.error("Unable to cache %s", cache_file)
902                         ret[pkg_name] = {"failed to cache cache_file": cache_file}
903                         continue
904             cached_pkg = __salt__["cp.is_cached"](installer, saltenv)
905             if not cached_pkg:
906                 try:
907                     cached_pkg = __salt__["cp.cache_file"](installer, saltenv)
908                 except MinionError as exc:
909                     msg = "Failed to cache {}".format(installer)
910                     log.exception(msg, exc_info=exc)
911                     return "{}\n{}".format(msg, exc)
912                 if not cached_pkg:
913                     log.error(
914                         "Unable to cache file %s from saltenv: %s", installer, saltenv
915                     )
916                     ret[pkg_name] = {"unable to cache": installer}
917                     continue
918             if installer.startswith("salt:"):
919                 if __salt__["cp.hash_file"](installer, saltenv) != __salt__[
920                     "cp.hash_file"
921                 ](cached_pkg):
922                     try:
923                         cached_pkg = __salt__["cp.cache_file"](installer, saltenv)
924                     except MinionError as exc:
925                         msg = "Failed to cache {}".format(installer)
926                         log.exception(msg, exc_info=exc)
927                         return "{}\n{}".format(msg, exc)
928                     if not cached_pkg:
929                         log.error("Unable to cache %s", installer)
930                         ret[pkg_name] = {"unable to cache": installer}
931                         continue
932         else:
933             cached_pkg = installer
934         cached_pkg = cached_pkg.replace("/", "\\")
935         cache_path = os.path.dirname(cached_pkg)
936         source_hash = pkginfo[version_num].get("source_hash", False)
937         if source_hash:
938             source_sum = _get_source_sum(source_hash, cached_pkg, saltenv)
939             log.debug(
940                 "pkg.install: Source %s hash: %s",
941                 source_sum["hash_type"],
942                 source_sum["hsum"],
943             )
944             cached_pkg_sum = salt.utils.hashutils.get_hash(
945                 cached_pkg, source_sum["hash_type"]
946             )
947             log.debug(
948                 "pkg.install: Package %s hash: %s",
949                 source_sum["hash_type"],
950                 cached_pkg_sum,
951             )
952             if source_sum["hsum"] != cached_pkg_sum:
953                 raise SaltInvocationError(
954                     "Source hash '{}' does not match package hash '{}'".format(
955                         source_sum["hsum"], cached_pkg_sum
956                     )
957                 )
958             log.debug("pkg.install: Source hash matches package hash.")
959         install_flags = pkginfo[version_num].get("install_flags", "")
960         if options and options.get("extra_install_flags"):
961             install_flags = "{} {}".format(
962                 install_flags, options.get("extra_install_flags", "")
963             )
964         use_msiexec, msiexec = _get_msiexec(pkginfo[version_num].get("msiexec", False))
965         cmd_shell = os.getenv(
966             "ComSpec", "{}\\system32\\cmd.exe".format(os.getenv("WINDIR"))
967         )
968         if use_msiexec:
969             arguments = '"{}" /I "{}"'.format(msiexec, cached_pkg)
970             if pkginfo[version_num].get("allusers", True):
971                 arguments = "{} ALLUSERS=1".format(arguments)
972         else:
973             arguments = '"{}"'.format(cached_pkg)
974         if install_flags:
975             arguments = "{} {}".format(arguments, install_flags)
976         if pkginfo[version_num].get("use_scheduler", False):
977             __salt__["task.create_task"](
978                 name="update-salt-software",
979                 user_name="System",
980                 force=True,
981                 action_type="Execute",
982                 cmd=cmd_shell,
983                 arguments='/s /c "{}"'.format(arguments),
984                 start_in=cache_path,
985                 trigger_type="Once",
986                 start_date="1975-01-01",
987                 start_time="01:00",
988                 ac_only=False,
989                 stop_if_on_batteries=False,
990             )
991             if (
992                 re.search(
993                     r"salt[\s_.-]*minion", pkg_name, flags=re.IGNORECASE + re.UNICODE
994                 )
995                 is not None
996             ):
997                 ret[pkg_name] = {"install status": "task started"}
998                 if not __salt__["task.run"](name="update-salt-software"):
999                     log.error(
1000                         "Scheduled Task failed to run. Failed to install %s", pkg_name
1001                     )
1002                     ret[pkg_name] = {"install status": "failed"}
1003                 else:
1004                     t_end = time.time() + 5
1005                     while time.time() &lt; t_end:
1006                         time.sleep(0.25)
1007                         task_running = (
1008                             __salt__["task.status"]("update-salt-software") == "Running"
1009                         )
1010                         if task_running:
1011                             break
1012                     if not task_running:
1013                         log.error(
1014                             "Scheduled Task failed to run. Failed to install %s",
1015                             pkg_name,
1016                         )
1017                         ret[pkg_name] = {"install status": "failed"}
1018             else:
1019                 if not __salt__["task.run_wait"](name="update-salt-software"):
1020                     log.error(
1021                         "Scheduled Task failed to run. Failed to install %s", pkg_name
1022                     )
1023                     ret[pkg_name] = {"install status": "failed"}
1024         else:
1025             result = __salt__["cmd.run_all"](
1026                 '"{}" /s /c "{}"'.format(cmd_shell, arguments),
1027                 cache_path,
1028                 output_loglevel="trace",
1029                 python_shell=False,
1030                 redirect_stderr=True,
1031             )
1032             if not result["retcode"]:
1033                 ret[pkg_name] = {"install status": "success"}
1034                 changed.append(pkg_name)
1035             elif result["retcode"] == 3010:
1036                 report_reboot_exit_codes = kwargs.pop("report_reboot_exit_codes", True)
1037                 if report_reboot_exit_codes:
1038                     __salt__["system.set_reboot_required_witnessed"]()
1039                 ret[pkg_name] = {"install status": "success, reboot required"}
1040                 changed.append(pkg_name)
1041             elif result["retcode"] == 1641:
1042                 ret[pkg_name] = {"install status": "success, reboot initiated"}
1043                 changed.append(pkg_name)
1044             else:
1045                 log.error(
1046                     "Failed to install %s; retcode: %s; installer output: %s",
1047                     pkg_name,
1048                     result["retcode"],
1049                     result["stdout"],
1050                 )
1051                 ret[pkg_name] = {"install status": "failed"}
1052     new = list_pkgs(saltenv=saltenv, refresh=False)
1053     __salt__["pkg_resource.stringify"](old)
1054     difference = salt.utils.data.compare_dicts(old, new)
1055     ret.update(difference)
1056     return ret
1057 def upgrade(**kwargs):
1058     log.warning("pkg.upgrade not implemented on Windows yet")
1059     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
1060     saltenv = kwargs.get("saltenv", "base")
1061     log.warning(
1062         "pkg.upgrade not implemented on Windows yet refresh:%s saltenv:%s",
1063         refresh,
1064         saltenv,
1065     )
1066     return {}
1067 def remove(name=None, pkgs=None, **kwargs):
1068     saltenv = kwargs.get("saltenv", "base")
1069     refresh = salt.utils.data.is_true(kwargs.get("refresh", False))
1070     ret = {}
1071     if not name and not pkgs:
1072         return "Must pass a single package or a list of packages"
1073     pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs, **kwargs)[0]
1074     old = list_pkgs(saltenv=saltenv, refresh=refresh, versions_as_list=True)
1075     changed = []  # list of changed package names
1076     for pkgname, version_num in pkg_params.items():
1077         pkginfo = _get_package_info(pkgname, saltenv=saltenv)
1078         if not pkginfo:
1079             msg = "Unable to locate package {}".format(pkgname)
1080             log.error(msg)
1081             ret[pkgname] = msg
1082             continue
1083         if pkgname not in old:
1084             log.debug(
1085                 "%s %s not installed", pkgname, version_num if version_num else ""
1086             )
1087             ret[pkgname] = {"current": "not installed"}
1088             continue
1089         removal_targets = []
1090         if version_num is not None:
1091             version_num = str(version_num)
1092         if version_num is None:
1093             for ver_install in old[pkgname]:
1094                 if ver_install not in pkginfo and "latest" in pkginfo:
1095                     log.debug(
1096                         "%s %s using package latest entry to to remove",
1097                         pkgname,
1098                         version_num,
1099                     )
1100                     removal_targets.append("latest")
1101                 else:
1102                     removal_targets.append(ver_install)
1103         else:
1104             if version_num in pkginfo:
1105                 if version_num in old[pkgname]:
1106                     removal_targets.append(version_num)
1107                 else:
1108                     log.debug("%s %s not installed", pkgname, version_num)
1109                     ret[pkgname] = {"current": "{} not installed".format(version_num)}
1110                     continue
1111             elif "latest" in pkginfo:
1112                 log.debug(
1113                     "%s %s using package latest entry to to remove",
1114                     pkgname,
1115                     version_num,
1116                 )
1117                 removal_targets.append("latest")
1118         if not removal_targets:
1119             log.error(
1120                 "%s %s no definition to remove this version", pkgname, version_num
1121             )
1122             ret[pkgname] = {
1123                 "current": "{} no definition, cannot removed".format(version_num)
1124             }
1125             continue
1126 <a name="3"></a>
1127         for target in removal_targets:
1128             uninstaller <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= pkginfo[target].get("uninstaller", "")
1129             cache_dir = pkginfo[target].get("cache_dir", False)
1130             uninstall_flags = pkginfo[target].get(</b></font>"uninstall_flags", "")
1131             if not uninstaller and uninstall_flags:
1132                 uninstaller = pkginfo[target].get("installer", "")
1133             if not uninstaller:
1134                 log.error(
1135                     "No installer or uninstaller configured for package %s",
1136                     pkgname,
1137                 )
1138                 ret[pkgname] = {"no uninstaller defined": target}
1139                 continue
1140             if uninstaller.startswith(("salt:", "http:", "https:", "ftp:")):
1141                 if cache_dir and uninstaller.startswith("salt:"):
1142                     path, _ = os.path.split(uninstaller)
1143                     try:
1144                         __salt__["cp.cache_dir"](
1145                             path, saltenv, False, None, "E@init.sls$"
1146                         )
1147                     except MinionError as exc:
1148                         msg = "Failed to cache {}".format(path)
1149                         log.exception(msg, exc_info=exc)
1150                         return "{}\n{}".format(msg, exc)
1151                 cached_pkg = __salt__["cp.is_cached"](uninstaller, saltenv)
1152                 if not cached_pkg:
1153                     try:
1154                         cached_pkg = __salt__["cp.cache_file"](uninstaller, saltenv)
1155                     except MinionError as exc:
1156                         msg = "Failed to cache {}".format(uninstaller)
1157                         log.exception(msg, exc_info=exc)
1158                         return "{}\n{}".format(msg, exc)
1159                     if not cached_pkg:
1160                         log.error("Unable to cache %s", uninstaller)
1161                         ret[pkgname] = {"unable to cache": uninstaller}
1162                         continue
1163                 if uninstaller.startswith("salt:"):
1164                     if __salt__["cp.hash_file"](uninstaller, saltenv) != __salt__[
1165                         "cp.hash_file"
1166                     ](cached_pkg):
1167                         try:
1168                             cached_pkg = __salt__["cp.cache_file"](uninstaller, saltenv)
1169                         except MinionError as exc:
1170                             msg = "Failed to cache {}".format(uninstaller)
1171                             log.exception(msg, exc_info=exc)
1172                             return "{}\n{}".format(msg, exc)
1173                         if not cached_pkg:
1174                             log.error("Unable to cache %s", uninstaller)
1175                             ret[pkgname] = {"unable to cache": uninstaller}
1176                             continue
1177             else:
1178                 cached_pkg = os.path.expandvars(uninstaller)
1179             cached_pkg = cached_pkg.replace("/", "\\")
1180             cache_path, _ = os.path.split(cached_pkg)
1181             if kwargs.get("extra_uninstall_flags"):
1182                 uninstall_flags = "{} {}".format(
1183                     uninstall_flags, kwargs.get("extra_uninstall_flags", "")
1184                 )
1185             use_msiexec, msiexec = _get_msiexec(pkginfo[target].get("msiexec", False))
1186             cmd_shell = os.getenv(
1187                 "ComSpec", "{}\\system32\\cmd.exe".format(os.getenv("WINDIR"))
1188             )
1189             if use_msiexec:
1190                 arguments = '"{}" /X "{}"'.format(msiexec, cached_pkg)
1191             else:
1192                 arguments = '"{}"'.format(cached_pkg)
1193             if uninstall_flags:
1194                 arguments = "{} {}".format(arguments, uninstall_flags)
1195             changed.append(pkgname)
1196             if pkginfo[target].get("use_scheduler", False):
1197                 __salt__["task.create_task"](
1198                     name="update-salt-software",
1199                     user_name="System",
1200                     force=True,
1201                     action_type="Execute",
1202                     cmd=cmd_shell,
1203                     arguments='/s /c "{}"'.format(arguments),
1204 <a name="2"></a>                    start_in=cache_path,
1205                     trigger_type="Once",
1206                     start_date="1975-01-01",
1207                     start_time<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="01:00",
1208                     ac_only=False,
1209                     stop_if_on_batteries=False,
1210                 )
1211                 if not __salt__["task.run_wait"](name="update-salt-software"):
1212                     log.error(
1213                         "Scheduled Task failed to run. Failed to remove %s", pkgname
1214                     )
1215                     ret[pkgname] = {"uninstall status"</b></font>: "failed"}
1216             else:
1217                 result = __salt__["cmd.run_all"](
1218                     '"{}" /s /c "{}"'.format(cmd_shell, arguments),
1219                     output_loglevel="trace",
1220                     python_shell=False,
1221                     redirect_stderr=True,
1222                 )
1223                 if not result["retcode"]:
1224                     ret[pkgname] = {"uninstall status": "success"}
1225                     changed.append(pkgname)
1226                 elif result["retcode"] == 3010:
1227                     report_reboot_exit_codes = kwargs.pop(
1228                         "report_reboot_exit_codes", True
1229                     )
1230                     if report_reboot_exit_codes:
1231                         __salt__["system.set_reboot_required_witnessed"]()
1232                     ret[pkgname] = {"uninstall status": "success, reboot required"}
1233                     changed.append(pkgname)
1234                 elif result["retcode"] == 1641:
1235                     ret[pkgname] = {"uninstall status": "success, reboot initiated"}
1236                     changed.append(pkgname)
1237                 else:
1238                     log.error(
1239                         "Failed to remove %s; retcode: %s; uninstaller output: %s",
1240                         pkgname,
1241                         result["retcode"],
1242                         result["stdout"],
1243                     )
1244                     ret[pkgname] = {"uninstall status": "failed"}
1245     new = list_pkgs(saltenv=saltenv, refresh=False)
1246     __salt__["pkg_resource.stringify"](old)
1247     difference = salt.utils.data.compare_dicts(old, new)
1248     found_chgs = all(name in difference for name in changed)
1249     end_t = time.time() + 3  # give it 3 seconds to catch up.
1250     while not found_chgs and time.time() &lt; end_t:
1251         time.sleep(0.5)
1252         new = list_pkgs(saltenv=saltenv, refresh=False)
1253         difference = salt.utils.data.compare_dicts(old, new)
1254         found_chgs = all(name in difference for name in changed)
1255     if not found_chgs:
1256         log.warning("Expected changes for package removal may not have occurred")
1257     ret.update(difference)
1258     return ret
1259 def purge(name=None, pkgs=None, **kwargs):
1260     return remove(name=name, pkgs=pkgs, **kwargs)
1261 def get_repo_data(saltenv="base"):
1262     repo_details = _get_repo_details(saltenv)
1263     if repo_details.winrepo_age == -1:
1264         log.debug("No winrepo.p cache file. Refresh pkg db now.")
1265         refresh_db(saltenv=saltenv)
1266     if "winrepo.data" in __context__:
1267         log.trace("get_repo_data returning results from __context__")
1268         return __context__["winrepo.data"]
1269     else:
1270         log.trace("get_repo_data called reading from disk")
1271     try:
1272         with salt.utils.files.fopen(repo_details.winrepo_file, "rb") as repofile:
1273             try:
1274                 repodata = salt.utils.data.decode(
1275                     salt.payload.loads(repofile.read()) or {}
1276                 )
1277                 __context__["winrepo.data"] = repodata
1278                 return repodata
1279             except Exception as exc:  # pylint: disable=broad-except
1280                 log.exception(exc)
1281                 return {}
1282     except OSError as exc:
1283         log.exception("Not able to read repo file: %s", exc)
1284         return {}
1285 def _get_name_map(saltenv="base"):
1286     u_name_map = {}
1287     name_map = get_repo_data(saltenv).get("name_map", {})
1288     return name_map
1289 def get_package_info(name, saltenv="base"):
1290     return _get_package_info(name=name, saltenv=saltenv)
1291 def _get_package_info(name, saltenv="base"):
1292     return get_repo_data(saltenv).get("repo", {}).get(name, {})
1293 def _reverse_cmp_pkg_versions(pkg1, pkg2):
1294     return 1 if LooseVersion(pkg1) &gt; LooseVersion(pkg2) else -1
1295 def _get_latest_pkg_version(pkginfo):
1296     if len(pkginfo) == 1:
1297         return next(iter(pkginfo.keys()))
1298     try:
1299         return sorted(pkginfo, key=cmp_to_key(_reverse_cmp_pkg_versions)).pop()
1300     except IndexError:
1301         return ""
1302 def compare_versions(ver1="", oper="==", ver2=""):
1303     if not ver1:
1304         raise SaltInvocationError("compare_version, ver1 is blank")
1305     if not ver2:
1306         raise SaltInvocationError("compare_version, ver2 is blank")
1307     if ver1 == "latest":
1308         ver1 = str(sys.maxsize)
1309     if ver2 == "latest":
1310         ver2 = str(sys.maxsize)
1311     if ver1 == "Not Found":
1312         ver1 = "0.0.0.0.0"
1313     if ver2 == "Not Found":
1314         ver2 = "0.0.0.0.0"
1315     return salt.utils.versions.compare(ver1, oper, ver2, ignore_epoch=True)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import csv
2 import ctypes
3 import glob
4 import io
5 import locale
6 import logging
7 import os
8 import re
9 import tempfile
10 import time
11 import uuid
12 import zlib
13 import salt.utils.dictupdate as dictupdate
14 import salt.utils.files
15 import salt.utils.path
16 import salt.utils.platform
17 import salt.utils.stringutils
18 import salt.utils.win_lgpo_netsh
19 from salt.exceptions import CommandExecutionError, SaltInvocationError
20 from salt.serializers.configparser import deserialize
21 log = logging.getLogger(__name__)
22 __virtualname__ =</b></font> "lgpo"
23 __func_alias__ = {"set_": "set"}
24 UUID = uuid.uuid4().hex
25 adm_policy_name_map = {True: {}, False: {}}
26 HAS_WINDOWS_MODULES = False
27 TRUE_VALUE_XPATH = None
28 FALSE_VALUE_XPATH = None
29 ELEMENTS_XPATH = None
30 ENABLED_VALUE_XPATH = None
31 DISABLED_VALUE_XPATH = None
32 ENABLED_LIST_XPATH = None
33 DISABLED_LIST_XPATH = None
34 VALUE_XPATH = None
35 TRUE_LIST_XPATH = None
36 FALSE_LIST_XPATH = None
37 REGKEY_XPATH = None
38 POLICY_ANCESTOR_XPATH = None
39 ALL_CLASS_POLICY_XPATH = None
40 ADML_DISPLAY_NAME_XPATH = None
41 VALUE_LIST_XPATH = None
42 ENUM_ITEM_DISPLAY_NAME_XPATH = None
43 ADMX_SEARCH_XPATH = None
44 ADML_SEARCH_XPATH = None
45 ADMX_DISPLAYNAME_SEARCH_XPATH = None
46 PRESENTATION_ANCESTOR_XPATH = None
47 TEXT_ELEMENT_XPATH = None
48 try:
49     import struct
50     import lxml
51     import win32net
52     import win32security
53     from lxml import etree
54     from salt.utils.win_reg import Registry
55     HAS_WINDOWS_MODULES = True
56     TRUE_VALUE_XPATH = etree.XPath('.//*[local-name() = "trueValue"]')
57     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
58     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
59     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
60     DISABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "disabledValue"]')
61     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
62     DISABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "disabledList"]')
63     VALUE_XPATH = etree.XPath('.//*[local-name() = "value"]')
64     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
65     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
66     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
67     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
68     ALL_CLASS_POLICY_XPATH = etree.XPath(
69         '//*[local-name() = "policy" and (@*[local-name() = "class"] = "Both" or'
70         ' @*[local-name() = "class"] = $registry_class)]'
71     )
72     ADML_DISPLAY_NAME_XPATH = etree.XPath(
73         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
74         " $displayNameId]"
75     )
76     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
77     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
78         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
79         " $display_name]]"
80     )
81     ADMX_SEARCH_XPATH = etree.XPath(
82         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
83         ' (@*[local-name() = "class"] = "Both" or @*[local-name() = "class"] ='
84         " $registry_class)]"
85     )
86     ADML_SEARCH_XPATH = etree.XPath(
87         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
88     )
89     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
90         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
91         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
92         ' "class"] = $registry_class) ]'
93     )
94     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
95         'ancestor::*[local-name() = "presentation"]'
96     )
97     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
98     windll = ctypes.windll.kernel32
99     INSTALL_LANGUAGE = locale.windows_locale.get(
100         windll.GetSystemDefaultUILanguage(), "en_US"
101     ).replace("_", "-")
102 except ImportError:
103     HAS_WINDOWS_MODULES = False
104 class _policy_info:
105     r"""
106     Policy Helper Class
107     ===================
108     The format of the policy dict is as follows:
109     The top most two key/value pairs in the dict divide the policies object into
110     the two sections of local group policy, using the keys "Machine" and "User".
111     The value make-up of these dicts are described below in "Policy Section
112     Definition"
113     Policy Section Definition
114     -------------------------
115     A policy section dict has two required key/value pairs:
116     ============  ==============================================================
117     Key
118     ============  ==============================================================
119     lgpo_section  String matching how the policy section is displayed in the mmc
120                   snap-in ("Computer Configuration" for "Machine" and "User
121                   Configuration" for "User")
122     policies      a dict containing the non-Administrative template policy
123                   definitions, the key for each item is a short/unique
124                   identifier for the policy, the value is described below in
125                   "Policies Definition"
126     ============  ==============================================================
127     Policies Definition
128     -------------------
129     A policies definition item describes the particular policy. There are three
130     child key/value pairs shared with all policy types:
131     ============  ==============================================================
132     Key           Value
133     ============  ==============================================================
134     lgpo_section  A list containing the hierarchical path to the policy in the
135                   gpedit mmc snap-in.
136     Policy        A string containing the name of the policy in the gpedit mmc
137                   snap-in
138     Settings      An object which describes valid settings for the policy. This
139                   can be None for no validation, a list of possible settings, or
140                   a dict with the following key/value pairs:
141                   - **Function:** The class function to use to validate the
142                     setting
143                   - **Args:** A dict of kwargs to pass to the class function
144     ============  ==============================================================
145     Additionally, each policies definition will contain a key/value pair that
146     defines the mechanism that will be used to configure the policy. The
147     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
148     Registry Mechanism
149     ------------------
150     Some policies simply set values in the Windows registry. The value of this
151     key is a dict with the following make-up:
152     =====  =====================================================================
153     Key    Value
154     =====  =====================================================================
155     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
156     Path   A string containing the registry key path, such as
157            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
158     Value  A string containing the name of the registry value, such as
159            **restrictanonymous**
160     Type   A string containing the registry type of the value, such as
161            ``REG_DWORD``
162     =====  =====================================================================
163     Secedit Mechanism
164     -----------------
165     Some policies are configurable via the "secedit.exe" executable. The value
166     of this key is a dict with the following make-up:
167     =======  ===================================================================
168     Key      Value
169     =======  ===================================================================
170     Option   A string containing the name of the policy as it appears in an
171              export from secedit, such as **PasswordComplexity**
172     Section  A string containing the name of the section in which the "Option"
173              value appears in an export from ``secedit``, such as "System
174              Access"
175     =======  ===================================================================
176     LsaRights Mechanism
177     -------------------
178     LSA Rights policies are configured via the LsaRights mechanism. The value of
179     this key is a dict with the following make-up:
180     ======  ====================================================================
181     Key     Value
182     ======  ====================================================================
183     Option  A string containing the programmatic name of the Lsa Right, such as
184             **SeNetworkLogonRight**
185     ======  ====================================================================
186     NetUserModal Mechanism
187     ----------------------
188     Some policies are configurable by the **NetUserModalGet** and
189     **NetUserModalSet** function from pywin32.  The value of this key is a dict
190     with the following make-up:
191     ======  ====================================================================
192     Key     Value
193     ======  ====================================================================
194     Modal   The modal "level" that the particular option is specified in (0-3),
195             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
196             aa370656(v=vs.85).aspx&gt;`_
197     Option  The name of the structure member which contains the data for the
198             policy, for example **max_passwd_age**
199     ======  ====================================================================
200     NetSH Mechanism
201     ---------------
202     The firewall policies are configured by the ``netsh.exe`` executable. The
203     value of this key is a dict with the following make-up:
204     =======  ===================================================================
205     Key      Value
206     =======  ===================================================================
207     Profile  The firewall profile to modify. Can be one of Domain, Private, or
208              Public
209     Section  The section of the firewall to modify. Can be one of state,
210              firewallpolicy, settings, or logging.
211     Option   The setting within that section
212     Value    The value of the setting
213     =======  ===================================================================
214     More information can be found in the advfirewall context in netsh. This can
215     be access by opening a netsh prompt. At a command prompt type the following:
216     c:\&gt;netsh
217     netsh&gt;advfirewall
218     netsh advfirewall&gt;set help
219     netsh advfirewall&gt;set domain help
220     AdvAudit Mechanism
221     ------------------
222     The Advanced Audit Policies are configured using a combination of the
223     auditpol command-line utility and modifying the audit.csv file in two
224     locations. The value of this key is a dict with the following make-up:
225     ======  ===================================
226     Key     Value
227     ======  ===================================
228     Option  The Advanced Audit Policy to modify
229     ======  ===================================
230     Transforms
231     ----------
232     Optionally, each policy definition can contain a "Transform" key. The
233     Transform key is used to handle data that is stored and viewed differently.
234     This key's value is a dict with the following key/value pairs:
235     ===  =======================================================================
236     Key  Value
237     ===  =======================================================================
238     Get  The name of the class function to use to transform the data from the
239          stored value to how the value is displayed in the GUI
240     Put The name of the class function to use to transform the data supplied by
241         the user to the correct value that the policy is stored in
242     ===  =======================================================================
243     For example, "Minimum password age" is stored in seconds, but is displayed
244     in days.  Thus the "Get" and "Put" functions for this policy do these
245     conversions so the user is able to set and view the policy using the same
246     data that is shown in the GUI.
247         ensures a value is not empty
248         converts a number of seconds to days
249         converts a number of days to seconds
250         converts a number of seconds to minutes
251         converts number of minutes to seconds
252         strips quotes from a string
253         add quotes around the string
254         converts a binary 0/1 to Disabled/Enabled
255         converts Enabled/Disabled to unicode char to write to a REG_BINARY value
256         converts 0/1/2 for dasd reg key
257         converts DASD String values to the reg_sz value
258         checks that a value is in an inclusive range
259         The value for 0 used by Max Password Age is actually 0xffffffff
260         converts the binary value in the registry for driver signing into the
261         correct string representation
262         converts the string value seen in the GUI to the correct registry value
263         for secedit
264         converts a list of pysid objects to string representations
265         converts a list of usernames to sid objects
266         converts true/false/None to the GUI representation of the powershell
267         startup/shutdown script order
268         converts powershell script GUI strings representations to
269         True/False/None
270         Retrieves the key or value from a dict based on the item
271         kwarg lookup dict to search for item
272         kwarg value_lookup bool to determine if item should be compared to keys
273         or values
274         kwarg value_lookup bool to determine if item_list should be compared to keys
275         or values
276         kwarg test_zero is used to determine if 0 should be tested when value_lookup is false
277         lookup should be a dict with integers for keys
278         if value_lookup is True, item is expected to be a list
279             the function will return the sum of the keys whose values are in the item list
280         if value_lookup is False, item is expected to be an integer
281             the function will return the values for the keys
282             which successfully "bitwise and" with item
283         transform for setting REG_MULTI_SZ to properly handle "Not Defined"
284         transform for getting REG_MULTI_SZ to properly handle `None`
285         transform for a REG_SZ to properly handle "Not Defined"
286     Only works on Windows systems
287     helper function to recursively update the namespaces of an item
288     helper function to add the reg key to each policies element definitions if
289     the key attribute is not defined to make xpath searching easier for each
290     child in the policy &lt;elements&gt; item
291     """
292     for child in policy_item.getiterator():
293         if "valueName" in child.attrib:
294             if "key" not in child.attrib:
295                 child.attrib["key"] = regkey
296     return policy_item
297 def _remove_unicode_encoding(xml_file):
298     with salt.utils.files.fopen(xml_file, "rb") as f:
299         xml_content = f.read()
300     modified_xml = re.sub(
301         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.decode("utf-16"), count=1
302     )
303     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
304     return xml_tree
305 def _remove_invalid_xmlns(xml_file):
306     with salt.utils.files.fopen(xml_file, "rb") as f:
307         xml_content = f.read()
308     modified_xml = re.sub(
309         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
310     )
311     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
312     return xml_tree
313 def _parse_xml(adm_file):
314     parser = lxml.etree.XMLParser(remove_comments=True)
315     modified_xml = ""
316     with salt.utils.files.fopen(adm_file, "rb") as rfh:
317         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
318     name, ext = os.path.splitext(os.path.basename(adm_file))
319     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
320     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
321     if not os.path.exists(cache_dir):
322         os.makedirs(cache_dir)
323     out_file = os.path.join(cache_dir, hashed_filename)
324     if not os.path.isfile(out_file):
325         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
326         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
327         for file_path in file_list:
328             os.remove(file_path)
329         with salt.utils.files.fopen(adm_file, "rb") as rfh:
330             encoding = "utf-8"
331             raw = rfh.read()
332             try:
333                 raw = raw.decode(encoding)
334             except UnicodeDecodeError:
335                 log.trace("LGPO: Detecting encoding")
336                 encoding = "utf-16"
337                 raw = raw.decode(encoding)
338             for line in raw.split("\r\n"):
339                 if 'key="' in line:
340                     start = line.index('key="')
341                     q1 = line[start:].index('"') + start
342                     q2 = line[q1 + 1 :].index('"') + q1 + 1
343                     line = line.replace(line[start:q2], line[start:q2].lower())
344                     found_key = True
345                 modified_xml += line + "\r\n"
346         modified_xml = modified_xml.replace("\u201c", '"').replace("\u201d", '"')
347         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
348         modified_xml = modified_xml.replace("\u2013", "-").replace("\u2014", "-")
349         with salt.utils.files.fopen(out_file, "wb") as wfh:
350             wfh.write(modified_xml.encode(encoding))
351     try:
352         xml_tree = lxml.etree.parse(out_file, parser=parser)
353     except lxml.etree.XMLSyntaxError:
354         try:
355             xml_tree = _remove_unicode_encoding(out_file)
356         except lxml.etree.XMLSyntaxError:
357             xml_tree = _remove_invalid_xmlns(out_file)
358     return xml_tree
359 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
360     display_language_fallback = INSTALL_LANGUAGE
361     t_policy_definitions = lxml.etree.Element("policyDefinitions")
362     t_policy_definitions.append(lxml.etree.Element("categories"))
363     t_policy_definitions.append(lxml.etree.Element("policies"))
364     t_policy_definitions.append(lxml.etree.Element("policyNamespaces"))
365     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
366     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
367     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
368     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
369     policydefs_resources_localname_xpath = etree.XPath(
370         '//*[local-name() = "policyDefinitionResources"]/*'
371     )
372     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
373     for root, dirs, files in salt.utils.path.os_walk(path):
374         if root == path:
375             for t_admx_file in files:
376                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
377                 if not admx_file_ext == ".admx":
378                     log.debug("%s is not an ADMX file", t_admx_file)
379                     continue
380                 admx_file = os.path.join(root, t_admx_file)
381                 try:
382                     xml_tree = _parse_xml(admx_file)
383                 except lxml.etree.XMLSyntaxError:
384                     log.error(
385                         "An error was found while processing admx "
386                         "file %s, all policies from this file will "
387                         "be unavailable via this module",
388                         admx_file,
389                     )
390                     continue
391                 namespaces = xml_tree.getroot().nsmap
392                 namespace_string = ""
393                 if None in namespaces:
394                     namespaces["None"] = namespaces[None]
395                     namespaces.pop(None)
396                     namespace_string = "None:"
397                 this_namespace = xml_tree.xpath(
398                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
399                         namespace_string
400                     ),
401                     namespaces=namespaces,
402                 )[0]
403                 categories = xml_tree.xpath(
404                     "/{0}policyDefinitions/{0}categories/{0}category".format(
405                         namespace_string
406                     ),
407                     namespaces=namespaces,
408                 )
409                 for category in categories:
410                     temp_cat = category
411                     temp_cat = _updateNamespace(temp_cat, this_namespace)
412                     policydefs_categories_xpath(t_policy_definitions)[0].append(
413                         temp_cat
414                     )
415                 policies = xml_tree.xpath(
416                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
417                         namespace_string
418                     ),
419                     namespaces=namespaces,
420                 )
421                 for policy in policies:
422                     temp_pol = policy
423                     temp_pol = _updateNamespace(temp_pol, this_namespace)
424                     if "key" in temp_pol.attrib:
425                         temp_pol = _updatePolicyElements(
426                             temp_pol, temp_pol.attrib["key"]
427                         )
428                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
429                 policy_namespaces = xml_tree.xpath(
430                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
431                         namespace_string
432                     ),
433                     namespaces=namespaces,
434                 )
435                 for policy_ns in policy_namespaces:
436                     temp_ns = policy_ns
437                     temp_ns = _updateNamespace(temp_ns, this_namespace)
438                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
439                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
440                 if not __salt__["file.file_exists"](adml_file):
441                     log.info(
442                         "An ADML file in the specified ADML language "
443                         '"%s" does not exist for the ADMX "%s", the '
444                         "the abbreviated language code will be tried.",
445                         language,
446                         t_admx_file,
447                     )
448                     adml_file = os.path.join(
449                         root, language.split("-")[0], admx_file_name + ".adml"
450                     )
451                     if not __salt__["file.file_exists"](adml_file):
452                         log.info(
453                             "An ADML file in the specified ADML language "
454                             'code %s does not exist for the ADMX "%s", '
455                             "the fallback language will be tried.",
456                             language[:2],
457                             t_admx_file,
458                         )
459                         adml_file = os.path.join(
460                             root, display_language_fallback, admx_file_name + ".adml"
461                         )
462                         if not __salt__["file.file_exists"](adml_file):
463                             log.info(
464                                 "An ADML file in the specified ADML "
465                                 'fallback language "%s" '
466                                 'does not exist for the ADMX "%s" '
467                                 "the abbreviated fallback language code "
468                                 "will be tried.",
469                                 display_language_fallback,
470                                 t_admx_file,
471                             )
472                             adml_file = os.path.join(
473                                 root,
474                                 display_language_fallback.split("-")[0],
475                                 admx_file_name + ".adml",
476                             )
477                             if not __salt__["file.file_exists"](adml_file):
478                                 raise SaltInvocationError(
479                                     "An ADML file in the specified ADML language "
480                                     '"{}" and the fallback language "{}" do not '
481                                     'exist for the ADMX "{}".'.format(
482                                         language, display_language_fallback, t_admx_file
483                                     )
484                                 )
485                 try:
486                     xml_tree = _parse_xml(adml_file)
487                 except lxml.etree.XMLSyntaxError:
488                     log.error(
489                         "An error was found while processing adml "
490                         "file %s, all policies from this file will "
491                         "be unavailable via this module",
492                         adml_file,
493                     )
494                     continue
495                 if None in namespaces:
496                     namespaces["None"] = namespaces[None]
497                     namespaces.pop(None)
498                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
499                 for policydefs_resource in policydefs_resources:
500                     t_poldef = policydefs_resource
501                     t_poldef = _updateNamespace(t_poldef, this_namespace)
502                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
503                         t_poldef
504                     )
505     __context__["lgpo.policy_definitions"] = t_policy_definitions
506     __context__["lgpo.policy_resources"] = t_policy_definition_resources
507 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
508     if "lgpo.policy_definitions" not in __context__:
509         log.debug("LGPO: Loading policy definitions")
510         _load_policy_definitions(path=path, language=language)
511     return __context__["lgpo.policy_definitions"]
512 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
513     if "lgpo.policy_resources" not in __context__:
514         log.debug("LGPO: Loading policy resources")
515         _load_policy_definitions(path=path, language=language)
516     return __context__["lgpo.policy_resources"]
517 def _buildElementNsmap(using_elements):
518     thisMap = {}
519     for e in using_elements:
520         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
521     return thisMap
522 def _get_advaudit_defaults(option=None):
523     if "lgpo.audit_defaults" not in __context__:
524         log.debug("Loading auditpol defaults into __context__")
525         dump = __utils__["auditpol.get_auditpol_dump"]()
526         reader = csv.DictReader(dump)
527         audit_defaults = {"fieldnames": reader.fieldnames}
528         for row in reader:
529             row["Machine Name"] = ""
530             row["Auditpol Name"] = row["Subcategory"]
531             if row["Subcategory"] == "Central Policy Staging":
532                 row["Subcategory"] = "Audit Central Access Policy Staging"
533             elif row["Subcategory"] == "Plug and Play Events":
534                 row["Subcategory"] = "Audit PNP Activity"
535             elif row["Subcategory"] == "Token Right Adjusted Events":
536                 row["Subcategory"] = "Audit Token Right Adjusted"
537             else:
538                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
539             audit_defaults[row["Subcategory"]] = row
540         __context__["lgpo.audit_defaults"] = audit_defaults
541     if option:
542         return __context__["lgpo.audit_defaults"][option]
543     else:
544         return __context__["lgpo.audit_defaults"]
545 def _advaudit_check_csv():
546     system_root <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.environ.get("SystemRoot", "C:\\Windows")
547     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
548     f_audit_gpo = os.path.join(
549         system_root,
550         "System32",
551         "GroupPolicy",
552         "Machine",
553         "Microsoft",
554         "Windows NT",
555         "Audit",
556         "audit.csv",
557     )
558     if not __salt__["file.file_exists"](</b></font>f_audit):
559         if __salt__["file.file_exists"](f_audit_gpo):
560             __salt__["file.copy"](f_audit_gpo, f_audit)
561         else:
562             field_names = _get_advaudit_defaults("fieldnames")
563             __salt__["file.makedirs"](f_audit)
564             __salt__["file.write"](f_audit, ",".join(field_names))
565 def _get_advaudit_value(option, refresh=False):
566     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
567         system_root = os.environ.get("SystemRoot", "C:\\Windows")
568         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
569         _advaudit_check_csv()
570         audit_settings = {}
571         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
572             reader = csv.DictReader(csv_file)
573             for row in reader:
574                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
575         __context__["lgpo.adv_audit_data"] = audit_settings
576     return __context__["lgpo.adv_audit_data"].get(option, None)
577 def _set_advaudit_file_data(option, value):
578     system_root <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.environ.get("SystemRoot", "C:\\Windows")
579     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
580     f_audit_gpo = os.path.join(</b></font>
581         system_root,
582         "System32",
583         "GroupPolicy",
584         "Machine",
585         "Microsoft",
586         "Windows NT",
587         "Audit",
588         "audit.csv",
589     )
590     f_temp = tempfile.NamedTemporaryFile(
591         mode="w", delete=False, suffix=".csv", prefix="audit"
592     )
593     auditpol_values = {
594         "None": "No Auditing",
595         "0": "No Auditing",
596         "1": "Success",
597         "2": "Failure",
598         "3": "Success and Failure",
599     }
600     _advaudit_check_csv()
601     try:
602         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
603             reader = csv.DictReader(csv_file)
604             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
605                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
606                 writer.writeheader()
607                 value_written = False
608                 for row in reader:
609                     if row["Subcategory"] == option:
610                         if not value == "None":
611                             row["Inclusion Setting"] = auditpol_values[value]
612                             row["Setting Value"] = value
613                             log.trace("LGPO: Setting %s to %s", option, value)
614                             writer.writerow(row)
615                         else:
616                             log.trace("LGPO: Removing %s", option)
617                         value_written = True
618                     else:
619                         writer.writerow(row)
620                 if not value_written:
621                     if not value == "None":
622                         log.trace("LGPO: Setting %s to %s", option, value)
623                         defaults = _get_advaudit_defaults(option)
624                         writer.writerow(
625                             {
626                                 "Machine Name": defaults["Machine Name"],
627                                 "Policy Target": defaults["Policy Target"],
628                                 "Subcategory": defaults["Subcategory"],
629                                 "Subcategory GUID": defaults["Subcategory GUID"],
630                                 "Inclusion Setting": auditpol_values[value],
631                                 "Exclusion Setting": defaults["Exclusion Setting"],
632                                 "Setting Value": value,
633                             }
634                         )
635                     value_written = True
636         if value_written:
637             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
638             __salt__["file.makedirs"](f_audit_gpo)
639             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
640     finally:
641         f_temp.close()
642         __salt__["file.remove"](f_temp.name)
643     return value_written
644 def _set_advaudit_pol_data(option, value):
645     auditpol_values = {
646         "None": "No Auditing",
647         "0": "No Auditing",
648         "1": "Success",
649         "2": "Failure",
650         "3": "Success and Failure",
651     }
652     defaults = _get_advaudit_defaults(option)
653     return __utils__["auditpol.set_setting"](
654         name=defaults["Auditpol Name"], value=auditpol_values[value]
655     )
656 def _set_advaudit_value(option, value):
657     if not _set_advaudit_file_data(option=option, value=value):
658         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
659     if not _set_advaudit_pol_data(option=option, value=value):
660         log.error(
661             "Failed to apply audit setting: %s\n"
662             "Policy will take effect on next GPO update",
663             option,
664         )
665     if "lgpo.adv_audit_data" not in __context__:
666         _get_advaudit_value(option)
667     if value is None:
668         log.debug("LGPO: Removing Advanced Audit data: %s", option)
669         __context__["lgpo.adv_audit_data"].pop(option)
670     else:
671         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
672         __context__["lgpo.adv_audit_data"][option] = value
673     return True
674 def _get_netsh_value(profile, option):
675     if "lgpo.netsh_data" not in __context__:
676         __context__["lgpo.netsh_data"] = {}
677     if profile not in __context__["lgpo.netsh_data"]:
678         log.debug("LGPO: Loading netsh data for %s profile", profile)
679         settings = salt.utils.win_lgpo_netsh.get_all_settings(
680             profile=profile, store="lgpo"
681         )
682         __context__["lgpo.netsh_data"].update({profile: settings})
683     log.trace(
684         "LGPO: netsh returning value: %s",
685         __context__["lgpo.netsh_data"][profile][option],
686     )
687     return __context__["lgpo.netsh_data"][profile][option]
688 def _set_netsh_value(profile, section, option, value):
689     if section not in ("firewallpolicy", "settings", "logging", "state"):
690         raise ValueError("LGPO: Invalid section: {}".format(section))
691     log.trace(
692         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
693         profile,
694         section,
695         option,
696         value,
697     )
698     if section == "firewallpolicy":
699         salt.utils.win_lgpo_netsh.set_firewall_settings(
700             profile=profile,
701             inbound=value if option == "Inbound" else None,
702             outbound=value if option == "Outbound" else None,
703             store="lgpo",
704         )
705     if section == "settings":
706         salt.utils.win_lgpo_netsh.set_settings(
707             profile=profile, setting=option, value=value, store="lgpo"
708         )
709     if section == "state":
710         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
711     if section == "logging":
712         if option in ("FileName", "MaxFileSize"):
713             if value == "Not configured":
714                 value = "notconfigured"
715         if option.startswith("Log"):
716             option = option[3:]
717         salt.utils.win_lgpo_netsh.set_logging_settings(
718             profile=profile, setting=option, value=value, store="lgpo"
719         )
720     log.trace("LGPO: Clearing netsh data for %s profile", profile)
721     __context__["lgpo.netsh_data"].pop(profile)
722     return True
723 def _load_secedit_data():
724     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
725     try:
726         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
727         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
728             secedit_data = fp.readlines()
729         return secedit_data
730     finally:
731         if __salt__["file.file_exists"](f_exp):
732             __salt__["file.remove"](f_exp)
733 def _get_secedit_data(refresh=False):
734     if "lgpo.secedit_data" not in __context__ or refresh is True:
735         log.debug("LGPO: Loading secedit data")
736         __context__["lgpo.secedit_data"] = _load_secedit_data()
737     return __context__["lgpo.secedit_data"]
738 def _get_secedit_value(option):
739     secedit_data = _get_secedit_data()
740     for _line in secedit_data:
741         if _line.startswith(option):
742             return _line.split("=")[1].strip()
743     return "Not Defined"
744 def _write_secedit_data(inf_data):
745     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
746     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
747     try:
748         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
749             fp.write(inf_data)
750         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
751         retcode = __salt__["cmd.retcode"](cmd)
752         if not retcode == 0:
753             log.debug("Secedit failed to import template data")
754             return False
755         cmd = ["secedit", "/configure", "/db", f_sdb]
756         retcode = __salt__["cmd.retcode"](cmd)
757         if not retcode == 0:
758             log.debug("Secedit failed to apply security database")
759             return False
760         __context__.pop("lgpo.secedit_data", None)
761         return True
762     finally:
763         if __salt__["file.file_exists"](f_inf):
764             __salt__["file.remove"](f_inf)
765 def _transform_value(value, policy, transform_type):
766     t_kwargs = {}
767     if "Transform" in policy:
768         if transform_type in policy["Transform"]:
769             _policydata = _policy_info()
770             if transform_type + "Args" in policy["Transform"]:
771                 t_kwargs = policy["Transform"][transform_type + "Args"]
772             return getattr(_policydata, policy["Transform"][transform_type])(
773                 value, **t_kwargs
774             )
775         else:
776             return value
777     else:
778         if "Registry" in policy:
779             if value == "(value not set)":
780                 return "Not Defined"
781         return value
782 def _validateSetting(value, policy):
783     log.debug("validating %s for policy %s", value, policy)
784     if "Settings" in policy:
785         if policy["Settings"]:
786             if isinstance(policy["Settings"], list):
787                 if value not in policy["Settings"]:
788                     return False
789             elif isinstance(policy["Settings"], dict):
790                 _policydata = _policy_info()
791                 if not getattr(_policydata, policy["Settings"]["Function"])(
792                     value, **policy["Settings"]["Args"]
793                 ):
794                     return False
795     else:
796         return True
797     return True
798 def _addAccountRights(sidObject, user_right):
799     try:
800         if sidObject:
801             _polHandle = win32security.LsaOpenPolicy(
802                 None, win32security.POLICY_ALL_ACCESS
803             )
804             user_rights_list = [user_right]
805             _ret = win32security.LsaAddAccountRights(
806                 _polHandle, sidObject, user_rights_list
807             )
808         return True
809     except Exception as e:  # pylint: disable=broad-except
810         log.exception("Error attempting to add account right, exception was %s", e)
811         return False
812 def _delAccountRights(sidObject, user_right):
813     try:
814         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
815         user_rights_list = [user_right]
816         _ret = win32security.LsaRemoveAccountRights(
817             _polHandle, sidObject, False, user_rights_list
818         )
819         return True
820     except Exception as e:  # pylint: disable=broad-except
821         log.exception("Error attempting to delete account right")
822         return False
823 def _getRightsAssignments(user_right):
824     sids = []
825     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
826     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
827     return sids
828 def _getAdmlDisplayName(adml_xml_data, display_name):
829     if display_name.startswith("$(") and display_name.endswith(")"):
830         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
831         display_name = display_name.split(".")
832         displayname_type = display_name[0]
833         displayname_id = display_name[1]
834         search_results = ADML_DISPLAY_NAME_XPATH(
835             adml_xml_data,
836             displayNameType=displayname_type,
837             displayNameId=displayname_id,
838         )
839         if search_results:
840             for result in search_results:
841                 return result.text.strip()
842     return None
843 def _getAdmlPresentationRefId(adml_data, ref_id):
844     search_results = adml_data.xpath(
845         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
846     )
847     alternate_label = ""
848     if search_results:
849         for result in search_results:
850             the_localname = etree.QName(result.tag).localname
851             if result.text is None:
852                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
853                 if presentation_element:
854                     presentation_element = presentation_element[0]
855                     if TEXT_ELEMENT_XPATH(presentation_element):
856                         for p_item in presentation_element:
857                             if p_item == result:
858                                 break
859                             if etree.QName(p_item.tag).localname == "text":
860                                 if getattr(p_item, "text"):
861                                     alternate_label = getattr(p_item, "text").rstrip()
862                         if alternate_label.endswith("."):
863                             alternate_label = ""
864             if the_localname in ["textBox", "comboBox"]:
865                 label_items = result.xpath('.//*[local-name() = "label"]')
866                 for label_item in label_items:
867                     if label_item.text:
868                         return label_item.text.rstrip().rstrip(":")
869             elif the_localname in [
870                 "decimalTextBox",
871                 "longDecimalTextBox",
872                 "dropdownList",
873                 "listBox",
874                 "checkBox",
875                 "text",
876                 "multiTextBox",
877             ]:
878                 if result.text:
879                     return result.text.rstrip().rstrip(":")
880                 else:
881                     return alternate_label.rstrip(":")
882     return None
883 def _getFullPolicyName(
884     policy_item, policy_name, return_full_policy_names, adml_language
885 ):
886     if policy_name in adm_policy_name_map[return_full_policy_names]:
887         return adm_policy_name_map[return_full_policy_names][policy_name]
888     adml_data = _get_policy_resources(language=adml_language)
889     if return_full_policy_names and "displayName" in policy_item.attrib:
890         fullPolicyName = _getAdmlDisplayName(
891             adml_data, policy_item.attrib["displayName"]
892         )
893         if fullPolicyName:
894             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
895             policy_name = fullPolicyName
896     elif return_full_policy_names and "id" in policy_item.attrib:
897         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
898         if fullPolicyName:
899             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
900             policy_name = fullPolicyName
901     policy_name = policy_name.rstrip(":").rstrip()
902     return policy_name
903 def _regexSearchRegPolData(search_string, policy_data):
904     if policy_data:
905         if search_string:
906             match = re.search(search_string, policy_data, re.IGNORECASE)
907             if match:
908                 return True
909     return False
910 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
911     value = None
912     values = []
913     encoded_semicolon = ";".encode("utf-16-le")
914     if return_value_name:
915         values = {}
916     if search_string:
917         registry = Registry()
918         if len(search_string.split(encoded_semicolon)) &gt;= 3:
919             vtype = registry.vtype_reverse[
920                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
921             ]
922         else:
923             vtype = None
924         search_string = re.escape(search_string)
925         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
926         matches = [m for m in matches]
927         if matches:
928             for match in matches:
929                 pol_entry = policy_data[
930                     match.start() : (
931                         policy_data.index("]".encode("utf-16-le"), match.end())
932                     )
933                 ].split(encoded_semicolon, 4)
934                 if len(pol_entry) &gt;= 2:
935                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
936                 if len(pol_entry) &gt;= 5:
937                     value = encoded_semicolon.join(pol_entry[4:])
938                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
939                         if value:
940                             if vtype == "REG_DWORD":
941                                 for v in struct.unpack(b"I", value):
942                                     value = v
943                             elif vtype == "REG_QWORD":
944                                 for v in struct.unpack(b"Q", value):
945                                     value = v
946                         else:
947                             value = 0
948                     elif vtype == "REG_MULTI_SZ":
949                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
950                     else:
951                         value = value.decode("utf-16-le").rstrip(chr(0))
952                 if return_value_name:
953                     log.trace("we want value names and the value")
954                     values[valueName] = value
955                 elif len(matches) &gt; 1:
956                     log.trace("we have multiple matches, we will return a list")
957                     values.append(value)
958     if values:
959         value = values
960     return value
961 def _checkListItem(
962     policy_element,
963     policy_name,
964     policy_key,
965     xpath_object,
966     policy_file_data,
967     test_items=True,
968 ):
969     xpath_string = (
970         './/*[local-name() = "decimal" or local-name() = "delete"'
971         ' or local-name() = "longDecimal" or local-name() = "string"]'
972     )
973     value_item_child_xpath = etree.XPath(xpath_string)
974     expected_strings = []
975     for list_element in xpath_object(policy_element):
976         configured_items = 0
977         required_items = 0
978         for item in list_element:
979             required_items = required_items + 1
980             if "key" in item.attrib:
981                 item_key = item.attrib["key"]
982             else:
983                 item_key = policy_key
984             if "valueName" in item.attrib:
985                 item_valuename = item.attrib["valueName"]
986             else:
987                 log.error(
988                     "%s item with attributes %s in policy %s does not "
989                     'have the required "valueName" attribute',
990                     etree.QName(list_element).localname,
991                     item.attrib,
992                     policy_element.attrib,
993                 )
994                 break
995             for value_item in value_item_child_xpath(item):
996                 search_string = _processValueItem(
997                     value_item, item_key, item_valuename, policy_element, item
998                 )
999                 if test_items:
1000                     if _regexSearchRegPolData(
1001                         re.escape(search_string), policy_file_data
1002                     ):
1003                         configured_items = configured_items + 1
1004                         log.trace(
1005                             "found the search string in the pol file,"
1006                             "%s of %s items for policy %s are "
1007                             "configured in registry.pol",
1008                             configured_items,
1009                             required_items,
1010                             policy_name,
1011                         )
1012                 else:
1013                     expected_strings.append(search_string)
1014         if test_items:
1015             if required_items &gt; 0 and required_items == configured_items:
1016                 log.trace("%s all items are set", policy_name)
1017                 return True
1018     if test_items:
1019         return False
1020     else:
1021         return expected_strings
1022 def _checkValueItemParent(
1023     policy_element,
1024     policy_name,
1025     policy_key,
1026     policy_valueName,
1027     xpath_object,
1028     policy_file_data,
1029     check_deleted=False,
1030     test_item=True,
1031 ):
1032     for element in xpath_object(policy_element):
1033         for value_item in element:
1034             search_string = _processValueItem(
1035                 value_item,
1036                 policy_key,
1037                 policy_valueName,
1038                 policy_element,
1039                 element,
1040                 check_deleted=check_deleted,
1041             )
1042             if not test_item:
1043                 return search_string
1044             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
1045                 log.trace(
1046                     "found the search string in the pol file, %s is configured",
1047                     policy_name,
1048                 )
1049                 return True
1050     return False
1051 def _encode_string(value):
1052     encoded_null = chr(0).encode("utf-16-le")
1053     if value is None:
1054         return encoded_null
1055     elif not isinstance(value, str):
1056         raise TypeError(
1057             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
1058         )
1059     return b"".join([value.encode("utf-16-le"), encoded_null])
1060 def _buildKnownDataSearchString(
1061     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
1062 ):
1063     registry = Registry()
1064     this_element_value = None
1065     expected_string = b""
1066     encoded_semicolon = ";".encode("utf-16-le")
1067     encoded_null = chr(0).encode("utf-16-le")
1068     if reg_key:
1069         reg_key = reg_key.encode("utf-16-le")
1070     if reg_valueName:
1071         reg_valueName = reg_valueName.encode("utf-16-le")
1072     if reg_data and not check_deleted:
1073         if reg_vtype == "REG_DWORD":
1074             this_element_value = struct.pack(b"I", int(reg_data))
1075         elif reg_vtype == "REG_QWORD":
1076             this_element_value = struct.pack(b"Q", int(reg_data))
1077         elif reg_vtype == "REG_SZ":
1078             this_element_value = _encode_string(reg_data)
1079     if check_deleted:
1080         reg_vtype = "REG_SZ"
1081         expected_string = b"".join(
1082             [
1083                 "[".encode("utf-16-le"),
1084                 reg_key,
1085                 encoded_null,
1086                 encoded_semicolon,
1087                 "**del.".encode("utf-16-le"),
1088                 reg_valueName,
1089                 encoded_null,
1090                 encoded_semicolon,
1091                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
1092                 encoded_semicolon,
1093                 chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode("utf-32-le"),
1094                 encoded_semicolon,
1095                 " ".encode("utf-16-le"),
1096                 encoded_null,
1097                 "]".encode("utf-16-le"),
1098             ]
1099         )
1100     else:
1101         expected_string = b"".join(
1102             [
1103                 "[".encode("utf-16-le"),
1104                 reg_key,
1105                 encoded_null,
1106                 encoded_semicolon,
1107                 reg_valueName,
1108                 encoded_null,
1109                 encoded_semicolon,
1110                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
1111                 encoded_semicolon,
1112                 chr(len(this_element_value)).encode("utf-32-le"),
1113                 encoded_semicolon,
1114                 this_element_value,
1115                 "]".encode("utf-16-le"),
1116             ]
1117         )
1118     return expected_string
1119 def _processValueItem(
1120     element,
1121     reg_key,
1122     reg_valuename,
1123     policy,
1124     parent_element,
1125     check_deleted=False,
1126     this_element_value=None,
1127 ):
1128     registry = Registry()
1129     expected_string = None
1130     this_vtype = "REG_SZ"
1131     encoded_semicolon = ";".encode("utf-16-le")
1132     encoded_null = chr(0).encode("utf-16-le")
1133     if reg_key:
1134         reg_key = reg_key.encode("utf-16-le")
1135     if reg_valuename:
1136         reg_valuename = reg_valuename.encode("utf-16-le")
1137     if (
1138         etree.QName(element).localname == "decimal"
1139         and etree.QName(parent_element).localname != "elements"
1140     ):
1141         this_vtype = "REG_DWORD"
1142         if "value" in element.attrib:
1143             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
1144         else:
1145             log.error(
1146                 "The %s child %s element for the policy with "
1147                 'attributes: %s does not have the required "value" '
1148                 "attribute. The element attributes are: %s",
1149                 etree.QName(parent_element).localname,
1150                 etree.QName(element).localname,
1151                 policy.attrib,
1152                 element.attrib,
1153             )
1154             return None
1155     elif (
1156         etree.QName(element).localname == "longDecimal"
1157         and etree.QName(parent_element).localname != "elements"
1158     ):
1159         this_vtype = "REG_QWORD"
1160         if "value" in element.attrib:
1161             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
1162         else:
1163             log.error(
1164                 "The %s child %s element for the policy with "
1165                 'attributes: %s does not have the required "value" '
1166                 "attribute. The element attributes are: %s",
1167                 etree.QName(parent_element).localname,
1168                 etree.QName(element).localname,
1169                 policy.attrib,
1170                 element.attrib,
1171             )
1172             return None
1173     elif etree.QName(element).localname == "string":
1174         this_vtype = "REG_SZ"
1175         this_element_value = _encode_string(element.text)
1176     elif etree.QName(parent_element).localname == "elements":
1177         standard_element_expected_string = True
1178         if etree.QName(element).localname == "boolean":
1179             if this_element_value is False:
1180                 check_deleted = True
1181             if not check_deleted:
1182                 this_vtype = "REG_DWORD"
1183             this_element_value = struct.pack("I", 1)
1184             standard_element_expected_string = False
1185         elif etree.QName(element).localname == "decimal":
1186             this_vtype = "REG_DWORD"
1187             requested_val = this_element_value
1188             if this_element_value is not None:
1189                 this_element_value = struct.pack(b"I", int(this_element_value))
1190             if "storeAsText" in element.attrib:
1191                 if element.attrib["storeAsText"].lower() == "true":
1192                     this_vtype = "REG_SZ"
1193                     if requested_val is not None:
1194                         this_element_value = str(requested_val).encode("utf-16-le")
1195             if check_deleted:
1196                 this_vtype = "REG_SZ"
1197         elif etree.QName(element).localname == "longDecimal":
1198             this_vtype = "REG_QWORD"
1199             requested_val = this_element_value
1200             if this_element_value is not None:
1201                 this_element_value = struct.pack(b"Q", int(this_element_value))
1202             if "storeAsText" in element.attrib:
1203                 if element.attrib["storeAsText"].lower() == "true":
1204                     this_vtype = "REG_SZ"
1205                     if requested_val is not None:
1206                         this_element_value = str(requested_val).encode("utf-16-le")
1207         elif etree.QName(element).localname == "text":
1208             this_vtype = "REG_SZ"
1209             if "expandable" in element.attrib:
1210                 if element.attrib["expandable"].lower() == "true":
1211                     this_vtype = "REG_EXPAND_SZ"
1212             if this_element_value is not None:
1213                 this_element_value = _encode_string(this_element_value)
1214         elif etree.QName(element).localname == "multiText":
1215             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
1216             if this_element_value is not None:
1217                 this_element_value = "{0}{1}{1}".format(
1218                     chr(0).join(this_element_value), chr(0)
1219                 )
1220         elif etree.QName(element).localname == "list":
1221             standard_element_expected_string = False
1222             del_keys = b""
1223             element_valuenames = []
1224             element_values = this_element_value
1225             if this_element_value is not None:
1226                 element_valuenames = [
1227                     str(z) for z in range(1, len(this_element_value) + 1)
1228                 ]
1229             if "additive" in element.attrib:
1230                 if element.attrib["additive"].lower() == "false":
1231                     del_keys = b"".join(
1232                         [
1233                             "[".encode("utf-16-le"),
1234                             reg_key,
1235                             encoded_null,
1236                             encoded_semicolon,
1237                             "**delvals.".encode("utf-16-le"),
1238                             encoded_null,
1239                             encoded_semicolon,
1240                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
1241                             encoded_semicolon,
1242                             chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
1243                                 "utf-32-le"
1244                             ),
1245                             encoded_semicolon,
1246                             " ".encode("utf-16-le"),
1247                             encoded_null,
1248                             "]".encode("utf-16-le"),
1249                         ]
1250                     )
1251             if "expandable" in element.attrib:
1252                 this_vtype = "REG_EXPAND_SZ"
1253             if element.attrib.get("explicitValue", "false").lower() == "true":
1254                 if this_element_value is not None:
1255                     element_valuenames = [str(k) for k in this_element_value.keys()]
1256                     element_values = [str(v) for v in this_element_value.values()]
1257             elif "valuePrefix" in element.attrib:
1258                 if element.attrib["valuePrefix"] != "":
1259                     if this_element_value is not None:
1260                         element_valuenames = [
1261                             "{}{}".format(element.attrib["valuePrefix"], k)
1262                             for k in element_valuenames
1263                         ]
1264             else:
1265                 if element_values is not None:
1266                     element_valuenames = [str(z) for z in element_values]
1267             if not check_deleted:
1268                 if this_element_value is not None:
1269                     log.trace(
1270                         "_processValueItem has an explicit element_value of %s",
1271                         this_element_value,
1272                     )
1273                     expected_string = del_keys
1274                     log.trace(
1275                         "element_valuenames == %s and element_values == %s",
1276                         element_valuenames,
1277                         element_values,
1278                     )
1279                     for i, item in enumerate(element_valuenames):
1280                         expected_string = expected_string + b"".join(
1281                             [
1282                                 "[".encode("utf-16-le"),
1283                                 reg_key,
1284                                 encoded_null,
1285                                 encoded_semicolon,
1286                                 element_valuenames[i].encode("utf-16-le"),
1287                                 encoded_null,
1288                                 encoded_semicolon,
1289                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
1290                                 encoded_semicolon,
1291                                 chr(
1292                                     len(
1293                                         "{}{}".format(element_values[i], chr(0)).encode(
1294                                             "utf-16-le"
1295                                         )
1296                                     )
1297                                 ).encode("utf-32-le"),
1298                                 encoded_semicolon,
1299                                 _encode_string(element_values[i]),
1300                                 "]".encode("utf-16-le"),
1301                             ]
1302                         )
1303                 else:
1304                     expected_string = del_keys + b"".join(
1305                         [
1306                             "[".encode("utf-16-le"),
1307                             reg_key,
1308                             encoded_null,
1309                             encoded_semicolon,
1310                         ]
1311                     )
1312             else:
1313                 expected_string = b"".join(
1314                     [
1315                         "[".encode("utf-16-le"),
1316                         reg_key,
1317                         encoded_null,
1318                         encoded_semicolon,
1319                         "**delvals.".encode("utf-16-le"),
1320                         encoded_null,
1321                         encoded_semicolon,
1322                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
1323                         encoded_semicolon,
1324                         chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
1325                             "utf-32-le"
1326                         ),
1327                         encoded_semicolon,
1328                         " ".encode("utf-16-le"),
1329                         encoded_null,
1330                         "]".encode("utf-16-le"),
1331                     ]
1332                 )
1333         elif etree.QName(element).localname == "enum":
1334             if this_element_value is not None:
1335                 pass
1336         if standard_element_expected_string and not check_deleted:
1337             if this_element_value is not None:
1338                 if isinstance(this_element_value, str):
1339                     log.debug("Converting %s to bytes", this_element_value)
1340                     this_element_value = this_element_value.encode("utf-32-le")
1341                 expected_string = b"".join(
1342                     [
1343                         "[".encode("utf-16-le"),
1344                         reg_key,
1345                         encoded_null,
1346                         encoded_semicolon,
1347                         reg_valuename,
1348                         encoded_null,
1349                         encoded_semicolon,
1350                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
1351                         encoded_semicolon,
1352                         chr(len(this_element_value)).encode("utf-32-le"),
1353                         encoded_semicolon,
1354                         this_element_value,
1355                         "]".encode("utf-16-le"),
1356                     ]
1357                 )
1358             else:
1359                 expected_string = b"".join(
1360                     [
1361                         "[".encode("utf-16-le"),
1362                         reg_key,
1363                         encoded_null,
1364                         encoded_semicolon,
1365                         reg_valuename,
1366                         encoded_null,
1367                         encoded_semicolon,
1368                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
1369                         encoded_semicolon,
1370                     ]
1371                 )
1372     if not expected_string:
1373         if etree.QName(element).localname == "delete" or check_deleted:
1374             expected_string = b"".join(
1375                 [
1376                     "[".encode("utf-16-le"),
1377                     reg_key,
1378                     encoded_null,
1379                     encoded_semicolon,
1380                     "**del.".encode("utf-16-le"),
1381                     reg_valuename,
1382                     encoded_null,
1383                     encoded_semicolon,
1384                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
1385                     encoded_semicolon,
1386                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
1387                         "utf-32-le"
1388                     ),
1389                     encoded_semicolon,
1390                     " ".encode("utf-16-le"),
1391                     encoded_null,
1392                     "]".encode("utf-16-le"),
1393                 ]
1394             )
1395         else:
1396             expected_string = b"".join(
1397                 [
1398                     "[".encode("utf-16-le"),
1399                     reg_key,
1400                     encoded_null,
1401                     encoded_semicolon,
1402                     reg_valuename,
1403                     encoded_null,
1404                     encoded_semicolon,
1405                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
1406                     encoded_semicolon,
1407                     chr(len(this_element_value)).encode("utf-32-le"),
1408                     encoded_semicolon,
1409                     this_element_value,
1410                     "]".encode("utf-16-le"),
1411                 ]
1412             )
1413     return expected_string
1414 def _checkAllAdmxPolicies(
1415     policy_class,
1416     adml_language="en-US",
1417     return_full_policy_names=False,
1418     hierarchical_return=False,
1419     return_not_configured=False,
1420 ):
1421     log.trace("POLICY CLASS == %s", policy_class)
1422     module_policy_data = _policy_info()
1423     policy_file_data = _read_regpol_file(
1424         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
1425     )
1426     admx_policies = []
1427     policy_vals = {}
1428     hierarchy = {}
1429     full_names = {}
1430     admx_policy_definitions = _get_policy_definitions(language=adml_language)
1431     adml_policy_resources = _get_policy_resources(language=adml_language)
1432     if policy_file_data:
1433         log.trace("POLICY CLASS %s has file data", policy_class)
1434         policy_filedata_split = re.sub(
1435             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
1436             b"",
1437             re.sub(
1438                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
1439                 b"",
1440                 re.sub(
1441                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
1442                     b"",
1443                     policy_file_data,
1444                 ),
1445             ),
1446         ).split("][".encode("utf-16-le"))
1447         log.trace("Searching %s policies...", len(policy_filedata_split))
1448         start_time = time.time()
1449         for policy_item in policy_filedata_split:
1450             policy_item_key = (
1451                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
1452                 .decode("utf-16-le")
1453                 .lower()
1454             )
1455             if policy_item_key:
1456                 admx_items = REGKEY_XPATH(
1457                     admx_policy_definitions, keyvalue=policy_item_key
1458                 )
1459                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
1460                 for admx_item in admx_items:
1461                     if etree.QName(admx_item).localname == "policy":
1462                         if admx_item not in admx_policies:
1463                             admx_policies.append(admx_item)
1464                     else:
1465                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
1466                             if policy_item not in admx_policies:
1467                                 admx_policies.append(policy_item)
1468         log.trace("Search complete: %s seconds", time.time() - start_time)
1469         if return_not_configured:
1470             log.trace("Gathering non configured policies")
1471             start_time = time.time()
1472             not_configured_policies = ALL_CLASS_POLICY_XPATH(
1473                 admx_policy_definitions, registry_class=policy_class
1474             )
1475             for policy_item in admx_policies:
1476                 if policy_item in not_configured_policies:
1477                     not_configured_policies.remove(policy_item)
1478             for not_configured_policy in not_configured_policies:
1479                 not_configured_policy_namespace = not_configured_policy.nsmap[
1480                     not_configured_policy.prefix
1481                 ]
1482                 if not_configured_policy_namespace not in policy_vals:
1483                     policy_vals[not_configured_policy_namespace] = {}
1484                 policy_vals[not_configured_policy_namespace][
1485                     not_configured_policy.attrib["name"]
1486                 ] = "Not Configured"
1487                 if return_full_policy_names:
1488                     if not_configured_policy_namespace not in full_names:
1489                         full_names[not_configured_policy_namespace] = {}
1490                     full_names[not_configured_policy_namespace][
1491                         not_configured_policy.attrib["name"]
1492                     ] = _getFullPolicyName(
1493                         policy_item=not_configured_policy,
1494                         policy_name=not_configured_policy.attrib["name"],
1495                         return_full_policy_names=return_full_policy_names,
1496                         adml_language=adml_language,
1497                     )
1498                 log.trace(
1499                     "building hierarchy for non-configured item %s",
1500                     not_configured_policy.attrib["name"],
1501                 )
1502                 if not_configured_policy_namespace not in hierarchy:
1503                     hierarchy[not_configured_policy_namespace] = {}
1504                 hierarchy[not_configured_policy_namespace][
1505                     not_configured_policy.attrib["name"]
1506                 ] = _build_parent_list(
1507                     policy_definition=not_configured_policy,
1508                     return_full_policy_names=return_full_policy_names,
1509                     adml_language=adml_language,
1510                 )
1511             log.trace("Gathering complete: %s seconds", time.time() - start_time)
1512         log.trace("Examining %s policies...", len(admx_policies))
1513         start_time = time.time()
1514         for admx_policy in admx_policies:
1515             this_valuename = None
1516             this_policy_setting = "Not Configured"
1517             element_only_enabled_disabled = True
1518             explicit_enable_disable_value_setting = False
1519             if "key" in admx_policy.attrib:
1520                 this_key = admx_policy.attrib["key"]
1521             else:
1522                 log.error(
1523                     'policy item %s does not have the required "key" attribute',
1524                     admx_policy.attrib,
1525                 )
1526                 break
1527             if "valueName" in admx_policy.attrib:
1528                 this_valuename = admx_policy.attrib["valueName"]
1529             if "name" in admx_policy.attrib:
1530                 this_policyname = admx_policy.attrib["name"]
1531             else:
1532                 log.error(
1533                     'policy item %s does not have the required "name" attribute',
1534                     admx_policy.attrib,
1535                 )
1536                 break
1537             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
1538             if (
1539                 ENABLED_VALUE_XPATH(admx_policy)
1540                 and this_policy_setting == "Not Configured"
1541             ):
1542                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
1543                     admx_policy
1544                 ):
1545                     element_only_enabled_disabled = False
1546                     explicit_enable_disable_value_setting = True
1547                 if _checkValueItemParent(
1548                     admx_policy,
1549                     this_policyname,
1550                     this_key,
1551                     this_valuename,
1552                     ENABLED_VALUE_XPATH,
1553                     policy_file_data,
1554                 ):
1555                     this_policy_setting = "Enabled"
1556                     log.trace(
1557                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
1558                     )
1559                     if this_policynamespace not in policy_vals:
1560                         policy_vals[this_policynamespace] = {}
1561                     policy_vals[this_policynamespace][
1562                         this_policyname
1563                     ] = this_policy_setting
1564             if (
1565                 DISABLED_VALUE_XPATH(admx_policy)
1566                 and this_policy_setting == "Not Configured"
1567             ):
1568                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
1569                     element_only_enabled_disabled = False
1570                     explicit_enable_disable_value_setting = True
1571                 if _checkValueItemParent(
1572                     admx_policy,
1573                     this_policyname,
1574                     this_key,
1575                     this_valuename,
1576                     DISABLED_VALUE_XPATH,
1577                     policy_file_data,
1578                 ):
1579                     this_policy_setting = "Disabled"
1580                     log.trace(
1581                         "%s is disabled by detected DISABLED_VALUE_XPATH",
1582                         this_policyname,
1583                     )
1584                     if this_policynamespace not in policy_vals:
1585                         policy_vals[this_policynamespace] = {}
1586                     policy_vals[this_policynamespace][
1587                         this_policyname
1588                     ] = this_policy_setting
1589             if (
1590                 ENABLED_LIST_XPATH(admx_policy)
1591                 and this_policy_setting == "Not Configured"
1592             ):
1593                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
1594                     admx_policy
1595                 ):
1596                     element_only_enabled_disabled = False
1597                     explicit_enable_disable_value_setting = True
1598                 if _checkListItem(
1599                     admx_policy,
1600                     this_policyname,
1601                     this_key,
1602                     ENABLED_LIST_XPATH,
1603                     policy_file_data,
1604                 ):
1605                     this_policy_setting = "Enabled"
1606                     log.trace(
1607                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
1608                     )
1609                     if this_policynamespace not in policy_vals:
1610                         policy_vals[this_policynamespace] = {}
1611                     policy_vals[this_policynamespace][
1612                         this_policyname
1613                     ] = this_policy_setting
1614             if (
1615                 DISABLED_LIST_XPATH(admx_policy)
1616                 and this_policy_setting == "Not Configured"
1617             ):
1618                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
1619                     element_only_enabled_disabled = False
1620                     explicit_enable_disable_value_setting = True
1621                 if _checkListItem(
1622                     admx_policy,
1623                     this_policyname,
1624                     this_key,
1625                     DISABLED_LIST_XPATH,
1626                     policy_file_data,
1627                 ):
1628                     this_policy_setting = "Disabled"
1629                     log.trace(
1630                         "%s is disabled by detected DISABLED_LIST_XPATH",
1631                         this_policyname,
1632                     )
1633                     if this_policynamespace not in policy_vals:
1634                         policy_vals[this_policynamespace] = {}
1635                     policy_vals[this_policynamespace][
1636                         this_policyname
1637                     ] = this_policy_setting
1638             if not explicit_enable_disable_value_setting and this_valuename:
1639                 if _regexSearchRegPolData(
1640                     re.escape(
1641                         _buildKnownDataSearchString(
1642                             this_key, this_valuename, "REG_DWORD", "1"
1643                         )
1644                     ),
1645                     policy_file_data,
1646                 ):
1647                     this_policy_setting = "Enabled"
1648                     log.trace(
1649                         "%s is enabled by no explicit enable/disable list or value",
1650                         this_policyname,
1651                     )
1652                     if this_policynamespace not in policy_vals:
1653                         policy_vals[this_policynamespace] = {}
1654                     policy_vals[this_policynamespace][
1655                         this_policyname
1656                     ] = this_policy_setting
1657                 elif _regexSearchRegPolData(
1658                     re.escape(
1659                         _buildKnownDataSearchString(
1660                             this_key,
1661                             this_valuename,
1662                             "REG_DWORD",
1663                             None,
1664                             check_deleted=True,
1665                         )
1666                     ),
1667                     policy_file_data,
1668                 ):
1669                     this_policy_setting = "Disabled"
1670                     log.trace(
1671                         "%s is disabled by no explicit enable/disable list or value",
1672                         this_policyname,
1673                     )
1674                     if this_policynamespace not in policy_vals:
1675                         policy_vals[this_policynamespace] = {}
1676                     policy_vals[this_policynamespace][
1677                         this_policyname
1678                     ] = this_policy_setting
1679             if ELEMENTS_XPATH(admx_policy):
1680                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
1681                     required_elements = {}
1682                     configured_elements = {}
1683                     policy_disabled_elements = 0
1684                     for elements_item in ELEMENTS_XPATH(admx_policy):
1685                         for child_item in elements_item:
1686                             this_element_name = _getFullPolicyName(
1687                                 policy_item=child_item,
1688                                 policy_name=child_item.attrib["id"],
1689                                 return_full_policy_names=return_full_policy_names,
1690 <a name="4"></a>                                adml_language=adml_language,
1691                             )
1692                             required_elements[this_element_name] = None
1693                             child_key <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= child_item.attrib.get("key", this_key)
1694                             child_valuename = child_item.attrib.get(
1695                                 "valueName", this_valuename
1696                             )
1697                             if etree.QName(child_item).</b></font>localname == "boolean":
1698                                 if child_item is not None:
1699                                     if (
1700                                         TRUE_VALUE_XPATH(child_item)
1701                                         and this_element_name not in configured_elements
1702                                     ):
1703                                         if _checkValueItemParent(
1704                                             child_item,
1705                                             this_policyname,
1706                                             child_key,
1707                                             child_valuename,
1708                                             TRUE_VALUE_XPATH,
1709                                             policy_file_data,
1710                                         ):
1711                                             configured_elements[
1712                                                 this_element_name
1713                                             ] = True
1714                                             log.trace(
1715                                                 "element %s is configured true",
1716                                                 child_item.attrib["id"],
1717                                             )
1718                                     if (
1719                                         FALSE_VALUE_XPATH(child_item)
1720                                         and this_element_name not in configured_elements
1721                                     ):
1722                                         if _checkValueItemParent(
1723                                             child_item,
1724                                             this_policyname,
1725                                             child_key,
1726                                             child_valuename,
1727                                             FALSE_VALUE_XPATH,
1728                                             policy_file_data,
1729                                         ):
1730                                             configured_elements[
1731                                                 this_element_name
1732                                             ] = False
1733                                             policy_disabled_elements = (
1734                                                 policy_disabled_elements + 1
1735                                             )
1736                                             log.trace(
1737                                                 "element %s is configured false",
1738                                                 child_item.attrib["id"],
1739                                             )
1740                                     if (
1741                                         TRUE_LIST_XPATH(child_item)
1742                                         and this_element_name not in configured_elements
1743                                     ):
1744                                         log.trace("checking trueList")
1745                                         if _checkListItem(
1746                                             child_item,
1747                                             this_policyname,
1748                                             this_key,
1749                                             TRUE_LIST_XPATH,
1750                                             policy_file_data,
1751                                         ):
1752                                             configured_elements[
1753                                                 this_element_name
1754                                             ] = True
1755                                             log.trace(
1756                                                 "element %s is configured true",
1757                                                 child_item.attrib["id"],
1758                                             )
1759                                     if (
1760                                         FALSE_LIST_XPATH(child_item)
1761                                         and this_element_name not in configured_elements
1762                                     ):
1763                                         log.trace("checking falseList")
1764                                         if _checkListItem(
1765                                             child_item,
1766                                             this_policyname,
1767                                             this_key,
1768                                             FALSE_LIST_XPATH,
1769                                             policy_file_data,
1770                                         ):
1771                                             configured_elements[
1772                                                 this_element_name
1773                                             ] = False
1774                                             policy_disabled_elements = (
1775                                                 policy_disabled_elements + 1
1776                                             )
1777                                             log.trace(
1778                                                 "element %s is configured false",
1779                                                 child_item.attrib["id"],
1780                                             )
1781                                 else:
1782                                     if _regexSearchRegPolData(
1783                                         re.escape(
1784                                             _processValueItem(
1785                                                 child_item,
1786                                                 child_key,
1787                                                 child_valuename,
1788                                                 admx_policy,
1789                                                 elements_item,
1790                                                 check_deleted=True,
1791                                             )
1792                                         ),
1793                                         policy_file_data,
1794                                     ):
1795                                         configured_elements[this_element_name] = False
1796                                         policy_disabled_elements = (
1797                                             policy_disabled_elements + 1
1798                                         )
1799                                         log.trace(
1800                                             "element %s is configured false",
1801                                             child_item.attrib["id"],
1802                                         )
1803                                     elif _regexSearchRegPolData(
1804                                         re.escape(
1805                                             _processValueItem(
1806                                                 child_item,
1807                                                 child_key,
1808                                                 child_valuename,
1809                                                 admx_policy,
1810                                                 elements_item,
1811                                                 check_deleted=False,
1812                                             )
1813                                         ),
1814                                         policy_file_data,
1815                                     ):
1816                                         configured_elements[this_element_name] = True
1817                                         log.trace(
1818                                             "element %s is configured true",
1819                                             child_item.attrib["id"],
1820                                         )
1821                             elif (
1822                                 etree.QName(child_item).localname == "decimal"
1823                                 or etree.QName(child_item).localname == "text"
1824                                 or etree.QName(child_item).localname == "longDecimal"
1825                                 or etree.QName(child_item).localname == "multiText"
1826                             ):
1827                                 if _regexSearchRegPolData(
1828                                     re.escape(
1829                                         _processValueItem(
1830                                             child_item,
1831                                             child_key,
1832                                             child_valuename,
1833                                             admx_policy,
1834                                             elements_item,
1835                                             check_deleted=True,
1836                                         )
1837                                     ),
1838                                     policy_file_data,
1839                                 ):
1840                                     configured_elements[this_element_name] = "Disabled"
1841                                     policy_disabled_elements = (
1842                                         policy_disabled_elements + 1
1843                                     )
1844                                     log.trace(
1845                                         "element %s is disabled",
1846                                         child_item.attrib["id"],
1847                                     )
1848                                 elif _regexSearchRegPolData(
1849                                     re.escape(
1850                                         _processValueItem(
1851                                             child_item,
1852                                             child_key,
1853                                             child_valuename,
1854                                             admx_policy,
1855                                             elements_item,
1856                                             check_deleted=False,
1857                                         )
1858                                     ),
1859                                     policy_file_data,
1860                                 ):
1861                                     configured_value = _getDataFromRegPolData(
1862                                         _processValueItem(
1863                                             child_item,
1864                                             child_key,
1865                                             child_valuename,
1866                                             admx_policy,
1867                                             elements_item,
1868                                             check_deleted=False,
1869                                         ),
1870                                         policy_file_data,
1871                                     )
1872                                     configured_elements[
1873                                         this_element_name
1874                                     ] = configured_value
1875                                     log.trace(
1876                                         "element %s is enabled, value == %s",
1877                                         child_item.attrib["id"],
1878                                         configured_value,
1879                                     )
1880                             elif etree.QName(child_item).localname == "enum":
1881                                 if _regexSearchRegPolData(
1882                                     re.escape(
1883                                         _processValueItem(
1884                                             child_item,
1885                                             child_key,
1886                                             child_valuename,
1887                                             admx_policy,
1888                                             elements_item,
1889                                             check_deleted=True,
1890                                         )
1891                                     ),
1892                                     policy_file_data,
1893                                 ):
1894                                     log.trace(
1895                                         "enum element %s is disabled",
1896                                         child_item.attrib["id"],
1897                                     )
1898                                     configured_elements[this_element_name] = "Disabled"
1899                                     policy_disabled_elements = (
1900                                         policy_disabled_elements + 1
1901                                     )
1902                                 else:
1903                                     for enum_item in child_item:
1904                                         if _checkValueItemParent(
1905                                             enum_item,
1906                                             child_item.attrib["id"],
1907                                             child_key,
1908                                             child_valuename,
1909                                             VALUE_XPATH,
1910                                             policy_file_data,
1911                                         ):
1912                                             if VALUE_LIST_XPATH(enum_item):
1913                                                 log.trace("enum item has a valueList")
1914                                                 if _checkListItem(
1915                                                     enum_item,
1916                                                     this_policyname,
1917                                                     child_key,
1918                                                     VALUE_LIST_XPATH,
1919                                                     policy_file_data,
1920                                                 ):
1921                                                     log.trace(
1922                                                         "all valueList items exist in"
1923                                                         " file"
1924                                                     )
1925                                                     configured_elements[
1926                                                         this_element_name
1927                                                     ] = _getAdmlDisplayName(
1928                                                         adml_policy_resources,
1929                                                         enum_item.attrib["displayName"],
1930                                                     )
1931                                                     break
1932                                             else:
1933                                                 configured_elements[
1934                                                     this_element_name
1935                                                 ] = _getAdmlDisplayName(
1936                                                     adml_policy_resources,
1937                                                     enum_item.attrib["displayName"],
1938                                                 )
1939                                                 break
1940                             elif etree.QName(child_item).localname == "list":
1941                                 return_value_name = False
1942                                 if (
1943                                     "explicitValue" in child_item.attrib
1944                                     and child_item.attrib["explicitValue"].lower()
1945                                     == "true"
1946                                 ):
1947                                     log.trace(
1948                                         "explicitValue list, we will return value names"
1949                                     )
1950                                     return_value_name = True
1951                                 regex_str = [
1952                                     r"(?!\*",
1953                                     r"\*",
1954                                     "D",
1955                                     "e",
1956                                     "l",
1957                                     "V",
1958                                     "a",
1959                                     "l",
1960                                     "s",
1961                                     r"\.",
1962                                     ")",
1963                                 ]
1964                                 delvals_regex = "\x00".join(regex_str)
1965                                 delvals_regex = salt.utils.stringutils.to_bytes(
1966                                     delvals_regex
1967                                 )
1968                                 if _regexSearchRegPolData(
1969                                     re.escape(
1970                                         _processValueItem(
1971                                             child_item,
1972                                             child_key,
1973                                             child_valuename,
1974                                             admx_policy,
1975                                             elements_item,
1976                                             check_deleted=False,
1977                                         )
1978                                     )
1979                                     + delvals_regex,
1980                                     policy_file_data,
1981                                 ):
1982                                     configured_value = _getDataFromRegPolData(
1983                                         _processValueItem(
1984                                             child_item,
1985                                             child_key,
1986                                             child_valuename,
1987                                             admx_policy,
1988                                             elements_item,
1989                                             check_deleted=False,
1990                                         ),
1991                                         policy_file_data,
1992                                         return_value_name=return_value_name,
1993                                     )
1994                                     configured_elements[
1995                                         this_element_name
1996                                     ] = configured_value
1997                                     log.trace(
1998                                         "element %s is enabled values: %s",
1999                                         child_item.attrib["id"],
2000                                         configured_value,
2001                                     )
2002                                 elif _regexSearchRegPolData(
2003                                     re.escape(
2004                                         _processValueItem(
2005                                             child_item,
2006                                             child_key,
2007                                             child_valuename,
2008                                             admx_policy,
2009                                             elements_item,
2010                                             check_deleted=True,
2011                                         )
2012                                     ),
2013                                     policy_file_data,
2014                                 ):
2015                                     configured_elements[this_element_name] = "Disabled"
2016                                     policy_disabled_elements = (
2017                                         policy_disabled_elements + 1
2018                                     )
2019                                     log.trace(
2020                                         "element %s is disabled",
2021                                         child_item.attrib["id"],
2022                                     )
2023                     if element_only_enabled_disabled:
2024                         if len(required_elements.keys()) &gt; 0 and len(
2025                             configured_elements.keys()
2026                         ) == len(required_elements.keys()):
2027                             if policy_disabled_elements == len(
2028                                 required_elements.keys()
2029                             ):
2030                                 log.trace(
2031                                     "%s is disabled by all enum elements",
2032                                     this_policyname,
2033                                 )
2034                                 if this_policynamespace not in policy_vals:
2035                                     policy_vals[this_policynamespace] = {}
2036                                 policy_vals[this_policynamespace][
2037                                     this_policyname
2038                                 ] = "Disabled"
2039                             else:
2040                                 if this_policynamespace not in policy_vals:
2041                                     policy_vals[this_policynamespace] = {}
2042                                 policy_vals[this_policynamespace][
2043                                     this_policyname
2044                                 ] = configured_elements
2045                                 log.trace(
2046                                     "%s is enabled by enum elements", this_policyname
2047                                 )
2048                     else:
2049                         if this_policy_setting == "Enabled":
2050                             if this_policynamespace not in policy_vals:
2051                                 policy_vals[this_policynamespace] = {}
2052                             policy_vals[this_policynamespace][
2053                                 this_policyname
2054                             ] = configured_elements
2055             if (
2056                 return_full_policy_names
2057                 and this_policynamespace in policy_vals
2058                 and this_policyname in policy_vals[this_policynamespace]
2059             ):
2060                 if this_policynamespace not in full_names:
2061                     full_names[this_policynamespace] = {}
2062                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
2063                     policy_item=admx_policy,
2064                     policy_name=admx_policy.attrib["name"],
2065                     return_full_policy_names=return_full_policy_names,
2066                     adml_language=adml_language,
2067                 )
2068                 if (
2069                     this_policyname
2070                     in policy_vals[this_policynamespace][this_policyname]
2071                 ):
2072                     full_name = full_names[this_policynamespace][this_policyname]
2073                     setting = policy_vals[this_policynamespace][this_policyname].pop(
2074                         this_policyname
2075                     )
2076                     policy_vals[this_policynamespace][this_policyname][
2077                         full_name
2078                     ] = setting
2079             if (
2080                 this_policynamespace in policy_vals
2081                 and this_policyname in policy_vals[this_policynamespace]
2082             ):
2083                 if this_policynamespace not in hierarchy:
2084                     hierarchy[this_policynamespace] = {}
2085                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
2086                     policy_definition=admx_policy,
2087                     return_full_policy_names=return_full_policy_names,
2088                     adml_language=adml_language,
2089                 )
2090         log.trace("Examination complete: %s seconds", time.time() - start_time)
2091     if policy_vals and return_full_policy_names and not hierarchical_return:
2092         log.debug("Compiling non hierarchical return...")
2093         start_time = time.time()
2094         unpathed_dict = {}
2095         pathed_dict = {}
2096         for policy_namespace in list(policy_vals):
2097             for policy_item in list(policy_vals[policy_namespace]):
2098                 if (
2099                     full_names[policy_namespace][policy_item]
2100                     in policy_vals[policy_namespace]
2101                 ):
2102                     full_path_list = hierarchy[policy_namespace][policy_item]
2103                     full_path_list.reverse()
2104                     full_path_list.append(full_names[policy_namespace][policy_item])
2105                     policy_vals["\\".join(full_path_list)] = policy_vals[
2106                         policy_namespace
2107                     ].pop(policy_item)
2108                     pathed_dict[full_names[policy_namespace][policy_item]] = True
2109                 else:
2110                     policy_vals[policy_namespace][
2111                         full_names[policy_namespace][policy_item]
2112                     ] = policy_vals[policy_namespace].pop(policy_item)
2113                     if policy_namespace not in unpathed_dict:
2114                         unpathed_dict[policy_namespace] = {}
2115                     unpathed_dict[policy_namespace][
2116                         full_names[policy_namespace][policy_item]
2117                     ] = policy_item
2118             if policy_namespace in unpathed_dict:
2119                 for path_needed in unpathed_dict[policy_namespace]:
2120                     full_path_list = hierarchy[policy_namespace][
2121                         unpathed_dict[policy_namespace][path_needed]
2122                     ]
2123                     full_path_list.reverse()
2124                     full_path_list.append(path_needed)
2125                     log.trace("full_path_list == %s", full_path_list)
2126                     policy_vals["\\".join(full_path_list)] = policy_vals[
2127                         policy_namespace
2128                     ].pop(path_needed)
2129         log.trace("Compilation complete: %s seconds", time.time() - start_time)
2130     for policy_namespace in list(policy_vals):
2131         if policy_vals[policy_namespace] == {}:
2132             policy_vals.pop(policy_namespace)
2133     if policy_vals and hierarchical_return:
2134         if hierarchy:
2135             log.debug("Compiling hierarchical return...")
2136             start_time = time.time()
2137             for policy_namespace in hierarchy:
2138                 for hierarchy_item in hierarchy[policy_namespace]:
2139                     if hierarchy_item in policy_vals[policy_namespace]:
2140                         tdict = {}
2141                         first_item = True
2142                         for item in hierarchy[policy_namespace][hierarchy_item]:
2143                             newdict = {}
2144                             if first_item:
2145                                 h_policy_name = hierarchy_item
2146                                 if return_full_policy_names:
2147                                     h_policy_name = full_names[policy_namespace][
2148                                         hierarchy_item
2149                                     ]
2150                                 newdict[item] = {
2151                                     h_policy_name: policy_vals[policy_namespace].pop(
2152                                         hierarchy_item
2153                                     )
2154                                 }
2155                                 first_item = False
2156                             else:
2157                                 newdict[item] = tdict
2158                             tdict = newdict
2159                         if tdict:
2160                             policy_vals = dictupdate.update(policy_vals, tdict)
2161                 if (
2162                     policy_namespace in policy_vals
2163                     and policy_vals[policy_namespace] == {}
2164                 ):
2165                     policy_vals.pop(policy_namespace)
2166             log.trace("Compilation complete: %s seconds", time.time() - start_time)
2167         policy_vals = {
2168             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
2169                 "Administrative Templates": policy_vals
2170             }
2171         }
2172     return policy_vals
2173 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
2174     parent_list = []
2175     policy_namespace = next(iter(policy_definition.nsmap))
2176     parent_category = policy_definition.xpath(
2177         "{}:parentCategory/@ref".format(policy_namespace),
2178         namespaces=policy_definition.nsmap,
2179     )
2180     admx_policy_definitions = _get_policy_definitions(language=adml_language)
2181     if parent_category:
2182         parent_category = parent_category[0]
2183         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
2184             policy_namespace
2185         )
2186         this_namespace_map = _buildElementNsmap(
2187             admx_policy_definitions.xpath(
2188                 nsmap_xpath, namespaces=policy_definition.nsmap
2189             )
2190         )
2191         this_namespace_map = dictupdate.update(
2192             this_namespace_map, policy_definition.nsmap
2193         )
2194         parent_list = _admx_policy_parent_walk(
2195             path=parent_list,
2196             policy_namespace=policy_namespace,
2197             parent_category=parent_category,
2198             policy_nsmap=this_namespace_map,
2199             return_full_policy_names=return_full_policy_names,
2200             adml_language=adml_language,
2201         )
2202     return parent_list
2203 def _admx_policy_parent_walk(
2204     path,
2205     policy_namespace,
2206     parent_category,
2207     policy_nsmap,
2208     return_full_policy_names,
2209     adml_language,
2210 ):
2211     admx_policy_definitions = _get_policy_definitions(language<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=adml_language)
2212     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
2213     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
2214     if parent_category.find(":") &gt;= 0:
2215         policy_namespace = parent_category.split(":")[0]
2216         parent_category = parent_category.</b></font>split(":")[1]
2217         using_xpath_string = using_xpath_string.format(policy_namespace)
2218         policy_nsmap = dictupdate.update(
2219             policy_nsmap,
2220             _buildElementNsmap(
2221                 admx_policy_definitions.xpath(
2222                     using_xpath_string, namespaces=policy_nsmap
2223                 )
2224             ),
2225         )
2226     category_xpath_string = category_xpath_string.format(
2227         policy_namespace, parent_category
2228     )
2229     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
2230         tparent_category = admx_policy_definitions.xpath(
2231             category_xpath_string, namespaces=policy_nsmap
2232         )[0]
2233         this_parent_name = _getFullPolicyName(
2234             policy_item=tparent_category,
2235             policy_name=tparent_category.attrib["name"],
2236             return_full_policy_names=return_full_policy_names,
2237             adml_language=adml_language,
2238         )
2239         path.append(this_parent_name)
2240         if tparent_category.xpath(
2241             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
2242         ):
2243             path = _admx_policy_parent_walk(
2244                 path=path,
2245                 policy_namespace=policy_namespace,
2246                 parent_category=tparent_category.xpath(
2247                     "{}:parentCategory/@ref".format(policy_namespace),
2248                     namespaces=policy_nsmap,
2249                 )[0],
2250                 policy_nsmap=policy_nsmap,
2251                 return_full_policy_names=return_full_policy_names,
2252                 adml_language=adml_language,
2253             )
2254     return path
2255 def _read_regpol_file(reg_pol_path):
2256     returndata = None
2257     if os.path.exists(reg_pol_path):
2258         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
2259             returndata = pol_file.read()
2260     return returndata
2261 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
2262     if policy_data:
2263         regex_str = [
2264             r"(\*",
2265             r"\*",
2266             "D",
2267             "e",
2268             "l",
2269             r"\.",
2270             r"|\*",
2271             r"\*",
2272             "D",
2273             "e",
2274             "l",
2275             "V",
2276             "a",
2277             "l",
2278             "s",
2279             r"\.",
2280             "){0,1}",
2281         ]
2282         specialValueRegex = "\x00".join(regex_str)
2283         specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)
2284         _thisSearch = b"".join(
2285             [
2286                 salt.utils.stringutils.to_bytes(r"\["),
2287                 re.escape(policy_regpath),
2288                 b"\x00;\x00",
2289                 specialValueRegex,
2290                 re.escape(policy_regkey.lstrip(b"\x00")),
2291                 b"\x00;",
2292             ]
2293         )
2294         match = re.search(_thisSearch, policy_data, re.IGNORECASE)
2295         if match:
2296             return policy_data[
2297                 match.start() : (policy_data.index(b"]", match.end())) + 2
2298             ]
2299     return None
2300 def _write_regpol_data(
2301     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
2302 ):
2303     if not os.path.exists(policy_file_path):
2304         __salt__["file.makedirs"](policy_file_path)
2305     try:
2306         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
2307             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
2308             if not data_to_write.startswith(reg_pol_header):
2309                 pol_file.write(reg_pol_header)
2310             pol_file.write(data_to_write)
2311     except Exception as e:  # pylint: disable=broad-except
2312         msg = (
2313             "An error occurred attempting to write to {}, the exception was: {}".format(
2314                 policy_file_path, e
2315             )
2316         )
2317         log.exception(msg)
2318         raise CommandExecutionError(msg)
2319     gpt_ini_data = ""
2320     if os.path.exists(gpt_ini_path):
2321         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
2322             gpt_ini_data = gpt_file.read()
2323         gpt_ini_data = (
2324             gpt_ini_data.replace("\r\n", "_|-")
2325             .replace("\n", "_|-")
2326             .replace("_|-", "\r\n")
2327         )
2328     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
2329         gpt_ini_data = "[General]\r\n" + gpt_ini_data
2330     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
2331         gpt_ext_loc = re.search(
2332             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
2333             gpt_ini_data,
2334             re.IGNORECASE | re.MULTILINE,
2335         )
2336         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.end()]
2337         if not _regexSearchRegPolData(
2338             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
2339         ):
2340             gpt_ext_str = gpt_ext_str.split("=")
2341             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
2342             gpt_ext_str = "=".join(gpt_ext_str)
2343             gpt_ini_data = (
2344                 gpt_ini_data[0 : gpt_ext_loc.start()]
2345                 + gpt_ext_str
2346                 + gpt_ini_data[gpt_ext_loc.end() :]
2347             )
2348     else:
2349         general_location = re.search(
2350             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
2351         )
2352         gpt_ini_data = "{}{}={}\r\n{}".format(
2353             gpt_ini_data[general_location.start() : general_location.end()],
2354             gpt_extension,
2355             gpt_extension_guid,
2356             gpt_ini_data[general_location.end() :],
2357         )
2358     if _regexSearchRegPolData(r"Version=", gpt_ini_data):
2359         version_loc = re.search(
2360             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
2361         )
2362         version_str = gpt_ini_data[version_loc.start() : version_loc.end()]
2363         version_str = version_str.split("=")
2364         version_nums = struct.unpack(b"&gt;2H", struct.pack(b"&gt;I", int(version_str[1])))
2365         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
2366             version_nums = (version_nums[0], version_nums[1] + 1)
2367         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
2368             version_nums = (version_nums[0] + 1, version_nums[1])
2369         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
2370         gpt_ini_data = "{}{}={}\r\n{}".format(
2371             gpt_ini_data[0 : version_loc.start()],
2372             "Version",
2373             version_num,
2374             gpt_ini_data[version_loc.end() :],
2375         )
2376     else:
2377         general_location = re.search(
2378             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
2379         )
2380         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
2381             version_nums = (0, 1)
2382         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
2383             version_nums = (1, 0)
2384         gpt_ini_data = "{}{}={}\r\n{}".format(
2385             gpt_ini_data[general_location.start() : general_location.end()],
2386             "Version",
2387             int(
2388                 "{}{}".format(
2389                     str(version_nums[0]).zfill(4),
2390                     str(version_nums[1]).zfill(4),
2391                 ),
2392                 16,
2393             ),
2394             gpt_ini_data[general_location.end() :],
2395         )
2396     if gpt_ini_data:
2397         try:
2398             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
2399                 gpt_file.write(gpt_ini_data)
2400         except Exception as e:  # pylint: disable=broad-except
2401             msg = (
2402                 "An error occurred attempting to write the gpg.ini file.\n"
2403                 "path: {}\n"
2404                 "exception: {}".format(gpt_ini_path, e)
2405             )
2406             log.exception(msg)
2407             raise CommandExecutionError(msg)
2408 def _policyFileReplaceOrAppendList(string_list, policy_data):
2409     if not policy_data:
2410         policy_data = b""
2411     specialValueRegex = salt.utils.stringutils.to_bytes(
2412         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
2413     )
2414     for this_string in string_list:
2415         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
2416         list_item_value_name = re.sub(
2417             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
2418         )
2419         log.trace("item value name is %s", list_item_value_name)
2420         data_to_replace = _regexSearchKeyValueCombo(
2421             policy_data, list_item_key, list_item_value_name
2422         )
2423         if data_to_replace:
2424             log.trace("replacing %s with %s", data_to_replace, this_string)
2425             policy_data = policy_data.replace(data_to_replace, this_string)
2426         else:
2427             log.trace("appending %s", this_string)
2428             policy_data = b"".join([policy_data, this_string])
2429     return policy_data
2430 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):
2431     if not policy_data:
2432         policy_data = b""
2433     specialValueRegex = salt.utils.stringutils.to_bytes(
2434         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
2435     )
2436     item_key = None
2437     item_value_name = None
2438     data_to_replace = None
2439     if not append_only:
2440         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
2441         item_value_name = re.sub(
2442             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
2443         )
2444         log.trace("item value name is %s", item_value_name)
2445         data_to_replace = _regexSearchKeyValueCombo(
2446             policy_data, item_key, item_value_name
2447         )
2448     if data_to_replace:
2449         log.trace("replacing %s with %s", data_to_replace, this_string)
2450         policy_data = policy_data.replace(data_to_replace, this_string)
2451     else:
2452         log.trace("appending %s", this_string)
2453         policy_data = b"".join([policy_data, this_string])
2454     return policy_data
2455 def _writeAdminTemplateRegPolFile(
2456     admtemplate_data, adml_language="en-US", registry_class="Machine"
2457 ):
2458     r"""
2459     helper function to prep/write adm template data to the Registry.pol file
2460     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
2461     REGISTRY_FILE_VERSION (u'\x01\00')
2462     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
2463     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
2464     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
2465     """
2466     existing_data = b""
2467     policy_data = _policy_info()
2468     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
2469     admx_policy_definitions = _get_policy_definitions(language=adml_language)
2470     adml_policy_resources = _get_policy_resources(language=adml_language)
2471     base_policy_settings = _checkAllAdmxPolicies(
2472         policy_class=registry_class,
2473         adml_language=adml_language,
2474         return_full_policy_names=False,
2475         hierarchical_return=False,
2476         return_not_configured=False,
2477     )
2478     for adm_namespace in admtemplate_data:
2479         for adm_policy in admtemplate_data[adm_namespace]:
2480             if (
2481                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
2482                 == "not configured"
2483             ):
2484                 if (
2485                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
2486                     is not None
2487                 ):
2488                     log.trace('Policy "%s" removed', adm_policy)
2489             else:
2490                 log.trace("adding %s to base_policy_settings", adm_policy)
2491                 if adm_namespace not in base_policy_settings:
2492                     base_policy_settings[adm_namespace] = {}
2493                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
2494                     adm_namespace
2495                 ][adm_policy]
2496     for adm_namespace in base_policy_settings:
2497         for admPolicy in base_policy_settings[adm_namespace]:
2498             log.trace("working on admPolicy %s", admPolicy)
2499             explicit_enable_disable_value_setting = False
2500             this_key = None
2501             this_valuename = None
2502             if (
2503                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
2504                 == "disabled"
2505             ):
2506                 log.trace("time to disable %s", admPolicy)
2507                 this_policy = admx_policy_definitions.xpath(
2508                     policySearchXpath.format(admPolicy),
2509                     namespaces={"ns1": adm_namespace},
2510                 )
2511                 if this_policy:
2512                     this_policy = this_policy[0]
2513                     if "class" in this_policy.attrib:
2514                         if (
2515                             this_policy.attrib["class"] == registry_class
2516                             or this_policy.attrib["class"] == "Both"
2517                         ):
2518                             if "key" in this_policy.attrib:
2519                                 this_key = this_policy.attrib["key"]
2520                             else:
2521                                 log.error(
2522                                     "policy item %s does not have "
2523                                     'the required "key" attribute',
2524                                     this_policy.attrib,
2525                                 )
2526                                 break
2527                             if "valueName" in this_policy.attrib:
2528                                 this_valuename = this_policy.attrib["valueName"]
2529                             if DISABLED_VALUE_XPATH(this_policy):
2530                                 explicit_enable_disable_value_setting = True
2531                                 disabled_value_string = _checkValueItemParent(
2532                                     this_policy,
2533                                     admPolicy,
2534                                     this_key,
2535                                     this_valuename,
2536                                     DISABLED_VALUE_XPATH,
2537                                     None,
2538                                     check_deleted=False,
2539                                     test_item=False,
2540                                 )
2541                                 existing_data = _policyFileReplaceOrAppend(
2542                                     disabled_value_string, existing_data
2543                                 )
2544                             if DISABLED_LIST_XPATH(this_policy):
2545                                 explicit_enable_disable_value_setting = True
2546                                 disabled_list_strings = _checkListItem(
2547                                     this_policy,
2548                                     admPolicy,
2549                                     this_key,
2550                                     DISABLED_LIST_XPATH,
2551                                     None,
2552                                     test_items=False,
2553                                 )
2554                                 log.trace(
2555                                     "working with disabledList portion of %s",
2556                                     admPolicy,
2557                                 )
2558                                 existing_data = _policyFileReplaceOrAppendList(
2559                                     disabled_list_strings, existing_data
2560                                 )
2561                             if (
2562                                 not explicit_enable_disable_value_setting
2563                                 and this_valuename
2564                             ):
2565                                 disabled_value_string = _buildKnownDataSearchString(
2566                                     this_key,
2567                                     this_valuename,
2568                                     "REG_DWORD",
2569                                     None,
2570                                     check_deleted=True,
2571                                 )
2572                                 existing_data = _policyFileReplaceOrAppend(
2573                                     disabled_value_string, existing_data
2574                                 )
2575                             if ELEMENTS_XPATH(this_policy):
2576                                 log.trace("checking elements of %s", admPolicy)
2577                                 for elements_item in ELEMENTS_XPATH(this_policy):
2578                                     for child_item in elements_item:
2579                                         child_key = this_key
2580                                         child_valuename = this_valuename
2581                                         if "key" in child_item.attrib:
2582                                             child_key = child_item.attrib["key"]
2583                                         if "valueName" in child_item.attrib:
2584                                             child_valuename = child_item.attrib[
2585                                                 "valueName"
2586                                             ]
2587                                         if etree.QName(
2588                                             child_item
2589                                         ).localname == "boolean" and (
2590                                             TRUE_LIST_XPATH(child_item)
2591                                             or FALSE_LIST_XPATH(child_item)
2592                                         ):
2593                                             temp_dict = {
2594                                                 "trueList": TRUE_LIST_XPATH,
2595                                                 "falseList": FALSE_LIST_XPATH,
2596                                             }
2597                                             for this_list in temp_dict:
2598                                                 disabled_list_strings = _checkListItem(
2599                                                     child_item,
2600                                                     admPolicy,
2601                                                     child_key,
2602                                                     temp_dict[this_list],
2603                                                     None,
2604                                                     test_items=False,
2605                                                 )
2606                                                 log.trace(
2607                                                     "working with %s portion of %s",
2608                                                     admPolicy,
2609                                                     this_list,
2610                                                 )
2611                                                 existing_data = (
2612                                                     _policyFileReplaceOrAppendList(
2613                                                         disabled_list_strings,
2614                                                         existing_data,
2615                                                     )
2616                                                 )
2617                                         elif (
2618                                             etree.QName(child_item).localname
2619                                             == "boolean"
2620                                             or etree.QName(child_item).localname
2621                                             == "decimal"
2622                                             or etree.QName(child_item).localname
2623                                             == "text"
2624                                             or etree.QName(child_item).localname
2625                                             == "longDecimal"
2626                                             or etree.QName(child_item).localname
2627                                             == "multiText"
2628                                             or etree.QName(child_item).localname
2629                                             == "enum"
2630                                         ):
2631                                             disabled_value_string = _processValueItem(
2632                                                 child_item,
2633                                                 child_key,
2634                                                 child_valuename,
2635                                                 this_policy,
2636                                                 elements_item,
2637                                                 check_deleted=True,
2638                                             )
2639                                             log.trace(
2640                                                 "I have disabled value string of %s",
2641                                                 disabled_value_string,
2642                                             )
2643                                             existing_data = _policyFileReplaceOrAppend(
2644                                                 disabled_value_string, existing_data
2645                                             )
2646                                         elif (
2647                                             etree.QName(child_item).localname == "list"
2648                                         ):
2649                                             disabled_value_string = _processValueItem(
2650                                                 child_item,
2651                                                 child_key,
2652                                                 child_valuename,
2653                                                 this_policy,
2654                                                 elements_item,
2655                                                 check_deleted=True,
2656                                             )
2657                                             log.trace(
2658                                                 "I have disabled value string of %s",
2659                                                 disabled_value_string,
2660                                             )
2661                                             existing_data = _policyFileReplaceOrAppend(
2662                                                 disabled_value_string, existing_data
2663                                             )
2664                         else:
2665                             log.error(
2666                                 "policy %s was found but it does not appear to be valid"
2667                                 " for the class %s",
2668                                 admPolicy,
2669                                 registry_class,
2670                             )
2671                     else:
2672                         log.error(
2673                             'policy item %s does not have the required "class"'
2674                             " attribute",
2675                             this_policy.attrib,
2676                         )
2677             else:
2678                 log.trace('time to enable and set the policy "%s"', admPolicy)
2679                 this_policy = admx_policy_definitions.xpath(
2680                     policySearchXpath.format(admPolicy),
2681                     namespaces={"ns1": adm_namespace},
2682                 )
2683                 log.trace("found this_policy == %s", this_policy)
2684                 if this_policy:
2685                     this_policy = this_policy[0]
2686                     if "class" in this_policy.attrib:
2687                         if (
2688                             this_policy.attrib["class"] == registry_class
2689                             or this_policy.attrib["class"] == "Both"
2690                         ):
2691                             if "key" in this_policy.attrib:
2692                                 this_key = this_policy.attrib["key"]
2693                             else:
2694                                 log.error(
2695                                     'policy item %s does not have the required "key"'
2696                                     " attribute",
2697                                     this_policy.attrib,
2698                                 )
2699                                 break
2700                             if "valueName" in this_policy.attrib:
2701                                 this_valuename = this_policy.attrib["valueName"]
2702                             if ENABLED_VALUE_XPATH(this_policy):
2703                                 explicit_enable_disable_value_setting = True
2704                                 enabled_value_string = _checkValueItemParent(
2705                                     this_policy,
2706                                     admPolicy,
2707                                     this_key,
2708                                     this_valuename,
2709                                     ENABLED_VALUE_XPATH,
2710                                     None,
2711                                     check_deleted=False,
2712                                     test_item=False,
2713                                 )
2714                                 existing_data = _policyFileReplaceOrAppend(
2715                                     enabled_value_string, existing_data
2716                                 )
2717                             if ENABLED_LIST_XPATH(this_policy):
2718                                 explicit_enable_disable_value_setting = True
2719                                 enabled_list_strings = _checkListItem(
2720                                     this_policy,
2721                                     admPolicy,
2722                                     this_key,
2723                                     ENABLED_LIST_XPATH,
2724                                     None,
2725                                     test_items=False,
2726                                 )
2727                                 log.trace(
2728                                     "working with enabledList portion of %s", admPolicy
2729                                 )
2730                                 existing_data = _policyFileReplaceOrAppendList(
2731                                     enabled_list_strings, existing_data
2732                                 )
2733                             if (
2734                                 not explicit_enable_disable_value_setting
2735                                 and this_valuename
2736                             ):
2737                                 enabled_value_string = _buildKnownDataSearchString(
2738                                     this_key,
2739                                     this_valuename,
2740                                     "REG_DWORD",
2741                                     "1",
2742                                     check_deleted=False,
2743                                 )
2744                                 existing_data = _policyFileReplaceOrAppend(
2745                                     enabled_value_string, existing_data
2746                                 )
2747                             if ELEMENTS_XPATH(this_policy):
2748                                 for elements_item in ELEMENTS_XPATH(this_policy):
2749                                     for child_item in elements_item:
2750                                         child_key = this_key
2751                                         child_valuename = this_valuename
2752                                         if "key" in child_item.attrib:
2753                                             child_key = child_item.attrib["key"]
2754                                         if "valueName" in child_item.attrib:
2755                                             child_valuename = child_item.attrib[
2756                                                 "valueName"
2757                                             ]
2758                                         if (
2759                                             child_item.attrib["id"]
2760                                             in base_policy_settings[adm_namespace][
2761                                                 admPolicy
2762                                             ]
2763                                         ):
2764                                             if etree.QName(
2765                                                 child_item
2766                                             ).localname == "boolean" and (
2767                                                 TRUE_LIST_XPATH(child_item)
2768                                                 or FALSE_LIST_XPATH(child_item)
2769                                             ):
2770                                                 list_strings = []
2771                                                 if base_policy_settings[adm_namespace][
2772                                                     admPolicy
2773                                                 ][child_item.attrib["id"]]:
2774                                                     list_strings = _checkListItem(
2775                                                         child_item,
2776                                                         admPolicy,
2777                                                         child_key,
2778                                                         TRUE_LIST_XPATH,
2779                                                         None,
2780                                                         test_items=False,
2781                                                     )
2782                                                     log.trace(
2783                                                         "working with trueList portion"
2784                                                         " of %s",
2785                                                         admPolicy,
2786                                                     )
2787                                                 else:
2788                                                     list_strings = _checkListItem(
2789                                                         child_item,
2790                                                         admPolicy,
2791                                                         child_key,
2792                                                         FALSE_LIST_XPATH,
2793                                                         None,
2794                                                         test_items=False,
2795                                                     )
2796                                                 existing_data = (
2797                                                     _policyFileReplaceOrAppendList(
2798                                                         list_strings, existing_data
2799                                                     )
2800                                                 )
2801                                             elif etree.QName(
2802                                                 child_item
2803                                             ).localname == "boolean" and (
2804                                                 TRUE_VALUE_XPATH(child_item)
2805                                                 or FALSE_VALUE_XPATH(child_item)
2806                                             ):
2807                                                 value_string = ""
2808                                                 if base_policy_settings[adm_namespace][
2809                                                     admPolicy
2810                                                 ][child_item.attrib["id"]]:
2811                                                     value_string = (
2812                                                         _checkValueItemParent(
2813                                                             child_item,
2814                                                             admPolicy,
2815                                                             child_key,
2816                                                             child_valuename,
2817                                                             TRUE_VALUE_XPATH,
2818                                                             None,
2819                                                             check_deleted=False,
2820                                                             test_item=False,
2821                                                         )
2822                                                     )
2823                                                 else:
2824                                                     value_string = (
2825                                                         _checkValueItemParent(
2826                                                             child_item,
2827                                                             admPolicy,
2828                                                             child_key,
2829                                                             child_valuename,
2830                                                             FALSE_VALUE_XPATH,
2831                                                             None,
2832                                                             check_deleted=False,
2833                                                             test_item=False,
2834                                                         )
2835                                                     )
2836                                                 existing_data = (
2837                                                     _policyFileReplaceOrAppend(
2838                                                         value_string, existing_data
2839                                                     )
2840                                                 )
2841                                             elif (
2842                                                 etree.QName(child_item).localname
2843                                                 == "boolean"
2844                                                 or etree.QName(child_item).localname
2845                                                 == "decimal"
2846                                                 or etree.QName(child_item).localname
2847                                                 == "text"
2848                                                 or etree.QName(child_item).localname
2849                                                 == "longDecimal"
2850                                                 or etree.QName(child_item).localname
2851                                                 == "multiText"
2852                                             ):
2853                                                 enabled_value_string = _processValueItem(
2854                                                     child_item,
2855                                                     child_key,
2856                                                     child_valuename,
2857                                                     this_policy,
2858                                                     elements_item,
2859                                                     check_deleted=False,
2860                                                     this_element_value=base_policy_settings[
2861                                                         adm_namespace
2862                                                     ][
2863                                                         admPolicy
2864                                                     ][
2865                                                         child_item.attrib["id"]
2866                                                     ],
2867                                                 )
2868                                                 log.trace(
2869                                                     "I have enabled value string of %s",
2870                                                     enabled_value_string,
2871                                                 )
2872                                                 existing_data = (
2873                                                     _policyFileReplaceOrAppend(
2874                                                         enabled_value_string,
2875                                                         existing_data,
2876                                                     )
2877                                                 )
2878                                             elif (
2879                                                 etree.QName(child_item).localname
2880                                                 == "enum"
2881                                             ):
2882                                                 for enum_item in child_item:
2883                                                     if (
2884                                                         base_policy_settings[
2885                                                             adm_namespace
2886                                                         ][admPolicy][
2887                                                             child_item.attrib["id"]
2888                                                         ]
2889                                                         == _getAdmlDisplayName(
2890                                                             adml_policy_resources,
2891                                                             enum_item.attrib[
2892                                                                 "displayName"
2893                                                             ],
2894                                                         ).strip()
2895                                                     ):
2896                                                         enabled_value_string = (
2897                                                             _checkValueItemParent(
2898                                                                 enum_item,
2899                                                                 child_item.attrib["id"],
2900                                                                 child_key,
2901                                                                 child_valuename,
2902                                                                 VALUE_XPATH,
2903                                                                 None,
2904                                                                 check_deleted=False,
2905                                                                 test_item=False,
2906                                                             )
2907                                                         )
2908                                                         existing_data = (
2909                                                             _policyFileReplaceOrAppend(
2910                                                                 enabled_value_string,
2911                                                                 existing_data,
2912                                                             )
2913                                                         )
2914                                                         if VALUE_LIST_XPATH(enum_item):
2915                                                             enabled_list_strings = (
2916                                                                 _checkListItem(
2917                                                                     enum_item,
2918                                                                     admPolicy,
2919                                                                     child_key,
2920                                                                     VALUE_LIST_XPATH,
2921                                                                     None,
2922                                                                     test_items=False,
2923                                                                 )
2924                                                             )
2925                                                             log.trace(
2926                                                                 "working with valueList"
2927                                                                 " portion of %s",
2928                                                                 child_item.attrib["id"],
2929                                                             )
2930                                                             existing_data = _policyFileReplaceOrAppendList(
2931                                                                 enabled_list_strings,
2932                                                                 existing_data,
2933                                                             )
2934                                                         break
2935                                             elif (
2936                                                 etree.QName(child_item).localname
2937                                                 == "list"
2938                                             ):
2939                                                 enabled_value_string = _processValueItem(
2940                                                     child_item,
2941                                                     child_key,
2942                                                     child_valuename,
2943                                                     this_policy,
2944                                                     elements_item,
2945                                                     check_deleted=False,
2946                                                     this_element_value=base_policy_settings[
2947                                                         adm_namespace
2948                                                     ][
2949                                                         admPolicy
2950                                                     ][
2951                                                         child_item.attrib["id"]
2952                                                     ],
2953                                                 )
2954                                                 log.trace(
2955                                                     "I have enabled value string of %s",
2956                                                     enabled_value_string,
2957                                                 )
2958                                                 existing_data = (
2959                                                     _policyFileReplaceOrAppend(
2960                                                         enabled_value_string,
2961                                                         existing_data,
2962                                                         append_only=True,
2963                                                     )
2964                                                 )
2965     try:
2966         _write_regpol_data(
2967             existing_data,
2968             policy_data.admx_registry_classes[registry_class]["policy_path"],
2969             policy_data.gpt_ini_path,
2970             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
2971             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
2972         )
2973     except CommandExecutionError as exc:  # pylint: disable=broad-except
2974         log.exception(
2975             "Unhandled exception occurred while attempting to "
2976             "write Adm Template Policy File.\nException: %s",
2977             exc,
2978         )
2979         return False
2980     return True
2981 def _getScriptSettingsFromIniFile(policy_info):
2982     _existingData = None
2983     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
2984         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
2985             _existingData = fhr.read()
2986         if _existingData:
2987             try:
2988                 _existingData = deserialize(
2989                     _existingData.decode("utf-16-le").lstrip("\ufeff")
2990                 )
2991                 log.trace("Have deserialized data %s", _existingData)
2992             except Exception as error:  # pylint: disable=broad-except
2993                 log.exception(
2994                     "An error occurred attempting to deserialize data for %s",
2995                     policy_info["Policy"],
2996                 )
2997                 raise CommandExecutionError(error)
2998             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
2999                 "Section"
3000             ].lower() in [z.lower() for z in _existingData.keys()]:
3001                 if "SettingName" in policy_info["ScriptIni"]:
3002                     log.trace(
3003                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
3004                     )
3005                     if policy_info["ScriptIni"]["SettingName"].lower() in [
3006                         z.lower()
3007                         for z in _existingData[
3008                             policy_info["ScriptIni"]["Section"]
3009                         ].keys()
3010                     ]:
3011                         return _existingData[policy_info["ScriptIni"]["Section"]][
3012                             policy_info["ScriptIni"]["SettingName"].lower()
3013                         ]
3014                     else:
3015                         return None
3016                 else:
3017                     return _existingData[policy_info["ScriptIni"]["Section"]]
3018             else:
3019                 return None
3020     return None
3021 def _writeGpoScript(psscript=False):
3022     _machineScriptPolicyPath = os.path.join(
3023         os.getenv("WINDIR"),
3024         "System32",
3025         "GroupPolicy",
3026         "Machine",
3027         "Scripts",
3028         "scripts.ini",
3029     )
3030     _machinePowershellScriptPolicyPath = os.path.join(
3031         os.getenv("WINDIR"),
3032         "System32",
3033         "GroupPolicy",
3034         "Machine",
3035         "Scripts",
3036         "psscripts.ini",
3037     )
3038     _userScriptPolicyPath = os.path.join(
3039         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
3040     )
3041     _userPowershellScriptPolicyPath = os.path.join(
3042         os.getenv("WINDIR"),
3043         "System32",
3044         "GroupPolicy",
3045         "User",
3046         "Scripts",
3047         "psscripts.ini",
3048     )
3049 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
3050     policy_aliases = []
3051     admx_policy_definitions = _get_policy_definitions(language=adml_language)
3052     adml_policy_resources = _get_policy_resources(language=adml_language)
3053     admx_search_results = ADMX_SEARCH_XPATH(
3054         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
3055     )
3056     if admx_search_results:
3057         if len(admx_search_results) == 1:
3058             the_policy = admx_search_results[0]
3059             policy_display_name = _getFullPolicyName(
3060                 policy_item=the_policy,
3061                 policy_name=the_policy.attrib["name"],
3062                 return_full_policy_names=True,
3063                 adml_language=adml_language,
3064             )
3065             policy_aliases.append(policy_display_name)
3066             policy_aliases.append(the_policy.attrib["name"])
3067             full_path_list = _build_parent_list(
3068                 policy_definition=the_policy,
3069                 return_full_policy_names=True,
3070                 adml_language=adml_language,
3071             )
3072             full_path_list.reverse()
3073             full_path_list.append(policy_display_name)
3074             policy_aliases.append("\\".join(full_path_list))
3075             return True, the_policy, policy_aliases, None
3076         else:
3077             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
3078             return False, None, [], msg
3079     else:
3080         adml_search_results = ADML_SEARCH_XPATH(
3081             adml_policy_resources, policy_name=policy_name
3082         )
3083         hierarchy = []
3084         hierarchy_policy_name = policy_name
3085         if not adml_search_results:
3086             log.warning("Trying another: %s", policy_name)
3087             if "\\" in policy_name:
3088                 hierarchy = policy_name.split("\\")
3089                 policy_name = hierarchy.pop()
3090                 adml_search_results = ADML_SEARCH_XPATH(
3091                     adml_policy_resources, policy_name=policy_name
3092                 )
3093         if adml_search_results:
3094             multiple_adml_entries = False
3095             suggested_policies = ""
3096             adml_to_remove = []
3097             if len(adml_search_results) &gt; 1:
3098                 log.trace(
3099                     "multiple ADML entries found matching the policy name %s",
3100                     policy_name,
3101                 )
3102                 multiple_adml_entries = True
3103                 for adml_search_result in adml_search_results:
3104                     if (
3105                         not getattr(adml_search_result, "text", "").strip()
3106                         == policy_name
3107                     ):
3108                         adml_to_remove.append(adml_search_result)
3109                     else:
3110                         if hierarchy:
3111                             log.trace("we have hierarchy of %s", hierarchy)
3112                             display_name_searchval = "$({}.{})".format(
3113                                 adml_search_result.tag.split("}")[1],
3114                                 adml_search_result.attrib["id"],
3115                             )
3116                             policy_search_string = (
3117                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
3118                                 ' or @class = "{}") ]'.format(
3119                                     adml_search_result.prefix,
3120                                     display_name_searchval,
3121                                     policy_class,
3122                                 )
3123                             )
3124                             admx_results = []
3125                             these_admx_search_results = admx_policy_definitions.xpath(
3126                                 policy_search_string,
3127                                 namespaces=adml_search_result.nsmap,
3128                             )
3129                             if not these_admx_search_results:
3130                                 log.trace(
3131                                     "No admx was found for the adml entry %s, it will"
3132                                     " be removed",
3133                                     display_name_searchval,
3134                                 )
3135                                 adml_to_remove.append(adml_search_result)
3136                             for search_result in these_admx_search_results:
3137                                 log.trace("policy_name == %s", policy_name)
3138                                 this_hierarchy = _build_parent_list(
3139                                     policy_definition=search_result,
3140                                     return_full_policy_names=True,
3141                                     adml_language=adml_language,
3142                                 )
3143                                 this_hierarchy.reverse()
3144                                 if hierarchy != this_hierarchy:
3145                                     log.trace(
3146                                         "hierarchy %s does not match this item's"
3147                                         " hierarchy of %s",
3148                                         hierarchy,
3149                                         this_hierarchy,
3150                                     )
3151                                     if len(these_admx_search_results) == 1:
3152                                         log.trace(
3153                                             "only 1 admx was found and it does not "
3154                                             "match this adml, it is safe to remove "
3155                                             "from the list"
3156                                         )
3157                                         adml_to_remove.append(adml_search_result)
3158                                 else:
3159                                     log.trace(
3160                                         "hierarchy %s matches item's hierarchy of %s",
3161                                         hierarchy,
3162                                         this_hierarchy,
3163                                     )
3164                                     log.trace(
3165                                         "search_result %s added to results",
3166                                         search_result,
3167                                     )
3168                                     admx_results.append(search_result)
3169                             if len(admx_results) == 1:
3170                                 admx_search_results.append(admx_results[0])
3171                         else:
3172                             display_name_searchval = "$({}.{})".format(
3173                                 adml_search_result.tag.split("}")[1],
3174                                 adml_search_result.attrib["id"],
3175                             )
3176                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
3177                                 admx_policy_definitions,
3178                                 display_name=display_name_searchval,
3179                                 registry_class=policy_class,
3180                             )
3181                             if not these_admx_search_results:
3182                                 adml_to_remove.append(adml_search_result)
3183             for adml in adml_to_remove:
3184                 if adml in adml_search_results:
3185                     adml_search_results.remove(adml)
3186             if len(adml_search_results) == 1 and multiple_adml_entries:
3187                 multiple_adml_entries = False
3188             for adml_search_result in adml_search_results:
3189                 log.trace(
3190                     "found an ADML entry matching the string! %s -- %s",
3191                     adml_search_result.tag,
3192                     adml_search_result.attrib,
3193                 )
3194                 display_name_searchval = "$({}.{})".format(
3195                     adml_search_result.tag.split("}")[1],
3196                     adml_search_result.attrib["id"],
3197                 )
3198                 log.trace("searching for displayName == %s", display_name_searchval)
3199                 if not admx_search_results:
3200                     log.trace(
3201                         "search for an admx entry matching display_name %s and"
3202                         " registry_class %s",
3203                         display_name_searchval,
3204                         policy_class,
3205                     )
3206                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
3207                         admx_policy_definitions,
3208                         display_name=display_name_searchval,
3209                         registry_class=policy_class,
3210                     )
3211                 if admx_search_results:
3212                     log.trace(
3213                         "processing admx_search_results of %s", admx_search_results
3214                     )
3215                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
3216                     if (
3217                         len(admx_search_results) == 1 or hierarchy
3218                     ) and not multiple_adml_entries:
3219                         found = False
3220                         for search_result in admx_search_results:
3221                             found = False
3222                             if hierarchy:
3223                                 this_hierarchy = _build_parent_list(
3224                                     policy_definition=search_result,
3225                                     return_full_policy_names=True,
3226                                     adml_language=adml_language,
3227                                 )
3228                                 this_hierarchy.reverse()
3229                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
3230                                 if hierarchy == this_hierarchy:
3231                                     found = True
3232                             else:
3233                                 found = True
3234                             if found:
3235                                 log.trace(
3236                                     "found the ADMX policy matching "
3237                                     "the display name %s -- %s",
3238                                     search_result,
3239                                     policy_name,
3240                                 )
3241                                 if "name" in search_result.attrib:
3242                                     policy_display_name = _getFullPolicyName(
3243                                         policy_item=search_result,
3244                                         policy_name=search_result.attrib["name"],
3245                                         return_full_policy_names=True,
3246                                         adml_language=adml_language,
3247                                     )
3248                                     policy_aliases.append(policy_display_name)
3249                                     policy_aliases.append(search_result.attrib["name"])
3250                                     full_path_list = _build_parent_list(
3251                                         policy_definition=search_result,
3252                                         return_full_policy_names=True,
3253                                         adml_language=adml_language,
3254                                     )
3255                                     full_path_list.reverse()
3256                                     full_path_list.append(policy_display_name)
3257                                     policy_aliases.append("\\".join(full_path_list))
3258                                     return True, search_result, policy_aliases, None
3259                                 else:
3260                                     msg = (
3261                                         "ADMX policy with the display name {} does not"
3262                                         "have the required name attribute"
3263                                     )
3264                                     msg = msg.format(policy_name)
3265                                     return False, None, [], msg
3266                         if not found:
3267                             msg = "Unable to correlate {} to any policy".format(
3268                                 hierarchy_policy_name
3269                             )
3270                             return False, None, [], msg
3271                     else:
3272                         for possible_policy in admx_search_results:
3273                             this_parent_list = _build_parent_list(
3274                                 policy_definition=possible_policy,
3275                                 return_full_policy_names=True,
3276                                 adml_language=adml_language,
3277                             )
3278                             this_parent_list.reverse()
3279                             this_parent_list.append(policy_name)
3280                             if suggested_policies:
3281                                 suggested_policies = ", ".join(
3282                                     [suggested_policies, "\\".join(this_parent_list)]
3283                                 )
3284                             else:
3285                                 suggested_policies = "\\".join(this_parent_list)
3286             if suggested_policies:
3287                 msg = (
3288                     'ADML policy name "{}" is used as the display name for '
3289                     "multiple policies. These policies matched: {}. You can "
3290                     "utilize these long names to specify the correct policy"
3291                 )
3292                 return False, None, [], msg.format(policy_name, suggested_policies)
3293     return (
3294         False,
3295         None,
3296         [],
3297         "Unable to find {} policy {}".format(policy_class, policy_name),
3298     )
3299 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
3300     r"""
3301     Returns information about a specified policy
3302     Args:
3303         policy_name (str):
3304             The name of the policy to lookup
3305         policy_class (str):
3306             The class of policy, i.e. machine, user, both
3307         adml_language (str):
3308             The ADML language to use for Administrative Template data lookup
3309     Returns:
3310         dict: Information about the specified policy
3311     CLI Example:
3312     .. code-block:: bash
3313         salt '*' lgpo.get_policy_info 'Maximum password age' machine
3314     You can use ``lgpo.get_policy_info`` to get all the possible names that
3315     could be used in a state file or from the command line (along with elements
3316     that need to be set/etc). The key is to match the text you see in the
3317     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
3318     "full path" style is really only needed when there are multiple policies
3319     that use the same base name. For example, ``Access data sources across
3320     domains`` exists in ~10 different paths. If you put that through
3321     ``get_policy_info`` you'll get back a message that it is used for multiple
3322     policies and you need to be more specific.
3323     CLI Example:
3324     .. code-block:: bash
3325         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
3326         local:
3327             ----------
3328             message:
3329             policy_aliases:
3330                 - Turn off the "Order Prints" picture task
3331                 - ShellRemoveOrderPrints_2
3332                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
3333             policy_class:
3334                 machine
3335             policy_elements:
3336             policy_found:
3337                 True
3338             policy_name:
3339                 ShellRemoveOrderPrints_2
3340             rights_assignment:
3341                 False
3342     Escaping can get tricky in cmd/Powershell. The following is an example of
3343     escaping in Powershell using backquotes:
3344     .. code-block:: bash
3345         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
3346         local:
3347             ----------
3348             message:
3349             policy_aliases:
3350                 - Turn off the "Order Prints" picture task
3351                 - ShellRemoveOrderPrints_2
3352                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
3353             policy_class:
3354                 machine
3355             policy_elements:
3356             policy_found:
3357                 True
3358             policy_name:
3359                 Turn off the "Order Prints" picture task
3360             rights_assignment:
3361                 False
3362     This function can then be used to get the options available for specifying
3363     Group Policy Objects to be used in state files. Based on the above any of
3364     these *should* be usable:
3365     .. code-block:: bash
3366         internet_communications_settings:
3367           lgpo.set:
3368             - computer_policy:
3369                 Turn off the "Order Prints" picture task: Enabled
3370     .. code-block:: bash
3371         internet_communications_settings:
3372           lgpo.set:
3373             - computer_policy:
3374                 ShellRemoveOrderPrints_2: Enabled
3375     When using the full path, it might be a good idea to use single quotes
3376     around the path:
3377     .. code-block:: bash
3378         internet_communications_settings:
3379           lgpo.set:
3380             - computer_policy:
3381                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
3382     If you struggle to find the policy from ``get_policy_info`` using the name
3383     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
3384     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
3385     relationships (ADML holds what you see in the GUI, ADMX holds the more
3386     technical details), then this may be a little bit too much info, but here is
3387     an example with the above policy using Powershell:
3388     .. code-block:: bash
3389         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
3390         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
3391         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
3392         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
3393         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
3394     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
3395     string used to describe this policy, then we search for it in the ADMX:
3396     .. code-block:: bash
3397         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
3398         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
3399         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
3400     Now we have two to pick from. And if you notice the ``class="Machine"`` and
3401     ``class="User"`` (which details if it is a computer policy or user policy
3402     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
3403     use to pass through ``get_policy_info`` to see what the module itself is
3404     expecting.
3405     Get a policy value
3406     Args:
3407         policy_class (str):
3408             Some policies are both user and computer, by default all policies
3409             will be pulled, but this can be used to retrieve only a specific
3410             policy class User/USER/user = retrieve user policies
3411             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
3412             machine/computer policies
3413         return_full_policy_names (bool):
3414             True/False to return the policy name as it is seen in the
3415             ``gpedit.msc`` GUI or to only return the policy key/id.
3416         hierarchical_return (bool):
3417             True/False to return the policy data in the hierarchy as seen in the
3418             ``gpedit.msc`` GUI. The default of False will return data split only
3419             into User/Computer configuration sections
3420         adml_language (str):
3421             The ADML language to use for processing display/descriptive names
3422             and enumeration values of ADMX template data, defaults to en-US
3423         return_not_configured (bool):
3424             Include Administrative Template policies that are 'Not Configured'
3425             in the return data
3426     Returns:
3427         dict: A dictionary containing the policy values for the specified class
3428     CLI Example:
3429     .. code-block:: bash
3430         salt '*' lgpo.get machine return_full_policy_names=True
3431     Some policies are defined in this module and others by the ADMX/ADML files
3432     on the machine. This function loads the current values for policies defined
3433     in this module.
3434     Args:
3435         policy_definition (dict):
3436             A sub-dict of Policies property of the _policy_info() class.
3437             Basically a dictionary that defines the policy
3438     Returns:
3439         The transformed value. The transform is defined in the policy
3440         definition. It can be a list, a string, a dictionary, depending on how
3441         it's defined
3442     Usage:
3443         policy_data = _policy_info()
3444         policy_name = 'RemoteRegistryExactPaths'
3445         policy_definition = policy_data.policies['Machine']['policies'][policy_name]
3446         policy_value = _get_policy_info_setting(policy_definition)
3447     Get the current setting for polices set via the policy templates (ADMX/ADML)
3448     files
3449     Args:
3450         admx_policy (obj):
3451             The XPath object as returned by the ``_lookup_admin_template``
3452             function
3453         policy_class (str):
3454             The policy class. Must be one of ``machine`` or ``user``
3455         adml_language (str):
3456             The language code for the adml file to use for localization. The
3457             default is ``en-US``
3458         return_full_policy_names (bool):
3459             Returns the full policy name regardless of what was passed in
3460             ``policy_name``
3461         hierarchical_return (bool):
3462             Returns a hierarchical view of the policy showing its parents
3463     Returns:
3464         dict: A dictionary containing the policy settings
3465     Usage:
3466         policy_name = 'AutoUpdateCfg'
3467         policy_class = 'machine'
3468         adml_language = 'en-US'
3469         success, policy_obj, _, _ = _lookup_admin_template(
3470             policy_name=policy_name,
3471             policy_class=policy_class,
3472             adml_language=adml_language)
3473         if success:
3474             setting = _get_policy_adm_setting(
3475                 admx_policy=policy_obj,
3476                 policy_class=policy_class,
3477                 adml_language=adml_language,
3478                 return_full_policy_names=return_full_policy_names,
3479                 hierarchical_return=hierarchical_return
3480             )
3481     if not policy_name:
3482         raise SaltInvocationError("policy_name must be defined")
3483     if not policy_class:
3484         raise SaltInvocationError("policy_class must be defined")
3485     policy_class = policy_class.title()
3486     policy_data = _policy_info()
3487     if policy_class not in policy_data.policies.keys():
3488         policy_classes = ", ".join(policy_data.policies.keys())
3489         raise CommandExecutionError(
3490             'The requested policy class "{}" is invalid, policy_class should '
3491             "be one of: {}".format(policy_class, policy_classes)
3492         )
3493     policy_definition = None
3494     if policy_name in policy_data.policies[policy_class]["policies"]:
3495         policy_definition = policy_data.policies[policy_class]["policies"][policy_name]
3496     else:
3497         for pol in policy_data.policies[policy_class]["policies"]:
3498             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
3499             if _p == policy_name:
3500                 policy_definition = policy_data.policies[policy_class]["policies"][pol]
3501                 break
3502         if policy_definition is None:
3503             for pol in policy_data.policies[policy_class]["policies"]:
3504                 _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
3505                 if _p.lower() == policy_name.lower():
3506                     policy_definition = policy_data.policies[policy_class]["policies"][
3507                         pol
3508                     ]
3509                     break
3510     if policy_definition:
3511         if return_value_only:
3512             return _get_policy_info_setting(policy_definition)
3513         if return_full_policy_names:
3514             key_name = policy_definition["Policy"]
3515         else:
3516             key_name = policy_name
3517         setting = {key_name: _get_policy_info_setting(policy_definition)}
3518         if hierarchical_return:
3519             if "lgpo_section" in policy_definition:
3520                 first_item = True
3521                 t_dict = {}
3522                 for level in reversed(policy_definition["lgpo_section"]):
3523                     new_dict = {}
3524                     if first_item:
3525                         new_dict[level] = {key_name: setting.pop(key_name)}
3526                         first_item = False
3527                     else:
3528                         new_dict[level] = t_dict
3529                     t_dict = new_dict
3530                 if t_dict:
3531                     setting = t_dict
3532         return setting
3533     success, policy_obj, _, _ = _lookup_admin_template(
3534         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
3535     )
3536     if success:
3537         setting = _get_policy_adm_setting(
3538             admx_policy=policy_obj,
3539             policy_class=policy_class,
3540             adml_language=adml_language,
3541             return_full_policy_names=return_full_policy_names,
3542             hierarchical_return=hierarchical_return,
3543         )
3544         if return_value_only:
3545             for key in setting:
3546                 return setting[key]
3547         return setting
3548 def set_computer_policy(
3549     name, setting, cumulative_rights_assignments=True, adml_language="en-US"
3550 ):
3551     pol = {}
3552     pol[name] = setting
3553     ret = set_(
3554         computer_policy=pol,
3555         user_policy=None,
3556         cumulative_rights_assignments=cumulative_rights_assignments,
3557         adml_language=adml_language,
3558     )
3559     return ret
3560 def set_user_policy(name, setting, adml_language="en-US"):
3561     pol = {}
3562     pol[name] = setting
3563     ret = set_(
3564         user_policy=pol,
3565         computer_policy=None,
3566         cumulative_rights_assignments=True,
3567         adml_language=adml_language,
3568     )
3569     return ret
3570 def set_(
3571     computer_policy=None,
3572     user_policy=None,
3573     cumulative_rights_assignments=True,
3574     adml_language="en-US",
3575 ):
3576     if computer_policy and not isinstance(computer_policy, dict):
3577         raise SaltInvocationError("computer_policy must be specified as a dict")
3578     if user_policy and not isinstance(user_policy, dict):
3579         raise SaltInvocationError("user_policy must be specified as a dict")
3580     policies = {}
3581     policies["User"] = user_policy
3582     policies["Machine"] = computer_policy
3583     if policies:
3584         adml_policy_resources = _get_policy_resources(language=adml_language)
3585         for p_class in policies:
3586             _secedits = {}
3587             _netshs = {}
3588             _advaudits = {}
3589             _modal_sets = {}
3590             _admTemplateData = {}
3591             _regedits = {}
3592             _lsarights = {}
3593             _policydata = _policy_info()
3594             if policies[p_class]:
3595                 for policy_name in policies[p_class]:
3596                     _pol = None
3597                     policy_key_name = policy_name
3598                     if policy_name in _policydata.policies[p_class]["policies"]:
3599                         _pol = _policydata.policies[p_class]["policies"][policy_name]
3600                     else:
3601                         for policy in _policydata.policies[p_class]["policies"]:
3602                             _p = _policydata.policies[p_class]["policies"][policy][
3603                                 "Policy"
3604                             ]
3605                             if _p == policy_name:
3606                                 _pol = _policydata.policies[p_class]["policies"][policy]
3607                                 policy_key_name = policy
3608                         if _pol is None:
3609                             for policy in _policydata.policies[p_class]["policies"]:
3610                                 _p = _policydata.policies[p_class]["policies"][policy][
3611                                     "Policy"
3612                                 ]
3613                                 if _p.lower() == policy_name.lower():
3614                                     _pol = _policydata.policies[p_class]["policies"][
3615                                         policy
3616                                     ]
3617                                     policy_key_name = policy
3618                     if _pol:
3619                         _value = _transform_value(
3620                             value=policies[p_class][policy_name],
3621                             policy=_policydata.policies[p_class]["policies"][
3622                                 policy_key_name
3623                             ],
3624                             transform_type="Put",
3625                         )
3626                         if not _validateSetting(
3627                             value=_value,
3628                             policy=_policydata.policies[p_class]["policies"][
3629                                 policy_key_name
3630                             ],
3631                         ):
3632                             raise SaltInvocationError(
3633                                 "The specified value {} is not an acceptable setting"
3634                                 " for policy {}.".format(
3635                                     policies[p_class][policy_name], policy_name
3636                                 )
3637                             )
3638                         if "Registry" in _pol:
3639                             log.trace("%s is a registry policy", policy_name)
3640                             _regedits[policy_name] = {"policy": _pol, "value": _value}
3641                         elif "Secedit" in _pol:
3642                             log.trace("%s is a Secedit policy", policy_name)
3643                             if _pol["Secedit"]["Section"] not in _secedits:
3644                                 _secedits[_pol["Secedit"]["Section"]] = []
3645                             _secedits[_pol["Secedit"]["Section"]].append(
3646                                 " ".join([_pol["Secedit"]["Option"], "=", str(_value)])
3647                             )
3648                         elif "NetSH" in _pol:
3649                             log.trace("%s is a NetSH policy", policy_name)
3650                             _netshs.setdefault(
3651                                 policy_name,
3652                                 {
3653                                     "profile": _pol["NetSH"]["Profile"],
3654                                     "section": _pol["NetSH"]["Section"],
3655                                     "option": _pol["NetSH"]["Option"],
3656                                     "value": str(_value),
3657                                 },
3658                             )
3659                         elif "AdvAudit" in _pol:
3660                             _advaudits.setdefault(
3661                                 policy_name,
3662                                 {
3663                                     "option": _pol["AdvAudit"]["Option"],
3664                                     "value": str(_value),
3665                                 },
3666                             )
3667                         elif "NetUserModal" in _pol:
3668                             log.trace("%s is a NetUserModal policy", policy_name)
3669                             if _pol["NetUserModal"]["Modal"] not in _modal_sets:
3670                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
3671                             _modal_sets[_pol["NetUserModal"]["Modal"]][
3672                                 _pol["NetUserModal"]["Option"]
3673                             ] = _value
3674                         elif "LsaRights" in _pol:
3675                             log.trace("%s is a LsaRights policy", policy_name)
3676                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
3677                     else:
3678                         _value = policies[p_class][policy_name]
3679                         log.trace('searching for "%s" in admx data', policy_name)
3680                         (
3681                             success,
3682                             the_policy,
3683                             policy_name_list,
3684                             msg,
3685                         ) = _lookup_admin_template(
3686                             policy_name=policy_name,
3687                             policy_class=p_class,
3688                             adml_language=adml_language,
3689                         )
3690                         if success:
3691                             policy_name = the_policy.attrib["name"]
3692                             policy_namespace = the_policy.nsmap[the_policy.prefix]
3693                             if policy_namespace not in _admTemplateData:
3694                                 _admTemplateData[policy_namespace] = {}
3695                             _admTemplateData[policy_namespace][policy_name] = _value
3696                         else:
3697                             raise SaltInvocationError(msg)
3698                         if (
3699                             policy_namespace
3700                             and policy_name in _admTemplateData[policy_namespace]
3701                             and the_policy is not None
3702                         ):
3703                             log.trace(
3704                                 "setting == %s",
3705                                 str(
3706                                     _admTemplateData[policy_namespace][policy_name]
3707                                 ).lower(),
3708                             )
3709                             log.trace(
3710                                 str(
3711                                     _admTemplateData[policy_namespace][policy_name]
3712                                 ).lower()
3713                             )
3714                             if (
3715                                 str(
3716                                     _admTemplateData[policy_namespace][policy_name]
3717                                 ).lower()
3718                                 != "disabled"
3719                                 and str(
3720                                     _admTemplateData[policy_namespace][policy_name]
3721                                 ).lower()
3722                                 != "not configured"
3723                             ):
3724                                 if ELEMENTS_XPATH(the_policy):
3725                                     if isinstance(
3726                                         _admTemplateData[policy_namespace][policy_name],
3727                                         dict,
3728                                     ):
3729                                         for elements_item in ELEMENTS_XPATH(the_policy):
3730                                             for child_item in elements_item:
3731                                                 log.trace(
3732                                                     "checking element %s",
3733                                                     child_item.attrib["id"],
3734                                                 )
3735                                                 temp_element_name = None
3736                                                 this_element_name = _getFullPolicyName(
3737                                                     policy_item=child_item,
3738                                                     policy_name=child_item.attrib["id"],
3739                                                     return_full_policy_names=True,
3740                                                     adml_language=adml_language,
3741                                                 )
3742                                                 log.trace(
3743                                                     'id attribute == "%s" '
3744                                                     ' this_element_name == "%s"',
3745                                                     child_item.attrib["id"],
3746                                                     this_element_name,
3747                                                 )
3748                                                 if (
3749                                                     this_element_name
3750                                                     in _admTemplateData[
3751                                                         policy_namespace
3752                                                     ][policy_name]
3753                                                 ):
3754                                                     temp_element_name = (
3755                                                         this_element_name
3756                                                     )
3757                                                 elif (
3758                                                     child_item.attrib["id"]
3759                                                     in _admTemplateData[
3760                                                         policy_namespace
3761                                                     ][policy_name]
3762                                                 ):
3763                                                     temp_element_name = (
3764                                                         child_item.attrib["id"]
3765                                                     )
3766                                                 else:
3767                                                     raise SaltInvocationError(
3768                                                         'Element "{}" must be included'
3769                                                         " in the policy configuration"
3770                                                         " for policy {}".format(
3771                                                             this_element_name,
3772                                                             policy_name,
3773                                                         )
3774                                                     )
3775                                                 if (
3776                                                     "required" in child_item.attrib
3777                                                     and child_item.attrib[
3778                                                         "required"
3779                                                     ].lower()
3780                                                     == "true"
3781                                                 ):
3782                                                     if not _admTemplateData[
3783                                                         policy_namespace
3784                                                     ][policy_name][temp_element_name]:
3785                                                         raise SaltInvocationError(
3786                                                             'Element "{}" requires a value '
3787                                                             "to be specified".format(
3788                                                                 temp_element_name
3789                                                             )
3790                                                         )
3791                                                 if (
3792                                                     etree.QName(child_item).localname
3793                                                     == "boolean"
3794                                                 ):
3795                                                     if not isinstance(
3796                                                         _admTemplateData[
3797                                                             policy_namespace
3798                                                         ][policy_name][
3799                                                             temp_element_name
3800                                                         ],
3801                                                         bool,
3802                                                     ):
3803                                                         raise SaltInvocationError(
3804                                                             "Element {} requires a boolean "
3805                                                             "True or False".format(
3806                                                                 temp_element_name
3807                                                             )
3808                                                         )
3809                                                 elif (
3810                                                     etree.QName(child_item).localname
3811                                                     == "decimal"
3812                                                     or etree.QName(child_item).localname
3813                                                     == "longDecimal"
3814                                                 ):
3815                                                     min_val = 0
3816                                                     max_val = 9999
3817                                                     if "minValue" in child_item.attrib:
3818                                                         min_val = int(
3819                                                             child_item.attrib[
3820                                                                 "minValue"
3821                                                             ]
3822                                                         )
3823                                                     if "maxValue" in child_item.attrib:
3824                                                         max_val = int(
3825                                                             child_item.attrib[
3826                                                                 "maxValue"
3827                                                             ]
3828                                                         )
3829                                                     if (
3830                                                         int(
3831                                                             _admTemplateData[
3832                                                                 policy_namespace
3833                                                             ][policy_name][
3834                                                                 temp_element_name
3835                                                             ]
3836                                                         )
3837                                                         &lt; min_val
3838                                                         or int(
3839                                                             _admTemplateData[
3840                                                                 policy_namespace
3841                                                             ][policy_name][
3842                                                                 temp_element_name
3843                                                             ]
3844                                                         )
3845                                                         &gt; max_val
3846                                                     ):
3847                                                         raise SaltInvocationError(
3848                                                             'Element "{}" value must be between '
3849                                                             "{} and {}".format(
3850                                                                 temp_element_name,
3851                                                                 min_val,
3852                                                                 max_val,
3853                                                             )
3854                                                         )
3855                                                 elif (
3856                                                     etree.QName(child_item).localname
3857                                                     == "enum"
3858                                                 ):
3859                                                     found = False
3860                                                     for enum_item in child_item:
3861                                                         if (
3862                                                             _admTemplateData[
3863                                                                 policy_namespace
3864                                                             ][policy_name][
3865                                                                 temp_element_name
3866                                                             ]
3867                                                             == _getAdmlDisplayName(
3868                                                                 adml_policy_resources,
3869                                                                 enum_item.attrib[
3870                                                                     "displayName"
3871                                                                 ],
3872                                                             ).strip()
3873                                                         ):
3874                                                             found = True
3875                                                             break
3876                                                     if not found:
3877                                                         raise SaltInvocationError(
3878                                                             'Element "{}" does not have'
3879                                                             " a valid value".format(
3880                                                                 temp_element_name
3881                                                             )
3882                                                         )
3883                                                 elif (
3884                                                     etree.QName(child_item).localname
3885                                                     == "list"
3886                                                 ):
3887                                                     if (
3888                                                         "explicitValue"
3889                                                         in child_item.attrib
3890                                                         and child_item.attrib[
3891                                                             "explicitValue"
3892                                                         ].lower()
3893                                                         == "true"
3894                                                     ):
3895                                                         if not isinstance(
3896                                                             _admTemplateData[
3897                                                                 policy_namespace
3898                                                             ][policy_name][
3899                                                                 temp_element_name
3900                                                             ],
3901                                                             dict,
3902                                                         ):
3903                                                             raise SaltInvocationError(
3904                                                                 "Each list item of element "
3905                                                                 '"{}" requires a dict '
3906                                                                 "value".format(
3907                                                                     temp_element_name
3908                                                                 )
3909                                                             )
3910                                                     elif not isinstance(
3911                                                         _admTemplateData[
3912                                                             policy_namespace
3913                                                         ][policy_name][
3914                                                             temp_element_name
3915                                                         ],
3916                                                         list,
3917                                                     ):
3918                                                         raise SaltInvocationError(
3919                                                             'Element "{}" requires a'
3920                                                             " list value".format(
3921                                                                 temp_element_name
3922                                                             )
3923                                                         )
3924                                                 elif (
3925                                                     etree.QName(child_item).localname
3926                                                     == "multiText"
3927                                                 ):
3928                                                     if not isinstance(
3929                                                         _admTemplateData[
3930                                                             policy_namespace
3931                                                         ][policy_name][
3932                                                             temp_element_name
3933                                                         ],
3934                                                         list,
3935                                                     ):
3936                                                         raise SaltInvocationError(
3937                                                             'Element "{}" requires a'
3938                                                             " list value".format(
3939                                                                 temp_element_name
3940                                                             )
3941                                                         )
3942                                                 _admTemplateData[policy_namespace][
3943                                                     policy_name
3944                                                 ][
3945                                                     child_item.attrib["id"]
3946                                                 ] = _admTemplateData[
3947                                                     policy_namespace
3948                                                 ][
3949                                                     policy_name
3950                                                 ].pop(
3951                                                     temp_element_name
3952                                                 )
3953                                     else:
3954                                         raise SaltInvocationError(
3955                                             'The policy "{}" has elements which must be'
3956                                             " configured".format(policy_name)
3957                                         )
3958                                 else:
3959                                     if (
3960                                         str(
3961                                             _admTemplateData[policy_namespace][
3962                                                 policy_name
3963                                             ]
3964                                         ).lower()
3965                                         != "enabled"
3966                                     ):
3967                                         raise SaltInvocationError(
3968                                             'The policy {} must either be "Enabled", '
3969                                             '"Disabled", or "Not Configured"'.format(
3970                                                 policy_name
3971                                             )
3972                                         )
3973                 if _regedits:
3974                     for regedit in _regedits:
3975                         log.trace("%s is a Registry policy", regedit)
3976                         if (
3977                             _regedits[regedit]["value"] is not None
3978                             and _regedits[regedit]["value"] != "(value not set)"
3979                         ):
3980                             _ret = __utils__["reg.set_value"](
3981                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
3982                                 _regedits[regedit]["policy"]["Registry"]["Path"],
3983                                 _regedits[regedit]["policy"]["Registry"]["Value"],
3984                                 _regedits[regedit]["value"],
3985                                 _regedits[regedit]["policy"]["Registry"]["Type"],
3986                             )
3987                         else:
3988                             _ret = __utils__["reg.read_value"](
3989                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
3990                                 _regedits[regedit]["policy"]["Registry"]["Path"],
3991                                 _regedits[regedit]["policy"]["Registry"]["Value"],
3992                             )
3993                             if _ret["success"] and _ret["vdata"] != "(value not set)":
3994                                 _ret = __utils__["reg.delete_value"](
3995                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
3996                                     _regedits[regedit]["policy"]["Registry"]["Path"],
3997                                     _regedits[regedit]["policy"]["Registry"]["Value"],
3998                                 )
3999                         if not _ret:
4000                             raise CommandExecutionError(
4001                                 "Error while attempting to set policy {} via the"
4002                                 " registry.  Some changes may not be applied as"
4003                                 " expected".format(regedit)
4004                             )
4005                 if _lsarights:
4006                     for lsaright in _lsarights:
4007                         _existingUsers = None
4008                         if not cumulative_rights_assignments:
4009                             _existingUsers = _getRightsAssignments(
4010                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
4011                             )
4012                         if _lsarights[lsaright]["value"]:
4013                             for acct in _lsarights[lsaright]["value"]:
4014                                 _ret = _addAccountRights(
4015                                     acct,
4016                                     _lsarights[lsaright]["policy"]["LsaRights"][
4017                                         "Option"
4018                                     ],
4019                                 )
4020                                 if not _ret:
4021                                     raise SaltInvocationError(
4022                                         "An error occurred attempting to configure the"
4023                                         " user right {}.".format(lsaright)
4024                                     )
4025                         if _existingUsers:
4026                             for acct in _existingUsers:
4027                                 if acct not in _lsarights[lsaright]["value"]:
4028                                     _ret = _delAccountRights(
4029                                         acct,
4030                                         _lsarights[lsaright]["policy"]["LsaRights"][
4031                                             "Option"
4032                                         ],
4033                                     )
4034                                     if not _ret:
4035                                         raise SaltInvocationError(
4036                                             "An error occurred attempting to remove previously "
4037                                             "configured users with right {}.".format(
4038                                                 lsaright
4039                                             )
4040                                         )
4041                 if _secedits:
4042                     log.trace(_secedits)
4043                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
4044                     _seceditSections = [
4045                         "System Access",
4046                         "Event Audit",
4047                         "Registry Values",
4048                         "Privilege Rights",
4049                     ]
4050                     for _seceditSection in _seceditSections:
4051                         if _seceditSection in _secedits:
4052                             ini_data = "\r\n".join(
4053                                 [
4054                                     ini_data,
4055                                     "".join(["[", _seceditSection, "]"]),
4056                                     "\r\n".join(_secedits[_seceditSection]),
4057                                 ]
4058                             )
4059                     ini_data = "\r\n".join(
4060                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
4061                     )
4062                     log.trace("ini_data == %s", ini_data)
4063                     if not _write_secedit_data(ini_data):
4064                         raise CommandExecutionError(
4065                             "Error while attempting to set policies via "
4066                             "secedit. Some changes may not be applied as "
4067                             "expected"
4068                         )
4069                 if _netshs:
4070                     for setting in _netshs:
4071                         log.trace("Setting firewall policy: %s", setting)
4072                         log.trace(_netshs[setting])
4073                         _set_netsh_value(**_netshs[setting])
4074                 if _advaudits:
4075                     for setting in _advaudits:
4076                         log.trace("Setting Advanced Audit policy: %s", setting)
4077                         log.trace(_advaudits[setting])
4078                         _set_advaudit_value(**_advaudits[setting])
4079                 if _modal_sets:
4080                     log.trace(_modal_sets)
4081                     for _modal_set in _modal_sets:
4082                         try:
4083                             _existingModalData = win32net.NetUserModalsGet(
4084                                 None, _modal_set
4085                             )
4086                             _newModalSetData = dictupdate.update(
4087                                 _existingModalData, _modal_sets[_modal_set]
4088                             )
4089                             log.trace("NEW MODAL SET = %s", _newModalSetData)
4090                             _ret = win32net.NetUserModalsSet(
4091                                 None, _modal_set, _newModalSetData
4092                             )
4093                         except Exception as exc:  # pylint: disable=broad-except
4094                             msg = (
4095                                 "An unhandled exception occurred while "
4096                                 "attempting to set policy via "
4097                                 "NetUserModalSet\n{}".format(exc)
4098                             )
4099                             log.exception(msg)
4100                             raise CommandExecutionError(msg)
4101                 if _admTemplateData:
4102                     _ret = False
4103                     log.trace(
4104                         "going to write some adm template data :: %s", _admTemplateData
4105                     )
4106                     _ret = _writeAdminTemplateRegPolFile(
4107                         _admTemplateData,
4108                         adml_language=adml_language,
4109                         registry_class=p_class,
4110                     )
4111                     if not _ret:
4112                         raise CommandExecutionError(
4113                             "Error while attempting to write Administrative Template"
4114                             " Policy data.  Some changes may not be applied as expected"
4115                         )
4116         return True
4117     else:
4118         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
