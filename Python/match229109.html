<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for win_pkg.py &amp; win_lgpo_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for win_pkg.py &amp; win_lgpo_1.py
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>win_pkg.py (3.1806617%)<th>win_lgpo_1.py (0.8430755%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(43-73)<td><a href="#" name="0">(39-63)</a><td align="center"><font color="#ff0000">24</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1584-1590)<td><a href="#" name="1">(5392-5405)</a><td align="center"><font color="#9f0000">15</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(2145-2154)<td><a href="#" name="2">(7456-7462)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(2024-2026)<td><a href="#" name="3">(5469-5471)</a><td align="center"><font color="#7f0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1033-1038)<td><a href="#" name="4">(6912-6917)</a><td align="center"><font color="#7f0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_pkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import errno
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
4 import os
5 import re
6 import sys
7 import time
8 import urllib.parse
9 from functools import cmp_to_key
10 import salt.payload
11 import salt.syspaths
12 import salt.utils.args
13 import salt.utils.data
14 import salt.utils.files
15 import salt.utils.hashutils
16 import salt.utils.path
17 import salt.utils.pkg
18 import salt.utils.platform
19 import salt.utils.versions
20 import salt.utils.win_functions
21 from salt.exceptions import (
22     CommandExecutionError,
23     MinionError,
24     SaltInvocationError,
25     SaltRenderError,
26 )
27 from salt.utils.versions import LooseVersion
28 log = logging.getLogger(__name__)
29 __virtualname__ =</b></font> "pkg"
30 def __virtual__():
31     if salt.utils.platform.is_windows():
32         return __virtualname__
33     return (False, "Module win_pkg: module only works on Windows systems")
34 def latest_version(*names, **kwargs):
35     if not names:
36         return ""
37     ret = {}
38     for name in names:
39         ret[name] = ""
40     saltenv = kwargs.get("saltenv", "base")
41     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
42     installed_pkgs = list_pkgs(versions_as_list=True, saltenv=saltenv, refresh=refresh)
43     log.trace("List of installed packages: %s", installed_pkgs)
44     for name in names:
45         latest_installed = "0"
46         if name in installed_pkgs:
47             log.trace("Determining latest installed version of %s", name)
48             try:
49                 latest_installed = sorted(
50                     installed_pkgs[name], key=cmp_to_key(_reverse_cmp_pkg_versions)
51                 ).pop()
52             except IndexError:
53                 log.warning(
54                     "%s was empty in pkg.list_pkgs return data, this is "
55                     "probably a bug in list_pkgs",
56                     name,
57                 )
58             else:
59                 log.debug(
60                     "Latest installed version of %s is %s", name, latest_installed
61                 )
62         pkg_info = _get_package_info(name, saltenv=saltenv)
63         log.trace("Raw winrepo pkg_info for %s is %s", name, pkg_info)
64         latest_available = _get_latest_pkg_version(pkg_info)
65         if latest_available:
66             log.debug(
67                 "Latest available version of package %s is %s", name, latest_available
68             )
69             if compare_versions(
70                 ver1=str(latest_available),
71                 oper="&gt;",
72                 ver2=str(latest_installed),
73             ):
74                 log.debug(
75                     "Upgrade of %s from %s to %s is available",
76                     name,
77                     latest_installed,
78                     latest_available,
79                 )
80                 ret[name] = latest_available
81             else:
82                 log.debug(
83                     "No newer version than %s of %s is available",
84                     latest_installed,
85                     name,
86                 )
87     if len(names) == 1:
88         return ret[names[0]]
89     return ret
90 def upgrade_available(name, **kwargs):
91     saltenv = kwargs.get("saltenv", "base")
92     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
93     return latest_version(name, saltenv=saltenv, refresh=refresh) != ""
94 def list_upgrades(refresh=True, **kwargs):
95     saltenv = kwargs.get("saltenv", "base")
96     refresh = salt.utils.data.is_true(refresh)
97     _refresh_db_conditional(saltenv, force=refresh)
98     installed_pkgs = list_pkgs(refresh=False, saltenv=saltenv)
99     available_pkgs = get_repo_data(saltenv).get("repo")
100     pkgs = {}
101     for pkg in installed_pkgs:
102         if pkg in available_pkgs:
103             latest_ver = latest_version(pkg, refresh=False, saltenv=saltenv)
104             if latest_ver:
105                 pkgs[pkg] = latest_ver
106     return pkgs
107 def list_available(*names, **kwargs):
108     if not names:
109         return ""
110     saltenv = kwargs.get("saltenv", "base")
111     refresh = salt.utils.data.is_true(kwargs.get("refresh", False))
112     _refresh_db_conditional(saltenv, force=refresh)
113     return_dict_always = salt.utils.data.is_true(
114         kwargs.get("return_dict_always", False)
115     )
116     if len(names) == 1 and not return_dict_always:
117         pkginfo = _get_package_info(names[0], saltenv=saltenv)
118         if not pkginfo:
119             return ""
120         versions = sorted(
121             list(pkginfo.keys()), key=cmp_to_key(_reverse_cmp_pkg_versions)
122         )
123     else:
124         versions = {}
125         for name in names:
126             pkginfo = _get_package_info(name, saltenv=saltenv)
127             if not pkginfo:
128                 continue
129             verlist = sorted(
130                 list(pkginfo.keys()) if pkginfo else [],
131                 key=cmp_to_key(_reverse_cmp_pkg_versions),
132             )
133             versions[name] = verlist
134     return versions
135 def version(*names, **kwargs):
136     saltenv = kwargs.get("saltenv", "base")
137     installed_pkgs = list_pkgs(saltenv=saltenv, refresh=kwargs.get("refresh", False))
138     if len(names) == 1:
139         return installed_pkgs.get(names[0], "")
140     ret = {}
141     for name in names:
142         ret[name] = installed_pkgs.get(name, "")
143     return ret
144 def list_pkgs(
145     versions_as_list=False, include_components=True, include_updates=True, **kwargs
146 ):
147     versions_as_list = salt.utils.data.is_true(versions_as_list)
148     if any(
149         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
150     ):
151         return {}
152     saltenv = kwargs.get("saltenv", "base")
153     refresh = salt.utils.data.is_true(kwargs.get("refresh", False))
154     _refresh_db_conditional(saltenv, force=refresh)
155     ret = {}
156     name_map = _get_name_map(saltenv)
157     for pkg_name, val_list in _get_reg_software(
158         include_components=include_components, include_updates=include_updates
159     ).items():
160         if pkg_name in name_map:
161             key = name_map[pkg_name]
162             for val in val_list:
163                 if val == "Not Found":
164                     pkg_info = _get_package_info(key, saltenv=saltenv)
165                     if not pkg_info:
166                         continue
167                     for pkg_ver in pkg_info.keys():
168                         if pkg_info[pkg_ver]["full_name"] == pkg_name:
169                             val = pkg_ver
170                 __salt__["pkg_resource.add_pkg"](ret, key, val)
171         else:
172             key = pkg_name
173             for val in val_list:
174                 __salt__["pkg_resource.add_pkg"](ret, key, val)
175     __salt__["pkg_resource.sort_pkglist"](ret)
176     if not versions_as_list:
177         __salt__["pkg_resource.stringify"](ret)
178     return ret
179 def _get_reg_software(include_components=True, include_updates=True):
180     reg_software = {}
181     def skip_component(hive, key, sub_key, use_32bit_registry):
182         if include_components:
183             return False
184         if __utils__["reg.value_exists"](
185             hive=hive,
186             key="{}\\{}".format(key, sub_key),
187             vname="SystemComponent",
188             use_32bit_registry=use_32bit_registry,
189         ):
190             if (
191                 __utils__["reg.read_value"](
192                     hive=hive,
193                     key="{}\\{}".format(key, sub_key),
194                     vname="SystemComponent",
195                     use_32bit_registry=use_32bit_registry,
196                 )["vdata"]
197                 &gt; 0
198             ):
199                 return True
200         return False
201     def skip_win_installer(hive, key, sub_key, use_32bit_registry):
202         products_key = "Software\\Classes\\Installer\\Products\\{0}"
203         if __utils__["reg.value_exists"](
204             hive=hive,
205             key="{}\\{}".format(key, sub_key),
206             vname="WindowsInstaller",
207             use_32bit_registry=use_32bit_registry,
208         ):
209             if (
210                 __utils__["reg.read_value"](
211                     hive=hive,
212                     key="{}\\{}".format(key, sub_key),
213                     vname="WindowsInstaller",
214                     use_32bit_registry=use_32bit_registry,
215                 )["vdata"]
216                 &gt; 0
217             ):
218                 squid = salt.utils.win_functions.guid_to_squid(sub_key)
219                 if not __utils__["reg.key_exists"](
220                     hive="HKLM",
221                     key=products_key.format(squid),
222                     use_32bit_registry=use_32bit_registry,
223                 ):
224                     return True
225         return False
226     def skip_uninstall_string(hive, key, sub_key, use_32bit_registry):
227         if not __utils__["reg.value_exists"](
228             hive=hive,
229             key="{}\\{}".format(key, sub_key),
230             vname="UninstallString",
231             use_32bit_registry=use_32bit_registry,
232         ):
233             return True
234         return False
235     def skip_release_type(hive, key, sub_key, use_32bit_registry):
236         if include_updates:
237             return False
238         skip_types = ["Hotfix", "Security Update", "Update Rollup"]
239         if __utils__["reg.value_exists"](
240             hive=hive,
241             key="{}\\{}".format(key, sub_key),
242             vname="ReleaseType",
243             use_32bit_registry=use_32bit_registry,
244         ):
245             if (
246                 __utils__["reg.read_value"](
247                     hive=hive,
248                     key="{}\\{}".format(key, sub_key),
249                     vname="ReleaseType",
250                     use_32bit_registry=use_32bit_registry,
251                 )["vdata"]
252                 in skip_types
253             ):
254                 return True
255         return False
256     def skip_parent_key(hive, key, sub_key, use_32bit_registry):
257         if __utils__["reg.value_exists"](
258             hive=hive,
259             key="{}\\{}".format(key, sub_key),
260             vname="ParentKeyName",
261             use_32bit_registry=use_32bit_registry,
262         ):
263             return True
264         return False
265     def add_software(hive, key, sub_key, use_32bit_registry):
266         d_name_regdata = __utils__["reg.read_value"](
267             hive=hive,
268             key="{}\\{}".format(key, sub_key),
269             vname="DisplayName",
270             use_32bit_registry=use_32bit_registry,
271         )
272         if (
273             not d_name_regdata["success"]
274             or d_name_regdata["vtype"] not in ["REG_SZ", "REG_EXPAND_SZ"]
275             or d_name_regdata["vdata"] in ["(value not set)", None, False]
276         ):
277             return
278         d_name = d_name_regdata["vdata"]
279         if not include_updates:
280             if re.match(r"^KB[0-9]{6}", d_name):
281                 return
282         d_vers_regdata = __utils__["reg.read_value"](
283             hive=hive,
284             key="{}\\{}".format(key, sub_key),
285             vname="DisplayVersion",
286             use_32bit_registry=use_32bit_registry,
287         )
288         d_vers = "Not Found"
289         if d_vers_regdata["success"] and d_vers_regdata["vtype"] in [
290             "REG_SZ",
291             "REG_EXPAND_SZ",
292             "REG_DWORD",
293         ]:
294             if isinstance(d_vers_regdata["vdata"], int):
295                 d_vers = str(d_vers_regdata["vdata"])
296             elif (
297                 d_vers_regdata["vdata"] and d_vers_regdata["vdata"] != "(value not set)"
298             ):  # Check for blank values
299                 d_vers = d_vers_regdata["vdata"]
300         reg_software.setdefault(d_name, []).append(d_vers)
301     kwargs = {
302         "hive": "HKLM",
303         "key": "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall",
304         "use_32bit_registry": False,
305     }
306     for sub_key in __utils__["reg.list_keys"](**kwargs):
307         kwargs["sub_key"] = sub_key
308         if skip_component(**kwargs):
309             continue
310         if skip_win_installer(**kwargs):
311             continue
312         if skip_uninstall_string(**kwargs):
313             continue
314         if skip_release_type(**kwargs):
315             continue
316         if skip_parent_key(**kwargs):
317             continue
318         add_software(**kwargs)
319     kwargs["use_32bit_registry"] = True
320     kwargs.pop("sub_key", False)
321     for sub_key in __utils__["reg.list_keys"](**kwargs):
322         kwargs["sub_key"] = sub_key
323         if skip_component(**kwargs):
324             continue
325         if skip_win_installer(**kwargs):
326             continue
327         if skip_uninstall_string(**kwargs):
328             continue
329         if skip_release_type(**kwargs):
330             continue
331         if skip_parent_key(**kwargs):
332             continue
333         add_software(**kwargs)
334     kwargs = {
335         "hive": "HKLM",
336         "key": "Software\\Classes\\Installer\\Products",
337         "use_32bit_registry": False,
338     }
339     userdata_key = (
340         "Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\"
341         "UserData\\S-1-5-18\\Products"
342     )
343     for sub_key in __utils__["reg.list_keys"](**kwargs):
344         if not __utils__["reg.key_exists"](
345             hive=kwargs["hive"], key="{}\\{}".format(userdata_key, sub_key)
346         ):
347             continue
348         kwargs["sub_key"] = sub_key
349         if skip_component(**kwargs):
350             continue
351         if skip_win_installer(**kwargs):
352             continue
353         add_software(**kwargs)
354     hive_hku = "HKU"
355     uninstall_key = "{0}\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
356     product_key = "{0}\\Software\\Microsoft\\Installer\\Products"
357     user_data_key = (
358         "Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\"
359         "UserData\\{0}\\Products\\{1}"
360     )
361     for user_guid in __utils__["reg.list_keys"](hive=hive_hku):
362         kwargs = {
363             "hive": hive_hku,
364             "key": uninstall_key.format(user_guid),
365             "use_32bit_registry": False,
366         }
367         if __utils__["reg.key_exists"](**kwargs):
368             for sub_key in __utils__["reg.list_keys"](**kwargs):
369                 kwargs["sub_key"] = sub_key
370                 if skip_component(**kwargs):
371                     continue
372                 if skip_win_installer(**kwargs):
373                     continue
374                 if skip_uninstall_string(**kwargs):
375                     continue
376                 if skip_release_type(**kwargs):
377                     continue
378                 if skip_parent_key(**kwargs):
379                     continue
380                 add_software(**kwargs)
381         kwargs = {
382             "hive": hive_hku,
383             "key": product_key.format(user_guid),
384             "use_32bit_registry": False,
385         }
386         if __utils__["reg.key_exists"](**kwargs):
387             for sub_key in __utils__["reg.list_keys"](**kwargs):
388                 kwargs = {
389                     "hive": "HKLM",
390                     "key": user_data_key.format(user_guid, sub_key),
391                     "use_32bit_registry": False,
392                 }
393                 if __utils__["reg.key_exists"](**kwargs):
394                     kwargs["sub_key"] = "InstallProperties"
395                     if skip_component(**kwargs):
396                         continue
397                     add_software(**kwargs)
398     for user_guid in __utils__["reg.list_keys"](hive=hive_hku, use_32bit_registry=True):
399         kwargs = {
400             "hive": hive_hku,
401             "key": uninstall_key.format(user_guid),
402             "use_32bit_registry": True,
403         }
404         if __utils__["reg.key_exists"](**kwargs):
405             for sub_key in __utils__["reg.list_keys"](**kwargs):
406                 kwargs["sub_key"] = sub_key
407                 if skip_component(**kwargs):
408                     continue
409                 if skip_win_installer(**kwargs):
410                     continue
411                 if skip_uninstall_string(**kwargs):
412                     continue
413                 if skip_release_type(**kwargs):
414                     continue
415                 if skip_parent_key(**kwargs):
416                     continue
417                 add_software(**kwargs)
418         kwargs = {
419             "hive": hive_hku,
420             "key": product_key.format(user_guid),
421             "use_32bit_registry": True,
422         }
423         if __utils__["reg.key_exists"](**kwargs):
424             for sub_key_2 in __utils__["reg.list_keys"](**kwargs):
425                 kwargs = {
426                     "hive": "HKLM",
427                     "key": user_data_key.format(user_guid, sub_key_2),
428                     "use_32bit_registry": True,
429                 }
430                 if __utils__["reg.key_exists"](**kwargs):
431                     kwargs["sub_key"] = "InstallProperties"
432                     if skip_component(**kwargs):
433                         continue
434                     add_software(**kwargs)
435     return reg_software
436 def _refresh_db_conditional(saltenv, **kwargs):
437     force = salt.utils.data.is_true(kwargs.pop("force", False))
438     failhard = salt.utils.data.is_true(kwargs.pop("failhard", False))
439     expired_max = __opts__["winrepo_cache_expire_max"]
440     expired_min = __opts__["winrepo_cache_expire_min"]
441     repo_details = _get_repo_details(saltenv)
442     if force and expired_min &gt; 0 and repo_details.winrepo_age &lt; expired_min:
443         log.info(
444             "Refresh skipped, age of winrepo metadata in seconds (%s) is less "
445             "than winrepo_cache_expire_min (%s)",
446             repo_details.winrepo_age,
447             expired_min,
448         )
449         force = False
450     refresh = (
451         True
452         if force
453         or repo_details.winrepo_age == -1
454         or repo_details.winrepo_age &gt; expired_max
455         else False
456     )
457     if not refresh:
458         log.debug(
459             "Using existing pkg metadata db for saltenv '%s' (age is %s)",
460             saltenv,
461             datetime.timedelta(seconds=repo_details.winrepo_age),
462         )
463         return True
464     if repo_details.winrepo_age == -1:
465         log.debug("No winrepo.p cache file for saltenv '%s', creating one now", saltenv)
466     results = refresh_db(saltenv=saltenv, verbose=False, failhard=failhard)
467     try:
468         return not bool(results.get("failed", 0))
469     except AttributeError:
470         return False
471 def refresh_db(**kwargs):
472     r"""
473     Generates the local software metadata database (`winrepo.p`) on the minion.
474     The database is stored in a serialized format located by default at the
475     following location:
476     ``C:\salt\var\cache\salt\minion\files\base\win\repo-ng\winrepo.p``
477     This module performs the following steps to generate the software metadata
478     database:
479     - Fetch the package definition files (.sls) from `winrepo_source_dir`
480       (default `salt://win/repo-ng`) and cache them in
481       `&lt;cachedir&gt;\files\&lt;saltenv&gt;\&lt;winrepo_source_dir&gt;`
482       (default: ``C:\salt\var\cache\salt\minion\files\base\win\repo-ng``)
483     - Call :py:func:`pkg.genrepo &lt;salt.modules.win_pkg.genrepo&gt;` to parse the
484       package definition files and generate the repository metadata database
485       file (`winrepo.p`)
486     - Return the report received from
487       :py:func:`pkg.genrepo &lt;salt.modules.win_pkg.genrepo&gt;`
488     The default winrepo directory on the master is `/srv/salt/win/repo-ng`. All
489     files that end with `.sls` in this and all subdirectories will be used to
490     generate the repository metadata database (`winrepo.p`).
491     .. note::
492         - Hidden directories (directories beginning with '`.`', such as
493           '`.git`') will be ignored.
494     .. note::
495         There is no need to call `pkg.refresh_db` every time you work with the
496         pkg module. Automatic refresh will occur based on the following minion
497         configuration settings:
498         - `winrepo_cache_expire_min`
499         - `winrepo_cache_expire_max`
500         However, if the package definition files have changed, as would be the
501         case if you are developing a new package definition, this function
502         should be called to ensure the minion has the latest information about
503         packages available to it.
504     .. warning::
505         Directories and files fetched from &lt;winrepo_source_dir&gt;
506         (`/srv/salt/win/repo-ng`) will be processed in alphabetical order. If
507         two or more software definition files contain the same name, the last
508         one processed replaces all data from the files processed before it.
509     For more information see
510     :ref:`Windows Software Repository &lt;windows-package-manager&gt;`
511     Arguments:
512     saltenv (str): Salt environment. Default: ``base``
513     verbose (bool):
514         Return a verbose data structure which includes 'success_list', a
515         list of all sls files and the package names contained within.
516         Default is 'False'
517     failhard (bool):
518         If ``True``, an error will be raised if any repo SLS files fails to
519         process. If ``False``, no error will be raised, and a dictionary
520         containing the full results will be returned.
521     Returns:
522         dict: A dictionary containing the results of the database refresh.
523     .. note::
524         A result with a `total: 0` generally means that the files are in the
525         wrong location on the master. Try running the following command on the
526         minion: `salt-call -l debug pkg.refresh saltenv=base`
527     .. warning::
528         When calling this command from a state using `module.run` be sure to
529         pass `failhard: False`. Otherwise the state will report failure if it
530         encounters a bad software definition file.
531     CLI Example:
532     .. code-block:: bash
533         salt '*' pkg.refresh_db
534         salt '*' pkg.refresh_db saltenv=base
535     Return repo details for the specified saltenv as a namedtuple
536     """
537         local_dest <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= os.sep.join(dirs)
538         winrepo_file = os.path.join(local_dest, "winrepo.p")  # Default
539         if not re.search(
540             r'[\/:*?"&lt;&gt;|]', __opts__[</b></font>"winrepo_cachefile"], flags=re.IGNORECASE
541         ):
542             winrepo_file = os.path.join(local_dest, __opts__["winrepo_cachefile"])
543         else:
544             log.error(
545                 "minion configuration option 'winrepo_cachefile' has been "
546                 "ignored as its value (%s) is invalid. Please ensure this "
547                 "option is set to a valid filename.",
548                 __opts__["winrepo_cachefile"],
549             )
550         system_root = os.environ.get("SystemRoot", r"C:\Windows")
551         if not salt.utils.path.safe_path(
552             path=local_dest, allow_path="\\".join([system_root, "TEMP"])
553         ):
554             raise CommandExecutionError(
555                 "Attempting to delete files from a possibly unsafe location: {}".format(
556                     local_dest
557                 )
558             )
559         __context__[contextkey] = (winrepo_source_dir, local_dest, winrepo_file)
560     try:
561         os.makedirs(local_dest)
562     except OSError as exc:
563         if exc.errno != errno.EEXIST:
564             raise CommandExecutionError(
565                 "Failed to create {}: {}".format(local_dest, exc)
566             )
567     winrepo_age = -1
568     try:
569         stat_result = os.stat(winrepo_file)
570         mtime = stat_result.st_mtime
571         winrepo_age = time.time() - mtime
572     except OSError as exc:
573         if exc.errno != errno.ENOENT:
574             raise CommandExecutionError(
575                 "Failed to get age of {}: {}".format(winrepo_file, exc)
576             )
577     except AttributeError:
578         log.warning("st_mtime missing from stat result %s", stat_result)
579     except TypeError:
580         log.warning("mtime of %s (%s) is an invalid type", winrepo_file, mtime)
581     repo_details = collections.namedtuple(
582         "RepoDetails",
583         ("winrepo_source_dir", "local_dest", "winrepo_file", "winrepo_age"),
584     )
585     return repo_details(winrepo_source_dir, local_dest, winrepo_file, winrepo_age)
586 def genrepo(**kwargs):
587     """
588     Generate package metadata db based on files within the winrepo_source_dir
589     Kwargs:
590         saltenv (str): Salt environment. Default: ``base``
591         verbose (bool):
592             Return verbose data structure which includes 'success_list', a list
593             of all sls files and the package names contained within.
594             Default ``False``.
595         failhard (bool):
596             If ``True``, an error will be raised if any repo SLS files failed
597             to process. If ``False``, no error will be raised, and a dictionary
598             containing the full results will be returned.
599     .. note::
600         - Hidden directories (directories beginning with '`.`', such as
601           '`.git`') will be ignored.
602     Returns:
603         dict: A dictionary of the results of the command
604     CLI Example:
605     .. code-block:: bash
606         salt-run pkg.genrepo
607         salt -G 'os:windows' pkg.genrepo verbose=true failhard=false
608         salt -G 'os:windows' pkg.genrepo saltenv=base
609     """
610     saltenv = kwargs.pop("saltenv", "base")
611     verbose = salt.utils.data.is_true(kwargs.pop("verbose", False))
612     failhard = salt.utils.data.is_true(kwargs.pop("failhard", True))
613     ret = {}
614     successful_verbose = {}
615     total_files_processed = 0
616     ret["repo"] = {}
617     ret["errors"] = {}
618     repo_details = _get_repo_details(saltenv)
619     for root, _, files in salt.utils.path.os_walk(
620         repo_details.local_dest, followlinks=False
621     ):
622         if re.search(r"[\\/]\..*", root):
623             log.debug("Skipping files in directory: %s", root)
624             continue
625         short_path = os.path.relpath(root, repo_details.local_dest)
626         if short_path == ".":
627             short_path = ""
628         for name in files:
629             if name.endswith(".sls"):
630                 total_files_processed += 1
631                 _repo_process_pkg_sls(
632                     os.path.join(root, name),
633                     os.path.join(short_path, name),
634                     ret,
635                     successful_verbose,
636                 )
637     with salt.utils.files.fopen(repo_details.winrepo_file, "wb") as repo_cache:
638         repo_cache.write(salt.payload.dumps(ret))
639     successful_count = len(successful_verbose)
640     error_count = len(ret["errors"])
641     if verbose:
642         results = {
643             "total": total_files_processed,
644             "success": successful_count,
645             "failed": error_count,
646             "success_list": successful_verbose,
647             "failed_list": ret["errors"],
648         }
649     else:
650         if error_count &gt; 0:
651             results = {
652                 "total": total_files_processed,
653                 "success": successful_count,
654                 "failed": error_count,
655                 "failed_list": ret["errors"],
656             }
657         else:
658             results = {
659                 "total": total_files_processed,
660                 "success": successful_count,
661                 "failed": error_count,
662             }
663     if error_count &gt; 0 and failhard:
664         raise CommandExecutionError(
665             "Error occurred while generating repo db", info=results
666         )
667     else:
668         return results
669 def _repo_process_pkg_sls(filename, short_path_name, ret, successful_verbose):
670     renderers = salt.loader.render(__opts__, __salt__)
671     def _failed_compile(prefix_msg, error_msg):
672         log.error("%s '%s': %s", prefix_msg, short_path_name, error_msg)
673         ret.setdefault("errors", {})[short_path_name] = [
674             "{}, {} ".format(prefix_msg, error_msg)
675         ]
676         return False
677     try:
678         config = salt.template.compile_template(
679             filename,
680             renderers,
681             __opts__["renderer"],
682             __opts__.get("renderer_blacklist", ""),
683             __opts__.get("renderer_whitelist", ""),
684         )
685     except SaltRenderError as exc:
686         return _failed_compile("Failed to compile", exc)
687     except Exception as exc:  # pylint: disable=broad-except
688         return _failed_compile("Failed to read", exc)
689     if config and isinstance(config, dict):
690         revmap = {}
691         errors = []
692         for pkgname, version_list in config.items():
693             if pkgname in ret["repo"]:
694                 log.error(
695                     "package '%s' within '%s' already defined, skipping",
696                     pkgname,
697                     short_path_name,
698                 )
699                 errors.append("package '{}' already defined".format(pkgname))
700                 break
701             for version_str, repodata in version_list.items():
702                 if not isinstance(version_str, str):
703                     log.error(
704                         "package '%s' within '%s', version number %s' is not a string",
705                         pkgname,
706                         short_path_name,
707                         version_str,
708                     )
709                     errors.append(
710                         "package '{}', version number {} is not a string".format(
711                             pkgname, version_str
712                         )
713                     )
714                     continue
715                 if not isinstance(repodata, dict):
716                     log.error(
717                         "package '%s' within '%s', repo data for "
718                         "version number %s is not defined as a dictionary",
719                         pkgname,
720                         short_path_name,
721                         version_str,
722                     )
723                     errors.append(
724                         "package '{}', repo data for "
725                         "version number {} is not defined as a dictionary".format(
726                             pkgname, version_str
727                         )
728                     )
729                     continue
730                 revmap[repodata["full_name"]] = pkgname
731         if errors:
732             ret.setdefault("errors", {})[short_path_name] = errors
733         else:
734             ret.setdefault("repo", {}).update(config)
735             ret.setdefault("name_map", {}).update(revmap)
736             successful_verbose[short_path_name] = list(config.keys())
737     elif config:
738         return _failed_compile("Compiled contents", "not a dictionary/hash")
739     else:
740         log.debug("No data within '%s' after processing", short_path_name)
741         successful_verbose[short_path_name] = []
742 def _get_source_sum(source_hash, file_path, saltenv):
743     """
744     Extract the hash sum, whether it is in a remote hash file, or just a string.
745     """
746     ret = dict()
747     schemes = ("salt", "http", "https", "ftp", "swift", "s3", "file")
748     invalid_hash_msg = (
749         "Source hash '{}' format is invalid. It must be in "
750         "the format &lt;hash type&gt;=&lt;hash&gt;".format(source_hash)
751     )
752     source_hash = str(source_hash)
753     source_hash_scheme = urllib.parse.urlparse(source_hash).scheme
754     if source_hash_scheme in schemes:
755         try:
756             cached_hash_file = __salt__["cp.cache_file"](source_hash, saltenv)
757         except MinionError as exc:
758             log.exception("Failed to cache %s", source_hash, exc_info=exc)
759             raise
760         if not cached_hash_file:
761             raise CommandExecutionError(
762                 "Source hash file {} not found".format(source_hash)
763             )
764         ret = __salt__["file.extract_hash"](cached_hash_file, "", file_path)
765         if ret is None:
766             raise SaltInvocationError(invalid_hash_msg)
767     else:
768         items = source_hash.split("=", 1)
769         if len(items) != 2:
770             invalid_hash_msg = "{}, or it must be a supported protocol: {}".format(
771                 invalid_hash_msg, ", ".join(schemes)
772             )
773             raise SaltInvocationError(invalid_hash_msg)
774         ret["hash_type"], ret["hsum"] = (item.strip().lower() for item in items)
775     return ret
776 def _get_msiexec(use_msiexec):
777     """
778     Return if msiexec.exe will be used and the command to invoke it.
779     """
780     if use_msiexec is False:
781         return False, ""
782     if isinstance(use_msiexec, str):
783         if os.path.isfile(use_msiexec):
784             return True, use_msiexec
785         else:
786             log.warning(
787                 "msiexec path '%s' not found. Using system registered msiexec instead",
788                 use_msiexec,
789             )
790             use_msiexec = True
791     if use_msiexec is True:
792         return True, "msiexec"
793 def install(name=None, refresh=False, pkgs=None, **kwargs):
794     r"""
795     Install the passed package(s) on the system using winrepo
796     Args:
797         name (str):
798             The name of a single package, or a comma-separated list of packages
799             to install. (no spaces after the commas)
800         refresh (bool):
801             Boolean value representing whether or not to refresh the winrepo db.
802             Default ``False``.
803         pkgs (list):
804             A list of packages to install from a software repository. All
805             packages listed under ``pkgs`` will be installed via a single
806             command.
807             You can specify a version by passing the item as a dict:
808             CLI Example:
809             .. code-block:: bash
810                 salt '*' pkg.install pkgs='["foo", "bar"]'
811                 salt '*' pkg.install pkgs='["foo", {"bar": "1.2.3"}]'
812     Kwargs:
813         version (str):
814             The specific version to install. If omitted, the latest version will
815             be installed. Recommend for use when installing a single package.
816             If passed with a list of packages in the ``pkgs`` parameter, the
817             version will be ignored.
818             CLI Example:
819              .. code-block:: bash
820                 salt '*' pkg.install pkgs="['foo', 'bar']" version=1.2.3
821             If passed with a comma separated list in the ``name`` parameter, the
822             version will apply to all packages in the list.
823             CLI Example:
824              .. code-block:: bash
825                 salt '*' pkg.install foo,bar version=1.2.3
826         extra_install_flags (str):
827             Additional install flags that will be appended to the
828             ``install_flags`` defined in the software definition file. Only
829             applies when single package is passed.
830         saltenv (str):
831             Salt environment. Default 'base'
832         report_reboot_exit_codes (bool):
833             If the installer exits with a recognized exit code indicating that
834             a reboot is required, the module function
835                *win_system.set_reboot_required_witnessed*
836             will be called, preserving the knowledge of this event for the
837             remainder of the current boot session. For the time being, 3010 is
838             the only recognized exit code. The value of this param defaults to
839             True.
840             .. versionadded:: 2016.11.0
841     Returns:
842         dict: Return a dict containing the new package names and versions. If
843         the package is already installed, an empty dict is returned.
844         If the package is installed by ``pkg.install``:
845         .. code-block:: cfg
846             {'&lt;package&gt;': {'old': '&lt;old-version&gt;',
847                            'new': '&lt;new-version&gt;'}}
848     The following example will refresh the winrepo and install a single
849     package, 7zip.
850     CLI Example:
851     .. code-block:: bash
852         salt '*' pkg.install 7zip refresh=True
853     CLI Example:
854     .. code-block:: bash
855         salt '*' pkg.install 7zip
856         salt '*' pkg.install 7zip,filezilla
857         salt '*' pkg.install pkgs='["7zip","filezilla"]'
858     WinRepo Definition File Examples:
859     The following example demonstrates the use of ``cache_file``. This would be
860     used if you have multiple installers in the same directory that use the
861     same ``install.ini`` file and you don't want to download the additional
862     installers.
863     .. code-block:: bash
864         ntp:
865           4.2.8:
866             installer: 'salt://win/repo/ntp/ntp-4.2.8-win32-setup.exe'
867             full_name: Meinberg NTP Windows Client
868             locale: en_US
869             reboot: False
870             cache_file: 'salt://win/repo/ntp/install.ini'
871             install_flags: '/USEFILE=C:\salt\var\cache\salt\minion\files\base\win\repo\ntp\install.ini'
872             uninstaller: 'NTP/uninst.exe'
873     The following example demonstrates the use of ``cache_dir``. It assumes a
874     file named ``install.ini`` resides in the same directory as the installer.
875     .. code-block:: bash
876         ntp:
877           4.2.8:
878             installer: 'salt://win/repo/ntp/ntp-4.2.8-win32-setup.exe'
879             full_name: Meinberg NTP Windows Client
880             locale: en_US
881             reboot: False
882             cache_dir: True
883             install_flags: '/USEFILE=C:\salt\var\cache\salt\minion\files\base\win\repo\ntp\install.ini'
884             uninstaller: 'NTP/uninst.exe'
885     """
886     ret = {}
887     saltenv = kwargs.pop("saltenv", "base")
888     refresh = salt.utils.data.is_true(refresh)
889     if not name and not pkgs:
890         return "Must pass a single package or a list of packages"
891     pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs, **kwargs)[0]
892     if len(pkg_params) &gt; 1:
893         if kwargs.get("extra_install_flags") is not None:
894             log.warning(
895                 "'extra_install_flags' argument will be ignored for "
896                 "multiple package targets"
897             )
898     for pkg in pkg_params:
899         pkg_params[pkg] = {"version": pkg_params[pkg]}
900     if not pkg_params:
901         log.error("No package definition found")
902         return {}
903     if not pkgs and len(pkg_params) == 1:
904         pkg_params = {
905             name: {
906                 "version": kwargs.get("version"),
907                 "extra_install_flags": kwargs.get("extra_install_flags"),
908             }
909         }
910     elif len(pkg_params) == 1:
911         pkg = next(iter(pkg_params))
912         pkg_params[pkg]["extra_install_flags"] = kwargs.get("extra_install_flags")
913     old = list_pkgs(saltenv=saltenv, refresh=refresh, versions_as_list=True)
914     changed = []
915     for pkg_name, options in pkg_params.items():
916         pkginfo = _get_package_info(pkg_name, saltenv=saltenv)
917         if not pkginfo:
918             log.error("Unable to locate package %s", pkg_name)
919             ret[pkg_name] = "Unable to locate package {}".format(pkg_name)
920             continue
921         version_num = options.get("version")
922         if not isinstance(version_num, str) and version_num is not None:
923             version_num = str(version_num)
924         if not version_num:
925             if pkg_name in old:
926                 log.debug(
927                     "pkg.install: '%s' version '%s' is already installed",
928                     pkg_name,
929                     old[pkg_name][0],
930                 )
931                 continue
932             version_num = _get_latest_pkg_version(pkginfo)
933         if version_num == "latest" and "latest" not in pkginfo:
934             version_num = _get_latest_pkg_version(pkginfo)
935         if version_num in old.get(pkg_name, []):
936             log.debug(
937                 "pkg.install: '%s' version '%s' is already installed",
938                 pkg_name,
939                 version_num,
940             )
941             continue
942         elif version_num != "latest" and version_num not in pkginfo:
943             log.error("Version %s not found for package %s", version_num, pkg_name)
944             ret[pkg_name] = {"not found": version_num}
945         installer <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= pkginfo[version_num].get("installer", "")
946         cache_dir = pkginfo[version_num].get("cache_dir", False)
947         cache_file = pkginfo[version_num].get("cache_file", "")
948         if not installer:
949             log.error(</b></font>
950                 "No installer configured for version %s of package %s",
951                 version_num,
952                 pkg_name,
953             )
954             ret[pkg_name] = {"no installer": version_num}
955             continue
956         if __salt__["config.valid_fileproto"](installer):
957             if cache_dir and installer.startswith("salt:"):
958                 path, _ = os.path.split(installer)
959                 try:
960                     __salt__["cp.cache_dir"](
961                         path=path,
962                         saltenv=saltenv,
963                         include_empty=False,
964                         include_pat=None,
965                         exclude_pat="E@init.sls$",
966                     )
967                 except MinionError as exc:
968                     msg = "Failed to cache {}".format(path)
969                     log.exception(msg, exc_info=exc)
970                     return "{}\n{}".format(msg, exc)
971             if cache_file and cache_file.startswith("salt:"):
972                 cached_file = __salt__["cp.is_cached"](cache_file, saltenv)
973                 if not cached_file:
974                     try:
975                         cached_file = __salt__["cp.cache_file"](cache_file, saltenv)
976                     except MinionError as exc:
977                         msg = "Failed to cache {}".format(cache_file)
978                         log.exception(msg, exc_info=exc)
979                         return "{}\n{}".format(msg, exc)
980                 if __salt__["cp.hash_file"](cache_file, saltenv) != __salt__[
981                     "cp.hash_file"
982                 ](cached_file):
983                     try:
984                         cached_file = __salt__["cp.cache_file"](cache_file, saltenv)
985                     except MinionError as exc:
986                         msg = "Failed to cache {}".format(cache_file)
987                         log.exception(msg, exc_info=exc)
988                         return "{}\n{}".format(msg, exc)
989                     if not cached_file:
990                         log.error("Unable to cache %s", cache_file)
991                         ret[pkg_name] = {"failed to cache cache_file": cache_file}
992                         continue
993             cached_pkg = __salt__["cp.is_cached"](installer, saltenv)
994             if not cached_pkg:
995                 try:
996                     cached_pkg = __salt__["cp.cache_file"](installer, saltenv)
997                 except MinionError as exc:
998                     msg = "Failed to cache {}".format(installer)
999                     log.exception(msg, exc_info=exc)
1000                     return "{}\n{}".format(msg, exc)
1001                 if not cached_pkg:
1002                     log.error(
1003                         "Unable to cache file %s from saltenv: %s", installer, saltenv
1004                     )
1005                     ret[pkg_name] = {"unable to cache": installer}
1006                     continue
1007             if installer.startswith("salt:"):
1008                 if __salt__["cp.hash_file"](installer, saltenv) != __salt__[
1009                     "cp.hash_file"
1010                 ](cached_pkg):
1011                     try:
1012                         cached_pkg = __salt__["cp.cache_file"](installer, saltenv)
1013                     except MinionError as exc:
1014                         msg = "Failed to cache {}".format(installer)
1015                         log.exception(msg, exc_info=exc)
1016                         return "{}\n{}".format(msg, exc)
1017                     if not cached_pkg:
1018                         log.error("Unable to cache %s", installer)
1019                         ret[pkg_name] = {"unable to cache": installer}
1020                         continue
1021         else:
1022             cached_pkg = installer
1023         cached_pkg = cached_pkg.replace("/", "\\")
1024         cache_path = os.path.dirname(cached_pkg)
1025         source_hash = pkginfo[version_num].get("source_hash", False)
1026         if source_hash:
1027             source_sum = _get_source_sum(source_hash, cached_pkg, saltenv)
1028             log.debug(
1029                 "pkg.install: Source %s hash: %s",
1030                 source_sum["hash_type"],
1031                 source_sum["hsum"],
1032             )
1033             cached_pkg_sum = salt.utils.hashutils.get_hash(
1034                 cached_pkg, source_sum["hash_type"]
1035             )
1036             log.debug(
1037                 "pkg.install: Package %s hash: %s",
1038                 source_sum["hash_type"],
1039                 cached_pkg_sum,
1040             )
1041             if source_sum["hsum"] != cached_pkg_sum:
1042                 raise SaltInvocationError(
1043                     "Source hash '{}' does not match package hash '{}'".format(
1044                         source_sum["hsum"], cached_pkg_sum
1045                     )
1046                 )
1047             log.debug("pkg.install: Source hash matches package hash.")
1048         install_flags = pkginfo[version_num].get("install_flags", "")
1049         if options and options.get("extra_install_flags"):
1050             install_flags = "{} {}".format(
1051                 install_flags, options.get("extra_install_flags", "")
1052             )
1053         use_msiexec, msiexec = _get_msiexec(pkginfo[version_num].get("msiexec", False))
1054         cmd_shell = os.getenv(
1055             "ComSpec", "{}\\system32\\cmd.exe".format(os.getenv("WINDIR"))
1056         )
1057         if use_msiexec:
1058             arguments = '"{}" /I "{}"'.format(msiexec, cached_pkg)
1059             if pkginfo[version_num].get("allusers", True):
1060                 arguments = "{} ALLUSERS=1".format(arguments)
1061         else:
1062             arguments = '"{}"'.format(cached_pkg)
1063         if install_flags:
1064             arguments = "{} {}".format(arguments, install_flags)
1065         if pkginfo[version_num].get("use_scheduler", False):
1066             __salt__["task.create_task"](
1067                 name="update-salt-software",
1068                 user_name="System",
1069                 force=True,
1070                 action_type="Execute",
1071                 cmd=cmd_shell,
1072                 arguments='/s /c "{}"'.format(arguments),
1073                 start_in=cache_path,
1074                 trigger_type="Once",
1075                 start_date="1975-01-01",
1076                 start_time="01:00",
1077                 ac_only=False,
1078                 stop_if_on_batteries=False,
1079             )
1080             if (
1081                 re.search(
1082                     r"salt[\s_.-]*minion", pkg_name, flags=re.IGNORECASE + re.UNICODE
1083                 )
1084                 is not None
1085             ):
1086                 ret[pkg_name] = {"install status": "task started"}
1087                 if not __salt__["task.run"](name="update-salt-software"):
1088                     log.error(
1089                         "Scheduled Task failed to run. Failed to install %s", pkg_name
1090                     )
1091                     ret[pkg_name] = {"install status": "failed"}
1092                 else:
1093                     t_end = time.time() + 5
1094                     while time.time() &lt; t_end:
1095                         time.sleep(0.25)
1096                         task_running = (
1097                             __salt__["task.status"]("update-salt-software") == "Running"
1098                         )
1099                         if task_running:
1100                             break
1101                     if not task_running:
1102                         log.error(
1103                             "Scheduled Task failed to run. Failed to install %s",
1104                             pkg_name,
1105                         )
1106                         ret[pkg_name] = {"install status": "failed"}
1107             else:
1108                 if not __salt__["task.run_wait"](name="update-salt-software"):
1109                     log.error(
1110                         "Scheduled Task failed to run. Failed to install %s", pkg_name
1111                     )
1112                     ret[pkg_name] = {"install status": "failed"}
1113         else:
1114             result = __salt__["cmd.run_all"](
1115                 '"{}" /s /c "{}"'.format(cmd_shell, arguments),
1116                 cache_path,
1117                 output_loglevel="trace",
1118                 python_shell=False,
1119                 redirect_stderr=True,
1120             )
1121             if not result["retcode"]:
1122                 ret[pkg_name] = {"install status": "success"}
1123                 changed.append(pkg_name)
1124             elif result["retcode"] == 3010:
1125                 report_reboot_exit_codes = kwargs.pop("report_reboot_exit_codes", True)
1126                 if report_reboot_exit_codes:
1127                     __salt__["system.set_reboot_required_witnessed"]()
1128                 ret[pkg_name] = {"install status": "success, reboot required"}
1129                 changed.append(pkg_name)
1130             elif result["retcode"] == 1641:
1131                 ret[pkg_name] = {"install status": "success, reboot initiated"}
1132                 changed.append(pkg_name)
1133             else:
1134                 log.error(
1135                     "Failed to install %s; retcode: %s; installer output: %s",
1136                     pkg_name,
1137                     result["retcode"],
1138                     result["stdout"],
1139                 )
1140                 ret[pkg_name] = {"install status": "failed"}
1141     new = list_pkgs(saltenv=saltenv, refresh=False)
1142     __salt__["pkg_resource.stringify"](old)
1143     difference = salt.utils.data.compare_dicts(old, new)
1144     ret.update(difference)
1145     return ret
1146 def upgrade(**kwargs):
1147     """
1148     Upgrade all software. Currently not implemented
1149     Kwargs:
1150         saltenv (str): The salt environment to use. Default ``base``.
1151         refresh (bool): Refresh package metadata. Default ``True``.
1152     .. note::
1153         This feature is not yet implemented for Windows.
1154     Returns:
1155         dict: Empty dict, until implemented
1156     CLI Example:
1157     .. code-block:: bash
1158         salt '*' pkg.upgrade
1159     """
1160     log.warning("pkg.upgrade not implemented on Windows yet")
1161     refresh = salt.utils.data.is_true(kwargs.get("refresh", True))
1162     saltenv = kwargs.get("saltenv", "base")
1163     log.warning(
1164         "pkg.upgrade not implemented on Windows yet refresh:%s saltenv:%s",
1165         refresh,
1166         saltenv,
1167     )
1168     return {}
1169 def remove(name=None, pkgs=None, **kwargs):
1170     """
1171     Remove the passed package(s) from the system using winrepo
1172     .. versionadded:: 0.16.0
1173     Args:
1174         name (str):
1175             The name(s) of the package(s) to be uninstalled. Can be a
1176             single package or a comma delimited list of packages, no spaces.
1177         pkgs (list):
1178             A list of packages to delete. Must be passed as a python list. The
1179             ``name`` parameter will be ignored if this option is passed.
1180     Kwargs:
1181         version (str):
1182             The version of the package to be uninstalled. If this option is
1183             used to to uninstall multiple packages, then this version will be
1184             applied to all targeted packages. Recommended using only when
1185             uninstalling a single package. If this parameter is omitted, the
1186             latest version will be uninstalled.
1187         saltenv (str): Salt environment. Default ``base``
1188         refresh (bool): Refresh package metadata. Default ``False``
1189     Returns:
1190         dict: Returns a dict containing the changes.
1191         If the package is removed by ``pkg.remove``:
1192             {'&lt;package&gt;': {'old': '&lt;old-version&gt;',
1193                            'new': '&lt;new-version&gt;'}}
1194         If the package is already uninstalled:
1195             {'&lt;package&gt;': {'current': 'not installed'}}
1196     CLI Example:
1197     .. code-block:: bash
1198         salt '*' pkg.remove &lt;package name&gt;
1199         salt '*' pkg.remove &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt;
1200         salt '*' pkg.remove pkgs='["foo", "bar"]'
1201     """
1202     saltenv = kwargs.get("saltenv", "base")
1203     refresh = salt.utils.data.is_true(kwargs.get("refresh", False))
1204     ret = {}
1205     if not name and not pkgs:
1206         return "Must pass a single package or a list of packages"
1207     pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs, **kwargs)[0]
1208     old = list_pkgs(saltenv=saltenv, refresh=refresh, versions_as_list=True)
1209     changed = []  # list of changed package names
1210     for pkgname, version_num in pkg_params.items():
1211         pkginfo = _get_package_info(pkgname, saltenv=saltenv)
1212         if not pkginfo:
1213             msg = "Unable to locate package {}".format(pkgname)
1214             log.error(msg)
1215             ret[pkgname] = msg
1216             continue
1217         if pkgname not in old:
1218             log.debug(
1219                 "%s %s not installed", pkgname, version_num if version_num else ""
1220             )
1221             ret[pkgname] = {"current": "not installed"}
1222             continue
1223         removal_targets = []
1224         if version_num is not None:
1225             version_num = str(version_num)
1226         if version_num is None:
1227             for ver_install in old[pkgname]:
1228                 if ver_install not in pkginfo and "latest" in pkginfo:
1229                     log.debug(
1230                         "%s %s using package latest entry to to remove",
1231                         pkgname,
1232                         version_num,
1233                     )
1234                     removal_targets.append("latest")
1235                 else:
1236                     removal_targets.append(ver_install)
1237         else:
1238             if version_num in pkginfo:
1239                 if version_num in old[pkgname]:
1240                     removal_targets.append(version_num)
1241                 else:
1242                     log.debug("%s %s not installed", pkgname, version_num)
1243                     ret[pkgname] = {"current": "{} not installed".format(version_num)}
1244                     continue
1245             elif "latest" in pkginfo:
1246                 log.debug(
1247                     "%s %s using package latest entry to to remove",
1248                     pkgname,
1249                     version_num,
1250                 )
1251                 removal_targets.append("latest")
1252         if not removal_targets:
1253             log.error(
1254                 "%s %s no definition to remove this version", pkgname, version_num
1255             )
1256             ret[pkgname] = {
1257                 "current": "{} no definition, cannot removed".format(version_num)
1258             }
1259             continue
1260         for target in removal_targets:
1261             uninstaller <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= pkginfo[target].get("uninstaller", "")
1262             cache_dir = pkginfo[target].get("cache_dir", False)
1263             uninstall_flags = pkginfo[target].get(</b></font>"uninstall_flags", "")
1264             if not uninstaller and uninstall_flags:
1265                 uninstaller = pkginfo[target].get("installer", "")
1266             if not uninstaller:
1267                 log.error(
1268                     "No installer or uninstaller configured for package %s",
1269                     pkgname,
1270                 )
1271                 ret[pkgname] = {"no uninstaller defined": target}
1272                 continue
1273             if uninstaller.startswith(("salt:", "http:", "https:", "ftp:")):
1274                 if cache_dir and uninstaller.startswith("salt:"):
1275                     path, _ = os.path.split(uninstaller)
1276                     try:
1277                         __salt__["cp.cache_dir"](
1278                             path, saltenv, False, None, "E@init.sls$"
1279                         )
1280                     except MinionError as exc:
1281                         msg = "Failed to cache {}".format(path)
1282                         log.exception(msg, exc_info=exc)
1283                         return "{}\n{}".format(msg, exc)
1284                 cached_pkg = __salt__["cp.is_cached"](uninstaller, saltenv)
1285                 if not cached_pkg:
1286                     try:
1287                         cached_pkg = __salt__["cp.cache_file"](uninstaller, saltenv)
1288                     except MinionError as exc:
1289                         msg = "Failed to cache {}".format(uninstaller)
1290                         log.exception(msg, exc_info=exc)
1291                         return "{}\n{}".format(msg, exc)
1292                     if not cached_pkg:
1293                         log.error("Unable to cache %s", uninstaller)
1294                         ret[pkgname] = {"unable to cache": uninstaller}
1295                         continue
1296                 if uninstaller.startswith("salt:"):
1297                     if __salt__["cp.hash_file"](uninstaller, saltenv) != __salt__[
1298                         "cp.hash_file"
1299                     ](cached_pkg):
1300                         try:
1301                             cached_pkg = __salt__["cp.cache_file"](uninstaller, saltenv)
1302                         except MinionError as exc:
1303                             msg = "Failed to cache {}".format(uninstaller)
1304                             log.exception(msg, exc_info=exc)
1305                             return "{}\n{}".format(msg, exc)
1306                         if not cached_pkg:
1307                             log.error("Unable to cache %s", uninstaller)
1308                             ret[pkgname] = {"unable to cache": uninstaller}
1309                             continue
1310             else:
1311                 cached_pkg = os.path.expandvars(uninstaller)
1312             cached_pkg = cached_pkg.replace("/", "\\")
1313             cache_path, _ = os.path.split(cached_pkg)
1314             if kwargs.get("extra_uninstall_flags"):
1315                 uninstall_flags = "{} {}".format(
1316                     uninstall_flags, kwargs.get("extra_uninstall_flags", "")
1317                 )
1318             use_msiexec, msiexec = _get_msiexec(pkginfo[target].get("msiexec", False))
1319             cmd_shell = os.getenv(
1320                 "ComSpec", "{}\\system32\\cmd.exe".format(os.getenv("WINDIR"))
1321             )
1322             if use_msiexec:
1323                 arguments = '"{}" /X "{}"'.format(msiexec, cached_pkg)
1324             else:
1325                 arguments = '"{}"'.format(cached_pkg)
1326             if uninstall_flags:
1327                 arguments = "{} {}".format(arguments, uninstall_flags)
1328             changed.append(pkgname)
1329             if pkginfo[target].get("use_scheduler", False):
1330                 __salt__["task.create_task"](
1331                     name="update-salt-software",
1332                     user_name="System",
1333                     force=True,
1334                     action_type="Execute",
1335                     cmd=cmd_shell,
1336                     arguments='/s /c "{}"'.format(arguments),
1337                     trigger_type="Once",
1338                     start_date="1975-01-01",
1339                     start_time<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>="01:00",
1340                     ac_only=False,
1341                     stop_if_on_batteries=False,
1342                 )
1343                 if not __salt__["task.run_wait"](name="update-salt-software"):
1344                     log.error(
1345                         "Scheduled Task failed to run. Failed to remove %s", pkgname
1346                     )
1347                     ret[pkgname] = {"uninstall status"</b></font>: "failed"}
1348             else:
1349                 result = __salt__["cmd.run_all"](
1350                     '"{}" /s /c "{}"'.format(cmd_shell, arguments),
1351                     output_loglevel="trace",
1352                     python_shell=False,
1353                     redirect_stderr=True,
1354                 )
1355                 if not result["retcode"]:
1356                     ret[pkgname] = {"uninstall status": "success"}
1357                     changed.append(pkgname)
1358                 elif result["retcode"] == 3010:
1359                     report_reboot_exit_codes = kwargs.pop(
1360                         "report_reboot_exit_codes", True
1361                     )
1362                     if report_reboot_exit_codes:
1363                         __salt__["system.set_reboot_required_witnessed"]()
1364                     ret[pkgname] = {"uninstall status": "success, reboot required"}
1365                     changed.append(pkgname)
1366                 elif result["retcode"] == 1641:
1367                     ret[pkgname] = {"uninstall status": "success, reboot initiated"}
1368                     changed.append(pkgname)
1369                 else:
1370                     log.error(
1371                         "Failed to remove %s; retcode: %s; uninstaller output: %s",
1372                         pkgname,
1373                         result["retcode"],
1374                         result["stdout"],
1375                     )
1376                     ret[pkgname] = {"uninstall status": "failed"}
1377     new = list_pkgs(saltenv=saltenv, refresh=False)
1378     __salt__["pkg_resource.stringify"](old)
1379     difference = salt.utils.data.compare_dicts(old, new)
1380     found_chgs = all(name in difference for name in changed)
1381     end_t = time.time() + 3  # give it 3 seconds to catch up.
1382     while not found_chgs and time.time() &lt; end_t:
1383         time.sleep(0.5)
1384         new = list_pkgs(saltenv=saltenv, refresh=False)
1385         difference = salt.utils.data.compare_dicts(old, new)
1386         found_chgs = all(name in difference for name in changed)
1387     if not found_chgs:
1388         log.warning("Expected changes for package removal may not have occurred")
1389     ret.update(difference)
1390     return ret
1391 def purge(name=None, pkgs=None, **kwargs):
1392     """
1393     Package purges are not supported on Windows, this function is identical to
1394     ``remove()``.
1395     .. note::
1396         At some point in the future, ``pkg.purge`` may direct the installer to
1397         remove all configs and settings for software packages that support that
1398         option.
1399     .. versionadded:: 0.16.0
1400     Args:
1401         name (str): The name of the package to be deleted.
1402         version (str):
1403             The version of the package to be deleted. If this option is
1404             used in combination with the ``pkgs`` option below, then this
1405             version will be applied to all targeted packages.
1406         pkgs (list):
1407             A list of packages to delete. Must be passed as a python
1408             list. The ``name`` parameter will be ignored if this option is
1409             passed.
1410     Kwargs:
1411         saltenv (str): Salt environment. Default ``base``
1412         refresh (bool): Refresh package metadata. Default ``False``
1413     Returns:
1414         dict: A dict containing the changes.
1415     CLI Example:
1416     .. code-block:: bash
1417         salt '*' pkg.purge &lt;package name&gt;
1418         salt '*' pkg.purge &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt;
1419         salt '*' pkg.purge pkgs='["foo", "bar"]'
1420     """
1421     return remove(name=name, pkgs=pkgs, **kwargs)
1422 def get_repo_data(saltenv="base"):
1423     """
1424     Returns the existing package metadata db. Will create it, if it does not
1425     exist, however will not refresh it.
1426     Args:
1427         saltenv (str): Salt environment. Default ``base``
1428     Returns:
1429         dict: A dict containing contents of metadata db.
1430     CLI Example:
1431     .. code-block:: bash
1432         salt '*' pkg.get_repo_data
1433     """
1434     repo_details = _get_repo_details(saltenv)
1435     if repo_details.winrepo_age == -1:
1436         log.debug("No winrepo.p cache file. Refresh pkg db now.")
1437         refresh_db(saltenv=saltenv)
1438     if "winrepo.data" in __context__:
1439         log.trace("get_repo_data returning results from __context__")
1440         return __context__["winrepo.data"]
1441     else:
1442         log.trace("get_repo_data called reading from disk")
1443     try:
1444         with salt.utils.files.fopen(repo_details.winrepo_file, "rb") as repofile:
1445             try:
1446                 repodata = salt.utils.data.decode(
1447                     salt.payload.loads(repofile.read()) or {}
1448                 )
1449                 __context__["winrepo.data"] = repodata
1450                 return repodata
1451             except Exception as exc:  # pylint: disable=broad-except
1452                 log.exception(exc)
1453                 return {}
1454     except OSError as exc:
1455         log.exception("Not able to read repo file: %s", exc)
1456         return {}
1457 def _get_name_map(saltenv="base"):
1458     """
1459     Return a reverse map of full pkg names to the names recognized by winrepo.
1460     """
1461     u_name_map = {}
1462     name_map = get_repo_data(saltenv).get("name_map", {})
1463     return name_map
1464 def get_package_info(name, saltenv="base"):
1465     """
1466     Return package info. Returns empty map if package not available.
1467     """
1468     return _get_package_info(name=name, saltenv=saltenv)
1469 def _get_package_info(name, saltenv="base"):
1470     """
1471     Return package info. Returns empty map if package not available
1472     TODO: Add option for version
1473     """
1474     return get_repo_data(saltenv).get("repo", {}).get(name, {})
1475 def _reverse_cmp_pkg_versions(pkg1, pkg2):
1476     """
1477     Compare software package versions
1478     """
1479     return 1 if LooseVersion(pkg1) &gt; LooseVersion(pkg2) else -1
1480 def _get_latest_pkg_version(pkginfo):
1481     """
1482     Returns the latest version of the package.
1483     Will return 'latest' or version number string, and
1484     'Not Found' if 'Not Found' is the only entry.
1485     """
1486     if len(pkginfo) == 1:
1487         return next(iter(pkginfo.keys()))
1488     try:
1489         return sorted(pkginfo, key=cmp_to_key(_reverse_cmp_pkg_versions)).pop()
1490     except IndexError:
1491         return ""
1492 def compare_versions(ver1="", oper="==", ver2=""):
1493     """
1494     Compare software package versions. Made public for use with Jinja
1495     Args:
1496         ver1 (str): A software version to compare
1497         oper (str): The operand to use to compare
1498         ver2 (str): A software version to compare
1499     Returns:
1500         bool: True if the comparison is valid, otherwise False
1501     CLI Example:
1502     .. code-block:: bash
1503         salt '*' pkg.compare_versions 1.2 &gt;= 1.3
1504     """
1505     if not ver1:
1506         raise SaltInvocationError("compare_version, ver1 is blank")
1507     if not ver2:
1508         raise SaltInvocationError("compare_version, ver2 is blank")
1509     if ver1 == "latest":
1510         ver1 = str(sys.maxsize)
1511     if ver2 == "latest":
1512         ver2 = str(sys.maxsize)
1513     if ver1 == "Not Found":
1514         ver1 = "0.0.0.0.0"
1515     if ver2 == "Not Found":
1516         ver2 = "0.0.0.0.0"
1517     return salt.utils.versions.compare(ver1, oper, ver2, ignore_epoch=True)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>win_lgpo_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Manage Local Policy on Windows
3 This module allows configuring local group policy (i.e. ``gpedit.msc``) on a
4 Windows server.
5 .. versionadded:: 2016.11.0
6 Administrative Templates
7 ========================
8 Administrative template policies are dynamically read from ADMX/ADML files on
9 the server.
10 Windows Settings
11 ================
12 Policies contained in the "Windows Settings" section of the ``gpedit.msc`` GUI
13 are statically defined in this module. Each policy is configured for the section
14 (Machine/User) in the module's _policy_info class. The ``_policy_info`` class
15 contains a "policies" dict on how the module will configure the policy, where
16 the policy resides in the GUI (for display purposes), data validation data, data
17 transformation data, etc.
18 Current known limitations
19 =========================
20 - At this time, start/shutdown scripts policies are displayed, but are not
21   configurable.
22 - Not all "Security Settings" policies exist in the _policy_info class
23 :depends:
24   - pywin32 Python module
25   - lxml
26   - uuid
27   - salt.utils.win_reg
28 """
29 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import csv
30 import ctypes
31 import glob
32 import io
33 import locale
34 import logging
35 import os
36 import re
37 import tempfile
38 import time
39 import uuid
40 import zlib
41 import salt.utils.dictupdate as dictupdate
42 import salt.utils.files
43 import salt.utils.path
44 import salt.utils.platform
45 import salt.utils.stringutils
46 import salt.utils.win_lgpo_netsh
47 from salt.exceptions import CommandExecutionError, SaltInvocationError
48 from salt.serializers.configparser import deserialize
49 log = logging.getLogger(__name__)
50 __virtualname__ =</b></font> "lgpo"
51 __func_alias__ = {"set_": "set"}
52 UUID = uuid.uuid4().hex
53 adm_policy_name_map = {True: {}, False: {}}
54 HAS_WINDOWS_MODULES = False
55 TRUE_VALUE_XPATH = None
56 FALSE_VALUE_XPATH = None
57 ELEMENTS_XPATH = None
58 ENABLED_VALUE_XPATH = None
59 DISABLED_VALUE_XPATH = None
60 ENABLED_LIST_XPATH = None
61 DISABLED_LIST_XPATH = None
62 VALUE_XPATH = None
63 TRUE_LIST_XPATH = None
64 FALSE_LIST_XPATH = None
65 REGKEY_XPATH = None
66 POLICY_ANCESTOR_XPATH = None
67 ALL_CLASS_POLICY_XPATH = None
68 ADML_DISPLAY_NAME_XPATH = None
69 VALUE_LIST_XPATH = None
70 ENUM_ITEM_DISPLAY_NAME_XPATH = None
71 ADMX_SEARCH_XPATH = None
72 ADML_SEARCH_XPATH = None
73 ADMX_DISPLAYNAME_SEARCH_XPATH = None
74 PRESENTATION_ANCESTOR_XPATH = None
75 TEXT_ELEMENT_XPATH = None
76 try:
77     import struct
78     import lxml
79     import win32net
80     import win32security
81     from lxml import etree
82     from salt.utils.win_reg import Registry
83     HAS_WINDOWS_MODULES = True
84     TRUE_VALUE_XPATH = etree.XPath('.//*[local-name() = "trueValue"]')
85     FALSE_VALUE_XPATH = etree.XPath('.//*[local-name() = "falseValue"]')
86     ELEMENTS_XPATH = etree.XPath('.//*[local-name() = "elements"]')
87     ENABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "enabledValue"]')
88     DISABLED_VALUE_XPATH = etree.XPath('.//*[local-name() = "disabledValue"]')
89     ENABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "enabledList"]')
90     DISABLED_LIST_XPATH = etree.XPath('.//*[local-name() = "disabledList"]')
91     VALUE_XPATH = etree.XPath('.//*[local-name() = "value"]')
92     TRUE_LIST_XPATH = etree.XPath('.//*[local-name() = "trueList"]')
93     FALSE_LIST_XPATH = etree.XPath('.//*[local-name() = "falseList"]')
94     REGKEY_XPATH = etree.XPath("//*[@key = $keyvalue]")
95     POLICY_ANCESTOR_XPATH = etree.XPath('ancestor::*[local-name() = "policy"]')
96     ALL_CLASS_POLICY_XPATH = etree.XPath(
97         '//*[local-name() = "policy" and (@*[local-name() = "class"] = "Both" or'
98         ' @*[local-name() = "class"] = $registry_class)]'
99     )
100     ADML_DISPLAY_NAME_XPATH = etree.XPath(
101         '//*[local-name() = $displayNameType and @*[local-name() = "id"] ='
102         " $displayNameId]"
103     )
104     VALUE_LIST_XPATH = etree.XPath('.//*[local-name() = "valueList"]')
105     ENUM_ITEM_DISPLAY_NAME_XPATH = etree.XPath(
106         './/*[local-name() = "item" and @*[local-name() = "displayName" ='
107         " $display_name]]"
108     )
109     ADMX_SEARCH_XPATH = etree.XPath(
110         '//*[local-name() = "policy" and @*[local-name() = "name"] = $policy_name and'
111         ' (@*[local-name() = "class"] = "Both" or @*[local-name() = "class"] ='
112         " $registry_class)]"
113     )
114     ADML_SEARCH_XPATH = etree.XPath(
115         '//*[starts-with(text(), $policy_name) and @*[local-name() = "id"]]'
116     )
117     ADMX_DISPLAYNAME_SEARCH_XPATH = etree.XPath(
118         '//*[local-name() = "policy" and @*[local-name() = "displayName"] ='
119         ' $display_name and (@*[local-name() = "class"] = "Both" or @*[local-name() ='
120         ' "class"] = $registry_class) ]'
121     )
122     PRESENTATION_ANCESTOR_XPATH = etree.XPath(
123         'ancestor::*[local-name() = "presentation"]'
124     )
125     TEXT_ELEMENT_XPATH = etree.XPath('.//*[local-name() = "text"]')
126     windll = ctypes.windll.kernel32
127     INSTALL_LANGUAGE = locale.windows_locale.get(
128         windll.GetSystemDefaultUILanguage(), "en_US"
129     ).replace("_", "-")
130 except ImportError:
131     HAS_WINDOWS_MODULES = False
132 class _policy_info:
133     r"""
134     Policy Helper Class
135     ===================
136     The format of the policy dict is as follows:
137     The top most two key/value pairs in the dict divide the policies object into
138     the two sections of local group policy, using the keys "Machine" and "User".
139     The value make-up of these dicts are described below in "Policy Section
140     Definition"
141     Policy Section Definition
142     -------------------------
143     A policy section dict has two required key/value pairs:
144     ============  ==============================================================
145     Key
146     ============  ==============================================================
147     lgpo_section  String matching how the policy section is displayed in the mmc
148                   snap-in ("Computer Configuration" for "Machine" and "User
149                   Configuration" for "User")
150     policies      a dict containing the non-Administrative template policy
151                   definitions, the key for each item is a short/unique
152                   identifier for the policy, the value is described below in
153                   "Policies Definition"
154     ============  ==============================================================
155     Policies Definition
156     -------------------
157     A policies definition item describes the particular policy. There are three
158     child key/value pairs shared with all policy types:
159     ============  ==============================================================
160     Key           Value
161     ============  ==============================================================
162     lgpo_section  A list containing the hierarchical path to the policy in the
163                   gpedit mmc snap-in.
164     Policy        A string containing the name of the policy in the gpedit mmc
165                   snap-in
166     Settings      An object which describes valid settings for the policy. This
167                   can be None for no validation, a list of possible settings, or
168                   a dict with the following key/value pairs:
169                   - **Function:** The class function to use to validate the
170                     setting
171                   - **Args:** A dict of kwargs to pass to the class function
172     ============  ==============================================================
173     Additionally, each policies definition will contain a key/value pair that
174     defines the mechanism that will be used to configure the policy. The
175     available mechanisms are:  NetUserModal, Registry, Secedit, and LsaRights
176     Registry Mechanism
177     ------------------
178     Some policies simply set values in the Windows registry. The value of this
179     key is a dict with the following make-up:
180     =====  =====================================================================
181     Key    Value
182     =====  =====================================================================
183     Hive   A string containing the Registry hive, such as ``HKEY_LOCAL_MACHINE``
184     Path   A string containing the registry key path, such as
185            ``SYSTEM\\CurrentControlSet\\Control\\Lsa``
186     Value  A string containing the name of the registry value, such as
187            **restrictanonymous**
188     Type   A string containing the registry type of the value, such as
189            ``REG_DWORD``
190     =====  =====================================================================
191     Secedit Mechanism
192     -----------------
193     Some policies are configurable via the "secedit.exe" executable. The value
194     of this key is a dict with the following make-up:
195     =======  ===================================================================
196     Key      Value
197     =======  ===================================================================
198     Option   A string containing the name of the policy as it appears in an
199              export from secedit, such as **PasswordComplexity**
200     Section  A string containing the name of the section in which the "Option"
201              value appears in an export from ``secedit``, such as "System
202              Access"
203     =======  ===================================================================
204     LsaRights Mechanism
205     -------------------
206     LSA Rights policies are configured via the LsaRights mechanism. The value of
207     this key is a dict with the following make-up:
208     ======  ====================================================================
209     Key     Value
210     ======  ====================================================================
211     Option  A string containing the programmatic name of the Lsa Right, such as
212             **SeNetworkLogonRight**
213     ======  ====================================================================
214     NetUserModal Mechanism
215     ----------------------
216     Some policies are configurable by the **NetUserModalGet** and
217     **NetUserModalSet** function from pywin32.  The value of this key is a dict
218     with the following make-up:
219     ======  ====================================================================
220     Key     Value
221     ======  ====================================================================
222     Modal   The modal "level" that the particular option is specified in (0-3),
223             see `here &lt;https://msdn.microsoft.com/en-us/library/windows/desktop/
224             aa370656(v=vs.85).aspx&gt;`_
225     Option  The name of the structure member which contains the data for the
226             policy, for example **max_passwd_age**
227     ======  ====================================================================
228     NetSH Mechanism
229     ---------------
230     The firewall policies are configured by the ``netsh.exe`` executable. The
231     value of this key is a dict with the following make-up:
232     =======  ===================================================================
233     Key      Value
234     =======  ===================================================================
235     Profile  The firewall profile to modify. Can be one of Domain, Private, or
236              Public
237     Section  The section of the firewall to modify. Can be one of state,
238              firewallpolicy, settings, or logging.
239     Option   The setting within that section
240     Value    The value of the setting
241     =======  ===================================================================
242     More information can be found in the advfirewall context in netsh. This can
243     be access by opening a netsh prompt. At a command prompt type the following:
244     c:\&gt;netsh
245     netsh&gt;advfirewall
246     netsh advfirewall&gt;set help
247     netsh advfirewall&gt;set domain help
248     AdvAudit Mechanism
249     ------------------
250     The Advanced Audit Policies are configured using a combination of the
251     auditpol command-line utility and modifying the audit.csv file in two
252     locations. The value of this key is a dict with the following make-up:
253     ======  ===================================
254     Key     Value
255     ======  ===================================
256     Option  The Advanced Audit Policy to modify
257     ======  ===================================
258     Transforms
259     ----------
260     Optionally, each policy definition can contain a "Transform" key. The
261     Transform key is used to handle data that is stored and viewed differently.
262     This key's value is a dict with the following key/value pairs:
263     ===  =======================================================================
264     Key  Value
265     ===  =======================================================================
266     Get  The name of the class function to use to transform the data from the
267          stored value to how the value is displayed in the GUI
268     Put The name of the class function to use to transform the data supplied by
269         the user to the correct value that the policy is stored in
270     ===  =======================================================================
271     For example, "Minimum password age" is stored in seconds, but is displayed
272     in days.  Thus the "Get" and "Put" functions for this policy do these
273     conversions so the user is able to set and view the policy using the same
274     data that is shown in the GUI.
275     """
276     def __init__(self):
277         self.audit_lookup = {
278             0: "No auditing",
279             1: "Success",
280             2: "Failure",
281             3: "Success, Failure",
282             "Not Defined": "Not Defined",
283             None: "Not Defined",
284         }
285         self.advanced_audit_lookup = {
286             0: "No Auditing",
287             1: "Success",
288             2: "Failure",
289             3: "Success and Failure",
290             None: "Not Configured",
291         }
292         self.sc_removal_lookup = {
293             "0": "No Action",
294             "1": "Lock Workstation",
295             "2": "Force Logoff",
296             "3": "Disconnect if a Remote Desktop Services session",
297             None: "Not Defined",
298             "(value not set)": "Not Defined",
299         }
300         self.uac_admin_prompt_lookup = {
301             0: "Elevate without prompting",
302             1: "Prompt for credentials on the secure desktop",
303             2: "Prompt for consent on the secure desktop",
304             3: "Prompt for credentials",
305             4: "Prompt for consent",
306             5: "Prompt for consent for non-Windows binaries",
307             None: "Not Defined",
308             "(value not set)": "Not Defined",
309         }
310         self.uac_user_prompt_lookup = {
311             0: "Automatically deny elevation requests",
312             1: "Prompt for credentials on the secure desktop",
313             3: "Prompt for credentials",
314             None: "Not Defined",
315             "(value not set)": "Not Defined",
316         }
317         self.enabled_one_disabled_zero = {
318             0: "Disabled",
319             1: "Enabled",
320             None: "Not Defined",
321             "(value not set)": "Not Defined",
322         }
323         self.enabled_one_disabled_zero_transform = {
324             "Get": "_dict_lookup",
325             "Put": "_dict_lookup",
326             "GetArgs": {
327                 "lookup": self.enabled_one_disabled_zero,
328                 "value_lookup": False,
329             },
330             "PutArgs": {
331                 "lookup": self.enabled_one_disabled_zero,
332                 "value_lookup": True,
333             },
334         }
335         self.s4u2self_options = {
336             0: "Default",
337             1: "Enabled",
338             2: "Disabled",
339             None: "Not Defined",
340             "(value not set)": "Not Defined",
341         }
342         self.audit_transform = {
343             "Get": "_dict_lookup",
344             "Put": "_dict_lookup",
345             "GetArgs": {"lookup": self.audit_lookup, "value_lookup": False},
346             "PutArgs": {"lookup": self.audit_lookup, "value_lookup": True},
347         }
348         self.advanced_audit_transform = {
349             "Get": "_dict_lookup",
350             "Put": "_dict_lookup",
351             "GetArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": False},
352             "PutArgs": {"lookup": self.advanced_audit_lookup, "value_lookup": True},
353         }
354         self.enabled_one_disabled_zero_strings = {
355             "0": "Disabled",
356             "1": "Enabled",
357             None: "Not Defined",
358             "(value not set)": "Not Defined",
359         }
360         self.enabled_one_disabled_zero_strings_transform = {
361             "Get": "_dict_lookup",
362             "Put": "_dict_lookup",
363             "GetArgs": {
364                 "lookup": self.enabled_one_disabled_zero_strings,
365                 "value_lookup": False,
366             },
367             "PutArgs": {
368                 "lookup": self.enabled_one_disabled_zero_strings,
369                 "value_lookup": True,
370             },
371         }
372         self.security_options_gpedit_path = [
373             "Computer Configuration",
374             "Windows Settings",
375             "Security Settings",
376             "Local Policies",
377             "Security Options",
378         ]
379         self.windows_firewall_gpedit_path = [
380             "Computer Configuration",
381             "Windows Settings",
382             "Security Settings",
383             "Windows Firewall with Advanced Security",
384             "Windows Firewall with Advanced Security - Local Group Policy Object",
385         ]
386         self.password_policy_gpedit_path = [
387             "Computer Configuration",
388             "Windows Settings",
389             "Security Settings",
390             "Account Policies",
391             "Password Policy",
392         ]
393         self.audit_policy_gpedit_path = [
394             "Computer Configuration",
395             "Windows Settings",
396             "Security Settings",
397             "Local Policies",
398             "Audit Policy",
399         ]
400         self.advanced_audit_policy_gpedit_path = [
401             "Computer Configuration",
402             "Windows Settings",
403             "Security Settings",
404             "Advanced Audit Policy Configuration",
405             "System Audit Policies - Local Group Policy Object",
406         ]
407         self.account_lockout_policy_gpedit_path = [
408             "Computer Configuration",
409             "Windows Settings",
410             "Security Settings",
411             "Account Policies",
412             "Account Lockout Policy",
413         ]
414         self.user_rights_assignment_gpedit_path = [
415             "Computer Configuration",
416             "Windows Settings",
417             "Security Settings",
418             "Local Policies",
419             "User Rights Assignment",
420         ]
421         self.block_ms_accounts = {
422             0: "This policy is disabled",
423             1: "Users can't add Microsoft accounts",
424             3: "Users can't add or log on with Microsoft accounts",
425             None: "Not Defined",
426             "(value not set)": "Not Defined",
427         }
428         self.ldap_server_signing_requirements = {
429             1: "None",
430             2: "Require signing",
431             None: "Not Defined",
432             "(value not set)": "Not Defined",
433         }
434         self.smb_server_name_hardening_levels = {
435             0: "Off",
436             1: "Accept if provided by client",
437             2: "Required from client",
438             None: "Not Defined",
439             "(value not set)": "Not Defined",
440         }
441         self.locked_session_user_info = {
442             1: "User display name, domain and user names",
443             2: "User display name only",
444             3: "Do not display user information",
445             None: "Not Defined",
446             "(value not set)": "Not Defined",
447         }
448         self.force_guest = {
449             0: "Classic - local users authenticate as themselves",
450             1: "Guest only - local users authenticate as Guest",
451             None: "Not Defined",
452             "(value not set)": "Not Defined",
453         }
454         self.force_key_protection = {
455             0: "User input is not required when new keys are stored and used",
456             1: "User is prompted when the key is first used",
457             2: "User must enter a password each time they use a key",
458             None: "Not Defined",
459             "(value not set)": "Not Defined",
460         }
461         self.firewall_inbound_connections = {
462             "blockinbound": "Block (default)",
463             "blockinboundalways": "Block all connections",
464             "allowinbound": "Allow",
465             "notconfigured": "Not configured",
466         }
467         self.firewall_outbound_connections = {
468             "blockoutbound": "Block",
469             "allowoutbound": "Allow (default)",
470             "notconfigured": "Not configured",
471         }
472         self.firewall_rule_merging = {
473             "enable": "Yes (default)",
474             "disable": "No",
475             "notconfigured": "Not configured",
476         }
477         self.firewall_log_packets_connections = {
478             "enable": "Yes",
479             "disable": "No (default)",
480             "notconfigured": "Not configured",
481         }
482         self.firewall_notification = {
483             "enable": "Yes",
484             "disable": "No",
485             "notconfigured": "Not configured",
486         }
487         self.firewall_state = {
488             "on": "On (recommended)",
489             "off": "Off",
490             "notconfigured": "Not configured",
491         }
492         self.krb_encryption_types = {
493             0: "No minimum",
494             1: "DES_CBC_CRC",
495             2: "DES_CBD_MD5",
496             4: "RC4_HMAC_MD5",
497             8: "AES128_HMAC_SHA1",
498             16: "AES256_HMAC_SHA1",
499             2147483616: "Future Encryption Types",
500             None: "Not Defined",
501             "(value not set)": "Not Defined",
502         }
503         self.lm_compat_levels = {
504             0: "Send LM &amp; NTLM response",
505             1: "Send LM &amp; NTLM - use NTLMv2 session security if negotiated",
506             2: "Send NTLM response only",
507             3: "Send NTLMv2 response only",
508             4: "Send NTLMv2 response only. Refuse LM",
509             5: "Send NTLMv2 response only. Refuse LM &amp; NTLM",
510             None: "Not Defined",
511             "(value not set)": "Not Defined",
512         }
513         self.ldap_signing_reqs = {
514             0: "None",
515             1: "Negotiate signing",
516             2: "Require signing",
517             None: "Not Defined",
518             "(value not set)": "Not Defined",
519         }
520         self.ntlm_session_security_levels = {
521             0: "No minimum",
522             524288: "Require NTLMv2 session security",
523             536870912: "Require 128-bit encryption",
524             None: "Not Defined",
525             "(value not set)": "Not Defined",
526         }
527         self.ntlm_audit_settings = {
528             0: "Disable",
529             1: "Enable auditing for domain accounts",
530             2: "Enable auditing for all accounts",
531             None: "Not Defined",
532             "(value not set)": "Not Defined",
533         }
534         self.ntlm_domain_audit_settings = {
535             0: "Disable",
536             1: "Enable for domain accounts to domain servers",
537             3: "Enable for domain accounts",
538             5: "Enable for domain servers",
539             7: "Enable all",
540             None: "Not Defined",
541             "(value not set)": "Not Defined",
542         }
543         self.incoming_ntlm_settings = {
544             0: "Allow all",
545             1: "Deny all domain accounts",
546             2: "Deny all accounts",
547             None: "Not Defined",
548             "(value not set)": "Not Defined",
549         }
550         self.ntlm_domain_auth_settings = {
551             0: "Disable",
552             1: "Deny for domain accounts to domain servers",
553             3: "Deny for domain accounts",
554             5: "Deny for domain servers",
555             7: "Deny all",
556             None: "Not Defined",
557             "(value not set)": "Not Defined",
558         }
559         self.outgoing_ntlm_settings = {
560             0: "Allow all",
561             1: "Audit all",
562             2: "Deny all",
563             None: "Not Defined",
564             "(value not set)": "Not Defined",
565         }
566         self.enabled_one_disabled_zero_no_not_defined = {
567             0: "Disabled",
568             1: "Enabled",
569         }
570         self.enabled_one_disabled_zero_no_not_defined_transform = {
571             "Get": "_dict_lookup",
572             "Put": "_dict_lookup",
573             "GetArgs": {
574                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
575                 "value_lookup": False,
576             },
577             "PutArgs": {
578                 "lookup": self.enabled_one_disabled_zero_no_not_defined,
579                 "value_lookup": True,
580             },
581         }
582         self.policies = {
583             "Machine": {
584                 "lgpo_section": "Computer Configuration",
585                 "policies": {
586                     "StartupScripts": {
587                         "Policy": "Startup Scripts",
588                         "lgpo_section": [
589                             "Computer Configuration",
590                             "Windows Settings",
591                             "Scripts (Startup/Shutdown)",
592                             "Startup",
593                         ],
594                         "ScriptIni": {
595                             "Section": "Startup",
596                             "IniPath": os.path.join(
597                                 os.getenv("WINDIR"),
598                                 "System32",
599                                 "GroupPolicy",
600                                 "Machine",
601                                 "Scripts",
602                                 "scripts.ini",
603                             ),
604                         },
605                     },
606                     "StartupPowershellScripts": {
607                         "Policy": "Startup Powershell Scripts",
608                         "lgpo_section": [
609                             "Computer Configuration",
610                             "Windows Settings",
611                             "Scripts (Startup/Shutdown)",
612                             "Startup",
613                         ],
614                         "ScriptIni": {
615                             "Section": "Startup",
616                             "IniPath": os.path.join(
617                                 os.getenv("WINDIR"),
618                                 "System32",
619                                 "GroupPolicy",
620                                 "Machine",
621                                 "Scripts",
622                                 "psscripts.ini",
623                             ),
624                         },
625                     },
626                     "StartupPowershellScriptOrder": {
627                         "Policy": (
628                             "Startup - For this GPO, run scripts in the following order"
629                         ),
630                         "lgpo_section": [
631                             "Computer Configuration",
632                             "Windows Settings",
633                             "Scripts (Startup/Shutdown)",
634                             "Startup",
635                         ],
636                         "ScriptIni": {
637                             "IniPath": os.path.join(
638                                 os.getenv("WINDIR"),
639                                 "System32",
640                                 "GroupPolicy",
641                                 "Machine",
642                                 "Scripts",
643                                 "psscripts.ini",
644                             ),
645                             "Section": "ScriptsConfig",
646                             "SettingName": "StartExecutePSFirst",
647                             "Settings": ["true", "false", None],
648                         },
649                         "Transform": {
650                             "Get": "_powershell_script_order_conversion",
651                             "Put": "_powershell_script_order_reverse_conversion",
652                         },
653                     },
654                     "ShutdownScripts": {
655                         "Policy": "Shutdown Scripts",
656                         "lgpo_section": [
657                             "Computer Configuration",
658                             "Windows Settings",
659                             "Scripts (Startup/Shutdown)",
660                             "Shutdown",
661                         ],
662                         "ScriptIni": {
663                             "Section": "Shutdown",
664                             "IniPath": os.path.join(
665                                 os.getenv("WINDIR"),
666                                 "System32",
667                                 "GroupPolicy",
668                                 "Machine",
669                                 "Scripts",
670                                 "scripts.ini",
671                             ),
672                         },
673                     },
674                     "ShutdownPowershellScripts": {
675                         "Policy": "Shutdown Powershell Scripts",
676                         "lgpo_section": [
677                             "Computer Configuration",
678                             "Windows Settings",
679                             "Scripts (Startup/Shutdown)",
680                             "Shutdown",
681                         ],
682                         "ScriptIni": {
683                             "Section": "Shutdown",
684                             "IniPath": os.path.join(
685                                 os.getenv("WINDIR"),
686                                 "System32",
687                                 "GroupPolicy",
688                                 "Machine",
689                                 "Scripts",
690                                 "psscripts.ini",
691                             ),
692                         },
693                     },
694                     "ShutdownPowershellScriptOrder": {
695                         "Policy": (
696                             "Shutdown - For this GPO, run scripts in the "
697                             "following order"
698                         ),
699                         "lgpo_section": [
700                             "Computer Configuration",
701                             "Windows Settings",
702                             "Scripts (Startup/Shutdown)",
703                             "Shutdown",
704                         ],
705                         "ScriptIni": {
706                             "IniPath": os.path.join(
707                                 os.getenv("WINDIR"),
708                                 "System32",
709                                 "GroupPolicy",
710                                 "Machine",
711                                 "Scripts",
712                                 "psscripts.ini",
713                             ),
714                             "Section": "ScriptsConfig",
715                             "SettingName": "EndExecutePSFirst",
716                             "Settings": ["true", "false", None],
717                         },
718                         "Transform": {
719                             "Get": "_powershell_script_order_conversion",
720                             "Put": "_powershell_script_order_reverse_conversion",
721                         },
722                     },
723                     "LSAAnonymousNameLookup": {
724                         "Policy": (
725                             "Network access: Allow anonymous SID/Name translation"
726                         ),
727                         "lgpo_section": self.password_policy_gpedit_path,
728                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
729                         "Secedit": {
730                             "Option": "LSAAnonymousNameLookup",
731                             "Section": "System Access",
732                         },
733                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
734                     },
735                     "RestrictAnonymousSam": {
736                         "Policy": (
737                             "Network access: Do not allow anonymous "
738                             "enumeration of SAM accounts"
739                         ),
740                         "lgpo_section": self.security_options_gpedit_path,
741                         "Settings": self.enabled_one_disabled_zero.keys(),
742                         "Registry": {
743                             "Hive": "HKEY_LOCAL_MACHINE",
744                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
745                             "Value": "RestrictAnonymousSam",
746                             "Type": "REG_DWORD",
747                         },
748                         "Transform": self.enabled_one_disabled_zero_transform,
749                     },
750                     "RestrictRemoteSAM": {
751                         "Policy": (
752                             "Network access: Restrict clients allowed to "
753                             "make remote calls to SAM"
754                         ),
755                         "lgpo_section": self.security_options_gpedit_path,
756                         "Registry": {
757                             "Hive": "HKEY_LOCAL_MACHINE",
758                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
759                             "Value": "RestrictRemoteSAM",
760                             "Type": "REG_SZ",
761                         },
762                         "Transform": {"Put": "_string_put_transform"},
763                     },
764                     "RestrictAnonymous": {
765                         "Policy": (
766                             "Network access: Do not allow anonymous "
767                             "enumeration of SAM accounts and shares"
768                         ),
769                         "lgpo_section": self.security_options_gpedit_path,
770                         "Settings": self.enabled_one_disabled_zero.keys(),
771                         "Registry": {
772                             "Hive": "HKEY_LOCAL_MACHINE",
773                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
774                             "Value": "RestrictAnonymous",
775                             "Type": "REG_DWORD",
776                         },
777                         "Transform": self.enabled_one_disabled_zero_transform,
778                     },
779                     "DisableDomainCreds": {
780                         "Policy": (
781                             "Network access: Do not allow storage of "
782                             "passwords and credentials for network "
783                             "authentication"
784                         ),
785                         "lgpo_section": self.security_options_gpedit_path,
786                         "Settings": self.enabled_one_disabled_zero.keys(),
787                         "Registry": {
788                             "Hive": "HKEY_LOCAL_MACHINE",
789                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
790                             "Value": "DisableDomainCreds",
791                             "Type": "REG_DWORD",
792                         },
793                         "Transform": self.enabled_one_disabled_zero_transform,
794                     },
795                     "EveryoneIncludesAnonymous": {
796                         "Policy": (
797                             "Network access: Let Everyone permissions "
798                             "apply to anonymous users"
799                         ),
800                         "lgpo_section": self.security_options_gpedit_path,
801                         "Settings": self.enabled_one_disabled_zero.keys(),
802                         "Registry": {
803                             "Hive": "HKEY_LOCAL_MACHINE",
804                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
805                             "Value": "everyoneincludesanonymous",
806                             "Type": "REG_DWORD",
807                         },
808                         "Transform": self.enabled_one_disabled_zero_transform,
809                     },
810                     "NullSessionPipes": {
811                         "Policy": (
812                             "Network access: Named Pipes that can be "
813                             "accessed anonymously"
814                         ),
815                         "lgpo_section": self.security_options_gpedit_path,
816                         "Registry": {
817                             "Hive": "HKEY_LOCAL_MACHINE",
818                             "Path": (
819                                 "SYSTEM\\CurrentControlSet\\Services\\"
820                                 "LanmanServer\\Parameters"
821                             ),
822                             "Value": "NullSessionPipes",
823                             "Type": "REG_MULTI_SZ",
824                         },
825                         "Transform": {
826                             "Put": "_multi_string_put_transform",
827                             "Get": "_multi_string_get_transform",
828                         },
829                     },
830                     "RemoteRegistryExactPaths": {
831                         "Policy": "Network access: Remotely accessible registry paths",
832                         "lgpo_section": self.security_options_gpedit_path,
833                         "Registry": {
834                             "Hive": "HKEY_LOCAL_MACHINE",
835                             "Path": (
836                                 "SYSTEM\\CurrentControlSet\\Control\\"
837                                 "SecurePipeServers\\winreg\\"
838                                 "AllowedExactPaths"
839                             ),
840                             "Value": "Machine",
841                             "Type": "REG_MULTI_SZ",
842                         },
843                         "Transform": {
844                             "Put": "_multi_string_put_transform",
845                             "Get": "_multi_string_get_transform",
846                         },
847                     },
848                     "RemoteRegistryPaths": {
849                         "Policy": (
850                             "Network access: Remotely accessible "
851                             "registry paths and sub-paths"
852                         ),
853                         "lgpo_section": self.security_options_gpedit_path,
854                         "Registry": {
855                             "Hive": "HKEY_LOCAL_MACHINE",
856                             "Path": (
857                                 "SYSTEM\\CurrentControlSet\\Control\\"
858                                 "SecurePipeServers\\winreg\\AllowedPaths"
859                             ),
860                             "Value": "Machine",
861                             "Type": "REG_MULTI_SZ",
862                         },
863                         "Transform": {
864                             "Put": "_multi_string_put_transform",
865                             "Get": "_multi_string_get_transform",
866                         },
867                     },
868                     "RestrictNullSessAccess": {
869                         "Policy": (
870                             "Network access: Restrict anonymous access "
871                             "to Named Pipes and Shares"
872                         ),
873                         "lgpo_section": self.security_options_gpedit_path,
874                         "Settings": self.enabled_one_disabled_zero.keys(),
875                         "Registry": {
876                             "Hive": "HKEY_LOCAL_MACHINE",
877                             "Path": (
878                                 "System\\CurrentControlSet\\Services\\"
879                                 "LanmanServer\\Parameters"
880                             ),
881                             "Value": "RestrictNullSessAccess",
882                             "Type": "REG_DWORD",
883                         },
884                         "Transform": self.enabled_one_disabled_zero_transform,
885                     },
886                     "NullSessionShares": {
887                         "Policy": (
888                             "Network access: Shares that can be accessed anonymously"
889                         ),
890                         "lgpo_section": self.security_options_gpedit_path,
891                         "Registry": {
892                             "Hive": "HKEY_LOCAL_MACHINE",
893                             "Path": (
894                                 "SYSTEM\\CurrentControlSet\\Services\\"
895                                 "LanmanServer\\Parameters"
896                             ),
897                             "Value": "NullSessionShares",
898                             "Type": "REG_MULTI_SZ",
899                         },
900                         "Transform": {
901                             "Put": "_multi_string_put_transform",
902                             "Get": "_multi_string_get_transform",
903                         },
904                     },
905                     "ForceGuest": {
906                         "Policy": (
907                             "Network access: Sharing and security model "
908                             "for local accounts"
909                         ),
910                         "lgpo_section": self.security_options_gpedit_path,
911                         "Settings": self.force_guest.keys(),
912                         "Registry": {
913                             "Hive": "HKEY_LOCAL_MACHINE",
914                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
915                             "Value": "ForceGuest",
916                             "Type": "REG_DWORD",
917                         },
918                         "Transform": {
919                             "Get": "_dict_lookup",
920                             "Put": "_dict_lookup",
921                             "GetArgs": {
922                                 "lookup": self.force_guest,
923                                 "value_lookup": False,
924                             },
925                             "PutArgs": {
926                                 "lookup": self.force_guest,
927                                 "value_lookup": True,
928                             },
929                         },
930                     },
931                     "WfwDomainState": {
932                         "Policy": "Network firewall: Domain: State",
933                         "lgpo_section": self.windows_firewall_gpedit_path,
934                         "Settings": self.firewall_state.keys(),
935                         "NetSH": {
936                             "Profile": "domain",
937                             "Section": "state",
938                             "Option": "State",  # Unused, but needed
939                         },
940                         "Transform": {
941                             "Get": "_dict_lookup",
942                             "Put": "_dict_lookup",
943                             "GetArgs": {
944                                 "lookup": self.firewall_state,
945                                 "value_lookup": False,
946                             },
947                             "PutArgs": {
948                                 "lookup": self.firewall_state,
949                                 "value_lookup": True,
950                             },
951                         },
952                     },
953                     "WfwPrivateState": {
954                         "Policy": "Network firewall: Private: State",
955                         "lgpo_section": self.windows_firewall_gpedit_path,
956                         "Settings": self.firewall_state.keys(),
957                         "NetSH": {
958                             "Profile": "private",
959                             "Section": "state",
960                             "Option": "State",  # Unused, but needed
961                         },
962                         "Transform": {
963                             "Get": "_dict_lookup",
964                             "Put": "_dict_lookup",
965                             "GetArgs": {
966                                 "lookup": self.firewall_state,
967                                 "value_lookup": False,
968                             },
969                             "PutArgs": {
970                                 "lookup": self.firewall_state,
971                                 "value_lookup": True,
972                             },
973                         },
974                     },
975                     "WfwPublicState": {
976                         "Policy": "Network firewall: Public: State",
977                         "lgpo_section": self.windows_firewall_gpedit_path,
978                         "Settings": self.firewall_state.keys(),
979                         "NetSH": {
980                             "Profile": "public",
981                             "Section": "state",
982                             "Option": "State",  # Unused, but needed
983                         },
984                         "Transform": {
985                             "Get": "_dict_lookup",
986                             "Put": "_dict_lookup",
987                             "GetArgs": {
988                                 "lookup": self.firewall_state,
989                                 "value_lookup": False,
990                             },
991                             "PutArgs": {
992                                 "lookup": self.firewall_state,
993                                 "value_lookup": True,
994                             },
995                         },
996                     },
997                     "WfwDomainInboundConnections": {
998                         "Policy": "Network firewall: Domain: Inbound connections",
999                         "lgpo_section": self.windows_firewall_gpedit_path,
1000                         "Settings": self.firewall_inbound_connections.keys(),
1001                         "NetSH": {
1002                             "Profile": "domain",
1003                             "Section": "firewallpolicy",
1004                             "Option": "Inbound",
1005                         },
1006                         "Transform": {
1007                             "Get": "_dict_lookup",
1008                             "Put": "_dict_lookup",
1009                             "GetArgs": {
1010                                 "lookup": self.firewall_inbound_connections,
1011                                 "value_lookup": False,
1012                             },
1013                             "PutArgs": {
1014                                 "lookup": self.firewall_inbound_connections,
1015                                 "value_lookup": True,
1016                             },
1017                         },
1018                     },
1019                     "WfwPrivateInboundConnections": {
1020                         "Policy": "Network firewall: Private: Inbound connections",
1021                         "lgpo_section": self.windows_firewall_gpedit_path,
1022                         "Settings": self.firewall_inbound_connections.keys(),
1023                         "NetSH": {
1024                             "Profile": "private",
1025                             "Section": "firewallpolicy",
1026                             "Option": "Inbound",
1027                         },
1028                         "Transform": {
1029                             "Get": "_dict_lookup",
1030                             "Put": "_dict_lookup",
1031                             "GetArgs": {
1032                                 "lookup": self.firewall_inbound_connections,
1033                                 "value_lookup": False,
1034                             },
1035                             "PutArgs": {
1036                                 "lookup": self.firewall_inbound_connections,
1037                                 "value_lookup": True,
1038                             },
1039                         },
1040                     },
1041                     "WfwPublicInboundConnections": {
1042                         "Policy": "Network firewall: Public: Inbound connections",
1043                         "lgpo_section": self.windows_firewall_gpedit_path,
1044                         "Settings": self.firewall_inbound_connections.keys(),
1045                         "NetSH": {
1046                             "Profile": "public",
1047                             "Section": "firewallpolicy",
1048                             "Option": "Inbound",
1049                         },
1050                         "Transform": {
1051                             "Get": "_dict_lookup",
1052                             "Put": "_dict_lookup",
1053                             "GetArgs": {
1054                                 "lookup": self.firewall_inbound_connections,
1055                                 "value_lookup": False,
1056                             },
1057                             "PutArgs": {
1058                                 "lookup": self.firewall_inbound_connections,
1059                                 "value_lookup": True,
1060                             },
1061                         },
1062                     },
1063                     "WfwDomainOutboundConnections": {
1064                         "Policy": "Network firewall: Domain: Outbound connections",
1065                         "lgpo_section": self.windows_firewall_gpedit_path,
1066                         "Settings": self.firewall_outbound_connections.keys(),
1067                         "NetSH": {
1068                             "Profile": "domain",
1069                             "Section": "firewallpolicy",
1070                             "Option": "Outbound",
1071                         },
1072                         "Transform": {
1073                             "Get": "_dict_lookup",
1074                             "Put": "_dict_lookup",
1075                             "GetArgs": {
1076                                 "lookup": self.firewall_outbound_connections,
1077                                 "value_lookup": False,
1078                             },
1079                             "PutArgs": {
1080                                 "lookup": self.firewall_outbound_connections,
1081                                 "value_lookup": True,
1082                             },
1083                         },
1084                     },
1085                     "WfwPrivateOutboundConnections": {
1086                         "Policy": "Network firewall: Private: Outbound connections",
1087                         "lgpo_section": self.windows_firewall_gpedit_path,
1088                         "Settings": self.firewall_outbound_connections.keys(),
1089                         "NetSH": {
1090                             "Profile": "private",
1091                             "Section": "firewallpolicy",
1092                             "Option": "Outbound",
1093                         },
1094                         "Transform": {
1095                             "Get": "_dict_lookup",
1096                             "Put": "_dict_lookup",
1097                             "GetArgs": {
1098                                 "lookup": self.firewall_outbound_connections,
1099                                 "value_lookup": False,
1100                             },
1101                             "PutArgs": {
1102                                 "lookup": self.firewall_outbound_connections,
1103                                 "value_lookup": True,
1104                             },
1105                         },
1106                     },
1107                     "WfwPublicOutboundConnections": {
1108                         "Policy": "Network firewall: Public: Outbound connections",
1109                         "lgpo_section": self.windows_firewall_gpedit_path,
1110                         "Settings": self.firewall_outbound_connections.keys(),
1111                         "NetSH": {
1112                             "Profile": "public",
1113                             "Section": "firewallpolicy",
1114                             "Option": "Outbound",
1115                         },
1116                         "Transform": {
1117                             "Get": "_dict_lookup",
1118                             "Put": "_dict_lookup",
1119                             "GetArgs": {
1120                                 "lookup": self.firewall_outbound_connections,
1121                                 "value_lookup": False,
1122                             },
1123                             "PutArgs": {
1124                                 "lookup": self.firewall_outbound_connections,
1125                                 "value_lookup": True,
1126                             },
1127                         },
1128                     },
1129                     "WfwDomainSettingsNotification": {
1130                         "Policy": (
1131                             "Network firewall: Domain: Settings: Display a notification"
1132                         ),
1133                         "lgpo_section": self.windows_firewall_gpedit_path,
1134                         "Settings": self.firewall_notification.keys(),
1135                         "NetSH": {
1136                             "Profile": "domain",
1137                             "Section": "settings",
1138                             "Option": "InboundUserNotification",
1139                         },
1140                         "Transform": {
1141                             "Get": "_dict_lookup",
1142                             "Put": "_dict_lookup",
1143                             "GetArgs": {
1144                                 "lookup": self.firewall_notification,
1145                                 "value_lookup": False,
1146                             },
1147                             "PutArgs": {
1148                                 "lookup": self.firewall_notification,
1149                                 "value_lookup": True,
1150                             },
1151                         },
1152                     },
1153                     "WfwPrivateSettingsNotification": {
1154                         "Policy": (
1155                             "Network firewall: Private: Settings: Display a"
1156                             " notification"
1157                         ),
1158                         "lgpo_section": self.windows_firewall_gpedit_path,
1159                         "Settings": self.firewall_notification.keys(),
1160                         "NetSH": {
1161                             "Profile": "private",
1162                             "Section": "settings",
1163                             "Option": "InboundUserNotification",
1164                         },
1165                         "Transform": {
1166                             "Get": "_dict_lookup",
1167                             "Put": "_dict_lookup",
1168                             "GetArgs": {
1169                                 "lookup": self.firewall_notification,
1170                                 "value_lookup": False,
1171                             },
1172                             "PutArgs": {
1173                                 "lookup": self.firewall_notification,
1174                                 "value_lookup": True,
1175                             },
1176                         },
1177                     },
1178                     "WfwPublicSettingsNotification": {
1179                         "Policy": (
1180                             "Network firewall: Public: Settings: Display a notification"
1181                         ),
1182                         "lgpo_section": self.windows_firewall_gpedit_path,
1183                         "Settings": self.firewall_notification.keys(),
1184                         "NetSH": {
1185                             "Profile": "public",
1186                             "Section": "settings",
1187                             "Option": "InboundUserNotification",
1188                         },
1189                         "Transform": {
1190                             "Get": "_dict_lookup",
1191                             "Put": "_dict_lookup",
1192                             "GetArgs": {
1193                                 "lookup": self.firewall_notification,
1194                                 "value_lookup": False,
1195                             },
1196                             "PutArgs": {
1197                                 "lookup": self.firewall_notification,
1198                                 "value_lookup": True,
1199                             },
1200                         },
1201                     },
1202                     "WfwDomainSettingsLocalFirewallRules": {
1203                         "Policy": (
1204                             "Network firewall: Domain: Settings: Apply "
1205                             "local firewall rules"
1206                         ),
1207                         "lgpo_section": self.windows_firewall_gpedit_path,
1208                         "Settings": self.firewall_rule_merging.keys(),
1209                         "NetSH": {
1210                             "Profile": "domain",
1211                             "Section": "settings",
1212                             "Option": "LocalFirewallRules",
1213                         },
1214                         "Transform": {
1215                             "Get": "_dict_lookup",
1216                             "Put": "_dict_lookup",
1217                             "GetArgs": {
1218                                 "lookup": self.firewall_rule_merging,
1219                                 "value_lookup": False,
1220                             },
1221                             "PutArgs": {
1222                                 "lookup": self.firewall_rule_merging,
1223                                 "value_lookup": True,
1224                             },
1225                         },
1226                     },
1227                     "WfwPrivateSettingsLocalFirewallRules": {
1228                         "Policy": (
1229                             "Network firewall: Private: Settings: Apply "
1230                             "local firewall rules"
1231                         ),
1232                         "lgpo_section": self.windows_firewall_gpedit_path,
1233                         "Settings": self.firewall_rule_merging.keys(),
1234                         "NetSH": {
1235                             "Profile": "private",
1236                             "Section": "settings",
1237                             "Option": "LocalFirewallRules",
1238                         },
1239                         "Transform": {
1240                             "Get": "_dict_lookup",
1241                             "Put": "_dict_lookup",
1242                             "GetArgs": {
1243                                 "lookup": self.firewall_rule_merging,
1244                                 "value_lookup": False,
1245                             },
1246                             "PutArgs": {
1247                                 "lookup": self.firewall_rule_merging,
1248                                 "value_lookup": True,
1249                             },
1250                         },
1251                     },
1252                     "WfwPublicSettingsLocalFirewallRules": {
1253                         "Policy": (
1254                             "Network firewall: Public: Settings: Apply "
1255                             "local firewall rules"
1256                         ),
1257                         "lgpo_section": self.windows_firewall_gpedit_path,
1258                         "Settings": self.firewall_rule_merging.keys(),
1259                         "NetSH": {
1260                             "Profile": "public",
1261                             "Section": "settings",
1262                             "Option": "LocalFirewallRules",
1263                         },
1264                         "Transform": {
1265                             "Get": "_dict_lookup",
1266                             "Put": "_dict_lookup",
1267                             "GetArgs": {
1268                                 "lookup": self.firewall_rule_merging,
1269                                 "value_lookup": False,
1270                             },
1271                             "PutArgs": {
1272                                 "lookup": self.firewall_rule_merging,
1273                                 "value_lookup": True,
1274                             },
1275                         },
1276                     },
1277                     "WfwDomainSettingsLocalConnectionRules": {
1278                         "Policy": (
1279                             "Network firewall: Domain: Settings: Apply "
1280                             "local connection security rules"
1281                         ),
1282                         "lgpo_section": self.windows_firewall_gpedit_path,
1283                         "Settings": self.firewall_rule_merging.keys(),
1284                         "NetSH": {
1285                             "Profile": "domain",
1286                             "Section": "settings",
1287                             "Option": "LocalConSecRules",
1288                         },
1289                         "Transform": {
1290                             "Get": "_dict_lookup",
1291                             "Put": "_dict_lookup",
1292                             "GetArgs": {
1293                                 "lookup": self.firewall_rule_merging,
1294                                 "value_lookup": False,
1295                             },
1296                             "PutArgs": {
1297                                 "lookup": self.firewall_rule_merging,
1298                                 "value_lookup": True,
1299                             },
1300                         },
1301                     },
1302                     "WfwPrivateSettingsLocalConnectionRules": {
1303                         "Policy": (
1304                             "Network firewall: Private: Settings: Apply "
1305                             "local connection security rules"
1306                         ),
1307                         "lgpo_section": self.windows_firewall_gpedit_path,
1308                         "Settings": self.firewall_rule_merging.keys(),
1309                         "NetSH": {
1310                             "Profile": "private",
1311                             "Section": "settings",
1312                             "Option": "LocalConSecRules",
1313                         },
1314                         "Transform": {
1315                             "Get": "_dict_lookup",
1316                             "Put": "_dict_lookup",
1317                             "GetArgs": {
1318                                 "lookup": self.firewall_rule_merging,
1319                                 "value_lookup": False,
1320                             },
1321                             "PutArgs": {
1322                                 "lookup": self.firewall_rule_merging,
1323                                 "value_lookup": True,
1324                             },
1325                         },
1326                     },
1327                     "WfwPublicSettingsLocalConnectionRules": {
1328                         "Policy": (
1329                             "Network firewall: Public: Settings: Apply "
1330                             "local connection security rules"
1331                         ),
1332                         "lgpo_section": self.windows_firewall_gpedit_path,
1333                         "Settings": self.firewall_rule_merging.keys(),
1334                         "NetSH": {
1335                             "Profile": "public",
1336                             "Section": "settings",
1337                             "Option": "LocalConSecRules",
1338                         },
1339                         "Transform": {
1340                             "Get": "_dict_lookup",
1341                             "Put": "_dict_lookup",
1342                             "GetArgs": {
1343                                 "lookup": self.firewall_rule_merging,
1344                                 "value_lookup": False,
1345                             },
1346                             "PutArgs": {
1347                                 "lookup": self.firewall_rule_merging,
1348                                 "value_lookup": True,
1349                             },
1350                         },
1351                     },
1352                     "WfwDomainLoggingName": {
1353                         "Policy": "Network firewall: Domain: Logging: Name",
1354                         "lgpo_section": self.windows_firewall_gpedit_path,
1355                         "Settings": None,
1356                         "NetSH": {
1357                             "Profile": "domain",
1358                             "Section": "logging",
1359                             "Option": "FileName",
1360                         },
1361                     },
1362                     "WfwPrivateLoggingName": {
1363                         "Policy": "Network firewall: Private: Logging: Name",
1364                         "lgpo_section": self.windows_firewall_gpedit_path,
1365                         "Settings": None,
1366                         "NetSH": {
1367                             "Profile": "private",
1368                             "Section": "logging",
1369                             "Option": "FileName",
1370                         },
1371                     },
1372                     "WfwPublicLoggingName": {
1373                         "Policy": "Network firewall: Public: Logging: Name",
1374                         "lgpo_section": self.windows_firewall_gpedit_path,
1375                         "Settings": None,
1376                         "NetSH": {
1377                             "Profile": "public",
1378                             "Section": "logging",
1379                             "Option": "FileName",
1380                         },
1381                     },
1382                     "WfwDomainLoggingMaxFileSize": {
1383                         "Policy": "Network firewall: Domain: Logging: Size limit (KB)",
1384                         "lgpo_section": self.windows_firewall_gpedit_path,
1385                         "Settings": None,
1386                         "NetSH": {
1387                             "Profile": "domain",
1388                             "Section": "logging",
1389                             "Option": "MaxFileSize",
1390                         },
1391                     },
1392                     "WfwPrivateLoggingMaxFileSize": {
1393                         "Policy": "Network firewall: Private: Logging: Size limit (KB)",
1394                         "lgpo_section": self.windows_firewall_gpedit_path,
1395                         "Settings": None,
1396                         "NetSH": {
1397                             "Profile": "private",
1398                             "Section": "logging",
1399                             "Option": "MaxFileSize",
1400                         },
1401                     },
1402                     "WfwPublicLoggingMaxFileSize": {
1403                         "Policy": "Network firewall: Public: Logging: Size limit (KB)",
1404                         "lgpo_section": self.windows_firewall_gpedit_path,
1405                         "Settings": None,
1406                         "NetSH": {
1407                             "Profile": "public",
1408                             "Section": "logging",
1409                             "Option": "MaxFileSize",
1410                         },
1411                     },
1412                     "WfwDomainLoggingAllowedConnections": {
1413                         "Policy": (
1414                             "Network firewall: Domain: Logging: Log successful"
1415                             " connections"
1416                         ),
1417                         "lgpo_section": self.windows_firewall_gpedit_path,
1418                         "Settings": self.firewall_log_packets_connections.keys(),
1419                         "NetSH": {
1420                             "Profile": "domain",
1421                             "Section": "logging",
1422                             "Option": "LogAllowedConnections",
1423                         },
1424                         "Transform": {
1425                             "Get": "_dict_lookup",
1426                             "Put": "_dict_lookup",
1427                             "GetArgs": {
1428                                 "lookup": self.firewall_log_packets_connections,
1429                                 "value_lookup": False,
1430                             },
1431                             "PutArgs": {
1432                                 "lookup": self.firewall_log_packets_connections,
1433                                 "value_lookup": True,
1434                             },
1435                         },
1436                     },
1437                     "WfwPrivateLoggingAllowedConnections": {
1438                         "Policy": (
1439                             "Network firewall: Private: Logging: Log successful"
1440                             " connections"
1441                         ),
1442                         "lgpo_section": self.windows_firewall_gpedit_path,
1443                         "Settings": self.firewall_log_packets_connections.keys(),
1444                         "NetSH": {
1445                             "Profile": "private",
1446                             "Section": "logging",
1447                             "Option": "LogAllowedConnections",
1448                         },
1449                         "Transform": {
1450                             "Get": "_dict_lookup",
1451                             "Put": "_dict_lookup",
1452                             "GetArgs": {
1453                                 "lookup": self.firewall_log_packets_connections,
1454                                 "value_lookup": False,
1455                             },
1456                             "PutArgs": {
1457                                 "lookup": self.firewall_log_packets_connections,
1458                                 "value_lookup": True,
1459                             },
1460                         },
1461                     },
1462                     "WfwPublicLoggingAllowedConnections": {
1463                         "Policy": (
1464                             "Network firewall: Public: Logging: Log successful"
1465                             " connections"
1466                         ),
1467                         "lgpo_section": self.windows_firewall_gpedit_path,
1468                         "Settings": self.firewall_log_packets_connections.keys(),
1469                         "NetSH": {
1470                             "Profile": "public",
1471                             "Section": "logging",
1472                             "Option": "LogAllowedConnections",
1473                         },
1474                         "Transform": {
1475                             "Get": "_dict_lookup",
1476                             "Put": "_dict_lookup",
1477                             "GetArgs": {
1478                                 "lookup": self.firewall_log_packets_connections,
1479                                 "value_lookup": False,
1480                             },
1481                             "PutArgs": {
1482                                 "lookup": self.firewall_log_packets_connections,
1483                                 "value_lookup": True,
1484                             },
1485                         },
1486                     },
1487                     "WfwDomainLoggingDroppedConnections": {
1488                         "Policy": (
1489                             "Network firewall: Domain: Logging: Log dropped packets"
1490                         ),
1491                         "lgpo_section": self.windows_firewall_gpedit_path,
1492                         "Settings": self.firewall_log_packets_connections.keys(),
1493                         "NetSH": {
1494                             "Profile": "domain",
1495                             "Section": "logging",
1496                             "Option": "LogDroppedConnections",
1497                         },
1498                         "Transform": {
1499                             "Get": "_dict_lookup",
1500                             "Put": "_dict_lookup",
1501                             "GetArgs": {
1502                                 "lookup": self.firewall_log_packets_connections,
1503                                 "value_lookup": False,
1504                             },
1505                             "PutArgs": {
1506                                 "lookup": self.firewall_log_packets_connections,
1507                                 "value_lookup": True,
1508                             },
1509                         },
1510                     },
1511                     "WfwPrivateLoggingDroppedConnections": {
1512                         "Policy": (
1513                             "Network firewall: Private: Logging: Log dropped packets"
1514                         ),
1515                         "lgpo_section": self.windows_firewall_gpedit_path,
1516                         "Settings": self.firewall_log_packets_connections.keys(),
1517                         "NetSH": {
1518                             "Profile": "private",
1519                             "Section": "logging",
1520                             "Option": "LogDroppedConnections",
1521                         },
1522                         "Transform": {
1523                             "Get": "_dict_lookup",
1524                             "Put": "_dict_lookup",
1525                             "GetArgs": {
1526                                 "lookup": self.firewall_log_packets_connections,
1527                                 "value_lookup": False,
1528                             },
1529                             "PutArgs": {
1530                                 "lookup": self.firewall_log_packets_connections,
1531                                 "value_lookup": True,
1532                             },
1533                         },
1534                     },
1535                     "WfwPublicLoggingDroppedConnections": {
1536                         "Policy": (
1537                             "Network firewall: Public: Logging: Log dropped packets"
1538                         ),
1539                         "lgpo_section": self.windows_firewall_gpedit_path,
1540                         "Settings": self.firewall_log_packets_connections.keys(),
1541                         "NetSH": {
1542                             "Profile": "public",
1543                             "Section": "logging",
1544                             "Option": "LogDroppedConnections",
1545                         },
1546                         "Transform": {
1547                             "Get": "_dict_lookup",
1548                             "Put": "_dict_lookup",
1549                             "GetArgs": {
1550                                 "lookup": self.firewall_log_packets_connections,
1551                                 "value_lookup": False,
1552                             },
1553                             "PutArgs": {
1554                                 "lookup": self.firewall_log_packets_connections,
1555                                 "value_lookup": True,
1556                             },
1557                         },
1558                     },
1559                     "PasswordHistory": {
1560                         "Policy": "Enforce password history",
1561                         "lgpo_section": self.password_policy_gpedit_path,
1562                         "Settings": {
1563                             "Function": "_in_range_inclusive",
1564                             "Args": {"min": 0, "max": 24},
1565                         },
1566                         "NetUserModal": {"Modal": 0, "Option": "password_hist_len"},
1567                     },
1568                     "MaxPasswordAge": {
1569                         "Policy": "Maximum password age",
1570                         "lgpo_section": self.password_policy_gpedit_path,
1571                         "Settings": {
1572                             "Function": "_in_range_inclusive",
1573                             "Args": {
1574                                 "min": 1,
1575                                 "max": 86313600,
1576                                 "zero_value": 0xFFFFFFFF,
1577                             },
1578                         },
1579                         "NetUserModal": {"Modal": 0, "Option": "max_passwd_age"},
1580                         "Transform": {
1581                             "Get": "_seconds_to_days",
1582                             "Put": "_days_to_seconds",
1583                             "GetArgs": {"zero_value": 0xFFFFFFFF},
1584                             "PutArgs": {"zero_value": 0xFFFFFFFF},
1585                         },
1586                     },
1587                     "MinPasswordAge": {
1588                         "Policy": "Minimum password age",
1589                         "lgpo_section": self.password_policy_gpedit_path,
1590                         "Settings": {
1591                             "Function": "_in_range_inclusive",
1592                             "Args": {"min": 0, "max": 86313600},
1593                         },
1594                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_age"},
1595                         "Transform": {
1596                             "Get": "_seconds_to_days",
1597                             "Put": "_days_to_seconds",
1598                         },
1599                     },
1600                     "MinPasswordLen": {
1601                         "Policy": "Minimum password length",
1602                         "lgpo_section": self.password_policy_gpedit_path,
1603                         "Settings": {
1604                             "Function": "_in_range_inclusive",
1605                             "Args": {"min": 0, "max": 14},
1606                         },
1607                         "NetUserModal": {"Modal": 0, "Option": "min_passwd_len"},
1608                     },
1609                     "PasswordComplexity": {
1610                         "Policy": "Password must meet complexity requirements",
1611                         "lgpo_section": self.password_policy_gpedit_path,
1612                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1613                         "Secedit": {
1614                             "Option": "PasswordComplexity",
1615                             "Section": "System Access",
1616                         },
1617                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1618                     },
1619                     "ClearTextPasswords": {
1620                         "Policy": "Store passwords using reversible encryption",
1621                         "lgpo_section": self.password_policy_gpedit_path,
1622                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1623                         "Secedit": {
1624                             "Option": "ClearTextPassword",
1625                             "Section": "System Access",
1626                         },
1627                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1628                     },
1629                     "AdminAccountStatus": {
1630                         "Policy": "Accounts: Administrator account status",
1631                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1632                         "lgpo_section": self.security_options_gpedit_path,
1633                         "Secedit": {
1634                             "Option": "EnableAdminAccount",
1635                             "Section": "System Access",
1636                         },
1637                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1638                     },
1639                     "NoConnectedUser": {
1640                         "Policy": "Accounts: Block Microsoft accounts",
1641                         "Settings": self.block_ms_accounts.keys(),
1642                         "lgpo_section": self.security_options_gpedit_path,
1643                         "Registry": {
1644                             "Hive": "HKEY_LOCAL_MACHINE",
1645                             "Path": (
1646                                 "SOFTWARE\\Microsoft\\Windows\\"
1647                                 "CurrentVersion\\policies\\system"
1648                             ),
1649                             "Value": "NoConnectedUser",
1650                             "Type": "REG_DWORD",
1651                         },
1652                         "Transform": {
1653                             "Get": "_dict_lookup",
1654                             "Put": "_dict_lookup",
1655                             "GetArgs": {
1656                                 "lookup": self.block_ms_accounts,
1657                                 "value_lookup": False,
1658                             },
1659                             "PutArgs": {
1660                                 "lookup": self.block_ms_accounts,
1661                                 "value_lookup": True,
1662                             },
1663                         },
1664                     },
1665                     "GuestAccountStatus": {
1666                         "Policy": "Accounts: Guest account status",
1667                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
1668                         "lgpo_section": self.security_options_gpedit_path,
1669                         "Secedit": {
1670                             "Option": "EnableGuestAccount",
1671                             "Section": "System Access",
1672                         },
1673                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
1674                     },
1675                     "LimitBlankPasswordUse": {
1676                         "Policy": (
1677                             "Accounts: Limit local account use of blank "
1678                             "passwords to console logon only"
1679                         ),
1680                         "lgpo_section": self.security_options_gpedit_path,
1681                         "Settings": self.enabled_one_disabled_zero.keys(),
1682                         "Registry": {
1683                             "Hive": "HKEY_LOCAL_MACHINE",
1684                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1685                             "Value": "limitblankpassworduse",
1686                             "Type": "REG_DWORD",
1687                         },
1688                         "Transform": self.enabled_one_disabled_zero_transform,
1689                     },
1690                     "RenameAdministratorAccount": {
1691                         "Policy": "Accounts: Rename administrator account",
1692                         "Settings": None,
1693                         "lgpo_section": self.security_options_gpedit_path,
1694                         "Secedit": {
1695                             "Option": "NewAdministratorName",
1696                             "Section": "System Access",
1697                         },
1698                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1699                     },
1700                     "RenameGuestAccount": {
1701                         "Policy": "Accounts: Rename guest account",
1702                         "Settings": None,
1703                         "lgpo_section": self.security_options_gpedit_path,
1704                         "Secedit": {
1705                             "Option": "NewGuestName",
1706                             "Section": "System Access",
1707                         },
1708                         "Transform": {"Get": "_strip_quotes", "Put": "_add_quotes"},
1709                     },
1710                     "AuditBaseObjects": {
1711                         "Policy": "Audit: Audit the access of global system objects",
1712                         "Settings": self.enabled_one_disabled_zero.keys(),
1713                         "lgpo_section": self.security_options_gpedit_path,
1714                         "Registry": {
1715                             "Hive": "HKEY_LOCAL_MACHINE",
1716                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1717                             "Value": "AuditBaseObjects",
1718                             "Type": "REG_DWORD",
1719                         },
1720                         "Transform": self.enabled_one_disabled_zero_transform,
1721                     },
1722                     "SceNoApplyLegacyAuditPolicy": {
1723                         "Policy": (
1724                             "Audit: Force audit policy subcategory "
1725                             "settings (Windows Vista or later) to "
1726                             "override audit policy category settings"
1727                         ),
1728                         "Settings": self.enabled_one_disabled_zero.keys(),
1729                         "lgpo_section": self.security_options_gpedit_path,
1730                         "Registry": {
1731                             "Hive": "HKEY_LOCAL_MACHINE",
1732                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
1733                             "Value": "SCENoApplyLegacyAuditPolicy",
1734                             "Type": "REG_DWORD",
1735                         },
1736                         "Transform": self.enabled_one_disabled_zero_transform,
1737                     },
1738                     "DontDisplayLastUserName": {
1739                         "Policy": "Interactive logon: Do not display last user name",
1740                         "Settings": self.enabled_one_disabled_zero.keys(),
1741                         "lgpo_section": self.security_options_gpedit_path,
1742                         "Registry": {
1743                             "Hive": "HKEY_LOCAL_MACHINE",
1744                             "Path": (
1745                                 "Software\\Microsoft\\Windows\\"
1746                                 "CurrentVersion\\Policies\\System"
1747                             ),
1748                             "Value": "DontDisplayLastUserName",
1749                             "Type": "REG_DWORD",
1750                         },
1751                         "Transform": self.enabled_one_disabled_zero_transform,
1752                     },
1753                     "CachedLogonsCount": {
1754                         "Policy": (
1755                             "Interactive logon: Number of previous "
1756                             "logons to cache (in case domain controller "
1757                             "is not available)"
1758                         ),
1759                         "Settings": {
1760                             "Function": "_in_range_inclusive",
1761                             "Args": {"min": 0, "max": 50},
1762                         },
1763                         "lgpo_section": self.security_options_gpedit_path,
1764                         "Registry": {
1765                             "Hive": "HKEY_LOCAL_MACHINE",
1766                             "Path": (
1767                                 "Software\\Microsoft\\Windows NT\\"
1768                                 "CurrentVersion\\Winlogon"
1769                             ),
1770                             "Value": "CachedLogonsCount",
1771                             "Type": "REG_SZ",
1772                         },
1773                     },
1774                     "ForceUnlockLogon": {
1775                         "Policy": (
1776                             "Interactive logon: Require Domain "
1777                             "Controller authentication to unlock "
1778                             "workstation"
1779                         ),
1780                         "Settings": self.enabled_one_disabled_zero.keys(),
1781                         "lgpo_section": self.security_options_gpedit_path,
1782                         "Registry": {
1783                             "Hive": "HKEY_LOCAL_MACHINE",
1784                             "Path": (
1785                                 "Software\\Microsoft\\Windows NT\\"
1786                                 "CurrentVersion\\Winlogon"
1787                             ),
1788                             "Value": "ForceUnlockLogon",
1789                             "Type": "REG_DWORD",
1790                         },
1791                         "Transform": self.enabled_one_disabled_zero_transform,
1792                     },
1793                     "ScRemoveOption": {
1794                         "Policy": "Interactive logon: Smart card removal behavior",
1795                         "Settings": self.sc_removal_lookup.keys(),
1796                         "lgpo_section": self.security_options_gpedit_path,
1797                         "Registry": {
1798                             "Hive": "HKEY_LOCAL_MACHINE",
1799                             "Path": (
1800                                 "Software\\Microsoft\\Windows NT\\"
1801                                 "CurrentVersion\\Winlogon"
1802                             ),
1803                             "Value": "ScRemoveOption",
1804                             "Type": "REG_SZ",
1805                         },
1806                         "Transform": {
1807                             "Get": "_dict_lookup",
1808                             "Put": "_dict_lookup",
1809                             "GetArgs": {
1810                                 "lookup": self.sc_removal_lookup,
1811                                 "value_lookup": False,
1812                             },
1813                             "PutArgs": {
1814                                 "lookup": self.sc_removal_lookup,
1815                                 "value_lookup": True,
1816                             },
1817                         },
1818                     },
1819                     "DisableCAD": {
1820                         "Policy": "Interactive logon: Do not require CTRL+ALT+DEL",
1821                         "Settings": self.enabled_one_disabled_zero.keys(),
1822                         "lgpo_section": self.security_options_gpedit_path,
1823                         "Registry": {
1824                             "Hive": "HKEY_LOCAL_MACHINE",
1825                             "Path": (
1826                                 "Software\\Microsoft\\Windows\\"
1827                                 "CurrentVersion\\Policies\\System"
1828                             ),
1829                             "Value": "DisableCAD",
1830                             "Type": "REG_DWORD",
1831                         },
1832                         "Transform": self.enabled_one_disabled_zero_transform,
1833                     },
1834                     "FilterAdministratorToken": {
1835                         "Policy": (
1836                             "User Account Control: Admin Approval Mode "
1837                             "for the built-in Administrator account"
1838                         ),
1839                         "Settings": self.enabled_one_disabled_zero.keys(),
1840                         "lgpo_section": self.security_options_gpedit_path,
1841                         "Registry": {
1842                             "Hive": "HKEY_LOCAL_MACHINE",
1843                             "Path": (
1844                                 "Software\\Microsoft\\Windows\\"
1845                                 "CurrentVersion\\Policies\\System"
1846                             ),
1847                             "Value": "FilterAdministratorToken",
1848                             "Type": "REG_DWORD",
1849                         },
1850                         "Transform": self.enabled_one_disabled_zero_transform,
1851                     },
1852                     "EnableUIADesktopToggle": {
1853                         "Policy": (
1854                             "User Account Control: Allow UIAccess "
1855                             "applications to prompt for elevation "
1856                             "without using the secure desktop"
1857                         ),
1858                         "Settings": self.enabled_one_disabled_zero.keys(),
1859                         "lgpo_section": self.security_options_gpedit_path,
1860                         "Registry": {
1861                             "Hive": "HKEY_LOCAL_MACHINE",
1862                             "Path": (
1863                                 "Software\\Microsoft\\Windows\\"
1864                                 "CurrentVersion\\Policies\\System"
1865                             ),
1866                             "Value": "EnableUIADesktopToggle",
1867                             "Type": "REG_DWORD",
1868                         },
1869                         "Transform": self.enabled_one_disabled_zero_transform,
1870                     },
1871                     "ConsentPromptBehaviorAdmin": {
1872                         "Policy": (
1873                             "User Account Control: Behavior of the "
1874                             "elevation prompt for administrators in "
1875                             "Admin Approval Mode"
1876                         ),
1877                         "Settings": self.uac_admin_prompt_lookup.keys(),
1878                         "lgpo_section": self.security_options_gpedit_path,
1879                         "Registry": {
1880                             "Hive": "HKEY_LOCAL_MACHINE",
1881                             "Path": (
1882                                 "Software\\Microsoft\\Windows\\"
1883                                 "CurrentVersion\\Policies\\System"
1884                             ),
1885                             "Value": "ConsentPromptBehaviorAdmin",
1886                             "Type": "REG_DWORD",
1887                         },
1888                         "Transform": {
1889                             "Get": "_dict_lookup",
1890                             "Put": "_dict_lookup",
1891                             "GetArgs": {
1892                                 "lookup": self.uac_admin_prompt_lookup,
1893                                 "value_lookup": False,
1894                             },
1895                             "PutArgs": {
1896                                 "lookup": self.uac_admin_prompt_lookup,
1897                                 "value_lookup": True,
1898                             },
1899                         },
1900                     },
1901                     "ConsentPromptBehaviorUser": {
1902                         "Policy": (
1903                             "User Account Control: Behavior of the "
1904                             "elevation prompt for standard users"
1905                         ),
1906                         "Settings": self.uac_user_prompt_lookup.keys(),
1907                         "lgpo_section": self.security_options_gpedit_path,
1908                         "Registry": {
1909                             "Hive": "HKEY_LOCAL_MACHINE",
1910                             "Path": (
1911                                 "Software\\Microsoft\\Windows\\"
1912                                 "CurrentVersion\\Policies\\System"
1913                             ),
1914                             "Value": "ConsentPromptBehaviorUser",
1915                             "Type": "REG_DWORD",
1916                         },
1917                         "Transform": {
1918                             "Get": "_dict_lookup",
1919                             "Put": "_dict_lookup",
1920                             "GetArgs": {
1921                                 "lookup": self.uac_user_prompt_lookup,
1922                                 "value_lookup": False,
1923                             },
1924                             "PutArgs": {
1925                                 "lookup": self.uac_user_prompt_lookup,
1926                                 "value_lookup": True,
1927                             },
1928                         },
1929                     },
1930                     "EnableInstallerDetection": {
1931                         "Policy": (
1932                             "User Account Control: Detect application "
1933                             "installations and prompt for elevation"
1934                         ),
1935                         "Settings": self.enabled_one_disabled_zero.keys(),
1936                         "lgpo_section": self.security_options_gpedit_path,
1937                         "Registry": {
1938                             "Hive": "HKEY_LOCAL_MACHINE",
1939                             "Path": (
1940                                 "Software\\Microsoft\\Windows\\"
1941                                 "CurrentVersion\\Policies\\System"
1942                             ),
1943                             "Value": "EnableInstallerDetection",
1944                             "Type": "REG_DWORD",
1945                         },
1946                         "Transform": self.enabled_one_disabled_zero_transform,
1947                     },
1948                     "ValidateAdminCodeSignatures": {
1949                         "Policy": (
1950                             "User Account Control: Only elevate "
1951                             "executables that are signed and validated"
1952                         ),
1953                         "Settings": self.enabled_one_disabled_zero.keys(),
1954                         "lgpo_section": self.security_options_gpedit_path,
1955                         "Registry": {
1956                             "Hive": "HKEY_LOCAL_MACHINE",
1957                             "Path": (
1958                                 "Software\\Microsoft\\Windows\\"
1959                                 "CurrentVersion\\Policies\\System"
1960                             ),
1961                             "Value": "ValidateAdminCodeSignatures",
1962                             "Type": "REG_DWORD",
1963                         },
1964                         "Transform": self.enabled_one_disabled_zero_transform,
1965                     },
1966                     "EnableSecureUIAPaths": {
1967                         "Policy": (
1968                             "User Account Control: Only elevate UIAccess "
1969                             "applications that are installed in secure "
1970                             "locations"
1971                         ),
1972                         "Settings": self.enabled_one_disabled_zero.keys(),
1973                         "lgpo_section": self.security_options_gpedit_path,
1974                         "Registry": {
1975                             "Hive": "HKEY_LOCAL_MACHINE",
1976                             "Path": (
1977                                 "Software\\Microsoft\\Windows\\"
1978                                 "CurrentVersion\\Policies\\System"
1979                             ),
1980                             "Value": "EnableSecureUIAPaths",
1981                             "Type": "REG_DWORD",
1982                         },
1983                         "Transform": self.enabled_one_disabled_zero_transform,
1984                     },
1985                     "EnableLUA": {
1986                         "Policy": (
1987                             "User Account Control: Run all "
1988                             "administrators in Admin Approval Mode"
1989                         ),
1990                         "Settings": self.enabled_one_disabled_zero.keys(),
1991                         "lgpo_section": self.security_options_gpedit_path,
1992                         "Registry": {
1993                             "Hive": "HKEY_LOCAL_MACHINE",
1994                             "Path": (
1995                                 "Software\\Microsoft\\Windows\\"
1996                                 "CurrentVersion\\Policies\\System"
1997                             ),
1998                             "Value": "EnableLUA",
1999                             "Type": "REG_DWORD",
2000                         },
2001                         "Transform": self.enabled_one_disabled_zero_transform,
2002                     },
2003                     "PromptOnSecureDesktop": {
2004                         "Policy": (
2005                             "User Account Control: Switch to the secure "
2006                             "desktop when prompting for elevation"
2007                         ),
2008                         "Settings": self.enabled_one_disabled_zero.keys(),
2009                         "lgpo_section": self.security_options_gpedit_path,
2010                         "Registry": {
2011                             "Hive": "HKEY_LOCAL_MACHINE",
2012                             "Path": (
2013                                 "Software\\Microsoft\\Windows\\"
2014                                 "CurrentVersion\\Policies\\System"
2015                             ),
2016                             "Value": "PromptOnSecureDesktop",
2017                             "Type": "REG_DWORD",
2018                         },
2019                         "Transform": self.enabled_one_disabled_zero_transform,
2020                     },
2021                     "EnableVirtualization": {
2022                         "Policy": (
2023                             "User Account Control: Virtualize file and "
2024                             "registry write failures to per-user "
2025                             "locations"
2026                         ),
2027                         "Settings": self.enabled_one_disabled_zero.keys(),
2028                         "lgpo_section": self.security_options_gpedit_path,
2029                         "Registry": {
2030                             "Hive": "HKEY_LOCAL_MACHINE",
2031                             "Path": (
2032                                 "Software\\Microsoft\\Windows\\"
2033                                 "CurrentVersion\\Policies\\System"
2034                             ),
2035                             "Value": "EnableVirtualization",
2036                             "Type": "REG_DWORD",
2037                         },
2038                         "Transform": self.enabled_one_disabled_zero_transform,
2039                     },
2040                     "PasswordExpiryWarning": {
2041                         "Policy": (
2042                             "Interactive logon: Prompt user to change "
2043                             "password before expiration"
2044                         ),
2045                         "Settings": {
2046                             "Function": "_in_range_inclusive",
2047                             "Args": {"min": 0, "max": 999},
2048                         },
2049                         "lgpo_section": self.security_options_gpedit_path,
2050                         "Registry": {
2051                             "Hive": "HKEY_LOCAL_MACHINE",
2052                             "Path": (
2053                                 "Software\\Microsoft\\Windows NT\\"
2054                                 "CurrentVersion\\Winlogon"
2055                             ),
2056                             "Value": "PasswordExpiryWarning",
2057                             "Type": "REG_DWORD",
2058                         },
2059                     },
2060                     "MaxDevicePasswordFailedAttempts": {
2061                         "Policy": (
2062                             "Interactive logon: Machine account lockout threshold"
2063                         ),
2064                         "Settings": {
2065                             "Function": "_in_range_inclusive",
2066                             "Args": {"min": 0, "max": 999},
2067                         },
2068                         "lgpo_section": self.security_options_gpedit_path,
2069                         "Registry": {
2070                             "Hive": "HKEY_LOCAL_MACHINE",
2071                             "Path": (
2072                                 "SOFTWARE\\Microsoft\\Windows\\"
2073                                 "CurrentVersion\\policies\\system"
2074                             ),
2075                             "Value": "MaxDevicePasswordFailedAttempts",
2076                             "Type": "REG_DWORD",
2077                         },
2078                     },
2079                     "InactivityTimeoutSecs": {
2080                         "Policy": "Interactive logon: Machine inactivity limit",
2081                         "Settings": {
2082                             "Function": "_in_range_inclusive",
2083                             "Args": {"min": 0, "max": 599940},
2084                         },
2085                         "lgpo_section": self.security_options_gpedit_path,
2086                         "Registry": {
2087                             "Hive": "HKEY_LOCAL_MACHINE",
2088                             "Path": (
2089                                 "SOFTWARE\\Microsoft\\Windows\\"
2090                                 "CurrentVersion\\policies\\system"
2091                             ),
2092                             "Value": "InactivityTimeoutSecs",
2093                             "Type": "REG_DWORD",
2094                         },
2095                     },
2096                     "legalnoticetext": {
2097                         "Policy": (
2098                             "Interactive logon: Message text for users "
2099                             "attempting to log on"
2100                         ),
2101                         "lgpo_section": self.security_options_gpedit_path,
2102                         "Registry": {
2103                             "Hive": "HKEY_LOCAL_MACHINE",
2104                             "Path": (
2105                                 "SOFTWARE\\Microsoft\\Windows\\"
2106                                 "CurrentVersion\\policies\\system"
2107                             ),
2108                             "Value": "legalnoticetext",
2109                             "Type": "REG_SZ",
2110                         },
2111                         "Transform": {"Put": "_string_put_transform"},
2112                     },
2113                     "legalnoticecaption": {
2114                         "Policy": (
2115                             "Interactive logon: Message title for users "
2116                             "attempting to log on"
2117                         ),
2118                         "lgpo_section": self.security_options_gpedit_path,
2119                         "Registry": {
2120                             "Hive": "HKEY_LOCAL_MACHINE",
2121                             "Path": (
2122                                 "SOFTWARE\\Microsoft\\Windows\\"
2123                                 "CurrentVersion\\policies\\system"
2124                             ),
2125                             "Value": "legalnoticecaption",
2126                             "Type": "REG_SZ",
2127                         },
2128                         "Transform": {"Put": "_string_put_transform"},
2129                     },
2130                     "DontDisplayLockedUserId": {
2131                         "Policy": (
2132                             "Interactive logon: Display user information "
2133                             "when the session is locked"
2134                         ),
2135                         "Settings": self.locked_session_user_info.keys(),
2136                         "lgpo_section": self.security_options_gpedit_path,
2137                         "Registry": {
2138                             "Hive": "HKEY_LOCAL_MACHINE",
2139                             "Path": (
2140                                 "SOFTWARE\\Microsoft\\Windows\\"
2141                                 "CurrentVersion\\policies\\system"
2142                             ),
2143                             "Value": "DontDisplayLockedUserId",
2144                             "Type": "REG_DWORD",
2145                         },
2146                         "Transform": {
2147                             "Get": "_dict_lookup",
2148                             "Put": "_dict_lookup",
2149                             "GetArgs": {
2150                                 "lookup": self.locked_session_user_info,
2151                                 "value_lookup": False,
2152                             },
2153                             "PutArgs": {
2154                                 "lookup": self.locked_session_user_info,
2155                                 "value_lookup": True,
2156                             },
2157                         },
2158                     },
2159                     "ScForceOption": {
2160                         "Policy": "Interactive logon: Require smart card",
2161                         "Settings": self.enabled_one_disabled_zero.keys(),
2162                         "lgpo_section": self.security_options_gpedit_path,
2163                         "Registry": {
2164                             "Hive": "HKEY_LOCAL_MACHINE",
2165                             "Path": (
2166                                 "Software\\Microsoft\\Windows\\"
2167                                 "CurrentVersion\\Policies\\System"
2168                             ),
2169                             "Value": "ScForceOption",
2170                             "Type": "REG_DWORD",
2171                         },
2172                         "Transform": self.enabled_one_disabled_zero_transform,
2173                     },
2174                     "Client_RequireSecuritySignature": {
2175                         "Policy": (
2176                             "Microsoft network client: Digitally sign "
2177                             "communications (always)"
2178                         ),
2179                         "Settings": self.enabled_one_disabled_zero.keys(),
2180                         "lgpo_section": self.security_options_gpedit_path,
2181                         "Registry": {
2182                             "Hive": "HKEY_LOCAL_MACHINE",
2183                             "Path": (
2184                                 "SYSTEM\\CurrentControlSet\\Services\\"
2185                                 "LanmanWorkstation\\Parameters"
2186                             ),
2187                             "Value": "RequireSecuritySignature",
2188                             "Type": "REG_DWORD",
2189                         },
2190                         "Transform": self.enabled_one_disabled_zero_transform,
2191                     },
2192                     "Client_EnableSecuritySignature": {
2193                         "Policy": (
2194                             "Microsoft network client: Digitally sign "
2195                             "communications (if server agrees)"
2196                         ),
2197                         "Settings": self.enabled_one_disabled_zero.keys(),
2198                         "lgpo_section": self.security_options_gpedit_path,
2199                         "Registry": {
2200                             "Hive": "HKEY_LOCAL_MACHINE",
2201                             "Path": (
2202                                 "SYSTEM\\CurrentControlSet\\Services\\"
2203                                 "LanmanWorkstation\\Parameters"
2204                             ),
2205                             "Value": "EnableSecuritySignature",
2206                             "Type": "REG_DWORD",
2207                         },
2208                         "Transform": self.enabled_one_disabled_zero_transform,
2209                     },
2210                     "EnablePlainTextPassword": {
2211                         "Policy": (
2212                             "Microsoft network client: Send unencrypted "
2213                             "password to third-party SMB servers"
2214                         ),
2215                         "Settings": self.enabled_one_disabled_zero.keys(),
2216                         "lgpo_section": self.security_options_gpedit_path,
2217                         "Registry": {
2218                             "Hive": "HKEY_LOCAL_MACHINE",
2219                             "Path": (
2220                                 "SYSTEM\\CurrentControlSet\\Services\\"
2221                                 "LanmanWorkstation\\Parameters"
2222                             ),
2223                             "Value": "EnablePlainTextPassword",
2224                             "Type": "REG_DWORD",
2225                         },
2226                         "Transform": self.enabled_one_disabled_zero_transform,
2227                     },
2228                     "AutoDisconnect": {
2229                         "Policy": (
2230                             "Microsoft network server: Amount of idle "
2231                             "time required before suspending session"
2232                         ),
2233                         "Settings": {
2234                             "Function": "_in_range_inclusive",
2235                             "Args": {"min": 0, "max": 99999},
2236                         },
2237                         "lgpo_section": self.security_options_gpedit_path,
2238                         "Registry": {
2239                             "Hive": "HKEY_LOCAL_MACHINE",
2240                             "Path": (
2241                                 "System\\CurrentControlSet\\Services\\"
2242                                 "LanmanServer\\Parameters"
2243                             ),
2244                             "Value": "AutoDisconnect",
2245                             "Type": "REG_DWORD",
2246                         },
2247                     },
2248                     "EnableS4U2SelfForClaims": {
2249                         "Policy": (
2250                             "Microsoft network server: Attempt S4U2Self "
2251                             "to obtain claim information"
2252                         ),
2253                         "Settings": self.s4u2self_options.keys(),
2254                         "lgpo_section": self.security_options_gpedit_path,
2255                         "Registry": {
2256                             "Hive": "HKEY_LOCAL_MACHINE",
2257                             "Path": (
2258                                 "System\\CurrentControlSet\\Services\\"
2259                                 "LanmanServer\\Parameters"
2260                             ),
2261                             "Value": "EnableS4U2SelfForClaims",
2262                             "Type": "REG_DWORD",
2263                         },
2264                         "Transform": {
2265                             "Get": "_dict_lookup",
2266                             "Put": "_dict_lookup",
2267                             "GetArgs": {
2268                                 "lookup": self.s4u2self_options,
2269                                 "value_lookup": False,
2270                             },
2271                             "PutArgs": {
2272                                 "lookup": self.s4u2self_options,
2273                                 "value_lookup": True,
2274                             },
2275                         },
2276                     },
2277                     "Server_RequireSecuritySignature": {
2278                         "Policy": (
2279                             "Microsoft network server: Digitally sign "
2280                             "communications (always)"
2281                         ),
2282                         "Settings": self.enabled_one_disabled_zero.keys(),
2283                         "lgpo_section": self.security_options_gpedit_path,
2284                         "Registry": {
2285                             "Hive": "HKEY_LOCAL_MACHINE",
2286                             "Path": (
2287                                 "SYSTEM\\CurrentControlSet\\Services\\"
2288                                 "LanmanServer\\Parameters"
2289                             ),
2290                             "Value": "RequireSecuritySignature",
2291                             "Type": "REG_DWORD",
2292                         },
2293                         "Transform": self.enabled_one_disabled_zero_transform,
2294                     },
2295                     "Server_EnableSecuritySignature": {
2296                         "Policy": (
2297                             "Microsoft network server: Digitally sign "
2298                             "communications (if client agrees)"
2299                         ),
2300                         "Settings": self.enabled_one_disabled_zero.keys(),
2301                         "lgpo_section": self.security_options_gpedit_path,
2302                         "Registry": {
2303                             "Hive": "HKEY_LOCAL_MACHINE",
2304                             "Path": (
2305                                 "SYSTEM\\CurrentControlSet\\Services\\"
2306                                 "LanmanServer\\Parameters"
2307                             ),
2308                             "Value": "EnableSecuritySignature",
2309                             "Type": "REG_DWORD",
2310                         },
2311                         "Transform": self.enabled_one_disabled_zero_transform,
2312                     },
2313                     "EnableForcedLogoff": {
2314                         "Policy": (
2315                             "Microsoft network server: Disconnect "
2316                             "clients when logon hours expire"
2317                         ),
2318                         "Settings": self.enabled_one_disabled_zero.keys(),
2319                         "lgpo_section": self.security_options_gpedit_path,
2320                         "Registry": {
2321                             "Hive": "HKEY_LOCAL_MACHINE",
2322                             "Path": (
2323                                 "SYSTEM\\CurrentControlSet\\Services\\"
2324                                 "LanmanServer\\Parameters"
2325                             ),
2326                             "Value": "EnableForcedLogoff",
2327                             "Type": "REG_DWORD",
2328                         },
2329                         "Transform": self.enabled_one_disabled_zero_transform,
2330                     },
2331                     "SmbServerNameHardeningLevel": {
2332                         "Policy": (
2333                             "Microsoft network server: Server SPN target "
2334                             "name validation level"
2335                         ),
2336                         "Settings": self.smb_server_name_hardening_levels.keys(),
2337                         "lgpo_section": self.security_options_gpedit_path,
2338                         "Registry": {
2339                             "Hive": "HKEY_LOCAL_MACHINE",
2340                             "Path": (
2341                                 "System\\CurrentControlSet\\Services\\"
2342                                 "LanmanServer\\Parameters"
2343                             ),
2344                             "Value": "SmbServerNameHardeningLevel",
2345                             "Type": "REG_DWORD",
2346                         },
2347                         "Transform": {
2348                             "Get": "_dict_lookup",
2349                             "Put": "_dict_lookup",
2350                             "GetArgs": {
2351                                 "lookup": self.smb_server_name_hardening_levels,
2352                                 "value_lookup": False,
2353                             },
2354                             "PutArgs": {
2355                                 "lookup": self.smb_server_name_hardening_levels,
2356                                 "value_lookup": True,
2357                             },
2358                         },
2359                     },
2360                     "FullPrivilegeAuditing": {
2361                         "Policy": (
2362                             "Audit: Audit the use of Backup and Restore privilege"
2363                         ),
2364                         "Settings": [chr(0), chr(1)],
2365                         "lgpo_section": self.security_options_gpedit_path,
2366                         "Registry": {
2367                             "Hive": "HKEY_LOCAL_MACHINE",
2368                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2369                             "Value": "FullPrivilegeAuditing",
2370                             "Type": "REG_BINARY",
2371                         },
2372                         "Transform": {
2373                             "Get": "_binary_enable_zero_disable_one_conversion",
2374                             "Put": "_binary_enable_zero_disable_one_reverse_conversion",
2375                         },
2376                     },
2377                     "CrashOnAuditFail": {
2378                         "Policy": (
2379                             "Audit: Shut down system immediately if "
2380                             "unable to log security audits"
2381                         ),
2382                         "Settings": self.enabled_one_disabled_zero.keys(),
2383                         "lgpo_section": self.security_options_gpedit_path,
2384                         "Registry": {
2385                             "Hive": "HKEY_LOCAL_MACHINE",
2386                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
2387                             "Value": "CrashOnAuditFail",
2388                             "Type": "REG_DWORD",
2389                         },
2390                         "Transform": self.enabled_one_disabled_zero_transform,
2391                     },
2392                     "UndockWithoutLogon": {
2393                         "Policy": "Devices: Allow undock without having to log on",
2394                         "Settings": self.enabled_one_disabled_zero.keys(),
2395                         "lgpo_section": self.security_options_gpedit_path,
2396                         "Registry": {
2397                             "Hive": "HKEY_LOCAL_MACHINE",
2398                             "Path": (
2399                                 "Software\\Microsoft\\Windows\\"
2400                                 "CurrentVersion\\Policies\\System"
2401                             ),
2402                             "Value": "UndockWithoutLogon",
2403                             "Type": "REG_DWORD",
2404                         },
2405                         "Transform": self.enabled_one_disabled_zero_transform,
2406                     },
2407                     "AddPrinterDrivers": {
2408                         "Policy": (
2409                             "Devices: Prevent users from installing printer drivers"
2410                         ),
2411                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2412                         "lgpo_section": self.security_options_gpedit_path,
2413                         "Registry": {
2414                             "Hive": "HKEY_LOCAL_MACHINE",
2415                             "Path": (
2416                                 "System\\CurrentControlSet\\Control\\"
2417                                 "Print\\Providers\\LanMan Print Services\\"
2418                                 "Servers"
2419                             ),
2420                             "Value": "AddPrinterDrivers",
2421                             "Type": "REG_DWORD",
2422                         },
2423                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2424                     },
2425                     "AllocateDASD": {
2426                         "Policy": (
2427                             "Devices: Allowed to format and eject removable media"
2428                         ),
2429                         "Settings": ["9999", "0", "1", "2"],
2430                         "lgpo_section": self.security_options_gpedit_path,
2431                         "Registry": {
2432                             "Hive": "HKEY_LOCAL_MACHINE",
2433                             "Path": (
2434                                 "Software\\Microsoft\\Windows NT\\"
2435                                 "CurrentVersion\\Winlogon"
2436                             ),
2437                             "Value": "AllocateDASD",
2438                             "Type": "REG_SZ",
2439                         },
2440                         "Transform": {
2441                             "Get": "_dasd_conversion",
2442                             "Put": "_dasd_reverse_conversion",
2443                         },
2444                     },
2445                     "AllocateCDRoms": {
2446                         "Policy": (
2447                             "Devices: Restrict CD-ROM access to locally "
2448                             "logged-on user only"
2449                         ),
2450                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2451                         "lgpo_section": self.security_options_gpedit_path,
2452                         "Registry": {
2453                             "Hive": "HKEY_LOCAL_MACHINE",
2454                             "Path": (
2455                                 "Software\\Microsoft\\Windows NT\\"
2456                                 "CurrentVersion\\Winlogon"
2457                             ),
2458                             "Value": "AllocateCDRoms",
2459                             "Type": "REG_SZ",
2460                         },
2461                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2462                     },
2463                     "AllocateFloppies": {
2464                         "Policy": (
2465                             "Devices: Restrict floppy access to locally "
2466                             "logged-on user only"
2467                         ),
2468                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2469                         "lgpo_section": self.security_options_gpedit_path,
2470                         "Registry": {
2471                             "Hive": "HKEY_LOCAL_MACHINE",
2472                             "Path": (
2473                                 "Software\\Microsoft\\Windows NT\\"
2474                                 "CurrentVersion\\Winlogon"
2475                             ),
2476                             "Value": "AllocateFloppies",
2477                             "Type": "REG_SZ",
2478                         },
2479                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2480                     },
2481                     "DriverSigningPolicy": {
2482                         "Policy": "Devices: Unsigned driver installation behavior",
2483                         "Settings": ["3,0", "3," + chr(1), "3," + chr(2)],
2484                         "lgpo_section": self.security_options_gpedit_path,
2485                         "Secedit": {
2486                             "Option": (
2487                                 "MACHINE\\Software\\Microsoft\\Driver Signing\\Policy"
2488                             ),
2489                             "Section": "Registry Values",
2490                         },
2491                         "Transform": {
2492                             "Get": "_driver_signing_reg_conversion",
2493                             "Put": "_driver_signing_reg_reverse_conversion",
2494                         },
2495                     },
2496                     "SubmitControl": {
2497                         "Policy": (
2498                             "Domain controller: Allow server operators "
2499                             "to schedule tasks"
2500                         ),
2501                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2502                         "lgpo_section": self.security_options_gpedit_path,
2503                         "Registry": {
2504                             "Hive": "HKEY_LOCAL_MACHINE",
2505                             "Path": "System\\CurrentControlSet\\Control\\Lsa",
2506                             "Value": "SubmitControl",
2507                             "Type": "REG_DWORD",
2508                         },
2509                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2510                     },
2511                     "LDAPServerIntegrity": {
2512                         "Policy": "Domain controller: LDAP server signing requirements",
2513                         "Settings": self.ldap_server_signing_requirements.keys(),
2514                         "lgpo_section": self.security_options_gpedit_path,
2515                         "Registry": {
2516                             "Hive": "HKEY_LOCAL_MACHINE",
2517                             "Path": (
2518                                 "System\\CurrentControlSet\\Services\\NTDS\\Parameters"
2519                             ),
2520                             "Value": "LDAPServerIntegrity",
2521                             "Type": "REG_DWORD",
2522                         },
2523                         "Transform": {
2524                             "Get": "_dict_lookup",
2525                             "Put": "_dict_lookup",
2526                             "GetArgs": {
2527                                 "lookup": self.ldap_server_signing_requirements,
2528                                 "value_lookup": False,
2529                             },
2530                             "PutArgs": {
2531                                 "lookup": self.ldap_server_signing_requirements,
2532                                 "value_lookup": True,
2533                             },
2534                         },
2535                     },
2536                     "RefusePasswordChange": {
2537                         "Policy": (
2538                             "Domain controller: Refuse machine account password changes"
2539                         ),
2540                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2541                         "lgpo_section": self.security_options_gpedit_path,
2542                         "Registry": {
2543                             "Hive": "HKEY_LOCAL_MACHINE",
2544                             "Path": (
2545                                 "SYSTEM\\CurrentControlSet\\Services\\"
2546                                 "Netlogon\\Parameters"
2547                             ),
2548                             "Value": "RefusePasswordChange",
2549                             "Type": "REG_DWORD",
2550                         },
2551                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2552                     },
2553                     "RequireSignOrSeal": {
2554                         "Policy": (
2555                             "Domain member: Digitally encrypt or sign "
2556                             "secure channel data (always)"
2557                         ),
2558                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2559                         "lgpo_section": self.security_options_gpedit_path,
2560                         "Registry": {
2561                             "Hive": "HKEY_LOCAL_MACHINE",
2562                             "Path": (
2563                                 "System\\CurrentControlSet\\Services\\"
2564                                 "Netlogon\\Parameters"
2565                             ),
2566                             "Value": "RequireSignOrSeal",
2567                             "Type": "REG_DWORD",
2568                         },
2569                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2570                     },
2571                     "SealSecureChannel": {
2572                         "Policy": (
2573                             "Domain member: Digitally encrypt secure "
2574                             "channel data (when possible)"
2575                         ),
2576                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2577                         "lgpo_section": self.security_options_gpedit_path,
2578                         "Registry": {
2579                             "Hive": "HKEY_LOCAL_MACHINE",
2580                             "Path": (
2581                                 "System\\CurrentControlSet\\Services\\"
2582                                 "Netlogon\\Parameters"
2583                             ),
2584                             "Value": "SealSecureChannel",
2585                             "Type": "REG_DWORD",
2586                         },
2587                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2588                     },
2589                     "SignSecureChannel": {
2590                         "Policy": (
2591                             "Domain member: Digitally sign secure "
2592                             "channel data (when possible)"
2593                         ),
2594                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2595                         "lgpo_section": self.security_options_gpedit_path,
2596                         "Registry": {
2597                             "Hive": "HKEY_LOCAL_MACHINE",
2598                             "Path": (
2599                                 "System\\CurrentControlSet\\Services\\"
2600                                 "Netlogon\\Parameters"
2601                             ),
2602                             "Value": "SignSecureChannel",
2603                             "Type": "REG_DWORD",
2604                         },
2605                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2606                     },
2607                     "DisablePasswordChange": {
2608                         "Policy": (
2609                             "Domain member: Disable machine account password changes"
2610                         ),
2611                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2612                         "lgpo_section": self.security_options_gpedit_path,
2613                         "Registry": {
2614                             "Hive": "HKEY_LOCAL_MACHINE",
2615                             "Path": (
2616                                 "System\\CurrentControlSet\\Services\\"
2617                                 "Netlogon\\Parameters"
2618                             ),
2619                             "Value": "DisablePasswordChange",
2620                             "Type": "REG_DWORD",
2621                         },
2622                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2623                     },
2624                     "MaximumPasswordAge": {
2625                         "Policy": "Domain member: Maximum machine account password age",
2626                         "Settings": {
2627                             "Function": "_in_range_inclusive",
2628                             "Args": {"min": 0, "max": 999},
2629                         },
2630                         "lgpo_section": self.security_options_gpedit_path,
2631                         "Registry": {
2632                             "Hive": "HKEY_LOCAL_MACHINE",
2633                             "Path": (
2634                                 "System\\CurrentControlSet\\Services\\"
2635                                 "Netlogon\\Parameters"
2636                             ),
2637                             "Value": "MaximumPasswordAge",
2638                             "Type": "REG_DWORD",
2639                         },
2640                     },
2641                     "RequireStrongKey": {
2642                         "Policy": (
2643                             "Domain member: Require strong (Windows 2000 "
2644                             "or later) session key"
2645                         ),
2646                         "Settings": self.enabled_one_disabled_zero_strings.keys(),
2647                         "lgpo_section": self.security_options_gpedit_path,
2648                         "Registry": {
2649                             "Hive": "HKEY_LOCAL_MACHINE",
2650                             "Path": (
2651                                 "System\\CurrentControlSet\\Services\\"
2652                                 "Netlogon\\Parameters"
2653                             ),
2654                             "Value": "RequireStrongKey",
2655                             "Type": "REG_DWORD",
2656                         },
2657                         "Transform": self.enabled_one_disabled_zero_strings_transform,
2658                     },
2659                     "LockoutDuration": {
2660                         "Policy": "Account lockout duration",
2661                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2662                         "Settings": {
2663                             "Function": "_in_range_inclusive",
2664                             "Args": {
2665                                 "min": 0,
2666                                 "max": 6000000,
2667                                 "zero_value": 0xFFFFFFFF,
2668                             },
2669                         },
2670                         "NetUserModal": {"Modal": 3, "Option": "lockout_duration"},
2671                         "Transform": {
2672                             "Get": "_seconds_to_minutes",
2673                             "Put": "_minutes_to_seconds",
2674                             "GetArgs": {"zero_value": 0xFFFFFFFF},
2675                             "PutArgs": {"zero_value": 0xFFFFFFFF},
2676                         },
2677                     },
2678                     "LockoutThreshold": {
2679                         "Policy": "Account lockout threshold",
2680                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2681                         "Settings": {
2682                             "Function": "_in_range_inclusive",
2683                             "Args": {"min": 0, "max": 1000},
2684                         },
2685                         "NetUserModal": {"Modal": 3, "Option": "lockout_threshold"},
2686                     },
2687                     "LockoutWindow": {
2688                         "Policy": "Reset account lockout counter after",
2689                         "lgpo_section": self.account_lockout_policy_gpedit_path,
2690                         "Settings": {
2691                             "Function": "_in_range_inclusive",
2692                             "Args": {"min": 0, "max": 6000000},
2693                         },
2694                         "NetUserModal": {
2695                             "Modal": 3,
2696                             "Option": "lockout_observation_window",
2697                         },
2698                         "Transform": {
2699                             "Get": "_seconds_to_minutes",
2700                             "Put": "_minutes_to_seconds",
2701                         },
2702                     },
2703                     "AuditAccountLogon": {
2704                         "Policy": "Audit account logon events",
2705                         "lgpo_section": self.audit_policy_gpedit_path,
2706                         "Settings": self.audit_lookup.keys(),
2707                         "Secedit": {
2708                             "Option": "AuditAccountLogon",
2709                             "Section": "Event Audit",
2710                         },
2711                         "Transform": self.audit_transform,
2712                     },
2713                     "AuditAccountManage": {
2714                         "Policy": "Audit account management",
2715                         "lgpo_section": self.audit_policy_gpedit_path,
2716                         "Settings": self.audit_lookup.keys(),
2717                         "Secedit": {
2718                             "Option": "AuditAccountManage",
2719                             "Section": "Event Audit",
2720                         },
2721                         "Transform": self.audit_transform,
2722                     },
2723                     "AuditDSAccess": {
2724                         "Policy": "Audit directory service access",
2725                         "lgpo_section": self.audit_policy_gpedit_path,
2726                         "Settings": self.audit_lookup.keys(),
2727                         "Secedit": {
2728                             "Option": "AuditDSAccess",
2729                             "Section": "Event Audit",
2730                         },
2731                         "Transform": self.audit_transform,
2732                     },
2733                     "AuditLogonEvents": {
2734                         "Policy": "Audit logon events",
2735                         "lgpo_section": self.audit_policy_gpedit_path,
2736                         "Settings": self.audit_lookup.keys(),
2737                         "Secedit": {
2738                             "Option": "AuditLogonEvents",
2739                             "Section": "Event Audit",
2740                         },
2741                         "Transform": self.audit_transform,
2742                     },
2743                     "AuditObjectAccess": {
2744                         "Policy": "Audit object access",
2745                         "lgpo_section": self.audit_policy_gpedit_path,
2746                         "Settings": self.audit_lookup.keys(),
2747                         "Secedit": {
2748                             "Option": "AuditObjectAccess",
2749                             "Section": "Event Audit",
2750                         },
2751                         "Transform": self.audit_transform,
2752                     },
2753                     "AuditPolicyChange": {
2754                         "Policy": "Audit policy change",
2755                         "lgpo_section": self.audit_policy_gpedit_path,
2756                         "Settings": self.audit_lookup.keys(),
2757                         "Secedit": {
2758                             "Option": "AuditPolicyChange",
2759                             "Section": "Event Audit",
2760                         },
2761                         "Transform": self.audit_transform,
2762                     },
2763                     "AuditPrivilegeUse": {
2764                         "Policy": "Audit privilege use",
2765                         "lgpo_section": self.audit_policy_gpedit_path,
2766                         "Settings": self.audit_lookup.keys(),
2767                         "Secedit": {
2768                             "Option": "AuditPrivilegeUse",
2769                             "Section": "Event Audit",
2770                         },
2771                         "Transform": self.audit_transform,
2772                     },
2773                     "AuditProcessTracking": {
2774                         "Policy": "Audit process tracking",
2775                         "lgpo_section": self.audit_policy_gpedit_path,
2776                         "Settings": self.audit_lookup.keys(),
2777                         "Secedit": {
2778                             "Option": "AuditProcessTracking",
2779                             "Section": "Event Audit",
2780                         },
2781                         "Transform": self.audit_transform,
2782                     },
2783                     "AuditSystemEvents": {
2784                         "Policy": "Audit system events",
2785                         "lgpo_section": self.audit_policy_gpedit_path,
2786                         "Settings": self.audit_lookup.keys(),
2787                         "Secedit": {
2788                             "Option": "AuditSystemEvents",
2789                             "Section": "Event Audit",
2790                         },
2791                         "Transform": self.audit_transform,
2792                     },
2793                     "AuditCredentialValidation": {
2794                         "Policy": "Audit Credential Validation",
2795                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2796                         "Settings": self.advanced_audit_lookup.keys(),
2797                         "AdvAudit": {"Option": "Audit Credential Validation"},
2798                         "Transform": self.advanced_audit_transform,
2799                     },
2800                     "AuditKerberosAuthenticationService": {
2801                         "Policy": "Audit Kerberos Authentication Service",
2802                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2803                         "Settings": self.advanced_audit_lookup.keys(),
2804                         "AdvAudit": {
2805                             "Option": "Audit Kerberos Authentication Service",
2806                         },
2807                         "Transform": self.advanced_audit_transform,
2808                     },
2809                     "AuditKerberosServiceTicketOperations": {
2810                         "Policy": "Audit Kerberos Service Ticket Operations",
2811                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2812                         "Settings": self.advanced_audit_lookup.keys(),
2813                         "AdvAudit": {
2814                             "Option": "Audit Kerberos Service Ticket Operations",
2815                         },
2816                         "Transform": self.advanced_audit_transform,
2817                     },
2818                     "AuditOtherAccountLogonEvents": {
2819                         "Policy": "Audit Other Account Logon Events",
2820                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2821                         "Settings": self.advanced_audit_lookup.keys(),
2822                         "AdvAudit": {"Option": "Audit Other Account Logon Events"},
2823                         "Transform": self.advanced_audit_transform,
2824                     },
2825                     "AuditApplicationGroupManagement": {
2826                         "Policy": "Audit Application Group Management",
2827                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2828                         "Settings": self.advanced_audit_lookup.keys(),
2829                         "AdvAudit": {"Option": "Audit Application Group Management"},
2830                         "Transform": self.advanced_audit_transform,
2831                     },
2832                     "AuditComputerAccountManagement": {
2833                         "Policy": "Audit Computer Account Management",
2834                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2835                         "Settings": self.advanced_audit_lookup.keys(),
2836                         "AdvAudit": {"Option": "Audit Computer Account Management"},
2837                         "Transform": self.advanced_audit_transform,
2838                     },
2839                     "AuditDistributionGroupManagement": {
2840                         "Policy": "Audit Distribution Group Management",
2841                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2842                         "Settings": self.advanced_audit_lookup.keys(),
2843                         "AdvAudit": {"Option": "Audit Distribution Group Management"},
2844                         "Transform": self.advanced_audit_transform,
2845                     },
2846                     "AuditOtherAccountManagementEvents": {
2847                         "Policy": "Audit Other Account Management Events",
2848                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2849                         "Settings": self.advanced_audit_lookup.keys(),
2850                         "AdvAudit": {
2851                             "Option": "Audit Other Account Management Events",
2852                         },
2853                         "Transform": self.advanced_audit_transform,
2854                     },
2855                     "AuditSecurityGroupManagement": {
2856                         "Policy": "Audit Security Group Management",
2857                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2858                         "Settings": self.advanced_audit_lookup.keys(),
2859                         "AdvAudit": {"Option": "Audit Security Group Management"},
2860                         "Transform": self.advanced_audit_transform,
2861                     },
2862                     "AuditUserAccountManagement": {
2863                         "Policy": "Audit User Account Management",
2864                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2865                         "Settings": self.advanced_audit_lookup.keys(),
2866                         "AdvAudit": {"Option": "Audit User Account Management"},
2867                         "Transform": self.advanced_audit_transform,
2868                     },
2869                     "AuditDPAPIActivity": {
2870                         "Policy": "Audit DPAPI Activity",
2871                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2872                         "Settings": self.advanced_audit_lookup.keys(),
2873                         "AdvAudit": {"Option": "Audit DPAPI Activity"},
2874                         "Transform": self.advanced_audit_transform,
2875                     },
2876                     "AuditPNPActivity": {
2877                         "Policy": "Audit PNP Activity",
2878                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2879                         "Settings": self.advanced_audit_lookup.keys(),
2880                         "AdvAudit": {"Option": "Audit PNP Activity"},
2881                         "Transform": self.advanced_audit_transform,
2882                     },
2883                     "AuditProcessCreation": {
2884                         "Policy": "Audit Process Creation",
2885                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2886                         "Settings": self.advanced_audit_lookup.keys(),
2887                         "AdvAudit": {"Option": "Audit Process Creation"},
2888                         "Transform": self.advanced_audit_transform,
2889                     },
2890                     "AuditProcessTermination": {
2891                         "Policy": "Audit Process Termination",
2892                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2893                         "Settings": self.advanced_audit_lookup.keys(),
2894                         "AdvAudit": {"Option": "Audit Process Termination"},
2895                         "Transform": self.advanced_audit_transform,
2896                     },
2897                     "AuditRPCEvents": {
2898                         "Policy": "Audit RPC Events",
2899                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2900                         "Settings": self.advanced_audit_lookup.keys(),
2901                         "AdvAudit": {"Option": "Audit RPC Events"},
2902                         "Transform": self.advanced_audit_transform,
2903                     },
2904                     "AuditTokenRightAdjusted": {
2905                         "Policy": "Audit Token Right Adjusted",
2906                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2907                         "Settings": self.advanced_audit_lookup.keys(),
2908                         "AdvAudit": {"Option": "Audit Token Right Adjusted"},
2909                         "Transform": self.advanced_audit_transform,
2910                     },
2911                     "AuditDetailedDirectoryServiceReplication": {
2912                         "Policy": "Audit Detailed Directory Service Replication",
2913                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2914                         "Settings": self.advanced_audit_lookup.keys(),
2915                         "AdvAudit": {
2916                             "Option": "Audit Detailed Directory Service Replication",
2917                         },
2918                         "Transform": self.advanced_audit_transform,
2919                     },
2920                     "AuditDirectoryServiceAccess": {
2921                         "Policy": "Audit Directory Service Access",
2922                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2923                         "Settings": self.advanced_audit_lookup.keys(),
2924                         "AdvAudit": {"Option": "Audit Directory Service Access"},
2925                         "Transform": self.advanced_audit_transform,
2926                     },
2927                     "AuditDirectoryServiceChanges": {
2928                         "Policy": "Audit Directory Service Changes",
2929                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2930                         "Settings": self.advanced_audit_lookup.keys(),
2931                         "AdvAudit": {"Option": "Audit Directory Service Changes"},
2932                         "Transform": self.advanced_audit_transform,
2933                     },
2934                     "AuditDirectoryServiceReplication": {
2935                         "Policy": "Audit Directory Service Replication",
2936                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2937                         "Settings": self.advanced_audit_lookup.keys(),
2938                         "AdvAudit": {"Option": "Audit Directory Service Replication"},
2939                         "Transform": self.advanced_audit_transform,
2940                     },
2941                     "AuditAccountLockout": {
2942                         "Policy": "Audit Account Lockout",
2943                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2944                         "Settings": self.advanced_audit_lookup.keys(),
2945                         "AdvAudit": {"Option": "Audit Account Lockout"},
2946                         "Transform": self.advanced_audit_transform,
2947                     },
2948                     "AuditUserDeviceClaims": {
2949                         "Policy": "Audit User / Device Claims",
2950                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2951                         "Settings": self.advanced_audit_lookup.keys(),
2952                         "AdvAudit": {"Option": "Audit User / Device Claims"},
2953                         "Transform": self.advanced_audit_transform,
2954                     },
2955                     "AuditGroupMembership": {
2956                         "Policy": "Audit Group Membership",
2957                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2958                         "Settings": self.advanced_audit_lookup.keys(),
2959                         "AdvAudit": {"Option": "Audit Group Membership"},
2960                         "Transform": self.advanced_audit_transform,
2961                     },
2962                     "AuditIPsecExtendedMode": {
2963                         "Policy": "Audit IPsec Extended Mode",
2964                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2965                         "Settings": self.advanced_audit_lookup.keys(),
2966                         "AdvAudit": {"Option": "Audit IPsec Extended Mode"},
2967                         "Transform": self.advanced_audit_transform,
2968                     },
2969                     "AuditIPsecMainMode": {
2970                         "Policy": "Audit IPsec Main Mode",
2971                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2972                         "Settings": self.advanced_audit_lookup.keys(),
2973                         "AdvAudit": {"Option": "Audit IPsec Main Mode"},
2974                         "Transform": self.advanced_audit_transform,
2975                     },
2976                     "AuditIPsecQuickMode": {
2977                         "Policy": "Audit IPsec Quick Mode",
2978                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2979                         "Settings": self.advanced_audit_lookup.keys(),
2980                         "AdvAudit": {"Option": "Audit IPsec Quick Mode"},
2981                         "Transform": self.advanced_audit_transform,
2982                     },
2983                     "AuditLogoff": {
2984                         "Policy": "Audit Logoff",
2985                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2986                         "Settings": self.advanced_audit_lookup.keys(),
2987                         "AdvAudit": {"Option": "Audit Logoff"},
2988                         "Transform": self.advanced_audit_transform,
2989                     },
2990                     "AuditLogon": {
2991                         "Policy": "Audit Logon",
2992                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
2993                         "Settings": self.advanced_audit_lookup.keys(),
2994                         "AdvAudit": {"Option": "Audit Logon"},
2995                         "Transform": self.advanced_audit_transform,
2996                     },
2997                     "AuditNetworkPolicyServer": {
2998                         "Policy": "Audit Network Policy Server",
2999                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3000                         "Settings": self.advanced_audit_lookup.keys(),
3001                         "AdvAudit": {"Option": "Audit Network Policy Server"},
3002                         "Transform": self.advanced_audit_transform,
3003                     },
3004                     "AuditOtherLogonLogoffEvents": {
3005                         "Policy": "Audit Other Logon/Logoff Events",
3006                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3007                         "Settings": self.advanced_audit_lookup.keys(),
3008                         "AdvAudit": {"Option": "Audit Other Logon/Logoff Events"},
3009                         "Transform": self.advanced_audit_transform,
3010                     },
3011                     "AuditSpecialLogon": {
3012                         "Policy": "Audit Special Logon",
3013                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3014                         "Settings": self.advanced_audit_lookup.keys(),
3015                         "AdvAudit": {"Option": "Audit Special Logon"},
3016                         "Transform": self.advanced_audit_transform,
3017                     },
3018                     "AuditApplicationGenerated": {
3019                         "Policy": "Audit Application Generated",
3020                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3021                         "Settings": self.advanced_audit_lookup.keys(),
3022                         "AdvAudit": {"Option": "Audit Application Generated"},
3023                         "Transform": self.advanced_audit_transform,
3024                     },
3025                     "AuditCertificationServices": {
3026                         "Policy": "Audit Certification Services",
3027                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3028                         "Settings": self.advanced_audit_lookup.keys(),
3029                         "AdvAudit": {"Option": "Audit Certification Services"},
3030                         "Transform": self.advanced_audit_transform,
3031                     },
3032                     "AuditDetailedFileShare": {
3033                         "Policy": "Audit Detailed File Share",
3034                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3035                         "Settings": self.advanced_audit_lookup.keys(),
3036                         "AdvAudit": {"Option": "Audit Detailed File Share"},
3037                         "Transform": self.advanced_audit_transform,
3038                     },
3039                     "AuditFileShare": {
3040                         "Policy": "Audit File Share",
3041                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3042                         "Settings": self.advanced_audit_lookup.keys(),
3043                         "AdvAudit": {"Option": "Audit File Share"},
3044                         "Transform": self.advanced_audit_transform,
3045                     },
3046                     "AuditFileSystem": {
3047                         "Policy": "Audit File System",
3048                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3049                         "Settings": self.advanced_audit_lookup.keys(),
3050                         "AdvAudit": {"Option": "Audit File System"},
3051                         "Transform": self.advanced_audit_transform,
3052                     },
3053                     "AuditFilteringPlatformConnection": {
3054                         "Policy": "Audit Filtering Platform Connection",
3055                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3056                         "Settings": self.advanced_audit_lookup.keys(),
3057                         "AdvAudit": {"Option": "Audit Filtering Platform Connection"},
3058                         "Transform": self.advanced_audit_transform,
3059                     },
3060                     "AuditFilteringPlatformPacketDrop": {
3061                         "Policy": "Audit Filtering Platform Packet Drop",
3062                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3063                         "Settings": self.advanced_audit_lookup.keys(),
3064                         "AdvAudit": {"Option": "Audit Filtering Platform Packet Drop"},
3065                         "Transform": self.advanced_audit_transform,
3066                     },
3067                     "AuditHandleManipulation": {
3068                         "Policy": "Audit Handle Manipulation",
3069                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3070                         "Settings": self.advanced_audit_lookup.keys(),
3071                         "AdvAudit": {"Option": "Audit Handle Manipulation"},
3072                         "Transform": self.advanced_audit_transform,
3073                     },
3074                     "AuditKernelObject": {
3075                         "Policy": "Audit Kernel Object",
3076                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3077                         "Settings": self.advanced_audit_lookup.keys(),
3078                         "AdvAudit": {"Option": "Audit Kernel Object"},
3079                         "Transform": self.advanced_audit_transform,
3080                     },
3081                     "AuditOtherObjectAccessEvents": {
3082                         "Policy": "Audit Other Object Access Events",
3083                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3084                         "Settings": self.advanced_audit_lookup.keys(),
3085                         "AdvAudit": {"Option": "Audit Other Object Access Events"},
3086                         "Transform": self.advanced_audit_transform,
3087                     },
3088                     "AuditRegistry": {
3089                         "Policy": "Audit Registry",
3090                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3091                         "Settings": self.advanced_audit_lookup.keys(),
3092                         "AdvAudit": {"Option": "Audit Registry"},
3093                         "Transform": self.advanced_audit_transform,
3094                     },
3095                     "AuditRemovableStorage": {
3096                         "Policy": "Audit Removable Storage",
3097                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3098                         "Settings": self.advanced_audit_lookup.keys(),
3099                         "AdvAudit": {"Option": "Audit Removable Storage"},
3100                         "Transform": self.advanced_audit_transform,
3101                     },
3102                     "AuditSAM": {
3103                         "Policy": "Audit SAM",
3104                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3105                         "Settings": self.advanced_audit_lookup.keys(),
3106                         "AdvAudit": {"Option": "Audit SAM"},
3107                         "Transform": self.advanced_audit_transform,
3108                     },
3109                     "AuditCentralAccessPolicyStaging": {
3110                         "Policy": "Audit Central Access Policy Staging",
3111                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3112                         "Settings": self.advanced_audit_lookup.keys(),
3113                         "AdvAudit": {"Option": "Audit Central Access Policy Staging"},
3114                         "Transform": self.advanced_audit_transform,
3115                     },
3116                     "AuditAuditPolicyChange": {
3117                         "Policy": "Audit Audit Policy Change",
3118                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3119                         "Settings": self.advanced_audit_lookup.keys(),
3120                         "AdvAudit": {"Option": "Audit Audit Policy Change"},
3121                         "Transform": self.advanced_audit_transform,
3122                     },
3123                     "AuditAuthenticationPolicyChange": {
3124                         "Policy": "Audit Authentication Policy Change",
3125                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3126                         "Settings": self.advanced_audit_lookup.keys(),
3127                         "AdvAudit": {"Option": "Audit Authentication Policy Change"},
3128                         "Transform": self.advanced_audit_transform,
3129                     },
3130                     "AuditAuthorizationPolicyChange": {
3131                         "Policy": "Audit Authorization Policy Change",
3132                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3133                         "Settings": self.advanced_audit_lookup.keys(),
3134                         "AdvAudit": {"Option": "Audit Authorization Policy Change"},
3135                         "Transform": self.advanced_audit_transform,
3136                     },
3137                     "AuditFilteringPlatformPolicyChange": {
3138                         "Policy": "Audit Filtering Platform Policy Change",
3139                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3140                         "Settings": self.advanced_audit_lookup.keys(),
3141                         "AdvAudit": {
3142                             "Option": "Audit Filtering Platform Policy Change",
3143                         },
3144                         "Transform": self.advanced_audit_transform,
3145                     },
3146                     "AuditMPSSVCRuleLevelPolicyChange": {
3147                         "Policy": "Audit MPSSVC Rule-Level Policy Change",
3148                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3149                         "Settings": self.advanced_audit_lookup.keys(),
3150                         "AdvAudit": {
3151                             "Option": "Audit MPSSVC Rule-Level Policy Change",
3152                         },
3153                         "Transform": self.advanced_audit_transform,
3154                     },
3155                     "AuditOtherPolicyChangeEvents": {
3156                         "Policy": "Audit Other Policy Change Events",
3157                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3158                         "Settings": self.advanced_audit_lookup.keys(),
3159                         "AdvAudit": {"Option": "Audit Other Policy Change Events"},
3160                         "Transform": self.advanced_audit_transform,
3161                     },
3162                     "AuditNonSensitivePrivilegeUse": {
3163                         "Policy": "Audit Non Sensitive Privilege Use",
3164                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3165                         "Settings": self.advanced_audit_lookup.keys(),
3166                         "AdvAudit": {"Option": "Audit Non Sensitive Privilege Use"},
3167                         "Transform": self.advanced_audit_transform,
3168                     },
3169                     "AuditOtherPrivilegeUseEvents": {
3170                         "Policy": "Audit Other Privilege Use Events",
3171                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3172                         "Settings": self.advanced_audit_lookup.keys(),
3173                         "AdvAudit": {"Option": "Audit Other Privilege Use Events"},
3174                         "Transform": self.advanced_audit_transform,
3175                     },
3176                     "AuditSensitivePrivilegeUse": {
3177                         "Policy": "Audit Sensitive Privilege Use",
3178                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3179                         "Settings": self.advanced_audit_lookup.keys(),
3180                         "AdvAudit": {"Option": "Audit Sensitive Privilege Use"},
3181                         "Transform": self.advanced_audit_transform,
3182                     },
3183                     "AuditIPsecDriver": {
3184                         "Policy": "Audit IPsec Driver",
3185                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3186                         "Settings": self.advanced_audit_lookup.keys(),
3187                         "AdvAudit": {"Option": "Audit IPsec Driver"},
3188                         "Transform": self.advanced_audit_transform,
3189                     },
3190                     "AuditOtherSystemEvents": {
3191                         "Policy": "Audit Other System Events",
3192                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3193                         "Settings": self.advanced_audit_lookup.keys(),
3194                         "AdvAudit": {"Option": "Audit Other System Events"},
3195                         "Transform": self.advanced_audit_transform,
3196                     },
3197                     "AuditSecurityStateChange": {
3198                         "Policy": "Audit Security State Change",
3199                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3200                         "Settings": self.advanced_audit_lookup.keys(),
3201                         "AdvAudit": {"Option": "Audit Security State Change"},
3202                         "Transform": self.advanced_audit_transform,
3203                     },
3204                     "AuditSecuritySystemExtension": {
3205                         "Policy": "Audit Security System Extension",
3206                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3207                         "Settings": self.advanced_audit_lookup.keys(),
3208                         "AdvAudit": {"Option": "Audit Security System Extension"},
3209                         "Transform": self.advanced_audit_transform,
3210                     },
3211                     "AuditSystemIntegrity": {
3212                         "Policy": "Audit System Integrity",
3213                         "lgpo_section": self.advanced_audit_policy_gpedit_path,
3214                         "Settings": self.advanced_audit_lookup.keys(),
3215                         "AdvAudit": {"Option": "Audit System Integrity"},
3216                         "Transform": self.advanced_audit_transform,
3217                     },
3218                     "SeTrustedCredManAccessPrivilege": {
3219                         "Policy": "Access Credential Manager as a trusted caller",
3220                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3221                         "rights_assignment": True,
3222                         "Settings": None,
3223                         "LsaRights": {"Option": "SeTrustedCredManAccessPrivilege"},
3224                         "Transform": {
3225                             "Get": "_sidConversion",
3226                             "Put": "_usernamesToSidObjects",
3227                         },
3228                     },
3229                     "SeNetworkLogonRight": {
3230                         "Policy": "Access this computer from the network",
3231                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3232                         "rights_assignment": True,
3233                         "Settings": None,
3234                         "LsaRights": {"Option": "SeNetworkLogonRight"},
3235                         "Transform": {
3236                             "Get": "_sidConversion",
3237                             "Put": "_usernamesToSidObjects",
3238                         },
3239                     },
3240                     "SeTcbPrivilege": {
3241                         "Policy": "Act as part of the operating system",
3242                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3243                         "rights_assignment": True,
3244                         "Settings": None,
3245                         "LsaRights": {"Option": "SeTcbPrivilege"},
3246                         "Transform": {
3247                             "Get": "_sidConversion",
3248                             "Put": "_usernamesToSidObjects",
3249                         },
3250                     },
3251                     "SeMachineAccountPrivilege": {
3252                         "Policy": "Add workstations to domain",
3253                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3254                         "rights_assignment": True,
3255                         "Settings": None,
3256                         "LsaRights": {"Option": "SeMachineAccountPrivilege"},
3257                         "Transform": {
3258                             "Get": "_sidConversion",
3259                             "Put": "_usernamesToSidObjects",
3260                         },
3261                     },
3262                     "SeIncreaseQuotaPrivilege": {
3263                         "Policy": "Adjust memory quotas for a process",
3264                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3265                         "rights_assignment": True,
3266                         "Settings": None,
3267                         "LsaRights": {"Option": "SeIncreaseQuotaPrivilege"},
3268                         "Transform": {
3269                             "Get": "_sidConversion",
3270                             "Put": "_usernamesToSidObjects",
3271                         },
3272                     },
3273                     "SeInteractiveLogonRight": {
3274                         "Policy": "Allow log on locally",
3275                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3276                         "rights_assignment": True,
3277                         "Settings": None,
3278                         "LsaRights": {"Option": "SeInteractiveLogonRight"},
3279                         "Transform": {
3280                             "Get": "_sidConversion",
3281                             "Put": "_usernamesToSidObjects",
3282                         },
3283                     },
3284                     "SeRemoteInteractiveLogonRight": {
3285                         "Policy": "Allow log on through Remote Desktop Services",
3286                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3287                         "rights_assignment": True,
3288                         "Settings": None,
3289                         "LsaRights": {"Option": "SeRemoteInteractiveLogonRight"},
3290                         "Transform": {
3291                             "Get": "_sidConversion",
3292                             "Put": "_usernamesToSidObjects",
3293                         },
3294                     },
3295                     "SeBackupPrivilege": {
3296                         "Policy": "Backup files and directories",
3297                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3298                         "rights_assignment": True,
3299                         "Settings": None,
3300                         "LsaRights": {"Option": "SeBackupPrivilege"},
3301                         "Transform": {
3302                             "Get": "_sidConversion",
3303                             "Put": "_usernamesToSidObjects",
3304                         },
3305                     },
3306                     "SeChangeNotifyPrivilege": {
3307                         "Policy": "Bypass traverse checking",
3308                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3309                         "rights_assignment": True,
3310                         "Settings": None,
3311                         "LsaRights": {"Option": "SeChangeNotifyPrivilege"},
3312                         "Transform": {
3313                             "Get": "_sidConversion",
3314                             "Put": "_usernamesToSidObjects",
3315                         },
3316                     },
3317                     "SeSystemtimePrivilege": {
3318                         "Policy": "Change the system time",
3319                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3320                         "rights_assignment": True,
3321                         "Settings": None,
3322                         "LsaRights": {"Option": "SeSystemtimePrivilege"},
3323                         "Transform": {
3324                             "Get": "_sidConversion",
3325                             "Put": "_usernamesToSidObjects",
3326                         },
3327                     },
3328                     "SeTimeZonePrivilege": {
3329                         "Policy": "Change the time zone",
3330                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3331                         "rights_assignment": True,
3332                         "Settings": None,
3333                         "LsaRights": {"Option": "SeTimeZonePrivilege"},
3334                         "Transform": {
3335                             "Get": "_sidConversion",
3336                             "Put": "_usernamesToSidObjects",
3337                         },
3338                     },
3339                     "SeCreatePagefilePrivilege": {
3340                         "Policy": "Create a pagefile",
3341                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3342                         "rights_assignment": True,
3343                         "Settings": None,
3344                         "LsaRights": {"Option": "SeCreatePagefilePrivilege"},
3345                         "Transform": {
3346                             "Get": "_sidConversion",
3347                             "Put": "_usernamesToSidObjects",
3348                         },
3349                     },
3350                     "SeCreateTokenPrivilege": {
3351                         "Policy": "Create a token object",
3352                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3353                         "rights_assignment": True,
3354                         "Settings": None,
3355                         "LsaRights": {"Option": "SeCreateTokenPrivilege"},
3356                         "Transform": {
3357                             "Get": "_sidConversion",
3358                             "Put": "_usernamesToSidObjects",
3359                         },
3360                     },
3361                     "SeCreateGlobalPrivilege": {
3362                         "Policy": "Create global objects",
3363                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3364                         "rights_assignment": True,
3365                         "Settings": None,
3366                         "LsaRights": {"Option": "SeCreateGlobalPrivilege"},
3367                         "Transform": {
3368                             "Get": "_sidConversion",
3369                             "Put": "_usernamesToSidObjects",
3370                         },
3371                     },
3372                     "SeCreatePermanentPrivilege": {
3373                         "Policy": "Create permanent shared objects",
3374                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3375                         "rights_assignment": True,
3376                         "Settings": None,
3377                         "LsaRights": {"Option": "SeCreatePermanentPrivilege"},
3378                         "Transform": {
3379                             "Get": "_sidConversion",
3380                             "Put": "_usernamesToSidObjects",
3381                         },
3382                     },
3383                     "SeCreateSymbolicLinkPrivilege": {
3384                         "Policy": "Create symbolic links",
3385                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3386                         "rights_assignment": True,
3387                         "Settings": None,
3388                         "LsaRights": {"Option": "SeCreateSymbolicLinkPrivilege"},
3389                         "Transform": {
3390                             "Get": "_sidConversion",
3391                             "Put": "_usernamesToSidObjects",
3392                         },
3393                     },
3394                     "SeDebugPrivilege": {
3395                         "Policy": "Debug programs",
3396                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3397                         "rights_assignment": True,
3398                         "Settings": None,
3399                         "LsaRights": {"Option": "SeDebugPrivilege"},
3400                         "Transform": {
3401                             "Get": "_sidConversion",
3402                             "Put": "_usernamesToSidObjects",
3403                         },
3404                     },
3405                     "SeDenyNetworkLogonRight": {
3406                         "Policy": "Deny access to this computer from the network",
3407                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3408                         "rights_assignment": True,
3409                         "Settings": None,
3410                         "LsaRights": {"Option": "SeDenyNetworkLogonRight"},
3411                         "Transform": {
3412                             "Get": "_sidConversion",
3413                             "Put": "_usernamesToSidObjects",
3414                         },
3415                     },
3416                     "SeDenyBatchLogonRight": {
3417                         "Policy": "Deny log on as a batch job",
3418                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3419                         "rights_assignment": True,
3420                         "Settings": None,
3421                         "LsaRights": {"Option": "SeDenyBatchLogonRight"},
3422                         "Transform": {
3423                             "Get": "_sidConversion",
3424                             "Put": "_usernamesToSidObjects",
3425                         },
3426                     },
3427                     "SeDenyServiceLogonRight": {
3428                         "Policy": "Deny log on as a service",
3429                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3430                         "rights_assignment": True,
3431                         "Settings": None,
3432                         "LsaRights": {"Option": "SeDenyServiceLogonRight"},
3433                         "Transform": {
3434                             "Get": "_sidConversion",
3435                             "Put": "_usernamesToSidObjects",
3436                         },
3437                     },
3438                     "SeDenyInteractiveLogonRight": {
3439                         "Policy": "Deny log on locally",
3440                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3441                         "rights_assignment": True,
3442                         "Settings": None,
3443                         "LsaRights": {"Option": "SeDenyInteractiveLogonRight"},
3444                         "Transform": {
3445                             "Get": "_sidConversion",
3446                             "Put": "_usernamesToSidObjects",
3447                         },
3448                     },
3449                     "SeDenyRemoteInteractiveLogonRight": {
3450                         "Policy": "Deny log on through Remote Desktop Services",
3451                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3452                         "rights_assignment": True,
3453                         "Settings": None,
3454                         "LsaRights": {"Option": "SeDenyRemoteInteractiveLogonRight"},
3455                         "Transform": {
3456                             "Get": "_sidConversion",
3457                             "Put": "_usernamesToSidObjects",
3458                         },
3459                     },
3460                     "SeEnableDelegationPrivilege": {
3461                         "Policy": (
3462                             "Enable computer and user accounts to be "
3463                             "trusted for delegation"
3464                         ),
3465                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3466                         "rights_assignment": True,
3467                         "Settings": None,
3468                         "LsaRights": {"Option": "SeEnableDelegationPrivilege"},
3469                         "Transform": {
3470                             "Get": "_sidConversion",
3471                             "Put": "_usernamesToSidObjects",
3472                         },
3473                     },
3474                     "SeRemoteShutdownPrivilege": {
3475                         "Policy": "Force shutdown from a remote system",
3476                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3477                         "rights_assignment": True,
3478                         "Settings": None,
3479                         "LsaRights": {"Option": "SeRemoteShutdownPrivilege"},
3480                         "Transform": {
3481                             "Get": "_sidConversion",
3482                             "Put": "_usernamesToSidObjects",
3483                         },
3484                     },
3485                     "SeAuditPrivilege": {
3486                         "Policy": "Generate security audits",
3487                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3488                         "rights_assignment": True,
3489                         "Settings": None,
3490                         "LsaRights": {"Option": "SeAuditPrivilege"},
3491                         "Transform": {
3492                             "Get": "_sidConversion",
3493                             "Put": "_usernamesToSidObjects",
3494                         },
3495                     },
3496                     "SeImpersonatePrivilege": {
3497                         "Policy": "Impersonate a client after authentication",
3498                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3499                         "rights_assignment": True,
3500                         "Settings": None,
3501                         "LsaRights": {"Option": "SeImpersonatePrivilege"},
3502                         "Transform": {
3503                             "Get": "_sidConversion",
3504                             "Put": "_usernamesToSidObjects",
3505                         },
3506                     },
3507                     "SeIncreaseWorkingSetPrivilege": {
3508                         "Policy": "Increase a process working set",
3509                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3510                         "rights_assignment": True,
3511                         "Settings": None,
3512                         "LsaRights": {"Option": "SeIncreaseWorkingSetPrivilege"},
3513                         "Transform": {
3514                             "Get": "_sidConversion",
3515                             "Put": "_usernamesToSidObjects",
3516                         },
3517                     },
3518                     "SeIncreaseBasePriorityPrivilege": {
3519                         "Policy": "Increase scheduling priority",
3520                         "rights_assignment": True,
3521                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3522                         "Settings": None,
3523                         "LsaRights": {"Option": "SeIncreaseBasePriorityPrivilege"},
3524                         "Transform": {
3525                             "Get": "_sidConversion",
3526                             "Put": "_usernamesToSidObjects",
3527                         },
3528                     },
3529                     "SeLoadDriverPrivilege": {
3530                         "Policy": "Load and unload device drivers",
3531                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3532                         "rights_assignment": True,
3533                         "Settings": None,
3534                         "LsaRights": {"Option": "SeLoadDriverPrivilege"},
3535                         "Transform": {
3536                             "Get": "_sidConversion",
3537                             "Put": "_usernamesToSidObjects",
3538                         },
3539                     },
3540                     "SeLockMemoryPrivilege": {
3541                         "Policy": "Lock pages in memory",
3542                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3543                         "rights_assignment": True,
3544                         "Settings": None,
3545                         "LsaRights": {"Option": "SeLockMemoryPrivilege"},
3546                         "Transform": {
3547                             "Get": "_sidConversion",
3548                             "Put": "_usernamesToSidObjects",
3549                         },
3550                     },
3551                     "SeBatchLogonRight": {
3552                         "Policy": "Log on as a batch job",
3553                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3554                         "rights_assignment": True,
3555                         "Settings": None,
3556                         "LsaRights": {"Option": "SeBatchLogonRight"},
3557                         "Transform": {
3558                             "Get": "_sidConversion",
3559                             "Put": "_usernamesToSidObjects",
3560                         },
3561                     },
3562                     "SeServiceLogonRight": {
3563                         "Policy": "Log on as a service",
3564                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3565                         "rights_assignment": True,
3566                         "Settings": None,
3567                         "LsaRights": {"Option": "SeServiceLogonRight"},
3568                         "Transform": {
3569                             "Get": "_sidConversion",
3570                             "Put": "_usernamesToSidObjects",
3571                         },
3572                     },
3573                     "SeSecurityPrivilege": {
3574                         "Policy": "Manage auditing and security log",
3575                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3576                         "rights_assignment": True,
3577                         "Settings": None,
3578                         "LsaRights": {"Option": "SeSecurityPrivilege"},
3579                         "Transform": {
3580                             "Get": "_sidConversion",
3581                             "Put": "_usernamesToSidObjects",
3582                         },
3583                     },
3584                     "SeRelabelPrivilege": {
3585                         "Policy": "Modify an object label",
3586                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3587                         "rights_assignment": True,
3588                         "Settings": None,
3589                         "LsaRights": {"Option": "SeRelabelPrivilege"},
3590                         "Transform": {
3591                             "Get": "_sidConversion",
3592                             "Put": "_usernamesToSidObjects",
3593                         },
3594                     },
3595                     "SeSystemEnvironmentPrivilege": {
3596                         "Policy": "Modify firmware environment values",
3597                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3598                         "rights_assignment": True,
3599                         "Settings": None,
3600                         "LsaRights": {"Option": "SeSystemEnvironmentPrivilege"},
3601                         "Transform": {
3602                             "Get": "_sidConversion",
3603                             "Put": "_usernamesToSidObjects",
3604                         },
3605                     },
3606                     "SeManageVolumePrivilege": {
3607                         "Policy": "Perform volume maintenance tasks",
3608                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3609                         "rights_assignment": True,
3610                         "Settings": None,
3611                         "LsaRights": {"Option": "SeManageVolumePrivilege"},
3612                         "Transform": {
3613                             "Get": "_sidConversion",
3614                             "Put": "_usernamesToSidObjects",
3615                         },
3616                     },
3617                     "SeProfileSingleProcessPrivilege": {
3618                         "Policy": "Profile single process",
3619                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3620                         "rights_assignment": True,
3621                         "Settings": None,
3622                         "LsaRights": {"Option": "SeProfileSingleProcessPrivilege"},
3623                         "Transform": {
3624                             "Get": "_sidConversion",
3625                             "Put": "_usernamesToSidObjects",
3626                         },
3627                     },
3628                     "SeSystemProfilePrivilege": {
3629                         "Policy": "Profile system performance",
3630                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3631                         "rights_assignment": True,
3632                         "Settings": None,
3633                         "LsaRights": {"Option": "SeSystemProfilePrivilege"},
3634                         "Transform": {
3635                             "Get": "_sidConversion",
3636                             "Put": "_usernamesToSidObjects",
3637                         },
3638                     },
3639                     "SeUndockPrivilege": {
3640                         "Policy": "Remove computer from docking station",
3641                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3642                         "rights_assignment": True,
3643                         "Settings": None,
3644                         "LsaRights": {"Option": "SeUndockPrivilege"},
3645                         "Transform": {
3646                             "Get": "_sidConversion",
3647                             "Put": "_usernamesToSidObjects",
3648                         },
3649                     },
3650                     "SeAssignPrimaryTokenPrivilege": {
3651                         "Policy": "Replace a process level token",
3652                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3653                         "rights_assignment": True,
3654                         "Settings": None,
3655                         "LsaRights": {"Option": "SeAssignPrimaryTokenPrivilege"},
3656                         "Transform": {
3657                             "Get": "_sidConversion",
3658                             "Put": "_usernamesToSidObjects",
3659                         },
3660                     },
3661                     "SeRestorePrivilege": {
3662                         "Policy": "Restore files and directories",
3663                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3664                         "rights_assignment": True,
3665                         "Settings": None,
3666                         "LsaRights": {"Option": "SeRestorePrivilege"},
3667                         "Transform": {
3668                             "Get": "_sidConversion",
3669                             "Put": "_usernamesToSidObjects",
3670                         },
3671                     },
3672                     "SeShutdownPrivilege": {
3673                         "Policy": "Shut down the system",
3674                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3675                         "rights_assignment": True,
3676                         "Settings": None,
3677                         "LsaRights": {"Option": "SeShutdownPrivilege"},
3678                         "Transform": {
3679                             "Get": "_sidConversion",
3680                             "Put": "_usernamesToSidObjects",
3681                         },
3682                     },
3683                     "SeSyncAgentPrivilege": {
3684                         "Policy": "Synchronize directory service data",
3685                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3686                         "rights_assignment": True,
3687                         "Settings": None,
3688                         "LsaRights": {"Option": "SeSyncAgentPrivilege"},
3689                         "Transform": {
3690                             "Get": "_sidConversion",
3691                             "Put": "_usernamesToSidObjects",
3692                         },
3693                     },
3694                     "SeTakeOwnershipPrivilege": {
3695                         "Policy": "Take ownership of files or other objects",
3696                         "lgpo_section": self.user_rights_assignment_gpedit_path,
3697                         "rights_assignment": True,
3698                         "Settings": None,
3699                         "LsaRights": {"Option": "SeTakeOwnershipPrivilege"},
3700                         "Transform": {
3701                             "Get": "_sidConversion",
3702                             "Put": "_usernamesToSidObjects",
3703                         },
3704                     },
3705                     "RecoveryConsoleSecurityLevel": {
3706                         "Policy": (
3707                             "Recovery console: Allow automatic administrative logon"
3708                         ),
3709                         "Settings": self.enabled_one_disabled_zero.keys(),
3710                         "lgpo_section": self.security_options_gpedit_path,
3711                         "Registry": {
3712                             "Hive": "HKEY_LOCAL_MACHINE",
3713                             "Path": (
3714                                 "Software\\Microsoft\\Windows NT\\"
3715                                 "CurrentVersion\\Setup\\RecoveryConsole"
3716                             ),
3717                             "Value": "SecurityLevel",
3718                             "Type": "REG_DWORD",
3719                         },
3720                         "Transform": self.enabled_one_disabled_zero_transform,
3721                     },
3722                     "RecoveryConsoleSetCommand": {
3723                         "Policy": (
3724                             "Recovery console: Allow floppy copy and "
3725                             "access to all drives and all folders"
3726                         ),
3727                         "Settings": self.enabled_one_disabled_zero.keys(),
3728                         "lgpo_section": self.security_options_gpedit_path,
3729                         "Registry": {
3730                             "Hive": "HKEY_LOCAL_MACHINE",
3731                             "Path": (
3732                                 "Software\\Microsoft\\Windows NT\\"
3733                                 "CurrentVersion\\Setup\\RecoveryConsole"
3734                             ),
3735                             "Value": "SetCommand",
3736                             "Type": "REG_DWORD",
3737                         },
3738                         "Transform": self.enabled_one_disabled_zero_transform,
3739                     },
3740                     "ForceKeyProtection": {
3741                         "Policy": (
3742                             "System Cryptography: Force strong key protection for "
3743                             "user keys stored on the computer"
3744                         ),
3745                         "Settings": self.force_key_protection.keys(),
3746                         "lgpo_section": self.security_options_gpedit_path,
3747                         "Registry": {
3748                             "Hive": "HKEY_LOCAL_MACHINE",
3749                             "Path": "Software\\Policies\\Microsoft\\Cryptography",
3750                             "Value": "ForceKeyProtection",
3751                             "Type": "REG_DWORD",
3752                         },
3753                         "Transform": {
3754                             "Get": "_dict_lookup",
3755                             "Put": "_dict_lookup",
3756                             "GetArgs": {
3757                                 "lookup": self.force_key_protection,
3758                                 "value_lookup": False,
3759                             },
3760                             "PutArgs": {
3761                                 "lookup": self.force_key_protection,
3762                                 "value_lookup": True,
3763                             },
3764                         },
3765                     },
3766                     "FIPSAlgorithmPolicy": {
3767                         "Policy": (
3768                             "System Cryptography: Use FIPS compliant algorithms "
3769                             "for encryption, hashing, and signing"
3770                         ),
3771                         "Settings": self.enabled_one_disabled_zero.keys(),
3772                         "lgpo_section": self.security_options_gpedit_path,
3773                         "Registry": {
3774                             "Hive": "HKEY_LOCAL_MACHINE",
3775                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\FIPSAlgorithmPolicy",
3776                             "Value": "Enabled",
3777                             "Type": "REG_DWORD",
3778                         },
3779                         "Transform": self.enabled_one_disabled_zero_transform,
3780                     },
3781                     "MachineAccessRestriction": {
3782                         "Policy": (
3783                             "DCOM: Machine Access Restrictions in Security Descriptor "
3784                             "Definition Language (SDDL) syntax"
3785                         ),
3786                         "Settings": None,
3787                         "lgpo_section": self.security_options_gpedit_path,
3788                         "Registry": {
3789                             "Hive": "HKEY_LOCAL_MACHINE",
3790                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3791                             "Value": "MachineAccessRestriction",
3792                             "Type": "REG_SZ",
3793                         },
3794                         "Transform": {"Put": "_string_put_transform"},
3795                     },
3796                     "MachineLaunchRestriction": {
3797                         "Policy": (
3798                             "DCOM: Machine Launch Restrictions in Security Descriptor "
3799                             "Definition Language (SDDL) syntax"
3800                         ),
3801                         "Settings": None,
3802                         "lgpo_section": self.security_options_gpedit_path,
3803                         "Registry": {
3804                             "Hive": "HKEY_LOCAL_MACHINE",
3805                             "Path": "Software\\Policies\\Microsoft\\Windows NT\\DCOM",
3806                             "Value": "MachineLaunchRestriction",
3807                             "Type": "REG_SZ",
3808                         },
3809                         "Transform": {"Put": "_string_put_transform"},
3810                     },
3811                     "UseMachineId": {
3812                         "Policy": (
3813                             "Network security: Allow Local System to use computer "
3814                             "identity for NTLM"
3815                         ),
3816                         "Settings": self.enabled_one_disabled_zero.keys(),
3817                         "lgpo_section": self.security_options_gpedit_path,
3818                         "Registry": {
3819                             "Hive": "HKEY_LOCAL_MACHINE",
3820                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3821                             "Value": "UseMachineId",
3822                             "Type": "REG_DWORD",
3823                         },
3824                         "Transform": self.enabled_one_disabled_zero_transform,
3825                     },
3826                     "allownullsessionfallback": {
3827                         "Policy": (
3828                             "Network security: Allow LocalSystem NULL session fallback"
3829                         ),
3830                         "Settings": self.enabled_one_disabled_zero.keys(),
3831                         "lgpo_section": self.security_options_gpedit_path,
3832                         "Registry": {
3833                             "Hive": "HKEY_LOCAL_MACHINE",
3834                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3835                             "Value": "allownullsessionfallback",
3836                             "Type": "REG_DWORD",
3837                         },
3838                         "Transform": self.enabled_one_disabled_zero_transform,
3839                     },
3840                     "AllowOnlineID": {
3841                         "Policy": (
3842                             "Network security: Allow PKU2U authentication requests "
3843                             "to this computer to use online identities."
3844                         ),
3845                         "Settings": self.enabled_one_disabled_zero.keys(),
3846                         "lgpo_section": self.security_options_gpedit_path,
3847                         "Registry": {
3848                             "Hive": "HKEY_LOCAL_MACHINE",
3849                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\pku2u",
3850                             "Value": "AllowOnlineID",
3851                             "Type": "REG_DWORD",
3852                         },
3853                         "Transform": self.enabled_one_disabled_zero_transform,
3854                     },
3855                     "KrbSupportedEncryptionTypes": {
3856                         "Policy": (
3857                             "Network security: Configure encryption types allowed "
3858                             "for Kerberos"
3859                         ),
3860                         "Settings": None,
3861                         "lgpo_section": self.security_options_gpedit_path,
3862                         "Registry": {
3863                             "Hive": "HKEY_LOCAL_MACHINE",
3864                             "Path": (
3865                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies"
3866                                 "\\system\\Kerberos\\Parameters"
3867                             ),
3868                             "Value": "SupportedEncryptionTypes",
3869                             "Type": "REG_DWORD",
3870                         },
3871                         "Transform": {
3872                             "Get": "_dict_lookup_bitwise_add",
3873                             "Put": "_dict_lookup_bitwise_add",
3874                             "GetArgs": {
3875                                 "lookup": self.krb_encryption_types,
3876                                 "value_lookup": False,
3877                             },
3878                             "PutArgs": {
3879                                 "lookup": self.krb_encryption_types,
3880                                 "value_lookup": True,
3881                             },
3882                         },
3883                     },
3884                     "NoLMHash": {
3885                         "Policy": (
3886                             "Network security: Do not store LAN Manager hash value "
3887                             "on next password change"
3888                         ),
3889                         "Settings": self.enabled_one_disabled_zero.keys(),
3890                         "lgpo_section": self.security_options_gpedit_path,
3891                         "Registry": {
3892                             "Hive": "HKEY_LOCAL_MACHINE",
3893                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3894                             "Value": "NoLMHash",
3895                             "Type": "REG_DWORD",
3896                         },
3897                         "Transform": self.enabled_one_disabled_zero_transform,
3898                     },
3899                     "ForceLogoffWhenHourExpire": {
3900                         "Policy": (
3901                             "Network security: Force logoff when logon hours expire"
3902                         ),
3903                         "lgpo_section": self.security_options_gpedit_path,
3904                         "Settings": self.enabled_one_disabled_zero_no_not_defined.keys(),
3905                         "Secedit": {
3906                             "Option": "ForceLogoffWhenHourExpire",
3907                             "Section": "System Access",
3908                         },
3909                         "Transform": self.enabled_one_disabled_zero_no_not_defined_transform,
3910                     },
3911                     "LmCompatibilityLevel": {
3912                         "Policy": "Network security: LAN Manager authentication level",
3913                         "Settings": self.lm_compat_levels.keys(),
3914                         "lgpo_section": self.security_options_gpedit_path,
3915                         "Registry": {
3916                             "Hive": "HKEY_LOCAL_MACHINE",
3917                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa",
3918                             "Value": "LmCompatibilityLevel",
3919                             "Type": "REG_DWORD",
3920                         },
3921                         "Transform": {
3922                             "Get": "_dict_lookup",
3923                             "Put": "_dict_lookup",
3924                             "GetArgs": {
3925                                 "lookup": self.lm_compat_levels,
3926                                 "value_lookup": False,
3927                             },
3928                             "PutArgs": {
3929                                 "lookup": self.lm_compat_levels,
3930                                 "value_lookup": True,
3931                             },
3932                         },
3933                     },
3934                     "LDAPClientIntegrity": {
3935                         "Policy": "Network security: LDAP client signing requirements",
3936                         "Settings": self.ldap_signing_reqs.keys(),
3937                         "lgpo_section": self.security_options_gpedit_path,
3938                         "Registry": {
3939                             "Hive": "HKEY_LOCAL_MACHINE",
3940                             "Path": "SYSTEM\\CurrentControlSet\\Services\\ldap",
3941                             "Value": "LDAPClientIntegrity",
3942                             "Type": "REG_DWORD",
3943                         },
3944                         "Transform": {
3945                             "Get": "_dict_lookup",
3946                             "Put": "_dict_lookup",
3947                             "GetArgs": {
3948                                 "lookup": self.ldap_signing_reqs,
3949                                 "value_lookup": False,
3950                             },
3951                             "PutArgs": {
3952                                 "lookup": self.ldap_signing_reqs,
3953                                 "value_lookup": True,
3954                             },
3955                         },
3956                     },
3957                     "NTLMMinClientSec": {
3958                         "Policy": (
3959                             "Network security: Minimum session security for NTLM SSP"
3960                             " based (including secure RPC) clients"
3961                         ),
3962                         "Settings": None,
3963                         "lgpo_section": self.security_options_gpedit_path,
3964                         "Registry": {
3965                             "Hive": "HKEY_LOCAL_MACHINE",
3966                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3967                             "Value": "NTLMMinClientSec",
3968                             "Type": "REG_DWORD",
3969                         },
3970                         "Transform": {
3971                             "Get": "_dict_lookup_bitwise_add",
3972                             "Put": "_dict_lookup_bitwise_add",
3973                             "GetArgs": {
3974                                 "lookup": self.ntlm_session_security_levels,
3975                                 "value_lookup": False,
3976                             },
3977                             "PutArgs": {
3978                                 "lookup": self.ntlm_session_security_levels,
3979                                 "value_lookup": True,
3980                             },
3981                         },
3982                     },
3983                     "NTLMMinServerSec": {
3984                         "Policy": (
3985                             "Network security: Minimum session security for NTLM SSP"
3986                             " based (including secure RPC) servers"
3987                         ),
3988                         "Settings": None,
3989                         "lgpo_section": self.security_options_gpedit_path,
3990                         "Registry": {
3991                             "Hive": "HKEY_LOCAL_MACHINE",
3992                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
3993                             "Value": "NTLMMinServerSec",
3994                             "Type": "REG_DWORD",
3995                         },
3996                         "Transform": {
3997                             "Get": "_dict_lookup_bitwise_add",
3998                             "Put": "_dict_lookup_bitwise_add",
3999                             "GetArgs": {
4000                                 "lookup": self.ntlm_session_security_levels,
4001                                 "value_lookup": False,
4002                             },
4003                             "PutArgs": {
4004                                 "lookup": self.ntlm_session_security_levels,
4005                                 "value_lookup": True,
4006                             },
4007                         },
4008                     },
4009                     "ClientAllowedNTLMServers": {
4010                         "Policy": (
4011                             "Network security: Restrict NTLM: Add remote server"
4012                             " exceptions for NTLM authentication"
4013                         ),
4014                         "lgpo_section": self.security_options_gpedit_path,
4015                         "Registry": {
4016                             "Hive": "HKEY_LOCAL_MACHINE",
4017                             "Path": "System\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4018                             "Value": "ClientAllowedNTLMServers",
4019                             "Type": "REG_MULTI_SZ",
4020                         },
4021                         "Transform": {
4022                             "Put": "_multi_string_put_transform",
4023                             "Get": "_multi_string_get_transform",
4024                         },
4025                     },
4026                     "DCAllowedNTLMServers": {
4027                         "Policy": (
4028                             "Network security: Restrict NTLM: Add server exceptions"
4029                             " in this domain"
4030                         ),
4031                         "lgpo_section": self.security_options_gpedit_path,
4032                         "Registry": {
4033                             "Hive": "HKEY_LOCAL_MACHINE",
4034                             "Path": "System\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4035                             "Value": "DCAllowedNTLMServers",
4036                             "Type": "REG_MULTI_SZ",
4037                         },
4038                         "Transform": {
4039                             "Put": "_multi_string_put_transform",
4040                             "Get": "_multi_string_get_transform",
4041                         },
4042                     },
4043                     "AuditReceivingNTLMTraffic": {
4044                         "Policy": (
4045                             "Network security: Restrict NTLM: Audit Incoming NTLM"
4046                             " Traffic"
4047                         ),
4048                         "Settings": self.ntlm_audit_settings.keys(),
4049                         "lgpo_section": self.security_options_gpedit_path,
4050                         "Registry": {
4051                             "Hive": "HKEY_LOCAL_MACHINE",
4052                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4053                             "Value": "AuditReceivingNTLMTraffic",
4054                             "Type": "REG_DWORD",
4055                         },
4056                         "Transform": {
4057                             "Get": "_dict_lookup",
4058                             "Put": "_dict_lookup",
4059                             "GetArgs": {
4060                                 "lookup": self.ntlm_audit_settings,
4061                                 "value_lookup": False,
4062                             },
4063                             "PutArgs": {
4064                                 "lookup": self.ntlm_audit_settings,
4065                                 "value_lookup": True,
4066                             },
4067                         },
4068                     },
4069                     "AuditNTLMInDomain": {
4070                         "Policy": (
4071                             "Network security: Restrict NTLM: Audit NTLM "
4072                             "authentication in this domain"
4073                         ),
4074                         "Settings": self.ntlm_domain_audit_settings.keys(),
4075                         "lgpo_section": self.security_options_gpedit_path,
4076                         "Registry": {
4077                             "Hive": "HKEY_LOCAL_MACHINE",
4078                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4079                             "Value": "AuditNTLMInDomain",
4080                             "Type": "REG_DWORD",
4081                         },
4082                         "Transform": {
4083                             "Get": "_dict_lookup",
4084                             "Put": "_dict_lookup",
4085                             "GetArgs": {
4086                                 "lookup": self.ntlm_domain_audit_settings,
4087                                 "value_lookup": False,
4088                             },
4089                             "PutArgs": {
4090                                 "lookup": self.ntlm_domain_audit_settings,
4091                                 "value_lookup": True,
4092                             },
4093                         },
4094                     },
4095                     "RestrictReceivingNTLMTraffic": {
4096                         "Policy": (
4097                             "Network security: Restrict NTLM: Incoming NTLM traffic"
4098                         ),
4099                         "Settings": self.incoming_ntlm_settings.keys(),
4100                         "lgpo_section": self.security_options_gpedit_path,
4101                         "Registry": {
4102                             "Hive": "HKEY_LOCAL_MACHINE",
4103                             "Path": "SYSTEM\\CurrentControlSet\\Control\\LSA\\MSV1_0",
4104                             "Value": "RestrictReceivingNTLMTraffic",
4105                             "Type": "REG_DWORD",
4106                         },
4107                         "Transform": {
4108                             "Get": "_dict_lookup",
4109                             "Put": "_dict_lookup",
4110                             "GetArgs": {
4111                                 "lookup": self.incoming_ntlm_settings,
4112                                 "value_lookup": False,
4113                             },
4114                             "PutArgs": {
4115                                 "lookup": self.incoming_ntlm_settings,
4116                                 "value_lookup": True,
4117                             },
4118                         },
4119                     },
4120                     "RestrictNTLMInDomain": {
4121                         "Policy": (
4122                             "Network security: Restrict NTLM: NTLM "
4123                             "authentication in this domain"
4124                         ),
4125                         "Settings": self.ntlm_domain_auth_settings.keys(),
4126                         "lgpo_section": self.security_options_gpedit_path,
4127                         "Registry": {
4128                             "Hive": "HKEY_LOCAL_MACHINE",
4129                             "Path": "SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
4130                             "Value": "RestrictNTLMInDomain",
4131                             "Type": "REG_DWORD",
4132                         },
4133                         "Transform": {
4134                             "Get": "_dict_lookup",
4135                             "Put": "_dict_lookup",
4136                             "GetArgs": {
4137                                 "lookup": self.ntlm_domain_auth_settings,
4138                                 "value_lookup": False,
4139                             },
4140                             "PutArgs": {
4141                                 "lookup": self.ntlm_domain_auth_settings,
4142                                 "value_lookup": True,
4143                             },
4144                         },
4145                     },
4146                     "RestrictSendingNTLMTraffic": {
4147                         "Policy": (
4148                             "Network security: Restrict NTLM: Outgoing NTLM"
4149                             " traffic to remote servers"
4150                         ),
4151                         "Settings": self.outgoing_ntlm_settings.keys(),
4152                         "lgpo_section": self.security_options_gpedit_path,
4153                         "Registry": {
4154                             "Hive": "HKEY_LOCAL_MACHINE",
4155                             "Path": "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0",
4156                             "Value": "RestrictSendingNTLMTraffic",
4157                             "Type": "REG_DWORD",
4158                         },
4159                         "Transform": {
4160                             "Get": "_dict_lookup",
4161                             "Put": "_dict_lookup",
4162                             "GetArgs": {
4163                                 "lookup": self.outgoing_ntlm_settings,
4164                                 "value_lookup": False,
4165                             },
4166                             "PutArgs": {
4167                                 "lookup": self.outgoing_ntlm_settings,
4168                                 "value_lookup": True,
4169                             },
4170                         },
4171                     },
4172                     "ShutdownWithoutLogon": {
4173                         "Policy": (
4174                             "Shutdown: Allow system to be shut down "
4175                             "without having to log on"
4176                         ),
4177                         "Settings": self.enabled_one_disabled_zero.keys(),
4178                         "lgpo_section": self.security_options_gpedit_path,
4179                         "Registry": {
4180                             "Hive": "HKEY_LOCAL_MACHINE",
4181                             "Path": "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
4182                             "Value": "ShutdownWithoutLogon",
4183                             "Type": "REG_DWORD",
4184                         },
4185                         "Transform": self.enabled_one_disabled_zero_transform,
4186                     },
4187                     "ClearPageFileAtShutdown": {
4188                         "Policy": "Shutdown: Clear virtual memory pagefile",
4189                         "Settings": self.enabled_one_disabled_zero.keys(),
4190                         "lgpo_section": self.security_options_gpedit_path,
4191                         "Registry": {
4192                             "Hive": "HKEY_LOCAL_MACHINE",
4193                             "Path": (
4194                                 "System\\CurrentControlSet\\Control\\"
4195                                 "SESSION MANAGER\\MEMORY MANAGEMENT"
4196                             ),
4197                             "Value": "ClearPageFileAtShutdown",
4198                             "Type": "REG_DWORD",
4199                         },
4200                         "Transform": self.enabled_one_disabled_zero_transform,
4201                     },
4202                     "ObCaseInsensitive": {
4203                         "Policy": (
4204                             "System objects: Require case insensitivity for "
4205                             "non-Windows subsystems"
4206                         ),
4207                         "Settings": self.enabled_one_disabled_zero.keys(),
4208                         "lgpo_section": self.security_options_gpedit_path,
4209                         "Registry": {
4210                             "Hive": "HKEY_LOCAL_MACHINE",
4211                             "Path": (
4212                                 "System\\CurrentControlSet\\Control\\"
4213                                 "SESSION MANAGER\\Kernel"
4214                             ),
4215                             "Value": "ObCaseInsensitive",
4216                             "Type": "REG_DWORD",
4217                         },
4218                         "Transform": self.enabled_one_disabled_zero_transform,
4219                     },
4220                     "ProtectionMode": {
4221                         "Policy": (
4222                             "System objects: Strengthen default permissions of "
4223                             "internal system objects (e.g. Symbolic Links)"
4224                         ),
4225                         "Settings": self.enabled_one_disabled_zero.keys(),
4226                         "lgpo_section": self.security_options_gpedit_path,
4227                         "Registry": {
4228                             "Hive": "HKEY_LOCAL_MACHINE",
4229                             "Path": (
4230                                 "System\\CurrentControlSet\\Control\\SESSION MANAGER"
4231                             ),
4232                             "Value": "ProtectionMode",
4233                             "Type": "REG_DWORD",
4234                         },
4235                         "Transform": self.enabled_one_disabled_zero_transform,
4236                     },
4237                     "OptionalSubsystems": {
4238                         "Policy": "System settings: Optional subsystems",
4239                         "lgpo_section": self.security_options_gpedit_path,
4240                         "Registry": {
4241                             "Hive": "HKEY_LOCAL_MACHINE",
4242                             "Path": (
4243                                 "System\\CurrentControlSet\\Control\\"
4244                                 "SESSION MANAGER\\SubSystems"
4245                             ),
4246                             "Value": "optional",
4247                             "Type": "REG_MULTI_SZ",
4248                         },
4249                         "Transform": {
4250                             "Put": "_multi_string_put_transform",
4251                             "Get": "_multi_string_get_transform",
4252                         },
4253                     },
4254                     "AuthenticodeEnabled": {
4255                         "Policy": (
4256                             "System settings: Use Certificate Rules on Windows"
4257                             " Executables for Software Restriction Policies"
4258                         ),
4259                         "Settings": self.enabled_one_disabled_zero.keys(),
4260                         "lgpo_section": self.security_options_gpedit_path,
4261                         "Registry": {
4262                             "Hive": "HKEY_LOCAL_MACHINE",
4263                             "Path": "SOFTWARE\\Policies\\Microsoft\\Windows\\safer\\codeidentifiers",
4264                             "Value": "AuthenticodeEnabled",
4265                             "Type": "REG_DWORD",
4266                         },
4267                         "Transform": self.enabled_one_disabled_zero_transform,
4268                     },
4269                 },
4270             },
4271             "User": {"lgpo_section": "User Configuration", "policies": {}},
4272         }
4273         self.admx_registry_classes = {
4274             "User": {
4275                 "policy_path": os.path.join(
4276                     os.getenv("WINDIR"),
4277                     "System32",
4278                     "GroupPolicy",
4279                     "User",
4280                     "Registry.pol",
4281                 ),
4282                 "hive": "HKEY_USERS",
4283                 "lgpo_section": "User Configuration",
4284                 "gpt_extension_location": "gPCUserExtensionNames",
4285                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F73-3407-48AE-BA88-E8213C6761F1}]",
4286             },
4287             "Machine": {
4288                 "policy_path": os.path.join(
4289                     os.getenv("WINDIR"),
4290                     "System32",
4291                     "GroupPolicy",
4292                     "Machine",
4293                     "Registry.pol",
4294                 ),
4295                 "hive": "HKEY_LOCAL_MACHINE",
4296                 "lgpo_section": "Computer Configuration",
4297                 "gpt_extension_location": "gPCMachineExtensionNames",
4298                 "gpt_extension_guid": "[{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}]",
4299             },
4300         }
4301         self.reg_pol_header = "\u5250\u6765\x01\x00"
4302         self.gpt_ini_path = os.path.join(
4303             os.getenv("WINDIR"), "System32", "GroupPolicy", "gpt.ini"
4304         )
4305     @classmethod
4306     def _notEmpty(cls, val, **kwargs):
4307         """
4308         ensures a value is not empty
4309         """
4310         if val:
4311             return True
4312         else:
4313             return False
4314     @classmethod
4315     def _seconds_to_days(cls, val, **kwargs):
4316         """
4317         converts a number of seconds to days
4318         """
4319         zero_value = kwargs.get("zero_value", 0)
4320         if val is not None:
4321             if val == zero_value:
4322                 return 0
4323             return val / 86400
4324         else:
4325             return "Not Defined"
4326     @classmethod
4327     def _days_to_seconds(cls, val, **kwargs):
4328         """
4329         converts a number of days to seconds
4330         """
4331         zero_value = kwargs.get("zero_value", 0)
4332         if val is not None:
4333             if val == 0:
4334                 return zero_value
4335             return val * 86400
4336         else:
4337             return "Not Defined"
4338     @classmethod
4339     def _seconds_to_minutes(cls, val, **kwargs):
4340         """
4341         converts a number of seconds to minutes
4342         """
4343         zero_value = kwargs.get("zero_value", 0)
4344         if val is not None:
4345             if val == zero_value:
4346                 return 0
4347             return val / 60
4348         else:
4349             return "Not Defined"
4350     @classmethod
4351     def _minutes_to_seconds(cls, val, **kwargs):
4352         """
4353         converts number of minutes to seconds
4354         """
4355         zero_value = kwargs.get("zero_value", 0)
4356         if val is not None:
4357             if val == 0:
4358                 return zero_value
4359             return val * 60
4360         else:
4361             return "Not Defined"
4362     @classmethod
4363     def _strip_quotes(cls, val, **kwargs):
4364         """
4365         strips quotes from a string
4366         """
4367         return val.replace('"', "")
4368     @classmethod
4369     def _add_quotes(cls, val, **kwargs):
4370         """
4371         add quotes around the string
4372         """
4373         return '"{}"'.format(val)
4374     @classmethod
4375     def _binary_enable_zero_disable_one_conversion(cls, val, **kwargs):
4376         """
4377         converts a binary 0/1 to Disabled/Enabled
4378         """
4379         try:
4380             if val is not None:
4381                 if ord(val) == 0:
4382                     return "Disabled"
4383                 elif ord(val) == 1:
4384                     return "Enabled"
4385                 else:
4386                     return "Invalid Value: {!r}".format(val)
4387             else:
4388                 return "Not Defined"
4389         except TypeError:
4390             return "Invalid Value"
4391     @classmethod
4392     def _binary_enable_zero_disable_one_reverse_conversion(cls, val, **kwargs):
4393         """
4394         converts Enabled/Disabled to unicode char to write to a REG_BINARY value
4395         """
4396         if val is not None:
4397             if val.upper() == "DISABLED":
4398                 return chr(0)
4399             elif val.upper() == "ENABLED":
4400                 return chr(1)
4401             else:
4402                 return None
4403         else:
4404             return None
4405     @classmethod
4406     def _dasd_conversion(cls, val, **kwargs):
4407         """
4408         converts 0/1/2 for dasd reg key
4409         """
4410         if val is not None:
4411             if val == "0" or val == 0 or val == "":
4412                 return "Administrators"
4413             elif val == "1" or val == 1:
4414                 return "Administrators and Power Users"
4415             elif val == "2" or val == 2:
4416                 return "Administrators and Interactive Users"
4417             else:
4418                 return "Not Defined"
4419         else:
4420             return "Not Defined"
4421     @classmethod
4422     def _dasd_reverse_conversion(cls, val, **kwargs):
4423         """
4424         converts DASD String values to the reg_sz value
4425         """
4426         if val is not None:
4427             if val.upper() == "ADMINISTRATORS":
4428                 return "0"
4429             elif val.upper() == "ADMINISTRATORS AND POWER USERS":
4430                 return "1"
4431             elif val.upper() == "ADMINISTRATORS AND INTERACTIVE USERS":
4432                 return "2"
4433             elif val.upper() == "NOT DEFINED":
4434                 return "9999"
4435             else:
4436                 return "Invalid Value"
4437         else:
4438             return "Not Defined"
4439     @classmethod
4440     def _in_range_inclusive(cls, val, **kwargs):
4441         """
4442         checks that a value is in an inclusive range
4443         The value for 0 used by Max Password Age is actually 0xffffffff
4444         """
4445         minimum = kwargs.get("min", 0)
4446         maximum = kwargs.get("max", 1)
4447         zero_value = kwargs.get("zero_value", 0)
4448         if isinstance(val, str):
4449             if val.lower() == "not defined":
4450                 return True
4451             else:
4452                 try:
4453                     val = int(val)
4454                 except ValueError:
4455                     return False
4456         if val is not None:
4457             if minimum &lt;= val &lt;= maximum or val == zero_value:
4458                 return True
4459             else:
4460                 return False
4461         else:
4462             return False
4463     @classmethod
4464     def _driver_signing_reg_conversion(cls, val, **kwargs):
4465         """
4466         converts the binary value in the registry for driver signing into the
4467         correct string representation
4468         """
4469         log.trace("we have %s for the driver signing value", val)
4470         if val is not None:
4471             _val = val.split(",")
4472             if len(_val) == 2:
4473                 if _val[1] == "0":
4474                     return "Silently Succeed"
4475                 elif _val[1] == "1":
4476                     return "Warn but allow installation"
4477                 elif _val[1] == "2":
4478                     return "Do not allow installation"
4479                 elif _val[1] == "Not Defined":
4480                     return "Not Defined"
4481                 else:
4482                     return "Invalid Value"
4483             else:
4484                 return "Not Defined"
4485         else:
4486             return "Not Defined"
4487     @classmethod
4488     def _driver_signing_reg_reverse_conversion(cls, val, **kwargs):
4489         """
4490         converts the string value seen in the GUI to the correct registry value
4491         for secedit
4492         """
4493         if val is not None:
4494             if val.upper() == "SILENTLY SUCCEED":
4495                 return ",".join(["3", "0"])
4496             elif val.upper() == "WARN BUT ALLOW INSTALLATION":
4497                 return ",".join(["3", chr(1)])
4498             elif val.upper() == "DO NOT ALLOW INSTALLATION":
4499                 return ",".join(["3", chr(2)])
4500             else:
4501                 return "Invalid Value"
4502         else:
4503             return "Not Defined"
4504     @classmethod
4505     def _sidConversion(cls, val, **kwargs):
4506         """
4507         converts a list of pysid objects to string representations
4508         """
4509         if isinstance(val, str):
4510             val = val.split(",")
4511         usernames = []
4512         for _sid in val:
4513             try:
4514                 userSid = win32security.LookupAccountSid("", _sid)
4515                 if userSid[1]:
4516                     userSid = "{1}\\{0}".format(userSid[0], userSid[1])
4517                 else:
4518                     userSid = "{}".format(userSid[0])
4519             except Exception:  # pylint: disable=broad-except
4520                 userSid = win32security.ConvertSidToStringSid(_sid)
4521                 log.warning(
4522                     "Unable to convert SID '%s' to a friendly name. "
4523                     "The SID will be displayed instead of a user/group name.",
4524                     userSid,
4525                 )
4526             usernames.append(userSid)
4527         return usernames
4528     @classmethod
4529     def _usernamesToSidObjects(cls, val, **kwargs):
4530         """
4531         converts a list of usernames to sid objects
4532         """
4533         if not val:
4534             return val
4535         if isinstance(val, str):
4536             val = val.split(",")
4537         sids = []
4538         for _user in val:
4539             try:
4540                 sid = win32security.LookupAccountName("", _user)[0]
4541                 sids.append(sid)
4542             except Exception as e:  # pylint: disable=broad-except
4543                 log.exception("Handle this explicitly")
4544                 raise CommandExecutionError(
4545                     'There was an error obtaining the SID of user "{}". Error '
4546                     "returned: {}".format(_user, e)
4547                 )
4548         return sids
4549     @classmethod
4550     def _powershell_script_order_conversion(cls, val, **kwargs):
4551         """
4552         converts true/false/None to the GUI representation of the powershell
4553         startup/shutdown script order
4554         """
4555         log.trace("script order value = %s", val)
4556         if val is None or val == "None":
4557             return "Not Configured"
4558         elif val == "true":
4559             return "Run Windows PowerShell scripts first"
4560         elif val == "false":
4561             return "Run Windows PowerShell scripts last"
4562         else:
4563             return "Invalid Value"
4564     @classmethod
4565     def _powershell_script_order_reverse_conversion(cls, val, **kwargs):
4566         """
4567         converts powershell script GUI strings representations to
4568         True/False/None
4569         """
4570         if val.upper() == "Run Windows PowerShell scripts first".upper():
4571             return "true"
4572         elif val.upper() == "Run Windows PowerShell scripts last".upper():
4573             return "false"
4574         elif val == "Not Configured":
4575             return None
4576         else:
4577             return "Invalid Value"
4578     @classmethod
4579     def _dict_lookup(cls, item, **kwargs):
4580         """
4581         Retrieves the key or value from a dict based on the item
4582         kwarg lookup dict to search for item
4583         kwarg value_lookup bool to determine if item should be compared to keys
4584         or values
4585         """
4586         log.trace("item == %s", item)
4587         value_lookup = kwargs.get("value_lookup", False)
4588         if "lookup" in kwargs:
4589             for k, v in kwargs["lookup"].items():
4590                 if value_lookup:
4591                     if str(v).lower() == str(item).lower():
4592                         log.trace("returning key %s", k)
4593                         return k
4594                 else:
4595                     if str(k).lower() == str(item).lower():
4596                         log.trace("returning value %s", v)
4597                         return v
4598         return "Invalid Value"
4599     @classmethod
4600     def _dict_lookup_bitwise_add(cls, item, **kwargs):
4601         """
4602         kwarg value_lookup bool to determine if item_list should be compared to keys
4603         or values
4604         kwarg test_zero is used to determine if 0 should be tested when value_lookup is false
4605         lookup should be a dict with integers for keys
4606         if value_lookup is True, item is expected to be a list
4607             the function will return the sum of the keys whose values are in the item list
4608         if value_lookup is False, item is expected to be an integer
4609             the function will return the values for the keys
4610             which successfully "bitwise and" with item
4611         """
4612         value_lookup = kwargs.get("value_lookup", False)
4613         test_zero = kwargs.get("test_zero", False)
4614         ret_val = None
4615         if str(item).lower() == "not defined":
4616             return None
4617         if value_lookup:
4618             if not isinstance(item, list):
4619                 return "Invalid Value"
4620             ret_val = 0
4621         else:
4622             if not isinstance(item, int):
4623                 return "Invalid Value"
4624             ret_val = []
4625         if "lookup" in kwargs:
4626             for k, v in kwargs["lookup"].items():
4627                 if value_lookup:
4628                     if str(v).lower() in [z.lower() for z in item]:
4629                         ret_val = ret_val + k
4630                 else:
4631                     do_test = True
4632                     if not test_zero:
4633                         if k == 0:
4634                             do_test = False
4635                     if do_test and isinstance(k, int) and item &amp; k == k:
4636                         ret_val.append(v)
4637         else:
4638             return "Invalid Value"
4639         return ret_val
4640     @classmethod
4641     def _multi_string_put_transform(cls, item, **kwargs):
4642         """
4643         transform for setting REG_MULTI_SZ to properly handle "Not Defined"
4644         """
4645         if isinstance(item, list):
4646             return item
4647         elif isinstance(item, str):
4648             if item.lower() == "not defined":
4649                 return None
4650             else:
4651                 return item.split(",")
4652         else:
4653             return "Invalid Value"
4654     @classmethod
4655     def _multi_string_get_transform(cls, item, **kwargs):
4656         """
4657         transform for getting REG_MULTI_SZ to properly handle `None`
4658         """
4659         if isinstance(item, list):
4660             return item
4661         elif item is None:
4662             return "Not Defined"
4663         else:
4664             return "Invalid Value"
4665     @classmethod
4666     def _string_put_transform(cls, item, **kwargs):
4667         """
4668         transform for a REG_SZ to properly handle "Not Defined"
4669         """
4670         if isinstance(item, str):
4671             if item.lower() == "not defined":
4672                 return None
4673             else:
4674                 return item
4675 def __virtual__():
4676     """
4677     Only works on Windows systems
4678     """
4679     if not salt.utils.platform.is_windows():
4680         return False, "win_lgpo: Not a Windows System"
4681     if not HAS_WINDOWS_MODULES:
4682         return False, "win_lgpo: Required modules failed to load"
4683     return __virtualname__
4684 def _updateNamespace(item, new_namespace):
4685     """
4686     helper function to recursively update the namespaces of an item
4687     """
4688     temp_item = ""
4689     i = item.tag.find("}")
4690     if i &gt;= 0:
4691         temp_item = item.tag[i + 1 :]
4692     else:
4693         temp_item = item.tag
4694     item.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4695     for child in item.getiterator():
4696         if isinstance(child.tag, str):
4697             temp_item = ""
4698             i = child.tag.find("}")
4699             if i &gt;= 0:
4700                 temp_item = child.tag[i + 1 :]
4701             else:
4702                 temp_item = child.tag
4703             child.tag = "{{{0}}}{1}".format(new_namespace, temp_item)
4704     return item
4705 def _updatePolicyElements(policy_item, regkey):
4706     """
4707     helper function to add the reg key to each policies element definitions if
4708     the key attribute is not defined to make xpath searching easier for each
4709     child in the policy &lt;elements&gt; item
4710     """
4711     for child in policy_item.getiterator():
4712         if "valueName" in child.attrib:
4713             if "key" not in child.attrib:
4714                 child.attrib["key"] = regkey
4715     return policy_item
4716 def _remove_unicode_encoding(xml_file):
4717     """
4718     attempts to remove the "encoding='unicode'" from an xml file
4719     as lxml does not support that on a windows node currently
4720     see issue #38100 (Search.adml)
4721     For some reason this file is encoded 'utf-16'
4722     """
4723     with salt.utils.files.fopen(xml_file, "rb") as f:
4724         xml_content = f.read()
4725     modified_xml = re.sub(
4726         r' encoding=[\'"]+unicode[\'"]+', "", xml_content.decode("utf-16"), count=1
4727     )
4728     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4729     return xml_tree
4730 def _remove_invalid_xmlns(xml_file):
4731     """
4732     Attempts to remove an invalid xmlns entry in newer versions of
4733     WindowsDefender.adml
4734     xmlns="http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions"
4735     For some reason this file is encoded 'utf-8'
4736     """
4737     with salt.utils.files.fopen(xml_file, "rb") as f:
4738         xml_content = f.read()
4739     modified_xml = re.sub(
4740         r' xmlns=[\'"]+.*[\'"]+', "", xml_content.decode("utf-8"), count=1
4741     )
4742     xml_tree = lxml.etree.parse(io.StringIO(modified_xml))
4743     return xml_tree
4744 def _parse_xml(adm_file):
4745     """
4746     Parse the admx/adml file. There are 3 scenarios (so far) that we'll likely
4747     encounter:
4748     1. Valid File
4749     2. invalid encoding (encoding="unicode") which the lxml library doesn't
4750        recognize
4751     3. invalid xmlns entry in the xml header, which the lxml library doesn't
4752        recognize
4753     """
4754     parser = lxml.etree.XMLParser(remove_comments=True)
4755     modified_xml = ""
4756     with salt.utils.files.fopen(adm_file, "rb") as rfh:
4757         file_hash = "{:X}".format(zlib.crc32(rfh.read()) &amp; 0xFFFFFFFF)
4758     name, ext = os.path.splitext(os.path.basename(adm_file))
4759     hashed_filename = "{}-{}{}".format(name, file_hash, ext)
4760     cache_dir = os.path.join(__opts__["cachedir"], "lgpo", "policy_defs")
4761     if not os.path.exists(cache_dir):
4762         os.makedirs(cache_dir)
4763     out_file = os.path.join(cache_dir, hashed_filename)
4764     if not os.path.isfile(out_file):
4765         log.debug("LGPO: Generating policy template cache for %s%s", name, ext)
4766         file_list = glob.glob(os.path.join(cache_dir, "{}*{}".format(name, ext)))
4767         for file_path in file_list:
4768             os.remove(file_path)
4769         with salt.utils.files.fopen(adm_file, "rb") as rfh:
4770             encoding = "utf-8"
4771             raw = rfh.read()
4772             try:
4773                 raw = raw.decode(encoding)
4774             except UnicodeDecodeError:
4775                 log.trace("LGPO: Detecting encoding")
4776                 encoding = "utf-16"
4777                 raw = raw.decode(encoding)
4778             for line in raw.split("\r\n"):
4779                 if 'key="' in line:
4780                     start = line.index('key="')
4781                     q1 = line[start:].index('"') + start
4782                     q2 = line[q1 + 1 :].index('"') + q1 + 1
4783                     line = line.replace(line[start:q2], line[start:q2].lower())
4784                     found_key = True
4785                 modified_xml += line + "\r\n"
4786         modified_xml = modified_xml.replace("\u201c", '"').replace("\u201d", '"')
4787         modified_xml = modified_xml.replace("\u2018", "'").replace("\u2019", "'")
4788         modified_xml = modified_xml.replace("\u2013", "-").replace("\u2014", "-")
4789         with salt.utils.files.fopen(out_file, "wb") as wfh:
4790             wfh.write(modified_xml.encode(encoding))
4791     try:
4792         xml_tree = lxml.etree.parse(out_file, parser=parser)
4793     except lxml.etree.XMLSyntaxError:
4794         try:
4795             xml_tree = _remove_unicode_encoding(out_file)
4796         except lxml.etree.XMLSyntaxError:
4797             xml_tree = _remove_invalid_xmlns(out_file)
4798     return xml_tree
4799 def _load_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4800     """
4801     helper function to process all ADMX files in the specified policy_def_path
4802     and build a single XML doc that we can search/use for ADMX policy processing
4803     """
4804     display_language_fallback = INSTALL_LANGUAGE
4805     t_policy_definitions = lxml.etree.Element("policyDefinitions")
4806     t_policy_definitions.append(lxml.etree.Element("categories"))
4807     t_policy_definitions.append(lxml.etree.Element("policies"))
4808     t_policy_definitions.append(lxml.etree.Element("policyNamespaces"))
4809     t_policy_definition_resources = lxml.etree.Element("policyDefinitionResources")
4810     policydefs_policies_xpath = etree.XPath("/policyDefinitions/policies")
4811     policydefs_categories_xpath = etree.XPath("/policyDefinitions/categories")
4812     policydefs_policyns_xpath = etree.XPath("/policyDefinitions/policyNamespaces")
4813     policydefs_resources_localname_xpath = etree.XPath(
4814         '//*[local-name() = "policyDefinitionResources"]/*'
4815     )
4816     policydef_resources_xpath = etree.XPath("/policyDefinitionResources")
4817     for root, dirs, files in salt.utils.path.os_walk(path):
4818         if root == path:
4819             for t_admx_file in files:
4820                 admx_file_name, admx_file_ext = os.path.splitext(t_admx_file)
4821                 if not admx_file_ext == ".admx":
4822                     log.debug("%s is not an ADMX file", t_admx_file)
4823                     continue
4824                 admx_file = os.path.join(root, t_admx_file)
4825                 try:
4826                     xml_tree = _parse_xml(admx_file)
4827                 except lxml.etree.XMLSyntaxError:
4828                     log.error(
4829                         "An error was found while processing admx "
4830                         "file %s, all policies from this file will "
4831                         "be unavailable via this module",
4832                         admx_file,
4833                     )
4834                     continue
4835                 namespaces = xml_tree.getroot().nsmap
4836                 namespace_string = ""
4837                 if None in namespaces:
4838                     namespaces["None"] = namespaces[None]
4839                     namespaces.pop(None)
4840                     namespace_string = "None:"
4841                 this_namespace = xml_tree.xpath(
4842                     "/{0}policyDefinitions/{0}policyNamespaces/{0}target/@namespace".format(
4843                         namespace_string
4844                     ),
4845                     namespaces=namespaces,
4846                 )[0]
4847                 categories = xml_tree.xpath(
4848                     "/{0}policyDefinitions/{0}categories/{0}category".format(
4849                         namespace_string
4850                     ),
4851                     namespaces=namespaces,
4852                 )
4853                 for category in categories:
4854                     temp_cat = category
4855                     temp_cat = _updateNamespace(temp_cat, this_namespace)
4856                     policydefs_categories_xpath(t_policy_definitions)[0].append(
4857                         temp_cat
4858                     )
4859                 policies = xml_tree.xpath(
4860                     "/{0}policyDefinitions/{0}policies/{0}policy".format(
4861                         namespace_string
4862                     ),
4863                     namespaces=namespaces,
4864                 )
4865                 for policy in policies:
4866                     temp_pol = policy
4867                     temp_pol = _updateNamespace(temp_pol, this_namespace)
4868                     if "key" in temp_pol.attrib:
4869                         temp_pol = _updatePolicyElements(
4870                             temp_pol, temp_pol.attrib["key"]
4871                         )
4872                     policydefs_policies_xpath(t_policy_definitions)[0].append(temp_pol)
4873                 policy_namespaces = xml_tree.xpath(
4874                     "/{0}policyDefinitions/{0}policyNamespaces/{0}*".format(
4875                         namespace_string
4876                     ),
4877                     namespaces=namespaces,
4878                 )
4879                 for policy_ns in policy_namespaces:
4880                     temp_ns = policy_ns
4881                     temp_ns = _updateNamespace(temp_ns, this_namespace)
4882                     policydefs_policyns_xpath(t_policy_definitions)[0].append(temp_ns)
4883                 adml_file = os.path.join(root, language, admx_file_name + ".adml")
4884                 if not __salt__["file.file_exists"](adml_file):
4885                     log.info(
4886                         "An ADML file in the specified ADML language "
4887                         '"%s" does not exist for the ADMX "%s", the '
4888                         "the abbreviated language code will be tried.",
4889                         language,
4890                         t_admx_file,
4891                     )
4892                     adml_file = os.path.join(
4893                         root, language.split("-")[0], admx_file_name + ".adml"
4894                     )
4895                     if not __salt__["file.file_exists"](adml_file):
4896                         log.info(
4897                             "An ADML file in the specified ADML language "
4898                             'code %s does not exist for the ADMX "%s", '
4899                             "the fallback language will be tried.",
4900                             language[:2],
4901                             t_admx_file,
4902                         )
4903                         adml_file = os.path.join(
4904                             root, display_language_fallback, admx_file_name + ".adml"
4905                         )
4906                         if not __salt__["file.file_exists"](adml_file):
4907                             log.info(
4908                                 "An ADML file in the specified ADML "
4909                                 'fallback language "%s" '
4910                                 'does not exist for the ADMX "%s" '
4911                                 "the abbreviated fallback language code "
4912                                 "will be tried.",
4913                                 display_language_fallback,
4914                                 t_admx_file,
4915                             )
4916                             adml_file = os.path.join(
4917                                 root,
4918                                 display_language_fallback.split("-")[0],
4919                                 admx_file_name + ".adml",
4920                             )
4921                             if not __salt__["file.file_exists"](adml_file):
4922                                 raise SaltInvocationError(
4923                                     "An ADML file in the specified ADML language "
4924                                     '"{}" and the fallback language "{}" do not '
4925                                     'exist for the ADMX "{}".'.format(
4926                                         language, display_language_fallback, t_admx_file
4927                                     )
4928                                 )
4929                 try:
4930                     xml_tree = _parse_xml(adml_file)
4931                 except lxml.etree.XMLSyntaxError:
4932                     log.error(
4933                         "An error was found while processing adml "
4934                         "file %s, all policies from this file will "
4935                         "be unavailable via this module",
4936                         adml_file,
4937                     )
4938                     continue
4939                 if None in namespaces:
4940                     namespaces["None"] = namespaces[None]
4941                     namespaces.pop(None)
4942                 policydefs_resources = policydefs_resources_localname_xpath(xml_tree)
4943                 for policydefs_resource in policydefs_resources:
4944                     t_poldef = policydefs_resource
4945                     t_poldef = _updateNamespace(t_poldef, this_namespace)
4946                     policydef_resources_xpath(t_policy_definition_resources)[0].append(
4947                         t_poldef
4948                     )
4949     __context__["lgpo.policy_definitions"] = t_policy_definitions
4950     __context__["lgpo.policy_resources"] = t_policy_definition_resources
4951 def _get_policy_definitions(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4952     if "lgpo.policy_definitions" not in __context__:
4953         log.debug("LGPO: Loading policy definitions")
4954         _load_policy_definitions(path=path, language=language)
4955     return __context__["lgpo.policy_definitions"]
4956 def _get_policy_resources(path="c:\\Windows\\PolicyDefinitions", language="en-US"):
4957     if "lgpo.policy_resources" not in __context__:
4958         log.debug("LGPO: Loading policy resources")
4959         _load_policy_definitions(path=path, language=language)
4960     return __context__["lgpo.policy_resources"]
4961 def _buildElementNsmap(using_elements):
4962     """
4963     build a namespace map for an ADMX element
4964     """
4965     thisMap = {}
4966     for e in using_elements:
4967         thisMap[e.attrib["prefix"]] = e.attrib["namespace"]
4968     return thisMap
4969 def _get_advaudit_defaults(option=None):
4970     """
4971     Loads audit.csv defaults into a dict in __context__ called
4972     'lgpo.audit_defaults'. The dictionary includes fieldnames and all
4973     configurable policies as keys. The values are used to create/modify the
4974     ``audit.csv`` file. The first entry is `fieldnames` used to create the
4975     header for the csv file. The rest of the entries are the audit policy names.
4976     Sample data follows:
4977     {
4978         'fieldnames': ['Machine Name',
4979                        'Policy Target',
4980                        'Subcategory',
4981                        'Subcategory GUID',
4982                        'Inclusion Setting',
4983                        'Exclusion Setting',
4984                        'Setting Value'],
4985         'Audit Sensitive Privilege Use': {'Auditpol Name': 'Sensitive Privilege Use',
4986                                           'Exclusion Setting': '',
4987                                           'Inclusion Setting': 'No Auditing',
4988                                           'Machine Name': 'WIN-8FGT3E045SE',
4989                                           'Policy Target': 'System',
4990                                           'Setting Value': '0',
4991                                           'Subcategory': u'Audit Sensitive Privilege Use',
4992                                           'Subcategory GUID': '{0CCE9228-69AE-11D9-BED3-505054503030}'},
4993         'Audit Special Logon': {'Auditpol Name': 'Special Logon',
4994                                 'Exclusion Setting': '',
4995                                 'Inclusion Setting': 'No Auditing',
4996                                 'Machine Name': 'WIN-8FGT3E045SE',
4997                                 'Policy Target': 'System',
4998                                 'Setting Value': '0',
4999                                 'Subcategory': u'Audit Special Logon',
5000                                 'Subcategory GUID': '{0CCE921B-69AE-11D9-BED3-505054503030}'},
5001         'Audit System Integrity': {'Auditpol Name': 'System Integrity',
5002                                    'Exclusion Setting': '',
5003                                    'Inclusion Setting': 'No Auditing',
5004                                    'Machine Name': 'WIN-8FGT3E045SE',
5005                                    'Policy Target': 'System',
5006                                    'Setting Value': '0',
5007                                    'Subcategory': u'Audit System Integrity',
5008                                    'Subcategory GUID': '{0CCE9212-69AE-11D9-BED3-505054503030}'},
5009         ...
5010     }
5011     .. note::
5012         `Auditpol Name` designates the value to use when setting the value with
5013         the auditpol command
5014     Args:
5015         option (str): The item from the dictionary to return. If ``None`` the
5016             entire dictionary is returned. Default is ``None``
5017     Returns:
5018         dict: If ``None`` or one of the audit settings is passed
5019         list: If ``fieldnames`` is passed
5020     """
5021     if "lgpo.audit_defaults" not in __context__:
5022         log.debug("Loading auditpol defaults into __context__")
5023         dump = __utils__["auditpol.get_auditpol_dump"]()
5024         reader = csv.DictReader(dump)
5025         audit_defaults = {"fieldnames": reader.fieldnames}
5026         for row in reader:
5027             row["Machine Name"] = ""
5028             row["Auditpol Name"] = row["Subcategory"]
5029             if row["Subcategory"] == "Central Policy Staging":
5030                 row["Subcategory"] = "Audit Central Access Policy Staging"
5031             elif row["Subcategory"] == "Plug and Play Events":
5032                 row["Subcategory"] = "Audit PNP Activity"
5033             elif row["Subcategory"] == "Token Right Adjusted Events":
5034                 row["Subcategory"] = "Audit Token Right Adjusted"
5035             else:
5036                 row["Subcategory"] = "Audit {}".format(row["Subcategory"])
5037             audit_defaults[row["Subcategory"]] = row
5038         __context__["lgpo.audit_defaults"] = audit_defaults
5039     if option:
5040         return __context__["lgpo.audit_defaults"][option]
5041     else:
5042         return __context__["lgpo.audit_defaults"]
5043 def _advaudit_check_csv():
5044     """
5045     This function checks for the existence of the `audit.csv` file here:
5046     `C:\\Windows\\security\\audit`
5047     If the file does not exist, then it copies the `audit.csv` file from the
5048     Group Policy location:
5049     `C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit`
5050     file is created.
5051     """
5052     system_root <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.environ.get("SystemRoot", "C:\\Windows")
5053     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
5054     f_audit_gpo = os.path.join(
5055         system_root,
5056         "System32",
5057         "GroupPolicy",
5058         "Machine",
5059         "Microsoft",
5060         "Windows NT",
5061         "Audit",
5062         "audit.csv",
5063     )
5064     if not __salt__["file.file_exists"](</b></font>f_audit):
5065         if __salt__["file.file_exists"](f_audit_gpo):
5066             __salt__["file.copy"](f_audit_gpo, f_audit)
5067         else:
5068             field_names = _get_advaudit_defaults("fieldnames")
5069             __salt__["file.makedirs"](f_audit)
5070             __salt__["file.write"](f_audit, ",".join(field_names))
5071 def _get_advaudit_value(option, refresh=False):
5072     """
5073     Get the Advanced Auditing policy as configured in
5074     ``C:\\Windows\\Security\\Audit\\audit.csv``
5075     Args:
5076         option (str):
5077             The name of the setting as it appears in audit.csv
5078         refresh (bool):
5079             Refresh secedit data stored in __context__. This is needed for
5080             testing where the state is setting the value, but the module that
5081             is checking the value has its own __context__.
5082     Returns:
5083         bool: ``True`` if successful, otherwise ``False``
5084     """
5085     if "lgpo.adv_audit_data" not in __context__ or refresh is True:
5086         system_root = os.environ.get("SystemRoot", "C:\\Windows")
5087         f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
5088         _advaudit_check_csv()
5089         audit_settings = {}
5090         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
5091             reader = csv.DictReader(csv_file)
5092             for row in reader:
5093                 audit_settings.update({row["Subcategory"]: row["Setting Value"]})
5094         __context__["lgpo.adv_audit_data"] = audit_settings
5095     return __context__["lgpo.adv_audit_data"].get(option, None)
5096 def _set_advaudit_file_data(option, value):
5097     """
5098     Helper function that sets the Advanced Audit settings in the two .csv files
5099     on Windows. Those files are located at:
5100     C:\\Windows\\Security\\Audit\\audit.csv
5101     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
5102     Args:
5103         option (str): The name of the option to set
5104         value (str): The value to set. ['None', '0', '1', '2', '3']
5105     Returns:
5106     """
5107     system_root <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.environ.get("SystemRoot", "C:\\Windows")
5108     f_audit = os.path.join(system_root, "security", "audit", "audit.csv")
5109     f_audit_gpo = os.path.join(</b></font>
5110         system_root,
5111         "System32",
5112         "GroupPolicy",
5113         "Machine",
5114         "Microsoft",
5115         "Windows NT",
5116         "Audit",
5117         "audit.csv",
5118     )
5119     f_temp = tempfile.NamedTemporaryFile(
5120         mode="w", delete=False, suffix=".csv", prefix="audit"
5121     )
5122     auditpol_values = {
5123         "None": "No Auditing",
5124         "0": "No Auditing",
5125         "1": "Success",
5126         "2": "Failure",
5127         "3": "Success and Failure",
5128     }
5129     _advaudit_check_csv()
5130     try:
5131         with salt.utils.files.fopen(f_audit, mode="r") as csv_file:
5132             reader = csv.DictReader(csv_file)
5133             with salt.utils.files.fopen(f_temp.name, mode="w") as tmp_file:
5134                 writer = csv.DictWriter(tmp_file, fieldnames=reader.fieldnames)
5135                 writer.writeheader()
5136                 value_written = False
5137                 for row in reader:
5138                     if row["Subcategory"] == option:
5139                         if not value == "None":
5140                             row["Inclusion Setting"] = auditpol_values[value]
5141                             row["Setting Value"] = value
5142                             log.trace("LGPO: Setting %s to %s", option, value)
5143                             writer.writerow(row)
5144                         else:
5145                             log.trace("LGPO: Removing %s", option)
5146                         value_written = True
5147                     else:
5148                         writer.writerow(row)
5149                 if not value_written:
5150                     if not value == "None":
5151                         log.trace("LGPO: Setting %s to %s", option, value)
5152                         defaults = _get_advaudit_defaults(option)
5153                         writer.writerow(
5154                             {
5155                                 "Machine Name": defaults["Machine Name"],
5156                                 "Policy Target": defaults["Policy Target"],
5157                                 "Subcategory": defaults["Subcategory"],
5158                                 "Subcategory GUID": defaults["Subcategory GUID"],
5159                                 "Inclusion Setting": auditpol_values[value],
5160                                 "Exclusion Setting": defaults["Exclusion Setting"],
5161                                 "Setting Value": value,
5162                             }
5163                         )
5164                     value_written = True
5165         if value_written:
5166             __salt__["file.copy"](f_temp.name, f_audit, remove_existing=True)
5167             __salt__["file.makedirs"](f_audit_gpo)
5168             __salt__["file.copy"](f_temp.name, f_audit_gpo, remove_existing=True)
5169     finally:
5170         f_temp.close()
5171         __salt__["file.remove"](f_temp.name)
5172     return value_written
5173 def _set_advaudit_pol_data(option, value):
5174     """
5175     Helper function that updates the current applied settings to match what has
5176     just been set in the audit.csv files. We're doing it this way instead of
5177     running `gpupdate`
5178     Args:
5179         option (str): The name of the option to set
5180         value (str): The value to set. ['None', '0', '1', '2', '3']
5181     Returns:
5182         bool: ``True`` if successful, otherwise ``False``
5183     """
5184     auditpol_values = {
5185         "None": "No Auditing",
5186         "0": "No Auditing",
5187         "1": "Success",
5188         "2": "Failure",
5189         "3": "Success and Failure",
5190     }
5191     defaults = _get_advaudit_defaults(option)
5192     return __utils__["auditpol.set_setting"](
5193         name=defaults["Auditpol Name"], value=auditpol_values[value]
5194     )
5195 def _set_advaudit_value(option, value):
5196     """
5197     Helper function to update the Advanced Audit policy on the machine. This
5198     function modifies the two ``audit.csv`` files in the following locations:
5199     C:\\Windows\\Security\\Audit\\audit.csv
5200     C:\\Windows\\System32\\GroupPolicy\\Machine\\Microsoft\\Windows NT\\Audit\\audit.csv
5201     Then it applies those settings using ``auditpol``
5202     After that, it updates ``__context__`` with the new setting
5203     Args:
5204         option (str): The name of the option to set
5205         value (str): The value to set. ['None', '0', '1', '2', '3']
5206     Returns:
5207         bool: ``True`` if successful, otherwise ``False``
5208     """
5209     if not _set_advaudit_file_data(option=option, value=value):
5210         raise CommandExecutionError("Failed to set audit.csv option: {}".format(option))
5211     if not _set_advaudit_pol_data(option=option, value=value):
5212         log.error(
5213             "Failed to apply audit setting: %s\n"
5214             "Policy will take effect on next GPO update",
5215             option,
5216         )
5217     if "lgpo.adv_audit_data" not in __context__:
5218         _get_advaudit_value(option)
5219     if value is None:
5220         log.debug("LGPO: Removing Advanced Audit data: %s", option)
5221         __context__["lgpo.adv_audit_data"].pop(option)
5222     else:
5223         log.debug("LGPO: Updating Advanced Audit data: %s: %s", option, value)
5224         __context__["lgpo.adv_audit_data"][option] = value
5225     return True
5226 def _get_netsh_value(profile, option):
5227     if "lgpo.netsh_data" not in __context__:
5228         __context__["lgpo.netsh_data"] = {}
5229     if profile not in __context__["lgpo.netsh_data"]:
5230         log.debug("LGPO: Loading netsh data for %s profile", profile)
5231         settings = salt.utils.win_lgpo_netsh.get_all_settings(
5232             profile=profile, store="lgpo"
5233         )
5234         __context__["lgpo.netsh_data"].update({profile: settings})
5235     log.trace(
5236         "LGPO: netsh returning value: %s",
5237         __context__["lgpo.netsh_data"][profile][option],
5238     )
5239     return __context__["lgpo.netsh_data"][profile][option]
5240 def _set_netsh_value(profile, section, option, value):
5241     if section not in ("firewallpolicy", "settings", "logging", "state"):
5242         raise ValueError("LGPO: Invalid section: {}".format(section))
5243     log.trace(
5244         "LGPO: Setting the following\nProfile: %s\nSection: %s\nOption: %s\nValue: %s",
5245         profile,
5246         section,
5247         option,
5248         value,
5249     )
5250     if section == "firewallpolicy":
5251         salt.utils.win_lgpo_netsh.set_firewall_settings(
5252             profile=profile,
5253             inbound=value if option == "Inbound" else None,
5254             outbound=value if option == "Outbound" else None,
5255             store="lgpo",
5256         )
5257     if section == "settings":
5258         salt.utils.win_lgpo_netsh.set_settings(
5259             profile=profile, setting=option, value=value, store="lgpo"
5260         )
5261     if section == "state":
5262         salt.utils.win_lgpo_netsh.set_state(profile=profile, state=value, store="lgpo")
5263     if section == "logging":
5264         if option in ("FileName", "MaxFileSize"):
5265             if value == "Not configured":
5266                 value = "notconfigured"
5267         if option.startswith("Log"):
5268             option = option[3:]
5269         salt.utils.win_lgpo_netsh.set_logging_settings(
5270             profile=profile, setting=option, value=value, store="lgpo"
5271         )
5272     log.trace("LGPO: Clearing netsh data for %s profile", profile)
5273     __context__["lgpo.netsh_data"].pop(profile)
5274     return True
5275 def _load_secedit_data():
5276     """
5277     Helper function that loads secedit data. It runs `secedit /export /cfg
5278     &lt;file_name&gt;` which creates a file that contains the secedit data.
5279     Returns:
5280         str: The contents of the file generated by the secedit command
5281     """
5282     f_exp = os.path.join(__opts__["cachedir"], "secedit-{}.txt".format(UUID))
5283     try:
5284         __salt__["cmd.run"](["secedit", "/export", "/cfg", f_exp])
5285         with salt.utils.files.fopen(f_exp, encoding="utf-16") as fp:
5286             secedit_data = fp.readlines()
5287         return secedit_data
5288     finally:
5289         if __salt__["file.file_exists"](f_exp):
5290             __salt__["file.remove"](f_exp)
5291 def _get_secedit_data(refresh=False):
5292     """
5293     Helper function that returns the secedit data in __context__ if it exists
5294     and puts the secedit data in __context__ if it does not.
5295     Args:
5296         refresh (bool):
5297             Refresh secedit data stored in __context__. This is needed for
5298             testing where the state is setting the value, but the module that
5299             is checking the value has its own __context__.
5300     Returns:
5301         str: secedit data from __context__
5302     """
5303     if "lgpo.secedit_data" not in __context__ or refresh is True:
5304         log.debug("LGPO: Loading secedit data")
5305         __context__["lgpo.secedit_data"] = _load_secedit_data()
5306     return __context__["lgpo.secedit_data"]
5307 def _get_secedit_value(option):
5308     """
5309     Helper function that looks for the passed option in the secedit data
5310     """
5311     secedit_data = _get_secedit_data()
5312     for _line in secedit_data:
5313         if _line.startswith(option):
5314             return _line.split("=")[1].strip()
5315     return "Not Defined"
5316 def _write_secedit_data(inf_data):
5317     """
5318     Helper function to write secedit data to the database
5319     """
5320     f_sdb = os.path.join(os.getenv("WINDIR"), "security", "database", "salt.sdb")
5321     f_inf = os.path.join(__opts__["cachedir"], "secedit-{}.inf".format(UUID))
5322     try:
5323         with salt.utils.files.fopen(f_inf, "w", encoding="utf-16") as fp:
5324             fp.write(inf_data)
5325         cmd = ["secedit", "/import", "/db", f_sdb, "/cfg", f_inf]
5326         retcode = __salt__["cmd.retcode"](cmd)
5327         if not retcode == 0:
5328             log.debug("Secedit failed to import template data")
5329             return False
5330         cmd = ["secedit", "/configure", "/db", f_sdb]
5331         retcode = __salt__["cmd.retcode"](cmd)
5332         if not retcode == 0:
5333             log.debug("Secedit failed to apply security database")
5334             return False
5335         __context__.pop("lgpo.secedit_data", None)
5336         return True
5337     finally:
5338         if __salt__["file.file_exists"](f_inf):
5339             __salt__["file.remove"](f_inf)
5340 def _transform_value(value, policy, transform_type):
5341     """
5342     helper function to transform the policy value into something that more
5343     closely matches how the policy is displayed in the gpedit GUI
5344     """
5345     t_kwargs = {}
5346     if "Transform" in policy:
5347         if transform_type in policy["Transform"]:
5348             _policydata = _policy_info()
5349             if transform_type + "Args" in policy["Transform"]:
5350                 t_kwargs = policy["Transform"][transform_type + "Args"]
5351             return getattr(_policydata, policy["Transform"][transform_type])(
5352                 value, **t_kwargs
5353             )
5354         else:
5355             return value
5356     else:
5357         if "Registry" in policy:
5358             if value == "(value not set)":
5359                 return "Not Defined"
5360         return value
5361 def _validateSetting(value, policy):
5362     """
5363     helper function to validate specified value is appropriate for the policy
5364     if the 'Settings' key is a list, the value will check that it is in the list
5365     if the 'Settings' key is a dict we will try to execute the function name
5366         from the 'Function' key, passing the value and additional arguments from
5367         the 'Args' dict
5368     if the 'Settings' key is None, we won't do any validation and just return
5369         True
5370     if the Policy has 'Children', we'll validate their settings too
5371     """
5372     log.debug("validating %s for policy %s", value, policy)
5373     if "Settings" in policy:
5374         if policy["Settings"]:
5375             if isinstance(policy["Settings"], list):
5376                 if value not in policy["Settings"]:
5377                     return False
5378             elif isinstance(policy["Settings"], dict):
5379                 _policydata = _policy_info()
5380                 if not getattr(_policydata, policy["Settings"]["Function"])(
5381                     value, **policy["Settings"]["Args"]
5382                 ):
5383                     return False
5384     else:
5385         return True
5386     return True
5387 def _addAccountRights(sidObject, user_right):
5388     """
5389     helper function to add an account right to a user
5390     """
5391     try:
5392         if sidObject:
5393             _polHandle = win32security.LsaOpenPolicy(
5394                 None, win32security.POLICY_ALL_ACCESS
5395             )
5396             user_rights_list = [user_right]
5397             _ret = win32security.LsaAddAccountRights(
5398                 _polHandle, sidObject, user_rights_list
5399             )
5400         return True
5401     except Exception as e:  # pylint: disable=broad-except
5402         log.exception("Error attempting to add account right, exception was %s", e)
5403         return False
5404 def _delAccountRights(sidObject, user_right):
5405     """
5406     helper function to remove an account right from a user
5407     """
5408     try:
5409         _polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5410         user_rights_list = [user_right]
5411         _ret = win32security.LsaRemoveAccountRights(
5412             _polHandle, sidObject, False, user_rights_list
5413         )
5414         return True
5415     except Exception as e:  # pylint: disable=broad-except
5416         log.exception("Error attempting to delete account right")
5417         return False
5418 def _getRightsAssignments(user_right):
5419     """
5420     helper function to return all the user rights assignments/users
5421     """
5422     sids = []
5423     polHandle = win32security.LsaOpenPolicy(None, win32security.POLICY_ALL_ACCESS)
5424     sids = win32security.LsaEnumerateAccountsWithUserRight(polHandle, user_right)
5425     return sids
5426 def _getAdmlDisplayName(adml_xml_data, display_name):
5427     """
5428     helper function to take the 'displayName' attribute of an element and find
5429     the value from the ADML data
5430     adml_xml_data :: XML data of all ADML files to search
5431     display_name :: the value of the displayName attribute from the ADMX entry
5432                     to search the ADML data for
5433     """
5434     if display_name.startswith("$(") and display_name.endswith(")"):
5435         display_name = re.sub(r"(^\$\(|\)$)", "", display_name)
5436         display_name = display_name.split(".")
5437         displayname_type = display_name[0]
5438         displayname_id = display_name[1]
5439         search_results = ADML_DISPLAY_NAME_XPATH(
5440             adml_xml_data,
5441             displayNameType=displayname_type,
5442             displayNameId=displayname_id,
5443         )
5444         if search_results:
5445             for result in search_results:
5446                 return result.text.strip()
5447     return None
5448 def _getAdmlPresentationRefId(adml_data, ref_id):
5449     """
5450     helper function to check for a presentation label for a policy element
5451     """
5452     search_results = adml_data.xpath(
5453         '//*[@*[local-name() = "refId"] = "{}"]'.format(ref_id)
5454     )
5455     alternate_label = ""
5456     if search_results:
5457         for result in search_results:
5458             the_localname = etree.QName(result.tag).localname
5459             if result.text is None:
5460                 presentation_element = PRESENTATION_ANCESTOR_XPATH(result)
5461                 if presentation_element:
5462                     presentation_element = presentation_element[0]
5463                     if TEXT_ELEMENT_XPATH(presentation_element):
5464                         for p_item in presentation_element:
5465                             if p_item == result:
5466                                 break
5467                             if etree.QName(p_item.tag).localname == "text":
5468                                 if getattr(p_item, "text"):
5469                                     alternate_label = getattr(p_item, "text").rstrip()
5470                         if alternate_label.endswith("."):
5471                             alternate_label = ""
5472             if the_localname in ["textBox", "comboBox"]:
5473                 label_items = result.xpath('.//*[local-name() = "label"]')
5474                 for label_item in label_items:
5475                     if label_item.text:
5476                         return label_item.text.rstrip().rstrip(":")
5477             elif the_localname in [
5478                 "decimalTextBox",
5479                 "longDecimalTextBox",
5480                 "dropdownList",
5481                 "listBox",
5482                 "checkBox",
5483                 "text",
5484                 "multiTextBox",
5485             ]:
5486                 if result.text:
5487                     return result.text.rstrip().rstrip(":")
5488                 else:
5489                     return alternate_label.rstrip(":")
5490     return None
5491 def _getFullPolicyName(
5492     policy_item, policy_name, return_full_policy_names, adml_language
5493 ):
5494     """
5495     helper function to retrieve the full policy name if needed
5496     """
5497     if policy_name in adm_policy_name_map[return_full_policy_names]:
5498         return adm_policy_name_map[return_full_policy_names][policy_name]
5499     adml_data = _get_policy_resources(language=adml_language)
5500     if return_full_policy_names and "displayName" in policy_item.attrib:
5501         fullPolicyName = _getAdmlDisplayName(
5502             adml_data, policy_item.attrib["displayName"]
5503         )
5504         if fullPolicyName:
5505             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5506             policy_name = fullPolicyName
5507     elif return_full_policy_names and "id" in policy_item.attrib:
5508         fullPolicyName = _getAdmlPresentationRefId(adml_data, policy_item.attrib["id"])
5509         if fullPolicyName:
5510             adm_policy_name_map[return_full_policy_names][policy_name] = fullPolicyName
5511             policy_name = fullPolicyName
5512     policy_name = policy_name.rstrip(":").rstrip()
5513     return policy_name
5514 def _regexSearchRegPolData(search_string, policy_data):
5515     """
5516     Helper function to do a regex search of a string value in policy_data.
5517     This is used to search the policy data from a registry.pol file or from
5518     gpt.ini
5519     Args:
5520         search_string (str): The string to search for
5521         policy_data (str): The data to be searched
5522     Returns:
5523         bool: ``True`` if the regex search_string is found, otherwise ``False``
5524     """
5525     if policy_data:
5526         if search_string:
5527             match = re.search(search_string, policy_data, re.IGNORECASE)
5528             if match:
5529                 return True
5530     return False
5531 def _getDataFromRegPolData(search_string, policy_data, return_value_name=False):
5532     """
5533     helper function to do a search of Policy data from a registry.pol file
5534     returns the "data" field
5535     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
5536     [key;value;type;size;data]
5537     """
5538     value = None
5539     values = []
5540     encoded_semicolon = ";".encode("utf-16-le")
5541     if return_value_name:
5542         values = {}
5543     if search_string:
5544         registry = Registry()
5545         if len(search_string.split(encoded_semicolon)) &gt;= 3:
5546             vtype = registry.vtype_reverse[
5547                 ord(search_string.split(encoded_semicolon)[2].decode("utf-32-le"))
5548             ]
5549         else:
5550             vtype = None
5551         search_string = re.escape(search_string)
5552         matches = re.finditer(search_string, policy_data, re.IGNORECASE)
5553         matches = [m for m in matches]
5554         if matches:
5555             for match in matches:
5556                 pol_entry = policy_data[
5557                     match.start() : (
5558                         policy_data.index("]".encode("utf-16-le"), match.end())
5559                     )
5560                 ].split(encoded_semicolon, 4)
5561                 if len(pol_entry) &gt;= 2:
5562                     valueName = pol_entry[1].decode("utf-16-le").rstrip(chr(0))
5563                 if len(pol_entry) &gt;= 5:
5564                     value = encoded_semicolon.join(pol_entry[4:])
5565                     if vtype == "REG_DWORD" or vtype == "REG_QWORD":
5566                         if value:
5567                             if vtype == "REG_DWORD":
5568                                 for v in struct.unpack(b"I", value):
5569                                     value = v
5570                             elif vtype == "REG_QWORD":
5571                                 for v in struct.unpack(b"Q", value):
5572                                     value = v
5573                         else:
5574                             value = 0
5575                     elif vtype == "REG_MULTI_SZ":
5576                         value = value.decode("utf-16-le").rstrip(chr(0)).split(chr(0))
5577                     else:
5578                         value = value.decode("utf-16-le").rstrip(chr(0))
5579                 if return_value_name:
5580                     log.trace("we want value names and the value")
5581                     values[valueName] = value
5582                 elif len(matches) &gt; 1:
5583                     log.trace("we have multiple matches, we will return a list")
5584                     values.append(value)
5585     if values:
5586         value = values
5587     return value
5588 def _checkListItem(
5589     policy_element,
5590     policy_name,
5591     policy_key,
5592     xpath_object,
5593     policy_file_data,
5594     test_items=True,
5595 ):
5596     """
5597     helper function to process an enabled/disabled/true/falseList set
5598     if test_items is True, it will determine if the policy is enabled or
5599     disabled returning True if all items are configured in the registry.pol file
5600     and false if they are not
5601     if test_items is False, the expected strings for the items will be returned
5602     as a list
5603     returns True if the enabled/disabledList is 100% configured in the
5604     registry.pol file, otherwise returns False
5605     """
5606     xpath_string = (
5607         './/*[local-name() = "decimal" or local-name() = "delete"'
5608         ' or local-name() = "longDecimal" or local-name() = "string"]'
5609     )
5610     value_item_child_xpath = etree.XPath(xpath_string)
5611     expected_strings = []
5612     for list_element in xpath_object(policy_element):
5613         configured_items = 0
5614         required_items = 0
5615         for item in list_element:
5616             required_items = required_items + 1
5617             if "key" in item.attrib:
5618                 item_key = item.attrib["key"]
5619             else:
5620                 item_key = policy_key
5621             if "valueName" in item.attrib:
5622                 item_valuename = item.attrib["valueName"]
5623             else:
5624                 log.error(
5625                     "%s item with attributes %s in policy %s does not "
5626                     'have the required "valueName" attribute',
5627                     etree.QName(list_element).localname,
5628                     item.attrib,
5629                     policy_element.attrib,
5630                 )
5631                 break
5632             for value_item in value_item_child_xpath(item):
5633                 search_string = _processValueItem(
5634                     value_item, item_key, item_valuename, policy_element, item
5635                 )
5636                 if test_items:
5637                     if _regexSearchRegPolData(
5638                         re.escape(search_string), policy_file_data
5639                     ):
5640                         configured_items = configured_items + 1
5641                         log.trace(
5642                             "found the search string in the pol file,"
5643                             "%s of %s items for policy %s are "
5644                             "configured in registry.pol",
5645                             configured_items,
5646                             required_items,
5647                             policy_name,
5648                         )
5649                 else:
5650                     expected_strings.append(search_string)
5651         if test_items:
5652             if required_items &gt; 0 and required_items == configured_items:
5653                 log.trace("%s all items are set", policy_name)
5654                 return True
5655     if test_items:
5656         return False
5657     else:
5658         return expected_strings
5659 def _checkValueItemParent(
5660     policy_element,
5661     policy_name,
5662     policy_key,
5663     policy_valueName,
5664     xpath_object,
5665     policy_file_data,
5666     check_deleted=False,
5667     test_item=True,
5668 ):
5669     """
5670     helper function to process the parent of a value item object
5671     if test_item is True, it will determine if the policy is enabled/disabled
5672     returns True if the value is configured in the registry.pol file, otherwise returns False
5673     if test_item is False, the expected search string will be returned
5674     value type parents:
5675         boolean: https://msdn.microsoft.com/en-us/library/dn606009(v=vs.85).aspx
5676         enabledValue: https://msdn.microsoft.com/en-us/library/dn606006(v=vs.85).aspx
5677         disabledValue: https://msdn.microsoft.com/en-us/library/dn606001(v=vs.85).aspx
5678     """
5679     for element in xpath_object(policy_element):
5680         for value_item in element:
5681             search_string = _processValueItem(
5682                 value_item,
5683                 policy_key,
5684                 policy_valueName,
5685                 policy_element,
5686                 element,
5687                 check_deleted=check_deleted,
5688             )
5689             if not test_item:
5690                 return search_string
5691             if _regexSearchRegPolData(re.escape(search_string), policy_file_data):
5692                 log.trace(
5693                     "found the search string in the pol file, %s is configured",
5694                     policy_name,
5695                 )
5696                 return True
5697     return False
5698 def _encode_string(value):
5699     encoded_null = chr(0).encode("utf-16-le")
5700     if value is None:
5701         return encoded_null
5702     elif not isinstance(value, str):
5703         raise TypeError(
5704             "Value {} is not a string type\nType: {}".format(repr(value), type(value))
5705         )
5706     return b"".join([value.encode("utf-16-le"), encoded_null])
5707 def _buildKnownDataSearchString(
5708     reg_key, reg_valueName, reg_vtype, reg_data, check_deleted=False
5709 ):
5710     """
5711     helper function similar to _processValueItem to build a search string for a
5712     known key/value/type/data
5713     """
5714     registry = Registry()
5715     this_element_value = None
5716     expected_string = b""
5717     encoded_semicolon = ";".encode("utf-16-le")
5718     encoded_null = chr(0).encode("utf-16-le")
5719     if reg_key:
5720         reg_key = reg_key.encode("utf-16-le")
5721     if reg_valueName:
5722         reg_valueName = reg_valueName.encode("utf-16-le")
5723     if reg_data and not check_deleted:
5724         if reg_vtype == "REG_DWORD":
5725             this_element_value = struct.pack(b"I", int(reg_data))
5726         elif reg_vtype == "REG_QWORD":
5727             this_element_value = struct.pack(b"Q", int(reg_data))
5728         elif reg_vtype == "REG_SZ":
5729             this_element_value = _encode_string(reg_data)
5730     if check_deleted:
5731         reg_vtype = "REG_SZ"
5732         expected_string = b"".join(
5733             [
5734                 "[".encode("utf-16-le"),
5735                 reg_key,
5736                 encoded_null,
5737                 encoded_semicolon,
5738                 "**del.".encode("utf-16-le"),
5739                 reg_valueName,
5740                 encoded_null,
5741                 encoded_semicolon,
5742                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5743                 encoded_semicolon,
5744                 chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode("utf-32-le"),
5745                 encoded_semicolon,
5746                 " ".encode("utf-16-le"),
5747                 encoded_null,
5748                 "]".encode("utf-16-le"),
5749             ]
5750         )
5751     else:
5752         expected_string = b"".join(
5753             [
5754                 "[".encode("utf-16-le"),
5755                 reg_key,
5756                 encoded_null,
5757                 encoded_semicolon,
5758                 reg_valueName,
5759                 encoded_null,
5760                 encoded_semicolon,
5761                 chr(registry.vtype[reg_vtype]).encode("utf-32-le"),
5762                 encoded_semicolon,
5763                 chr(len(this_element_value)).encode("utf-32-le"),
5764                 encoded_semicolon,
5765                 this_element_value,
5766                 "]".encode("utf-16-le"),
5767             ]
5768         )
5769     return expected_string
5770 def _processValueItem(
5771     element,
5772     reg_key,
5773     reg_valuename,
5774     policy,
5775     parent_element,
5776     check_deleted=False,
5777     this_element_value=None,
5778 ):
5779     """
5780     helper function to process a value type item and generate the expected
5781     string in the Registry.pol file
5782     element - the element to process
5783     reg_key - the registry key associated with the element (some inherit from
5784               their parent policy)
5785     reg_valuename - the registry valueName associated with the element (some
5786                     inherit from their parent policy)
5787     policy - the parent policy element
5788     parent_element - the parent element (primarily passed in to differentiate
5789                      children of "elements" objects
5790     check_deleted - if the returned expected string should be for a deleted
5791                     value
5792     this_element_value - a specific value to place into the expected string
5793                          returned for "elements" children whose values are
5794                          specified by the user
5795     """
5796     registry = Registry()
5797     expected_string = None
5798     this_vtype = "REG_SZ"
5799     encoded_semicolon = ";".encode("utf-16-le")
5800     encoded_null = chr(0).encode("utf-16-le")
5801     if reg_key:
5802         reg_key = reg_key.encode("utf-16-le")
5803     if reg_valuename:
5804         reg_valuename = reg_valuename.encode("utf-16-le")
5805     if (
5806         etree.QName(element).localname == "decimal"
5807         and etree.QName(parent_element).localname != "elements"
5808     ):
5809         this_vtype = "REG_DWORD"
5810         if "value" in element.attrib:
5811             this_element_value = struct.pack(b"I", int(element.attrib["value"]))
5812         else:
5813             log.error(
5814                 "The %s child %s element for the policy with "
5815                 'attributes: %s does not have the required "value" '
5816                 "attribute. The element attributes are: %s",
5817                 etree.QName(parent_element).localname,
5818                 etree.QName(element).localname,
5819                 policy.attrib,
5820                 element.attrib,
5821             )
5822             return None
5823     elif (
5824         etree.QName(element).localname == "longDecimal"
5825         and etree.QName(parent_element).localname != "elements"
5826     ):
5827         this_vtype = "REG_QWORD"
5828         if "value" in element.attrib:
5829             this_element_value = struct.pack(b"Q", int(element.attrib["value"]))
5830         else:
5831             log.error(
5832                 "The %s child %s element for the policy with "
5833                 'attributes: %s does not have the required "value" '
5834                 "attribute. The element attributes are: %s",
5835                 etree.QName(parent_element).localname,
5836                 etree.QName(element).localname,
5837                 policy.attrib,
5838                 element.attrib,
5839             )
5840             return None
5841     elif etree.QName(element).localname == "string":
5842         this_vtype = "REG_SZ"
5843         this_element_value = _encode_string(element.text)
5844     elif etree.QName(parent_element).localname == "elements":
5845         standard_element_expected_string = True
5846         if etree.QName(element).localname == "boolean":
5847             if this_element_value is False:
5848                 check_deleted = True
5849             if not check_deleted:
5850                 this_vtype = "REG_DWORD"
5851             this_element_value = struct.pack("I", 1)
5852             standard_element_expected_string = False
5853         elif etree.QName(element).localname == "decimal":
5854             this_vtype = "REG_DWORD"
5855             requested_val = this_element_value
5856             if this_element_value is not None:
5857                 this_element_value = struct.pack(b"I", int(this_element_value))
5858             if "storeAsText" in element.attrib:
5859                 if element.attrib["storeAsText"].lower() == "true":
5860                     this_vtype = "REG_SZ"
5861                     if requested_val is not None:
5862                         this_element_value = str(requested_val).encode("utf-16-le")
5863             if check_deleted:
5864                 this_vtype = "REG_SZ"
5865         elif etree.QName(element).localname == "longDecimal":
5866             this_vtype = "REG_QWORD"
5867             requested_val = this_element_value
5868             if this_element_value is not None:
5869                 this_element_value = struct.pack(b"Q", int(this_element_value))
5870             if "storeAsText" in element.attrib:
5871                 if element.attrib["storeAsText"].lower() == "true":
5872                     this_vtype = "REG_SZ"
5873                     if requested_val is not None:
5874                         this_element_value = str(requested_val).encode("utf-16-le")
5875         elif etree.QName(element).localname == "text":
5876             this_vtype = "REG_SZ"
5877             if "expandable" in element.attrib:
5878                 if element.attrib["expandable"].lower() == "true":
5879                     this_vtype = "REG_EXPAND_SZ"
5880             if this_element_value is not None:
5881                 this_element_value = _encode_string(this_element_value)
5882         elif etree.QName(element).localname == "multiText":
5883             this_vtype = "REG_MULTI_SZ" if not check_deleted else "REG_SZ"
5884             if this_element_value is not None:
5885                 this_element_value = "{0}{1}{1}".format(
5886                     chr(0).join(this_element_value), chr(0)
5887                 )
5888         elif etree.QName(element).localname == "list":
5889             standard_element_expected_string = False
5890             del_keys = b""
5891             element_valuenames = []
5892             element_values = this_element_value
5893             if this_element_value is not None:
5894                 element_valuenames = [
5895                     str(z) for z in range(1, len(this_element_value) + 1)
5896                 ]
5897             if "additive" in element.attrib:
5898                 if element.attrib["additive"].lower() == "false":
5899                     del_keys = b"".join(
5900                         [
5901                             "[".encode("utf-16-le"),
5902                             reg_key,
5903                             encoded_null,
5904                             encoded_semicolon,
5905                             "**delvals.".encode("utf-16-le"),
5906                             encoded_null,
5907                             encoded_semicolon,
5908                             chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5909                             encoded_semicolon,
5910                             chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5911                                 "utf-32-le"
5912                             ),
5913                             encoded_semicolon,
5914                             " ".encode("utf-16-le"),
5915                             encoded_null,
5916                             "]".encode("utf-16-le"),
5917                         ]
5918                     )
5919             if "expandable" in element.attrib:
5920                 this_vtype = "REG_EXPAND_SZ"
5921             if element.attrib.get("explicitValue", "false").lower() == "true":
5922                 if this_element_value is not None:
5923                     element_valuenames = [str(k) for k in this_element_value.keys()]
5924                     element_values = [str(v) for v in this_element_value.values()]
5925             elif "valuePrefix" in element.attrib:
5926                 if element.attrib["valuePrefix"] != "":
5927                     if this_element_value is not None:
5928                         element_valuenames = [
5929                             "{}{}".format(element.attrib["valuePrefix"], k)
5930                             for k in element_valuenames
5931                         ]
5932             else:
5933                 if element_values is not None:
5934                     element_valuenames = [str(z) for z in element_values]
5935             if not check_deleted:
5936                 if this_element_value is not None:
5937                     log.trace(
5938                         "_processValueItem has an explicit element_value of %s",
5939                         this_element_value,
5940                     )
5941                     expected_string = del_keys
5942                     log.trace(
5943                         "element_valuenames == %s and element_values == %s",
5944                         element_valuenames,
5945                         element_values,
5946                     )
5947                     for i, item in enumerate(element_valuenames):
5948                         expected_string = expected_string + b"".join(
5949                             [
5950                                 "[".encode("utf-16-le"),
5951                                 reg_key,
5952                                 encoded_null,
5953                                 encoded_semicolon,
5954                                 element_valuenames[i].encode("utf-16-le"),
5955                                 encoded_null,
5956                                 encoded_semicolon,
5957                                 chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5958                                 encoded_semicolon,
5959                                 chr(
5960                                     len(
5961                                         "{}{}".format(element_values[i], chr(0)).encode(
5962                                             "utf-16-le"
5963                                         )
5964                                     )
5965                                 ).encode("utf-32-le"),
5966                                 encoded_semicolon,
5967                                 _encode_string(element_values[i]),
5968                                 "]".encode("utf-16-le"),
5969                             ]
5970                         )
5971                 else:
5972                     expected_string = del_keys + b"".join(
5973                         [
5974                             "[".encode("utf-16-le"),
5975                             reg_key,
5976                             encoded_null,
5977                             encoded_semicolon,
5978                         ]
5979                     )
5980             else:
5981                 expected_string = b"".join(
5982                     [
5983                         "[".encode("utf-16-le"),
5984                         reg_key,
5985                         encoded_null,
5986                         encoded_semicolon,
5987                         "**delvals.".encode("utf-16-le"),
5988                         encoded_null,
5989                         encoded_semicolon,
5990                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
5991                         encoded_semicolon,
5992                         chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
5993                             "utf-32-le"
5994                         ),
5995                         encoded_semicolon,
5996                         " ".encode("utf-16-le"),
5997                         encoded_null,
5998                         "]".encode("utf-16-le"),
5999                     ]
6000                 )
6001         elif etree.QName(element).localname == "enum":
6002             if this_element_value is not None:
6003                 pass
6004         if standard_element_expected_string and not check_deleted:
6005             if this_element_value is not None:
6006                 if isinstance(this_element_value, str):
6007                     log.debug("Converting %s to bytes", this_element_value)
6008                     this_element_value = this_element_value.encode("utf-32-le")
6009                 expected_string = b"".join(
6010                     [
6011                         "[".encode("utf-16-le"),
6012                         reg_key,
6013                         encoded_null,
6014                         encoded_semicolon,
6015                         reg_valuename,
6016                         encoded_null,
6017                         encoded_semicolon,
6018                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6019                         encoded_semicolon,
6020                         chr(len(this_element_value)).encode("utf-32-le"),
6021                         encoded_semicolon,
6022                         this_element_value,
6023                         "]".encode("utf-16-le"),
6024                     ]
6025                 )
6026             else:
6027                 expected_string = b"".join(
6028                     [
6029                         "[".encode("utf-16-le"),
6030                         reg_key,
6031                         encoded_null,
6032                         encoded_semicolon,
6033                         reg_valuename,
6034                         encoded_null,
6035                         encoded_semicolon,
6036                         chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6037                         encoded_semicolon,
6038                     ]
6039                 )
6040     if not expected_string:
6041         if etree.QName(element).localname == "delete" or check_deleted:
6042             expected_string = b"".join(
6043                 [
6044                     "[".encode("utf-16-le"),
6045                     reg_key,
6046                     encoded_null,
6047                     encoded_semicolon,
6048                     "**del.".encode("utf-16-le"),
6049                     reg_valuename,
6050                     encoded_null,
6051                     encoded_semicolon,
6052                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6053                     encoded_semicolon,
6054                     chr(len(" {}".format(chr(0)).encode("utf-16-le"))).encode(
6055                         "utf-32-le"
6056                     ),
6057                     encoded_semicolon,
6058                     " ".encode("utf-16-le"),
6059                     encoded_null,
6060                     "]".encode("utf-16-le"),
6061                 ]
6062             )
6063         else:
6064             expected_string = b"".join(
6065                 [
6066                     "[".encode("utf-16-le"),
6067                     reg_key,
6068                     encoded_null,
6069                     encoded_semicolon,
6070                     reg_valuename,
6071                     encoded_null,
6072                     encoded_semicolon,
6073                     chr(registry.vtype[this_vtype]).encode("utf-32-le"),
6074                     encoded_semicolon,
6075                     chr(len(this_element_value)).encode("utf-32-le"),
6076                     encoded_semicolon,
6077                     this_element_value,
6078                     "]".encode("utf-16-le"),
6079                 ]
6080             )
6081     return expected_string
6082 def _checkAllAdmxPolicies(
6083     policy_class,
6084     adml_language="en-US",
6085     return_full_policy_names=False,
6086     hierarchical_return=False,
6087     return_not_configured=False,
6088 ):
6089     """
6090     rewrite of _getAllAdminTemplateSettingsFromRegPolFile where instead of
6091     looking only at the contents of the file, we're going to loop through every
6092     policy and look in the registry.pol file to determine if it is
6093     enabled/disabled/not configured
6094     """
6095     log.trace("POLICY CLASS == %s", policy_class)
6096     module_policy_data = _policy_info()
6097     policy_file_data = _read_regpol_file(
6098         module_policy_data.admx_registry_classes[policy_class]["policy_path"]
6099     )
6100     admx_policies = []
6101     policy_vals = {}
6102     hierarchy = {}
6103     full_names = {}
6104     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6105     adml_policy_resources = _get_policy_resources(language=adml_language)
6106     if policy_file_data:
6107         log.trace("POLICY CLASS %s has file data", policy_class)
6108         policy_filedata_split = re.sub(
6109             salt.utils.stringutils.to_bytes(r"\]{}$".format(chr(0))),
6110             b"",
6111             re.sub(
6112                 salt.utils.stringutils.to_bytes(r"^\[{}".format(chr(0))),
6113                 b"",
6114                 re.sub(
6115                     re.escape(module_policy_data.reg_pol_header.encode("utf-16-le")),
6116                     b"",
6117                     policy_file_data,
6118                 ),
6119             ),
6120         ).split("][".encode("utf-16-le"))
6121         log.trace("Searching %s policies...", len(policy_filedata_split))
6122         start_time = time.time()
6123         for policy_item in policy_filedata_split:
6124             policy_item_key = (
6125                 policy_item.split("{};".format(chr(0)).encode("utf-16-le"))[0]
6126                 .decode("utf-16-le")
6127                 .lower()
6128             )
6129             if policy_item_key:
6130                 admx_items = REGKEY_XPATH(
6131                     admx_policy_definitions, keyvalue=policy_item_key
6132                 )
6133                 log.trace("Found %s policies for %s", len(admx_items), policy_item_key)
6134                 for admx_item in admx_items:
6135                     if etree.QName(admx_item).localname == "policy":
6136                         if admx_item not in admx_policies:
6137                             admx_policies.append(admx_item)
6138                     else:
6139                         for policy_item in POLICY_ANCESTOR_XPATH(admx_item):
6140                             if policy_item not in admx_policies:
6141                                 admx_policies.append(policy_item)
6142         log.trace("Search complete: %s seconds", time.time() - start_time)
6143         if return_not_configured:
6144             log.trace("Gathering non configured policies")
6145             start_time = time.time()
6146             not_configured_policies = ALL_CLASS_POLICY_XPATH(
6147                 admx_policy_definitions, registry_class=policy_class
6148             )
6149             for policy_item in admx_policies:
6150                 if policy_item in not_configured_policies:
6151                     not_configured_policies.remove(policy_item)
6152             for not_configured_policy in not_configured_policies:
6153                 not_configured_policy_namespace = not_configured_policy.nsmap[
6154                     not_configured_policy.prefix
6155                 ]
6156                 if not_configured_policy_namespace not in policy_vals:
6157                     policy_vals[not_configured_policy_namespace] = {}
6158                 policy_vals[not_configured_policy_namespace][
6159                     not_configured_policy.attrib["name"]
6160                 ] = "Not Configured"
6161                 if return_full_policy_names:
6162                     if not_configured_policy_namespace not in full_names:
6163                         full_names[not_configured_policy_namespace] = {}
6164                     full_names[not_configured_policy_namespace][
6165                         not_configured_policy.attrib["name"]
6166                     ] = _getFullPolicyName(
6167                         policy_item=not_configured_policy,
6168                         policy_name=not_configured_policy.attrib["name"],
6169                         return_full_policy_names=return_full_policy_names,
6170                         adml_language=adml_language,
6171                     )
6172                 log.trace(
6173                     "building hierarchy for non-configured item %s",
6174                     not_configured_policy.attrib["name"],
6175                 )
6176                 if not_configured_policy_namespace not in hierarchy:
6177                     hierarchy[not_configured_policy_namespace] = {}
6178                 hierarchy[not_configured_policy_namespace][
6179                     not_configured_policy.attrib["name"]
6180                 ] = _build_parent_list(
6181                     policy_definition=not_configured_policy,
6182                     return_full_policy_names=return_full_policy_names,
6183                     adml_language=adml_language,
6184                 )
6185             log.trace("Gathering complete: %s seconds", time.time() - start_time)
6186         log.trace("Examining %s policies...", len(admx_policies))
6187         start_time = time.time()
6188         for admx_policy in admx_policies:
6189             this_valuename = None
6190             this_policy_setting = "Not Configured"
6191             element_only_enabled_disabled = True
6192             explicit_enable_disable_value_setting = False
6193             if "key" in admx_policy.attrib:
6194                 this_key = admx_policy.attrib["key"]
6195             else:
6196                 log.error(
6197                     'policy item %s does not have the required "key" attribute',
6198                     admx_policy.attrib,
6199                 )
6200                 break
6201             if "valueName" in admx_policy.attrib:
6202                 this_valuename = admx_policy.attrib["valueName"]
6203             if "name" in admx_policy.attrib:
6204                 this_policyname = admx_policy.attrib["name"]
6205             else:
6206                 log.error(
6207                     'policy item %s does not have the required "name" attribute',
6208                     admx_policy.attrib,
6209                 )
6210                 break
6211             this_policynamespace = admx_policy.nsmap[admx_policy.prefix]
6212             if (
6213                 ENABLED_VALUE_XPATH(admx_policy)
6214                 and this_policy_setting == "Not Configured"
6215             ):
6216                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6217                     admx_policy
6218                 ):
6219                     element_only_enabled_disabled = False
6220                     explicit_enable_disable_value_setting = True
6221                 if _checkValueItemParent(
6222                     admx_policy,
6223                     this_policyname,
6224                     this_key,
6225                     this_valuename,
6226                     ENABLED_VALUE_XPATH,
6227                     policy_file_data,
6228                 ):
6229                     this_policy_setting = "Enabled"
6230                     log.trace(
6231                         "%s is enabled by detected ENABLED_VALUE_XPATH", this_policyname
6232                     )
6233                     if this_policynamespace not in policy_vals:
6234                         policy_vals[this_policynamespace] = {}
6235                     policy_vals[this_policynamespace][
6236                         this_policyname
6237                     ] = this_policy_setting
6238             if (
6239                 DISABLED_VALUE_XPATH(admx_policy)
6240                 and this_policy_setting == "Not Configured"
6241             ):
6242                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6243                     element_only_enabled_disabled = False
6244                     explicit_enable_disable_value_setting = True
6245                 if _checkValueItemParent(
6246                     admx_policy,
6247                     this_policyname,
6248                     this_key,
6249                     this_valuename,
6250                     DISABLED_VALUE_XPATH,
6251                     policy_file_data,
6252                 ):
6253                     this_policy_setting = "Disabled"
6254                     log.trace(
6255                         "%s is disabled by detected DISABLED_VALUE_XPATH",
6256                         this_policyname,
6257                     )
6258                     if this_policynamespace not in policy_vals:
6259                         policy_vals[this_policynamespace] = {}
6260                     policy_vals[this_policynamespace][
6261                         this_policyname
6262                     ] = this_policy_setting
6263             if (
6264                 ENABLED_LIST_XPATH(admx_policy)
6265                 and this_policy_setting == "Not Configured"
6266             ):
6267                 if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(
6268                     admx_policy
6269                 ):
6270                     element_only_enabled_disabled = False
6271                     explicit_enable_disable_value_setting = True
6272                 if _checkListItem(
6273                     admx_policy,
6274                     this_policyname,
6275                     this_key,
6276                     ENABLED_LIST_XPATH,
6277                     policy_file_data,
6278                 ):
6279                     this_policy_setting = "Enabled"
6280                     log.trace(
6281                         "%s is enabled by detected ENABLED_LIST_XPATH", this_policyname
6282                     )
6283                     if this_policynamespace not in policy_vals:
6284                         policy_vals[this_policynamespace] = {}
6285                     policy_vals[this_policynamespace][
6286                         this_policyname
6287                     ] = this_policy_setting
6288             if (
6289                 DISABLED_LIST_XPATH(admx_policy)
6290                 and this_policy_setting == "Not Configured"
6291             ):
6292                 if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
6293                     element_only_enabled_disabled = False
6294                     explicit_enable_disable_value_setting = True
6295                 if _checkListItem(
6296                     admx_policy,
6297                     this_policyname,
6298                     this_key,
6299                     DISABLED_LIST_XPATH,
6300                     policy_file_data,
6301                 ):
6302                     this_policy_setting = "Disabled"
6303                     log.trace(
6304                         "%s is disabled by detected DISABLED_LIST_XPATH",
6305                         this_policyname,
6306                     )
6307                     if this_policynamespace not in policy_vals:
6308                         policy_vals[this_policynamespace] = {}
6309                     policy_vals[this_policynamespace][
6310                         this_policyname
6311                     ] = this_policy_setting
6312             if not explicit_enable_disable_value_setting and this_valuename:
6313                 if _regexSearchRegPolData(
6314                     re.escape(
6315                         _buildKnownDataSearchString(
6316                             this_key, this_valuename, "REG_DWORD", "1"
6317                         )
6318                     ),
6319                     policy_file_data,
6320                 ):
6321                     this_policy_setting = "Enabled"
6322                     log.trace(
6323                         "%s is enabled by no explicit enable/disable list or value",
6324                         this_policyname,
6325                     )
6326                     if this_policynamespace not in policy_vals:
6327                         policy_vals[this_policynamespace] = {}
6328                     policy_vals[this_policynamespace][
6329                         this_policyname
6330                     ] = this_policy_setting
6331                 elif _regexSearchRegPolData(
6332                     re.escape(
6333                         _buildKnownDataSearchString(
6334                             this_key,
6335                             this_valuename,
6336                             "REG_DWORD",
6337                             None,
6338                             check_deleted=True,
6339                         )
6340                     ),
6341                     policy_file_data,
6342                 ):
6343                     this_policy_setting = "Disabled"
6344                     log.trace(
6345                         "%s is disabled by no explicit enable/disable list or value",
6346                         this_policyname,
6347                     )
6348                     if this_policynamespace not in policy_vals:
6349                         policy_vals[this_policynamespace] = {}
6350                     policy_vals[this_policynamespace][
6351                         this_policyname
6352                     ] = this_policy_setting
6353             if ELEMENTS_XPATH(admx_policy):
6354                 if element_only_enabled_disabled or this_policy_setting == "Enabled":
6355                     required_elements = {}
6356                     configured_elements = {}
6357                     policy_disabled_elements = 0
6358                     for elements_item in ELEMENTS_XPATH(admx_policy):
6359                         for child_item in elements_item:
6360                             this_element_name = _getFullPolicyName(
6361                                 policy_item=child_item,
6362                                 policy_name=child_item.attrib["id"],
6363                                 return_full_policy_names=return_full_policy_names,
6364                             )
6365                             required_elements[this_element_name] = None
6366                             child_key <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= child_item.attrib.get("key", this_key)
6367                             child_valuename = child_item.attrib.get(
6368                                 "valueName", this_valuename
6369                             )
6370                             if etree.QName(child_item).</b></font>localname == "boolean":
6371                                 if child_item is not None:
6372                                     if (
6373                                         TRUE_VALUE_XPATH(child_item)
6374                                         and this_element_name not in configured_elements
6375                                     ):
6376                                         if _checkValueItemParent(
6377                                             child_item,
6378                                             this_policyname,
6379                                             child_key,
6380                                             child_valuename,
6381                                             TRUE_VALUE_XPATH,
6382                                             policy_file_data,
6383                                         ):
6384                                             configured_elements[
6385                                                 this_element_name
6386                                             ] = True
6387                                             log.trace(
6388                                                 "element %s is configured true",
6389                                                 child_item.attrib["id"],
6390                                             )
6391                                     if (
6392                                         FALSE_VALUE_XPATH(child_item)
6393                                         and this_element_name not in configured_elements
6394                                     ):
6395                                         if _checkValueItemParent(
6396                                             child_item,
6397                                             this_policyname,
6398                                             child_key,
6399                                             child_valuename,
6400                                             FALSE_VALUE_XPATH,
6401                                             policy_file_data,
6402                                         ):
6403                                             configured_elements[
6404                                                 this_element_name
6405                                             ] = False
6406                                             policy_disabled_elements = (
6407                                                 policy_disabled_elements + 1
6408                                             )
6409                                             log.trace(
6410                                                 "element %s is configured false",
6411                                                 child_item.attrib["id"],
6412                                             )
6413                                     if (
6414                                         TRUE_LIST_XPATH(child_item)
6415                                         and this_element_name not in configured_elements
6416                                     ):
6417                                         log.trace("checking trueList")
6418                                         if _checkListItem(
6419                                             child_item,
6420                                             this_policyname,
6421                                             this_key,
6422                                             TRUE_LIST_XPATH,
6423                                             policy_file_data,
6424                                         ):
6425                                             configured_elements[
6426                                                 this_element_name
6427                                             ] = True
6428                                             log.trace(
6429                                                 "element %s is configured true",
6430                                                 child_item.attrib["id"],
6431                                             )
6432                                     if (
6433                                         FALSE_LIST_XPATH(child_item)
6434                                         and this_element_name not in configured_elements
6435                                     ):
6436                                         log.trace("checking falseList")
6437                                         if _checkListItem(
6438                                             child_item,
6439                                             this_policyname,
6440                                             this_key,
6441                                             FALSE_LIST_XPATH,
6442                                             policy_file_data,
6443                                         ):
6444                                             configured_elements[
6445                                                 this_element_name
6446                                             ] = False
6447                                             policy_disabled_elements = (
6448                                                 policy_disabled_elements + 1
6449                                             )
6450                                             log.trace(
6451                                                 "element %s is configured false",
6452                                                 child_item.attrib["id"],
6453                                             )
6454                                 else:
6455                                     if _regexSearchRegPolData(
6456                                         re.escape(
6457                                             _processValueItem(
6458                                                 child_item,
6459                                                 child_key,
6460                                                 child_valuename,
6461                                                 admx_policy,
6462                                                 elements_item,
6463                                                 check_deleted=True,
6464                                             )
6465                                         ),
6466                                         policy_file_data,
6467                                     ):
6468                                         configured_elements[this_element_name] = False
6469                                         policy_disabled_elements = (
6470                                             policy_disabled_elements + 1
6471                                         )
6472                                         log.trace(
6473                                             "element %s is configured false",
6474                                             child_item.attrib["id"],
6475                                         )
6476                                     elif _regexSearchRegPolData(
6477                                         re.escape(
6478                                             _processValueItem(
6479                                                 child_item,
6480                                                 child_key,
6481                                                 child_valuename,
6482                                                 admx_policy,
6483                                                 elements_item,
6484                                                 check_deleted=False,
6485                                             )
6486                                         ),
6487                                         policy_file_data,
6488                                     ):
6489                                         configured_elements[this_element_name] = True
6490                                         log.trace(
6491                                             "element %s is configured true",
6492                                             child_item.attrib["id"],
6493                                         )
6494                             elif (
6495                                 etree.QName(child_item).localname == "decimal"
6496                                 or etree.QName(child_item).localname == "text"
6497                                 or etree.QName(child_item).localname == "longDecimal"
6498                                 or etree.QName(child_item).localname == "multiText"
6499                             ):
6500                                 if _regexSearchRegPolData(
6501                                     re.escape(
6502                                         _processValueItem(
6503                                             child_item,
6504                                             child_key,
6505                                             child_valuename,
6506                                             admx_policy,
6507                                             elements_item,
6508                                             check_deleted=True,
6509                                         )
6510                                     ),
6511                                     policy_file_data,
6512                                 ):
6513                                     configured_elements[this_element_name] = "Disabled"
6514                                     policy_disabled_elements = (
6515                                         policy_disabled_elements + 1
6516                                     )
6517                                     log.trace(
6518                                         "element %s is disabled",
6519                                         child_item.attrib["id"],
6520                                     )
6521                                 elif _regexSearchRegPolData(
6522                                     re.escape(
6523                                         _processValueItem(
6524                                             child_item,
6525                                             child_key,
6526                                             child_valuename,
6527                                             admx_policy,
6528                                             elements_item,
6529                                             check_deleted=False,
6530                                         )
6531                                     ),
6532                                     policy_file_data,
6533                                 ):
6534                                     configured_value = _getDataFromRegPolData(
6535                                         _processValueItem(
6536                                             child_item,
6537                                             child_key,
6538                                             child_valuename,
6539                                             admx_policy,
6540                                             elements_item,
6541                                             check_deleted=False,
6542                                         ),
6543                                         policy_file_data,
6544                                     )
6545                                     configured_elements[
6546                                         this_element_name
6547                                     ] = configured_value
6548                                     log.trace(
6549                                         "element %s is enabled, value == %s",
6550                                         child_item.attrib["id"],
6551                                         configured_value,
6552                                     )
6553                             elif etree.QName(child_item).localname == "enum":
6554                                 if _regexSearchRegPolData(
6555                                     re.escape(
6556                                         _processValueItem(
6557                                             child_item,
6558                                             child_key,
6559                                             child_valuename,
6560                                             admx_policy,
6561                                             elements_item,
6562                                             check_deleted=True,
6563                                         )
6564                                     ),
6565                                     policy_file_data,
6566                                 ):
6567                                     log.trace(
6568                                         "enum element %s is disabled",
6569                                         child_item.attrib["id"],
6570                                     )
6571                                     configured_elements[this_element_name] = "Disabled"
6572                                     policy_disabled_elements = (
6573                                         policy_disabled_elements + 1
6574                                     )
6575                                 else:
6576                                     for enum_item in child_item:
6577                                         if _checkValueItemParent(
6578                                             enum_item,
6579                                             child_item.attrib["id"],
6580                                             child_key,
6581                                             child_valuename,
6582                                             VALUE_XPATH,
6583                                             policy_file_data,
6584                                         ):
6585                                             if VALUE_LIST_XPATH(enum_item):
6586                                                 log.trace("enum item has a valueList")
6587                                                 if _checkListItem(
6588                                                     enum_item,
6589                                                     this_policyname,
6590                                                     child_key,
6591                                                     VALUE_LIST_XPATH,
6592                                                     policy_file_data,
6593                                                 ):
6594                                                     log.trace(
6595                                                         "all valueList items exist in"
6596                                                         " file"
6597                                                     )
6598                                                     configured_elements[
6599                                                         this_element_name
6600                                                     ] = _getAdmlDisplayName(
6601                                                         adml_policy_resources,
6602                                                         enum_item.attrib["displayName"],
6603                                                     )
6604                                                     break
6605                                             else:
6606                                                 configured_elements[
6607                                                     this_element_name
6608                                                 ] = _getAdmlDisplayName(
6609                                                     adml_policy_resources,
6610                                                     enum_item.attrib["displayName"],
6611                                                 )
6612                                                 break
6613                             elif etree.QName(child_item).localname == "list":
6614                                 return_value_name = False
6615                                 if (
6616                                     "explicitValue" in child_item.attrib
6617                                     and child_item.attrib["explicitValue"].lower()
6618                                     == "true"
6619                                 ):
6620                                     log.trace(
6621                                         "explicitValue list, we will return value names"
6622                                     )
6623                                     return_value_name = True
6624                                 regex_str = [
6625                                     r"(?!\*",
6626                                     r"\*",
6627                                     "D",
6628                                     "e",
6629                                     "l",
6630                                     "V",
6631                                     "a",
6632                                     "l",
6633                                     "s",
6634                                     r"\.",
6635                                     ")",
6636                                 ]
6637                                 delvals_regex = "\x00".join(regex_str)
6638                                 delvals_regex = salt.utils.stringutils.to_bytes(
6639                                     delvals_regex
6640                                 )
6641                                 if _regexSearchRegPolData(
6642                                     re.escape(
6643                                         _processValueItem(
6644                                             child_item,
6645                                             child_key,
6646                                             child_valuename,
6647                                             admx_policy,
6648                                             elements_item,
6649                                             check_deleted=False,
6650                                         )
6651                                     )
6652                                     + delvals_regex,
6653                                     policy_file_data,
6654                                 ):
6655                                     configured_value = _getDataFromRegPolData(
6656                                         _processValueItem(
6657                                             child_item,
6658                                             child_key,
6659                                             child_valuename,
6660                                             admx_policy,
6661                                             elements_item,
6662                                             check_deleted=False,
6663                                         ),
6664                                         policy_file_data,
6665                                         return_value_name=return_value_name,
6666                                     )
6667                                     configured_elements[
6668                                         this_element_name
6669                                     ] = configured_value
6670                                     log.trace(
6671                                         "element %s is enabled values: %s",
6672                                         child_item.attrib["id"],
6673                                         configured_value,
6674                                     )
6675                                 elif _regexSearchRegPolData(
6676                                     re.escape(
6677                                         _processValueItem(
6678                                             child_item,
6679                                             child_key,
6680                                             child_valuename,
6681                                             admx_policy,
6682                                             elements_item,
6683                                             check_deleted=True,
6684                                         )
6685                                     ),
6686                                     policy_file_data,
6687                                 ):
6688                                     configured_elements[this_element_name] = "Disabled"
6689                                     policy_disabled_elements = (
6690                                         policy_disabled_elements + 1
6691                                     )
6692                                     log.trace(
6693                                         "element %s is disabled",
6694                                         child_item.attrib["id"],
6695                                     )
6696                     if element_only_enabled_disabled:
6697                         if len(required_elements.keys()) &gt; 0 and len(
6698                             configured_elements.keys()
6699                         ) == len(required_elements.keys()):
6700                             if policy_disabled_elements == len(
6701                                 required_elements.keys()
6702                             ):
6703                                 log.trace(
6704                                     "%s is disabled by all enum elements",
6705                                     this_policyname,
6706                                 )
6707                                 if this_policynamespace not in policy_vals:
6708                                     policy_vals[this_policynamespace] = {}
6709                                 policy_vals[this_policynamespace][
6710                                     this_policyname
6711                                 ] = "Disabled"
6712                             else:
6713                                 if this_policynamespace not in policy_vals:
6714                                     policy_vals[this_policynamespace] = {}
6715                                 policy_vals[this_policynamespace][
6716                                     this_policyname
6717                                 ] = configured_elements
6718                                 log.trace(
6719                                     "%s is enabled by enum elements", this_policyname
6720                                 )
6721                     else:
6722                         if this_policy_setting == "Enabled":
6723                             if this_policynamespace not in policy_vals:
6724                                 policy_vals[this_policynamespace] = {}
6725                             policy_vals[this_policynamespace][
6726                                 this_policyname
6727                             ] = configured_elements
6728             if (
6729                 return_full_policy_names
6730                 and this_policynamespace in policy_vals
6731                 and this_policyname in policy_vals[this_policynamespace]
6732             ):
6733                 if this_policynamespace not in full_names:
6734                     full_names[this_policynamespace] = {}
6735                 full_names[this_policynamespace][this_policyname] = _getFullPolicyName(
6736                     policy_item=admx_policy,
6737                     policy_name=admx_policy.attrib["name"],
6738                     return_full_policy_names=return_full_policy_names,
6739                     adml_language=adml_language,
6740                 )
6741                 if (
6742                     this_policyname
6743                     in policy_vals[this_policynamespace][this_policyname]
6744                 ):
6745                     full_name = full_names[this_policynamespace][this_policyname]
6746                     setting = policy_vals[this_policynamespace][this_policyname].pop(
6747                         this_policyname
6748                     )
6749                     policy_vals[this_policynamespace][this_policyname][
6750                         full_name
6751                     ] = setting
6752             if (
6753                 this_policynamespace in policy_vals
6754                 and this_policyname in policy_vals[this_policynamespace]
6755             ):
6756                 if this_policynamespace not in hierarchy:
6757                     hierarchy[this_policynamespace] = {}
6758                 hierarchy[this_policynamespace][this_policyname] = _build_parent_list(
6759                     policy_definition=admx_policy,
6760                     return_full_policy_names=return_full_policy_names,
6761                     adml_language=adml_language,
6762                 )
6763         log.trace("Examination complete: %s seconds", time.time() - start_time)
6764     if policy_vals and return_full_policy_names and not hierarchical_return:
6765         log.debug("Compiling non hierarchical return...")
6766         start_time = time.time()
6767         unpathed_dict = {}
6768         pathed_dict = {}
6769         for policy_namespace in list(policy_vals):
6770             for policy_item in list(policy_vals[policy_namespace]):
6771                 if (
6772                     full_names[policy_namespace][policy_item]
6773                     in policy_vals[policy_namespace]
6774                 ):
6775                     full_path_list = hierarchy[policy_namespace][policy_item]
6776                     full_path_list.reverse()
6777                     full_path_list.append(full_names[policy_namespace][policy_item])
6778                     policy_vals["\\".join(full_path_list)] = policy_vals[
6779                         policy_namespace
6780                     ].pop(policy_item)
6781                     pathed_dict[full_names[policy_namespace][policy_item]] = True
6782                 else:
6783                     policy_vals[policy_namespace][
6784                         full_names[policy_namespace][policy_item]
6785                     ] = policy_vals[policy_namespace].pop(policy_item)
6786                     if policy_namespace not in unpathed_dict:
6787                         unpathed_dict[policy_namespace] = {}
6788                     unpathed_dict[policy_namespace][
6789                         full_names[policy_namespace][policy_item]
6790                     ] = policy_item
6791             if policy_namespace in unpathed_dict:
6792                 for path_needed in unpathed_dict[policy_namespace]:
6793                     full_path_list = hierarchy[policy_namespace][
6794                         unpathed_dict[policy_namespace][path_needed]
6795                     ]
6796                     full_path_list.reverse()
6797                     full_path_list.append(path_needed)
6798                     log.trace("full_path_list == %s", full_path_list)
6799                     policy_vals["\\".join(full_path_list)] = policy_vals[
6800                         policy_namespace
6801                     ].pop(path_needed)
6802         log.trace("Compilation complete: %s seconds", time.time() - start_time)
6803     for policy_namespace in list(policy_vals):
6804         if policy_vals[policy_namespace] == {}:
6805             policy_vals.pop(policy_namespace)
6806     if policy_vals and hierarchical_return:
6807         if hierarchy:
6808             log.debug("Compiling hierarchical return...")
6809             start_time = time.time()
6810             for policy_namespace in hierarchy:
6811                 for hierarchy_item in hierarchy[policy_namespace]:
6812                     if hierarchy_item in policy_vals[policy_namespace]:
6813                         tdict = {}
6814                         first_item = True
6815                         for item in hierarchy[policy_namespace][hierarchy_item]:
6816                             newdict = {}
6817                             if first_item:
6818                                 h_policy_name = hierarchy_item
6819                                 if return_full_policy_names:
6820                                     h_policy_name = full_names[policy_namespace][
6821                                         hierarchy_item
6822                                     ]
6823                                 newdict[item] = {
6824                                     h_policy_name: policy_vals[policy_namespace].pop(
6825                                         hierarchy_item
6826                                     )
6827                                 }
6828                                 first_item = False
6829                             else:
6830                                 newdict[item] = tdict
6831                             tdict = newdict
6832                         if tdict:
6833                             policy_vals = dictupdate.update(policy_vals, tdict)
6834                 if (
6835                     policy_namespace in policy_vals
6836                     and policy_vals[policy_namespace] == {}
6837                 ):
6838                     policy_vals.pop(policy_namespace)
6839             log.trace("Compilation complete: %s seconds", time.time() - start_time)
6840         policy_vals = {
6841             module_policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
6842                 "Administrative Templates": policy_vals
6843             }
6844         }
6845     return policy_vals
6846 def _build_parent_list(policy_definition, return_full_policy_names, adml_language):
6847     """
6848     helper function to build a list containing parent elements of the ADMX
6849     policy
6850     """
6851     parent_list = []
6852     policy_namespace = next(iter(policy_definition.nsmap))
6853     parent_category = policy_definition.xpath(
6854         "{}:parentCategory/@ref".format(policy_namespace),
6855         namespaces=policy_definition.nsmap,
6856     )
6857     admx_policy_definitions = _get_policy_definitions(language=adml_language)
6858     if parent_category:
6859         parent_category = parent_category[0]
6860         nsmap_xpath = "/policyDefinitions/policyNamespaces/{}:*".format(
6861             policy_namespace
6862         )
6863         this_namespace_map = _buildElementNsmap(
6864             admx_policy_definitions.xpath(
6865                 nsmap_xpath, namespaces=policy_definition.nsmap
6866             )
6867         )
6868         this_namespace_map = dictupdate.update(
6869             this_namespace_map, policy_definition.nsmap
6870         )
6871         parent_list = _admx_policy_parent_walk(
6872             path=parent_list,
6873             policy_namespace=policy_namespace,
6874             parent_category=parent_category,
6875             policy_nsmap=this_namespace_map,
6876             return_full_policy_names=return_full_policy_names,
6877             adml_language=adml_language,
6878         )
6879     return parent_list
6880 def _admx_policy_parent_walk(
6881     path,
6882     policy_namespace,
6883     parent_category,
6884     policy_nsmap,
6885     return_full_policy_names,
6886     adml_language,
6887 ):
6888     """
6889     hierarchy for the policy
6890     """
6891     admx_policy_definitions = _get_policy_definitions(language<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=adml_language)
6892     category_xpath_string = '/policyDefinitions/categories/{}:category[@name="{}"]'
6893     using_xpath_string = "/policyDefinitions/policyNamespaces/{}:using"
6894     if parent_category.find(":") &gt;= 0:
6895         policy_namespace = parent_category.split(":")[0]
6896         parent_category = parent_category.</b></font>split(":")[1]
6897         using_xpath_string = using_xpath_string.format(policy_namespace)
6898         policy_nsmap = dictupdate.update(
6899             policy_nsmap,
6900             _buildElementNsmap(
6901                 admx_policy_definitions.xpath(
6902                     using_xpath_string, namespaces=policy_nsmap
6903                 )
6904             ),
6905         )
6906     category_xpath_string = category_xpath_string.format(
6907         policy_namespace, parent_category
6908     )
6909     if admx_policy_definitions.xpath(category_xpath_string, namespaces=policy_nsmap):
6910         tparent_category = admx_policy_definitions.xpath(
6911             category_xpath_string, namespaces=policy_nsmap
6912         )[0]
6913         this_parent_name = _getFullPolicyName(
6914             policy_item=tparent_category,
6915             policy_name=tparent_category.attrib["name"],
6916             return_full_policy_names=return_full_policy_names,
6917             adml_language=adml_language,
6918         )
6919         path.append(this_parent_name)
6920         if tparent_category.xpath(
6921             "{}:parentCategory/@ref".format(policy_namespace), namespaces=policy_nsmap
6922         ):
6923             path = _admx_policy_parent_walk(
6924                 path=path,
6925                 policy_namespace=policy_namespace,
6926                 parent_category=tparent_category.xpath(
6927                     "{}:parentCategory/@ref".format(policy_namespace),
6928                     namespaces=policy_nsmap,
6929                 )[0],
6930                 policy_nsmap=policy_nsmap,
6931                 return_full_policy_names=return_full_policy_names,
6932                 adml_language=adml_language,
6933             )
6934     return path
6935 def _read_regpol_file(reg_pol_path):
6936     """
6937     helper function to read a reg policy file and return decoded data
6938     """
6939     returndata = None
6940     if os.path.exists(reg_pol_path):
6941         with salt.utils.files.fopen(reg_pol_path, "rb") as pol_file:
6942             returndata = pol_file.read()
6943     return returndata
6944 def _regexSearchKeyValueCombo(policy_data, policy_regpath, policy_regkey):
6945     """
6946     helper function to do a search of Policy data from a registry.pol file
6947     for a policy_regpath and policy_regkey combo
6948     """
6949     if policy_data:
6950         regex_str = [
6951             r"(\*",
6952             r"\*",
6953             "D",
6954             "e",
6955             "l",
6956             r"\.",
6957             r"|\*",
6958             r"\*",
6959             "D",
6960             "e",
6961             "l",
6962             "V",
6963             "a",
6964             "l",
6965             "s",
6966             r"\.",
6967             "){0,1}",
6968         ]
6969         specialValueRegex = "\x00".join(regex_str)
6970         specialValueRegex = salt.utils.stringutils.to_bytes(specialValueRegex)
6971         _thisSearch = b"".join(
6972             [
6973                 salt.utils.stringutils.to_bytes(r"\["),
6974                 re.escape(policy_regpath),
6975                 b"\x00;\x00",
6976                 specialValueRegex,
6977                 re.escape(policy_regkey.lstrip(b"\x00")),
6978                 b"\x00;",
6979             ]
6980         )
6981         match = re.search(_thisSearch, policy_data, re.IGNORECASE)
6982         if match:
6983             return policy_data[
6984                 match.start() : (policy_data.index(b"]", match.end())) + 2
6985             ]
6986     return None
6987 def _write_regpol_data(
6988     data_to_write, policy_file_path, gpt_ini_path, gpt_extension, gpt_extension_guid
6989 ):
6990     """
6991     helper function to actually write the data to a Registry.pol file
6992     also updates/edits the gpt.ini file to include the ADM policy extensions
6993     to let the computer know user and/or machine registry policy files need
6994     to be processed
6995     data_to_write: data to write into the user/machine registry.pol file
6996     policy_file_path: path to the registry.pol file
6997     gpt_ini_path: path to gpt.ini file
6998     gpt_extension: gpt extension list name from _policy_info class for this registry class gpt_extension_location
6999     gpt_extension_guid: admx registry extension guid for the class
7000     """
7001     if not os.path.exists(policy_file_path):
7002         __salt__["file.makedirs"](policy_file_path)
7003     try:
7004         with salt.utils.files.fopen(policy_file_path, "wb") as pol_file:
7005             reg_pol_header = "\u5250\u6765\x01\x00".encode("utf-16-le")
7006             if not data_to_write.startswith(reg_pol_header):
7007                 pol_file.write(reg_pol_header)
7008             pol_file.write(data_to_write)
7009     except Exception as e:  # pylint: disable=broad-except
7010         msg = (
7011             "An error occurred attempting to write to {}, the exception was: {}".format(
7012                 policy_file_path, e
7013             )
7014         )
7015         log.exception(msg)
7016         raise CommandExecutionError(msg)
7017     gpt_ini_data = ""
7018     if os.path.exists(gpt_ini_path):
7019         with salt.utils.files.fopen(gpt_ini_path, "r") as gpt_file:
7020             gpt_ini_data = gpt_file.read()
7021         gpt_ini_data = (
7022             gpt_ini_data.replace("\r\n", "_|-")
7023             .replace("\n", "_|-")
7024             .replace("_|-", "\r\n")
7025         )
7026     if not _regexSearchRegPolData(r"\[General\]\r\n", gpt_ini_data):
7027         gpt_ini_data = "[General]\r\n" + gpt_ini_data
7028     if _regexSearchRegPolData(r"{}=".format(re.escape(gpt_extension)), gpt_ini_data):
7029         gpt_ext_loc = re.search(
7030             r"^{}=.*\r\n".format(re.escape(gpt_extension)),
7031             gpt_ini_data,
7032             re.IGNORECASE | re.MULTILINE,
7033         )
7034         gpt_ext_str = gpt_ini_data[gpt_ext_loc.start() : gpt_ext_loc.end()]
7035         if not _regexSearchRegPolData(
7036             r"{}".format(re.escape(gpt_extension_guid)), gpt_ext_str
7037         ):
7038             gpt_ext_str = gpt_ext_str.split("=")
7039             gpt_ext_str[1] = gpt_extension_guid + gpt_ext_str[1]
7040             gpt_ext_str = "=".join(gpt_ext_str)
7041             gpt_ini_data = (
7042                 gpt_ini_data[0 : gpt_ext_loc.start()]
7043                 + gpt_ext_str
7044                 + gpt_ini_data[gpt_ext_loc.end() :]
7045             )
7046     else:
7047         general_location = re.search(
7048             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
7049         )
7050         gpt_ini_data = "{}{}={}\r\n{}".format(
7051             gpt_ini_data[general_location.start() : general_location.end()],
7052             gpt_extension,
7053             gpt_extension_guid,
7054             gpt_ini_data[general_location.end() :],
7055         )
7056     if _regexSearchRegPolData(r"Version=", gpt_ini_data):
7057         version_loc = re.search(
7058             r"^Version=.*\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
7059         )
7060         version_str = gpt_ini_data[version_loc.start() : version_loc.end()]
7061         version_str = version_str.split("=")
7062         version_nums = struct.unpack(b"&gt;2H", struct.pack(b"&gt;I", int(version_str[1])))
7063         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
7064             version_nums = (version_nums[0], version_nums[1] + 1)
7065         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
7066             version_nums = (version_nums[0] + 1, version_nums[1])
7067         version_num = struct.unpack(b"&gt;I", struct.pack(b"&gt;2H", *version_nums))[0]
7068         gpt_ini_data = "{}{}={}\r\n{}".format(
7069             gpt_ini_data[0 : version_loc.start()],
7070             "Version",
7071             version_num,
7072             gpt_ini_data[version_loc.end() :],
7073         )
7074     else:
7075         general_location = re.search(
7076             r"^\[General\]\r\n", gpt_ini_data, re.IGNORECASE | re.MULTILINE
7077         )
7078         if gpt_extension.lower() == "gPCMachineExtensionNames".lower():
7079             version_nums = (0, 1)
7080         elif gpt_extension.lower() == "gPCUserExtensionNames".lower():
7081             version_nums = (1, 0)
7082         gpt_ini_data = "{}{}={}\r\n{}".format(
7083             gpt_ini_data[general_location.start() : general_location.end()],
7084             "Version",
7085             int(
7086                 "{}{}".format(
7087                     str(version_nums[0]).zfill(4),
7088                     str(version_nums[1]).zfill(4),
7089                 ),
7090                 16,
7091             ),
7092             gpt_ini_data[general_location.end() :],
7093         )
7094     if gpt_ini_data:
7095         try:
7096             with salt.utils.files.fopen(gpt_ini_path, "w") as gpt_file:
7097                 gpt_file.write(gpt_ini_data)
7098         except Exception as e:  # pylint: disable=broad-except
7099             msg = (
7100                 "An error occurred attempting to write the gpg.ini file.\n"
7101                 "path: {}\n"
7102                 "exception: {}".format(gpt_ini_path, e)
7103             )
7104             log.exception(msg)
7105             raise CommandExecutionError(msg)
7106 def _policyFileReplaceOrAppendList(string_list, policy_data):
7107     """
7108     helper function to take a list of strings for registry.pol file data and
7109     update existing strings or append the strings
7110     """
7111     if not policy_data:
7112         policy_data = b""
7113     specialValueRegex = salt.utils.stringutils.to_bytes(
7114         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
7115     )
7116     for this_string in string_list:
7117         list_item_key = this_string.split(b"\00;")[0].lstrip(b"[")
7118         list_item_value_name = re.sub(
7119             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
7120         )
7121         log.trace("item value name is %s", list_item_value_name)
7122         data_to_replace = _regexSearchKeyValueCombo(
7123             policy_data, list_item_key, list_item_value_name
7124         )
7125         if data_to_replace:
7126             log.trace("replacing %s with %s", data_to_replace, this_string)
7127             policy_data = policy_data.replace(data_to_replace, this_string)
7128         else:
7129             log.trace("appending %s", this_string)
7130             policy_data = b"".join([policy_data, this_string])
7131     return policy_data
7132 def _policyFileReplaceOrAppend(this_string, policy_data, append_only=False):
7133     """
7134     helper function to take a ADMX policy string for registry.pol file data and
7135     update existing string or append the string to the data
7136     """
7137     if not policy_data:
7138         policy_data = b""
7139     specialValueRegex = salt.utils.stringutils.to_bytes(
7140         r"(\*\*Del\.|\*\*DelVals\.){0,1}"
7141     )
7142     item_key = None
7143     item_value_name = None
7144     data_to_replace = None
7145     if not append_only:
7146         item_key = this_string.split(b"\00;")[0].lstrip(b"[")
7147         item_value_name = re.sub(
7148             specialValueRegex, b"", this_string.split(b"\00;")[1], flags=re.IGNORECASE
7149         )
7150         log.trace("item value name is %s", item_value_name)
7151         data_to_replace = _regexSearchKeyValueCombo(
7152             policy_data, item_key, item_value_name
7153         )
7154     if data_to_replace:
7155         log.trace("replacing %s with %s", data_to_replace, this_string)
7156         policy_data = policy_data.replace(data_to_replace, this_string)
7157     else:
7158         log.trace("appending %s", this_string)
7159         policy_data = b"".join([policy_data, this_string])
7160     return policy_data
7161 def _writeAdminTemplateRegPolFile(
7162     admtemplate_data, adml_language="en-US", registry_class="Machine"
7163 ):
7164     r"""
7165     helper function to prep/write adm template data to the Registry.pol file
7166     each file begins with REGFILE_SIGNATURE (u'\u5250\u6765') and
7167     REGISTRY_FILE_VERSION (u'\x01\00')
7168     https://msdn.microsoft.com/en-us/library/aa374407(VS.85).aspx
7169     +    https://msdn.microsoft.com/en-us/library/cc232696.aspx
7170     [Registry Path&lt;NULL&gt;;Reg Value&lt;NULL&gt;;Reg Type;SizeInBytes;Data&lt;NULL&gt;]
7171     """
7172     existing_data = b""
7173     policy_data = _policy_info()
7174     policySearchXpath = '//ns1:*[@id = "{0}" or @name = "{0}"]'
7175     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7176     adml_policy_resources = _get_policy_resources(language=adml_language)
7177     base_policy_settings = _checkAllAdmxPolicies(
7178         policy_class=registry_class,
7179         adml_language=adml_language,
7180         return_full_policy_names=False,
7181         hierarchical_return=False,
7182         return_not_configured=False,
7183     )
7184     for adm_namespace in admtemplate_data:
7185         for adm_policy in admtemplate_data[adm_namespace]:
7186             if (
7187                 str(admtemplate_data[adm_namespace][adm_policy]).lower()
7188                 == "not configured"
7189             ):
7190                 if (
7191                     base_policy_settings.get(adm_namespace, {}).pop(adm_policy, None)
7192                     is not None
7193                 ):
7194                     log.trace('Policy "%s" removed', adm_policy)
7195             else:
7196                 log.trace("adding %s to base_policy_settings", adm_policy)
7197                 if adm_namespace not in base_policy_settings:
7198                     base_policy_settings[adm_namespace] = {}
7199                 base_policy_settings[adm_namespace][adm_policy] = admtemplate_data[
7200                     adm_namespace
7201                 ][adm_policy]
7202     for adm_namespace in base_policy_settings:
7203         for admPolicy in base_policy_settings[adm_namespace]:
7204             log.trace("working on admPolicy %s", admPolicy)
7205             explicit_enable_disable_value_setting = False
7206             this_key = None
7207             this_valuename = None
7208             if (
7209                 str(base_policy_settings[adm_namespace][admPolicy]).lower()
7210                 == "disabled"
7211             ):
7212                 log.trace("time to disable %s", admPolicy)
7213                 this_policy = admx_policy_definitions.xpath(
7214                     policySearchXpath.format(admPolicy),
7215                     namespaces={"ns1": adm_namespace},
7216                 )
7217                 if this_policy:
7218                     this_policy = this_policy[0]
7219                     if "class" in this_policy.attrib:
7220                         if (
7221                             this_policy.attrib["class"] == registry_class
7222                             or this_policy.attrib["class"] == "Both"
7223                         ):
7224                             if "key" in this_policy.attrib:
7225                                 this_key = this_policy.attrib["key"]
7226                             else:
7227                                 log.error(
7228                                     "policy item %s does not have "
7229                                     'the required "key" attribute',
7230                                     this_policy.attrib,
7231                                 )
7232                                 break
7233                             if "valueName" in this_policy.attrib:
7234                                 this_valuename = this_policy.attrib["valueName"]
7235                             if DISABLED_VALUE_XPATH(this_policy):
7236                                 explicit_enable_disable_value_setting = True
7237                                 disabled_value_string = _checkValueItemParent(
7238                                     this_policy,
7239                                     admPolicy,
7240                                     this_key,
7241                                     this_valuename,
7242                                     DISABLED_VALUE_XPATH,
7243                                     None,
7244                                     check_deleted=False,
7245                                     test_item=False,
7246                                 )
7247                                 existing_data = _policyFileReplaceOrAppend(
7248                                     disabled_value_string, existing_data
7249                                 )
7250                             if DISABLED_LIST_XPATH(this_policy):
7251                                 explicit_enable_disable_value_setting = True
7252                                 disabled_list_strings = _checkListItem(
7253                                     this_policy,
7254                                     admPolicy,
7255                                     this_key,
7256                                     DISABLED_LIST_XPATH,
7257                                     None,
7258                                     test_items=False,
7259                                 )
7260                                 log.trace(
7261                                     "working with disabledList portion of %s",
7262                                     admPolicy,
7263                                 )
7264                                 existing_data = _policyFileReplaceOrAppendList(
7265                                     disabled_list_strings, existing_data
7266                                 )
7267                             if (
7268                                 not explicit_enable_disable_value_setting
7269                                 and this_valuename
7270                             ):
7271                                 disabled_value_string = _buildKnownDataSearchString(
7272                                     this_key,
7273                                     this_valuename,
7274                                     "REG_DWORD",
7275                                     None,
7276                                     check_deleted=True,
7277                                 )
7278                                 existing_data = _policyFileReplaceOrAppend(
7279                                     disabled_value_string, existing_data
7280                                 )
7281                             if ELEMENTS_XPATH(this_policy):
7282                                 log.trace("checking elements of %s", admPolicy)
7283                                 for elements_item in ELEMENTS_XPATH(this_policy):
7284                                     for child_item in elements_item:
7285                                         child_key = this_key
7286                                         child_valuename = this_valuename
7287                                         if "key" in child_item.attrib:
7288                                             child_key = child_item.attrib["key"]
7289                                         if "valueName" in child_item.attrib:
7290                                             child_valuename = child_item.attrib[
7291                                                 "valueName"
7292                                             ]
7293                                         if etree.QName(
7294                                             child_item
7295                                         ).localname == "boolean" and (
7296                                             TRUE_LIST_XPATH(child_item)
7297                                             or FALSE_LIST_XPATH(child_item)
7298                                         ):
7299                                             temp_dict = {
7300                                                 "trueList": TRUE_LIST_XPATH,
7301                                                 "falseList": FALSE_LIST_XPATH,
7302                                             }
7303                                             for this_list in temp_dict:
7304                                                 disabled_list_strings = _checkListItem(
7305                                                     child_item,
7306                                                     admPolicy,
7307                                                     child_key,
7308                                                     temp_dict[this_list],
7309                                                     None,
7310                                                     test_items=False,
7311                                                 )
7312                                                 log.trace(
7313                                                     "working with %s portion of %s",
7314                                                     admPolicy,
7315                                                     this_list,
7316                                                 )
7317                                                 existing_data = (
7318                                                     _policyFileReplaceOrAppendList(
7319                                                         disabled_list_strings,
7320                                                         existing_data,
7321                                                     )
7322                                                 )
7323                                         elif (
7324                                             etree.QName(child_item).localname
7325                                             == "boolean"
7326                                             or etree.QName(child_item).localname
7327                                             == "decimal"
7328                                             or etree.QName(child_item).localname
7329                                             == "text"
7330                                             or etree.QName(child_item).localname
7331                                             == "longDecimal"
7332                                             or etree.QName(child_item).localname
7333                                             == "multiText"
7334                                             or etree.QName(child_item).localname
7335                                             == "enum"
7336                                         ):
7337                                             disabled_value_string = _processValueItem(
7338                                                 child_item,
7339                                                 child_key,
7340                                                 child_valuename,
7341                                                 this_policy,
7342                                                 elements_item,
7343                                                 check_deleted=True,
7344                                             )
7345                                             log.trace(
7346                                                 "I have disabled value string of %s",
7347                                                 disabled_value_string,
7348                                             )
7349                                             existing_data = _policyFileReplaceOrAppend(
7350                                                 disabled_value_string, existing_data
7351                                             )
7352                                         elif (
7353                                             etree.QName(child_item).localname == "list"
7354                                         ):
7355                                             disabled_value_string = _processValueItem(
7356                                                 child_item,
7357                                                 child_key,
7358                                                 child_valuename,
7359                                                 this_policy,
7360                                                 elements_item,
7361                                                 check_deleted=True,
7362                                             )
7363                                             log.trace(
7364                                                 "I have disabled value string of %s",
7365                                                 disabled_value_string,
7366                                             )
7367                                             existing_data = _policyFileReplaceOrAppend(
7368                                                 disabled_value_string, existing_data
7369                                             )
7370                         else:
7371                             log.error(
7372                                 "policy %s was found but it does not appear to be valid"
7373                                 " for the class %s",
7374                                 admPolicy,
7375                                 registry_class,
7376                             )
7377                     else:
7378                         log.error(
7379                             'policy item %s does not have the required "class"'
7380                             " attribute",
7381                             this_policy.attrib,
7382                         )
7383             else:
7384                 log.trace('time to enable and set the policy "%s"', admPolicy)
7385                 this_policy = admx_policy_definitions.xpath(
7386                     policySearchXpath.format(admPolicy),
7387                     namespaces={"ns1": adm_namespace},
7388                 )
7389                 log.trace("found this_policy == %s", this_policy)
7390                 if this_policy:
7391                     this_policy = this_policy[0]
7392                     if "class" in this_policy.attrib:
7393                         if (
7394                             this_policy.attrib["class"] == registry_class
7395                             or this_policy.attrib["class"] == "Both"
7396                         ):
7397                             if "key" in this_policy.attrib:
7398                                 this_key = this_policy.attrib["key"]
7399                             else:
7400                                 log.error(
7401                                     'policy item %s does not have the required "key"'
7402                                     " attribute",
7403                                     this_policy.attrib,
7404                                 )
7405                                 break
7406                             if "valueName" in this_policy.attrib:
7407                                 this_valuename = this_policy.attrib["valueName"]
7408                             if ENABLED_VALUE_XPATH(this_policy):
7409                                 explicit_enable_disable_value_setting = True
7410                                 enabled_value_string = _checkValueItemParent(
7411                                     this_policy,
7412                                     admPolicy,
7413                                     this_key,
7414                                     this_valuename,
7415                                     ENABLED_VALUE_XPATH,
7416                                     None,
7417                                     check_deleted=False,
7418                                     test_item=False,
7419                                 )
7420                                 existing_data = _policyFileReplaceOrAppend(
7421                                     enabled_value_string, existing_data
7422                                 )
7423                             if ENABLED_LIST_XPATH(this_policy):
7424                                 explicit_enable_disable_value_setting = True
7425                                 enabled_list_strings = _checkListItem(
7426                                     this_policy,
7427                                     admPolicy,
7428                                     this_key,
7429                                     ENABLED_LIST_XPATH,
7430                                     None,
7431                                     test_items=False,
7432                                 )
7433                                 log.trace(
7434                                     "working with enabledList portion of %s", admPolicy
7435                                 )
7436                                 existing_data = _policyFileReplaceOrAppendList(
7437                                     enabled_list_strings, existing_data
7438                                 )
7439                             if (
7440                                 not explicit_enable_disable_value_setting
7441                                 and this_valuename
7442                             ):
7443                                 enabled_value_string = _buildKnownDataSearchString(
7444                                     this_key,
7445                                     this_valuename,
7446                                     "REG_DWORD",
7447                                     "1",
7448                                     check_deleted=False,
7449                                 )
7450                                 existing_data = _policyFileReplaceOrAppend(
7451                                     enabled_value_string, existing_data
7452                                 )
7453                             if ELEMENTS_XPATH(this_policy):
7454                                 for elements_item in ELEMENTS_XPATH(this_policy):
7455                                     for child_item in elements_item:
7456                                         child_key = this_key
7457                                         child_valuename = this_valuename
7458                                         if "key" in child_item.attrib:
7459                                             child_key = child_item.attrib["key"]
7460                                         if "valueName" in child_item.attrib:
7461                                             child_valuename = child_item.attrib[
7462                                                 "valueName"
7463                                             ]
7464                                         if (
7465                                             child_item.attrib["id"]
7466                                             in base_policy_settings[adm_namespace][
7467                                                 admPolicy
7468                                             ]
7469                                         ):
7470                                             if etree.QName(
7471                                                 child_item
7472                                             ).localname == "boolean" and (
7473                                                 TRUE_LIST_XPATH(child_item)
7474                                                 or FALSE_LIST_XPATH(child_item)
7475                                             ):
7476                                                 list_strings = []
7477                                                 if base_policy_settings[adm_namespace][
7478                                                     admPolicy
7479                                                 ][child_item.attrib["id"]]:
7480                                                     list_strings = _checkListItem(
7481                                                         child_item,
7482                                                         admPolicy,
7483                                                         child_key,
7484                                                         TRUE_LIST_XPATH,
7485                                                         None,
7486                                                         test_items=False,
7487                                                     )
7488                                                     log.trace(
7489                                                         "working with trueList portion"
7490                                                         " of %s",
7491                                                         admPolicy,
7492                                                     )
7493                                                 else:
7494                                                     list_strings = _checkListItem(
7495                                                         child_item,
7496                                                         admPolicy,
7497                                                         child_key,
7498                                                         FALSE_LIST_XPATH,
7499                                                         None,
7500                                                         test_items=False,
7501                                                     )
7502                                                 existing_data = (
7503                                                     _policyFileReplaceOrAppendList(
7504                                                         list_strings, existing_data
7505                                                     )
7506                                                 )
7507                                             elif etree.QName(
7508                                                 child_item
7509                                             ).localname == "boolean" and (
7510                                                 TRUE_VALUE_XPATH(child_item)
7511                                                 or FALSE_VALUE_XPATH(child_item)
7512                                             ):
7513                                                 value_string = ""
7514                                                 if base_policy_settings[adm_namespace][
7515                                                     admPolicy
7516                                                 ][child_item.attrib["id"]]:
7517                                                     value_string = (
7518                                                         _checkValueItemParent(
7519                                                             child_item,
7520                                                             admPolicy,
7521                                                             child_key,
7522                                                             child_valuename,
7523                                                             TRUE_VALUE_XPATH,
7524                                                             None,
7525                                                             check_deleted=False,
7526                                                             test_item=False,
7527                                                         )
7528                                                     )
7529                                                 else:
7530                                                     value_string = (
7531                                                         _checkValueItemParent(
7532                                                             child_item,
7533                                                             admPolicy,
7534                                                             child_key,
7535                                                             child_valuename,
7536                                                             FALSE_VALUE_XPATH,
7537                                                             None,
7538                                                             check_deleted=False,
7539                                                             test_item=False,
7540                                                         )
7541                                                     )
7542                                                 existing_data = (
7543                                                     _policyFileReplaceOrAppend(
7544                                                         value_string, existing_data
7545                                                     )
7546                                                 )
7547                                             elif (
7548                                                 etree.QName(child_item).localname
7549                                                 == "boolean"
7550                                                 or etree.QName(child_item).localname
7551                                                 == "decimal"
7552                                                 or etree.QName(child_item).localname
7553                                                 == "text"
7554                                                 or etree.QName(child_item).localname
7555                                                 == "longDecimal"
7556                                                 or etree.QName(child_item).localname
7557                                                 == "multiText"
7558                                             ):
7559                                                 enabled_value_string = _processValueItem(
7560                                                     child_item,
7561                                                     child_key,
7562                                                     child_valuename,
7563                                                     this_policy,
7564                                                     elements_item,
7565                                                     check_deleted=False,
7566                                                     this_element_value=base_policy_settings[
7567                                                         adm_namespace
7568                                                     ][
7569                                                         admPolicy
7570                                                     ][
7571                                                         child_item.attrib["id"]
7572                                                     ],
7573                                                 )
7574                                                 log.trace(
7575                                                     "I have enabled value string of %s",
7576                                                     enabled_value_string,
7577                                                 )
7578                                                 existing_data = (
7579                                                     _policyFileReplaceOrAppend(
7580                                                         enabled_value_string,
7581                                                         existing_data,
7582                                                     )
7583                                                 )
7584                                             elif (
7585                                                 etree.QName(child_item).localname
7586                                                 == "enum"
7587                                             ):
7588                                                 for enum_item in child_item:
7589                                                     if (
7590                                                         base_policy_settings[
7591                                                             adm_namespace
7592                                                         ][admPolicy][
7593                                                             child_item.attrib["id"]
7594                                                         ]
7595                                                         == _getAdmlDisplayName(
7596                                                             adml_policy_resources,
7597                                                             enum_item.attrib[
7598                                                                 "displayName"
7599                                                             ],
7600                                                         ).strip()
7601                                                     ):
7602                                                         enabled_value_string = (
7603                                                             _checkValueItemParent(
7604                                                                 enum_item,
7605                                                                 child_item.attrib["id"],
7606                                                                 child_key,
7607                                                                 child_valuename,
7608                                                                 VALUE_XPATH,
7609                                                                 None,
7610                                                                 check_deleted=False,
7611                                                                 test_item=False,
7612                                                             )
7613                                                         )
7614                                                         existing_data = (
7615                                                             _policyFileReplaceOrAppend(
7616                                                                 enabled_value_string,
7617                                                                 existing_data,
7618                                                             )
7619                                                         )
7620                                                         if VALUE_LIST_XPATH(enum_item):
7621                                                             enabled_list_strings = (
7622                                                                 _checkListItem(
7623                                                                     enum_item,
7624                                                                     admPolicy,
7625                                                                     child_key,
7626                                                                     VALUE_LIST_XPATH,
7627                                                                     None,
7628                                                                     test_items=False,
7629                                                                 )
7630                                                             )
7631                                                             log.trace(
7632                                                                 "working with valueList"
7633                                                                 " portion of %s",
7634                                                                 child_item.attrib["id"],
7635                                                             )
7636                                                             existing_data = _policyFileReplaceOrAppendList(
7637                                                                 enabled_list_strings,
7638                                                                 existing_data,
7639                                                             )
7640                                                         break
7641                                             elif (
7642                                                 etree.QName(child_item).localname
7643                                                 == "list"
7644                                             ):
7645                                                 enabled_value_string = _processValueItem(
7646                                                     child_item,
7647                                                     child_key,
7648                                                     child_valuename,
7649                                                     this_policy,
7650                                                     elements_item,
7651                                                     check_deleted=False,
7652                                                     this_element_value=base_policy_settings[
7653                                                         adm_namespace
7654                                                     ][
7655                                                         admPolicy
7656                                                     ][
7657                                                         child_item.attrib["id"]
7658                                                     ],
7659                                                 )
7660                                                 log.trace(
7661                                                     "I have enabled value string of %s",
7662                                                     enabled_value_string,
7663                                                 )
7664                                                 existing_data = (
7665                                                     _policyFileReplaceOrAppend(
7666                                                         enabled_value_string,
7667                                                         existing_data,
7668                                                         append_only=True,
7669                                                     )
7670                                                 )
7671     try:
7672         _write_regpol_data(
7673             existing_data,
7674             policy_data.admx_registry_classes[registry_class]["policy_path"],
7675             policy_data.gpt_ini_path,
7676             policy_data.admx_registry_classes[registry_class]["gpt_extension_location"],
7677             policy_data.admx_registry_classes[registry_class]["gpt_extension_guid"],
7678         )
7679     except CommandExecutionError as exc:  # pylint: disable=broad-except
7680         log.exception(
7681             "Unhandled exception occurred while attempting to "
7682             "write Adm Template Policy File.\nException: %s",
7683             exc,
7684         )
7685         return False
7686     return True
7687 def _getScriptSettingsFromIniFile(policy_info):
7688     """
7689     helper function to parse/read a GPO Startup/Shutdown script file
7690     psscript.ini and script.ini file definitions are here
7691         https://msdn.microsoft.com/en-us/library/ff842529.aspx
7692         https://msdn.microsoft.com/en-us/library/dd303238.aspx
7693     """
7694     _existingData = None
7695     if os.path.isfile(policy_info["ScriptIni"]["IniPath"]):
7696         with salt.utils.files.fopen(policy_info["ScriptIni"]["IniPath"], "rb") as fhr:
7697             _existingData = fhr.read()
7698         if _existingData:
7699             try:
7700                 _existingData = deserialize(
7701                     _existingData.decode("utf-16-le").lstrip("\ufeff")
7702                 )
7703                 log.trace("Have deserialized data %s", _existingData)
7704             except Exception as error:  # pylint: disable=broad-except
7705                 log.exception(
7706                     "An error occurred attempting to deserialize data for %s",
7707                     policy_info["Policy"],
7708                 )
7709                 raise CommandExecutionError(error)
7710             if "Section" in policy_info["ScriptIni"] and policy_info["ScriptIni"][
7711                 "Section"
7712             ].lower() in [z.lower() for z in _existingData.keys()]:
7713                 if "SettingName" in policy_info["ScriptIni"]:
7714                     log.trace(
7715                         "Need to look for %s", policy_info["ScriptIni"]["SettingName"]
7716                     )
7717                     if policy_info["ScriptIni"]["SettingName"].lower() in [
7718                         z.lower()
7719                         for z in _existingData[
7720                             policy_info["ScriptIni"]["Section"]
7721                         ].keys()
7722                     ]:
7723                         return _existingData[policy_info["ScriptIni"]["Section"]][
7724                             policy_info["ScriptIni"]["SettingName"].lower()
7725                         ]
7726                     else:
7727                         return None
7728                 else:
7729                     return _existingData[policy_info["ScriptIni"]["Section"]]
7730             else:
7731                 return None
7732     return None
7733 def _writeGpoScript(psscript=False):
7734     """
7735     helper function to write local GPO startup/shutdown script
7736     scripts are stored in scripts.ini and psscripts.ini files in
7737     ``WINDIR\\System32\\GroupPolicy\\Machine|User\\Scripts``
7738     these files have the hidden attribute set
7739     files have following format:
7740         empty line
7741         [Startup]
7742         0CmdLine=&lt;path to script 0&gt;
7743         0Parameters=&lt;script 0 parameters&gt;
7744         [Shutdown]
7745         0CmdLine=&lt;path to shutdown script 0&gt;
7746         0Parameters=&lt;shutdown script 0 parameters&gt;
7747     Number is incremented for each script added
7748     psscript file also has the option of a [ScriptsConfig] section, which has
7749     the following two parameters:
7750         StartExecutePSFirst
7751         EndExecutePSFirst
7752     these can be set to True/False to denote if the powershell startup/shutdown
7753     scripts execute first (True) or last (False), if the value isn't set, then
7754     it is 'Not Configured' in the GUI
7755     """
7756     _machineScriptPolicyPath = os.path.join(
7757         os.getenv("WINDIR"),
7758         "System32",
7759         "GroupPolicy",
7760         "Machine",
7761         "Scripts",
7762         "scripts.ini",
7763     )
7764     _machinePowershellScriptPolicyPath = os.path.join(
7765         os.getenv("WINDIR"),
7766         "System32",
7767         "GroupPolicy",
7768         "Machine",
7769         "Scripts",
7770         "psscripts.ini",
7771     )
7772     _userScriptPolicyPath = os.path.join(
7773         os.getenv("WINDIR"), "System32", "GroupPolicy", "User", "Scripts", "scripts.ini"
7774     )
7775     _userPowershellScriptPolicyPath = os.path.join(
7776         os.getenv("WINDIR"),
7777         "System32",
7778         "GroupPolicy",
7779         "User",
7780         "Scripts",
7781         "psscripts.ini",
7782     )
7783 def _lookup_admin_template(policy_name, policy_class, adml_language="en-US"):
7784     """
7785     (success_flag, policy_xml_item, policy_name_list, message)
7786     """
7787     policy_aliases = []
7788     admx_policy_definitions = _get_policy_definitions(language=adml_language)
7789     adml_policy_resources = _get_policy_resources(language=adml_language)
7790     admx_search_results = ADMX_SEARCH_XPATH(
7791         admx_policy_definitions, policy_name=policy_name, registry_class=policy_class
7792     )
7793     if admx_search_results:
7794         if len(admx_search_results) == 1:
7795             the_policy = admx_search_results[0]
7796             policy_display_name = _getFullPolicyName(
7797                 policy_item=the_policy,
7798                 policy_name=the_policy.attrib["name"],
7799                 return_full_policy_names=True,
7800                 adml_language=adml_language,
7801             )
7802             policy_aliases.append(policy_display_name)
7803             policy_aliases.append(the_policy.attrib["name"])
7804             full_path_list = _build_parent_list(
7805                 policy_definition=the_policy,
7806                 return_full_policy_names=True,
7807                 adml_language=adml_language,
7808             )
7809             full_path_list.reverse()
7810             full_path_list.append(policy_display_name)
7811             policy_aliases.append("\\".join(full_path_list))
7812             return True, the_policy, policy_aliases, None
7813         else:
7814             msg = 'ADMX policy name/id "{}" is used in multiple ADMX files'
7815             return False, None, [], msg
7816     else:
7817         adml_search_results = ADML_SEARCH_XPATH(
7818             adml_policy_resources, policy_name=policy_name
7819         )
7820         hierarchy = []
7821         hierarchy_policy_name = policy_name
7822         if not adml_search_results:
7823             log.warning("Trying another: %s", policy_name)
7824             if "\\" in policy_name:
7825                 hierarchy = policy_name.split("\\")
7826                 policy_name = hierarchy.pop()
7827                 adml_search_results = ADML_SEARCH_XPATH(
7828                     adml_policy_resources, policy_name=policy_name
7829                 )
7830         if adml_search_results:
7831             multiple_adml_entries = False
7832             suggested_policies = ""
7833             adml_to_remove = []
7834             if len(adml_search_results) &gt; 1:
7835                 log.trace(
7836                     "multiple ADML entries found matching the policy name %s",
7837                     policy_name,
7838                 )
7839                 multiple_adml_entries = True
7840                 for adml_search_result in adml_search_results:
7841                     if (
7842                         not getattr(adml_search_result, "text", "").strip()
7843                         == policy_name
7844                     ):
7845                         adml_to_remove.append(adml_search_result)
7846                     else:
7847                         if hierarchy:
7848                             log.trace("we have hierarchy of %s", hierarchy)
7849                             display_name_searchval = "$({}.{})".format(
7850                                 adml_search_result.tag.split("}")[1],
7851                                 adml_search_result.attrib["id"],
7852                             )
7853                             policy_search_string = (
7854                                 '//{}:policy[@displayName = "{}" and (@class = "Both"'
7855                                 ' or @class = "{}") ]'.format(
7856                                     adml_search_result.prefix,
7857                                     display_name_searchval,
7858                                     policy_class,
7859                                 )
7860                             )
7861                             admx_results = []
7862                             these_admx_search_results = admx_policy_definitions.xpath(
7863                                 policy_search_string,
7864                                 namespaces=adml_search_result.nsmap,
7865                             )
7866                             if not these_admx_search_results:
7867                                 log.trace(
7868                                     "No admx was found for the adml entry %s, it will"
7869                                     " be removed",
7870                                     display_name_searchval,
7871                                 )
7872                                 adml_to_remove.append(adml_search_result)
7873                             for search_result in these_admx_search_results:
7874                                 log.trace("policy_name == %s", policy_name)
7875                                 this_hierarchy = _build_parent_list(
7876                                     policy_definition=search_result,
7877                                     return_full_policy_names=True,
7878                                     adml_language=adml_language,
7879                                 )
7880                                 this_hierarchy.reverse()
7881                                 if hierarchy != this_hierarchy:
7882                                     log.trace(
7883                                         "hierarchy %s does not match this item's"
7884                                         " hierarchy of %s",
7885                                         hierarchy,
7886                                         this_hierarchy,
7887                                     )
7888                                     if len(these_admx_search_results) == 1:
7889                                         log.trace(
7890                                             "only 1 admx was found and it does not "
7891                                             "match this adml, it is safe to remove "
7892                                             "from the list"
7893                                         )
7894                                         adml_to_remove.append(adml_search_result)
7895                                 else:
7896                                     log.trace(
7897                                         "hierarchy %s matches item's hierarchy of %s",
7898                                         hierarchy,
7899                                         this_hierarchy,
7900                                     )
7901                                     log.trace(
7902                                         "search_result %s added to results",
7903                                         search_result,
7904                                     )
7905                                     admx_results.append(search_result)
7906                             if len(admx_results) == 1:
7907                                 admx_search_results.append(admx_results[0])
7908                         else:
7909                             display_name_searchval = "$({}.{})".format(
7910                                 adml_search_result.tag.split("}")[1],
7911                                 adml_search_result.attrib["id"],
7912                             )
7913                             these_admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7914                                 admx_policy_definitions,
7915                                 display_name=display_name_searchval,
7916                                 registry_class=policy_class,
7917                             )
7918                             if not these_admx_search_results:
7919                                 adml_to_remove.append(adml_search_result)
7920             for adml in adml_to_remove:
7921                 if adml in adml_search_results:
7922                     adml_search_results.remove(adml)
7923             if len(adml_search_results) == 1 and multiple_adml_entries:
7924                 multiple_adml_entries = False
7925             for adml_search_result in adml_search_results:
7926                 log.trace(
7927                     "found an ADML entry matching the string! %s -- %s",
7928                     adml_search_result.tag,
7929                     adml_search_result.attrib,
7930                 )
7931                 display_name_searchval = "$({}.{})".format(
7932                     adml_search_result.tag.split("}")[1],
7933                     adml_search_result.attrib["id"],
7934                 )
7935                 log.trace("searching for displayName == %s", display_name_searchval)
7936                 if not admx_search_results:
7937                     log.trace(
7938                         "search for an admx entry matching display_name %s and"
7939                         " registry_class %s",
7940                         display_name_searchval,
7941                         policy_class,
7942                     )
7943                     admx_search_results = ADMX_DISPLAYNAME_SEARCH_XPATH(
7944                         admx_policy_definitions,
7945                         display_name=display_name_searchval,
7946                         registry_class=policy_class,
7947                     )
7948                 if admx_search_results:
7949                     log.trace(
7950                         "processing admx_search_results of %s", admx_search_results
7951                     )
7952                     log.trace("multiple_adml_entries is %s", multiple_adml_entries)
7953                     if (
7954                         len(admx_search_results) == 1 or hierarchy
7955                     ) and not multiple_adml_entries:
7956                         found = False
7957                         for search_result in admx_search_results:
7958                             found = False
7959                             if hierarchy:
7960                                 this_hierarchy = _build_parent_list(
7961                                     policy_definition=search_result,
7962                                     return_full_policy_names=True,
7963                                     adml_language=adml_language,
7964                                 )
7965                                 this_hierarchy.reverse()
7966                                 log.trace("testing %s == %s", hierarchy, this_hierarchy)
7967                                 if hierarchy == this_hierarchy:
7968                                     found = True
7969                             else:
7970                                 found = True
7971                             if found:
7972                                 log.trace(
7973                                     "found the ADMX policy matching "
7974                                     "the display name %s -- %s",
7975                                     search_result,
7976                                     policy_name,
7977                                 )
7978                                 if "name" in search_result.attrib:
7979                                     policy_display_name = _getFullPolicyName(
7980                                         policy_item=search_result,
7981                                         policy_name=search_result.attrib["name"],
7982                                         return_full_policy_names=True,
7983                                         adml_language=adml_language,
7984                                     )
7985                                     policy_aliases.append(policy_display_name)
7986                                     policy_aliases.append(search_result.attrib["name"])
7987                                     full_path_list = _build_parent_list(
7988                                         policy_definition=search_result,
7989                                         return_full_policy_names=True,
7990                                         adml_language=adml_language,
7991                                     )
7992                                     full_path_list.reverse()
7993                                     full_path_list.append(policy_display_name)
7994                                     policy_aliases.append("\\".join(full_path_list))
7995                                     return True, search_result, policy_aliases, None
7996                                 else:
7997                                     msg = (
7998                                         "ADMX policy with the display name {} does not"
7999                                         "have the required name attribute"
8000                                     )
8001                                     msg = msg.format(policy_name)
8002                                     return False, None, [], msg
8003                         if not found:
8004                             msg = "Unable to correlate {} to any policy".format(
8005                                 hierarchy_policy_name
8006                             )
8007                             return False, None, [], msg
8008                     else:
8009                         for possible_policy in admx_search_results:
8010                             this_parent_list = _build_parent_list(
8011                                 policy_definition=possible_policy,
8012                                 return_full_policy_names=True,
8013                                 adml_language=adml_language,
8014                             )
8015                             this_parent_list.reverse()
8016                             this_parent_list.append(policy_name)
8017                             if suggested_policies:
8018                                 suggested_policies = ", ".join(
8019                                     [suggested_policies, "\\".join(this_parent_list)]
8020                                 )
8021                             else:
8022                                 suggested_policies = "\\".join(this_parent_list)
8023             if suggested_policies:
8024                 msg = (
8025                     'ADML policy name "{}" is used as the display name for '
8026                     "multiple policies. These policies matched: {}. You can "
8027                     "utilize these long names to specify the correct policy"
8028                 )
8029                 return False, None, [], msg.format(policy_name, suggested_policies)
8030     return (
8031         False,
8032         None,
8033         [],
8034         "Unable to find {} policy {}".format(policy_class, policy_name),
8035     )
8036 def get_policy_info(policy_name, policy_class, adml_language="en-US"):
8037     r"""
8038     Returns information about a specified policy
8039     Args:
8040         policy_name (str):
8041             The name of the policy to lookup
8042         policy_class (str):
8043             The class of policy, i.e. machine, user, both
8044         adml_language (str):
8045             The ADML language to use for Administrative Template data lookup
8046     Returns:
8047         dict: Information about the specified policy
8048     CLI Example:
8049     .. code-block:: bash
8050         salt '*' lgpo.get_policy_info 'Maximum password age' machine
8051     You can use ``lgpo.get_policy_info`` to get all the possible names that
8052     could be used in a state file or from the command line (along with elements
8053     that need to be set/etc). The key is to match the text you see in the
8054     ``gpedit.msc`` gui exactly, including quotes around words or phrases. The
8055     "full path" style is really only needed when there are multiple policies
8056     that use the same base name. For example, ``Access data sources across
8057     domains`` exists in ~10 different paths. If you put that through
8058     ``get_policy_info`` you'll get back a message that it is used for multiple
8059     policies and you need to be more specific.
8060     CLI Example:
8061     .. code-block:: bash
8062         salt-call --local lgpo.get_policy_info ShellRemoveOrderPrints_2 machine
8063         local:
8064             ----------
8065             message:
8066             policy_aliases:
8067                 - Turn off the "Order Prints" picture task
8068                 - ShellRemoveOrderPrints_2
8069                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
8070             policy_class:
8071                 machine
8072             policy_elements:
8073             policy_found:
8074                 True
8075             policy_name:
8076                 ShellRemoveOrderPrints_2
8077             rights_assignment:
8078                 False
8079     Escaping can get tricky in cmd/Powershell. The following is an example of
8080     escaping in Powershell using backquotes:
8081     .. code-block:: bash
8082         PS&gt;salt-call --local lgpo.get_policy_info "Turn off the `\`"Order Prints`\`" picture task" machine
8083         local:
8084             ----------
8085             message:
8086             policy_aliases:
8087                 - Turn off the "Order Prints" picture task
8088                 - ShellRemoveOrderPrints_2
8089                 - System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task
8090             policy_class:
8091                 machine
8092             policy_elements:
8093             policy_found:
8094                 True
8095             policy_name:
8096                 Turn off the "Order Prints" picture task
8097             rights_assignment:
8098                 False
8099     This function can then be used to get the options available for specifying
8100     Group Policy Objects to be used in state files. Based on the above any of
8101     these *should* be usable:
8102     .. code-block:: bash
8103         internet_communications_settings:
8104           lgpo.set:
8105             - computer_policy:
8106                 Turn off the "Order Prints" picture task: Enabled
8107     .. code-block:: bash
8108         internet_communications_settings:
8109           lgpo.set:
8110             - computer_policy:
8111                 ShellRemoveOrderPrints_2: Enabled
8112     When using the full path, it might be a good idea to use single quotes
8113     around the path:
8114     .. code-block:: bash
8115         internet_communications_settings:
8116           lgpo.set:
8117             - computer_policy:
8118                 'System\Internet Communication Management\Internet Communication settings\Turn off the "Order Prints" picture task': 'Enabled'
8119     If you struggle to find the policy from ``get_policy_info`` using the name
8120     as you see in ``gpedit.msc``, the names such as "ShellRemoveOrderPrints_2"
8121     come from the ``.admx`` files. If you know nothing about ``.admx/.adml``
8122     relationships (ADML holds what you see in the GUI, ADMX holds the more
8123     technical details), then this may be a little bit too much info, but here is
8124     an example with the above policy using Powershell:
8125     .. code-block:: bash
8126         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.adml | Select-String "Order Prints"
8127         C:\windows\PolicyDefinitions\en-US\ICM.adml:152:      &lt;string id="ShellRemoveOrderPrints"&gt;Turn off the "Order Prints" picture task&lt;/string&gt;
8128         C:\windows\PolicyDefinitions\en-US\ICM.adml:153:      &lt;string id="ShellRemoveOrderPrints_Help"&gt;This policy setting specifies whether the "Order Prints Online" task is available from Picture Tasks in Windows folders.
8129         C:\windows\PolicyDefinitions\en-US\ICM.adml:155:The Order Prints Online Wizard is used to download a list of providers and allow users to order prints online.
8130         C:\windows\PolicyDefinitions\en-US\ICM.adml:157:If you enable this policy setting, the task "Order Prints Online" is removed from Picture Tasks in File Explorer folders.
8131     From this grep, we can see id "ShellRemoveOrderPrints" is the ID of the
8132     string used to describe this policy, then we search for it in the ADMX:
8133     .. code-block:: bash
8134         PS&gt;Get-ChildItem -Path C:\Windows\PolicyDefinitions -Recurse -Filter *.admx | Select-String "ShellRemoveOrderPrints"
8135         C:\windows\PolicyDefinitions\ICM.admx:661:    &lt;policy name="ShellRemoveOrderPrints_1" class="User" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
8136         C:\windows\PolicyDefinitions\ICM.admx:671:    &lt;policy name="ShellRemoveOrderPrints_2" class="Machine" displayName="$(string.ShellRemoveOrderPrints)" explainText="$(string.ShellRemoveOrderPrints_Help)" key="Software\Microsoft\Windows\CurrentVersion\Policies\Explorer" valueName="NoOnlinePrintsWizard"&gt;
8137     Now we have two to pick from. And if you notice the ``class="Machine"`` and
8138     ``class="User"`` (which details if it is a computer policy or user policy
8139     respectively) the ``ShellRemoveOrderPrints_2`` is the "short name" we could
8140     use to pass through ``get_policy_info`` to see what the module itself is
8141     expecting.
8142     """
8143     ret = {
8144         "policy_name": policy_name,
8145         "policy_class": policy_class,
8146         "policy_aliases": [],
8147         "policy_found": False,
8148         "rights_assignment": False,
8149         "policy_elements": [],
8150         "message": "policy not found",
8151     }
8152     policy_class = policy_class.title()
8153     policy_data = _policy_info()
8154     if policy_class not in policy_data.policies.keys():
8155         policy_classes = ", ".join(policy_data.policies.keys())
8156         ret["message"] = (
8157             'The requested policy class "{}" is invalid, '
8158             "policy_class should be one of: {}"
8159             "".format(policy_class, policy_classes)
8160         )
8161         return ret
8162     if policy_name in policy_data.policies[policy_class]["policies"]:
8163         ret["policy_aliases"].append(
8164             policy_data.policies[policy_class]["policies"][policy_name]["Policy"]
8165         )
8166         ret["policy_found"] = True
8167         ret["message"] = ""
8168         if "LsaRights" in policy_data.policies[policy_class]["policies"][policy_name]:
8169             ret["rights_assignment"] = True
8170         return ret
8171     else:
8172         for pol in policy_data.policies[policy_class]["policies"]:
8173             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8174             if _p == policy_name:
8175                 ret["policy_aliases"].append(pol)
8176                 ret["policy_found"] = True
8177                 ret["message"] = ""
8178                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8179                     ret["rights_assignment"] = True
8180                 return ret
8181         for pol in policy_data.policies[policy_class]["policies"]:
8182             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
8183             if _p.lower() == policy_name.lower():
8184                 ret["policy_aliases"].append(pol)
8185                 ret["policy_found"] = True
8186                 ret["message"] = ""
8187                 if "LsaRights" in policy_data.policies[policy_class]["policies"][pol]:
8188                     ret["rights_assignment"] = True
8189                 return ret
8190     success, policy_xml_item, policy_name_list, message = _lookup_admin_template(
8191         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
8192     )
8193     if success:
8194         for elements_item in ELEMENTS_XPATH(policy_xml_item):
8195             for child_item in elements_item:
8196                 this_element_name = _getFullPolicyName(
8197                     policy_item=child_item,
8198                     policy_name=child_item.attrib["id"],
8199                     return_full_policy_names=True,
8200                     adml_language=adml_language,
8201                 )
8202                 ret["policy_elements"].append(
8203                     {
8204                         "element_id": child_item.attrib["id"],
8205                         "element_aliases": [child_item.attrib["id"], this_element_name],
8206                     }
8207                 )
8208         ret["policy_aliases"] = policy_name_list
8209         ret["policy_found"] = True
8210         ret["message"] = ""
8211         return ret
8212     else:
8213         ret["message"] = message
8214     return ret
8215 def get(
8216     policy_class=None,
8217     return_full_policy_names=True,
8218     hierarchical_return=False,
8219     adml_language="en-US",
8220     return_not_configured=False,
8221 ):
8222     """
8223     Get a policy value
8224     Args:
8225         policy_class (str):
8226             Some policies are both user and computer, by default all policies
8227             will be pulled, but this can be used to retrieve only a specific
8228             policy class User/USER/user = retrieve user policies
8229             Machine/MACHINE/machine/Computer/COMPUTER/computer = retrieve
8230             machine/computer policies
8231         return_full_policy_names (bool):
8232             True/False to return the policy name as it is seen in the
8233             ``gpedit.msc`` GUI or to only return the policy key/id.
8234         hierarchical_return (bool):
8235             True/False to return the policy data in the hierarchy as seen in the
8236             ``gpedit.msc`` GUI. The default of False will return data split only
8237             into User/Computer configuration sections
8238         adml_language (str):
8239             The ADML language to use for processing display/descriptive names
8240             and enumeration values of ADMX template data, defaults to en-US
8241         return_not_configured (bool):
8242             Include Administrative Template policies that are 'Not Configured'
8243             in the return data
8244     Returns:
8245         dict: A dictionary containing the policy values for the specified class
8246     CLI Example:
8247     .. code-block:: bash
8248         salt '*' lgpo.get machine return_full_policy_names=True
8249     """
8250     vals = {}
8251     _policydata = _policy_info()
8252     if policy_class is None or policy_class.lower() == "both":
8253         policy_class = _policydata.policies.keys()
8254     elif policy_class.lower() not in [z.lower() for z in _policydata.policies]:
8255         msg = (
8256             "The policy_class {} is not an available policy class, please "
8257             "use one of the following: {}, Both"
8258         )
8259         raise SaltInvocationError(
8260             msg.format(policy_class, ", ".join(_policydata.policies.keys()))
8261         )
8262     else:
8263         policy_class = [policy_class.title()]
8264     for p_class in policy_class:
8265         this_class_policy_names = _policydata.policies[p_class]["policies"]
8266         class_vals = {}
8267         for policy_name in this_class_policy_names:
8268             _pol = None
8269             if policy_name in _policydata.policies[p_class]["policies"]:
8270                 _pol = _policydata.policies[p_class]["policies"][policy_name]
8271             else:
8272                 for policy in _policydata.policies[p_class]["policies"]:
8273                     _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8274                     if _p == policy_name:
8275                         _pol = _policydata.policies[p_class]["policies"][policy]
8276                         policy_name = policy
8277                 if _pol is None:
8278                     for policy in _policydata.policies[p_class]["policies"]:
8279                         _p = _policydata.policies[p_class]["policies"][policy]["Policy"]
8280                         if _p.lower() == policy_name.lower():
8281                             _pol = _policydata.policies[p_class]["policies"][policy]
8282                             policy_name = policy
8283             if _pol:
8284                 vals_key_name = policy_name
8285                 class_vals[policy_name] = _get_policy_info_setting(_pol)
8286                 if return_full_policy_names:
8287                     class_vals[_pol["Policy"]] = class_vals.pop(policy_name)
8288                     vals_key_name = _pol["Policy"]
8289                 if hierarchical_return:
8290                     if "lgpo_section" in _pol:
8291                         firstItem = True
8292                         tdict = {}
8293                         for level in reversed(_pol["lgpo_section"]):
8294                             newdict = {}
8295                             if firstItem:
8296                                 newdict[level] = {
8297                                     vals_key_name: class_vals.pop(vals_key_name)
8298                                 }
8299                                 firstItem = False
8300                             else:
8301                                 newdict[level] = tdict
8302                             tdict = newdict
8303                         if tdict:
8304                             class_vals = dictupdate.update(class_vals, tdict)
8305             else:
8306                 raise CommandExecutionError(
8307                     "The specified policy {} is not currently available "
8308                     "to be configured via this module".format(policy_name)
8309                 )
8310         class_vals = dictupdate.update(
8311             class_vals,
8312             _checkAllAdmxPolicies(
8313                 policy_class=p_class,
8314                 adml_language=adml_language,
8315                 return_full_policy_names=return_full_policy_names,
8316                 hierarchical_return=hierarchical_return,
8317                 return_not_configured=return_not_configured,
8318             ),
8319         )
8320         if _policydata.policies[p_class]["lgpo_section"] not in class_vals:
8321             temp_dict = {_policydata.policies[p_class]["lgpo_section"]: class_vals}
8322             class_vals = temp_dict
8323         vals = dictupdate.update(vals, class_vals)
8324     return vals
8325 def _get_policy_info_setting(policy_definition):
8326     """
8327     Some policies are defined in this module and others by the ADMX/ADML files
8328     on the machine. This function loads the current values for policies defined
8329     in this module.
8330     Args:
8331         policy_definition (dict):
8332             A sub-dict of Policies property of the _policy_info() class.
8333             Basically a dictionary that defines the policy
8334     Returns:
8335         The transformed value. The transform is defined in the policy
8336         definition. It can be a list, a string, a dictionary, depending on how
8337         it's defined
8338     Usage:
8339         policy_data = _policy_info()
8340         policy_name = 'RemoteRegistryExactPaths'
8341         policy_definition = policy_data.policies['Machine']['policies'][policy_name]
8342         policy_value = _get_policy_info_setting(policy_definition)
8343     """
8344     if "Registry" in policy_definition:
8345         value = __utils__["reg.read_value"](
8346             policy_definition["Registry"]["Hive"],
8347             policy_definition["Registry"]["Path"],
8348             policy_definition["Registry"]["Value"],
8349         )["vdata"]
8350         log.trace(
8351             "Value %r found for Regisry policy %s", value, policy_definition["Policy"]
8352         )
8353     elif "Secedit" in policy_definition:
8354         value = _get_secedit_value(option=policy_definition["Secedit"]["Option"])
8355         log.trace(
8356             "Value %r found for Secedit policy %s", value, policy_definition["Policy"]
8357         )
8358     elif "NetSH" in policy_definition:
8359         value = _get_netsh_value(
8360             profile=policy_definition["NetSH"]["Profile"],
8361             option=policy_definition["NetSH"]["Option"],
8362         )
8363         log.trace(
8364             "Value %r found for NetSH policy %s", value, policy_definition["Policy"]
8365         )
8366     elif "AdvAudit" in policy_definition:
8367         value = _get_advaudit_value(option=policy_definition["AdvAudit"]["Option"])
8368         log.trace(
8369             "Value %r found for AuditPol policy %s", value, policy_definition["Policy"]
8370         )
8371     elif "NetUserModal" in policy_definition:
8372         modal_return = win32net.NetUserModalsGet(
8373             None, policy_definition["NetUserModal"]["Modal"]
8374         )
8375         value = modal_return[policy_definition["NetUserModal"]["Option"]]
8376         log.trace(
8377             "Value %r found for NetUserModal policy %s",
8378             value,
8379             policy_definition["Policy"],
8380         )
8381     elif "LsaRights" in policy_definition:
8382         value = _getRightsAssignments(policy_definition["LsaRights"]["Option"])
8383         log.trace(
8384             "Value %r found for LSARights policy %s", value, policy_definition["Policy"]
8385         )
8386     elif "ScriptIni" in policy_definition:
8387         value = _getScriptSettingsFromIniFile(policy_definition)
8388         log.trace(
8389             "Value %r found for ScriptIni policy %s", value, policy_definition["Policy"]
8390         )
8391     else:
8392         raise CommandExecutionError(
8393             "Unknown or missing mechanism in policy_definition\n{}".format(
8394                 policy_definition
8395             )
8396         )
8397     value = _transform_value(
8398         value=value, policy=policy_definition, transform_type="Get"
8399     )
8400     return value
8401 def _get_policy_adm_setting(
8402     admx_policy,
8403     policy_class,
8404     adml_language="en-US",
8405     return_full_policy_names=False,
8406     hierarchical_return=False,
8407 ):
8408     """
8409     Get the current setting for polices set via the policy templates (ADMX/ADML)
8410     files
8411     Args:
8412         admx_policy (obj):
8413             The XPath object as returned by the ``_lookup_admin_template``
8414             function
8415         policy_class (str):
8416             The policy class. Must be one of ``machine`` or ``user``
8417         adml_language (str):
8418             The language code for the adml file to use for localization. The
8419             default is ``en-US``
8420         return_full_policy_names (bool):
8421             Returns the full policy name regardless of what was passed in
8422             ``policy_name``
8423         hierarchical_return (bool):
8424             Returns a hierarchical view of the policy showing its parents
8425     Returns:
8426         dict: A dictionary containing the policy settings
8427     Usage:
8428         policy_name = 'AutoUpdateCfg'
8429         policy_class = 'machine'
8430         adml_language = 'en-US'
8431         success, policy_obj, _, _ = _lookup_admin_template(
8432             policy_name=policy_name,
8433             policy_class=policy_class,
8434             adml_language=adml_language)
8435         if success:
8436             setting = _get_policy_adm_setting(
8437                 admx_policy=policy_obj,
8438                 policy_class=policy_class,
8439                 adml_language=adml_language,
8440                 return_full_policy_names=return_full_policy_names,
8441                 hierarchical_return=hierarchical_return
8442             )
8443     """
8444     this_key = admx_policy.attrib.get("key", None)
8445     this_policy_name = admx_policy.attrib.get("name", None)
8446     if this_key is None or this_policy_name is None:
8447         raise CommandExecutionError(
8448             'Policy is missing the required "key" or "name" attribute:\n{}'.format(
8449                 admx_policy.attrib
8450             )
8451         )
8452     this_value_name = admx_policy.attrib.get("valueName", None)
8453     this_policy_setting = "Not Configured"
8454     this_policy_namespace = admx_policy.nsmap[admx_policy.prefix]
8455     element_only_enabled_disabled = True
8456     explicit_enable_disable_value_setting = False
8457     policy_data = _policy_info()
8458     policy_file_data = _read_regpol_file(
8459         policy_data.admx_registry_classes[policy_class]["policy_path"]
8460     )
8461     adml_policy_resources = _get_policy_resources(language=adml_language)
8462     policy_vals = {}
8463     if ENABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8464         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8465             element_only_enabled_disabled = False
8466             explicit_enable_disable_value_setting = True
8467             if _checkValueItemParent(
8468                 policy_element=admx_policy,
8469                 policy_name=this_policy_name,
8470                 policy_key=this_key,
8471                 policy_valueName=this_value_name,
8472                 xpath_object=ENABLED_VALUE_XPATH,
8473                 policy_file_data=policy_file_data,
8474             ):
8475                 log.trace(
8476                     "%s is enabled by detected ENABLED_VALUE_XPATH", this_policy_name
8477                 )
8478                 this_policy_setting = "Enabled"
8479                 policy_vals.setdefault(this_policy_namespace, {})[
8480                     this_policy_name
8481                 ] = this_policy_setting
8482     if DISABLED_VALUE_XPATH(admx_policy) and this_policy_setting == "Not Configured":
8483         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8484             element_only_enabled_disabled = False
8485             explicit_enable_disable_value_setting = True
8486             if _checkValueItemParent(
8487                 policy_element=admx_policy,
8488                 policy_name=this_policy_name,
8489                 policy_key=this_key,
8490                 policy_valueName=this_value_name,
8491                 xpath_object=DISABLED_VALUE_XPATH,
8492                 policy_file_data=policy_file_data,
8493             ):
8494                 log.trace(
8495                     "%s is disabled by detected DISABLED_VALUE_XPATH", this_policy_name
8496                 )
8497                 this_policy_setting = "Disabled"
8498                 policy_vals.setdefault(this_policy_namespace, {})[
8499                     this_policy_name
8500                 ] = this_policy_setting
8501     if ENABLED_LIST_XPATH(admx_policy):
8502         if DISABLED_LIST_XPATH(admx_policy) or DISABLED_VALUE_XPATH(admx_policy):
8503             element_only_enabled_disabled = False
8504             explicit_enable_disable_value_setting = True
8505             if _checkListItem(
8506                 policy_element=admx_policy,
8507                 policy_name=this_policy_name,
8508                 policy_key=this_key,
8509                 xpath_object=ENABLED_LIST_XPATH,
8510                 policy_file_data=policy_file_data,
8511             ):
8512                 log.trace(
8513                     "%s is enabled by detected ENABLED_LIST_XPATH", this_policy_name
8514                 )
8515                 this_policy_setting = "Enabled"
8516                 policy_vals.setdefault(this_policy_namespace, {})[
8517                     this_policy_name
8518                 ] = this_policy_setting
8519     if DISABLED_LIST_XPATH(admx_policy):
8520         if ENABLED_LIST_XPATH(admx_policy) or ENABLED_VALUE_XPATH(admx_policy):
8521             element_only_enabled_disabled = False
8522             explicit_enable_disable_value_setting = True
8523             if _checkListItem(
8524                 policy_element=admx_policy,
8525                 policy_name=this_policy_name,
8526                 policy_key=this_key,
8527                 xpath_object=DISABLED_LIST_XPATH,
8528                 policy_file_data=policy_file_data,
8529             ):
8530                 log.trace(
8531                     "%s is disabled by detected DISABLED_LIST_XPATH", this_policy_name
8532                 )
8533                 this_policy_setting = "Disabled"
8534                 policy_vals.setdefault(this_policy_namespace, {})[
8535                     this_policy_name
8536                 ] = this_policy_setting
8537     if not explicit_enable_disable_value_setting and this_value_name:
8538         if _regexSearchRegPolData(
8539             re.escape(
8540                 _buildKnownDataSearchString(
8541                     reg_key=this_key,
8542                     reg_valueName=this_value_name,
8543                     reg_vtype="REG_DWORD",
8544                     reg_data="1",
8545                 )
8546             ),
8547             policy_file_data,
8548         ):
8549             log.trace(
8550                 "%s is enabled by no explicit enable/disable list or value",
8551                 this_policy_name,
8552             )
8553             this_policy_setting = "Enabled"
8554             policy_vals.setdefault(this_policy_namespace, {})[
8555                 this_policy_name
8556             ] = this_policy_setting
8557         elif _regexSearchRegPolData(
8558             re.escape(
8559                 _buildKnownDataSearchString(
8560                     reg_key=this_key,
8561                     reg_valueName=this_value_name,
8562                     reg_vtype="REG_DWORD",
8563                     reg_data=None,
8564                     check_deleted=True,
8565                 )
8566             ),
8567             policy_file_data,
8568         ):
8569             log.trace(
8570                 "%s is disabled by no explicit enable/disable list or value",
8571                 this_policy_name,
8572             )
8573             this_policy_setting = "Disabled"
8574             policy_vals.setdefault(this_policy_namespace, {})[
8575                 this_policy_name
8576             ] = this_policy_setting
8577     full_names = {}
8578     hierarchy = {}
8579     if ELEMENTS_XPATH(admx_policy):
8580         if element_only_enabled_disabled or this_policy_setting == "Enabled":
8581             required_elements = {}
8582             configured_elements = {}
8583             policy_disabled_elements = 0
8584             for elements_item in ELEMENTS_XPATH(admx_policy):
8585                 for child_item in elements_item:
8586                     this_element_name = _getFullPolicyName(
8587                         policy_item=child_item,
8588                         policy_name=child_item.attrib["id"],
8589                         return_full_policy_names=return_full_policy_names,
8590                         adml_language=adml_language,
8591                     )
8592                     required_elements[this_element_name] = None
8593                     child_key = child_item.attrib.get("key", this_key)
8594                     child_value_name = child_item.attrib.get(
8595                         "valueName", this_value_name
8596                     )
8597                     if etree.QName(child_item).localname == "boolean":
8598                         if child_item is not None:
8599                             if (
8600                                 TRUE_VALUE_XPATH(child_item)
8601                                 and this_element_name not in configured_elements
8602                             ):
8603                                 if _checkValueItemParent(
8604                                     policy_element=child_item,
8605                                     policy_name=this_policy_name,
8606                                     policy_key=child_key,
8607                                     policy_valueName=child_value_name,
8608                                     xpath_object=TRUE_VALUE_XPATH,
8609                                     policy_file_data=policy_file_data,
8610                                 ):
8611                                     configured_elements[this_element_name] = True
8612                                     log.trace(
8613                                         "element %s is configured true",
8614                                         child_item.attrib["id"],
8615                                     )
8616                             if (
8617                                 FALSE_VALUE_XPATH(child_item)
8618                                 and this_element_name not in configured_elements
8619                             ):
8620                                 if _checkValueItemParent(
8621                                     policy_element=child_item,
8622                                     policy_name=this_policy_name,
8623                                     policy_key=child_key,
8624                                     policy_valueName=child_value_name,
8625                                     xpath_object=FALSE_VALUE_XPATH,
8626                                     policy_file_data=policy_file_data,
8627                                 ):
8628                                     configured_elements[this_element_name] = False
8629                                     policy_disabled_elements = (
8630                                         policy_disabled_elements + 1
8631                                     )
8632                                     log.trace(
8633                                         "element %s is configured false",
8634                                         child_item.attrib["id"],
8635                                     )
8636                             if (
8637                                 TRUE_LIST_XPATH(child_item)
8638                                 and this_element_name not in configured_elements
8639                             ):
8640                                 log.trace("checking trueList")
8641                                 if _checkListItem(
8642                                     policy_element=child_item,
8643                                     policy_name=this_policy_name,
8644                                     policy_key=this_key,
8645                                     xpath_object=TRUE_LIST_XPATH,
8646                                     policy_file_data=policy_file_data,
8647                                 ):
8648                                     configured_elements[this_element_name] = True
8649                                     log.trace(
8650                                         "element %s is configured true",
8651                                         child_item.attrib["id"],
8652                                     )
8653                             if (
8654                                 FALSE_LIST_XPATH(child_item)
8655                                 and this_element_name not in configured_elements
8656                             ):
8657                                 log.trace("checking falseList")
8658                                 if _checkListItem(
8659                                     policy_element=child_item,
8660                                     policy_name=this_policy_name,
8661                                     policy_key=this_key,
8662                                     xpath_object=FALSE_LIST_XPATH,
8663                                     policy_file_data=policy_file_data,
8664                                 ):
8665                                     configured_elements[this_element_name] = False
8666                                     policy_disabled_elements = (
8667                                         policy_disabled_elements + 1
8668                                     )
8669                                     log.trace(
8670                                         "element %s is configured false",
8671                                         child_item.attrib["id"],
8672                                     )
8673                         else:
8674                             if _regexSearchRegPolData(
8675                                 re.escape(
8676                                     _processValueItem(
8677                                         element=child_item,
8678                                         reg_key=child_key,
8679                                         reg_valuename=child_value_name,
8680                                         policy=admx_policy,
8681                                         parent_element=elements_item,
8682                                         check_deleted=True,
8683                                     )
8684                                 ),
8685                                 policy_file_data,
8686                             ):
8687                                 configured_elements[this_element_name] = False
8688                                 policy_disabled_elements = policy_disabled_elements + 1
8689                                 log.trace(
8690                                     "element %s is configured false",
8691                                     child_item.attrib["id"],
8692                                 )
8693                             elif _regexSearchRegPolData(
8694                                 re.escape(
8695                                     _processValueItem(
8696                                         element=child_item,
8697                                         reg_key=child_key,
8698                                         reg_valuename=child_value_name,
8699                                         policy=admx_policy,
8700                                         parent_element=elements_item,
8701                                         check_deleted=False,
8702                                     )
8703                                 ),
8704                                 policy_file_data,
8705                             ):
8706                                 configured_elements[this_element_name] = True
8707                                 log.trace(
8708                                     "element %s is configured true",
8709                                     child_item.attrib["id"],
8710                                 )
8711                     elif etree.QName(child_item).localname in [
8712                         "decimal",
8713                         "text",
8714                         "longDecimal",
8715                         "multiText",
8716                     ]:
8717                         if _regexSearchRegPolData(
8718                             re.escape(
8719                                 _processValueItem(
8720                                     element=child_item,
8721                                     reg_key=child_key,
8722                                     reg_valuename=child_value_name,
8723                                     policy=admx_policy,
8724                                     parent_element=elements_item,
8725                                     check_deleted=True,
8726                                 )
8727                             ),
8728                             policy_file_data,
8729                         ):
8730                             configured_elements[this_element_name] = "Disabled"
8731                             policy_disabled_elements = policy_disabled_elements + 1
8732                             log.trace("element %s is disabled", child_item.attrib["id"])
8733                         elif _regexSearchRegPolData(
8734                             re.escape(
8735                                 _processValueItem(
8736                                     element=child_item,
8737                                     reg_key=child_key,
8738                                     reg_valuename=child_value_name,
8739                                     policy=admx_policy,
8740                                     parent_element=elements_item,
8741                                     check_deleted=False,
8742                                 )
8743                             ),
8744                             policy_data=policy_file_data,
8745                         ):
8746                             configured_value = _getDataFromRegPolData(
8747                                 _processValueItem(
8748                                     element=child_item,
8749                                     reg_key=child_key,
8750                                     reg_valuename=child_value_name,
8751                                     policy=admx_policy,
8752                                     parent_element=elements_item,
8753                                     check_deleted=False,
8754                                 ),
8755                                 policy_data=policy_file_data,
8756                             )
8757                             configured_elements[this_element_name] = configured_value
8758                             log.trace(
8759                                 "element %s is enabled, value == %s",
8760                                 child_item.attrib["id"],
8761                                 configured_value,
8762                             )
8763                     elif etree.QName(child_item).localname == "enum":
8764                         if _regexSearchRegPolData(
8765                             re.escape(
8766                                 _processValueItem(
8767                                     element=child_item,
8768                                     reg_key=child_key,
8769                                     reg_valuename=child_value_name,
8770                                     policy=admx_policy,
8771                                     parent_element=elements_item,
8772                                     check_deleted=True,
8773                                 )
8774                             ),
8775                             policy_file_data,
8776                         ):
8777                             log.trace(
8778                                 "enum element %s is disabled", child_item.attrib["id"]
8779                             )
8780                             configured_elements[this_element_name] = "Disabled"
8781                             policy_disabled_elements = policy_disabled_elements + 1
8782                         else:
8783                             for enum_item in child_item:
8784                                 if _checkValueItemParent(
8785                                     policy_element=enum_item,
8786                                     policy_name=child_item.attrib["id"],
8787                                     policy_key=child_key,
8788                                     policy_valueName=child_value_name,
8789                                     xpath_object=VALUE_XPATH,
8790                                     policy_file_data=policy_file_data,
8791                                 ):
8792                                     if VALUE_LIST_XPATH(enum_item):
8793                                         log.trace("enum item has a valueList")
8794                                         if _checkListItem(
8795                                             policy_element=enum_item,
8796                                             policy_name=this_policy_name,
8797                                             policy_key=child_key,
8798                                             xpath_object=VALUE_LIST_XPATH,
8799                                             policy_file_data=policy_file_data,
8800                                         ):
8801                                             log.trace(
8802                                                 "all valueList items exist in file"
8803                                             )
8804                                             configured_elements[
8805                                                 this_element_name
8806                                             ] = _getAdmlDisplayName(
8807                                                 adml_xml_data=adml_policy_resources,
8808                                                 display_name=enum_item.attrib[
8809                                                     "displayName"
8810                                                 ],
8811                                             )
8812                                             break
8813                                     else:
8814                                         configured_elements[
8815                                             this_element_name
8816                                         ] = _getAdmlDisplayName(
8817                                             adml_xml_data=adml_policy_resources,
8818                                             display_name=enum_item.attrib[
8819                                                 "displayName"
8820                                             ],
8821                                         )
8822                                         break
8823                     elif etree.QName(child_item).localname == "list":
8824                         return_value_name = False
8825                         if (
8826                             "explicitValue" in child_item.attrib
8827                             and child_item.attrib["explicitValue"].lower() == "true"
8828                         ):
8829                             log.trace("explicitValue list, we will return value names")
8830                             return_value_name = True
8831                         regex_str = [
8832                             r"(?!\*",
8833                             r"\*",
8834                             "D",
8835                             "e",
8836                             "l",
8837                             "V",
8838                             "a",
8839                             "l",
8840                             "s",
8841                             r"\.",
8842                             ")",
8843                         ]
8844                         delvals_regex = "\x00".join(regex_str)
8845                         delvals_regex = salt.utils.stringutils.to_bytes(delvals_regex)
8846                         if _regexSearchRegPolData(
8847                             re.escape(
8848                                 _processValueItem(
8849                                     element=child_item,
8850                                     reg_key=child_key,
8851                                     reg_valuename=child_value_name,
8852                                     policy=admx_policy,
8853                                     parent_element=elements_item,
8854                                     check_deleted=False,
8855                                 )
8856                             )
8857                             + delvals_regex,
8858                             policy_data=policy_file_data,
8859                         ):
8860                             configured_value = _getDataFromRegPolData(
8861                                 _processValueItem(
8862                                     element=child_item,
8863                                     reg_key=child_key,
8864                                     reg_valuename=child_value_name,
8865                                     policy=admx_policy,
8866                                     parent_element=elements_item,
8867                                     check_deleted=False,
8868                                 ),
8869                                 policy_data=policy_file_data,
8870                                 return_value_name=return_value_name,
8871                             )
8872                             configured_elements[this_element_name] = configured_value
8873                             log.trace(
8874                                 "element %s is enabled values: %s",
8875                                 child_item.attrib["id"],
8876                                 configured_value,
8877                             )
8878                         elif _regexSearchRegPolData(
8879                             re.escape(
8880                                 _processValueItem(
8881                                     element=child_item,
8882                                     reg_key=child_key,
8883                                     reg_valuename=child_value_name,
8884                                     policy=admx_policy,
8885                                     parent_element=elements_item,
8886                                     check_deleted=True,
8887                                 )
8888                             ),
8889                             policy_file_data,
8890                         ):
8891                             configured_elements[this_element_name] = "Disabled"
8892                             policy_disabled_elements = policy_disabled_elements + 1
8893                             log.trace("element %s is disabled", child_item.attrib["id"])
8894             if element_only_enabled_disabled:
8895                 if 0 &lt; len(required_elements.keys()) == len(configured_elements.keys()):
8896                     if policy_disabled_elements == len(required_elements.keys()):
8897                         log.trace(
8898                             "%s is disabled by all enum elements", this_policy_name
8899                         )
8900                         policy_vals.setdefault(this_policy_namespace, {})[
8901                             this_policy_name
8902                         ] = "Disabled"
8903                     else:
8904                         log.trace("%s is enabled by enum elements", this_policy_name)
8905                         policy_vals.setdefault(this_policy_namespace, {})[
8906                             this_policy_name
8907                         ] = configured_elements
8908                 else:
8909                     policy_vals.setdefault(this_policy_namespace, {})[
8910                         this_policy_name
8911                     ] = this_policy_setting
8912             else:
8913                 if this_policy_setting == "Enabled":
8914                     policy_vals.setdefault(this_policy_namespace, {})[
8915                         this_policy_name
8916                     ] = configured_elements
8917         else:
8918             policy_vals.setdefault(this_policy_namespace, {})[
8919                 this_policy_name
8920             ] = this_policy_setting
8921     else:
8922         policy_vals.setdefault(this_policy_namespace, {})[
8923             this_policy_name
8924         ] = this_policy_setting
8925     if (
8926         return_full_policy_names
8927         and this_policy_namespace in policy_vals
8928         and this_policy_name in policy_vals[this_policy_namespace]
8929     ):
8930         full_names.setdefault(this_policy_namespace, {})
8931         full_names[this_policy_namespace][this_policy_name] = _getFullPolicyName(
8932             policy_item=admx_policy,
8933             policy_name=admx_policy.attrib["name"],
8934             return_full_policy_names=return_full_policy_names,
8935             adml_language=adml_language,
8936         )
8937         if this_policy_name in policy_vals[this_policy_namespace][this_policy_name]:
8938             full_name = full_names[this_policy_namespace][this_policy_name]
8939             setting = policy_vals[this_policy_namespace][this_policy_name].pop(
8940                 this_policy_name
8941             )
8942             policy_vals[this_policy_namespace][this_policy_name][full_name] = setting
8943     if (
8944         this_policy_namespace in policy_vals
8945         and this_policy_name in policy_vals[this_policy_namespace]
8946     ):
8947         hierarchy.setdefault(this_policy_namespace, {})[
8948             this_policy_name
8949         ] = _build_parent_list(
8950             policy_definition=admx_policy,
8951             return_full_policy_names=return_full_policy_names,
8952             adml_language=adml_language,
8953         )
8954     if policy_vals and return_full_policy_names and not hierarchical_return:
8955         log.debug("Compiling non hierarchical return...")
8956         unpathed_dict = {}
8957         pathed_dict = {}
8958         for policy_namespace in list(policy_vals):
8959             for policy_item in list(policy_vals[policy_namespace]):
8960                 full_name = full_names[policy_namespace][policy_item]
8961                 if full_name in policy_vals[policy_namespace]:
8962                     full_path_list = hierarchy[policy_namespace][policy_item]
8963                     full_path_list.reverse()
8964                     full_path_list.append(full_names[policy_namespace][policy_item])
8965                     policy_vals["\\".join(full_path_list)] = policy_vals[
8966                         policy_namespace
8967                     ].pop(policy_item)
8968                     pathed_dict[full_name] = True
8969                 else:
8970                     policy_vals[policy_namespace][full_name] = policy_vals[
8971                         policy_namespace
8972                     ].pop(policy_item)
8973                     unpathed_dict.setdefault(policy_namespace, {})[
8974                         full_name
8975                     ] = policy_item
8976             for path_needed in unpathed_dict[policy_namespace]:
8977                 full_path_list = hierarchy[policy_namespace][
8978                     unpathed_dict[policy_namespace][path_needed]
8979                 ]
8980                 full_path_list.reverse()
8981                 full_path_list.append(path_needed)
8982                 log.trace("full_path_list == %s", full_path_list)
8983                 policy_vals["\\".join(full_path_list)] = policy_vals[
8984                     policy_namespace
8985                 ].pop(path_needed)
8986     for policy_namespace in list(policy_vals):
8987         if policy_vals[policy_namespace] == {}:
8988             policy_vals.pop(policy_namespace)
8989         elif isinstance(policy_vals[policy_namespace], dict):
8990             if this_policy_namespace == policy_namespace and not hierarchical_return:
8991                 policy_vals.update(policy_vals[policy_namespace])
8992                 policy_vals.pop(policy_namespace)
8993     if policy_vals and hierarchical_return:
8994         if hierarchy:
8995             log.debug("Compiling hierarchical return...")
8996             for policy_namespace in hierarchy:
8997                 for hierarchy_item in hierarchy[policy_namespace]:
8998                     if hierarchy_item in policy_vals[policy_namespace]:
8999                         t_dict = {}
9000                         first_item = True
9001                         for item in hierarchy[policy_namespace][hierarchy_item]:
9002                             new_dict = {}
9003                             if first_item:
9004                                 h_policy_name = hierarchy_item
9005                                 if return_full_policy_names:
9006                                     h_policy_name = full_names[policy_namespace][
9007                                         hierarchy_item
9008                                     ]
9009                                 new_dict[item] = {
9010                                     h_policy_name: policy_vals[policy_namespace].pop(
9011                                         hierarchy_item
9012                                     )
9013                                 }
9014                                 first_item = False
9015                             else:
9016                                 new_dict[item] = t_dict
9017                             t_dict = new_dict
9018                         if t_dict:
9019                             policy_vals = dictupdate.update(policy_vals, t_dict)
9020                 if (
9021                     policy_namespace in policy_vals
9022                     and policy_vals[policy_namespace] == {}
9023                 ):
9024                     policy_vals.pop(policy_namespace)
9025         policy_vals = {
9026             policy_data.admx_registry_classes[policy_class]["lgpo_section"]: {
9027                 "Administrative Templates": policy_vals
9028             }
9029         }
9030     return policy_vals
9031 def get_policy(
9032     policy_name,
9033     policy_class,
9034     adml_language="en-US",
9035     return_value_only=True,
9036     return_full_policy_names=True,
9037     hierarchical_return=False,
9038 ):
9039     r"""
9040     Get the current settings for a single policy on the machine
9041     Args:
9042         policy_name (str):
9043             The name of the policy to retrieve. Can be the any of the names
9044             or alieses returned by ``lgpo.get_policy_info``
9045         policy_class (str):
9046             The policy class. Must be one of ``machine`` or ``user``
9047         adml_language (str):
9048             The language code for the adml file to use for localization. The
9049             default is ``en-US``
9050         return_value_only (bool):
9051             ``True`` will return only the value for the policy, without the
9052             name of the policy. ``return_full_policy_names`` and
9053             ``hierarchical_return`` will be ignored. Default is ``True``
9054         return_full_policy_names (bool):
9055             Returns the full policy name regardless of what was passed in
9056             ``policy_name``
9057             .. note::
9058                 This setting applies to sub-elements of the policy if they
9059                 exist. The value passed in ``policy_name`` will always be used
9060                 as the policy name when this setting is ``False``
9061         hierarchical_return (bool):
9062             Returns a hierarchical view of the policy showing its parents
9063     Returns:
9064         dict: A dictionary containing the policy settings
9065     CLI Example:
9066     .. code-block:: bash
9067         salt * lgpo.get_policy LockoutDuration machine
9068         salt * lgpo.get_policy AutoUpdateCfg machine
9069         salt * lgpo.get_policy "Account lockout duration" machine
9070         salt * lgpo.get_policy "Configure Automatic Updates" machine
9071         salt * lgpo.get_policy "Windows Components\Windows Update\Configure Automatic Updates" machine
9072     """
9073     if not policy_name:
9074         raise SaltInvocationError("policy_name must be defined")
9075     if not policy_class:
9076         raise SaltInvocationError("policy_class must be defined")
9077     policy_class = policy_class.title()
9078     policy_data = _policy_info()
9079     if policy_class not in policy_data.policies.keys():
9080         policy_classes = ", ".join(policy_data.policies.keys())
9081         raise CommandExecutionError(
9082             'The requested policy class "{}" is invalid, policy_class should '
9083             "be one of: {}".format(policy_class, policy_classes)
9084         )
9085     policy_definition = None
9086     if policy_name in policy_data.policies[policy_class]["policies"]:
9087         policy_definition = policy_data.policies[policy_class]["policies"][policy_name]
9088     else:
9089         for pol in policy_data.policies[policy_class]["policies"]:
9090             _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
9091             if _p == policy_name:
9092                 policy_definition = policy_data.policies[policy_class]["policies"][pol]
9093                 break
9094         if policy_definition is None:
9095             for pol in policy_data.policies[policy_class]["policies"]:
9096                 _p = policy_data.policies[policy_class]["policies"][pol]["Policy"]
9097                 if _p.lower() == policy_name.lower():
9098                     policy_definition = policy_data.policies[policy_class]["policies"][
9099                         pol
9100                     ]
9101                     break
9102     if policy_definition:
9103         if return_value_only:
9104             return _get_policy_info_setting(policy_definition)
9105         if return_full_policy_names:
9106             key_name = policy_definition["Policy"]
9107         else:
9108             key_name = policy_name
9109         setting = {key_name: _get_policy_info_setting(policy_definition)}
9110         if hierarchical_return:
9111             if "lgpo_section" in policy_definition:
9112                 first_item = True
9113                 t_dict = {}
9114                 for level in reversed(policy_definition["lgpo_section"]):
9115                     new_dict = {}
9116                     if first_item:
9117                         new_dict[level] = {key_name: setting.pop(key_name)}
9118                         first_item = False
9119                     else:
9120                         new_dict[level] = t_dict
9121                     t_dict = new_dict
9122                 if t_dict:
9123                     setting = t_dict
9124         return setting
9125     success, policy_obj, _, _ = _lookup_admin_template(
9126         policy_name=policy_name, policy_class=policy_class, adml_language=adml_language
9127     )
9128     if success:
9129         setting = _get_policy_adm_setting(
9130             admx_policy=policy_obj,
9131             policy_class=policy_class,
9132             adml_language=adml_language,
9133             return_full_policy_names=return_full_policy_names,
9134             hierarchical_return=hierarchical_return,
9135         )
9136         if return_value_only:
9137             for key in setting:
9138                 return setting[key]
9139         return setting
9140 def set_computer_policy(
9141     name, setting, cumulative_rights_assignments=True, adml_language="en-US"
9142 ):
9143     """
9144     Set a single computer policy
9145     Args:
9146         name (str):
9147             The name of the policy to configure
9148         setting (str):
9149             The setting to configure the named policy with
9150         cumulative_rights_assignments (bool): Determine how user rights
9151             assignment policies are configured. If True, user right assignment
9152             specifications are simply added to the existing policy. If False,
9153             only the users specified will get the right (any existing will have
9154             the right revoked)
9155         adml_language (str): The language files to use for looking up
9156             Administrative Template policy data (i.e. how the policy is
9157             displayed in the GUI).  Defaults to 'en-US' (U.S. English).
9158     Returns:
9159         bool: True if successful, otherwise False
9160     CLI Example:
9161     .. code-block:: bash
9162         salt '*' lgpo.set_computer_policy LockoutDuration 1440
9163     """
9164     pol = {}
9165     pol[name] = setting
9166     ret = set_(
9167         computer_policy=pol,
9168         user_policy=None,
9169         cumulative_rights_assignments=cumulative_rights_assignments,
9170         adml_language=adml_language,
9171     )
9172     return ret
9173 def set_user_policy(name, setting, adml_language="en-US"):
9174     """
9175     Set a single user policy
9176     Args:
9177         name (str):
9178             The name of the policy to configure
9179         setting (str):
9180             The setting to configure the named policy with
9181         adml_language (str):
9182             The language files to use for looking up Administrative Template
9183             policy data (i.e. how the policy is displayed in the GUI). Defaults
9184             to 'en-US' (U.S. English).
9185     Returns:
9186         bool: True if successful, Otherwise False
9187     CLI Example:
9188     .. code-block:: bash
9189         salt '*' lgpo.set_user_policy "Control Panel\\Display\\Disable the Display Control Panel" Enabled
9190     """
9191     pol = {}
9192     pol[name] = setting
9193     ret = set_(
9194         user_policy=pol,
9195         computer_policy=None,
9196         cumulative_rights_assignments=True,
9197         adml_language=adml_language,
9198     )
9199     return ret
9200 def set_(
9201     computer_policy=None,
9202     user_policy=None,
9203     cumulative_rights_assignments=True,
9204     adml_language="en-US",
9205 ):
9206     """
9207     Set a local server policy.
9208     Args:
9209         computer_policy (dict):
9210             A dictionary of "policyname: value" pairs of computer policies to
9211             set. 'value' should be how it is displayed in the gpedit GUI, i.e.
9212             if a setting can be 'Enabled'/'Disabled', then that should be passed
9213             Administrative Template data may require dicts within dicts, to
9214             specify each element of the Administrative Template policy.
9215             Administrative Templates policies are always cumulative.
9216             Policy names can be specified in a number of ways based on the type
9217             of policy:
9218                 Windows Settings Policies:
9219                     These policies can be specified using the GUI display name
9220                     or the key name from the _policy_info class in this module.
9221                     The GUI display name is also contained in the _policy_info
9222                     class in this module.
9223                 Administrative Template Policies:
9224                     These can be specified using the policy name as displayed in
9225                     the GUI (case sensitive). Some policies have the same name,
9226                     but a different location (for example, "Access data sources
9227                     across domains"). These can be differentiated by the "path"
9228                     in the GUI (for example, "Windows Components\\Internet
9229                     Explorer\\Internet Control Panel\\Security Page\\Internet
9230                     Zone\\Access data sources across domains").
9231                     Additionally, policies can be specified using the "name" and
9232                     "id" attributes from the ADMX files.
9233                     For Administrative Templates that have policy elements, each
9234                     element can be specified using the text string as seen in
9235                     the GUI or using the ID attribute from the ADMX file. Due to
9236                     the way some of the GUI text is laid out, some policy
9237                     element names could include descriptive text that appears
9238                     lbefore the policy element in the GUI.
9239                     Use the get_policy_info function for the policy name to view
9240                     the element ID/names that the module will accept.
9241         user_policy (dict):
9242             The same setup as the computer_policy, except with data to configure
9243             the local user policy.
9244         cumulative_rights_assignments (bool):
9245             Determine how user rights assignment policies are configured.
9246             If True, user right assignment specifications are simply added to
9247             the existing policy
9248             If False, only the users specified will get the right (any existing
9249             will have the right revoked)
9250         adml_language (str):
9251             The language files to use for looking up Administrative Template
9252             policy data (i.e. how the policy is displayed in the GUI). Defaults
9253             to 'en-US' (U.S. English).
9254     Returns:
9255         bool: True is successful, otherwise False
9256     CLI Example:
9257     .. code-block:: bash
9258         salt '*' lgpo.set computer_policy="{'LockoutDuration': 2, 'RestrictAnonymous': 'Enabled', 'AuditProcessTracking': 'Succes, Failure'}"
9259     """
9260     if computer_policy and not isinstance(computer_policy, dict):
9261         raise SaltInvocationError("computer_policy must be specified as a dict")
9262     if user_policy and not isinstance(user_policy, dict):
9263         raise SaltInvocationError("user_policy must be specified as a dict")
9264     policies = {}
9265     policies["User"] = user_policy
9266     policies["Machine"] = computer_policy
9267     if policies:
9268         adml_policy_resources = _get_policy_resources(language=adml_language)
9269         for p_class in policies:
9270             _secedits = {}
9271             _netshs = {}
9272             _advaudits = {}
9273             _modal_sets = {}
9274             _admTemplateData = {}
9275             _regedits = {}
9276             _lsarights = {}
9277             _policydata = _policy_info()
9278             if policies[p_class]:
9279                 for policy_name in policies[p_class]:
9280                     _pol = None
9281                     policy_key_name = policy_name
9282                     if policy_name in _policydata.policies[p_class]["policies"]:
9283                         _pol = _policydata.policies[p_class]["policies"][policy_name]
9284                     else:
9285                         for policy in _policydata.policies[p_class]["policies"]:
9286                             _p = _policydata.policies[p_class]["policies"][policy][
9287                                 "Policy"
9288                             ]
9289                             if _p == policy_name:
9290                                 _pol = _policydata.policies[p_class]["policies"][policy]
9291                                 policy_key_name = policy
9292                         if _pol is None:
9293                             for policy in _policydata.policies[p_class]["policies"]:
9294                                 _p = _policydata.policies[p_class]["policies"][policy][
9295                                     "Policy"
9296                                 ]
9297                                 if _p.lower() == policy_name.lower():
9298                                     _pol = _policydata.policies[p_class]["policies"][
9299                                         policy
9300                                     ]
9301                                     policy_key_name = policy
9302                     if _pol:
9303                         _value = _transform_value(
9304                             value=policies[p_class][policy_name],
9305                             policy=_policydata.policies[p_class]["policies"][
9306                                 policy_key_name
9307                             ],
9308                             transform_type="Put",
9309                         )
9310                         if not _validateSetting(
9311                             value=_value,
9312                             policy=_policydata.policies[p_class]["policies"][
9313                                 policy_key_name
9314                             ],
9315                         ):
9316                             raise SaltInvocationError(
9317                                 "The specified value {} is not an acceptable setting"
9318                                 " for policy {}.".format(
9319                                     policies[p_class][policy_name], policy_name
9320                                 )
9321                             )
9322                         if "Registry" in _pol:
9323                             log.trace("%s is a registry policy", policy_name)
9324                             _regedits[policy_name] = {"policy": _pol, "value": _value}
9325                         elif "Secedit" in _pol:
9326                             log.trace("%s is a Secedit policy", policy_name)
9327                             if _pol["Secedit"]["Section"] not in _secedits:
9328                                 _secedits[_pol["Secedit"]["Section"]] = []
9329                             _secedits[_pol["Secedit"]["Section"]].append(
9330                                 " ".join([_pol["Secedit"]["Option"], "=", str(_value)])
9331                             )
9332                         elif "NetSH" in _pol:
9333                             log.trace("%s is a NetSH policy", policy_name)
9334                             _netshs.setdefault(
9335                                 policy_name,
9336                                 {
9337                                     "profile": _pol["NetSH"]["Profile"],
9338                                     "section": _pol["NetSH"]["Section"],
9339                                     "option": _pol["NetSH"]["Option"],
9340                                     "value": str(_value),
9341                                 },
9342                             )
9343                         elif "AdvAudit" in _pol:
9344                             _advaudits.setdefault(
9345                                 policy_name,
9346                                 {
9347                                     "option": _pol["AdvAudit"]["Option"],
9348                                     "value": str(_value),
9349                                 },
9350                             )
9351                         elif "NetUserModal" in _pol:
9352                             log.trace("%s is a NetUserModal policy", policy_name)
9353                             if _pol["NetUserModal"]["Modal"] not in _modal_sets:
9354                                 _modal_sets[_pol["NetUserModal"]["Modal"]] = {}
9355                             _modal_sets[_pol["NetUserModal"]["Modal"]][
9356                                 _pol["NetUserModal"]["Option"]
9357                             ] = _value
9358                         elif "LsaRights" in _pol:
9359                             log.trace("%s is a LsaRights policy", policy_name)
9360                             _lsarights[policy_name] = {"policy": _pol, "value": _value}
9361                     else:
9362                         _value = policies[p_class][policy_name]
9363                         log.trace('searching for "%s" in admx data', policy_name)
9364                         (
9365                             success,
9366                             the_policy,
9367                             policy_name_list,
9368                             msg,
9369                         ) = _lookup_admin_template(
9370                             policy_name=policy_name,
9371                             policy_class=p_class,
9372                             adml_language=adml_language,
9373                         )
9374                         if success:
9375                             policy_name = the_policy.attrib["name"]
9376                             policy_namespace = the_policy.nsmap[the_policy.prefix]
9377                             if policy_namespace not in _admTemplateData:
9378                                 _admTemplateData[policy_namespace] = {}
9379                             _admTemplateData[policy_namespace][policy_name] = _value
9380                         else:
9381                             raise SaltInvocationError(msg)
9382                         if (
9383                             policy_namespace
9384                             and policy_name in _admTemplateData[policy_namespace]
9385                             and the_policy is not None
9386                         ):
9387                             log.trace(
9388                                 "setting == %s",
9389                                 str(
9390                                     _admTemplateData[policy_namespace][policy_name]
9391                                 ).lower(),
9392                             )
9393                             log.trace(
9394                                 str(
9395                                     _admTemplateData[policy_namespace][policy_name]
9396                                 ).lower()
9397                             )
9398                             if (
9399                                 str(
9400                                     _admTemplateData[policy_namespace][policy_name]
9401                                 ).lower()
9402                                 != "disabled"
9403                                 and str(
9404                                     _admTemplateData[policy_namespace][policy_name]
9405                                 ).lower()
9406                                 != "not configured"
9407                             ):
9408                                 if ELEMENTS_XPATH(the_policy):
9409                                     if isinstance(
9410                                         _admTemplateData[policy_namespace][policy_name],
9411                                         dict,
9412                                     ):
9413                                         for elements_item in ELEMENTS_XPATH(the_policy):
9414                                             for child_item in elements_item:
9415                                                 log.trace(
9416                                                     "checking element %s",
9417                                                     child_item.attrib["id"],
9418                                                 )
9419                                                 temp_element_name = None
9420                                                 this_element_name = _getFullPolicyName(
9421                                                     policy_item=child_item,
9422                                                     policy_name=child_item.attrib["id"],
9423                                                     return_full_policy_names=True,
9424                                                     adml_language=adml_language,
9425                                                 )
9426                                                 log.trace(
9427                                                     'id attribute == "%s" '
9428                                                     ' this_element_name == "%s"',
9429                                                     child_item.attrib["id"],
9430                                                     this_element_name,
9431                                                 )
9432                                                 if (
9433                                                     this_element_name
9434                                                     in _admTemplateData[
9435                                                         policy_namespace
9436                                                     ][policy_name]
9437                                                 ):
9438                                                     temp_element_name = (
9439                                                         this_element_name
9440                                                     )
9441                                                 elif (
9442                                                     child_item.attrib["id"]
9443                                                     in _admTemplateData[
9444                                                         policy_namespace
9445                                                     ][policy_name]
9446                                                 ):
9447                                                     temp_element_name = (
9448                                                         child_item.attrib["id"]
9449                                                     )
9450                                                 else:
9451                                                     raise SaltInvocationError(
9452                                                         'Element "{}" must be included'
9453                                                         " in the policy configuration"
9454                                                         " for policy {}".format(
9455                                                             this_element_name,
9456                                                             policy_name,
9457                                                         )
9458                                                     )
9459                                                 if (
9460                                                     "required" in child_item.attrib
9461                                                     and child_item.attrib[
9462                                                         "required"
9463                                                     ].lower()
9464                                                     == "true"
9465                                                 ):
9466                                                     if not _admTemplateData[
9467                                                         policy_namespace
9468                                                     ][policy_name][temp_element_name]:
9469                                                         raise SaltInvocationError(
9470                                                             'Element "{}" requires a value '
9471                                                             "to be specified".format(
9472                                                                 temp_element_name
9473                                                             )
9474                                                         )
9475                                                 if (
9476                                                     etree.QName(child_item).localname
9477                                                     == "boolean"
9478                                                 ):
9479                                                     if not isinstance(
9480                                                         _admTemplateData[
9481                                                             policy_namespace
9482                                                         ][policy_name][
9483                                                             temp_element_name
9484                                                         ],
9485                                                         bool,
9486                                                     ):
9487                                                         raise SaltInvocationError(
9488                                                             "Element {} requires a boolean "
9489                                                             "True or False".format(
9490                                                                 temp_element_name
9491                                                             )
9492                                                         )
9493                                                 elif (
9494                                                     etree.QName(child_item).localname
9495                                                     == "decimal"
9496                                                     or etree.QName(child_item).localname
9497                                                     == "longDecimal"
9498                                                 ):
9499                                                     min_val = 0
9500                                                     max_val = 9999
9501                                                     if "minValue" in child_item.attrib:
9502                                                         min_val = int(
9503                                                             child_item.attrib[
9504                                                                 "minValue"
9505                                                             ]
9506                                                         )
9507                                                     if "maxValue" in child_item.attrib:
9508                                                         max_val = int(
9509                                                             child_item.attrib[
9510                                                                 "maxValue"
9511                                                             ]
9512                                                         )
9513                                                     if (
9514                                                         int(
9515                                                             _admTemplateData[
9516                                                                 policy_namespace
9517                                                             ][policy_name][
9518                                                                 temp_element_name
9519                                                             ]
9520                                                         )
9521                                                         &lt; min_val
9522                                                         or int(
9523                                                             _admTemplateData[
9524                                                                 policy_namespace
9525                                                             ][policy_name][
9526                                                                 temp_element_name
9527                                                             ]
9528                                                         )
9529                                                         &gt; max_val
9530                                                     ):
9531                                                         raise SaltInvocationError(
9532                                                             'Element "{}" value must be between '
9533                                                             "{} and {}".format(
9534                                                                 temp_element_name,
9535                                                                 min_val,
9536                                                                 max_val,
9537                                                             )
9538                                                         )
9539                                                 elif (
9540                                                     etree.QName(child_item).localname
9541                                                     == "enum"
9542                                                 ):
9543                                                     found = False
9544                                                     for enum_item in child_item:
9545                                                         if (
9546                                                             _admTemplateData[
9547                                                                 policy_namespace
9548                                                             ][policy_name][
9549                                                                 temp_element_name
9550                                                             ]
9551                                                             == _getAdmlDisplayName(
9552                                                                 adml_policy_resources,
9553                                                                 enum_item.attrib[
9554                                                                     "displayName"
9555                                                                 ],
9556                                                             ).strip()
9557                                                         ):
9558                                                             found = True
9559                                                             break
9560                                                     if not found:
9561                                                         raise SaltInvocationError(
9562                                                             'Element "{}" does not have'
9563                                                             " a valid value".format(
9564                                                                 temp_element_name
9565                                                             )
9566                                                         )
9567                                                 elif (
9568                                                     etree.QName(child_item).localname
9569                                                     == "list"
9570                                                 ):
9571                                                     if (
9572                                                         "explicitValue"
9573                                                         in child_item.attrib
9574                                                         and child_item.attrib[
9575                                                             "explicitValue"
9576                                                         ].lower()
9577                                                         == "true"
9578                                                     ):
9579                                                         if not isinstance(
9580                                                             _admTemplateData[
9581                                                                 policy_namespace
9582                                                             ][policy_name][
9583                                                                 temp_element_name
9584                                                             ],
9585                                                             dict,
9586                                                         ):
9587                                                             raise SaltInvocationError(
9588                                                                 "Each list item of element "
9589                                                                 '"{}" requires a dict '
9590                                                                 "value".format(
9591                                                                     temp_element_name
9592                                                                 )
9593                                                             )
9594                                                     elif not isinstance(
9595                                                         _admTemplateData[
9596                                                             policy_namespace
9597                                                         ][policy_name][
9598                                                             temp_element_name
9599                                                         ],
9600                                                         list,
9601                                                     ):
9602                                                         raise SaltInvocationError(
9603                                                             'Element "{}" requires a'
9604                                                             " list value".format(
9605                                                                 temp_element_name
9606                                                             )
9607                                                         )
9608                                                 elif (
9609                                                     etree.QName(child_item).localname
9610                                                     == "multiText"
9611                                                 ):
9612                                                     if not isinstance(
9613                                                         _admTemplateData[
9614                                                             policy_namespace
9615                                                         ][policy_name][
9616                                                             temp_element_name
9617                                                         ],
9618                                                         list,
9619                                                     ):
9620                                                         raise SaltInvocationError(
9621                                                             'Element "{}" requires a'
9622                                                             " list value".format(
9623                                                                 temp_element_name
9624                                                             )
9625                                                         )
9626                                                 _admTemplateData[policy_namespace][
9627                                                     policy_name
9628                                                 ][
9629                                                     child_item.attrib["id"]
9630                                                 ] = _admTemplateData[
9631                                                     policy_namespace
9632                                                 ][
9633                                                     policy_name
9634                                                 ].pop(
9635                                                     temp_element_name
9636                                                 )
9637                                     else:
9638                                         raise SaltInvocationError(
9639                                             'The policy "{}" has elements which must be'
9640                                             " configured".format(policy_name)
9641                                         )
9642                                 else:
9643                                     if (
9644                                         str(
9645                                             _admTemplateData[policy_namespace][
9646                                                 policy_name
9647                                             ]
9648                                         ).lower()
9649                                         != "enabled"
9650                                     ):
9651                                         raise SaltInvocationError(
9652                                             'The policy {} must either be "Enabled", '
9653                                             '"Disabled", or "Not Configured"'.format(
9654                                                 policy_name
9655                                             )
9656                                         )
9657                 if _regedits:
9658                     for regedit in _regedits:
9659                         log.trace("%s is a Registry policy", regedit)
9660                         if (
9661                             _regedits[regedit]["value"] is not None
9662                             and _regedits[regedit]["value"] != "(value not set)"
9663                         ):
9664                             _ret = __utils__["reg.set_value"](
9665                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
9666                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9667                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9668                                 _regedits[regedit]["value"],
9669                                 _regedits[regedit]["policy"]["Registry"]["Type"],
9670                             )
9671                         else:
9672                             _ret = __utils__["reg.read_value"](
9673                                 _regedits[regedit]["policy"]["Registry"]["Hive"],
9674                                 _regedits[regedit]["policy"]["Registry"]["Path"],
9675                                 _regedits[regedit]["policy"]["Registry"]["Value"],
9676                             )
9677                             if _ret["success"] and _ret["vdata"] != "(value not set)":
9678                                 _ret = __utils__["reg.delete_value"](
9679                                     _regedits[regedit]["policy"]["Registry"]["Hive"],
9680                                     _regedits[regedit]["policy"]["Registry"]["Path"],
9681                                     _regedits[regedit]["policy"]["Registry"]["Value"],
9682                                 )
9683                         if not _ret:
9684                             raise CommandExecutionError(
9685                                 "Error while attempting to set policy {} via the"
9686                                 " registry.  Some changes may not be applied as"
9687                                 " expected".format(regedit)
9688                             )
9689                 if _lsarights:
9690                     for lsaright in _lsarights:
9691                         _existingUsers = None
9692                         if not cumulative_rights_assignments:
9693                             _existingUsers = _getRightsAssignments(
9694                                 _lsarights[lsaright]["policy"]["LsaRights"]["Option"]
9695                             )
9696                         if _lsarights[lsaright]["value"]:
9697                             for acct in _lsarights[lsaright]["value"]:
9698                                 _ret = _addAccountRights(
9699                                     acct,
9700                                     _lsarights[lsaright]["policy"]["LsaRights"][
9701                                         "Option"
9702                                     ],
9703                                 )
9704                                 if not _ret:
9705                                     raise SaltInvocationError(
9706                                         "An error occurred attempting to configure the"
9707                                         " user right {}.".format(lsaright)
9708                                     )
9709                         if _existingUsers:
9710                             for acct in _existingUsers:
9711                                 if acct not in _lsarights[lsaright]["value"]:
9712                                     _ret = _delAccountRights(
9713                                         acct,
9714                                         _lsarights[lsaright]["policy"]["LsaRights"][
9715                                             "Option"
9716                                         ],
9717                                     )
9718                                     if not _ret:
9719                                         raise SaltInvocationError(
9720                                             "An error occurred attempting to remove previously "
9721                                             "configured users with right {}.".format(
9722                                                 lsaright
9723                                             )
9724                                         )
9725                 if _secedits:
9726                     log.trace(_secedits)
9727                     ini_data = "\r\n".join(["[Unicode]", "Unicode=yes"])
9728                     _seceditSections = [
9729                         "System Access",
9730                         "Event Audit",
9731                         "Registry Values",
9732                         "Privilege Rights",
9733                     ]
9734                     for _seceditSection in _seceditSections:
9735                         if _seceditSection in _secedits:
9736                             ini_data = "\r\n".join(
9737                                 [
9738                                     ini_data,
9739                                     "".join(["[", _seceditSection, "]"]),
9740                                     "\r\n".join(_secedits[_seceditSection]),
9741                                 ]
9742                             )
9743                     ini_data = "\r\n".join(
9744                         [ini_data, "[Version]", 'signature="$CHICAGO$"', "Revision=1"]
9745                     )
9746                     log.trace("ini_data == %s", ini_data)
9747                     if not _write_secedit_data(ini_data):
9748                         raise CommandExecutionError(
9749                             "Error while attempting to set policies via "
9750                             "secedit. Some changes may not be applied as "
9751                             "expected"
9752                         )
9753                 if _netshs:
9754                     for setting in _netshs:
9755                         log.trace("Setting firewall policy: %s", setting)
9756                         log.trace(_netshs[setting])
9757                         _set_netsh_value(**_netshs[setting])
9758                 if _advaudits:
9759                     for setting in _advaudits:
9760                         log.trace("Setting Advanced Audit policy: %s", setting)
9761                         log.trace(_advaudits[setting])
9762                         _set_advaudit_value(**_advaudits[setting])
9763                 if _modal_sets:
9764                     log.trace(_modal_sets)
9765                     for _modal_set in _modal_sets:
9766                         try:
9767                             _existingModalData = win32net.NetUserModalsGet(
9768                                 None, _modal_set
9769                             )
9770                             _newModalSetData = dictupdate.update(
9771                                 _existingModalData, _modal_sets[_modal_set]
9772                             )
9773                             log.trace("NEW MODAL SET = %s", _newModalSetData)
9774                             _ret = win32net.NetUserModalsSet(
9775                                 None, _modal_set, _newModalSetData
9776                             )
9777                         except Exception as exc:  # pylint: disable=broad-except
9778                             msg = (
9779                                 "An unhandled exception occurred while "
9780                                 "attempting to set policy via "
9781                                 "NetUserModalSet\n{}".format(exc)
9782                             )
9783                             log.exception(msg)
9784                             raise CommandExecutionError(msg)
9785                 if _admTemplateData:
9786                     _ret = False
9787                     log.trace(
9788                         "going to write some adm template data :: %s", _admTemplateData
9789                     )
9790                     _ret = _writeAdminTemplateRegPolFile(
9791                         _admTemplateData,
9792                         adml_language=adml_language,
9793                         registry_class=p_class,
9794                     )
9795                     if not _ret:
9796                         raise CommandExecutionError(
9797                             "Error while attempting to write Administrative Template"
9798                             " Policy data.  Some changes may not be applied as expected"
9799                         )
9800         return True
9801     else:
9802         raise SaltInvocationError("You have to specify something!")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
