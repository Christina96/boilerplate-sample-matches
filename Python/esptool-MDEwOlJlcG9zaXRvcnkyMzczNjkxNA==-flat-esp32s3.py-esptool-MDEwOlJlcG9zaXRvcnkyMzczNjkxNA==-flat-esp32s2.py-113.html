
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32s3.py</h3>
            <pre><code>1  import os
2  import struct
3  from .esp32 import ESP32ROM
4  from ..loader import ESPLoader
5  from ..reset import HardReset
6  from ..util import FatalError, NotImplementedInROMError
7  class ESP32S3ROM(ESP32ROM):
8      CHIP_NAME = &quot;ESP32-S3&quot;
9      IMAGE_CHIP_ID = 9
10      CHIP_DETECT_MAGIC_VALUE = [0x9]
11      FPGA_SLOW_BOOT = False
12      IROM_MAP_START = 0x42000000
13      IROM_MAP_END = 0x44000000
14      DROM_MAP_START = 0x3C000000
15      DROM_MAP_END = 0x3E000000
16      UART_DATE_REG_ADDR = 0x60000080
17      SPI_REG_BASE = 0x60002000
18      SPI_USR_OFFS = 0x18
19      SPI_USR1_OFFS = 0x1C
20      SPI_USR2_OFFS = 0x20
21      SPI_MOSI_DLEN_OFFS = 0x24
22      SPI_MISO_DLEN_OFFS = 0x28
23      SPI_W0_OFFS = 0x58
24      BOOTLOADER_FLASH_OFFSET = 0x0
25      SUPPORTS_ENCRYPTED_FLASH = True
26      FLASH_ENCRYPTED_WRITE_ALIGN = 16
27      EFUSE_BASE = 0x60007000  # BLOCK0 read base address
28      EFUSE_BLOCK1_ADDR = EFUSE_BASE + 0x44
29      EFUSE_BLOCK2_ADDR = EFUSE_BASE + 0x5C
30      MAC_EFUSE_REG = EFUSE_BASE + 0x044
31      EFUSE_RD_REG_BASE = EFUSE_BASE + 0x030  # BLOCK0 read base address
32      EFUSE_PURPOSE_KEY0_REG = EFUSE_BASE + 0x34
33      EFUSE_PURPOSE_KEY0_SHIFT = 24
34      EFUSE_PURPOSE_KEY1_REG = EFUSE_BASE + 0x34
35      EFUSE_PURPOSE_KEY1_SHIFT = 28
36      EFUSE_PURPOSE_KEY2_REG = EFUSE_BASE + 0x38
37      EFUSE_PURPOSE_KEY2_SHIFT = 0
38      EFUSE_PURPOSE_KEY3_REG = EFUSE_BASE + 0x38
39      EFUSE_PURPOSE_KEY3_SHIFT = 4
40      EFUSE_PURPOSE_KEY4_REG = EFUSE_BASE + 0x38
41      EFUSE_PURPOSE_KEY4_SHIFT = 8
42      EFUSE_PURPOSE_KEY5_REG = EFUSE_BASE + 0x38
43      EFUSE_PURPOSE_KEY5_SHIFT = 12
44      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = EFUSE_RD_REG_BASE
45      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 &lt;&lt; 20
46      EFUSE_SPI_BOOT_CRYPT_CNT_REG = EFUSE_BASE + 0x034
47      EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 &lt;&lt; 18
48      EFUSE_SECURE_BOOT_EN_REG = EFUSE_BASE + 0x038
49      EFUSE_SECURE_BOOT_EN_MASK = 1 &lt;&lt; 20
50      EFUSE_RD_REPEAT_DATA3_REG = EFUSE_BASE + 0x3C
51      EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK = 1 &lt;&lt; 9
52      PURPOSE_VAL_XTS_AES256_KEY_1 = 2
53      PURPOSE_VAL_XTS_AES256_KEY_2 = 3
54      PURPOSE_VAL_XTS_AES128_KEY = 4
55      UARTDEV_BUF_NO = 0x3FCEF14C  # Variable in ROM .bss which indicates the port in use
56      UARTDEV_BUF_NO_USB_OTG = 3  # The above var when USB-OTG is used
57      UARTDEV_BUF_NO_USB_JTAG_SERIAL = 4  # The above var when USB-JTAG/Serial is used
58      RTCCNTL_BASE_REG = 0x60008000
59      RTC_CNTL_SWD_CONF_REG = RTCCNTL_BASE_REG + 0x00B4
60      RTC_CNTL_SWD_AUTO_FEED_EN = 1 &lt;&lt; 31
61      RTC_CNTL_SWD_WPROTECT_REG = RTCCNTL_BASE_REG + 0x00B8
62      RTC_CNTL_SWD_WKEY = 0x8F1D312A
63      RTC_CNTL_WDTCONFIG0_REG = RTCCNTL_BASE_REG + 0x0098
64      RTC_CNTL_WDTWPROTECT_REG = RTCCNTL_BASE_REG + 0x00B0
65      RTC_CNTL_WDT_WKEY = 0x50D83AA1
66      USB_RAM_BLOCK = 0x800  # Max block size USB-OTG is used
67      GPIO_STRAP_REG = 0x60004038
68      GPIO_STRAP_SPI_BOOT_MASK = 0x8  # Not download mode
69      RTC_CNTL_OPTION1_REG = 0x6000812C
70      RTC_CNTL_FORCE_DOWNLOAD_BOOT_MASK = 0x1  # Is download mode forced over USB?
71      UART_CLKDIV_REG = 0x60000014
72      MEMORY_MAP = [
73          [0x00000000, 0x00010000, &quot;PADDING&quot;],
74          [0x3C000000, 0x3D000000, &quot;DROM&quot;],
75          [0x3D000000, 0x3E000000, &quot;EXTRAM_DATA&quot;],
76          [0x600FE000, 0x60100000, &quot;RTC_DRAM&quot;],
77          [0x3FC88000, 0x3FD00000, &quot;BYTE_ACCESSIBLE&quot;],
78          [0x3FC88000, 0x403E2000, &quot;MEM_INTERNAL&quot;],
79          [0x3FC88000, 0x3FD00000, &quot;DRAM&quot;],
80          [0x40000000, 0x4001A100, &quot;IROM_MASK&quot;],
81          [0x40370000, 0x403E0000, &quot;IRAM&quot;],
82          [0x600FE000, 0x60100000, &quot;RTC_IRAM&quot;],
83          [0x42000000, 0x42800000, &quot;IROM&quot;],
84          [0x50000000, 0x50002000, &quot;RTC_DATA&quot;],
85      ]
86      def get_pkg_version(self):
87          num_word = 3
88          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) &gt;&gt; 21) &amp; 0x07
89      def is_eco0(self, minor_raw):
90          return (
91              (minor_raw &amp; 0x7) == 0
92              and self.get_blk_version_major() == 1
93              and self.get_blk_version_minor() == 1
94          )
95      def get_minor_chip_version(self):
96          minor_raw = self.get_raw_minor_chip_version()
97          if self.is_eco0(minor_raw):
98              return 0
99          return minor_raw
100      def get_raw_minor_chip_version(self):
101          hi_num_word = 5
102          hi = (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * hi_num_word)) &gt;&gt; 23) &amp; 0x01
103          low_num_word = 3
104          low = (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * low_num_word)) &gt;&gt; 18) &amp; 0x07
105          return (hi &lt;&lt; 3) + low
106      def get_blk_version_major(self):
107          num_word = 4
108          return (self.read_reg(self.EFUSE_BLOCK2_ADDR + (4 * num_word)) &gt;&gt; 0) &amp; 0x03
109      def get_blk_version_minor(self):
110          num_word = 3
111          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) &gt;&gt; 24) &amp; 0x07
112      def get_major_chip_version(self):
113          minor_raw = self.get_raw_minor_chip_version()
114          if self.is_eco0(minor_raw):
115              return 0
116          return self.get_raw_major_chip_version()
117      def get_raw_major_chip_version(self):
118          num_word = 5
119          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) &gt;&gt; 24) &amp; 0x03
120      def get_chip_description(self):
121          major_rev = self.get_major_chip_version()
122          minor_rev = self.get_minor_chip_version()
123          return f&quot;{self.CHIP_NAME} (revision v{major_rev}.{minor_rev})&quot;
124      def get_chip_features(self):
125          return [&quot;WiFi&quot;, &quot;BLE&quot;]
126      def get_crystal_freq(self):
127          return 40
128      def get_flash_crypt_config(self):
129          return None  # doesn&#x27;t exist on ESP32-S3
130      def get_key_block_purpose(self, key_block):
131          if key_block &lt; 0 or key_block &gt; 5:
132              raise FatalError(&quot;Valid key block numbers must be in range 0-5&quot;)
133          reg, shift = [
134              (self.EFUSE_PURPOSE_KEY0_REG, self.EFUSE_PURPOSE_KEY0_SHIFT),
135              (self.EFUSE_PURPOSE_KEY1_REG, self.EFUSE_PURPOSE_KEY1_SHIFT),
136              (self.EFUSE_PURPOSE_KEY2_REG, self.EFUSE_PURPOSE_KEY2_SHIFT),
137              (self.EFUSE_PURPOSE_KEY3_REG, self.EFUSE_PURPOSE_KEY3_SHIFT),
138              (self.EFUSE_PURPOSE_KEY4_REG, self.EFUSE_PURPOSE_KEY4_SHIFT),
139              (self.EFUSE_PURPOSE_KEY5_REG, self.EFUSE_PURPOSE_KEY5_SHIFT),
140          ][key_block]
141          return (self.read_reg(reg) &gt;&gt; shift) &amp; 0xF
142      def is_flash_encryption_key_valid(self):
143          purposes = [self.get_key_block_purpose(b) for b in range(6)]
144          if any(p == self.PURPOSE_VAL_XTS_AES128_KEY for p in purposes):
145              return True
146          return any(p == self.PURPOSE_VAL_XTS_AES256_KEY_1 for p in purposes) and any(
147              p == self.PURPOSE_VAL_XTS_AES256_KEY_2 for p in purposes
148          )
149      def get_secure_boot_enabled(self):
150          return (
151              self.read_reg(self.EFUSE_SECURE_BOOT_EN_REG)
152              &amp; self.EFUSE_SECURE_BOOT_EN_MASK
153          )
154      def override_vddsdio(self, new_voltage):
155          raise NotImplementedInROMError(
156              &quot;VDD_SDIO overrides are not supported for ESP32-S3&quot;
157          )
158      def read_mac(self, mac_type=&quot;BASE_MAC&quot;):
159          if mac_type != &quot;BASE_MAC&quot;:
160              return None
161          mac0 = self.read_reg(self.MAC_EFUSE_REG)
162          mac1 = self.read_reg(self.MAC_EFUSE_REG + 4)  # only bottom 16 bits are MAC
163          bitstring = struct.pack(&quot;&gt;II&quot;, mac1, mac0)[2:]
164          return tuple(bitstring)
165      def flash_type(self):
166          return (
<span onclick='openModal()' class='match'>167              1
168              if self.read_reg(self.EFUSE_RD_REPEAT_DATA3_REG)
169              &amp; self.EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK
170              else 0
171          )
172      def uses_usb_otg(self):
173          if self.secure_download_mode:
</span>174              return False  # can&#x27;t detect native USB in secure download mode
175          return self.get_uart_no() == self.UARTDEV_BUF_NO_USB_OTG
176      def uses_usb_jtag_serial(self):
177          if self.secure_download_mode:
178              return False  # can&#x27;t detect USB-JTAG/Serial in secure download mode
179          return self.get_uart_no() == self.UARTDEV_BUF_NO_USB_JTAG_SERIAL
180      def disable_watchdogs(self):
181          if self.uses_usb_jtag_serial():
182              self.write_reg(self.RTC_CNTL_WDTWPROTECT_REG, self.RTC_CNTL_WDT_WKEY)
183              self.write_reg(self.RTC_CNTL_WDTCONFIG0_REG, 0)
184              self.write_reg(self.RTC_CNTL_WDTWPROTECT_REG, 0)
185              self.write_reg(self.RTC_CNTL_SWD_WPROTECT_REG, self.RTC_CNTL_SWD_WKEY)
186              self.write_reg(
187                  self.RTC_CNTL_SWD_CONF_REG,
188                  self.read_reg(self.RTC_CNTL_SWD_CONF_REG)
189                  | self.RTC_CNTL_SWD_AUTO_FEED_EN,
190              )
191              self.write_reg(self.RTC_CNTL_SWD_WPROTECT_REG, 0)
192      def _post_connect(self):
193          if self.uses_usb_otg():
194              self.ESP_RAM_BLOCK = self.USB_RAM_BLOCK
195          if not self.sync_stub_detected:  # Don&#x27;t run if stub is reused
196              self.disable_watchdogs()
197      def _check_if_can_reset(self):
198          if os.getenv(&quot;ESPTOOL_TESTING&quot;) is not None:
199              print(&quot;ESPTOOL_TESTING is set, ignoring strapping mode check&quot;)
200              return
201          strap_reg = self.read_reg(self.GPIO_STRAP_REG)
202          force_dl_reg = self.read_reg(self.RTC_CNTL_OPTION1_REG)
203          if (
204              strap_reg &amp; self.GPIO_STRAP_SPI_BOOT_MASK == 0
205              and force_dl_reg &amp; self.RTC_CNTL_FORCE_DOWNLOAD_BOOT_MASK == 0
206          ):
207              print(
208                  &quot;WARNING: {} chip was placed into download mode using GPIO0.\n&quot;
209                  &quot;esptool.py can not exit the download mode over USB. &quot;
210                  &quot;To run the app, reset the chip manually.\n&quot;
211                  &quot;To suppress this note, set --after option to &#x27;no_reset&#x27;.&quot;.format(
212                      self.get_chip_description()
213                  )
214              )
215              raise SystemExit(1)
216      def hard_reset(self):
217          uses_usb_otg = self.uses_usb_otg()
218          if uses_usb_otg:
219              self._check_if_can_reset()
220          print(&quot;Hard resetting via RTS pin...&quot;)
221          HardReset(self._port, uses_usb_otg)()
222      def change_baud(self, baud):
223          ESPLoader.change_baud(self, baud)
224  class ESP32S3StubLoader(ESP32S3ROM):
225      FLASH_WRITE_SIZE = 0x4000  # matches MAX_WRITE_BLOCK in stub_loader.c
226      STATUS_BYTES_LENGTH = 2  # same as ESP8266, different to ESP32 ROM
227      IS_STUB = True
228      def __init__(self, rom_loader):
229          self.secure_download_mode = rom_loader.secure_download_mode
230          self._port = rom_loader._port
231          self._trace_enabled = rom_loader._trace_enabled
232          self.cache = rom_loader.cache
233          self.flush_input()  # resets _slip_reader
234          if rom_loader.uses_usb_otg():
235              self.ESP_RAM_BLOCK = self.USB_RAM_BLOCK
236              self.FLASH_WRITE_SIZE = self.USB_RAM_BLOCK
237  ESP32S3ROM.STUB_CLASS = ESP32S3StubLoader
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32s2.py</h3>
            <pre><code>1  import os
2  import struct
3  from .esp32 import ESP32ROM
4  from ..loader import ESPLoader
5  from ..reset import HardReset
6  from ..util import FatalError, NotImplementedInROMError
7  class ESP32S2ROM(ESP32ROM):
8      CHIP_NAME = &quot;ESP32-S2&quot;
9      IMAGE_CHIP_ID = 2
10      FPGA_SLOW_BOOT = False
11      IROM_MAP_START = 0x40080000
12      IROM_MAP_END = 0x40B80000
13      DROM_MAP_START = 0x3F000000
14      DROM_MAP_END = 0x3F3F0000
15      CHIP_DETECT_MAGIC_VALUE = [0x000007C6]
16      SPI_REG_BASE = 0x3F402000
17      SPI_USR_OFFS = 0x18
18      SPI_USR1_OFFS = 0x1C
19      SPI_USR2_OFFS = 0x20
20      SPI_MOSI_DLEN_OFFS = 0x24
21      SPI_MISO_DLEN_OFFS = 0x28
22      SPI_W0_OFFS = 0x58
23      MAC_EFUSE_REG = 0x3F41A044  # ESP32-S2 has special block for MAC efuses
24      UART_CLKDIV_REG = 0x3F400014
25      SUPPORTS_ENCRYPTED_FLASH = True
26      FLASH_ENCRYPTED_WRITE_ALIGN = 16
27      EFUSE_BASE = 0x3F41A000
28      EFUSE_RD_REG_BASE = EFUSE_BASE + 0x030  # BLOCK0 read base address
29      EFUSE_BLOCK1_ADDR = EFUSE_BASE + 0x044
30      EFUSE_BLOCK2_ADDR = EFUSE_BASE + 0x05C
31      EFUSE_PURPOSE_KEY0_REG = EFUSE_BASE + 0x34
32      EFUSE_PURPOSE_KEY0_SHIFT = 24
33      EFUSE_PURPOSE_KEY1_REG = EFUSE_BASE + 0x34
34      EFUSE_PURPOSE_KEY1_SHIFT = 28
35      EFUSE_PURPOSE_KEY2_REG = EFUSE_BASE + 0x38
36      EFUSE_PURPOSE_KEY2_SHIFT = 0
37      EFUSE_PURPOSE_KEY3_REG = EFUSE_BASE + 0x38
38      EFUSE_PURPOSE_KEY3_SHIFT = 4
39      EFUSE_PURPOSE_KEY4_REG = EFUSE_BASE + 0x38
40      EFUSE_PURPOSE_KEY4_SHIFT = 8
41      EFUSE_PURPOSE_KEY5_REG = EFUSE_BASE + 0x38
42      EFUSE_PURPOSE_KEY5_SHIFT = 12
43      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG = EFUSE_RD_REG_BASE
44      EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT = 1 &lt;&lt; 19
45      EFUSE_SPI_BOOT_CRYPT_CNT_REG = EFUSE_BASE + 0x034
46      EFUSE_SPI_BOOT_CRYPT_CNT_MASK = 0x7 &lt;&lt; 18
47      EFUSE_SECURE_BOOT_EN_REG = EFUSE_BASE + 0x038
48      EFUSE_SECURE_BOOT_EN_MASK = 1 &lt;&lt; 20
49      EFUSE_RD_REPEAT_DATA3_REG = EFUSE_BASE + 0x3C
50      EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK = 1 &lt;&lt; 9
51      PURPOSE_VAL_XTS_AES256_KEY_1 = 2
52      PURPOSE_VAL_XTS_AES256_KEY_2 = 3
53      PURPOSE_VAL_XTS_AES128_KEY = 4
54      UARTDEV_BUF_NO = 0x3FFFFD14  # Variable in ROM .bss which indicates the port in use
55      UARTDEV_BUF_NO_USB_OTG = 2  # Value of the above indicating that USB-OTG is in use
56      USB_RAM_BLOCK = 0x800  # Max block size USB-OTG is used
57      GPIO_STRAP_REG = 0x3F404038
58      GPIO_STRAP_SPI_BOOT_MASK = 0x8  # Not download mode
59      RTC_CNTL_OPTION1_REG = 0x3F408128
60      RTC_CNTL_FORCE_DOWNLOAD_BOOT_MASK = 0x1  # Is download mode forced over USB?
61      MEMORY_MAP = [
62          [0x00000000, 0x00010000, &quot;PADDING&quot;],
63          [0x3F000000, 0x3FF80000, &quot;DROM&quot;],
64          [0x3F500000, 0x3FF80000, &quot;EXTRAM_DATA&quot;],
65          [0x3FF9E000, 0x3FFA0000, &quot;RTC_DRAM&quot;],
66          [0x3FF9E000, 0x40000000, &quot;BYTE_ACCESSIBLE&quot;],
67          [0x3FF9E000, 0x40072000, &quot;MEM_INTERNAL&quot;],
68          [0x3FFB0000, 0x40000000, &quot;DRAM&quot;],
69          [0x40000000, 0x4001A100, &quot;IROM_MASK&quot;],
70          [0x40020000, 0x40070000, &quot;IRAM&quot;],
71          [0x40070000, 0x40072000, &quot;RTC_IRAM&quot;],
72          [0x40080000, 0x40800000, &quot;IROM&quot;],
73          [0x50000000, 0x50002000, &quot;RTC_DATA&quot;],
74      ]
75      def get_pkg_version(self):
76          num_word = 4
77          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) &gt;&gt; 0) &amp; 0x0F
78      def get_minor_chip_version(self):
79          hi_num_word = 3
80          hi = (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * hi_num_word)) &gt;&gt; 20) &amp; 0x01
81          low_num_word = 4
82          low = (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * low_num_word)) &gt;&gt; 4) &amp; 0x07
83          return (hi &lt;&lt; 3) + low
84      def get_major_chip_version(self):
85          num_word = 3
86          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) &gt;&gt; 18) &amp; 0x03
87      def get_flash_version(self):
88          num_word = 3
89          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) &gt;&gt; 21) &amp; 0x0F
90      def get_psram_version(self):
91          num_word = 3
92          return (self.read_reg(self.EFUSE_BLOCK1_ADDR + (4 * num_word)) &gt;&gt; 28) &amp; 0x0F
93      def get_block2_version(self):
94          num_word = 4
95          return (self.read_reg(self.EFUSE_BLOCK2_ADDR + (4 * num_word)) &gt;&gt; 4) &amp; 0x07
96      def get_chip_description(self):
97          chip_name = {
98              0: &quot;ESP32-S2&quot;,
99              1: &quot;ESP32-S2FH2&quot;,
100              2: &quot;ESP32-S2FH4&quot;,
101              102: &quot;ESP32-S2FNR2&quot;,
102              100: &quot;ESP32-S2R2&quot;,
103          }.get(
104              self.get_flash_version() + self.get_psram_version() * 100,
105              &quot;unknown ESP32-S2&quot;,
106          )
107          major_rev = self.get_major_chip_version()
108          minor_rev = self.get_minor_chip_version()
109          return f&quot;{chip_name} (revision v{major_rev}.{minor_rev})&quot;
110      def get_chip_features(self):
111          features = [&quot;WiFi&quot;]
112          if self.secure_download_mode:
113              features += [&quot;Secure Download Mode Enabled&quot;]
114          flash_version = {
115              0: &quot;No Embedded Flash&quot;,
116              1: &quot;Embedded Flash 2MB&quot;,
117              2: &quot;Embedded Flash 4MB&quot;,
118          }.get(self.get_flash_version(), &quot;Unknown Embedded Flash&quot;)
119          features += [flash_version]
120          psram_version = {
121              0: &quot;No Embedded PSRAM&quot;,
122              1: &quot;Embedded PSRAM 2MB&quot;,
123              2: &quot;Embedded PSRAM 4MB&quot;,
124          }.get(self.get_psram_version(), &quot;Unknown Embedded PSRAM&quot;)
125          features += [psram_version]
126          block2_version = {
127              0: &quot;No calibration in BLK2 of efuse&quot;,
128              1: &quot;ADC and temperature sensor calibration in BLK2 of efuse V1&quot;,
129              2: &quot;ADC and temperature sensor calibration in BLK2 of efuse V2&quot;,
130          }.get(self.get_block2_version(), &quot;Unknown Calibration in BLK2&quot;)
131          features += [block2_version]
132          return features
133      def get_crystal_freq(self):
134          return 40
135      def override_vddsdio(self, new_voltage):
136          raise NotImplementedInROMError(
137              &quot;VDD_SDIO overrides are not supported for ESP32-S2&quot;
138          )
139      def read_mac(self, mac_type=&quot;BASE_MAC&quot;):
140          if mac_type != &quot;BASE_MAC&quot;:
141              return None
142          mac0 = self.read_reg(self.MAC_EFUSE_REG)
143          mac1 = self.read_reg(self.MAC_EFUSE_REG + 4)  # only bottom 16 bits are MAC
144          bitstring = struct.pack(&quot;&gt;II&quot;, mac1, mac0)[2:]
145          return tuple(bitstring)
146      def flash_type(self):
147          return (
<span onclick='openModal()' class='match'>148              1
149              if self.read_reg(self.EFUSE_RD_REPEAT_DATA3_REG)
150              &amp; self.EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK
151              else 0
152          )
153      def get_flash_crypt_config(self):
154          return None  # doesn&#x27;t exist on ESP32-S2
</span>155      def get_secure_boot_enabled(self):
156          return (
157              self.read_reg(self.EFUSE_SECURE_BOOT_EN_REG)
158              &amp; self.EFUSE_SECURE_BOOT_EN_MASK
159          )
160      def get_key_block_purpose(self, key_block):
161          if key_block &lt; 0 or key_block &gt; 5:
162              raise FatalError(&quot;Valid key block numbers must be in range 0-5&quot;)
163          reg, shift = [
164              (self.EFUSE_PURPOSE_KEY0_REG, self.EFUSE_PURPOSE_KEY0_SHIFT),
165              (self.EFUSE_PURPOSE_KEY1_REG, self.EFUSE_PURPOSE_KEY1_SHIFT),
166              (self.EFUSE_PURPOSE_KEY2_REG, self.EFUSE_PURPOSE_KEY2_SHIFT),
167              (self.EFUSE_PURPOSE_KEY3_REG, self.EFUSE_PURPOSE_KEY3_SHIFT),
168              (self.EFUSE_PURPOSE_KEY4_REG, self.EFUSE_PURPOSE_KEY4_SHIFT),
169              (self.EFUSE_PURPOSE_KEY5_REG, self.EFUSE_PURPOSE_KEY5_SHIFT),
170          ][key_block]
171          return (self.read_reg(reg) &gt;&gt; shift) &amp; 0xF
172      def is_flash_encryption_key_valid(self):
173          purposes = [self.get_key_block_purpose(b) for b in range(6)]
174          if any(p == self.PURPOSE_VAL_XTS_AES128_KEY for p in purposes):
175              return True
176          return any(p == self.PURPOSE_VAL_XTS_AES256_KEY_1 for p in purposes) and any(
177              p == self.PURPOSE_VAL_XTS_AES256_KEY_2 for p in purposes
178          )
179      def uses_usb_otg(self):
180          if self.secure_download_mode:
181              return False  # can&#x27;t detect native USB in secure download mode
182          return self.get_uart_no() == self.UARTDEV_BUF_NO_USB_OTG
183      def _post_connect(self):
184          if self.uses_usb_otg():
185              self.ESP_RAM_BLOCK = self.USB_RAM_BLOCK
186      def _check_if_can_reset(self):
187          if os.getenv(&quot;ESPTOOL_TESTING&quot;) is not None:
188              print(&quot;ESPTOOL_TESTING is set, ignoring strapping mode check&quot;)
189              return
190          strap_reg = self.read_reg(self.GPIO_STRAP_REG)
191          force_dl_reg = self.read_reg(self.RTC_CNTL_OPTION1_REG)
192          if (
193              strap_reg &amp; self.GPIO_STRAP_SPI_BOOT_MASK == 0
194              and force_dl_reg &amp; self.RTC_CNTL_FORCE_DOWNLOAD_BOOT_MASK == 0
195          ):
196              print(
197                  &quot;WARNING: {} chip was placed into download mode using GPIO0.\n&quot;
198                  &quot;esptool.py can not exit the download mode over USB. &quot;
199                  &quot;To run the app, reset the chip manually.\n&quot;
200                  &quot;To suppress this note, set --after option to &#x27;no_reset&#x27;.&quot;.format(
201                      self.get_chip_description()
202                  )
203              )
204              raise SystemExit(1)
205      def hard_reset(self):
206          uses_usb_otg = self.uses_usb_otg()
207          if uses_usb_otg:
208              self._check_if_can_reset()
209          print(&quot;Hard resetting via RTS pin...&quot;)
210          HardReset(self._port, uses_usb_otg)()
211      def change_baud(self, baud):
212          ESPLoader.change_baud(self, baud)
213  class ESP32S2StubLoader(ESP32S2ROM):
214      FLASH_WRITE_SIZE = 0x4000  # matches MAX_WRITE_BLOCK in stub_loader.c
215      STATUS_BYTES_LENGTH = 2  # same as ESP8266, different to ESP32 ROM
216      IS_STUB = True
217      def __init__(self, rom_loader):
218          self.secure_download_mode = rom_loader.secure_download_mode
219          self._port = rom_loader._port
220          self._trace_enabled = rom_loader._trace_enabled
221          self.cache = rom_loader.cache
222          self.flush_input()  # resets _slip_reader
223          if rom_loader.uses_usb_otg():
224              self.ESP_RAM_BLOCK = self.USB_RAM_BLOCK
225              self.FLASH_WRITE_SIZE = self.USB_RAM_BLOCK
226  ESP32S2ROM.STUB_CLASS = ESP32S2StubLoader
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32s3.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-esp32s2.py</div>
                </div>
                <div class="column column_space"><pre><code>167              1
168              if self.read_reg(self.EFUSE_RD_REPEAT_DATA3_REG)
169              &amp; self.EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK
170              else 0
171          )
172      def uses_usb_otg(self):
173          if self.secure_download_mode:
</pre></code></div>
                <div class="column column_space"><pre><code>148              1
149              if self.read_reg(self.EFUSE_RD_REPEAT_DATA3_REG)
150              &amp; self.EFUSE_RD_REPEAT_DATA3_REG_FLASH_TYPE_MASK
151              else 0
152          )
153      def get_flash_crypt_config(self):
154          return None  # doesn&#x27;t exist on ESP32-S2
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    