<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_state.py &amp; test_ipaddress.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_state.py &amp; test_ipaddress.py
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_state.py (3.2994924%)<th>test_ipaddress.py (0.46906006%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(317-363)<td><a href="#" name="0">(959-965)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(479-485)<td><a href="#" name="1">(1104-1109)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import os
import textwrap
import threading
import time
import pytest
import salt.loader
import salt.utils.atomicfile
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
log = logging.getLogger(__name__)
pytestmark = [
    pytest.mark.windows_whitelisted,
]
def test_show_highstate(state, state_testfile_dest_path):
    high = state.show_highstate()
    assert isinstance(high, dict)
    assert str(state_testfile_dest_path) in high
    assert high[str(state_testfile_dest_path)]["__env__"] == "base"
def test_show_lowstate(state):
    low = state.show_lowstate()
    assert isinstance(low, list)
    for entry in low:
        assert isinstance(entry, dict)
def test_show_states(state):
    states = state.show_states()
    assert isinstance(states, list)
    for entry in states:
        assert isinstance(entry, str)
    assert states == ["core"]
def test_show_states_missing_sls(state, state_tree):
    top_sls_contents = """
    base:
      '*':
        - core
        - does-not-exist
    state.show_sls used to catch a recursive ref
    with pytest.helpers.temp_file("recurse-fail.sls", sls_contents, state_tree):
        ret = state.sls("recurse-fail")
        assert ret.failed
        assert (
            'A recursive requisite was found, SLS "recurse-fail" ID "/etc/mysql/my.cnf" ID "mysql"'
            in ret.errors
        )
RECURSE_SLS_ONE = """
snmpd:
  pkg:
    - installed
  service:
    - running
    - require:
      - pkg: snmpd
    - watch:
      - file: /etc/snmp/snmpd.conf
/etc/snmp/snmpd.conf:
  file:
    - managed
    - source: salt://snmpd/snmpd.conf.jinja
    - template: jinja
    - user: root
    - group: root
    - mode: "0600"
    - require:
      - pkg: snmpd
@pytest.mark.parametrize(
    "sls_contents, expected_in_output",
    [(RECURSE_SLS_ONE, "snmpd"), (RECURSE_SLS_TWO, "/etc/nagios/nrpe.cfg")],
    ids=("recurse-scenario-1", "recurse-scenario-2"),
)
def test_no_recurse(state, state_tree, sls_contents, expected_in_output):
    with pytest.helpers.temp_file("recurse-ok.sls", sls_contents, state_tree):
        ret = state.show_sls("recurse-ok")
        assert expected_in_output in ret
def test_running_dictionary_consistency(state):
    running_dict_fields = {
        "__id__",
        "__run_num__",
        "__sls__",
        "changes",
        "comment",
        "duration",
        "name",
        "result",
        "start_time",
    }
    sls = state.single("test.succeed_without_changes", name="gndn")
    ret_values_set = set(sls.full_return.keys())
    assert running_dict_fields.issubset(ret_values_set)
def test_running_dictionary_key_sls(state, state_tree):
    sls1 = state.single("test.succeed_with_changes", name="gndn")
    assert "__sls__" in sls1.full_return
    assert sls1.full_return["__sls__"] is None
    sls_contents = """
    gndn:
      test.succeed_with_changes
        sls_key = "cmd_|-count_root_dir_contents_|-ls -a / | wc -l_|-run"
    else:
        sls_contents = r"""
        count_root_dir_contents:
          cmd.run:
            - name: 'Get-ChildItem C:\ | Measure-Object | %{$_.Count}'
            - shell: powershell
    verify sending a state request to the minion(s)
    verify checking a state request sent to the minion(s)
    verify clearing a state request sent to the minion(s)
    verify running a state request sent to the minion(s)
    verify not running a state request sent to the minion(s)
    verify that we catch the following syntax error::
        /tmp/salttest/issue-1876:
          file:
            - managed
            - source: salt://testfile
          file.append:
            - text: foo
        testfile
    )
    with pytest.helpers.temp_file("issue-1876.sls", sls_contents, state_tree):
        ret = state.sls("issue-1876")
        assert ret.failed
        errmsg = (
            "ID '{}' in SLS 'issue-1876' contains multiple state declarations of the"
            " same type".format(testfile)
        )
        assert errmsg in ret.errors
<a name="0"></a>
def test_issue_1879_too_simple_contains_check(state, state_tree, tmp_path):
    testfile <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= tmp_path / "issue-1979.txt"
    init_sls_contents = """
    {}:
      file:
        - touch
        testfile
    )
    step2_sls_contents = """
    {}:
      file.append:
        - text: |
            if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
                . /etc/bash_completion
            fi
        if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
            debian_chroot=$(cat /etc/debian_chroot)
        fi
        if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
            . /etc/bash_completion
        fi
    issue_1879_dir =</b></font> state_tree / "issue-1879"
    with pytest.helpers.temp_file(
        "init.sls", init_sls_contents, issue_1879_dir
    ), pytest.helpers.temp_file(
        "step-1.sls", step1_sls_contents, issue_1879_dir
    ), pytest.helpers.temp_file(
        "step-2.sls", step2_sls_contents, issue_1879_dir
    ):
        ret = state.sls("issue-1879")
        for staterun in ret:
            assert staterun.result is True
        ret = state.sls("issue-1879.step-1")
        for staterun in ret:
            assert staterun.result is True
        ret = state.sls("issue-1879.step-2")
        for staterun in ret:
            assert staterun.result is True
        contents = testfile.read_text()
        assert contents == expected
        ret = state.sls("issue-1879.step-1")
        for staterun in ret:
            assert staterun.result is True
        ret = state.sls("issue-1879.step-2")
        for staterun in ret:
            assert staterun.result is True
        contents = testfile.read_text()
        assert contents == expected
def test_include(state, state_tree, tmp_path):
    testfile_path = tmp_path / "testfile"
    testfile_path.write_text("foo")
    include_test_path = tmp_path / "include-test.txt"
    to_include_test_path = tmp_path / "to-include-test.txt"
    exclude_test_path = tmp_path / "exclude-test.txt"
    to_include_sls_contents = """
    {}:
      file.managed:
        - source: salt://testfile
        include_test_path
    )
    with pytest.helpers.temp_file(
        "testfile", "foo", state_tree
    ), pytest.helpers.temp_file(
        "to-include-test.sls", to_include_sls_contents, state_tree
    ), pytest.helpers.temp_file(
        "include-test.sls", include_sls_contents, state_tree
    ):
        ret = state.sls("include-test")
        for staterun in ret:
            assert staterun.result is True
    assert include_test_path.exists()
    assert to_include_test_path.exists()
    assert exclude_test_path.exists() is False
def test_exclude(state, state_tree, tmp_path):
    testfile_path = tmp_path / "testfile"
    testfile_path.write_text("foo")
    include_test_path = tmp_path / "include-test.txt"
    to_include_test_path = tmp_path / "to-include-test.txt"
    exclude_test_path = tmp_path / "exclude-test.txt"
    to_include_sls_contents = """
    {}:
      file.managed:
        - source: salt://testfile
        include_test_path
    )
    exclude_sls_contents = """
    exclude:
      - to-include-test
    include:
      - include-test
    {}:
      file.managed:
        - source: salt://testfile
<a name="1"></a>    """.format(
        exclude_test_path
    )
    with pytest<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.helpers.temp_file(
        "testfile", "foo", state_tree
    ), pytest.helpers.temp_file(
        "to-include-test.sls", to_include_sls_contents, state_tree
    ), pytest.helpers.temp_file(
        "include-test.sls", include_sls_contents, state_tree
    ), pytest.helpers.temp_file(</b></font>
        "exclude-test.sls", exclude_sls_contents, state_tree
    ):
        ret = state.sls("exclude-test")
        for staterun in ret:
            assert staterun.result is True
    assert include_test_path.exists()
    assert exclude_test_path.exists()
    assert to_include_test_path.exists() is False
def test_issue_2068_template_str(state, state_tree):
    template_str_no_dot_sls_contents = """
    required_state:
      test:
        - succeed_without_changes
    requiring_state:
      test:
        - succeed_without_changes
        - require:
          - test: required_state
    with pytest.helpers.temp_file(
        "issue-2068-no-dot.sls", template_str_no_dot_sls_contents, state_tree
    ) as template_str_no_dot_path, pytest.helpers.temp_file(
        "issue-2068.sls", template_str_sls_contents, state_tree
    ) as template_str_path:
        ret = state.sls("issue-2068-no-dot")
        for staterun in ret:
            assert staterun.result is True
        template_str_no_dot_contents = template_str_no_dot_path.read_text()
        ret = state.template_str(template_str_no_dot_contents)
        for staterun in ret:
            assert staterun.result is True
        ret = state.template(str(template_str_no_dot_path))
        for staterun in ret:
            assert staterun.result is True
        ret = state.sls("issue-2068")
        for staterun in ret:
            assert staterun.result is True
        template_str_contents = template_str_path.read_text()
        ret = state.template_str(template_str_contents)
        for staterun in ret:
            assert staterun.result is True
        ret = state.template(str(template_str_path))
        for staterun in ret:
            assert staterun.result is True
@pytest.mark.parametrize("item", ("include", "exclude", "extends"))
def test_template_str_invalid_items(state, item):
    TEMPLATE = textwrap.dedent(
            item
        )
    )
    ret = state.template_str(TEMPLATE.format(item))
    assert ret.failed
    errmsg = (
        "The '{}' declaration found on '&lt;template-str&gt;' is invalid when "
        "rendering single templates".format(item)
    )
    assert errmsg in ret.errors
@pytest.mark.skip_on_windows(
    reason=(
        "Functional testing this on windows raises unicode errors. "
        "Tested in tests/pytests/integration/modules/state/test_state.py"
    )
)
def test_pydsl(state, state_tree, tmp_path):
    testfile = tmp_path / "testfile"
    sls_contents = """
    state("{}").file("touch")
    Call sls file with yaml syntax error.
    Ensure theses errors are detected and presented to the user without
    stack traces.
    badlist_2_sls_contents = """
    B:
      file.exist:
        - name: /foo/bar/foobar
    /foo/bar/foobar:
      file.exist
    C:
      /foo/bar/foobar:
        file.exist
    test the retry option on a simple state with defaults
    ensure comment is as expected
    ensure state duration is greater than configured the passed (interval * attempts)
    expected_comment = (
        'Attempt 1: Returned a result of "False", with the following '
        'comment: "Specified path /path/to/a/non-existent/file.txt does not exist"'
    )
    with pytest.helpers.temp_file("retry.sls", sls_contents, state_tree):
        ret = state.sls("retry")
        for state_return in ret:
            assert state_return.result is False
            assert expected_comment in state_return.comment
            assert state_return.full_return["duration"] &gt;= 3
def test_retry_option_success(state, state_tree, tmp_path):
    testfile = tmp_path / "testfile"
    testfile.touch()
    sls_contents = """
    file_test:
      file.exists:
        - name: {}
        - retry:
            until: True
            attempts: 5
            interval: 2
            splay: 0
    test a state with the retry option that should return True, eventually
        testfile1, testfile2
    )
    with pytest.helpers.temp_file("retry.sls", sls_contents, state_tree):
        thread.start()
        ret = state.sls("retry")
        for state_return in ret:
            assert state_return.result is True
            assert state_return.full_return["duration"] &gt; 4
            assert "Attempt 5" not in state_return.comment
@pytest.mark.slow_test
def test_state_non_base_environment(state, state_tree_prod, tmp_path):
    testfile = tmp_path / "testfile"
    sls_contents = """
    {}:
      file.managed:
        - content: foo
    This tests the case where the state being executed has a long ID dec or
    name and states are being run in parallel. The filenames used for the
    parallel state cache were previously based on the tag for each chunk,
    and longer ID decs or name params can cause the cache file to be longer
    than the operating system's max file name length. To counter this we
    instead generate a SHA1 hash of the chunk's tag to use as the cache
    filename. This test will ensure that long tags don't cause caching
    failures.
    See https://github.com/saltstack/salt/issues/49738 for more info.
        short_command, long_command
    )
    with pytest.helpers.temp_file("issue-49738.sls", sls_contents, state_tree):
        ret = state.sls(
            "issue-49738",
            __pub_jid="1",  # Because these run in parallel we need a fake JID
        )
    comments = sorted(x.comment for x in ret)
    expected = sorted(
        'Command "{}" run'.format(x) for x in (short_command, long_command)
    )
    assert comments == expected, "{} != {}".format(comments, expected)
@pytest.mark.skip_on_darwin(reason="Test is broken on macosx")
@pytest.mark.skip_on_windows(
    reason=(
        "Functional testing this on windows raises unicode errors. "
        "Tested in tests/pytests/integration/modules/state/test_state.py"
    )
)
def test_state_sls_unicode_characters(state, state_tree):
    sls_contents = """
    echo1:
      cmd.run:
        - name: "echo 'This is Ã† test!'"
    This tests the case where the state file is named
    only with integers
    state_id = "test_|-always-passes_|-always-passes_|-succeed_without_changes"
    with pytest.helpers.temp_file("12345.sls", sls_contents, state_tree):
        ret = state.sls("12345")
        assert state_id in ret
        for state_return in ret:
            assert state_return.result is True
            assert "Success!" in state_return.comment
        ret = state.sls(mods=12345)
        assert state_id in ret
        for state_return in ret:
            assert state_return.result is True
            assert "Success!" in state_return.comment
def test_state_sls_lazyloader_allows_recursion(state, state_tree):
    sls_contents = """
    {% if 'nonexistent_module.function' in salt %}
    {% do salt.log.warning("Module is available") %}
    {% endif %}
    always-passes:
      test.succeed_without_changes:
        - name: foo
    Object that is greater than anything (except itself).
    Object that is less than anything (except itself).
        Ensure exception does not display a context by default
        Wraps unittest.TestCase.assertRaisesRegex
    objects_with_scoped <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= objects + v6_scoped_objects
    v4addr2 = ipaddress.IPv4Address(2)
    v4net2 = ipaddress.IPv4Network(2)
    v4intf2 = ipaddress.IPv4Interface(2)
    v6addr2 = ipaddress.IPv6Address(2)
    v6net2 =</b></font> ipaddress.IPv6Network(2)
    v6intf2 = ipaddress.IPv6Interface(2)
    v6addr2_scoped = ipaddress.IPv6Address("::2%scope")
    v6net2_scoped = ipaddress.IPv6Network("::2%scope")
    v6intf2_scoped = ipaddress.IPv6Interface("::2%scope")
    def test_foreign_type_equality(self):
        other = object()
        for obj in self.objects_with_scoped:
            self.assertNotEqual(obj, other)
            self.assertFalse(obj == other)
            self.assertEqual(obj.__eq__(other), NotImplemented)
            self.assertEqual(obj.__ne__(other), NotImplemented)
    def test_mixed_type_equality(self):
        for lhs in self.objects:
            for rhs in self.objects:
                if lhs is rhs:
                    continue
                self.assertNotEqual(lhs, rhs)
    def test_scoped_ipv6_equality(self):
        for lhs, rhs in zip(self.v6_objects, self.v6_scoped_objects):
            self.assertNotEqual(lhs, rhs)
    def test_v4_with_v6_scoped_equality(self):
        for lhs in self.v4_objects:
            for rhs in self.v6_scoped_objects:
                self.assertNotEqual(lhs, rhs)
    def test_same_type_equality(self):
        for obj in self.objects_with_scoped:
            self.assertEqual(obj, obj)
            self.assertLessEqual(obj, obj)
            self.assertGreaterEqual(obj, obj)
    def test_same_type_ordering(self):
        for lhs, rhs in (
            (self.v4addr, self.v4addr2),
            (self.v4net, self.v4net2),
            (self.v4intf, self.v4intf2),
            (self.v6addr, self.v6addr2),
            (self.v6net, self.v6net2),
            (self.v6intf, self.v6intf2),
            (self.v6addr_scoped, self.v6addr2_scoped),
            (self.v6net_scoped, self.v6net2_scoped),
            (self.v6intf_scoped, self.v6intf2_scoped),
        ):
            self.assertNotEqual(lhs, rhs)
            self.assertLess(lhs, rhs)
            self.assertLessEqual(lhs, rhs)
            self.assertGreater(rhs, lhs)
            self.assertGreaterEqual(rhs, lhs)
            self.assertFalse(lhs &gt; rhs)
            self.assertFalse(rhs &lt; lhs)
            self.assertFalse(lhs &gt;= rhs)
            self.assertFalse(rhs &lt;= lhs)
    def test_containment(self):
        for obj in self.v4_addresses:
            self.assertIn(obj, self.v4net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net_scoped)
        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net)
        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net_scoped)
        for obj in self.v6_objects + self.v6_scoped_objects + [self.v4net]:
            self.assertNotIn(obj, self.v4net)
    def test_mixed_type_ordering(self):
        for lhs in self.objects_with_scoped:
            for rhs in self.objects_with_scoped:
                if isinstance(lhs, type(rhs)) or isinstance(rhs, type(lhs)):
                    continue
                self.assertRaises(TypeError, lambda: lhs &lt; rhs)
                self.assertRaises(TypeError, lambda: lhs &gt; rhs)
                self.assertRaises(TypeError, lambda: lhs &lt;= rhs)
                self.assertRaises(TypeError, lambda: lhs &gt;= rhs)
    def test_foreign_type_ordering(self):
        other = object()
        for obj in self.objects_with_scoped:
            with self.assertRaises(TypeError):
                obj &lt; other
            with self.assertRaises(TypeError):
                obj &gt; other
            with self.assertRaises(TypeError):
                obj &lt;= other
            with self.assertRaises(TypeError):
                obj &gt;= other
            self.assertTrue(obj &lt; LARGEST)
            self.assertFalse(obj &gt; LARGEST)
            self.assertTrue(obj &lt;= LARGEST)
            self.assertFalse(obj &gt;= LARGEST)
            self.assertFalse(obj &lt; SMALLEST)
            self.assertTrue(obj &gt; SMALLEST)
            self.assertFalse(obj &lt;= SMALLEST)
            self.assertTrue(obj &gt;= SMALLEST)
    def test_mixed_type_key(self):
        v4_ordered = [self.v4addr, self.v4net, self.v4intf]
        v6_ordered = [self.v6addr, self.v6net, self.v6intf]
        v6_scoped_ordered = [self.v6addr_scoped, self.v6net_scoped, self.v6intf_scoped]
        self.assertEqual(
            v4_ordered, sorted(self.v4_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_ordered, sorted(self.v6_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_scoped_ordered,
            sorted(self.v6_scoped_objects, key=ipaddress.get_mixed_type_key),
        )
        self.assertEqual(
            v4_ordered + v6_scoped_ordered,
            sorted(
                self.v4_objects + self.v6_scoped_objects,
                key=ipaddress.get_mixed_type_key,
            ),
        )
        self.assertEqual(NotImplemented, ipaddress.get_mixed_type_key(object))
    def test_incompatible_versions(self):
        v4addr = ipaddress.ip_address("1.1.1.1")
        v4net = ipaddress.ip_network("1.1.1.1")
        v6addr = ipaddress.ip_address("::1")
        v6net = ipaddress.ip_network("::1")
<a name="1"></a>        v6addr_scoped = ipaddress.ip_address("::1%scope")
        v6net_scoped = ipaddress.ip_network("::1%scope")
        self.assertRaises(TypeError, v4addr<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.__lt__, v6addr)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr)
        self.assertRaises(TypeError, v4net.__lt__, v6net)
        self.assertRaises(TypeError, v4net.__gt__, v6net)
        self.assertRaises(</b></font>TypeError, v6addr.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr.__gt__, v4addr)
        self.assertRaises(TypeError, v6net.__lt__, v4net)
        self.assertRaises(TypeError, v6net.__gt__, v4net)
        self.assertRaises(TypeError, v4addr.__lt__, v6addr_scoped)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr_scoped)
        self.assertRaises(TypeError, v4net.__lt__, v6net_scoped)
        self.assertRaises(TypeError, v4net.__gt__, v6net_scoped)
        self.assertRaises(TypeError, v6addr_scoped.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr_scoped.__gt__, v4addr)
        self.assertRaises(TypeError, v6net_scoped.__lt__, v4net)
        self.assertRaises(TypeError, v6net_scoped.__gt__, v4net)
@skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
class IpaddrUnitTest(TestCase):
    def setUp(self):
        self.ipv4_address = ipaddress.IPv4Address("1.2.3.4")
        self.ipv4_interface = ipaddress.IPv4Interface("1.2.3.4/24")
        self.ipv4_network = ipaddress.IPv4Network("1.2.3.0/24")
        self.ipv6_address = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1")
        self.ipv6_interface = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1/64")
        self.ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/64")
        self.ipv6_scoped_address = ipaddress.IPv6Interface(
            "2001:658:22a:cafe:200:0:0:1%scope"
        )
        self.ipv6_scoped_interface = ipaddress.IPv6Interface(
            "2001:658:22a:cafe:200:0:0:1%scope/64"
        )
        self.ipv6_scoped_network = ipaddress.IPv6Network("2001:658:22a:cafe::%scope/64")
    def testRepr(self):
        self.assertEqual(
            "IPv4Interface('1.2.3.4/32')", repr(ipaddress.IPv4Interface("1.2.3.4"))
        )
        self.assertEqual(
            "IPv6Interface('::1/128')", repr(ipaddress.IPv6Interface("::1"))
        )
        self.assertEqual(
            "IPv6Interface('::1%scope/128')", repr(ipaddress.IPv6Interface("::1%scope"))
        )
    def testIPv4Tuple(self):
        ip = ipaddress.IPv4Address("192.0.2.1")
        net = ipaddress.IPv4Network("192.0.2.1/32")
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", 32)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 32)), net)
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", "255.255.255.255")), net)
        self.assertEqual(ipaddress.IPv4Network((ip, "255.255.255.255")), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, "255.255.255.255")), net)
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network(("192.0.2.1", 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network(("192.0.2.1", "255.255.255.0"))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, "255.255.255.0"))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, "255.255.255.0"))
        net = ipaddress.IPv4Network("192.0.2.0/24")
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 24), strict=False), net)
        self.assertEqual(
            ipaddress.IPv4Network(("192.0.2.1", "255.255.255.0"), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((ip, "255.255.255.0"), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((3221225985, "255.255.255.0"), strict=False), net
        )
        ip = ipaddress.IPv4Address("192.0.2.0")
        net = ipaddress.IPv4Network("192.0.2.0/24")
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.0", "255.255.255.0")), net)
        self.assertEqual(ipaddress.IPv4Network((ip, "255.255.255.0")), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, "255.255.255.0")), net)
        self.assertEqual(ipaddress.IPv4Network(("192.0.2.0", 24)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, 24)), net)
        self.assertEqual(
            ipaddress.IPv4Interface(("192.0.2.1", 24)),
            ipaddress.IPv4Interface("192.0.2.1/24"),
        )
        self.assertEqual(
            ipaddress.IPv4Interface((3221225985, 24)),
            ipaddress.IPv4Interface("192.0.2.1/24"),
        )
    def testIPv6Tuple(self):
        ip = ipaddress.IPv6Address("2001:db8::")
        net = ipaddress.IPv6Network("2001:db8::/128")
        self.assertEqual(ipaddress.IPv6Network(("2001:db8::", "128")), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 128)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, "128")), net)
        ip = ipaddress.IPv6Address("2001:db8::")
        net = ipaddress.IPv6Network("2001:db8::/96")
        self.assertEqual(ipaddress.IPv6Network(("2001:db8::", "96")), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 96)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, "96")), net)
        ip_scoped = ipaddress.IPv6Address("2001:db8::%scope")
        ip = ipaddress.IPv6Address("2001:db8::1")
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network(("2001:db8::1", 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((42540766411282592856903984951653826561, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip, 96))
        net = ipaddress.IPv6Network("2001:db8::/96")
        self.assertEqual(ipaddress.IPv6Network(("2001:db8::1", 96), strict=False), net)
        self.assertEqual(
            ipaddress.IPv6Network(
                (42540766411282592856903984951653826561, 96), strict=False
            ),
            net,
        )
        self.assertEqual(ipaddress.IPv6Network((ip, 96), strict=False), net)
        self.assertEqual(
            ipaddress.IPv6Interface(("2001:db8::1", "96")),
            ipaddress.IPv6Interface("2001:db8::1/96"),
        )
        self.assertEqual(
            ipaddress.IPv6Interface((42540766411282592856903984951653826561, "96")),
            ipaddress.IPv6Interface("2001:db8::1/96"),
        )
        ip_scoped = ipaddress.IPv6Address("2001:db8::1%scope")
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network(("2001:db8::1%scope", 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip_scoped, 96))
    def testAddressIntMath(self):
        self.assertEqual(
            ipaddress.IPv4Address("1.1.1.1") + 255, ipaddress.IPv4Address("1.1.2.0")
        )
        self.assertEqual(
            ipaddress.IPv4Address("1.1.1.1") - 256, ipaddress.IPv4Address("1.1.0.1")
        )
        self.assertEqual(
            ipaddress.IPv6Address("::1") + (2 ** 16 - 2),
            ipaddress.IPv6Address("::ffff"),
        )
        self.assertEqual(
            ipaddress.IPv6Address("::ffff") - (2 ** 16 - 2),
            ipaddress.IPv6Address("::1"),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address("::1%scope") + (2 ** 16 - 2),
            ipaddress.IPv6Address("::ffff%scope"),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address("::ffff%scope") - (2 ** 16 - 2),
            ipaddress.IPv6Address("::1%scope"),
        )
    def testInvalidIntToBytes(self):
        self.assertRaises(ValueError, ipaddress.v4_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v4_int_to_packed, 2 ** ipaddress.IPV4LENGTH
        )
        self.assertRaises(ValueError, ipaddress.v6_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v6_int_to_packed, 2 ** ipaddress.IPV6LENGTH
        )
    def testInternals(self):
        ip1 = ipaddress.IPv4Address("10.10.10.10")
        ip2 = ipaddress.IPv4Address("10.10.10.11")
        ip3 = ipaddress.IPv4Address("10.10.10.12")
        self.assertEqual(list(ipaddress._find_address_range([ip1])), [(ip1, ip1)])
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip3])), [(ip1, ip1), (ip3, ip3)]
        )
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip2, ip3])), [(ip1, ip3)]
        )
        self.assertEqual(128, ipaddress._count_righthand_zero_bits(0, 128))
        self.assertEqual("IPv4Network('1.2.3.0/24')", repr(self.ipv4_network))
    def testGetNetwork(self):
        self.assertEqual(int(self.ipv4_network.network_address), 16909056)
        self.assertEqual(str(self.ipv4_network.network_address), "1.2.3.0")
        self.assertEqual(
            int(self.ipv6_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(str(self.ipv6_network.network_address), "2001:658:22a:cafe::")
        self.assertEqual(str(self.ipv6_network.hostmask), "::ffff:ffff:ffff:ffff")
        self.assertEqual(
            int(self.ipv6_scoped_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address), "2001:658:22a:cafe::%scope"
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.hostmask), "::ffff:ffff:ffff:ffff"
        )
    def testIpFromInt(self):
        self.assertEqual(self.ipv4_interface._ip, ipaddress.IPv4Interface(16909060)._ip)
        ipv4 = ipaddress.ip_network("1.2.3.4")
        ipv6 = ipaddress.ip_network("2001:658:22a:cafe:200:0:0:1")
        ipv6_scoped = ipaddress.ip_network("2001:658:22a:cafe:200:0:0:1%scope")
        self.assertEqual(ipv4, ipaddress.ip_network(int(ipv4.network_address)))
        self.assertEqual(ipv6, ipaddress.ip_network(int(ipv6.network_address)))
        self.assertNotEqual(
            ipv6_scoped, ipaddress.ip_network(int(ipv6_scoped.network_address))
        )
        v6_int = 42540616829182469433547762482097946625
        self.assertEqual(self.ipv6_interface._ip, ipaddress.IPv6Interface(v6_int)._ip)
        self.assertEqual(
            self.ipv6_scoped_interface._ip, ipaddress.IPv6Interface(v6_int)._ip
        )
        self.assertEqual(ipaddress.ip_network(self.ipv4_address._ip).version, 4)
        self.assertEqual(ipaddress.ip_network(self.ipv6_address._ip).version, 6)
        self.assertEqual(ipaddress.ip_network(self.ipv6_scoped_address._ip).version, 6)
    def testIpFromPacked(self):
        address = ipaddress.ip_address
        self.assertEqual(
            self.ipv4_interface._ip, ipaddress.ip_interface(b"\x01\x02\x03\x04")._ip
        )
        self.assertEqual(address("255.254.253.252"), address(b"\xff\xfe\xfd\xfc"))
        self.assertEqual(
            self.ipv6_interface.ip,
            ipaddress.ip_interface(
                b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01"
            ).ip,
        )
        self.assertEqual(
            address("ffff:2:3:4:ffff::"),
            address(b"\xff\xff\x00\x02\x00\x03\x00\x04" + b"\xff\xff" + b"\x00" * 6),
        )
        self.assertEqual(address("::"), address(b"\x00" * 16))
    def testGetIp(self):
        self.assertEqual(int(self.ipv4_interface.ip), 16909060)
        self.assertEqual(str(self.ipv4_interface.ip), "1.2.3.4")
        self.assertEqual(
            int(self.ipv6_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_interface.ip), "2001:658:22a:cafe:200::1")
        self.assertEqual(
            int(self.ipv6_scoped_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_scoped_interface.ip), "2001:658:22a:cafe:200::1")
    def testGetScopeId(self):
        self.assertEqual(self.ipv6_address.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_address.scope_id), "scope")
        self.assertEqual(self.ipv6_interface.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_interface.scope_id), "scope")
        self.assertEqual(self.ipv6_network.network_address.scope_id, None)
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address.scope_id), "scope"
        )
    def testGetNetmask(self):
        self.assertEqual(int(self.ipv4_network.netmask), 4294967040)
        self.assertEqual(str(self.ipv4_network.netmask), "255.255.255.0")
        self.assertEqual(
            int(self.ipv6_network.netmask), 340282366920938463444927863358058659840
        )
        self.assertEqual(self.ipv6_network.prefixlen, 64)
        self.assertEqual(
            int(self.ipv6_scoped_network.netmask),
            340282366920938463444927863358058659840,
        )
        self.assertEqual(self.ipv6_scoped_network.prefixlen, 64)
    def testZeroNetmask(self):
        ipv4_zero_netmask = ipaddress.IPv4Interface("1.2.3.4/0")
        self.assertEqual(int(ipv4_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv4_zero_netmask._prefix_from_prefix_string("0"), 0)
        ipv6_zero_netmask = ipaddress.IPv6Interface("::1/0")
        self.assertEqual(int(ipv6_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_zero_netmask._prefix_from_prefix_string("0"), 0)
        ipv6_scoped_zero_netmask = ipaddress.IPv6Interface("::1%scope/0")
        self.assertEqual(int(ipv6_scoped_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_scoped_zero_netmask._prefix_from_prefix_string("0"), 0)
    def testIPv4Net(self):
        net = ipaddress.IPv4Network("127.0.0.0/0.0.0.255")
        self.assertEqual(net.prefixlen, 24)
    def testGetBroadcast(self):
        self.assertEqual(int(self.ipv4_network.broadcast_address), 16909311)
        self.assertEqual(str(self.ipv4_network.broadcast_address), "1.2.3.255")
        self.assertEqual(
            int(self.ipv6_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_network.broadcast_address),
            "2001:658:22a:cafe:ffff:ffff:ffff:ffff",
        )
        self.assertEqual(
            int(self.ipv6_scoped_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.broadcast_address),
            "2001:658:22a:cafe:ffff:ffff:ffff:ffff",
        )
    def testGetPrefixlen(self):
        self.assertEqual(self.ipv4_interface.network.prefixlen, 24)
        self.assertEqual(self.ipv6_interface.network.prefixlen, 64)
        self.assertEqual(self.ipv6_scoped_interface.network.prefixlen, 64)
    def testGetSupernet(self):
        self.assertEqual(self.ipv4_network.supernet().prefixlen, 23)
        self.assertEqual(str(self.ipv4_network.supernet().network_address), "1.2.2.0")
        self.assertEqual(
            ipaddress.IPv4Interface("0.0.0.0/0").network.supernet(),
            ipaddress.IPv4Network("0.0.0.0/0"),
        )
        self.assertEqual(self.ipv6_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_network.supernet().network_address), "2001:658:22a:cafe::"
        )
        self.assertEqual(
            ipaddress.IPv6Interface("::0/0").network.supernet(),
            ipaddress.IPv6Network("::0/0"),
        )
        self.assertEqual(self.ipv6_scoped_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet().network_address),
            "2001:658:22a:cafe::",
        )
    def testGetSupernet3(self):
        self.assertEqual(self.ipv4_network.supernet(3).prefixlen, 21)
        self.assertEqual(str(self.ipv4_network.supernet(3).network_address), "1.2.0.0")
        self.assertEqual(self.ipv6_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_network.supernet(3).network_address), "2001:658:22a:caf8::"
        )
        self.assertEqual(self.ipv6_scoped_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet(3).network_address),
            "2001:658:22a:caf8::",
        )
    def testGetSupernet4(self):
        self.assertRaises(
            ValueError, self.ipv4_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv4_network.supernet, new_prefix=25)
        self.assertEqual(
            self.ipv4_network.supernet(prefixlen_diff=2),
            self.ipv4_network.supernet(new_prefix=22),
        )
        self.assertRaises(
            ValueError, self.ipv6_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv6_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_network.supernet(prefixlen_diff=2),
            self.ipv6_network.supernet(new_prefix=62),
        )
        self.assertRaises(
            ValueError,
            self.ipv6_scoped_network.supernet,
            prefixlen_diff=2,
            new_prefix=1,
        )
        self.assertRaises(ValueError, self.ipv6_scoped_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_scoped_network.supernet(prefixlen_diff=2),
            self.ipv6_scoped_network.supernet(new_prefix=62),
        )
    def testHosts(self):
        hosts = list(self.ipv4_network.hosts())
        self.assertEqual(254, len(hosts))
        self.assertEqual(ipaddress.IPv4Address("1.2.3.1"), hosts[0])
        self.assertEqual(ipaddress.IPv4Address("1.2.3.254"), hosts[-1])
        ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/120")
        hosts = list(ipv6_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::1"), hosts[0])
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::ff"), hosts[-1])
        ipv6_scoped_network = ipaddress.IPv6Network("2001:658:22a:cafe::%scope/120")
        hosts = list(ipv6_scoped_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::1"), hosts[0])
        self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::ff"), hosts[-1])
        addrs = [ipaddress.IPv4Address("2.0.0.0"), ipaddress.IPv4Address("2.0.0.1")]
        str_args = "2.0.0.0/31"
        tpl_args = ("2.0.0.0", 31)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
        addrs = [ipaddress.IPv4Address("1.2.3.4")]
        str_args = "1.2.3.4/32"
        tpl_args = ("1.2.3.4", 32)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
        addrs = [
            ipaddress.IPv6Address("2001:658:22a:cafe::"),
            ipaddress.IPv6Address("2001:658:22a:cafe::1"),
        ]
        str_args = "2001:658:22a:cafe::/127"
        tpl_args = ("2001:658:22a:cafe::", 127)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
        addrs = [
            ipaddress.IPv6Address("2001:658:22a:cafe::1"),
        ]
        str_args = "2001:658:22a:cafe::1/128"
        tpl_args = ("2001:658:22a:cafe::1", 128)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )
    def testFancySubnetting(self):
        self.assertEqual(
            sorted(self.ipv4_network.subnets(prefixlen_diff=3)),
            sorted(self.ipv4_network.subnets(new_prefix=27)),
        )
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(new_prefix=23))
        self.assertRaises(
            ValueError, list, self.ipv4_network.subnets(prefixlen_diff=3, new_prefix=27)
        )
        self.assertEqual(
            sorted(self.ipv6_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_network.subnets(new_prefix=68)),
        )
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(new_prefix=63))
        self.assertRaises(
            ValueError, list, self.ipv6_network.subnets(prefixlen_diff=4, new_prefix=68)
        )
        self.assertEqual(
            sorted(self.ipv6_scoped_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_scoped_network.subnets(new_prefix=68)),
        )
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_network.subnets(new_prefix=63)
        )
        self.assertRaises(
            ValueError,
            list,
            self.ipv6_scoped_network.subnets(prefixlen_diff=4, new_prefix=68),
        )
    def testGetSubnets(self):
        self.assertEqual(list(self.ipv4_network.subnets())[0].prefixlen, 25)
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[0].network_address), "1.2.3.0"
        )
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[1].network_address), "1.2.3.128"
        )
        self.assertEqual(list(self.ipv6_network.subnets())[0].prefixlen, 65)
        self.assertEqual(list(self.ipv6_scoped_network.subnets())[0].prefixlen, 65)
    def testGetSubnetForSingle32(self):
        ip = ipaddress.IPv4Network("1.2.3.4/32")
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, ["1.2.3.4/32"])
        self.assertEqual(subnets1, subnets2)
    def testGetSubnetForSingle128(self):
        ip = ipaddress.IPv6Network("::1/128")
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, ["::1/128"])
        self.assertEqual(subnets1, subnets2)
        ip_scoped = ipaddress.IPv6Network("::1%scope/128")
        subnets1 = [str(x) for x in ip_scoped.subnets()]
        subnets2 = [str(x) for x in ip_scoped.subnets(2)]
        self.assertEqual(subnets1, ["::1%scope/128"])
        self.assertEqual(subnets1, subnets2)
    def testSubnet2(self):
        ips = [str(x) for x in self.ipv4_network.subnets(2)]
        self.assertEqual(
            ips, ["1.2.3.0/26", "1.2.3.64/26", "1.2.3.128/26", "1.2.3.192/26"]
        )
        ipsv6 = [str(x) for x in self.ipv6_network.subnets(2)]
        self.assertEqual(
            ipsv6,
            [
                "2001:658:22a:cafe::/66",
                "2001:658:22a:cafe:4000::/66",
                "2001:658:22a:cafe:8000::/66",
                "2001:658:22a:cafe:c000::/66",
            ],
        )
    def testGetSubnets3(self):
        subnets = [str(x) for x in self.ipv4_network.subnets(8)]
        self.assertEqual(subnets[:3], ["1.2.3.0/32", "1.2.3.1/32", "1.2.3.2/32"])
        self.assertEqual(subnets[-3:], ["1.2.3.253/32", "1.2.3.254/32", "1.2.3.255/32"])
        self.assertEqual(len(subnets), 256)
        ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/120")
        subnets = [str(x) for x in ipv6_network.subnets(8)]
        self.assertEqual(
            subnets[:3],
            [
                "2001:658:22a:cafe::/128",
                "2001:658:22a:cafe::1/128",
                "2001:658:22a:cafe::2/128",
            ],
        )
        self.assertEqual(
            subnets[-3:],
            [
                "2001:658:22a:cafe::fd/128",
                "2001:658:22a:cafe::fe/128",
                "2001:658:22a:cafe::ff/128",
            ],
        )
        self.assertEqual(len(subnets), 256)
    def testSubnetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(65))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(65))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(65)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(65))
    def testSupernetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, self.ipv4_interface.network.supernet, 25)
        self.assertRaises(ValueError, self.ipv6_interface.network.supernet, 65)
        self.assertRaises(ValueError, self.ipv6_scoped_interface.network.supernet, 65)
    def testSubnetFailsForNegativeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(-1))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(-1)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(-1))
    def testGetNum_Addresses(self):
        self.assertEqual(self.ipv4_network.num_addresses, 256)
        self.assertEqual(list(self.ipv4_network.subnets())[0].num_addresses, 128)
        self.assertEqual(self.ipv4_network.supernet().num_addresses, 512)
        self.assertEqual(self.ipv6_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_network.subnets())[0].num_addresses, 9223372036854775808
        )
        self.assertEqual(
            self.ipv6_network.supernet().num_addresses, 36893488147419103232
        )
        self.assertEqual(self.ipv6_scoped_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_scoped_network.subnets())[0].num_addresses,
            9223372036854775808,
        )
        self.assertEqual(
            self.ipv6_scoped_network.supernet().num_addresses, 36893488147419103232
        )
    def testContains(self):
        self.assertIn(ipaddress.IPv4Interface("1.2.3.128/25"), self.ipv4_network)
        self.assertNotIn(ipaddress.IPv4Interface("1.2.4.1/24"), self.ipv4_network)
        addr1 = ipaddress.IPv4Address("1.2.3.37")
        self.assertIn(addr1, self.ipv4_network)
        self.assertFalse(
            ipaddress.IPv4Network("1.1.0.0/16").__contains__(
                ipaddress.IPv4Network("1.0.0.0/15")
            )
        )
    def testNth(self):
        self.assertEqual(str(self.ipv4_network[5]), "1.2.3.5")
        self.assertRaises(IndexError, self.ipv4_network.__getitem__, 256)
        self.assertEqual(str(self.ipv6_network[5]), "2001:658:22a:cafe::5")
        self.assertRaises(IndexError, self.ipv6_network.__getitem__, 1 &lt;&lt; 64)
        self.assertEqual(str(self.ipv6_scoped_network[5]), "2001:658:22a:cafe::5")
        self.assertRaises(IndexError, self.ipv6_scoped_network.__getitem__, 1 &lt;&lt; 64)
    def testGetitem(self):
        addr = ipaddress.IPv4Network("172.31.255.128/255.255.255.240")
        self.assertEqual(28, addr.prefixlen)
        addr_list = list(addr)
        self.assertEqual("172.31.255.128", str(addr_list[0]))
        self.assertEqual("172.31.255.128", str(addr[0]))
        self.assertEqual("172.31.255.143", str(addr_list[-1]))
        self.assertEqual("172.31.255.143", str(addr[-1]))
        self.assertEqual(addr_list[-1], addr[-1])
    def testEqual(self):
        self.assertTrue(self.ipv4_interface == ipaddress.IPv4Interface("1.2.3.4/24"))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv6Interface("::1.2.3.4/24"))
        self.assertFalse(
            self.ipv4_interface == ipaddress.IPv6Interface("::1.2.3.4%scope/24")
        )
        self.assertFalse(self.ipv4_interface == "")
        self.assertFalse(self.ipv4_interface == [])
        self.assertFalse(self.ipv4_interface == 2)
        self.assertTrue(
            self.ipv6_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertFalse(
            self.ipv6_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertFalse(self.ipv6_interface == ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertFalse(self.ipv6_interface == "")
        self.assertFalse(self.ipv6_interface == [])
        self.assertFalse(self.ipv6_interface == 2)
        self.assertTrue(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/64")
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/63")
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertFalse(
            self.ipv6_scoped_interface == ipaddress.IPv4Interface("1.2.3.4/23")
        )
        self.assertFalse(self.ipv6_scoped_interface == "")
        self.assertFalse(self.ipv6_scoped_interface == [])
        self.assertFalse(self.ipv6_scoped_interface == 2)
    def testNotEqual(self):
        self.assertFalse(self.ipv4_interface != ipaddress.IPv4Interface("1.2.3.4/24"))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv6Interface("::1.2.3.4/24"))
        self.assertTrue(
            self.ipv4_interface != ipaddress.IPv6Interface("::1.2.3.4%scope/24")
        )
        self.assertTrue(self.ipv4_interface != "")
        self.assertTrue(self.ipv4_interface != [])
        self.assertTrue(self.ipv4_interface != 2)
        self.assertTrue(self.ipv4_address != ipaddress.IPv4Address("1.2.3.5"))
        self.assertTrue(self.ipv4_address != "")
        self.assertTrue(self.ipv4_address != [])
        self.assertTrue(self.ipv4_address != 2)
        self.assertFalse(
            self.ipv6_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertTrue(
            self.ipv6_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertTrue(self.ipv6_interface != ipaddress.IPv4Interface("1.2.3.4/23"))
        self.assertTrue(self.ipv6_interface != "")
        self.assertTrue(self.ipv6_interface != [])
        self.assertTrue(self.ipv6_interface != 2)
        self.assertTrue(self.ipv6_address != ipaddress.IPv4Address("1.2.3.4"))
        self.assertTrue(self.ipv6_address != "")
        self.assertTrue(self.ipv6_address != [])
        self.assertTrue(self.ipv6_address != 2)
        self.assertFalse(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/64")
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/63")
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
        )
        self.assertTrue(
            self.ipv6_scoped_interface != ipaddress.IPv4Interface("1.2.3.4/23")
        )
        self.assertTrue(self.ipv6_scoped_interface != "")
        self.assertTrue(self.ipv6_scoped_interface != [])
        self.assertTrue(self.ipv6_scoped_interface != 2)
        self.assertTrue(self.ipv6_scoped_address != ipaddress.IPv4Address("1.2.3.4"))
        self.assertTrue(self.ipv6_scoped_address != "")
        self.assertTrue(self.ipv6_scoped_address != [])
        self.assertTrue(self.ipv6_scoped_address != 2)
    def testSlash32Constructor(self):
        self.assertEqual(
            str(ipaddress.IPv4Interface("1.2.3.4/255.255.255.255")), "1.2.3.4/32"
        )
    def testSlash128Constructor(self):
        self.assertEqual(str(ipaddress.IPv6Interface("::1/128")), "::1/128")
        self.assertEqual(str(ipaddress.IPv6Interface("::1%scope/128")), "::1%scope/128")
    def testSlash0Constructor(self):
        self.assertEqual(str(ipaddress.IPv4Interface("1.2.3.4/0.0.0.0")), "1.2.3.4/0")
    def testCollapsing(self):
        ip1 = ipaddress.IPv4Address("1.1.1.0")
        ip2 = ipaddress.IPv4Address("1.1.1.1")
        ip3 = ipaddress.IPv4Address("1.1.1.2")
        ip4 = ipaddress.IPv4Address("1.1.1.3")
        ip5 = ipaddress.IPv4Address("1.1.1.4")
        ip6 = ipaddress.IPv4Address("1.1.1.0")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network("1.1.1.0/30"), ipaddress.IPv4Network("1.1.1.4/32")],
        )
        ip1 = ipaddress.IPv4Address("1.1.1.0")
        ip2 = ipaddress.IPv4Address("1.1.1.1")
        ip3 = ipaddress.IPv4Address("1.1.1.2")
        ip4 = ipaddress.IPv4Address("1.1.1.3")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network("1.1.1.0/30")])
        ip1 = ipaddress.IPv4Network("1.1.0.0/24")
        ip2 = ipaddress.IPv4Network("1.1.1.0/24")
        ip3 = ipaddress.IPv4Network("1.1.2.0/24")
        ip4 = ipaddress.IPv4Network("1.1.3.0/24")
        ip5 = ipaddress.IPv4Network("1.1.4.0/24")
        ip6 = ipaddress.IPv4Network("1.1.0.0/22")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network("1.1.0.0/22"), ipaddress.IPv4Network("1.1.4.0/24")],
        )
        collapsed = ipaddress.collapse_addresses([ip1, ip2])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network("1.1.0.0/23")])
        ip_same1 = ip_same2 = ipaddress.IPv4Network("1.1.1.1/32")
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])), [ip_same1]
        )
        ip_same1 = ip_same2 = ipaddress.IPv4Address("1.1.1.1")
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])),
            [ipaddress.ip_network("1.1.1.1/32")],
        )
        ip1 = ipaddress.IPv6Network("2001::/100")
        ip2 = ipaddress.IPv6Network("2001::/120")
        ip3 = ipaddress.IPv6Network("2001::/96")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])
        ip1 = ipaddress.IPv6Network("2001::%scope/100")
        ip2 = ipaddress.IPv6Network("2001::%scope/120")
        ip3 = ipaddress.IPv6Network("2001::%scope/96")
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])
        addr_tuples = [
            (ipaddress.ip_address("1.1.1.1"), ipaddress.ip_address("::1")),
            (ipaddress.IPv4Network("1.1.0.0/24"), ipaddress.IPv6Network("2001::/120")),
            (ipaddress.IPv4Network("1.1.0.0/32"), ipaddress.IPv6Network("2001::/128")),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])
        addr_tuples = [
            (ipaddress.ip_address("1.1.1.1"), ipaddress.ip_address("::1%scope")),
            (
                ipaddress.IPv4Network("1.1.0.0/24"),
                ipaddress.IPv6Network("2001::%scope/120"),
            ),
            (
                ipaddress.IPv4Network("1.1.0.0/32"),
                ipaddress.IPv6Network("2001::%scope/128"),
            ),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])
    def testSummarizing(self):
        summarize = ipaddress.summarize_address_range
        ip1 = ipaddress.ip_address("1.1.1.0")
        ip2 = ipaddress.ip_address("1.1.1.255")
        class IPv7Address(ipaddress.IPv6Address):
            @property
            def version(self):
                return 7
        ip_invalid1 = IPv7Address("::1")
        ip_invalid2 = IPv7Address("::1")
        self.assertRaises(ValueError, list, summarize(ip_invalid1, ip_invalid2))
        self.assertRaises(TypeError, list, summarize(ip1, ipaddress.IPv6Address("::1")))
        self.assertRaises(
            TypeError, list, summarize(ip1, ipaddress.IPv6Address("::1%scope"))
        )
        self.assertEqual(
            list(summarize(ip1, ip2))[0], ipaddress.ip_network("1.1.1.0/24")
        )
        ip2 = ipaddress.ip_address("1.1.1.8")
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network("1.1.1.0/29"), ipaddress.ip_network("1.1.1.8")],
        )
        ip1 = ipaddress.IPv4Address(0)
        ip2 = ipaddress.IPv4Address(ipaddress.IPv4Address._ALL_ONES)
        self.assertEqual(
            [ipaddress.IPv4Network("0.0.0.0/0")], list(summarize(ip1, ip2))
        )
        ip1 = ipaddress.ip_address("1::")
        ip2 = ipaddress.ip_address("1:ffff:ffff:ffff:ffff:ffff:ffff:ffff")
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network("1::/16"))
        ip2 = ipaddress.ip_address("2::")
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network("1::/16"), ipaddress.ip_network("2::/128")],
        )
        ip1 = ipaddress.ip_address("1::%scope")
        ip2 = ipaddress.ip_address("1:ffff:ffff:ffff:ffff:ffff:ffff:ffff%scope")
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network("1::/16"))
        ip2 = ipaddress.ip_address("2::%scope")
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network("1::/16"), ipaddress.ip_network("2::/128")],
        )
        self.assertRaises(
            ValueError,
            list,
            summarize(ipaddress.ip_address("1.1.1.0"), ipaddress.ip_address("1.1.0.0")),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network("1.1.1.0"), ipaddress.ip_network("1.1.0.0")),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network("1.1.1.0"), ipaddress.ip_network("1.1.0.0")),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_address("::"), ipaddress.ip_network("1.1.0.0")),
        )
    def testAddressComparison(self):
        self.assertTrue(
            ipaddress.ip_address("1.1.1.1") &lt;= ipaddress.ip_address("1.1.1.1")
        )
        self.assertTrue(
            ipaddress.ip_address("1.1.1.1") &lt;= ipaddress.ip_address("1.1.1.2")
        )
        self.assertTrue(ipaddress.ip_address("::1") &lt;= ipaddress.ip_address("::1"))
        self.assertTrue(ipaddress.ip_address("::1") &lt;= ipaddress.ip_address("::2"))
        self.assertTrue(
            ipaddress.ip_address("::1%scope") &lt;= ipaddress.ip_address("::1%scope")
        )
        self.assertTrue(
            ipaddress.ip_address("::1%scope") &lt;= ipaddress.ip_address("::2%scope")
        )
    def testInterfaceComparison(self):
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") == ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/16") &lt; ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") &lt; ipaddress.ip_interface("1.1.1.2/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.2/16") &lt; ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") &gt; ipaddress.ip_interface("1.1.1.1/16")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.2/24") &gt; ipaddress.ip_interface("1.1.1.1/24")
        )
        self.assertTrue(
            ipaddress.ip_interface("1.1.1.1/24") &gt; ipaddress.ip_interface("1.1.1.2/16")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") == ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::1/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::2/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/48") &lt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/80") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/64") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &gt; ipaddress.ip_interface("::2/48")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            == ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            &lt; ipaddress.ip_interface("::1%scope/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            &lt; ipaddress.ip_interface("::2%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/48")
            &lt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/80")
            &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/64")
            &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64")
            &gt; ipaddress.ip_interface("::2%scope/48")
        )
        self.assertFalse(
            ipaddress.ip_interface("::1%scope/64") == ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64") &lt; ipaddress.ip_interface("::1/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64") &lt; ipaddress.ip_interface("::2/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/48") &lt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/80") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2%scope/64") &gt; ipaddress.ip_interface("::1/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1%scope/64") &gt; ipaddress.ip_interface("::2/48")
        )
        self.assertFalse(
            ipaddress.ip_interface("::1/64") == ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::1%scope/80")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::2%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/48") &lt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/80") &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::2/64") &gt; ipaddress.ip_interface("::1%scope/64")
        )
        self.assertTrue(
            ipaddress.ip_interface("::1/64") &gt; ipaddress.ip_interface("::2%scope/48")
        )
    def testNetworkComparison(self):
        ip1 = ipaddress.IPv4Network("1.1.1.0/24")
        ip2 = ipaddress.IPv4Network("1.1.1.0/32")
        ip3 = ipaddress.IPv4Network("1.1.2.0/24")
        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        self.assertEqual(ip1.compare_networks(ip1), 0)
        self.assertEqual(ip1.compare_networks(ip2), -1)
        self.assertEqual(ip2.compare_networks(ip1), 1)
        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertEqual(ip3.compare_networks(ip1), 1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())
        ip1 = ipaddress.IPv6Network("2001:2000::/96")
        ip2 = ipaddress.IPv6Network("2001:2001::/96")
        ip3 = ipaddress.IPv6Network("2001:ffff:2000::/96")
        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())
        self.assertRaises(
            TypeError, self.ipv4_network.compare_networks, self.ipv6_network
        )
        ipv6 = ipaddress.IPv6Interface("::/0")
        ipv4 = ipaddress.IPv4Interface("0.0.0.0/0")
        self.assertRaises(TypeError, ipv4.__lt__, ipv6)
        self.assertRaises(TypeError, ipv4.__gt__, ipv6)
        self.assertRaises(TypeError, ipv6.__lt__, ipv4)
        self.assertRaises(TypeError, ipv6.__gt__, ipv4)
        ip1 = ipaddress.ip_network("10.1.2.128/25")
        self.assertFalse(ip1 &lt; ip1)
        self.assertFalse(ip1 &gt; ip1)
        ip2 = ipaddress.ip_network("10.1.3.0/24")
        self.assertTrue(ip1 &lt; ip2)
        self.assertFalse(ip2 &lt; ip1)
        self.assertFalse(ip1 &gt; ip2)
        self.assertTrue(ip2 &gt; ip1)
        ip3 = ipaddress.ip_network("10.1.3.0/25")
        self.assertTrue(ip2 &lt; ip3)
        self.assertFalse(ip3 &lt; ip2)
        self.assertFalse(ip2 &gt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        ip1 = ipaddress.ip_network("10.10.10.0/31")
        ip2 = ipaddress.ip_network("10.10.10.0")
        ip3 = ipaddress.ip_network("10.10.10.2/31")
        ip4 = ipaddress.ip_network("10.10.10.2")
        sorted = [ip1, ip2, ip3, ip4]
        unsorted = [ip2, ip4, ip1, ip3]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        unsorted = [ip4, ip1, ip3, ip2]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        self.assertIs(ip1.__lt__(ipaddress.ip_address("10.10.10.0")), NotImplemented)
        self.assertIs(ip2.__lt__(ipaddress.ip_address("10.10.10.0")), NotImplemented)
        self.assertTrue(
            ipaddress.ip_network("1.1.1.1") &lt;= ipaddress.ip_network("1.1.1.1")
        )
        self.assertTrue(
            ipaddress.ip_network("1.1.1.1") &lt;= ipaddress.ip_network("1.1.1.2")
        )
        self.assertFalse(
            ipaddress.ip_network("1.1.1.2") &lt;= ipaddress.ip_network("1.1.1.1")
        )
        self.assertTrue(ipaddress.ip_network("::1") &lt;= ipaddress.ip_network("::1"))
        self.assertTrue(ipaddress.ip_network("::1") &lt;= ipaddress.ip_network("::2"))
        self.assertFalse(ipaddress.ip_network("::2") &lt;= ipaddress.ip_network("::1"))
    def testStrictNetworks(self):
        self.assertRaises(ValueError, ipaddress.ip_network, "192.168.1.1/24")
        self.assertRaises(ValueError, ipaddress.ip_network, "::1/120")
        self.assertRaises(ValueError, ipaddress.ip_network, "::1%scope/120")
    def testOverlaps(self):
        other = ipaddress.IPv4Network("1.2.3.0/30")
        other2 = ipaddress.IPv4Network("1.2.2.0/24")
        other3 = ipaddress.IPv4Network("1.2.2.64/26")
        self.assertTrue(self.ipv4_network.overlaps(other))
        self.assertFalse(self.ipv4_network.overlaps(other2))
        self.assertTrue(other2.overlaps(other3))
    def testEmbeddedIpv4(self):
        ipv4_string = "192.168.0.1"
        ipv4 = ipaddress.IPv4Interface(ipv4_string)
        v4compat_ipv6 = ipaddress.IPv6Interface("::%s" % ipv4_string)
        self.assertEqual(int(v4compat_ipv6.ip), int(ipv4.ip))
        v4mapped_ipv6 = ipaddress.IPv6Interface("::ffff:%s" % ipv4_string)
        self.assertNotEqual(v4mapped_ipv6.ip, ipv4.ip)
        self.assertRaises(
            ipaddress.AddressValueError, ipaddress.IPv6Interface, "2001:1.1.1.1:1.1.1.1"
        )
    def testIPv6AddressTooLarge(self):
        self.assertEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1"),
            ipaddress.ip_address("::FFFF:c000:201"),
        )
        self.assertEqual(
            ipaddress.ip_address("FFFF::192.0.2.1"),
            ipaddress.ip_address("FFFF::c000:201"),
        )
        self.assertEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1%scope"),
            ipaddress.ip_address("::FFFF:c000:201%scope"),
        )
        self.assertEqual(
            ipaddress.ip_address("FFFF::192.0.2.1%scope"),
            ipaddress.ip_address("FFFF::c000:201%scope"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1%scope"),
            ipaddress.ip_address("::FFFF:c000:201"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("FFFF::192.0.2.1%scope"),
            ipaddress.ip_address("FFFF::c000:201"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("::FFFF:192.0.2.1"),
            ipaddress.ip_address("::FFFF:c000:201%scope"),
        )
        self.assertNotEqual(
            ipaddress.ip_address("FFFF::192.0.2.1"),
            ipaddress.ip_address("FFFF::c000:201%scope"),
        )
    def testIPVersion(self):
        self.assertEqual(self.ipv4_address.version, 4)
        self.assertEqual(self.ipv6_address.version, 6)
        self.assertEqual(self.ipv6_scoped_address.version, 6)
    def testMaxPrefixLength(self):
        self.assertEqual(self.ipv4_interface.max_prefixlen, 32)
        self.assertEqual(self.ipv6_interface.max_prefixlen, 128)
        self.assertEqual(self.ipv6_scoped_interface.max_prefixlen, 128)
    def testPacked(self):
        self.assertEqual(self.ipv4_address.packed, b"\x01\x02\x03\x04")
        self.assertEqual(
            ipaddress.IPv4Interface("255.254.253.252").packed, b"\xff\xfe\xfd\xfc"
        )
        self.assertEqual(
            self.ipv6_address.packed,
            b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01",
        )
        self.assertEqual(
            ipaddress.IPv6Interface("ffff:2:3:4:ffff::").packed,
            b"\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff" + b"\x00" * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface("::1:0:0:0:0").packed,
            b"\x00" * 6 + b"\x00\x01" + b"\x00" * 8,
        )
        self.assertEqual(
            self.ipv6_scoped_address.packed,
            b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01",
        )
        self.assertEqual(
            ipaddress.IPv6Interface("ffff:2:3:4:ffff::%scope").packed,
            b"\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff" + b"\x00" * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface("::1:0:0:0:0%scope").packed,
            b"\x00" * 6 + b"\x00\x01" + b"\x00" * 8,
        )
    def testIpType(self):
        ipv4net = ipaddress.ip_network("1.2.3.4")
        ipv4addr = ipaddress.ip_address("1.2.3.4")
        ipv6net = ipaddress.ip_network("::1.2.3.4")
        ipv6addr = ipaddress.ip_address("::1.2.3.4")
        self.assertEqual(ipaddress.IPv4Network, type(ipv4net))
        self.assertEqual(ipaddress.IPv4Address, type(ipv4addr))
        self.assertEqual(ipaddress.IPv6Network, type(ipv6net))
        self.assertEqual(ipaddress.IPv6Address, type(ipv6addr))
    def testReservedIpv4(self):
        self.assertEqual(True, ipaddress.ip_interface("224.1.1.1/31").is_multicast)
        self.assertEqual(False, ipaddress.ip_network("240.0.0.0").is_multicast)
        self.assertEqual(True, ipaddress.ip_network("240.0.0.0").is_reserved)
        self.assertEqual(True, ipaddress.ip_interface("192.168.1.1/17").is_private)
        self.assertEqual(False, ipaddress.ip_network("192.169.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_network("10.255.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_network("11.0.0.0").is_private)
        self.assertEqual(False, ipaddress.ip_network("11.0.0.0").is_reserved)
        self.assertEqual(True, ipaddress.ip_network("172.31.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_network("172.32.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_network("169.254.1.0/24").is_link_local)
        self.assertEqual(
            True, ipaddress.ip_interface("169.254.100.200/24").is_link_local
        )
        self.assertEqual(
            False, ipaddress.ip_interface("169.255.100.200/24").is_link_local
        )
        self.assertEqual(True, ipaddress.ip_network("127.100.200.254/32").is_loopback)
        self.assertEqual(True, ipaddress.ip_network("127.42.0.0/16").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("128.0.0.0").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("100.64.0.0/10").is_private)
        self.assertEqual(False, ipaddress.ip_network("100.64.0.0/10").is_global)
        self.assertEqual(True, ipaddress.ip_network("192.0.2.128/25").is_private)
        self.assertEqual(True, ipaddress.ip_network("192.0.3.0/24").is_global)
        self.assertEqual(True, ipaddress.ip_address("0.0.0.0").is_unspecified)
        self.assertEqual(True, ipaddress.ip_address("224.1.1.1").is_multicast)
        self.assertEqual(False, ipaddress.ip_address("240.0.0.0").is_multicast)
        self.assertEqual(True, ipaddress.ip_address("240.0.0.1").is_reserved)
        self.assertEqual(False, ipaddress.ip_address("239.255.255.255").is_reserved)
        self.assertEqual(True, ipaddress.ip_address("192.168.1.1").is_private)
        self.assertEqual(False, ipaddress.ip_address("192.169.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_address("10.255.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_address("11.0.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_address("172.31.255.255").is_private)
        self.assertEqual(False, ipaddress.ip_address("172.32.0.0").is_private)
        self.assertEqual(True, ipaddress.ip_address("169.254.100.200").is_link_local)
        self.assertEqual(False, ipaddress.ip_address("169.255.100.200").is_link_local)
        self.assertTrue(ipaddress.ip_address("192.0.7.1").is_global)
        self.assertFalse(ipaddress.ip_address("203.0.113.1").is_global)
        self.assertEqual(True, ipaddress.ip_address("127.100.200.254").is_loopback)
        self.assertEqual(True, ipaddress.ip_address("127.42.0.0").is_loopback)
        self.assertEqual(False, ipaddress.ip_address("128.0.0.0").is_loopback)
        self.assertEqual(True, ipaddress.ip_network("0.0.0.0").is_unspecified)
    def testReservedIpv6(self):
        self.assertEqual(True, ipaddress.ip_network("ffff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_network(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_network("ff00::").is_multicast)
        self.assertEqual(False, ipaddress.ip_network("fdff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_network("fecf::").is_site_local)
        self.assertEqual(
            True, ipaddress.ip_network("feff:ffff:ffff:ffff::").is_site_local
        )
        self.assertEqual(False, ipaddress.ip_network("fbf:ffff::").is_site_local)
        self.assertEqual(False, ipaddress.ip_network("ff00::").is_site_local)
        self.assertEqual(True, ipaddress.ip_network("fc00::").is_private)
        self.assertEqual(True, ipaddress.ip_network("fc00:ffff:ffff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_network("fbff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_network("fe00::").is_private)
        self.assertEqual(True, ipaddress.ip_network("fea0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_network("febf:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_network("fe7f:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_network("fec0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_interface("0:0::0:01").is_loopback)
        self.assertEqual(False, ipaddress.ip_interface("::1/127").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("::").is_loopback)
        self.assertEqual(False, ipaddress.ip_network("::2").is_loopback)
        self.assertEqual(True, ipaddress.ip_network("0::0").is_unspecified)
        self.assertEqual(False, ipaddress.ip_network("::1").is_unspecified)
        self.assertEqual(False, ipaddress.ip_network("::/127").is_unspecified)
        self.assertEqual(True, ipaddress.ip_network("2001::1/128").is_private)
        self.assertEqual(True, ipaddress.ip_network("200::1/128").is_global)
        self.assertEqual(True, ipaddress.ip_address("ffff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_address(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_address("ff00::").is_multicast)
        self.assertEqual(False, ipaddress.ip_address("fdff::").is_multicast)
        self.assertEqual(True, ipaddress.ip_address("fecf::").is_site_local)
        self.assertEqual(
            True, ipaddress.ip_address("feff:ffff:ffff:ffff::").is_site_local
        )
        self.assertEqual(False, ipaddress.ip_address("fbf:ffff::").is_site_local)
        self.assertEqual(False, ipaddress.ip_address("ff00::").is_site_local)
        self.assertEqual(True, ipaddress.ip_address("fc00::").is_private)
        self.assertEqual(True, ipaddress.ip_address("fc00:ffff:ffff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_address("fbff:ffff::").is_private)
        self.assertEqual(False, ipaddress.ip_address("fe00::").is_private)
        self.assertEqual(True, ipaddress.ip_address("fea0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_address("febf:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_address("fe7f:ffff::").is_link_local)
        self.assertEqual(False, ipaddress.ip_address("fec0::").is_link_local)
        self.assertEqual(True, ipaddress.ip_address("0:0::0:01").is_loopback)
        self.assertEqual(True, ipaddress.ip_address("::1").is_loopback)
        self.assertEqual(False, ipaddress.ip_address("::2").is_loopback)
        self.assertEqual(True, ipaddress.ip_address("0::0").is_unspecified)
        self.assertEqual(False, ipaddress.ip_address("::1").is_unspecified)
        self.assertEqual(True, ipaddress.ip_address("100::").is_reserved)
        self.assertEqual(True, ipaddress.ip_network("4000::1/128").is_reserved)
    def testIpv4Mapped(self):
        self.assertEqual(
            ipaddress.ip_address("::ffff:192.168.1.1").ipv4_mapped,
            ipaddress.ip_address("192.168.1.1"),
        )
        self.assertEqual(ipaddress.ip_address("::c0a8:101").ipv4_mapped, None)
        self.assertEqual(
            ipaddress.ip_address("::ffff:c0a8:101").ipv4_mapped,
            ipaddress.ip_address("192.168.1.1"),
        )
    def testAddrExclude(self):
        addr1 = ipaddress.ip_network("10.1.1.0/24")
        addr2 = ipaddress.ip_network("10.1.1.0/26")
        addr3 = ipaddress.ip_network("10.2.1.0/24")
        addr4 = ipaddress.ip_address("10.1.1.0")
        addr5 = ipaddress.ip_network("2001:db8::0/32")
        addr6 = ipaddress.ip_network("10.1.1.5/32")
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr2))),
            [
                ipaddress.ip_network("10.1.1.64/26"),
                ipaddress.ip_network("10.1.1.128/25"),
            ],
        )
        self.assertRaises(ValueError, list, addr1.address_exclude(addr3))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr4))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr5))
        self.assertEqual(list(addr1.address_exclude(addr1)), [])
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr6))),
            [
                ipaddress.ip_network("10.1.1.0/30"),
                ipaddress.ip_network("10.1.1.4/32"),
                ipaddress.ip_network("10.1.1.6/31"),
                ipaddress.ip_network("10.1.1.8/29"),
                ipaddress.ip_network("10.1.1.16/28"),
                ipaddress.ip_network("10.1.1.32/27"),
                ipaddress.ip_network("10.1.1.64/26"),
                ipaddress.ip_network("10.1.1.128/25"),
            ],
        )
    def testHash(self):
        self.assertEqual(
            hash(ipaddress.ip_interface("10.1.1.0/24")),
            hash(ipaddress.ip_interface("10.1.1.0/24")),
        )
        self.assertEqual(
            hash(ipaddress.ip_network("10.1.1.0/24")),
            hash(ipaddress.ip_network("10.1.1.0/24")),
        )
        self.assertEqual(
            hash(ipaddress.ip_address("10.1.1.0")),
            hash(ipaddress.ip_address("10.1.1.0")),
        )
        self.assertEqual(
            hash(ipaddress.ip_address("1.2.3.4")),
            hash(ipaddress.ip_address(int(ipaddress.ip_address("1.2.3.4")._ip))),
        )
        ip1 = ipaddress.ip_address("10.1.1.0")
        ip2 = ipaddress.ip_address("1::")
        dummy = {}
        dummy[self.ipv4_address] = None
        dummy[self.ipv6_address] = None
        dummy[ip1] = None
        dummy[ip2] = None
        self.assertIn(self.ipv4_address, dummy)
        self.assertIn(ip2, dummy)
    def testIPBases(self):
        net = self.ipv4_network
        self.assertEqual("1.2.3.0/24", net.compressed)
        net = self.ipv6_network
        self.assertRaises(ValueError, net._string_from_ip_int, 2 ** 128 + 1)
    def testIPv6NetworkHelpers(self):
        net = self.ipv6_network
        self.assertEqual("2001:658:22a:cafe::/64", net.with_prefixlen)
        self.assertEqual("2001:658:22a:cafe::/ffff:ffff:ffff:ffff::", net.with_netmask)
        self.assertEqual("2001:658:22a:cafe::/::ffff:ffff:ffff:ffff", net.with_hostmask)
        self.assertEqual("2001:658:22a:cafe::/64", str(net))
    def testIPv4NetworkHelpers(self):
        net = self.ipv4_network
        self.assertEqual("1.2.3.0/24", net.with_prefixlen)
        self.assertEqual("1.2.3.0/255.255.255.0", net.with_netmask)
        self.assertEqual("1.2.3.0/0.0.0.255", net.with_hostmask)
        self.assertEqual("1.2.3.0/24", str(net))
    def testCopyConstructor(self):
        addr1 = ipaddress.ip_network("10.1.1.0/24")
        addr2 = ipaddress.ip_network(addr1)
        addr3 = ipaddress.ip_interface("2001:658:22a:cafe:200::1/64")
        addr4 = ipaddress.ip_interface(addr3)
        addr5 = ipaddress.IPv4Address("1.1.1.1")
        addr6 = ipaddress.IPv6Address("2001:658:22a:cafe:200::1")
        self.assertEqual(addr1, addr2)
        self.assertEqual(addr3, addr4)
        self.assertEqual(addr5, ipaddress.IPv4Address(addr5))
        self.assertEqual(addr6, ipaddress.IPv6Address(addr6))
    def testCompressIPv6Address(self):
        test_addresses = {
            "1:2:3:4:5:6:7:8": "1:2:3:4:5:6:7:8/128",
            "2001:0:0:4:0:0:0:8": "2001:0:0:4::8/128",
            "2001:0:0:4:5:6:7:8": "2001::4:5:6:7:8/128",
            "2001:0:3:4:5:6:7:8": "2001:0:3:4:5:6:7:8/128",
            "0:0:3:0:0:0:0:ffff": "0:0:3::ffff/128",
            "0:0:0:4:0:0:0:ffff": "::4:0:0:0:ffff/128",
            "0:0:0:0:5:0:0:ffff": "::5:0:0:ffff/128",
            "1:0:0:4:0:0:7:8": "1::4:0:0:7:8/128",
            "0:0:0:0:0:0:0:0": "::/128",
            "0:0:0:0:0:0:0:0/0": "::/0",
            "0:0:0:0:0:0:0:1": "::1/128",
            "2001:0658:022a:cafe:0000:0000:0000:0000/66": "2001:658:22a:cafe::/66",
            "::1.2.3.4": "::102:304/128",
            "1:2:3:4:5:ffff:1.2.3.4": "1:2:3:4:5:ffff:102:304/128",
            "::7:6:5:4:3:2:1": "0:7:6:5:4:3:2:1/128",
            "::7:6:5:4:3:2:0": "0:7:6:5:4:3:2:0/128",
            "7:6:5:4:3:2:1::": "7:6:5:4:3:2:1:0/128",
            "0:6:5:4:3:2:1::": "0:6:5:4:3:2:1:0/128",
        }
        for uncompressed, compressed in list(test_addresses.items()):
            self.assertEqual(compressed, str(ipaddress.IPv6Interface(uncompressed)))
    def testExplodeShortHandIpStr(self):
        addr1 = ipaddress.IPv6Interface("2001::1")
        addr2 = ipaddress.IPv6Address("2001:0:5ef5:79fd:0:59d:a0e5:ba1")
        addr3 = ipaddress.IPv6Network("2001::/96")
        addr4 = ipaddress.IPv4Address("192.168.178.1")
        self.assertEqual("2001:0000:0000:0000:0000:0000:0000:0001/128", addr1.exploded)
        self.assertEqual(
            "0000:0000:0000:0000:0000:0000:0000:0001/128",
            ipaddress.IPv6Interface("::1/128").exploded,
        )
        self.assertEqual("2001:0000:5ef5:79fd:0000:059d:a0e5:0ba1", addr2.exploded)
        self.assertEqual("2001:0000:0000:0000:0000:0000:0000:0000/96", addr3.exploded)
        self.assertEqual("192.168.178.1", addr4.exploded)
    def testReversePointer(self):
        addr1 = ipaddress.IPv4Address("127.0.0.1")
        addr2 = ipaddress.IPv6Address("2001:db8::1")
        self.assertEqual("1.0.0.127.in-addr.arpa", addr1.reverse_pointer)
        self.assertEqual(
            "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8."
            + "b.d.0.1.0.0.2.ip6.arpa",
            addr2.reverse_pointer,
        )
    def testIntRepresentation(self):
        self.assertEqual(16909060, int(self.ipv4_address))
        self.assertEqual(42540616829182469433547762482097946625, int(self.ipv6_address))
    def testForceVersion(self):
        self.assertEqual(ipaddress.ip_network(1).version, 4)
        self.assertEqual(ipaddress.IPv6Network(1).version, 6)
    def testWithStar(self):
        self.assertEqual(self.ipv4_interface.with_prefixlen, "1.2.3.4/24")
        self.assertEqual(self.ipv4_interface.with_netmask, "1.2.3.4/255.255.255.0")
        self.assertEqual(self.ipv4_interface.with_hostmask, "1.2.3.4/0.0.0.255")
        self.assertEqual(
            self.ipv6_interface.with_prefixlen, "2001:658:22a:cafe:200::1/64"
        )
        self.assertEqual(
            self.ipv6_interface.with_netmask,
            "2001:658:22a:cafe:200::1/ffff:ffff:ffff:ffff::",
        )
        self.assertEqual(
            self.ipv6_interface.with_hostmask,
            "2001:658:22a:cafe:200::1/::ffff:ffff:ffff:ffff",
        )
    def testNetworkElementCaching(self):
        self.assertNotIn("broadcast_address", self.ipv4_network._cache)
        self.assertNotIn("hostmask", self.ipv4_network._cache)
        self.assertEqual(
            self.ipv4_network.broadcast_address, ipaddress.IPv4Address("1.2.3.255")
        )
        self.assertEqual(self.ipv4_network.hostmask, ipaddress.IPv4Address("0.0.0.255"))
        self.assertIn("broadcast_address", self.ipv4_network._cache)
        self.assertIn("hostmask", self.ipv4_network._cache)
        self.assertNotIn("broadcast_address", self.ipv6_network._cache)
        self.assertNotIn("hostmask", self.ipv6_network._cache)
        self.assertEqual(
            self.ipv6_network.network_address,
            ipaddress.IPv6Address("2001:658:22a:cafe::"),
        )
        self.assertEqual(
            self.ipv6_interface.network.network_address,
            ipaddress.IPv6Address("2001:658:22a:cafe::"),
        )
        self.assertEqual(
            self.ipv6_network.broadcast_address,
            ipaddress.IPv6Address("2001:658:22a:cafe:ffff:ffff:ffff:ffff"),
        )
        self.assertEqual(
            self.ipv6_network.hostmask, ipaddress.IPv6Address("::ffff:ffff:ffff:ffff")
        )
        self.assertEqual(
            self.ipv6_interface.network.broadcast_address,
            ipaddress.IPv6Address("2001:658:22a:cafe:ffff:ffff:ffff:ffff"),
        )
        self.assertEqual(
            self.ipv6_interface.network.hostmask,
            ipaddress.IPv6Address("::ffff:ffff:ffff:ffff"),
        )
        self.assertIn("broadcast_address", self.ipv6_network._cache)
        self.assertIn("hostmask", self.ipv6_network._cache)
        self.assertIn("broadcast_address", self.ipv6_interface.network._cache)
        self.assertIn("hostmask", self.ipv6_interface.network._cache)
    def testTeredo(self):
        server = ipaddress.IPv4Address("65.54.227.120")
        client = ipaddress.IPv4Address("192.0.2.45")
        teredo_addr = "2001:0000:4136:e378:8000:63bf:3fff:fdd2"
        self.assertEqual((server, client), ipaddress.ip_address(teredo_addr).teredo)
        bad_addr = "2000::4136:e378:8000:63bf:3fff:fdd2"
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
        bad_addr = "2001:0001:4136:e378:8000:63bf:3fff:fdd2"
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
        teredo_addr = ipaddress.IPv6Address("2001:0:5ef5:79fd:0:59d:a0e5:ba1")
        self.assertEqual(
            (
                ipaddress.IPv4Address("94.245.121.253"),
                ipaddress.IPv4Address("95.26.244.94"),
            ),
            teredo_addr.teredo,
        )
    def testsixtofour(self):
        sixtofouraddr = ipaddress.ip_address("2002:ac1d:2d64::1")
        bad_addr = ipaddress.ip_address("2000:ac1d:2d64::1")
        self.assertEqual(
            ipaddress.IPv4Address("172.29.45.100"), sixtofouraddr.sixtofour
        )
        self.assertFalse(bad_addr.sixtofour)
    def testV4HashIsNotConstant(self):
        ipv4_address1 = ipaddress.IPv4Interface("1.2.3.4")
        ipv4_address2 = ipaddress.IPv4Interface("2.3.4.5")
        self.assertNotEqual(ipv4_address1.__hash__(), ipv4_address2.__hash__())
    def testV6HashIsNotConstant(self):
        ipv6_address1 = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1")
        ipv6_address2 = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:2")
        self.assertNotEqual(ipv6_address1.__hash__(), ipv6_address2.__hash__())
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
