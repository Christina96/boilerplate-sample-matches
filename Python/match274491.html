<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_state.py &amp; test_ipaddress.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_state.py &amp; test_ipaddress.py
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_state.py (3.2994924%)<th>test_ipaddress.py (0.46906006%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(317-363)<td><a href="#" name="0">(959-965)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(479-485)<td><a href="#" name="1">(1104-1109)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import textwrap
4 import threading
5 import time
6 import pytest
7 import salt.loader
8 import salt.utils.atomicfile
9 import salt.utils.files
10 import salt.utils.path
11 import salt.utils.platform
12 import salt.utils.stringutils
13 log = logging.getLogger(__name__)
14 pytestmark = [
15     pytest.mark.windows_whitelisted,
16 ]
17 def test_show_highstate(state, state_testfile_dest_path):
18     high = state.show_highstate()
19     assert isinstance(high, dict)
20     assert str(state_testfile_dest_path) in high
21     assert high[str(state_testfile_dest_path)]["__env__"] == "base"
22 def test_show_lowstate(state):
23     low = state.show_lowstate()
24     assert isinstance(low, list)
25     for entry in low:
26         assert isinstance(entry, dict)
27 def test_show_states(state):
28     states = state.show_states()
29     assert isinstance(states, list)
30     for entry in states:
31         assert isinstance(entry, str)
32     assert states == ["core"]
33 def test_show_states_missing_sls(state, state_tree):
34     top_sls_contents = """
35     base:
36       '*':
37         - core
38         - does-not-exist
39     state.show_sls used to catch a recursive ref
40     with pytest.helpers.temp_file("recurse-fail.sls", sls_contents, state_tree):
41         ret = state.sls("recurse-fail")
42         assert ret.failed
43         assert (
44             'A recursive requisite was found, SLS "recurse-fail" ID "/etc/mysql/my.cnf" ID "mysql"'
45             in ret.errors
46         )
47 RECURSE_SLS_ONE = """
48 snmpd:
49   pkg:
50     - installed
51   service:
52     - running
53     - require:
54       - pkg: snmpd
55     - watch:
56       - file: /etc/snmp/snmpd.conf
57 /etc/snmp/snmpd.conf:
58   file:
59     - managed
60     - source: salt://snmpd/snmpd.conf.jinja
61     - template: jinja
62     - user: root
63     - group: root
64     - mode: "0600"
65     - require:
66       - pkg: snmpd
67 @pytest.mark.parametrize(
68     "sls_contents, expected_in_output",
69     [(RECURSE_SLS_ONE, "snmpd"), (RECURSE_SLS_TWO, "/etc/nagios/nrpe.cfg")],
70     ids=("recurse-scenario-1", "recurse-scenario-2"),
71 )
72 def test_no_recurse(state, state_tree, sls_contents, expected_in_output):
73     with pytest.helpers.temp_file("recurse-ok.sls", sls_contents, state_tree):
74         ret = state.show_sls("recurse-ok")
75         assert expected_in_output in ret
76 def test_running_dictionary_consistency(state):
77     running_dict_fields = {
78         "__id__",
79         "__run_num__",
80         "__sls__",
81         "changes",
82         "comment",
83         "duration",
84         "name",
85         "result",
86         "start_time",
87     }
88     sls = state.single("test.succeed_without_changes", name="gndn")
89     ret_values_set = set(sls.full_return.keys())
90     assert running_dict_fields.issubset(ret_values_set)
91 def test_running_dictionary_key_sls(state, state_tree):
92     sls1 = state.single("test.succeed_with_changes", name="gndn")
93     assert "__sls__" in sls1.full_return
94     assert sls1.full_return["__sls__"] is None
95     sls_contents = """
96     gndn:
97       test.succeed_with_changes
98         sls_key = "cmd_|-count_root_dir_contents_|-ls -a / | wc -l_|-run"
99     else:
100         sls_contents = r"""
101         count_root_dir_contents:
102           cmd.run:
103             - name: 'Get-ChildItem C:\ | Measure-Object | %{$_.Count}'
104             - shell: powershell
105     verify sending a state request to the minion(s)
106     verify checking a state request sent to the minion(s)
107     verify clearing a state request sent to the minion(s)
108     verify running a state request sent to the minion(s)
109     verify not running a state request sent to the minion(s)
110     verify that we catch the following syntax error::
111         /tmp/salttest/issue-1876:
112           file:
113             - managed
114             - source: salt://testfile
115           file.append:
116             - text: foo
117         testfile
118     )
119     with pytest.helpers.temp_file("issue-1876.sls", sls_contents, state_tree):
120         ret = state.sls("issue-1876")
121         assert ret.failed
122         errmsg = (
123             "ID '{}' in SLS 'issue-1876' contains multiple state declarations of the"
124             " same type".format(testfile)
125         )
126         assert errmsg in ret.errors
127 def test_issue_1879_too_simple_contains_check(state, state_tree, tmp_path):
128     testfile <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= tmp_path / "issue-1979.txt"
129     init_sls_contents = """
130     {}:
131       file:
132         - touch
133         testfile
134     )
135     step2_sls_contents = """
136     {}:
137       file.append:
138         - text: |
139             if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
140                 . /etc/bash_completion
141             fi
142         if [ -z "$debian_chroot" ] &amp;&amp; [ -r /etc/debian_chroot ]; then
143             debian_chroot=$(cat /etc/debian_chroot)
144         fi
145         if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
146             . /etc/bash_completion
147         fi
148         """
149     issue_1879_dir =</b></font> state_tree / "issue-1879"
150     with pytest.helpers.temp_file(
151         "init.sls", init_sls_contents, issue_1879_dir
152     ), pytest.helpers.temp_file(
153         "step-1.sls", step1_sls_contents, issue_1879_dir
154     ), pytest.helpers.temp_file(
155         "step-2.sls", step2_sls_contents, issue_1879_dir
156     ):
157         ret = state.sls("issue-1879")
158         for staterun in ret:
159             assert staterun.result is True
160         ret = state.sls("issue-1879.step-1")
161         for staterun in ret:
162             assert staterun.result is True
163         ret = state.sls("issue-1879.step-2")
164         for staterun in ret:
165             assert staterun.result is True
166         contents = testfile.read_text()
167         assert contents == expected
168         ret = state.sls("issue-1879.step-1")
169         for staterun in ret:
170             assert staterun.result is True
171         ret = state.sls("issue-1879.step-2")
172         for staterun in ret:
173             assert staterun.result is True
174         contents = testfile.read_text()
175         assert contents == expected
176 def test_include(state, state_tree, tmp_path):
177     testfile_path = tmp_path / "testfile"
178     testfile_path.write_text("foo")
179     include_test_path = tmp_path / "include-test.txt"
180     to_include_test_path = tmp_path / "to-include-test.txt"
181     exclude_test_path = tmp_path / "exclude-test.txt"
182     to_include_sls_contents = """
183     {}:
184       file.managed:
185         - source: salt://testfile
186     """.format(
187         to_include_test_path
188     )
189     include_sls_contents = """
190     include:
191       - to-include-test
192     {}:
193       file.managed:
194         - source: salt://testfile
195     """.format(
196         include_test_path
197     )
198     with pytest.helpers.temp_file(
199         "testfile", "foo", state_tree
200     ), pytest.helpers.temp_file(
201         "to-include-test.sls", to_include_sls_contents, state_tree
202     ), pytest.helpers.temp_file(
203         "include-test.sls", include_sls_contents, state_tree
204     ):
205         ret = state.sls("include-test")
206         for staterun in ret:
207             assert staterun.result is True
208     assert include_test_path.exists()
209     assert to_include_test_path.exists()
210     assert exclude_test_path.exists() is False
211 def test_exclude(state, state_tree, tmp_path):
212     testfile_path = tmp_path / "testfile"
213     testfile_path.write_text("foo")
214     include_test_path = tmp_path / "include-test.txt"
215     to_include_test_path = tmp_path / "to-include-test.txt"
216     exclude_test_path = tmp_path / "exclude-test.txt"
217     to_include_sls_contents = """
218     {}:
219       file.managed:
220         - source: salt://testfile
221     """.format(
222         to_include_test_path
223     )
224     include_sls_contents = """
225     include:
226       - to-include-test
227     {}:
228       file.managed:
229         - source: salt://testfile
230     """.format(
231         include_test_path
232     )
233     exclude_sls_contents = """
234     exclude:
235       - to-include-test
236     include:
237       - include-test
238     {}:
239       file.managed:
240         - source: salt://testfile
241         exclude_test_path
242     )
243     with pytest<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.helpers.temp_file(
244         "testfile", "foo", state_tree
245     ), pytest.helpers.temp_file(
246         "to-include-test.sls", to_include_sls_contents, state_tree
247     ), pytest.helpers.temp_file(
248         "include-test.sls", include_sls_contents, state_tree
249     ), pytest.helpers.temp_file(</b></font>
250         "exclude-test.sls", exclude_sls_contents, state_tree
251     ):
252         ret = state.sls("exclude-test")
253         for staterun in ret:
254             assert staterun.result is True
255     assert include_test_path.exists()
256     assert exclude_test_path.exists()
257     assert to_include_test_path.exists() is False
258 def test_issue_2068_template_str(state, state_tree):
259     template_str_no_dot_sls_contents = """
260     required_state:
261       test:
262         - succeed_without_changes
263     requiring_state:
264       test:
265         - succeed_without_changes
266         - require:
267           - test: required_state
268     """
269     template_str_sls_contents = """
270     required_state: test.succeed_without_changes
271     requiring_state:
272       test.succeed_without_changes:
273         - require:
274           - test: required_state
275     """
276     with pytest.helpers.temp_file(
277         "issue-2068-no-dot.sls", template_str_no_dot_sls_contents, state_tree
278     ) as template_str_no_dot_path, pytest.helpers.temp_file(
279         "issue-2068.sls", template_str_sls_contents, state_tree
280     ) as template_str_path:
281         ret = state.sls("issue-2068-no-dot")
282         for staterun in ret:
283             assert staterun.result is True
284         template_str_no_dot_contents = template_str_no_dot_path.read_text()
285         ret = state.template_str(template_str_no_dot_contents)
286         for staterun in ret:
287             assert staterun.result is True
288         ret = state.template(str(template_str_no_dot_path))
289         for staterun in ret:
290             assert staterun.result is True
291         ret = state.sls("issue-2068")
292         for staterun in ret:
293             assert staterun.result is True
294         template_str_contents = template_str_path.read_text()
295         ret = state.template_str(template_str_contents)
296         for staterun in ret:
297             assert staterun.result is True
298         ret = state.template(str(template_str_path))
299         for staterun in ret:
300             assert staterun.result is True
301 @pytest.mark.parametrize("item", ("include", "exclude", "extends"))
302 def test_template_str_invalid_items(state, item):
303     TEMPLATE = textwrap.dedent(
304         """\
305         {}:
306           - existing-state
307         /tmp/test-template-invalid-items:
308           file:
309             - managed
310             - source: salt://testfile
311         """.format(
312             item
313         )
314     )
315     ret = state.template_str(TEMPLATE.format(item))
316     assert ret.failed
317     errmsg = (
318         "The '{}' declaration found on '&lt;template-str&gt;' is invalid when "
319         "rendering single templates".format(item)
320     )
321     assert errmsg in ret.errors
322 @pytest.mark.skip_on_windows(
323     reason=(
324         "Functional testing this on windows raises unicode errors. "
325         "Tested in tests/pytests/integration/modules/state/test_state.py"
326     )
327 )
328 def test_pydsl(state, state_tree, tmp_path):
329     """
330     Test the basics of the pydsl
331     """
332     testfile = tmp_path / "testfile"
333     sls_contents = """
334     state("{}").file("touch")
335     """.format(
336         testfile
337     )
338     with pytest.helpers.temp_file("pydsl.sls", sls_contents, state_tree):
339         ret = state.sls("pydsl")
340         for staterun in ret:
341             assert staterun.result is True
342         assert testfile.exists()
343 def test_issues_7905_and_8174_sls_syntax_error(state, state_tree):
344     """
345     Call sls file with yaml syntax error.
346     Ensure theses errors are detected and presented to the user without
347     stack traces.
348     """
349     badlist_1_sls_contents = """
350     A:
351       cmd.run:
352         -name: echo foo
353         -foo:
354           - bar
355     """
356     badlist_2_sls_contents = """
357     B:
358       file.exist:
359         - name: /foo/bar/foobar
360     /foo/bar/foobar:
361       file.exist
362     C:
363       /foo/bar/foobar:
364         file.exist
365     """
366     with pytest.helpers.temp_file(
367         "badlist1.sls", badlist_1_sls_contents, state_tree
368     ), pytest.helpers.temp_file("badlist2.sls", badlist_2_sls_contents, state_tree):
369         ret = state.sls("badlist1")
370         assert ret.failed
371         assert ret.errors == ["State 'A' in SLS 'badlist1' is not formed as a list"]
372         ret = state.sls("badlist2")
373         assert ret.failed
374         assert ret.errors == ["State 'C' in SLS 'badlist2' is not formed as a list"]
375 @pytest.mark.slow_test
376 def test_retry_option(state, state_tree):
377     """
378     test the retry option on a simple state with defaults
379     ensure comment is as expected
380     ensure state duration is greater than configured the passed (interval * attempts)
381     """
382     sls_contents = """
383     file_test:
384       file.exists:
385         - name: /path/to/a/non-existent/file.txt
386         - retry:
387             until: True
388             attempts: 3
389             interval: 1
390             splay: 0
391     """
392     expected_comment = (
393         'Attempt 1: Returned a result of "False", with the following '
394         'comment: "Specified path /path/to/a/non-existent/file.txt does not exist"'
395     )
396     with pytest.helpers.temp_file("retry.sls", sls_contents, state_tree):
397         ret = state.sls("retry")
398         for state_return in ret:
399             assert state_return.result is False
400             assert expected_comment in state_return.comment
401             assert state_return.full_return["duration"] &gt;= 3
402 def test_retry_option_success(state, state_tree, tmp_path):
403     """
404     test a state with the retry option that should return True immediately (i.e. no retries)
405     """
406     testfile = tmp_path / "testfile"
407     testfile.touch()
408     sls_contents = """
409     file_test:
410       file.exists:
411         - name: {}
412         - retry:
413             until: True
414             attempts: 5
415             interval: 2
416             splay: 0
417     """.format(
418         testfile
419     )
420     duration = 4
421     if salt.utils.platform.is_windows():
422         duration = 16
423     with pytest.helpers.temp_file("retry.sls", sls_contents, state_tree):
424         ret = state.sls("retry")
425         for state_return in ret:
426             assert state_return.result is True
427             assert state_return.full_return["duration"] &lt; duration
428             assert "Attempt 2" not in state_return.comment
429 @pytest.mark.slow_test
430 def test_retry_option_eventual_success(state, state_tree, tmp_path):
431     """
432     test a state with the retry option that should return True, eventually
433     """
434     testfile1 = tmp_path / "testfile-1"
435     testfile2 = tmp_path / "testfile-2"
436     def create_testfile(testfile1, testfile2):
437         while True:
438             if testfile1.exists():
439                 break
440         time.sleep(2)
441         testfile2.touch()
442     thread = threading.Thread(target=create_testfile, args=(testfile1, testfile2))
443     sls_contents = """
444     file_test_a:
445       file.managed:
446         - name: {}
447         - content: 'a'
448     file_test:
449       file.exists:
450         - name: {}
451         - retry:
452             until: True
453             attempts: 5
454             interval: 2
455             splay: 0
456         - require:
457           - file_test_a
458     """.format(
459         testfile1, testfile2
460     )
461     with pytest.helpers.temp_file("retry.sls", sls_contents, state_tree):
462         thread.start()
463         ret = state.sls("retry")
464         for state_return in ret:
465             assert state_return.result is True
466             assert state_return.full_return["duration"] &gt; 4
467             assert "Attempt 5" not in state_return.comment
468 @pytest.mark.slow_test
469 def test_state_non_base_environment(state, state_tree_prod, tmp_path):
470     """
471     test state.sls with saltenv using a nonbase environment
472     with a salt source
473     """
474     testfile = tmp_path / "testfile"
475     sls_contents = """
476     {}:
477       file.managed:
478         - content: foo
479     """.format(
480         testfile
481     )
482     with pytest.helpers.temp_file("non-base-env.sls", sls_contents, state_tree_prod):
483         ret = state.sls("non-base-env", saltenv="prod")
484         for state_return in ret:
485             assert state_return.result is True
486         assert testfile.exists()
487 @pytest.mark.skip_on_windows(
488     reason="Skipped until parallel states can be fixed on Windows"
489 )
490 def test_parallel_state_with_long_tag(state, state_tree):
491     """
492     This tests the case where the state being executed has a long ID dec or
493     name and states are being run in parallel. The filenames used for the
494     parallel state cache were previously based on the tag for each chunk,
495     and longer ID decs or name params can cause the cache file to be longer
496     than the operating system's max file name length. To counter this we
497     instead generate a SHA1 hash of the chunk's tag to use as the cache
498     filename. This test will ensure that long tags don't cause caching
499     failures.
500     See https://github.com/saltstack/salt/issues/49738 for more info.
501     """
502     short_command = "helloworld"
503     long_command = short_command * 25
504     sls_contents = """
505     test_cmd_short:
506       cmd.run:
507         - name: {}
508         - parallel: True
509     test_cmd_long:
510       cmd.run:
511         - name: {}
512         - parallel: True
513     """.format(
514         short_command, long_command
515     )
516     with pytest.helpers.temp_file("issue-49738.sls", sls_contents, state_tree):
517         ret = state.sls(
518             "issue-49738",
519             __pub_jid="1",  # Because these run in parallel we need a fake JID
520         )
521     comments = sorted(x.comment for x in ret)
522     expected = sorted(
523         'Command "{}" run'.format(x) for x in (short_command, long_command)
524     )
525     assert comments == expected, "{} != {}".format(comments, expected)
526 @pytest.mark.skip_on_darwin(reason="Test is broken on macosx")
527 @pytest.mark.skip_on_windows(
528     reason=(
529         "Functional testing this on windows raises unicode errors. "
530         "Tested in tests/pytests/integration/modules/state/test_state.py"
531     )
532 )
533 def test_state_sls_unicode_characters(state, state_tree):
534     """
535     test state.sls when state file contains non-ascii characters
536     """
537     sls_contents = """
538     echo1:
539       cmd.run:
540         - name: "echo 'This is Æ test!'"
541     """
542     with pytest.helpers.temp_file("issue-46672.sls", sls_contents, state_tree):
543         ret = state.sls("issue-46672")
544         expected = "cmd_|-echo1_|-echo 'This is Æ test!'_|-run"
545         assert expected in ret
546 def test_state_sls_integer_name(state, state_tree):
547     """
548     This tests the case where the state file is named
549     only with integers
550     """
551     sls_contents = """
552     always-passes:
553       test.succeed_without_changes
554     """
555     state_id = "test_|-always-passes_|-always-passes_|-succeed_without_changes"
556     with pytest.helpers.temp_file("12345.sls", sls_contents, state_tree):
557         ret = state.sls("12345")
558         assert state_id in ret
559         for state_return in ret:
560             assert state_return.result is True
561             assert "Success!" in state_return.comment
562         ret = state.sls(mods=12345)
563         assert state_id in ret
564         for state_return in ret:
565             assert state_return.result is True
566             assert "Success!" in state_return.comment
567 def test_state_sls_lazyloader_allows_recursion(state, state_tree):
568     """
569     This tests that referencing dunders like __salt__ work
570     context: https://github.com/saltstack/salt/pull/51499
571     """
572     sls_contents = """
573     {% if 'nonexistent_module.function' in salt %}
574     {% do salt.log.warning("Module is available") %}
575     {% endif %}
576     always-passes:
577       test.succeed_without_changes:
578         - name: foo
579     """
580     state_id = "test_|-always-passes_|-foo_|-succeed_without_changes"
581     with pytest.helpers.temp_file("issue-51499.sls", sls_contents, state_tree):
582         ret = state.sls("issue-51499")
583         assert state_id in ret
584         for state_return in ret:
585             assert state_return.result is True
586             assert "Success!" in state_return.comment
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ipaddress.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import contextlib
2 import functools
3 import operator
4 import pickle
5 import re
6 import sys
7 import weakref
8 import pytest
9 from salt._compat import ipaddress
10 from tests.support.unit import TestCase, skipIf
11 @functools.total_ordering
12 class _LARGEST:
13     """
14     Object that is greater than anything (except itself).
15     """
16     def __eq__(self, other):
17         return isinstance(other, _LARGEST)
18     def __lt__(self, other):
19         return False
20 LARGEST = _LARGEST()
21 @functools.total_ordering
22 class _SMALLEST:
23     """
24     Object that is less than anything (except itself).
25     """
26     def __eq__(self, other):
27         return isinstance(other, _SMALLEST)
28     def __gt__(self, other):
29         return False
30 SMALLEST = _SMALLEST()
31 class BaseTestCase(TestCase):
32     @property
33     def factory(self):
34         raise NotImplementedError
35     @contextlib.contextmanager
36     def assertCleanError(self, exc_type, details, *args):
37         """
38         Ensure exception does not display a context by default
39         Wraps unittest.TestCase.assertRaisesRegex
40         """
41         if args:
42             details = details % args
43         cm = self.assertRaisesRegex(exc_type, details)
44         with cm as exc:
45             yield exc
46         if exc.exception.__context__ is not None:
47             self.assertTrue(exc.exception.__suppress_context__)
48     def assertAddressError(self, details, *args):
49         return self.assertCleanError(ipaddress.AddressValueError, details, *args)
50     def assertNetmaskError(self, details, *args):
51         return self.assertCleanError(ipaddress.NetmaskValueError, details, *args)
52     def assertInstancesEqual(self, lhs, rhs):
53         self.assertEqual(self.factory(lhs), self.factory(rhs))
54 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
55 class CommonTestMixin:
56     def test_empty_address(self):
57         with self.assertAddressError("Address cannot be empty"):
58             self.factory("")
59     def test_floats_rejected(self):
60         with self.assertAddressError(re.escape(repr("1.0"))):
61             self.factory(1.0)
62     def test_not_an_index_issue15559(self):
63         self.assertRaises(TypeError, operator.index, self.factory(1))
64         self.assertRaises(TypeError, hex, self.factory(1))
65         self.assertRaises(TypeError, bytes, self.factory(1))
66     def pickle_test(self, addr):
67         for proto in range(pickle.HIGHEST_PROTOCOL + 1):
68             with self.subTest(proto=proto):
69                 x = self.factory(addr)
70                 y = pickle.loads(pickle.dumps(x, proto))
71                 self.assertEqual(y, x)
72 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
73 class CommonTestMixin_v4(CommonTestMixin):
74     def test_leading_zeros(self):
75         msg = r"Leading zeros are not permitted in '\d+'"
76         addresses = [
77             "000.000.000.000",
78             "192.168.000.001",
79             "016.016.016.016",
80             "192.168.000.001",
81             "001.000.008.016",
82             "01.2.3.40",
83             "1.02.3.40",
84             "1.2.03.40",
85             "1.2.3.040",
86         ]
87         for address in addresses:
88             with self.subTest(address=address):
89                 with self.assertAddressError(msg):
90                     self.factory(address)
91     def test_int(self):
92         self.assertInstancesEqual(0, "0.0.0.0")
93         self.assertInstancesEqual(3232235521, "192.168.0.1")
94     def test_packed(self):
95         self.assertInstancesEqual(bytes.fromhex("00000000"), "0.0.0.0")
96         self.assertInstancesEqual(bytes.fromhex("c0a80001"), "192.168.0.1")
97     def test_negative_ints_rejected(self):
98         msg = "-1 (&lt; 0) is not permitted as an IPv4 address"
99         with self.assertAddressError(re.escape(msg)):
100             self.factory(-1)
101     def test_large_ints_rejected(self):
102         msg = "%d (&gt;= 2**32) is not permitted as an IPv4 address"
103         with self.assertAddressError(re.escape(msg % 2 ** 32)):
104             self.factory(2 ** 32)
105     def test_bad_packed_length(self):
106         def assertBadLength(length):
107             addr = b"\0" * length
108             msg = "%r (len %d != 4) is not permitted as an IPv4 address"
109             with self.assertAddressError(re.escape(msg % (addr, length))):
110                 self.factory(addr)
111         assertBadLength(3)
112         assertBadLength(5)
113 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
114 class CommonTestMixin_v6(CommonTestMixin):
115     def test_leading_zeros(self):
116         self.assertInstancesEqual("0000::0000", "::")
117         self.assertInstancesEqual("000::c0a8:0001", "::c0a8:1")
118     def test_int(self):
119         self.assertInstancesEqual(0, "::")
120         self.assertInstancesEqual(3232235521, "::c0a8:1")
121     def test_packed(self):
122         addr = b"\0" * 12 + bytes.fromhex("00000000")
123         self.assertInstancesEqual(addr, "::")
124         addr = b"\0" * 12 + bytes.fromhex("c0a80001")
125         self.assertInstancesEqual(addr, "::c0a8:1")
126         addr = bytes.fromhex("c0a80001") + b"\0" * 12
127         self.assertInstancesEqual(addr, "c0a8:1::")
128     def test_negative_ints_rejected(self):
129         msg = "-1 (&lt; 0) is not permitted as an IPv6 address"
130         with self.assertAddressError(re.escape(msg)):
131             self.factory(-1)
132     def test_large_ints_rejected(self):
133         msg = "%d (&gt;= 2**128) is not permitted as an IPv6 address"
134         with self.assertAddressError(re.escape(msg % 2 ** 128)):
135             self.factory(2 ** 128)
136     def test_bad_packed_length(self):
137         def assertBadLength(length):
138             addr = b"\0" * length
139             msg = "%r (len %d != 16) is not permitted as an IPv6 address"
140             with self.assertAddressError(re.escape(msg % (addr, length))):
141                 self.factory(addr)
142                 self.factory(addr)
143         assertBadLength(15)
144         assertBadLength(17)
145     def test_blank_scope_id(self):
146         address = "::1%"
147         with self.assertAddressError('Invalid IPv6 address: "%r"', address):
148             self.factory(address)
149     def test_invalid_scope_id_with_percent(self):
150         address = "::1%scope%"
151         with self.assertAddressError('Invalid IPv6 address: "%r"', address):
152             self.factory(address)
153 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
154 class AddressTestCase_v4(BaseTestCase, CommonTestMixin_v4):
155     factory = ipaddress.IPv4Address
156     @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason="Don't run on Py3.5")
157     def test_format(self):
158         v4 = ipaddress.IPv4Address("1.2.3.42")
159         v4_pairs = [
160             ("b", "00000001000000100000001100101010"),
161             ("n", "00000001000000100000001100101010"),
162             ("x", "0102032a"),
163             ("X", "0102032A"),
164             ("_b", "0000_0001_0000_0010_0000_0011_0010_1010"),
165             ("_n", "0000_0001_0000_0010_0000_0011_0010_1010"),
166             ("_x", "0102_032a"),
167             ("_X", "0102_032A"),
168             ("#b", "0b00000001000000100000001100101010"),
169             ("#n", "0b00000001000000100000001100101010"),
170             ("#x", "0x0102032a"),
171             ("#X", "0X0102032A"),
172             ("#_b", "0b0000_0001_0000_0010_0000_0011_0010_1010"),
173             ("#_n", "0b0000_0001_0000_0010_0000_0011_0010_1010"),
174             ("#_x", "0x0102_032a"),
175             ("#_X", "0X0102_032A"),
176             ("s", "1.2.3.42"),
177             ("", "1.2.3.42"),
178         ]
179         for (fmt, txt) in v4_pairs:
180             self.assertEqual(txt, format(v4, fmt))
181     def test_network_passed_as_address(self):
182         addr = "127.0.0.1/24"
183         with self.assertAddressError("Unexpected '/' in %r", addr):
184             ipaddress.IPv4Address(addr)
185     def test_bad_address_split(self):
186         def assertBadSplit(addr):
187             with self.assertAddressError("Expected 4 octets in %r", addr):
188                 ipaddress.IPv4Address(addr)
189         assertBadSplit("127.0.1")
190         assertBadSplit("42.42.42.42.42")
191         assertBadSplit("42.42.42")
192         assertBadSplit("42.42")
193         assertBadSplit("42")
194         assertBadSplit("42..42.42.42")
195         assertBadSplit("42.42.42.42.")
196         assertBadSplit("42.42.42.42...")
197         assertBadSplit(".42.42.42.42")
198         assertBadSplit("...42.42.42.42")
199         assertBadSplit("016.016.016")
200         assertBadSplit("016.016")
201         assertBadSplit("016")
202         assertBadSplit("000")
203         assertBadSplit("0x0a.0x0a.0x0a")
204         assertBadSplit("0x0a.0x0a")
205         assertBadSplit("0x0a")
206         assertBadSplit(".")
207         assertBadSplit("bogus")
208         assertBadSplit("bogus.com")
209         assertBadSplit("1000")
210         assertBadSplit("1000000000000000")
211         assertBadSplit("192.168.0.1.com")
212     def test_empty_octet(self):
213         def assertBadOctet(addr):
214             with self.assertAddressError("Empty octet not permitted in %r", addr):
215                 ipaddress.IPv4Address(addr)
216         assertBadOctet("42..42.42")
217         assertBadOctet("...")
218     def test_invalid_characters(self):
219         def assertBadOctet(addr, octet):
220             msg = "Only decimal digits permitted in {!r} in {!r}".format(octet, addr)
221             with self.assertAddressError(re.escape(msg)):
222                 ipaddress.IPv4Address(addr)
223         assertBadOctet("0x0a.0x0a.0x0a.0x0a", "0x0a")
224         assertBadOctet("0xa.0x0a.0x0a.0x0a", "0xa")
225         assertBadOctet("42.42.42.-0", "-0")
226         assertBadOctet("42.42.42.+0", "+0")
227         assertBadOctet("42.42.42.-42", "-42")
228         assertBadOctet("+1.+2.+3.4", "+1")
229         assertBadOctet("1.2.3.4e0", "4e0")
230         assertBadOctet("1.2.3.4::", "4::")
231         assertBadOctet("1.a.2.3", "a")
232     def test_octet_length(self):
233         def assertBadOctet(addr, octet):
234             msg = "At most 3 characters permitted in %r in %r"
235             with self.assertAddressError(re.escape(msg % (octet, addr))):
236                 ipaddress.IPv4Address(addr)
237         assertBadOctet("0000.000.000.000", "0000")
238         assertBadOctet("12345.67899.-54321.-98765", "12345")
239     def test_octet_limit(self):
240         def assertBadOctet(addr, octet):
241             msg = "Octet %d (&gt; 255) not permitted in %r" % (octet, addr)
242             with self.assertAddressError(re.escape(msg)):
243                 ipaddress.IPv4Address(addr)
244         assertBadOctet("257.0.0.0", 257)
245         assertBadOctet("192.168.0.999", 999)
246     def test_pickle(self):
247         self.pickle_test("192.0.2.1")
248     def test_weakref(self):
249         weakref.ref(self.factory("192.0.2.1"))
250 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
251 class AddressTestCase_v6(BaseTestCase, CommonTestMixin_v6):
252     factory = ipaddress.IPv6Address
253     @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason="Don't run on Py3.5")
254     def test_format(self):
255         v6 = ipaddress.IPv6Address("::1.2.3.42")
256         v6_pairs = [
257             (
258                 "b",
259                 "000000000000000000000000000000000000000000000000000000"
260                 "000000000000000000000000000000000000000000000000010000"
261                 "00100000001100101010",
262             ),
263             ("n", "0000000000000000000000000102032a"),
264             ("x", "0000000000000000000000000102032a"),
265             ("X", "0000000000000000000000000102032A"),
266             (
267                 "_b",
268                 "0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
269                 "_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
270                 "_0000_0000_0000_0000_0001_0000_0010_0000_0011_0010"
271                 "_1010",
272             ),
273             ("_n", "0000_0000_0000_0000_0000_0000_0102_032a"),
274             ("_x", "0000_0000_0000_0000_0000_0000_0102_032a"),
275             ("_X", "0000_0000_0000_0000_0000_0000_0102_032A"),
276             (
277                 "#b",
278                 "0b0000000000000000000000000000000000000000000000000000"
279                 "000000000000000000000000000000000000000000000000000100"
280                 "0000100000001100101010",
281             ),
282             ("#n", "0x0000000000000000000000000102032a"),
283             ("#x", "0x0000000000000000000000000102032a"),
284             ("#X", "0X0000000000000000000000000102032A"),
285             (
286                 "#_b",
287                 "0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
288                 "_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000"
289                 "_0000_0000_0000_0000_0000_0001_0000_0010_0000_0011"
290                 "_0010_1010",
291             ),
292             ("#_n", "0x0000_0000_0000_0000_0000_0000_0102_032a"),
293             ("#_x", "0x0000_0000_0000_0000_0000_0000_0102_032a"),
294             ("#_X", "0X0000_0000_0000_0000_0000_0000_0102_032A"),
295             ("s", "::102:32a"),
296             ("", "::102:32a"),
297         ]
298         for (fmt, txt) in v6_pairs:
299             self.assertEqual(txt, format(v6, fmt))
300     def test_network_passed_as_address(self):
301         def assertBadSplit(addr):
302             msg = "Unexpected '/' in %r"
303             with self.assertAddressError(msg, addr):
304                 ipaddress.IPv6Address(addr)
305         assertBadSplit("::1/24")
306         assertBadSplit("::1%scope_id/24")
307     def test_bad_address_split_v6_not_enough_parts(self):
308         def assertBadSplit(addr):
309             msg = "At least 3 parts expected in %r"
310             with self.assertAddressError(msg, addr.split("%")[0]):
311                 ipaddress.IPv6Address(addr)
312         assertBadSplit(":")
313         assertBadSplit(":1")
314         assertBadSplit("FEDC:9878")
315         assertBadSplit(":%scope")
316         assertBadSplit(":1%scope")
317         assertBadSplit("FEDC:9878%scope")
318     def test_bad_address_split_v6_too_many_colons(self):
319         def assertBadSplit(addr):
320             msg = "At most 8 colons permitted in %r"
321             with self.assertAddressError(msg, addr.split("%")[0]):
322                 ipaddress.IPv6Address(addr)
323         assertBadSplit("9:8:7:6:5:4:3::2:1")
324         assertBadSplit("10:9:8:7:6:5:4:3:2:1")
325         assertBadSplit("::8:7:6:5:4:3:2:1")
326         assertBadSplit("8:7:6:5:4:3:2:1::")
327         assertBadSplit("10:9:8:7:6:5:4:3:42.42.42.42")
328         assertBadSplit("9:8:7:6:5:4:3::2:1%scope")
329         assertBadSplit("10:9:8:7:6:5:4:3:2:1%scope")
330         assertBadSplit("::8:7:6:5:4:3:2:1%scope")
331         assertBadSplit("8:7:6:5:4:3:2:1::%scope")
332         assertBadSplit("10:9:8:7:6:5:4:3:42.42.42.42%scope")
333     def test_bad_address_split_v6_too_many_parts(self):
334         def assertBadSplit(addr):
335             msg = "Exactly 8 parts expected without '::' in %r"
336             with self.assertAddressError(msg, addr.split("%")[0]):
337                 ipaddress.IPv6Address(addr)
338         assertBadSplit("3ffe:0:0:0:0:0:0:0:1")
339         assertBadSplit("9:8:7:6:5:4:3:2:1")
340         assertBadSplit("7:6:5:4:3:2:1")
341         assertBadSplit("9:8:7:6:5:4:3:42.42.42.42")
342         assertBadSplit("7:6:5:4:3:42.42.42.42")
343         assertBadSplit("3ffe:0:0:0:0:0:0:0:1%scope")
344         assertBadSplit("9:8:7:6:5:4:3:2:1%scope")
345         assertBadSplit("7:6:5:4:3:2:1%scope")
346         assertBadSplit("9:8:7:6:5:4:3:42.42.42.42%scope")
347         assertBadSplit("7:6:5:4:3:42.42.42.42%scope")
348     def test_bad_address_split_v6_too_many_parts_with_double_colon(self):
349         def assertBadSplit(addr):
350             msg = "Expected at most 7 other parts with '::' in %r"
351             with self.assertAddressError(msg, addr.split("%")[0]):
352                 ipaddress.IPv6Address(addr)
353         assertBadSplit("1:2:3:4::5:6:7:8")
354         assertBadSplit("1:2:3:4::5:6:7:8%scope")
355     def test_bad_address_split_v6_repeated_double_colon(self):
356         def assertBadSplit(addr):
357             msg = "At most one '::' permitted in %r"
358             with self.assertAddressError(msg, addr.split("%")[0]):
359                 ipaddress.IPv6Address(addr)
360         assertBadSplit("3ffe::1::1")
361         assertBadSplit("1::2::3::4:5")
362         assertBadSplit("2001::db:::1")
363         assertBadSplit("3ffe::1::")
364         assertBadSplit("::3ffe::1")
365         assertBadSplit(":3ffe::1::1")
366         assertBadSplit("3ffe::1::1:")
367         assertBadSplit(":3ffe::1::1:")
368         assertBadSplit(":::")
369         assertBadSplit("2001:db8:::1")
370         assertBadSplit("3ffe::1::1%scope")
371         assertBadSplit("1::2::3::4:5%scope")
372         assertBadSplit("2001::db:::1%scope")
373         assertBadSplit("3ffe::1::%scope")
374         assertBadSplit("::3ffe::1%scope")
375         assertBadSplit(":3ffe::1::1%scope")
376         assertBadSplit("3ffe::1::1:%scope")
377         assertBadSplit(":3ffe::1::1:%scope")
378         assertBadSplit(":::%scope")
379         assertBadSplit("2001:db8:::1%scope")
380     def test_bad_address_split_v6_leading_colon(self):
381         def assertBadSplit(addr):
382             msg = "Leading ':' only permitted as part of '::' in %r"
383             with self.assertAddressError(msg, addr.split("%")[0]):
384                 ipaddress.IPv6Address(addr)
385         assertBadSplit(":2001:db8::1")
386         assertBadSplit(":1:2:3:4:5:6:7")
387         assertBadSplit(":1:2:3:4:5:6:")
388         assertBadSplit(":6:5:4:3:2:1::")
389         assertBadSplit(":2001:db8::1%scope")
390         assertBadSplit(":1:2:3:4:5:6:7%scope")
391         assertBadSplit(":1:2:3:4:5:6:%scope")
392         assertBadSplit(":6:5:4:3:2:1::%scope")
393     def test_bad_address_split_v6_trailing_colon(self):
394         def assertBadSplit(addr):
395             msg = "Trailing ':' only permitted as part of '::' in %r"
396             with self.assertAddressError(msg, addr.split("%")[0]):
397                 ipaddress.IPv6Address(addr)
398         assertBadSplit("2001:db8::1:")
399         assertBadSplit("1:2:3:4:5:6:7:")
400         assertBadSplit("::1.2.3.4:")
401         assertBadSplit("::7:6:5:4:3:2:")
402         assertBadSplit("2001:db8::1:%scope")
403         assertBadSplit("1:2:3:4:5:6:7:%scope")
404         assertBadSplit("::1.2.3.4:%scope")
405         assertBadSplit("::7:6:5:4:3:2:%scope")
406     def test_bad_v4_part_in(self):
407         def assertBadAddressPart(addr, v4_error):
408             with self.assertAddressError("%s in %r", v4_error, addr.split("%")[0]):
409                 ipaddress.IPv6Address(addr)
410         assertBadAddressPart("3ffe::1.net", "Expected 4 octets in '1.net'")
411         assertBadAddressPart("3ffe::127.0.1", "Expected 4 octets in '127.0.1'")
412         assertBadAddressPart("::1.2.3", "Expected 4 octets in '1.2.3'")
413         assertBadAddressPart("::1.2.3.4.5", "Expected 4 octets in '1.2.3.4.5'")
414         assertBadAddressPart(
415             "3ffe::1.1.1.net",
416             "Only decimal digits permitted in 'net' in '1.1.1.net'",
417         )
418         assertBadAddressPart("3ffe::1.net%scope", "Expected 4 octets in '1.net'")
419         assertBadAddressPart("3ffe::127.0.1%scope", "Expected 4 octets in '127.0.1'")
420         assertBadAddressPart("::1.2.3%scope", "Expected 4 octets in '1.2.3'")
421         assertBadAddressPart("::1.2.3.4.5%scope", "Expected 4 octets in '1.2.3.4.5'")
422         assertBadAddressPart(
423             "3ffe::1.1.1.net%scope",
424             "Only decimal digits permitted in 'net' in '1.1.1.net'",
425         )
426     def test_invalid_characters(self):
427         def assertBadPart(addr, part):
428             msg = "Only hex digits permitted in {!r} in {!r}".format(
429                 part, addr.split("%")[0]
430             )
431             with self.assertAddressError(re.escape(msg)):
432                 ipaddress.IPv6Address(addr)
433         assertBadPart("3ffe::goog", "goog")
434         assertBadPart("3ffe::-0", "-0")
435         assertBadPart("3ffe::+0", "+0")
436         assertBadPart("3ffe::-1", "-1")
437         assertBadPart("1.2.3.4::", "1.2.3.4")
438         assertBadPart("1234:axy::b", "axy")
439         assertBadPart("3ffe::goog%scope", "goog")
440         assertBadPart("3ffe::-0%scope", "-0")
441         assertBadPart("3ffe::+0%scope", "+0")
442         assertBadPart("3ffe::-1%scope", "-1")
443         assertBadPart("1.2.3.4::%scope", "1.2.3.4")
444         assertBadPart("1234:axy::b%scope", "axy")
445     def test_part_length(self):
446         def assertBadPart(addr, part):
447             msg = "At most 4 characters permitted in %r in %r"
448             with self.assertAddressError(msg, part, addr.split("%")[0]):
449                 ipaddress.IPv6Address(addr)
450         assertBadPart("::00000", "00000")
451         assertBadPart("3ffe::10000", "10000")
452         assertBadPart("02001:db8::", "02001")
453         assertBadPart("2001:888888::1", "888888")
454         assertBadPart("::00000%scope", "00000")
455         assertBadPart("3ffe::10000%scope", "10000")
456         assertBadPart("02001:db8::%scope", "02001")
457         assertBadPart("2001:888888::1%scope", "888888")
458     def test_pickle(self):
459         self.pickle_test("2001:db8::")
460     def test_weakref(self):
461         weakref.ref(self.factory("2001:db8::"))
462         weakref.ref(self.factory("2001:db8::%scope"))
463 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
464 class NetmaskTestMixin_v4(CommonTestMixin_v4):
465     def test_no_mask(self):
466         for address in ("1.2.3.4", 0x01020304, b"\x01\x02\x03\x04"):
467             net = self.factory(address)
468             self.assertEqual(str(net), "1.2.3.4/32")
469             self.assertEqual(str(net.netmask), "255.255.255.255")
470             self.assertEqual(str(net.hostmask), "0.0.0.0")
471     def test_split_netmask(self):
472         addr = "1.2.3.4/32/24"
473         with self.assertAddressError("Only one '/' permitted in %r" % addr):
474             self.factory(addr)
475     def test_address_errors(self):
476         def assertBadAddress(addr, details):
477             with self.assertAddressError(details):
478                 self.factory(addr)
479         assertBadAddress("/", "Address cannot be empty")
480         assertBadAddress("/8", "Address cannot be empty")
481         assertBadAddress("bogus", "Expected 4 octets")
482         assertBadAddress("google.com", "Expected 4 octets")
483         assertBadAddress("10/8", "Expected 4 octets")
484         assertBadAddress("::1.2.3.4", "Only decimal digits")
485         assertBadAddress("1.2.3.256", re.escape("256 (&gt; 255)"))
486     def test_valid_netmask(self):
487         self.assertEqual(str(self.factory("192.0.2.0/255.255.255.0")), "192.0.2.0/24")
488         for i in range(0, 33):
489             net_str = "0.0.0.0/%d" % i
490             net = self.factory(net_str)
491             self.assertEqual(str(net), net_str)
492             self.assertEqual(str(self.factory("0.0.0.0/%s" % net.netmask)), net_str)
493             self.assertEqual(str(self.factory("0.0.0.0/0%d" % i)), net_str)
494             if i in (32, 0):
495                 net_str = "0.0.0.0/%d" % (32 - i)
496             self.assertEqual(str(self.factory("0.0.0.0/%s" % net.hostmask)), net_str)
497     def test_netmask_errors(self):
498         def assertBadNetmask(addr, netmask):
499             msg = "%r is not a valid netmask" % netmask
500             with self.assertNetmaskError(re.escape(msg)):
501                 self.factory("{}/{}".format(addr, netmask))
502         assertBadNetmask("1.2.3.4", "")
503         assertBadNetmask("1.2.3.4", "-1")
504         assertBadNetmask("1.2.3.4", "+1")
505         assertBadNetmask("1.2.3.4", " 1 ")
506         assertBadNetmask("1.2.3.4", "0x1")
507         assertBadNetmask("1.2.3.4", "33")
508         assertBadNetmask("1.2.3.4", "254.254.255.256")
509         assertBadNetmask("1.2.3.4", "1.a.2.3")
510         assertBadNetmask("1.1.1.1", "254.xyz.2.3")
511         assertBadNetmask("1.1.1.1", "240.255.0.0")
512         assertBadNetmask("1.1.1.1", "255.254.128.0")
513         assertBadNetmask("1.1.1.1", "0.1.127.255")
514         assertBadNetmask("1.1.1.1", "pudding")
515         assertBadNetmask("1.1.1.1", "::")
516     def test_netmask_in_tuple_errors(self):
517         def assertBadNetmask(addr, netmask):
518             msg = "%r is not a valid netmask" % netmask
519             with self.assertNetmaskError(re.escape(msg)):
520                 self.factory((addr, netmask))
521         assertBadNetmask("1.1.1.1", -1)
522         assertBadNetmask("1.1.1.1", 33)
523     def test_pickle(self):
524         self.pickle_test("192.0.2.0/27")
525         self.pickle_test("192.0.2.0/31")  # IPV4LENGTH - 1
526         self.pickle_test("192.0.2.0")  # IPV4LENGTH
527 class InterfaceTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
528     factory = ipaddress.IPv4Interface
529 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
530 class NetworkTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
531     factory = ipaddress.IPv4Network
532     def test_subnet_of(self):
533         self.assertFalse(
534             self.factory("10.0.0.0/30").subnet_of(self.factory("10.0.1.0/24"))
535         )
536         self.assertTrue(
537             self.factory("10.0.0.0/30").subnet_of(self.factory("10.0.0.0/24"))
538         )
539         self.assertFalse(
540             self.factory("10.0.0.0/30").subnet_of(self.factory("10.0.1.0/24"))
541         )
542         self.assertFalse(
543             self.factory("10.0.1.0/24").subnet_of(self.factory("10.0.0.0/30"))
544         )
545     def test_supernet_of(self):
546         self.assertFalse(
547             self.factory("10.0.0.0/30").supernet_of(self.factory("10.0.1.0/24"))
548         )
549         self.assertFalse(
550             self.factory("10.0.0.0/30").supernet_of(self.factory("10.0.0.0/24"))
551         )
552         self.assertFalse(
553             self.factory("10.0.0.0/30").supernet_of(self.factory("10.0.1.0/24"))
554         )
555         self.assertTrue(
556             self.factory("10.0.0.0/24").supernet_of(self.factory("10.0.0.0/30"))
557         )
558     def test_subnet_of_mixed_types(self):
559         with self.assertRaises(TypeError):
560             ipaddress.IPv4Network("10.0.0.0/30").supernet_of(
561                 ipaddress.IPv6Network("::1/128")
562             )
563         with self.assertRaises(TypeError):
564             ipaddress.IPv6Network("::1/128").supernet_of(
565                 ipaddress.IPv4Network("10.0.0.0/30")
566             )
567         with self.assertRaises(TypeError):
568             ipaddress.IPv4Network("10.0.0.0/30").subnet_of(
569                 ipaddress.IPv6Network("::1/128")
570             )
571         with self.assertRaises(TypeError):
572             ipaddress.IPv6Network("::1/128").subnet_of(
573                 ipaddress.IPv4Network("10.0.0.0/30")
574             )
575 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
576 class NetmaskTestMixin_v6(CommonTestMixin_v6):
577     def test_no_mask(self):
578         for address in ("::1", 1, b"\x00" * 15 + b"\x01"):
579             net = self.factory(address)
580             self.assertEqual(str(net), "::1/128")
581             self.assertEqual(
582                 str(net.netmask), "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
583             )
584             self.assertEqual(str(net.hostmask), "::")
585         scoped_net = self.factory("::1%scope")
586         self.assertEqual(str(scoped_net), "::1%scope/128")
587         self.assertEqual(
588             str(scoped_net.netmask), "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
589         )
590         self.assertEqual(str(scoped_net.hostmask), "::")
591     def test_split_netmask(self):
592         addr = "cafe:cafe::/128/190"
593         with self.assertAddressError("Only one '/' permitted in %r" % addr):
594             self.factory(addr)
595         scoped_addr = "cafe:cafe::%scope/128/190"
596         with self.assertAddressError("Only one '/' permitted in %r" % scoped_addr):
597             self.factory(scoped_addr)
598     def test_address_errors(self):
599         def assertBadAddress(addr, details):
600             with self.assertAddressError(details):
601                 self.factory(addr)
602         assertBadAddress("/", "Address cannot be empty")
603         assertBadAddress("/8", "Address cannot be empty")
604         assertBadAddress("google.com", "At least 3 parts")
605         assertBadAddress("1.2.3.4", "At least 3 parts")
606         assertBadAddress("10/8", "At least 3 parts")
607         assertBadAddress("1234:axy::b", "Only hex digits")
608         assertBadAddress("/%scope", "Address cannot be empty")
609         assertBadAddress("/%scope8", "Address cannot be empty")
610         assertBadAddress("google.com%scope", "At least 3 parts")
611         assertBadAddress("1.2.3.4%scope", "At least 3 parts")
612         assertBadAddress("10%scope/8", "At least 3 parts")
613         assertBadAddress("1234:axy::b%scope", "Only hex digits")
614     def test_valid_netmask(self):
615         self.assertEqual(str(self.factory("2001:db8::/32")), "2001:db8::/32")
616         for i in range(0, 129):
617             net_str = "::/%d" % i
618             self.assertEqual(str(self.factory(net_str)), net_str)
619             self.assertEqual(str(self.factory("::/0%d" % i)), net_str)
620         self.assertEqual(
621             str(self.factory("2001:db8::%scope/32")), "2001:db8::%scope/32"
622         )
623         for i in range(0, 129):
624             net_str = "::/%d" % i
625             self.assertEqual(str(self.factory(net_str)), net_str)
626             self.assertEqual(str(self.factory("::/0%d" % i)), net_str)
627     def test_netmask_errors(self):
628         def assertBadNetmask(addr, netmask):
629             msg = "%r is not a valid netmask" % netmask
630             with self.assertNetmaskError(re.escape(msg)):
631                 self.factory("{}/{}".format(addr, netmask))
632         assertBadNetmask("::1", "")
633         assertBadNetmask("::1", "::1")
634         assertBadNetmask("::1", "1::")
635         assertBadNetmask("::1", "-1")
636         assertBadNetmask("::1", "+1")
637         assertBadNetmask("::1", " 1 ")
638         assertBadNetmask("::1", "0x1")
639         assertBadNetmask("::1", "129")
640         assertBadNetmask("::1", "1.2.3.4")
641         assertBadNetmask("::1", "pudding")
642         assertBadNetmask("::", "::")
643         assertBadNetmask("::1%scope", "pudding")
644     def test_netmask_in_tuple_errors(self):
645         def assertBadNetmask(addr, netmask):
646             msg = "%r is not a valid netmask" % netmask
647             with self.assertNetmaskError(re.escape(msg)):
648                 self.factory((addr, netmask))
649         assertBadNetmask("::1", -1)
650         assertBadNetmask("::1", 129)
651         assertBadNetmask("::1%scope", 129)
652     def test_pickle(self):
653         self.pickle_test("2001:db8::1000/124")
654         self.pickle_test("2001:db8::1000/127")  # IPV6LENGTH - 1
655         self.pickle_test("2001:db8::1000")  # IPV6LENGTH
656         self.pickle_test("2001:db8::1000%scope")  # IPV6LENGTH
657 class InterfaceTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
658     factory = ipaddress.IPv6Interface
659 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
660 class NetworkTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
661     factory = ipaddress.IPv6Network
662     def test_subnet_of(self):
663         self.assertFalse(
664             self.factory("2000:999::/56").subnet_of(self.factory("2000:aaa::/48"))
665         )
666         self.assertTrue(
667             self.factory("2000:aaa::/56").subnet_of(self.factory("2000:aaa::/48"))
668         )
669         self.assertFalse(
670             self.factory("2000:bbb::/56").subnet_of(self.factory("2000:aaa::/48"))
671         )
672         self.assertFalse(
673             self.factory("2000:aaa::/48").subnet_of(self.factory("2000:aaa::/56"))
674         )
675         self.assertFalse(
676             self.factory("2000:999::%scope/56").subnet_of(
677                 self.factory("2000:aaa::%scope/48")
678             )
679         )
680         self.assertTrue(
681             self.factory("2000:aaa::%scope/56").subnet_of(
682                 self.factory("2000:aaa::%scope/48")
683             )
684         )
685     def test_supernet_of(self):
686         self.assertFalse(
687             self.factory("2000:999::/56").supernet_of(self.factory("2000:aaa::/48"))
688         )
689         self.assertFalse(
690             self.factory("2000:aaa::/56").supernet_of(self.factory("2000:aaa::/48"))
691         )
692         self.assertFalse(
693             self.factory("2000:bbb::/56").supernet_of(self.factory("2000:aaa::/48"))
694         )
695         self.assertTrue(
696             self.factory("2000:aaa::/48").supernet_of(self.factory("2000:aaa::/56"))
697         )
698 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
699 class FactoryFunctionErrors(BaseTestCase):
700     def assertFactoryError(self, factory, kind):
701         addr = "camelot"
702         msg = "%r does not appear to be an IPv4 or IPv6 %s"
703         with self.assertCleanError(ValueError, msg, addr, kind):
704             factory(addr)
705     def test_ip_address(self):
706         self.assertFactoryError(ipaddress.ip_address, "address")
707     def test_ip_interface(self):
708         self.assertFactoryError(ipaddress.ip_interface, "interface")
709     def test_ip_network(self):
710         self.assertFactoryError(ipaddress.ip_network, "network")
711 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
712 class ComparisonTests(TestCase):
713     v4addr = ipaddress.IPv4Address(1)
714     v4net = ipaddress.IPv4Network(1)
715     v4intf = ipaddress.IPv4Interface(1)
716     v6addr = ipaddress.IPv6Address(1)
717     v6net = ipaddress.IPv6Network(1)
718     v6intf = ipaddress.IPv6Interface(1)
719     v6addr_scoped = ipaddress.IPv6Address("::1%scope")
720     v6net_scoped = ipaddress.IPv6Network("::1%scope")
721     v6intf_scoped = ipaddress.IPv6Interface("::1%scope")
722     v4_addresses = [v4addr, v4intf]
723     v4_objects = v4_addresses + [v4net]
724     v6_addresses = [v6addr, v6intf]
725     v6_objects = v6_addresses + [v6net]
726     v6_scoped_addresses = [v6addr_scoped, v6intf_scoped]
727     objects = v4_objects + v6_objects
728     objects_with_scoped <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= objects + v6_scoped_objects
729     v4addr2 = ipaddress.IPv4Address(2)
730     v4net2 = ipaddress.IPv4Network(2)
731     v4intf2 = ipaddress.IPv4Interface(2)
732     v6addr2 = ipaddress.IPv6Address(2)
733     v6net2 =</b></font> ipaddress.IPv6Network(2)
734     v6intf2 = ipaddress.IPv6Interface(2)
735     v6addr2_scoped = ipaddress.IPv6Address("::2%scope")
736     v6net2_scoped = ipaddress.IPv6Network("::2%scope")
737     v6intf2_scoped = ipaddress.IPv6Interface("::2%scope")
738     def test_foreign_type_equality(self):
739         other = object()
740         for obj in self.objects_with_scoped:
741             self.assertNotEqual(obj, other)
742             self.assertFalse(obj == other)
743             self.assertEqual(obj.__eq__(other), NotImplemented)
744             self.assertEqual(obj.__ne__(other), NotImplemented)
745     def test_mixed_type_equality(self):
746         for lhs in self.objects:
747             for rhs in self.objects:
748                 if lhs is rhs:
749                     continue
750                 self.assertNotEqual(lhs, rhs)
751     def test_scoped_ipv6_equality(self):
752         for lhs, rhs in zip(self.v6_objects, self.v6_scoped_objects):
753             self.assertNotEqual(lhs, rhs)
754     def test_v4_with_v6_scoped_equality(self):
755         for lhs in self.v4_objects:
756             for rhs in self.v6_scoped_objects:
757                 self.assertNotEqual(lhs, rhs)
758     def test_same_type_equality(self):
759         for obj in self.objects_with_scoped:
760             self.assertEqual(obj, obj)
761             self.assertLessEqual(obj, obj)
762             self.assertGreaterEqual(obj, obj)
763     def test_same_type_ordering(self):
764         for lhs, rhs in (
765             (self.v4addr, self.v4addr2),
766             (self.v4net, self.v4net2),
767             (self.v4intf, self.v4intf2),
768             (self.v6addr, self.v6addr2),
769             (self.v6net, self.v6net2),
770             (self.v6intf, self.v6intf2),
771             (self.v6addr_scoped, self.v6addr2_scoped),
772             (self.v6net_scoped, self.v6net2_scoped),
773             (self.v6intf_scoped, self.v6intf2_scoped),
774         ):
775             self.assertNotEqual(lhs, rhs)
776             self.assertLess(lhs, rhs)
777             self.assertLessEqual(lhs, rhs)
778             self.assertGreater(rhs, lhs)
779             self.assertGreaterEqual(rhs, lhs)
780             self.assertFalse(lhs &gt; rhs)
781             self.assertFalse(rhs &lt; lhs)
782             self.assertFalse(lhs &gt;= rhs)
783             self.assertFalse(rhs &lt;= lhs)
784     def test_containment(self):
785         for obj in self.v4_addresses:
786             self.assertIn(obj, self.v4net)
787         for obj in self.v6_addresses + self.v6_scoped_addresses:
788             self.assertIn(obj, self.v6net)
789         for obj in self.v6_addresses + self.v6_scoped_addresses:
790             self.assertIn(obj, self.v6net_scoped)
791         for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
792             self.assertNotIn(obj, self.v6net)
793         for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
794             self.assertNotIn(obj, self.v6net_scoped)
795         for obj in self.v6_objects + self.v6_scoped_objects + [self.v4net]:
796             self.assertNotIn(obj, self.v4net)
797     def test_mixed_type_ordering(self):
798         for lhs in self.objects_with_scoped:
799             for rhs in self.objects_with_scoped:
800                 if isinstance(lhs, type(rhs)) or isinstance(rhs, type(lhs)):
801                     continue
802                 self.assertRaises(TypeError, lambda: lhs &lt; rhs)
803                 self.assertRaises(TypeError, lambda: lhs &gt; rhs)
804                 self.assertRaises(TypeError, lambda: lhs &lt;= rhs)
805                 self.assertRaises(TypeError, lambda: lhs &gt;= rhs)
806     def test_foreign_type_ordering(self):
807         other = object()
808         for obj in self.objects_with_scoped:
809             with self.assertRaises(TypeError):
810                 obj &lt; other
811             with self.assertRaises(TypeError):
812                 obj &gt; other
813             with self.assertRaises(TypeError):
814                 obj &lt;= other
815             with self.assertRaises(TypeError):
816                 obj &gt;= other
817             self.assertTrue(obj &lt; LARGEST)
818             self.assertFalse(obj &gt; LARGEST)
819             self.assertTrue(obj &lt;= LARGEST)
820             self.assertFalse(obj &gt;= LARGEST)
821             self.assertFalse(obj &lt; SMALLEST)
822             self.assertTrue(obj &gt; SMALLEST)
823             self.assertFalse(obj &lt;= SMALLEST)
824             self.assertTrue(obj &gt;= SMALLEST)
825     def test_mixed_type_key(self):
826         v4_ordered = [self.v4addr, self.v4net, self.v4intf]
827         v6_ordered = [self.v6addr, self.v6net, self.v6intf]
828         v6_scoped_ordered = [self.v6addr_scoped, self.v6net_scoped, self.v6intf_scoped]
829         self.assertEqual(
830             v4_ordered, sorted(self.v4_objects, key=ipaddress.get_mixed_type_key)
831         )
832         self.assertEqual(
833             v6_ordered, sorted(self.v6_objects, key=ipaddress.get_mixed_type_key)
834         )
835         self.assertEqual(
836             v6_scoped_ordered,
837             sorted(self.v6_scoped_objects, key=ipaddress.get_mixed_type_key),
838         )
839         self.assertEqual(
840             v4_ordered + v6_scoped_ordered,
841             sorted(
842                 self.v4_objects + self.v6_scoped_objects,
843                 key=ipaddress.get_mixed_type_key,
844             ),
845         )
846         self.assertEqual(NotImplemented, ipaddress.get_mixed_type_key(object))
847     def test_incompatible_versions(self):
848         v4addr = ipaddress.ip_address("1.1.1.1")
849         v4net = ipaddress.ip_network("1.1.1.1")
850         v6addr = ipaddress.ip_address("::1")
851         v6net = ipaddress.ip_network("::1")
852         v6net_scoped = ipaddress.ip_network("::1%scope")
853         self.assertRaises(TypeError, v4addr<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.__lt__, v6addr)
854         self.assertRaises(TypeError, v4addr.__gt__, v6addr)
855         self.assertRaises(TypeError, v4net.__lt__, v6net)
856         self.assertRaises(TypeError, v4net.__gt__, v6net)
857         self.assertRaises(</b></font>TypeError, v6addr.__lt__, v4addr)
858         self.assertRaises(TypeError, v6addr.__gt__, v4addr)
859         self.assertRaises(TypeError, v6net.__lt__, v4net)
860         self.assertRaises(TypeError, v6net.__gt__, v4net)
861         self.assertRaises(TypeError, v4addr.__lt__, v6addr_scoped)
862         self.assertRaises(TypeError, v4addr.__gt__, v6addr_scoped)
863         self.assertRaises(TypeError, v4net.__lt__, v6net_scoped)
864         self.assertRaises(TypeError, v4net.__gt__, v6net_scoped)
865         self.assertRaises(TypeError, v6addr_scoped.__lt__, v4addr)
866         self.assertRaises(TypeError, v6addr_scoped.__gt__, v4addr)
867         self.assertRaises(TypeError, v6net_scoped.__lt__, v4net)
868         self.assertRaises(TypeError, v6net_scoped.__gt__, v4net)
869 @skipIf(sys.version_info &gt;= (3, 9, 5), "We use builtin ipaddress on Python &gt;= 3.9.5")
870 class IpaddrUnitTest(TestCase):
871     def setUp(self):
872         self.ipv4_address = ipaddress.IPv4Address("1.2.3.4")
873         self.ipv4_interface = ipaddress.IPv4Interface("1.2.3.4/24")
874         self.ipv4_network = ipaddress.IPv4Network("1.2.3.0/24")
875         self.ipv6_address = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1")
876         self.ipv6_interface = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1/64")
877         self.ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/64")
878         self.ipv6_scoped_address = ipaddress.IPv6Interface(
879             "2001:658:22a:cafe:200:0:0:1%scope"
880         )
881         self.ipv6_scoped_interface = ipaddress.IPv6Interface(
882             "2001:658:22a:cafe:200:0:0:1%scope/64"
883         )
884         self.ipv6_scoped_network = ipaddress.IPv6Network("2001:658:22a:cafe::%scope/64")
885     def testRepr(self):
886         self.assertEqual(
887             "IPv4Interface('1.2.3.4/32')", repr(ipaddress.IPv4Interface("1.2.3.4"))
888         )
889         self.assertEqual(
890             "IPv6Interface('::1/128')", repr(ipaddress.IPv6Interface("::1"))
891         )
892         self.assertEqual(
893             "IPv6Interface('::1%scope/128')", repr(ipaddress.IPv6Interface("::1%scope"))
894         )
895     def testIPv4Tuple(self):
896         ip = ipaddress.IPv4Address("192.0.2.1")
897         net = ipaddress.IPv4Network("192.0.2.1/32")
898         self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", 32)), net)
899         self.assertEqual(ipaddress.IPv4Network((ip, 32)), net)
900         self.assertEqual(ipaddress.IPv4Network((3221225985, 32)), net)
901         self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", "255.255.255.255")), net)
902         self.assertEqual(ipaddress.IPv4Network((ip, "255.255.255.255")), net)
903         self.assertEqual(ipaddress.IPv4Network((3221225985, "255.255.255.255")), net)
904         with self.assertRaises(ValueError):
905             ipaddress.IPv4Network(("192.0.2.1", 24))
906         with self.assertRaises(ValueError):
907             ipaddress.IPv4Network((ip, 24))
908         with self.assertRaises(ValueError):
909             ipaddress.IPv4Network((3221225985, 24))
910         with self.assertRaises(ValueError):
911             ipaddress.IPv4Network(("192.0.2.1", "255.255.255.0"))
912         with self.assertRaises(ValueError):
913             ipaddress.IPv4Network((ip, "255.255.255.0"))
914         with self.assertRaises(ValueError):
915             ipaddress.IPv4Network((3221225985, "255.255.255.0"))
916         net = ipaddress.IPv4Network("192.0.2.0/24")
917         self.assertEqual(ipaddress.IPv4Network(("192.0.2.1", 24), strict=False), net)
918         self.assertEqual(ipaddress.IPv4Network((ip, 24), strict=False), net)
919         self.assertEqual(ipaddress.IPv4Network((3221225985, 24), strict=False), net)
920         self.assertEqual(
921             ipaddress.IPv4Network(("192.0.2.1", "255.255.255.0"), strict=False), net
922         )
923         self.assertEqual(
924             ipaddress.IPv4Network((ip, "255.255.255.0"), strict=False), net
925         )
926         self.assertEqual(
927             ipaddress.IPv4Network((3221225985, "255.255.255.0"), strict=False), net
928         )
929         ip = ipaddress.IPv4Address("192.0.2.0")
930         net = ipaddress.IPv4Network("192.0.2.0/24")
931         self.assertEqual(ipaddress.IPv4Network(("192.0.2.0", "255.255.255.0")), net)
932         self.assertEqual(ipaddress.IPv4Network((ip, "255.255.255.0")), net)
933         self.assertEqual(ipaddress.IPv4Network((3221225984, "255.255.255.0")), net)
934         self.assertEqual(ipaddress.IPv4Network(("192.0.2.0", 24)), net)
935         self.assertEqual(ipaddress.IPv4Network((ip, 24)), net)
936         self.assertEqual(ipaddress.IPv4Network((3221225984, 24)), net)
937         self.assertEqual(
938             ipaddress.IPv4Interface(("192.0.2.1", 24)),
939             ipaddress.IPv4Interface("192.0.2.1/24"),
940         )
941         self.assertEqual(
942             ipaddress.IPv4Interface((3221225985, 24)),
943             ipaddress.IPv4Interface("192.0.2.1/24"),
944         )
945     def testIPv6Tuple(self):
946         ip = ipaddress.IPv6Address("2001:db8::")
947         net = ipaddress.IPv6Network("2001:db8::/128")
948         self.assertEqual(ipaddress.IPv6Network(("2001:db8::", "128")), net)
949         self.assertEqual(
950             ipaddress.IPv6Network((42540766411282592856903984951653826560, 128)), net
951         )
952         self.assertEqual(ipaddress.IPv6Network((ip, "128")), net)
953         ip = ipaddress.IPv6Address("2001:db8::")
954         net = ipaddress.IPv6Network("2001:db8::/96")
955         self.assertEqual(ipaddress.IPv6Network(("2001:db8::", "96")), net)
956         self.assertEqual(
957             ipaddress.IPv6Network((42540766411282592856903984951653826560, 96)), net
958         )
959         self.assertEqual(ipaddress.IPv6Network((ip, "96")), net)
960         ip_scoped = ipaddress.IPv6Address("2001:db8::%scope")
961         ip = ipaddress.IPv6Address("2001:db8::1")
962         with self.assertRaises(ValueError):
963             ipaddress.IPv6Network(("2001:db8::1", 96))
964         with self.assertRaises(ValueError):
965             ipaddress.IPv6Network((42540766411282592856903984951653826561, 96))
966         with self.assertRaises(ValueError):
967             ipaddress.IPv6Network((ip, 96))
968         net = ipaddress.IPv6Network("2001:db8::/96")
969         self.assertEqual(ipaddress.IPv6Network(("2001:db8::1", 96), strict=False), net)
970         self.assertEqual(
971             ipaddress.IPv6Network(
972                 (42540766411282592856903984951653826561, 96), strict=False
973             ),
974             net,
975         )
976         self.assertEqual(ipaddress.IPv6Network((ip, 96), strict=False), net)
977         self.assertEqual(
978             ipaddress.IPv6Interface(("2001:db8::1", "96")),
979             ipaddress.IPv6Interface("2001:db8::1/96"),
980         )
981         self.assertEqual(
982             ipaddress.IPv6Interface((42540766411282592856903984951653826561, "96")),
983             ipaddress.IPv6Interface("2001:db8::1/96"),
984         )
985         ip_scoped = ipaddress.IPv6Address("2001:db8::1%scope")
986         with self.assertRaises(ValueError):
987             ipaddress.IPv6Network(("2001:db8::1%scope", 96))
988         with self.assertRaises(ValueError):
989             ipaddress.IPv6Network((ip_scoped, 96))
990     def testAddressIntMath(self):
991         self.assertEqual(
992             ipaddress.IPv4Address("1.1.1.1") + 255, ipaddress.IPv4Address("1.1.2.0")
993         )
994         self.assertEqual(
995             ipaddress.IPv4Address("1.1.1.1") - 256, ipaddress.IPv4Address("1.1.0.1")
996         )
997         self.assertEqual(
998             ipaddress.IPv6Address("::1") + (2 ** 16 - 2),
999             ipaddress.IPv6Address("::ffff"),
1000         )
1001         self.assertEqual(
1002             ipaddress.IPv6Address("::ffff") - (2 ** 16 - 2),
1003             ipaddress.IPv6Address("::1"),
1004         )
1005         self.assertNotEqual(
1006             ipaddress.IPv6Address("::1%scope") + (2 ** 16 - 2),
1007             ipaddress.IPv6Address("::ffff%scope"),
1008         )
1009         self.assertNotEqual(
1010             ipaddress.IPv6Address("::ffff%scope") - (2 ** 16 - 2),
1011             ipaddress.IPv6Address("::1%scope"),
1012         )
1013     def testInvalidIntToBytes(self):
1014         self.assertRaises(ValueError, ipaddress.v4_int_to_packed, -1)
1015         self.assertRaises(
1016             ValueError, ipaddress.v4_int_to_packed, 2 ** ipaddress.IPV4LENGTH
1017         )
1018         self.assertRaises(ValueError, ipaddress.v6_int_to_packed, -1)
1019         self.assertRaises(
1020             ValueError, ipaddress.v6_int_to_packed, 2 ** ipaddress.IPV6LENGTH
1021         )
1022     def testInternals(self):
1023         ip1 = ipaddress.IPv4Address("10.10.10.10")
1024         ip2 = ipaddress.IPv4Address("10.10.10.11")
1025         ip3 = ipaddress.IPv4Address("10.10.10.12")
1026         self.assertEqual(list(ipaddress._find_address_range([ip1])), [(ip1, ip1)])
1027         self.assertEqual(
1028             list(ipaddress._find_address_range([ip1, ip3])), [(ip1, ip1), (ip3, ip3)]
1029         )
1030         self.assertEqual(
1031             list(ipaddress._find_address_range([ip1, ip2, ip3])), [(ip1, ip3)]
1032         )
1033         self.assertEqual(128, ipaddress._count_righthand_zero_bits(0, 128))
1034         self.assertEqual("IPv4Network('1.2.3.0/24')", repr(self.ipv4_network))
1035     def testGetNetwork(self):
1036         self.assertEqual(int(self.ipv4_network.network_address), 16909056)
1037         self.assertEqual(str(self.ipv4_network.network_address), "1.2.3.0")
1038         self.assertEqual(
1039             int(self.ipv6_network.network_address),
1040             42540616829182469433403647294022090752,
1041         )
1042         self.assertEqual(str(self.ipv6_network.network_address), "2001:658:22a:cafe::")
1043         self.assertEqual(str(self.ipv6_network.hostmask), "::ffff:ffff:ffff:ffff")
1044         self.assertEqual(
1045             int(self.ipv6_scoped_network.network_address),
1046             42540616829182469433403647294022090752,
1047         )
1048         self.assertEqual(
1049             str(self.ipv6_scoped_network.network_address), "2001:658:22a:cafe::%scope"
1050         )
1051         self.assertEqual(
1052             str(self.ipv6_scoped_network.hostmask), "::ffff:ffff:ffff:ffff"
1053         )
1054     def testIpFromInt(self):
1055         self.assertEqual(self.ipv4_interface._ip, ipaddress.IPv4Interface(16909060)._ip)
1056         ipv4 = ipaddress.ip_network("1.2.3.4")
1057         ipv6 = ipaddress.ip_network("2001:658:22a:cafe:200:0:0:1")
1058         ipv6_scoped = ipaddress.ip_network("2001:658:22a:cafe:200:0:0:1%scope")
1059         self.assertEqual(ipv4, ipaddress.ip_network(int(ipv4.network_address)))
1060         self.assertEqual(ipv6, ipaddress.ip_network(int(ipv6.network_address)))
1061         self.assertNotEqual(
1062             ipv6_scoped, ipaddress.ip_network(int(ipv6_scoped.network_address))
1063         )
1064         v6_int = 42540616829182469433547762482097946625
1065         self.assertEqual(self.ipv6_interface._ip, ipaddress.IPv6Interface(v6_int)._ip)
1066         self.assertEqual(
1067             self.ipv6_scoped_interface._ip, ipaddress.IPv6Interface(v6_int)._ip
1068         )
1069         self.assertEqual(ipaddress.ip_network(self.ipv4_address._ip).version, 4)
1070         self.assertEqual(ipaddress.ip_network(self.ipv6_address._ip).version, 6)
1071         self.assertEqual(ipaddress.ip_network(self.ipv6_scoped_address._ip).version, 6)
1072     def testIpFromPacked(self):
1073         address = ipaddress.ip_address
1074         self.assertEqual(
1075             self.ipv4_interface._ip, ipaddress.ip_interface(b"\x01\x02\x03\x04")._ip
1076         )
1077         self.assertEqual(address("255.254.253.252"), address(b"\xff\xfe\xfd\xfc"))
1078         self.assertEqual(
1079             self.ipv6_interface.ip,
1080             ipaddress.ip_interface(
1081                 b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01"
1082             ).ip,
1083         )
1084         self.assertEqual(
1085             address("ffff:2:3:4:ffff::"),
1086             address(b"\xff\xff\x00\x02\x00\x03\x00\x04" + b"\xff\xff" + b"\x00" * 6),
1087         )
1088         self.assertEqual(address("::"), address(b"\x00" * 16))
1089     def testGetIp(self):
1090         self.assertEqual(int(self.ipv4_interface.ip), 16909060)
1091         self.assertEqual(str(self.ipv4_interface.ip), "1.2.3.4")
1092         self.assertEqual(
1093             int(self.ipv6_interface.ip), 42540616829182469433547762482097946625
1094         )
1095         self.assertEqual(str(self.ipv6_interface.ip), "2001:658:22a:cafe:200::1")
1096         self.assertEqual(
1097             int(self.ipv6_scoped_interface.ip), 42540616829182469433547762482097946625
1098         )
1099         self.assertEqual(str(self.ipv6_scoped_interface.ip), "2001:658:22a:cafe:200::1")
1100     def testGetScopeId(self):
1101         self.assertEqual(self.ipv6_address.scope_id, None)
1102         self.assertEqual(str(self.ipv6_scoped_address.scope_id), "scope")
1103         self.assertEqual(self.ipv6_interface.scope_id, None)
1104         self.assertEqual(str(self.ipv6_scoped_interface.scope_id), "scope")
1105         self.assertEqual(self.ipv6_network.network_address.scope_id, None)
1106         self.assertEqual(
1107             str(self.ipv6_scoped_network.network_address.scope_id), "scope"
1108         )
1109     def testGetNetmask(self):
1110         self.assertEqual(int(self.ipv4_network.netmask), 4294967040)
1111         self.assertEqual(str(self.ipv4_network.netmask), "255.255.255.0")
1112         self.assertEqual(
1113             int(self.ipv6_network.netmask), 340282366920938463444927863358058659840
1114         )
1115         self.assertEqual(self.ipv6_network.prefixlen, 64)
1116         self.assertEqual(
1117             int(self.ipv6_scoped_network.netmask),
1118             340282366920938463444927863358058659840,
1119         )
1120         self.assertEqual(self.ipv6_scoped_network.prefixlen, 64)
1121     def testZeroNetmask(self):
1122         ipv4_zero_netmask = ipaddress.IPv4Interface("1.2.3.4/0")
1123         self.assertEqual(int(ipv4_zero_netmask.network.netmask), 0)
1124         self.assertEqual(ipv4_zero_netmask._prefix_from_prefix_string("0"), 0)
1125         ipv6_zero_netmask = ipaddress.IPv6Interface("::1/0")
1126         self.assertEqual(int(ipv6_zero_netmask.network.netmask), 0)
1127         self.assertEqual(ipv6_zero_netmask._prefix_from_prefix_string("0"), 0)
1128         ipv6_scoped_zero_netmask = ipaddress.IPv6Interface("::1%scope/0")
1129         self.assertEqual(int(ipv6_scoped_zero_netmask.network.netmask), 0)
1130         self.assertEqual(ipv6_scoped_zero_netmask._prefix_from_prefix_string("0"), 0)
1131     def testIPv4Net(self):
1132         net = ipaddress.IPv4Network("127.0.0.0/0.0.0.255")
1133         self.assertEqual(net.prefixlen, 24)
1134     def testGetBroadcast(self):
1135         self.assertEqual(int(self.ipv4_network.broadcast_address), 16909311)
1136         self.assertEqual(str(self.ipv4_network.broadcast_address), "1.2.3.255")
1137         self.assertEqual(
1138             int(self.ipv6_network.broadcast_address),
1139             42540616829182469451850391367731642367,
1140         )
1141         self.assertEqual(
1142             str(self.ipv6_network.broadcast_address),
1143             "2001:658:22a:cafe:ffff:ffff:ffff:ffff",
1144         )
1145         self.assertEqual(
1146             int(self.ipv6_scoped_network.broadcast_address),
1147             42540616829182469451850391367731642367,
1148         )
1149         self.assertEqual(
1150             str(self.ipv6_scoped_network.broadcast_address),
1151             "2001:658:22a:cafe:ffff:ffff:ffff:ffff",
1152         )
1153     def testGetPrefixlen(self):
1154         self.assertEqual(self.ipv4_interface.network.prefixlen, 24)
1155         self.assertEqual(self.ipv6_interface.network.prefixlen, 64)
1156         self.assertEqual(self.ipv6_scoped_interface.network.prefixlen, 64)
1157     def testGetSupernet(self):
1158         self.assertEqual(self.ipv4_network.supernet().prefixlen, 23)
1159         self.assertEqual(str(self.ipv4_network.supernet().network_address), "1.2.2.0")
1160         self.assertEqual(
1161             ipaddress.IPv4Interface("0.0.0.0/0").network.supernet(),
1162             ipaddress.IPv4Network("0.0.0.0/0"),
1163         )
1164         self.assertEqual(self.ipv6_network.supernet().prefixlen, 63)
1165         self.assertEqual(
1166             str(self.ipv6_network.supernet().network_address), "2001:658:22a:cafe::"
1167         )
1168         self.assertEqual(
1169             ipaddress.IPv6Interface("::0/0").network.supernet(),
1170             ipaddress.IPv6Network("::0/0"),
1171         )
1172         self.assertEqual(self.ipv6_scoped_network.supernet().prefixlen, 63)
1173         self.assertEqual(
1174             str(self.ipv6_scoped_network.supernet().network_address),
1175             "2001:658:22a:cafe::",
1176         )
1177     def testGetSupernet3(self):
1178         self.assertEqual(self.ipv4_network.supernet(3).prefixlen, 21)
1179         self.assertEqual(str(self.ipv4_network.supernet(3).network_address), "1.2.0.0")
1180         self.assertEqual(self.ipv6_network.supernet(3).prefixlen, 61)
1181         self.assertEqual(
1182             str(self.ipv6_network.supernet(3).network_address), "2001:658:22a:caf8::"
1183         )
1184         self.assertEqual(self.ipv6_scoped_network.supernet(3).prefixlen, 61)
1185         self.assertEqual(
1186             str(self.ipv6_scoped_network.supernet(3).network_address),
1187             "2001:658:22a:caf8::",
1188         )
1189     def testGetSupernet4(self):
1190         self.assertRaises(
1191             ValueError, self.ipv4_network.supernet, prefixlen_diff=2, new_prefix=1
1192         )
1193         self.assertRaises(ValueError, self.ipv4_network.supernet, new_prefix=25)
1194         self.assertEqual(
1195             self.ipv4_network.supernet(prefixlen_diff=2),
1196             self.ipv4_network.supernet(new_prefix=22),
1197         )
1198         self.assertRaises(
1199             ValueError, self.ipv6_network.supernet, prefixlen_diff=2, new_prefix=1
1200         )
1201         self.assertRaises(ValueError, self.ipv6_network.supernet, new_prefix=65)
1202         self.assertEqual(
1203             self.ipv6_network.supernet(prefixlen_diff=2),
1204             self.ipv6_network.supernet(new_prefix=62),
1205         )
1206         self.assertRaises(
1207             ValueError,
1208             self.ipv6_scoped_network.supernet,
1209             prefixlen_diff=2,
1210             new_prefix=1,
1211         )
1212         self.assertRaises(ValueError, self.ipv6_scoped_network.supernet, new_prefix=65)
1213         self.assertEqual(
1214             self.ipv6_scoped_network.supernet(prefixlen_diff=2),
1215             self.ipv6_scoped_network.supernet(new_prefix=62),
1216         )
1217     def testHosts(self):
1218         hosts = list(self.ipv4_network.hosts())
1219         self.assertEqual(254, len(hosts))
1220         self.assertEqual(ipaddress.IPv4Address("1.2.3.1"), hosts[0])
1221         self.assertEqual(ipaddress.IPv4Address("1.2.3.254"), hosts[-1])
1222         ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/120")
1223         hosts = list(ipv6_network.hosts())
1224         self.assertEqual(255, len(hosts))
1225         self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::1"), hosts[0])
1226         self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::ff"), hosts[-1])
1227         ipv6_scoped_network = ipaddress.IPv6Network("2001:658:22a:cafe::%scope/120")
1228         hosts = list(ipv6_scoped_network.hosts())
1229         self.assertEqual(255, len(hosts))
1230         self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::1"), hosts[0])
1231         self.assertEqual(ipaddress.IPv6Address("2001:658:22a:cafe::ff"), hosts[-1])
1232         addrs = [ipaddress.IPv4Address("2.0.0.0"), ipaddress.IPv4Address("2.0.0.1")]
1233         str_args = "2.0.0.0/31"
1234         tpl_args = ("2.0.0.0", 31)
1235         self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
1236         self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
1237         self.assertEqual(
1238             list(ipaddress.ip_network(str_args).hosts()),
1239             list(ipaddress.ip_network(tpl_args).hosts()),
1240         )
1241         addrs = [ipaddress.IPv4Address("1.2.3.4")]
1242         str_args = "1.2.3.4/32"
1243         tpl_args = ("1.2.3.4", 32)
1244         self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
1245         self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
1246         self.assertEqual(
1247             list(ipaddress.ip_network(str_args).hosts()),
1248             list(ipaddress.ip_network(tpl_args).hosts()),
1249         )
1250         addrs = [
1251             ipaddress.IPv6Address("2001:658:22a:cafe::"),
1252             ipaddress.IPv6Address("2001:658:22a:cafe::1"),
1253         ]
1254         str_args = "2001:658:22a:cafe::/127"
1255         tpl_args = ("2001:658:22a:cafe::", 127)
1256         self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
1257         self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
1258         self.assertEqual(
1259             list(ipaddress.ip_network(str_args).hosts()),
1260             list(ipaddress.ip_network(tpl_args).hosts()),
1261         )
1262         addrs = [
1263             ipaddress.IPv6Address("2001:658:22a:cafe::1"),
1264         ]
1265         str_args = "2001:658:22a:cafe::1/128"
1266         tpl_args = ("2001:658:22a:cafe::1", 128)
1267         self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
1268         self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
1269         self.assertEqual(
1270             list(ipaddress.ip_network(str_args).hosts()),
1271             list(ipaddress.ip_network(tpl_args).hosts()),
1272         )
1273     def testFancySubnetting(self):
1274         self.assertEqual(
1275             sorted(self.ipv4_network.subnets(prefixlen_diff=3)),
1276             sorted(self.ipv4_network.subnets(new_prefix=27)),
1277         )
1278         self.assertRaises(ValueError, list, self.ipv4_network.subnets(new_prefix=23))
1279         self.assertRaises(
1280             ValueError, list, self.ipv4_network.subnets(prefixlen_diff=3, new_prefix=27)
1281         )
1282         self.assertEqual(
1283             sorted(self.ipv6_network.subnets(prefixlen_diff=4)),
1284             sorted(self.ipv6_network.subnets(new_prefix=68)),
1285         )
1286         self.assertRaises(ValueError, list, self.ipv6_network.subnets(new_prefix=63))
1287         self.assertRaises(
1288             ValueError, list, self.ipv6_network.subnets(prefixlen_diff=4, new_prefix=68)
1289         )
1290         self.assertEqual(
1291             sorted(self.ipv6_scoped_network.subnets(prefixlen_diff=4)),
1292             sorted(self.ipv6_scoped_network.subnets(new_prefix=68)),
1293         )
1294         self.assertRaises(
1295             ValueError, list, self.ipv6_scoped_network.subnets(new_prefix=63)
1296         )
1297         self.assertRaises(
1298             ValueError,
1299             list,
1300             self.ipv6_scoped_network.subnets(prefixlen_diff=4, new_prefix=68),
1301         )
1302     def testGetSubnets(self):
1303         self.assertEqual(list(self.ipv4_network.subnets())[0].prefixlen, 25)
1304         self.assertEqual(
1305             str(list(self.ipv4_network.subnets())[0].network_address), "1.2.3.0"
1306         )
1307         self.assertEqual(
1308             str(list(self.ipv4_network.subnets())[1].network_address), "1.2.3.128"
1309         )
1310         self.assertEqual(list(self.ipv6_network.subnets())[0].prefixlen, 65)
1311         self.assertEqual(list(self.ipv6_scoped_network.subnets())[0].prefixlen, 65)
1312     def testGetSubnetForSingle32(self):
1313         ip = ipaddress.IPv4Network("1.2.3.4/32")
1314         subnets1 = [str(x) for x in ip.subnets()]
1315         subnets2 = [str(x) for x in ip.subnets(2)]
1316         self.assertEqual(subnets1, ["1.2.3.4/32"])
1317         self.assertEqual(subnets1, subnets2)
1318     def testGetSubnetForSingle128(self):
1319         ip = ipaddress.IPv6Network("::1/128")
1320         subnets1 = [str(x) for x in ip.subnets()]
1321         subnets2 = [str(x) for x in ip.subnets(2)]
1322         self.assertEqual(subnets1, ["::1/128"])
1323         self.assertEqual(subnets1, subnets2)
1324         ip_scoped = ipaddress.IPv6Network("::1%scope/128")
1325         subnets1 = [str(x) for x in ip_scoped.subnets()]
1326         subnets2 = [str(x) for x in ip_scoped.subnets(2)]
1327         self.assertEqual(subnets1, ["::1%scope/128"])
1328         self.assertEqual(subnets1, subnets2)
1329     def testSubnet2(self):
1330         ips = [str(x) for x in self.ipv4_network.subnets(2)]
1331         self.assertEqual(
1332             ips, ["1.2.3.0/26", "1.2.3.64/26", "1.2.3.128/26", "1.2.3.192/26"]
1333         )
1334         ipsv6 = [str(x) for x in self.ipv6_network.subnets(2)]
1335         self.assertEqual(
1336             ipsv6,
1337             [
1338                 "2001:658:22a:cafe::/66",
1339                 "2001:658:22a:cafe:4000::/66",
1340                 "2001:658:22a:cafe:8000::/66",
1341                 "2001:658:22a:cafe:c000::/66",
1342             ],
1343         )
1344     def testGetSubnets3(self):
1345         subnets = [str(x) for x in self.ipv4_network.subnets(8)]
1346         self.assertEqual(subnets[:3], ["1.2.3.0/32", "1.2.3.1/32", "1.2.3.2/32"])
1347         self.assertEqual(subnets[-3:], ["1.2.3.253/32", "1.2.3.254/32", "1.2.3.255/32"])
1348         self.assertEqual(len(subnets), 256)
1349         ipv6_network = ipaddress.IPv6Network("2001:658:22a:cafe::/120")
1350         subnets = [str(x) for x in ipv6_network.subnets(8)]
1351         self.assertEqual(
1352             subnets[:3],
1353             [
1354                 "2001:658:22a:cafe::/128",
1355                 "2001:658:22a:cafe::1/128",
1356                 "2001:658:22a:cafe::2/128",
1357             ],
1358         )
1359         self.assertEqual(
1360             subnets[-3:],
1361             [
1362                 "2001:658:22a:cafe::fd/128",
1363                 "2001:658:22a:cafe::fe/128",
1364                 "2001:658:22a:cafe::ff/128",
1365             ],
1366         )
1367         self.assertEqual(len(subnets), 256)
1368     def testSubnetFailsForLargeCidrDiff(self):
1369         self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(9))
1370         self.assertRaises(ValueError, list, self.ipv4_network.subnets(9))
1371         self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(65))
1372         self.assertRaises(ValueError, list, self.ipv6_network.subnets(65))
1373         self.assertRaises(
1374             ValueError, list, self.ipv6_scoped_interface.network.subnets(65)
1375         )
1376         self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(65))
1377     def testSupernetFailsForLargeCidrDiff(self):
1378         self.assertRaises(ValueError, self.ipv4_interface.network.supernet, 25)
1379         self.assertRaises(ValueError, self.ipv6_interface.network.supernet, 65)
1380         self.assertRaises(ValueError, self.ipv6_scoped_interface.network.supernet, 65)
1381     def testSubnetFailsForNegativeCidrDiff(self):
1382         self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(-1))
1383         self.assertRaises(ValueError, list, self.ipv4_network.subnets(-1))
1384         self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(-1))
1385         self.assertRaises(ValueError, list, self.ipv6_network.subnets(-1))
1386         self.assertRaises(
1387             ValueError, list, self.ipv6_scoped_interface.network.subnets(-1)
1388         )
1389         self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(-1))
1390     def testGetNum_Addresses(self):
1391         self.assertEqual(self.ipv4_network.num_addresses, 256)
1392         self.assertEqual(list(self.ipv4_network.subnets())[0].num_addresses, 128)
1393         self.assertEqual(self.ipv4_network.supernet().num_addresses, 512)
1394         self.assertEqual(self.ipv6_network.num_addresses, 18446744073709551616)
1395         self.assertEqual(
1396             list(self.ipv6_network.subnets())[0].num_addresses, 9223372036854775808
1397         )
1398         self.assertEqual(
1399             self.ipv6_network.supernet().num_addresses, 36893488147419103232
1400         )
1401         self.assertEqual(self.ipv6_scoped_network.num_addresses, 18446744073709551616)
1402         self.assertEqual(
1403             list(self.ipv6_scoped_network.subnets())[0].num_addresses,
1404             9223372036854775808,
1405         )
1406         self.assertEqual(
1407             self.ipv6_scoped_network.supernet().num_addresses, 36893488147419103232
1408         )
1409     def testContains(self):
1410         self.assertIn(ipaddress.IPv4Interface("1.2.3.128/25"), self.ipv4_network)
1411         self.assertNotIn(ipaddress.IPv4Interface("1.2.4.1/24"), self.ipv4_network)
1412         addr1 = ipaddress.IPv4Address("1.2.3.37")
1413         self.assertIn(addr1, self.ipv4_network)
1414         self.assertFalse(
1415             ipaddress.IPv4Network("1.1.0.0/16").__contains__(
1416                 ipaddress.IPv4Network("1.0.0.0/15")
1417             )
1418         )
1419     def testNth(self):
1420         self.assertEqual(str(self.ipv4_network[5]), "1.2.3.5")
1421         self.assertRaises(IndexError, self.ipv4_network.__getitem__, 256)
1422         self.assertEqual(str(self.ipv6_network[5]), "2001:658:22a:cafe::5")
1423         self.assertRaises(IndexError, self.ipv6_network.__getitem__, 1 &lt;&lt; 64)
1424         self.assertEqual(str(self.ipv6_scoped_network[5]), "2001:658:22a:cafe::5")
1425         self.assertRaises(IndexError, self.ipv6_scoped_network.__getitem__, 1 &lt;&lt; 64)
1426     def testGetitem(self):
1427         addr = ipaddress.IPv4Network("172.31.255.128/255.255.255.240")
1428         self.assertEqual(28, addr.prefixlen)
1429         addr_list = list(addr)
1430         self.assertEqual("172.31.255.128", str(addr_list[0]))
1431         self.assertEqual("172.31.255.128", str(addr[0]))
1432         self.assertEqual("172.31.255.143", str(addr_list[-1]))
1433         self.assertEqual("172.31.255.143", str(addr[-1]))
1434         self.assertEqual(addr_list[-1], addr[-1])
1435     def testEqual(self):
1436         self.assertTrue(self.ipv4_interface == ipaddress.IPv4Interface("1.2.3.4/24"))
1437         self.assertFalse(self.ipv4_interface == ipaddress.IPv4Interface("1.2.3.4/23"))
1438         self.assertFalse(self.ipv4_interface == ipaddress.IPv6Interface("::1.2.3.4/24"))
1439         self.assertFalse(
1440             self.ipv4_interface == ipaddress.IPv6Interface("::1.2.3.4%scope/24")
1441         )
1442         self.assertFalse(self.ipv4_interface == "")
1443         self.assertFalse(self.ipv4_interface == [])
1444         self.assertFalse(self.ipv4_interface == 2)
1445         self.assertTrue(
1446             self.ipv6_interface
1447             == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
1448         )
1449         self.assertFalse(
1450             self.ipv6_interface
1451             == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
1452         )
1453         self.assertFalse(self.ipv6_interface == ipaddress.IPv4Interface("1.2.3.4/23"))
1454         self.assertFalse(self.ipv6_interface == "")
1455         self.assertFalse(self.ipv6_interface == [])
1456         self.assertFalse(self.ipv6_interface == 2)
1457         self.assertTrue(
1458             self.ipv6_scoped_interface
1459             == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/64")
1460         )
1461         self.assertFalse(
1462             self.ipv6_scoped_interface
1463             == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/63")
1464         )
1465         self.assertFalse(
1466             self.ipv6_scoped_interface
1467             == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
1468         )
1469         self.assertFalse(
1470             self.ipv6_scoped_interface
1471             == ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
1472         )
1473         self.assertFalse(
1474             self.ipv6_scoped_interface == ipaddress.IPv4Interface("1.2.3.4/23")
1475         )
1476         self.assertFalse(self.ipv6_scoped_interface == "")
1477         self.assertFalse(self.ipv6_scoped_interface == [])
1478         self.assertFalse(self.ipv6_scoped_interface == 2)
1479     def testNotEqual(self):
1480         self.assertFalse(self.ipv4_interface != ipaddress.IPv4Interface("1.2.3.4/24"))
1481         self.assertTrue(self.ipv4_interface != ipaddress.IPv4Interface("1.2.3.4/23"))
1482         self.assertTrue(self.ipv4_interface != ipaddress.IPv6Interface("::1.2.3.4/24"))
1483         self.assertTrue(
1484             self.ipv4_interface != ipaddress.IPv6Interface("::1.2.3.4%scope/24")
1485         )
1486         self.assertTrue(self.ipv4_interface != "")
1487         self.assertTrue(self.ipv4_interface != [])
1488         self.assertTrue(self.ipv4_interface != 2)
1489         self.assertTrue(self.ipv4_address != ipaddress.IPv4Address("1.2.3.5"))
1490         self.assertTrue(self.ipv4_address != "")
1491         self.assertTrue(self.ipv4_address != [])
1492         self.assertTrue(self.ipv4_address != 2)
1493         self.assertFalse(
1494             self.ipv6_interface
1495             != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
1496         )
1497         self.assertTrue(
1498             self.ipv6_interface
1499             != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
1500         )
1501         self.assertTrue(self.ipv6_interface != ipaddress.IPv4Interface("1.2.3.4/23"))
1502         self.assertTrue(self.ipv6_interface != "")
1503         self.assertTrue(self.ipv6_interface != [])
1504         self.assertTrue(self.ipv6_interface != 2)
1505         self.assertTrue(self.ipv6_address != ipaddress.IPv4Address("1.2.3.4"))
1506         self.assertTrue(self.ipv6_address != "")
1507         self.assertTrue(self.ipv6_address != [])
1508         self.assertTrue(self.ipv6_address != 2)
1509         self.assertFalse(
1510             self.ipv6_scoped_interface
1511             != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/64")
1512         )
1513         self.assertTrue(
1514             self.ipv6_scoped_interface
1515             != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1%scope/63")
1516         )
1517         self.assertTrue(
1518             self.ipv6_scoped_interface
1519             != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/64")
1520         )
1521         self.assertTrue(
1522             self.ipv6_scoped_interface
1523             != ipaddress.IPv6Interface("2001:658:22a:cafe:200::1/63")
1524         )
1525         self.assertTrue(
1526             self.ipv6_scoped_interface != ipaddress.IPv4Interface("1.2.3.4/23")
1527         )
1528         self.assertTrue(self.ipv6_scoped_interface != "")
1529         self.assertTrue(self.ipv6_scoped_interface != [])
1530         self.assertTrue(self.ipv6_scoped_interface != 2)
1531         self.assertTrue(self.ipv6_scoped_address != ipaddress.IPv4Address("1.2.3.4"))
1532         self.assertTrue(self.ipv6_scoped_address != "")
1533         self.assertTrue(self.ipv6_scoped_address != [])
1534         self.assertTrue(self.ipv6_scoped_address != 2)
1535     def testSlash32Constructor(self):
1536         self.assertEqual(
1537             str(ipaddress.IPv4Interface("1.2.3.4/255.255.255.255")), "1.2.3.4/32"
1538         )
1539     def testSlash128Constructor(self):
1540         self.assertEqual(str(ipaddress.IPv6Interface("::1/128")), "::1/128")
1541         self.assertEqual(str(ipaddress.IPv6Interface("::1%scope/128")), "::1%scope/128")
1542     def testSlash0Constructor(self):
1543         self.assertEqual(str(ipaddress.IPv4Interface("1.2.3.4/0.0.0.0")), "1.2.3.4/0")
1544     def testCollapsing(self):
1545         ip1 = ipaddress.IPv4Address("1.1.1.0")
1546         ip2 = ipaddress.IPv4Address("1.1.1.1")
1547         ip3 = ipaddress.IPv4Address("1.1.1.2")
1548         ip4 = ipaddress.IPv4Address("1.1.1.3")
1549         ip5 = ipaddress.IPv4Address("1.1.1.4")
1550         ip6 = ipaddress.IPv4Address("1.1.1.0")
1551         collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
1552         self.assertEqual(
1553             list(collapsed),
1554             [ipaddress.IPv4Network("1.1.1.0/30"), ipaddress.IPv4Network("1.1.1.4/32")],
1555         )
1556         ip1 = ipaddress.IPv4Address("1.1.1.0")
1557         ip2 = ipaddress.IPv4Address("1.1.1.1")
1558         ip3 = ipaddress.IPv4Address("1.1.1.2")
1559         ip4 = ipaddress.IPv4Address("1.1.1.3")
1560         collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4])
1561         self.assertEqual(list(collapsed), [ipaddress.IPv4Network("1.1.1.0/30")])
1562         ip1 = ipaddress.IPv4Network("1.1.0.0/24")
1563         ip2 = ipaddress.IPv4Network("1.1.1.0/24")
1564         ip3 = ipaddress.IPv4Network("1.1.2.0/24")
1565         ip4 = ipaddress.IPv4Network("1.1.3.0/24")
1566         ip5 = ipaddress.IPv4Network("1.1.4.0/24")
1567         ip6 = ipaddress.IPv4Network("1.1.0.0/22")
1568         collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
1569         self.assertEqual(
1570             list(collapsed),
1571             [ipaddress.IPv4Network("1.1.0.0/22"), ipaddress.IPv4Network("1.1.4.0/24")],
1572         )
1573         collapsed = ipaddress.collapse_addresses([ip1, ip2])
1574         self.assertEqual(list(collapsed), [ipaddress.IPv4Network("1.1.0.0/23")])
1575         ip_same1 = ip_same2 = ipaddress.IPv4Network("1.1.1.1/32")
1576         self.assertEqual(
1577             list(ipaddress.collapse_addresses([ip_same1, ip_same2])), [ip_same1]
1578         )
1579         ip_same1 = ip_same2 = ipaddress.IPv4Address("1.1.1.1")
1580         self.assertEqual(
1581             list(ipaddress.collapse_addresses([ip_same1, ip_same2])),
1582             [ipaddress.ip_network("1.1.1.1/32")],
1583         )
1584         ip1 = ipaddress.IPv6Network("2001::/100")
1585         ip2 = ipaddress.IPv6Network("2001::/120")
1586         ip3 = ipaddress.IPv6Network("2001::/96")
1587         collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
1588         self.assertEqual(list(collapsed), [ip3])
1589         ip1 = ipaddress.IPv6Network("2001::%scope/100")
1590         ip2 = ipaddress.IPv6Network("2001::%scope/120")
1591         ip3 = ipaddress.IPv6Network("2001::%scope/96")
1592         collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
1593         self.assertEqual(list(collapsed), [ip3])
1594         addr_tuples = [
1595             (ipaddress.ip_address("1.1.1.1"), ipaddress.ip_address("::1")),
1596             (ipaddress.IPv4Network("1.1.0.0/24"), ipaddress.IPv6Network("2001::/120")),
1597             (ipaddress.IPv4Network("1.1.0.0/32"), ipaddress.IPv6Network("2001::/128")),
1598         ]
1599         for ip1, ip2 in addr_tuples:
1600             self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])
1601         addr_tuples = [
1602             (ipaddress.ip_address("1.1.1.1"), ipaddress.ip_address("::1%scope")),
1603             (
1604                 ipaddress.IPv4Network("1.1.0.0/24"),
1605                 ipaddress.IPv6Network("2001::%scope/120"),
1606             ),
1607             (
1608                 ipaddress.IPv4Network("1.1.0.0/32"),
1609                 ipaddress.IPv6Network("2001::%scope/128"),
1610             ),
1611         ]
1612         for ip1, ip2 in addr_tuples:
1613             self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])
1614     def testSummarizing(self):
1615         summarize = ipaddress.summarize_address_range
1616         ip1 = ipaddress.ip_address("1.1.1.0")
1617         ip2 = ipaddress.ip_address("1.1.1.255")
1618         class IPv7Address(ipaddress.IPv6Address):
1619             @property
1620             def version(self):
1621                 return 7
1622         ip_invalid1 = IPv7Address("::1")
1623         ip_invalid2 = IPv7Address("::1")
1624         self.assertRaises(ValueError, list, summarize(ip_invalid1, ip_invalid2))
1625         self.assertRaises(TypeError, list, summarize(ip1, ipaddress.IPv6Address("::1")))
1626         self.assertRaises(
1627             TypeError, list, summarize(ip1, ipaddress.IPv6Address("::1%scope"))
1628         )
1629         self.assertEqual(
1630             list(summarize(ip1, ip2))[0], ipaddress.ip_network("1.1.1.0/24")
1631         )
1632         ip2 = ipaddress.ip_address("1.1.1.8")
1633         self.assertEqual(
1634             list(summarize(ip1, ip2)),
1635             [ipaddress.ip_network("1.1.1.0/29"), ipaddress.ip_network("1.1.1.8")],
1636         )
1637         ip1 = ipaddress.IPv4Address(0)
1638         ip2 = ipaddress.IPv4Address(ipaddress.IPv4Address._ALL_ONES)
1639         self.assertEqual(
1640             [ipaddress.IPv4Network("0.0.0.0/0")], list(summarize(ip1, ip2))
1641         )
1642         ip1 = ipaddress.ip_address("1::")
1643         ip2 = ipaddress.ip_address("1:ffff:ffff:ffff:ffff:ffff:ffff:ffff")
1644         self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network("1::/16"))
1645         ip2 = ipaddress.ip_address("2::")
1646         self.assertEqual(
1647             list(summarize(ip1, ip2)),
1648             [ipaddress.ip_network("1::/16"), ipaddress.ip_network("2::/128")],
1649         )
1650         ip1 = ipaddress.ip_address("1::%scope")
1651         ip2 = ipaddress.ip_address("1:ffff:ffff:ffff:ffff:ffff:ffff:ffff%scope")
1652         self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network("1::/16"))
1653         ip2 = ipaddress.ip_address("2::%scope")
1654         self.assertEqual(
1655             list(summarize(ip1, ip2)),
1656             [ipaddress.ip_network("1::/16"), ipaddress.ip_network("2::/128")],
1657         )
1658         self.assertRaises(
1659             ValueError,
1660             list,
1661             summarize(ipaddress.ip_address("1.1.1.0"), ipaddress.ip_address("1.1.0.0")),
1662         )
1663         self.assertRaises(
1664             TypeError,
1665             list,
1666             summarize(ipaddress.ip_network("1.1.1.0"), ipaddress.ip_network("1.1.0.0")),
1667         )
1668         self.assertRaises(
1669             TypeError,
1670             list,
1671             summarize(ipaddress.ip_network("1.1.1.0"), ipaddress.ip_network("1.1.0.0")),
1672         )
1673         self.assertRaises(
1674             TypeError,
1675             list,
1676             summarize(ipaddress.ip_address("::"), ipaddress.ip_network("1.1.0.0")),
1677         )
1678     def testAddressComparison(self):
1679         self.assertTrue(
1680             ipaddress.ip_address("1.1.1.1") &lt;= ipaddress.ip_address("1.1.1.1")
1681         )
1682         self.assertTrue(
1683             ipaddress.ip_address("1.1.1.1") &lt;= ipaddress.ip_address("1.1.1.2")
1684         )
1685         self.assertTrue(ipaddress.ip_address("::1") &lt;= ipaddress.ip_address("::1"))
1686         self.assertTrue(ipaddress.ip_address("::1") &lt;= ipaddress.ip_address("::2"))
1687         self.assertTrue(
1688             ipaddress.ip_address("::1%scope") &lt;= ipaddress.ip_address("::1%scope")
1689         )
1690         self.assertTrue(
1691             ipaddress.ip_address("::1%scope") &lt;= ipaddress.ip_address("::2%scope")
1692         )
1693     def testInterfaceComparison(self):
1694         self.assertTrue(
1695             ipaddress.ip_interface("1.1.1.1/24") == ipaddress.ip_interface("1.1.1.1/24")
1696         )
1697         self.assertTrue(
1698             ipaddress.ip_interface("1.1.1.1/16") &lt; ipaddress.ip_interface("1.1.1.1/24")
1699         )
1700         self.assertTrue(
1701             ipaddress.ip_interface("1.1.1.1/24") &lt; ipaddress.ip_interface("1.1.1.2/24")
1702         )
1703         self.assertTrue(
1704             ipaddress.ip_interface("1.1.1.2/16") &lt; ipaddress.ip_interface("1.1.1.1/24")
1705         )
1706         self.assertTrue(
1707             ipaddress.ip_interface("1.1.1.1/24") &gt; ipaddress.ip_interface("1.1.1.1/16")
1708         )
1709         self.assertTrue(
1710             ipaddress.ip_interface("1.1.1.2/24") &gt; ipaddress.ip_interface("1.1.1.1/24")
1711         )
1712         self.assertTrue(
1713             ipaddress.ip_interface("1.1.1.1/24") &gt; ipaddress.ip_interface("1.1.1.2/16")
1714         )
1715         self.assertTrue(
1716             ipaddress.ip_interface("::1/64") == ipaddress.ip_interface("::1/64")
1717         )
1718         self.assertTrue(
1719             ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::1/80")
1720         )
1721         self.assertTrue(
1722             ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::2/64")
1723         )
1724         self.assertTrue(
1725             ipaddress.ip_interface("::2/48") &lt; ipaddress.ip_interface("::1/64")
1726         )
1727         self.assertTrue(
1728             ipaddress.ip_interface("::1/80") &gt; ipaddress.ip_interface("::1/64")
1729         )
1730         self.assertTrue(
1731             ipaddress.ip_interface("::2/64") &gt; ipaddress.ip_interface("::1/64")
1732         )
1733         self.assertTrue(
1734             ipaddress.ip_interface("::1/64") &gt; ipaddress.ip_interface("::2/48")
1735         )
1736         self.assertTrue(
1737             ipaddress.ip_interface("::1%scope/64")
1738             == ipaddress.ip_interface("::1%scope/64")
1739         )
1740         self.assertTrue(
1741             ipaddress.ip_interface("::1%scope/64")
1742             &lt; ipaddress.ip_interface("::1%scope/80")
1743         )
1744         self.assertTrue(
1745             ipaddress.ip_interface("::1%scope/64")
1746             &lt; ipaddress.ip_interface("::2%scope/64")
1747         )
1748         self.assertTrue(
1749             ipaddress.ip_interface("::2%scope/48")
1750             &lt; ipaddress.ip_interface("::1%scope/64")
1751         )
1752         self.assertTrue(
1753             ipaddress.ip_interface("::1%scope/80")
1754             &gt; ipaddress.ip_interface("::1%scope/64")
1755         )
1756         self.assertTrue(
1757             ipaddress.ip_interface("::2%scope/64")
1758             &gt; ipaddress.ip_interface("::1%scope/64")
1759         )
1760         self.assertTrue(
1761             ipaddress.ip_interface("::1%scope/64")
1762             &gt; ipaddress.ip_interface("::2%scope/48")
1763         )
1764         self.assertFalse(
1765             ipaddress.ip_interface("::1%scope/64") == ipaddress.ip_interface("::1/64")
1766         )
1767         self.assertTrue(
1768             ipaddress.ip_interface("::1%scope/64") &lt; ipaddress.ip_interface("::1/80")
1769         )
1770         self.assertTrue(
1771             ipaddress.ip_interface("::1%scope/64") &lt; ipaddress.ip_interface("::2/64")
1772         )
1773         self.assertTrue(
1774             ipaddress.ip_interface("::2%scope/48") &lt; ipaddress.ip_interface("::1/64")
1775         )
1776         self.assertTrue(
1777             ipaddress.ip_interface("::1%scope/80") &gt; ipaddress.ip_interface("::1/64")
1778         )
1779         self.assertTrue(
1780             ipaddress.ip_interface("::2%scope/64") &gt; ipaddress.ip_interface("::1/64")
1781         )
1782         self.assertTrue(
1783             ipaddress.ip_interface("::1%scope/64") &gt; ipaddress.ip_interface("::2/48")
1784         )
1785         self.assertFalse(
1786             ipaddress.ip_interface("::1/64") == ipaddress.ip_interface("::1%scope/64")
1787         )
1788         self.assertTrue(
1789             ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::1%scope/80")
1790         )
1791         self.assertTrue(
1792             ipaddress.ip_interface("::1/64") &lt; ipaddress.ip_interface("::2%scope/64")
1793         )
1794         self.assertTrue(
1795             ipaddress.ip_interface("::2/48") &lt; ipaddress.ip_interface("::1%scope/64")
1796         )
1797         self.assertTrue(
1798             ipaddress.ip_interface("::1/80") &gt; ipaddress.ip_interface("::1%scope/64")
1799         )
1800         self.assertTrue(
1801             ipaddress.ip_interface("::2/64") &gt; ipaddress.ip_interface("::1%scope/64")
1802         )
1803         self.assertTrue(
1804             ipaddress.ip_interface("::1/64") &gt; ipaddress.ip_interface("::2%scope/48")
1805         )
1806     def testNetworkComparison(self):
1807         ip1 = ipaddress.IPv4Network("1.1.1.0/24")
1808         ip2 = ipaddress.IPv4Network("1.1.1.0/32")
1809         ip3 = ipaddress.IPv4Network("1.1.2.0/24")
1810         self.assertTrue(ip1 &lt; ip3)
1811         self.assertTrue(ip3 &gt; ip2)
1812         self.assertEqual(ip1.compare_networks(ip1), 0)
1813         self.assertEqual(ip1.compare_networks(ip2), -1)
1814         self.assertEqual(ip2.compare_networks(ip1), 1)
1815         self.assertEqual(ip1.compare_networks(ip3), -1)
1816         self.assertEqual(ip3.compare_networks(ip1), 1)
1817         self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())
1818         ip1 = ipaddress.IPv6Network("2001:2000::/96")
1819         ip2 = ipaddress.IPv6Network("2001:2001::/96")
1820         ip3 = ipaddress.IPv6Network("2001:ffff:2000::/96")
1821         self.assertTrue(ip1 &lt; ip3)
1822         self.assertTrue(ip3 &gt; ip2)
1823         self.assertEqual(ip1.compare_networks(ip3), -1)
1824         self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())
1825         self.assertRaises(
1826             TypeError, self.ipv4_network.compare_networks, self.ipv6_network
1827         )
1828         ipv6 = ipaddress.IPv6Interface("::/0")
1829         ipv4 = ipaddress.IPv4Interface("0.0.0.0/0")
1830         self.assertRaises(TypeError, ipv4.__lt__, ipv6)
1831         self.assertRaises(TypeError, ipv4.__gt__, ipv6)
1832         self.assertRaises(TypeError, ipv6.__lt__, ipv4)
1833         self.assertRaises(TypeError, ipv6.__gt__, ipv4)
1834         ip1 = ipaddress.ip_network("10.1.2.128/25")
1835         self.assertFalse(ip1 &lt; ip1)
1836         self.assertFalse(ip1 &gt; ip1)
1837         ip2 = ipaddress.ip_network("10.1.3.0/24")
1838         self.assertTrue(ip1 &lt; ip2)
1839         self.assertFalse(ip2 &lt; ip1)
1840         self.assertFalse(ip1 &gt; ip2)
1841         self.assertTrue(ip2 &gt; ip1)
1842         ip3 = ipaddress.ip_network("10.1.3.0/25")
1843         self.assertTrue(ip2 &lt; ip3)
1844         self.assertFalse(ip3 &lt; ip2)
1845         self.assertFalse(ip2 &gt; ip3)
1846         self.assertTrue(ip3 &gt; ip2)
1847         ip1 = ipaddress.ip_network("10.10.10.0/31")
1848         ip2 = ipaddress.ip_network("10.10.10.0")
1849         ip3 = ipaddress.ip_network("10.10.10.2/31")
1850         ip4 = ipaddress.ip_network("10.10.10.2")
1851         sorted = [ip1, ip2, ip3, ip4]
1852         unsorted = [ip2, ip4, ip1, ip3]
1853         unsorted.sort()
1854         self.assertEqual(sorted, unsorted)
1855         unsorted = [ip4, ip1, ip3, ip2]
1856         unsorted.sort()
1857         self.assertEqual(sorted, unsorted)
1858         self.assertIs(ip1.__lt__(ipaddress.ip_address("10.10.10.0")), NotImplemented)
1859         self.assertIs(ip2.__lt__(ipaddress.ip_address("10.10.10.0")), NotImplemented)
1860         self.assertTrue(
1861             ipaddress.ip_network("1.1.1.1") &lt;= ipaddress.ip_network("1.1.1.1")
1862         )
1863         self.assertTrue(
1864             ipaddress.ip_network("1.1.1.1") &lt;= ipaddress.ip_network("1.1.1.2")
1865         )
1866         self.assertFalse(
1867             ipaddress.ip_network("1.1.1.2") &lt;= ipaddress.ip_network("1.1.1.1")
1868         )
1869         self.assertTrue(ipaddress.ip_network("::1") &lt;= ipaddress.ip_network("::1"))
1870         self.assertTrue(ipaddress.ip_network("::1") &lt;= ipaddress.ip_network("::2"))
1871         self.assertFalse(ipaddress.ip_network("::2") &lt;= ipaddress.ip_network("::1"))
1872     def testStrictNetworks(self):
1873         self.assertRaises(ValueError, ipaddress.ip_network, "192.168.1.1/24")
1874         self.assertRaises(ValueError, ipaddress.ip_network, "::1/120")
1875         self.assertRaises(ValueError, ipaddress.ip_network, "::1%scope/120")
1876     def testOverlaps(self):
1877         other = ipaddress.IPv4Network("1.2.3.0/30")
1878         other2 = ipaddress.IPv4Network("1.2.2.0/24")
1879         other3 = ipaddress.IPv4Network("1.2.2.64/26")
1880         self.assertTrue(self.ipv4_network.overlaps(other))
1881         self.assertFalse(self.ipv4_network.overlaps(other2))
1882         self.assertTrue(other2.overlaps(other3))
1883     def testEmbeddedIpv4(self):
1884         ipv4_string = "192.168.0.1"
1885         ipv4 = ipaddress.IPv4Interface(ipv4_string)
1886         v4compat_ipv6 = ipaddress.IPv6Interface("::%s" % ipv4_string)
1887         self.assertEqual(int(v4compat_ipv6.ip), int(ipv4.ip))
1888         v4mapped_ipv6 = ipaddress.IPv6Interface("::ffff:%s" % ipv4_string)
1889         self.assertNotEqual(v4mapped_ipv6.ip, ipv4.ip)
1890         self.assertRaises(
1891             ipaddress.AddressValueError, ipaddress.IPv6Interface, "2001:1.1.1.1:1.1.1.1"
1892         )
1893     def testIPv6AddressTooLarge(self):
1894         self.assertEqual(
1895             ipaddress.ip_address("::FFFF:192.0.2.1"),
1896             ipaddress.ip_address("::FFFF:c000:201"),
1897         )
1898         self.assertEqual(
1899             ipaddress.ip_address("FFFF::192.0.2.1"),
1900             ipaddress.ip_address("FFFF::c000:201"),
1901         )
1902         self.assertEqual(
1903             ipaddress.ip_address("::FFFF:192.0.2.1%scope"),
1904             ipaddress.ip_address("::FFFF:c000:201%scope"),
1905         )
1906         self.assertEqual(
1907             ipaddress.ip_address("FFFF::192.0.2.1%scope"),
1908             ipaddress.ip_address("FFFF::c000:201%scope"),
1909         )
1910         self.assertNotEqual(
1911             ipaddress.ip_address("::FFFF:192.0.2.1%scope"),
1912             ipaddress.ip_address("::FFFF:c000:201"),
1913         )
1914         self.assertNotEqual(
1915             ipaddress.ip_address("FFFF::192.0.2.1%scope"),
1916             ipaddress.ip_address("FFFF::c000:201"),
1917         )
1918         self.assertNotEqual(
1919             ipaddress.ip_address("::FFFF:192.0.2.1"),
1920             ipaddress.ip_address("::FFFF:c000:201%scope"),
1921         )
1922         self.assertNotEqual(
1923             ipaddress.ip_address("FFFF::192.0.2.1"),
1924             ipaddress.ip_address("FFFF::c000:201%scope"),
1925         )
1926     def testIPVersion(self):
1927         self.assertEqual(self.ipv4_address.version, 4)
1928         self.assertEqual(self.ipv6_address.version, 6)
1929         self.assertEqual(self.ipv6_scoped_address.version, 6)
1930     def testMaxPrefixLength(self):
1931         self.assertEqual(self.ipv4_interface.max_prefixlen, 32)
1932         self.assertEqual(self.ipv6_interface.max_prefixlen, 128)
1933         self.assertEqual(self.ipv6_scoped_interface.max_prefixlen, 128)
1934     def testPacked(self):
1935         self.assertEqual(self.ipv4_address.packed, b"\x01\x02\x03\x04")
1936         self.assertEqual(
1937             ipaddress.IPv4Interface("255.254.253.252").packed, b"\xff\xfe\xfd\xfc"
1938         )
1939         self.assertEqual(
1940             self.ipv6_address.packed,
1941             b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01",
1942         )
1943         self.assertEqual(
1944             ipaddress.IPv6Interface("ffff:2:3:4:ffff::").packed,
1945             b"\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff" + b"\x00" * 6,
1946         )
1947         self.assertEqual(
1948             ipaddress.IPv6Interface("::1:0:0:0:0").packed,
1949             b"\x00" * 6 + b"\x00\x01" + b"\x00" * 8,
1950         )
1951         self.assertEqual(
1952             self.ipv6_scoped_address.packed,
1953             b"\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01",
1954         )
1955         self.assertEqual(
1956             ipaddress.IPv6Interface("ffff:2:3:4:ffff::%scope").packed,
1957             b"\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff" + b"\x00" * 6,
1958         )
1959         self.assertEqual(
1960             ipaddress.IPv6Interface("::1:0:0:0:0%scope").packed,
1961             b"\x00" * 6 + b"\x00\x01" + b"\x00" * 8,
1962         )
1963     def testIpType(self):
1964         ipv4net = ipaddress.ip_network("1.2.3.4")
1965         ipv4addr = ipaddress.ip_address("1.2.3.4")
1966         ipv6net = ipaddress.ip_network("::1.2.3.4")
1967         ipv6addr = ipaddress.ip_address("::1.2.3.4")
1968         self.assertEqual(ipaddress.IPv4Network, type(ipv4net))
1969         self.assertEqual(ipaddress.IPv4Address, type(ipv4addr))
1970         self.assertEqual(ipaddress.IPv6Network, type(ipv6net))
1971         self.assertEqual(ipaddress.IPv6Address, type(ipv6addr))
1972     def testReservedIpv4(self):
1973         self.assertEqual(True, ipaddress.ip_interface("224.1.1.1/31").is_multicast)
1974         self.assertEqual(False, ipaddress.ip_network("240.0.0.0").is_multicast)
1975         self.assertEqual(True, ipaddress.ip_network("240.0.0.0").is_reserved)
1976         self.assertEqual(True, ipaddress.ip_interface("192.168.1.1/17").is_private)
1977         self.assertEqual(False, ipaddress.ip_network("192.169.0.0").is_private)
1978         self.assertEqual(True, ipaddress.ip_network("10.255.255.255").is_private)
1979         self.assertEqual(False, ipaddress.ip_network("11.0.0.0").is_private)
1980         self.assertEqual(False, ipaddress.ip_network("11.0.0.0").is_reserved)
1981         self.assertEqual(True, ipaddress.ip_network("172.31.255.255").is_private)
1982         self.assertEqual(False, ipaddress.ip_network("172.32.0.0").is_private)
1983         self.assertEqual(True, ipaddress.ip_network("169.254.1.0/24").is_link_local)
1984         self.assertEqual(
1985             True, ipaddress.ip_interface("169.254.100.200/24").is_link_local
1986         )
1987         self.assertEqual(
1988             False, ipaddress.ip_interface("169.255.100.200/24").is_link_local
1989         )
1990         self.assertEqual(True, ipaddress.ip_network("127.100.200.254/32").is_loopback)
1991         self.assertEqual(True, ipaddress.ip_network("127.42.0.0/16").is_loopback)
1992         self.assertEqual(False, ipaddress.ip_network("128.0.0.0").is_loopback)
1993         self.assertEqual(False, ipaddress.ip_network("100.64.0.0/10").is_private)
1994         self.assertEqual(False, ipaddress.ip_network("100.64.0.0/10").is_global)
1995         self.assertEqual(True, ipaddress.ip_network("192.0.2.128/25").is_private)
1996         self.assertEqual(True, ipaddress.ip_network("192.0.3.0/24").is_global)
1997         self.assertEqual(True, ipaddress.ip_address("0.0.0.0").is_unspecified)
1998         self.assertEqual(True, ipaddress.ip_address("224.1.1.1").is_multicast)
1999         self.assertEqual(False, ipaddress.ip_address("240.0.0.0").is_multicast)
2000         self.assertEqual(True, ipaddress.ip_address("240.0.0.1").is_reserved)
2001         self.assertEqual(False, ipaddress.ip_address("239.255.255.255").is_reserved)
2002         self.assertEqual(True, ipaddress.ip_address("192.168.1.1").is_private)
2003         self.assertEqual(False, ipaddress.ip_address("192.169.0.0").is_private)
2004         self.assertEqual(True, ipaddress.ip_address("10.255.255.255").is_private)
2005         self.assertEqual(False, ipaddress.ip_address("11.0.0.0").is_private)
2006         self.assertEqual(True, ipaddress.ip_address("172.31.255.255").is_private)
2007         self.assertEqual(False, ipaddress.ip_address("172.32.0.0").is_private)
2008         self.assertEqual(True, ipaddress.ip_address("169.254.100.200").is_link_local)
2009         self.assertEqual(False, ipaddress.ip_address("169.255.100.200").is_link_local)
2010         self.assertTrue(ipaddress.ip_address("192.0.7.1").is_global)
2011         self.assertFalse(ipaddress.ip_address("203.0.113.1").is_global)
2012         self.assertEqual(True, ipaddress.ip_address("127.100.200.254").is_loopback)
2013         self.assertEqual(True, ipaddress.ip_address("127.42.0.0").is_loopback)
2014         self.assertEqual(False, ipaddress.ip_address("128.0.0.0").is_loopback)
2015         self.assertEqual(True, ipaddress.ip_network("0.0.0.0").is_unspecified)
2016     def testReservedIpv6(self):
2017         self.assertEqual(True, ipaddress.ip_network("ffff::").is_multicast)
2018         self.assertEqual(True, ipaddress.ip_network(2 ** 128 - 1).is_multicast)
2019         self.assertEqual(True, ipaddress.ip_network("ff00::").is_multicast)
2020         self.assertEqual(False, ipaddress.ip_network("fdff::").is_multicast)
2021         self.assertEqual(True, ipaddress.ip_network("fecf::").is_site_local)
2022         self.assertEqual(
2023             True, ipaddress.ip_network("feff:ffff:ffff:ffff::").is_site_local
2024         )
2025         self.assertEqual(False, ipaddress.ip_network("fbf:ffff::").is_site_local)
2026         self.assertEqual(False, ipaddress.ip_network("ff00::").is_site_local)
2027         self.assertEqual(True, ipaddress.ip_network("fc00::").is_private)
2028         self.assertEqual(True, ipaddress.ip_network("fc00:ffff:ffff:ffff::").is_private)
2029         self.assertEqual(False, ipaddress.ip_network("fbff:ffff::").is_private)
2030         self.assertEqual(False, ipaddress.ip_network("fe00::").is_private)
2031         self.assertEqual(True, ipaddress.ip_network("fea0::").is_link_local)
2032         self.assertEqual(True, ipaddress.ip_network("febf:ffff::").is_link_local)
2033         self.assertEqual(False, ipaddress.ip_network("fe7f:ffff::").is_link_local)
2034         self.assertEqual(False, ipaddress.ip_network("fec0::").is_link_local)
2035         self.assertEqual(True, ipaddress.ip_interface("0:0::0:01").is_loopback)
2036         self.assertEqual(False, ipaddress.ip_interface("::1/127").is_loopback)
2037         self.assertEqual(False, ipaddress.ip_network("::").is_loopback)
2038         self.assertEqual(False, ipaddress.ip_network("::2").is_loopback)
2039         self.assertEqual(True, ipaddress.ip_network("0::0").is_unspecified)
2040         self.assertEqual(False, ipaddress.ip_network("::1").is_unspecified)
2041         self.assertEqual(False, ipaddress.ip_network("::/127").is_unspecified)
2042         self.assertEqual(True, ipaddress.ip_network("2001::1/128").is_private)
2043         self.assertEqual(True, ipaddress.ip_network("200::1/128").is_global)
2044         self.assertEqual(True, ipaddress.ip_address("ffff::").is_multicast)
2045         self.assertEqual(True, ipaddress.ip_address(2 ** 128 - 1).is_multicast)
2046         self.assertEqual(True, ipaddress.ip_address("ff00::").is_multicast)
2047         self.assertEqual(False, ipaddress.ip_address("fdff::").is_multicast)
2048         self.assertEqual(True, ipaddress.ip_address("fecf::").is_site_local)
2049         self.assertEqual(
2050             True, ipaddress.ip_address("feff:ffff:ffff:ffff::").is_site_local
2051         )
2052         self.assertEqual(False, ipaddress.ip_address("fbf:ffff::").is_site_local)
2053         self.assertEqual(False, ipaddress.ip_address("ff00::").is_site_local)
2054         self.assertEqual(True, ipaddress.ip_address("fc00::").is_private)
2055         self.assertEqual(True, ipaddress.ip_address("fc00:ffff:ffff:ffff::").is_private)
2056         self.assertEqual(False, ipaddress.ip_address("fbff:ffff::").is_private)
2057         self.assertEqual(False, ipaddress.ip_address("fe00::").is_private)
2058         self.assertEqual(True, ipaddress.ip_address("fea0::").is_link_local)
2059         self.assertEqual(True, ipaddress.ip_address("febf:ffff::").is_link_local)
2060         self.assertEqual(False, ipaddress.ip_address("fe7f:ffff::").is_link_local)
2061         self.assertEqual(False, ipaddress.ip_address("fec0::").is_link_local)
2062         self.assertEqual(True, ipaddress.ip_address("0:0::0:01").is_loopback)
2063         self.assertEqual(True, ipaddress.ip_address("::1").is_loopback)
2064         self.assertEqual(False, ipaddress.ip_address("::2").is_loopback)
2065         self.assertEqual(True, ipaddress.ip_address("0::0").is_unspecified)
2066         self.assertEqual(False, ipaddress.ip_address("::1").is_unspecified)
2067         self.assertEqual(True, ipaddress.ip_address("100::").is_reserved)
2068         self.assertEqual(True, ipaddress.ip_network("4000::1/128").is_reserved)
2069     def testIpv4Mapped(self):
2070         self.assertEqual(
2071             ipaddress.ip_address("::ffff:192.168.1.1").ipv4_mapped,
2072             ipaddress.ip_address("192.168.1.1"),
2073         )
2074         self.assertEqual(ipaddress.ip_address("::c0a8:101").ipv4_mapped, None)
2075         self.assertEqual(
2076             ipaddress.ip_address("::ffff:c0a8:101").ipv4_mapped,
2077             ipaddress.ip_address("192.168.1.1"),
2078         )
2079     def testAddrExclude(self):
2080         addr1 = ipaddress.ip_network("10.1.1.0/24")
2081         addr2 = ipaddress.ip_network("10.1.1.0/26")
2082         addr3 = ipaddress.ip_network("10.2.1.0/24")
2083         addr4 = ipaddress.ip_address("10.1.1.0")
2084         addr5 = ipaddress.ip_network("2001:db8::0/32")
2085         addr6 = ipaddress.ip_network("10.1.1.5/32")
2086         self.assertEqual(
2087             sorted(list(addr1.address_exclude(addr2))),
2088             [
2089                 ipaddress.ip_network("10.1.1.64/26"),
2090                 ipaddress.ip_network("10.1.1.128/25"),
2091             ],
2092         )
2093         self.assertRaises(ValueError, list, addr1.address_exclude(addr3))
2094         self.assertRaises(TypeError, list, addr1.address_exclude(addr4))
2095         self.assertRaises(TypeError, list, addr1.address_exclude(addr5))
2096         self.assertEqual(list(addr1.address_exclude(addr1)), [])
2097         self.assertEqual(
2098             sorted(list(addr1.address_exclude(addr6))),
2099             [
2100                 ipaddress.ip_network("10.1.1.0/30"),
2101                 ipaddress.ip_network("10.1.1.4/32"),
2102                 ipaddress.ip_network("10.1.1.6/31"),
2103                 ipaddress.ip_network("10.1.1.8/29"),
2104                 ipaddress.ip_network("10.1.1.16/28"),
2105                 ipaddress.ip_network("10.1.1.32/27"),
2106                 ipaddress.ip_network("10.1.1.64/26"),
2107                 ipaddress.ip_network("10.1.1.128/25"),
2108             ],
2109         )
2110     def testHash(self):
2111         self.assertEqual(
2112             hash(ipaddress.ip_interface("10.1.1.0/24")),
2113             hash(ipaddress.ip_interface("10.1.1.0/24")),
2114         )
2115         self.assertEqual(
2116             hash(ipaddress.ip_network("10.1.1.0/24")),
2117             hash(ipaddress.ip_network("10.1.1.0/24")),
2118         )
2119         self.assertEqual(
2120             hash(ipaddress.ip_address("10.1.1.0")),
2121             hash(ipaddress.ip_address("10.1.1.0")),
2122         )
2123         self.assertEqual(
2124             hash(ipaddress.ip_address("1.2.3.4")),
2125             hash(ipaddress.ip_address(int(ipaddress.ip_address("1.2.3.4")._ip))),
2126         )
2127         ip1 = ipaddress.ip_address("10.1.1.0")
2128         ip2 = ipaddress.ip_address("1::")
2129         dummy = {}
2130         dummy[self.ipv4_address] = None
2131         dummy[self.ipv6_address] = None
2132         dummy[ip1] = None
2133         dummy[ip2] = None
2134         self.assertIn(self.ipv4_address, dummy)
2135         self.assertIn(ip2, dummy)
2136     def testIPBases(self):
2137         net = self.ipv4_network
2138         self.assertEqual("1.2.3.0/24", net.compressed)
2139         net = self.ipv6_network
2140         self.assertRaises(ValueError, net._string_from_ip_int, 2 ** 128 + 1)
2141     def testIPv6NetworkHelpers(self):
2142         net = self.ipv6_network
2143         self.assertEqual("2001:658:22a:cafe::/64", net.with_prefixlen)
2144         self.assertEqual("2001:658:22a:cafe::/ffff:ffff:ffff:ffff::", net.with_netmask)
2145         self.assertEqual("2001:658:22a:cafe::/::ffff:ffff:ffff:ffff", net.with_hostmask)
2146         self.assertEqual("2001:658:22a:cafe::/64", str(net))
2147     def testIPv4NetworkHelpers(self):
2148         net = self.ipv4_network
2149         self.assertEqual("1.2.3.0/24", net.with_prefixlen)
2150         self.assertEqual("1.2.3.0/255.255.255.0", net.with_netmask)
2151         self.assertEqual("1.2.3.0/0.0.0.255", net.with_hostmask)
2152         self.assertEqual("1.2.3.0/24", str(net))
2153     def testCopyConstructor(self):
2154         addr1 = ipaddress.ip_network("10.1.1.0/24")
2155         addr2 = ipaddress.ip_network(addr1)
2156         addr3 = ipaddress.ip_interface("2001:658:22a:cafe:200::1/64")
2157         addr4 = ipaddress.ip_interface(addr3)
2158         addr5 = ipaddress.IPv4Address("1.1.1.1")
2159         addr6 = ipaddress.IPv6Address("2001:658:22a:cafe:200::1")
2160         self.assertEqual(addr1, addr2)
2161         self.assertEqual(addr3, addr4)
2162         self.assertEqual(addr5, ipaddress.IPv4Address(addr5))
2163         self.assertEqual(addr6, ipaddress.IPv6Address(addr6))
2164     def testCompressIPv6Address(self):
2165         test_addresses = {
2166             "1:2:3:4:5:6:7:8": "1:2:3:4:5:6:7:8/128",
2167             "2001:0:0:4:0:0:0:8": "2001:0:0:4::8/128",
2168             "2001:0:0:4:5:6:7:8": "2001::4:5:6:7:8/128",
2169             "2001:0:3:4:5:6:7:8": "2001:0:3:4:5:6:7:8/128",
2170             "0:0:3:0:0:0:0:ffff": "0:0:3::ffff/128",
2171             "0:0:0:4:0:0:0:ffff": "::4:0:0:0:ffff/128",
2172             "0:0:0:0:5:0:0:ffff": "::5:0:0:ffff/128",
2173             "1:0:0:4:0:0:7:8": "1::4:0:0:7:8/128",
2174             "0:0:0:0:0:0:0:0": "::/128",
2175             "0:0:0:0:0:0:0:0/0": "::/0",
2176             "0:0:0:0:0:0:0:1": "::1/128",
2177             "2001:0658:022a:cafe:0000:0000:0000:0000/66": "2001:658:22a:cafe::/66",
2178             "::1.2.3.4": "::102:304/128",
2179             "1:2:3:4:5:ffff:1.2.3.4": "1:2:3:4:5:ffff:102:304/128",
2180             "::7:6:5:4:3:2:1": "0:7:6:5:4:3:2:1/128",
2181             "::7:6:5:4:3:2:0": "0:7:6:5:4:3:2:0/128",
2182             "7:6:5:4:3:2:1::": "7:6:5:4:3:2:1:0/128",
2183             "0:6:5:4:3:2:1::": "0:6:5:4:3:2:1:0/128",
2184         }
2185         for uncompressed, compressed in list(test_addresses.items()):
2186             self.assertEqual(compressed, str(ipaddress.IPv6Interface(uncompressed)))
2187     def testExplodeShortHandIpStr(self):
2188         addr1 = ipaddress.IPv6Interface("2001::1")
2189         addr2 = ipaddress.IPv6Address("2001:0:5ef5:79fd:0:59d:a0e5:ba1")
2190         addr3 = ipaddress.IPv6Network("2001::/96")
2191         addr4 = ipaddress.IPv4Address("192.168.178.1")
2192         self.assertEqual("2001:0000:0000:0000:0000:0000:0000:0001/128", addr1.exploded)
2193         self.assertEqual(
2194             "0000:0000:0000:0000:0000:0000:0000:0001/128",
2195             ipaddress.IPv6Interface("::1/128").exploded,
2196         )
2197         self.assertEqual("2001:0000:5ef5:79fd:0000:059d:a0e5:0ba1", addr2.exploded)
2198         self.assertEqual("2001:0000:0000:0000:0000:0000:0000:0000/96", addr3.exploded)
2199         self.assertEqual("192.168.178.1", addr4.exploded)
2200     def testReversePointer(self):
2201         addr1 = ipaddress.IPv4Address("127.0.0.1")
2202         addr2 = ipaddress.IPv6Address("2001:db8::1")
2203         self.assertEqual("1.0.0.127.in-addr.arpa", addr1.reverse_pointer)
2204         self.assertEqual(
2205             "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8."
2206             + "b.d.0.1.0.0.2.ip6.arpa",
2207             addr2.reverse_pointer,
2208         )
2209     def testIntRepresentation(self):
2210         self.assertEqual(16909060, int(self.ipv4_address))
2211         self.assertEqual(42540616829182469433547762482097946625, int(self.ipv6_address))
2212     def testForceVersion(self):
2213         self.assertEqual(ipaddress.ip_network(1).version, 4)
2214         self.assertEqual(ipaddress.IPv6Network(1).version, 6)
2215     def testWithStar(self):
2216         self.assertEqual(self.ipv4_interface.with_prefixlen, "1.2.3.4/24")
2217         self.assertEqual(self.ipv4_interface.with_netmask, "1.2.3.4/255.255.255.0")
2218         self.assertEqual(self.ipv4_interface.with_hostmask, "1.2.3.4/0.0.0.255")
2219         self.assertEqual(
2220             self.ipv6_interface.with_prefixlen, "2001:658:22a:cafe:200::1/64"
2221         )
2222         self.assertEqual(
2223             self.ipv6_interface.with_netmask,
2224             "2001:658:22a:cafe:200::1/ffff:ffff:ffff:ffff::",
2225         )
2226         self.assertEqual(
2227             self.ipv6_interface.with_hostmask,
2228             "2001:658:22a:cafe:200::1/::ffff:ffff:ffff:ffff",
2229         )
2230     def testNetworkElementCaching(self):
2231         self.assertNotIn("broadcast_address", self.ipv4_network._cache)
2232         self.assertNotIn("hostmask", self.ipv4_network._cache)
2233         self.assertEqual(
2234             self.ipv4_network.broadcast_address, ipaddress.IPv4Address("1.2.3.255")
2235         )
2236         self.assertEqual(self.ipv4_network.hostmask, ipaddress.IPv4Address("0.0.0.255"))
2237         self.assertIn("broadcast_address", self.ipv4_network._cache)
2238         self.assertIn("hostmask", self.ipv4_network._cache)
2239         self.assertNotIn("broadcast_address", self.ipv6_network._cache)
2240         self.assertNotIn("hostmask", self.ipv6_network._cache)
2241         self.assertEqual(
2242             self.ipv6_network.network_address,
2243             ipaddress.IPv6Address("2001:658:22a:cafe::"),
2244         )
2245         self.assertEqual(
2246             self.ipv6_interface.network.network_address,
2247             ipaddress.IPv6Address("2001:658:22a:cafe::"),
2248         )
2249         self.assertEqual(
2250             self.ipv6_network.broadcast_address,
2251             ipaddress.IPv6Address("2001:658:22a:cafe:ffff:ffff:ffff:ffff"),
2252         )
2253         self.assertEqual(
2254             self.ipv6_network.hostmask, ipaddress.IPv6Address("::ffff:ffff:ffff:ffff")
2255         )
2256         self.assertEqual(
2257             self.ipv6_interface.network.broadcast_address,
2258             ipaddress.IPv6Address("2001:658:22a:cafe:ffff:ffff:ffff:ffff"),
2259         )
2260         self.assertEqual(
2261             self.ipv6_interface.network.hostmask,
2262             ipaddress.IPv6Address("::ffff:ffff:ffff:ffff"),
2263         )
2264         self.assertIn("broadcast_address", self.ipv6_network._cache)
2265         self.assertIn("hostmask", self.ipv6_network._cache)
2266         self.assertIn("broadcast_address", self.ipv6_interface.network._cache)
2267         self.assertIn("hostmask", self.ipv6_interface.network._cache)
2268     def testTeredo(self):
2269         server = ipaddress.IPv4Address("65.54.227.120")
2270         client = ipaddress.IPv4Address("192.0.2.45")
2271         teredo_addr = "2001:0000:4136:e378:8000:63bf:3fff:fdd2"
2272         self.assertEqual((server, client), ipaddress.ip_address(teredo_addr).teredo)
2273         bad_addr = "2000::4136:e378:8000:63bf:3fff:fdd2"
2274         self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
2275         bad_addr = "2001:0001:4136:e378:8000:63bf:3fff:fdd2"
2276         self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
2277         teredo_addr = ipaddress.IPv6Address("2001:0:5ef5:79fd:0:59d:a0e5:ba1")
2278         self.assertEqual(
2279             (
2280                 ipaddress.IPv4Address("94.245.121.253"),
2281                 ipaddress.IPv4Address("95.26.244.94"),
2282             ),
2283             teredo_addr.teredo,
2284         )
2285     def testsixtofour(self):
2286         sixtofouraddr = ipaddress.ip_address("2002:ac1d:2d64::1")
2287         bad_addr = ipaddress.ip_address("2000:ac1d:2d64::1")
2288         self.assertEqual(
2289             ipaddress.IPv4Address("172.29.45.100"), sixtofouraddr.sixtofour
2290         )
2291         self.assertFalse(bad_addr.sixtofour)
2292     def testV4HashIsNotConstant(self):
2293         ipv4_address1 = ipaddress.IPv4Interface("1.2.3.4")
2294         ipv4_address2 = ipaddress.IPv4Interface("2.3.4.5")
2295         self.assertNotEqual(ipv4_address1.__hash__(), ipv4_address2.__hash__())
2296     def testV6HashIsNotConstant(self):
2297         ipv6_address1 = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:1")
2298         ipv6_address2 = ipaddress.IPv6Interface("2001:658:22a:cafe:200:0:0:2")
2299         self.assertNotEqual(ipv6_address1.__hash__(), ipv6_address2.__hash__())
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
