<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_state.py & test_ipaddress.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_state.py & test_ipaddress.py
      </h3>
      <h1 align="center">
        0.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_state.py (3.2994924%)<TH>test_ipaddress.py (0.46906006%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match274491-0.html#0',2,'match274491-1.html#0',3)" NAME="0">(317-363)<TD><A HREF="javascript:ZweiFrames('match274491-0.html#0',2,'match274491-1.html#0',3)" NAME="0">(959-965)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match274491-0.html#1',2,'match274491-1.html#1',3)" NAME="1">(479-485)<TD><A HREF="javascript:ZweiFrames('match274491-0.html#1',2,'match274491-1.html#1',3)" NAME="1">(1104-1109)</A><TD ALIGN=center><FONT COLOR="#da0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_state.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import logging
import os
import textwrap
import threading
import time

import pytest
import salt.loader
import salt.utils.atomicfile
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils

log = logging.getLogger(__name__)


pytestmark = [
    pytest.mark.windows_whitelisted,
]


def test_show_highstate(state, state_testfile_dest_path):
    &quot;&quot;&quot;
    state.show_highstate
    &quot;&quot;&quot;
    high = state.show_highstate()
    assert isinstance(high, dict)
    assert str(state_testfile_dest_path) in high
    assert high[str(state_testfile_dest_path)][&quot;__env__&quot;] == &quot;base&quot;


def test_show_lowstate(state):
    &quot;&quot;&quot;
    state.show_lowstate
    &quot;&quot;&quot;
    low = state.show_lowstate()
    assert isinstance(low, list)
    for entry in low:
        assert isinstance(entry, dict)


def test_show_states(state):
    &quot;&quot;&quot;
    state.show_states
    &quot;&quot;&quot;
    states = state.show_states()
    assert isinstance(states, list)
    for entry in states:
        assert isinstance(entry, str)
    assert states == [&quot;core&quot;]


def test_show_states_missing_sls(state, state_tree):
    &quot;&quot;&quot;
    Test state.show_states with a sls file
    defined in a top file is missing
    &quot;&quot;&quot;
    top_sls_contents = &quot;&quot;&quot;
    base:
      '*':
        - core
        - does-not-exist
    &quot;&quot;&quot;
    with pytest.helpers.temp_file(&quot;top.sls&quot;, top_sls_contents, state_tree):
        states = state.show_states()
        assert isinstance(states, list)
        assert states == [&quot;No matching sls found for 'does-not-exist' in env 'base'&quot;]


def test_catch_recurse(state, state_tree):
    &quot;&quot;&quot;
    state.show_sls used to catch a recursive ref
    &quot;&quot;&quot;
    sls_contents = &quot;&quot;&quot;
    mysql:
      service:
        - running
        - require:
          - file: /etc/mysql/my.cnf

    /etc/mysql/my.cnf:
      file:
        - managed
        - source: salt://master.cnf
        - require:
          - service: mysql
    &quot;&quot;&quot;
    with pytest.helpers.temp_file(&quot;recurse-fail.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;recurse-fail&quot;)
        assert ret.failed
        assert (
            'A recursive requisite was found, SLS &quot;recurse-fail&quot; ID &quot;/etc/mysql/my.cnf&quot; ID &quot;mysql&quot;'
            in ret.errors
        )


RECURSE_SLS_ONE = &quot;&quot;&quot;
snmpd:
  pkg:
    - installed
  service:
    - running
    - require:
      - pkg: snmpd
    - watch:
      - file: /etc/snmp/snmpd.conf

/etc/snmp/snmpd.conf:
  file:
    - managed
    - source: salt://snmpd/snmpd.conf.jinja
    - template: jinja
    - user: root
    - group: root
    - mode: &quot;0600&quot;
    - require:
      - pkg: snmpd
&quot;&quot;&quot;
RECURSE_SLS_TWO = &quot;&quot;&quot;
nagios-nrpe-server:
  pkg:
    - installed
  service:
    - running
    - watch:
      - file: /etc/nagios/nrpe.cfg

/etc/nagios/nrpe.cfg:
  file:
    - managed
    - source: salt://baseserver/nrpe.cfg
    - require:
      - pkg: nagios-nrpe-server
&quot;&quot;&quot;


@pytest.mark.parametrize(
    &quot;sls_contents, expected_in_output&quot;,
    [(RECURSE_SLS_ONE, &quot;snmpd&quot;), (RECURSE_SLS_TWO, &quot;/etc/nagios/nrpe.cfg&quot;)],
    ids=(&quot;recurse-scenario-1&quot;, &quot;recurse-scenario-2&quot;),
)
def test_no_recurse(state, state_tree, sls_contents, expected_in_output):
    &quot;&quot;&quot;
    verify that a sls structure is NOT a recursive ref
    &quot;&quot;&quot;
    with pytest.helpers.temp_file(&quot;recurse-ok.sls&quot;, sls_contents, state_tree):
        ret = state.show_sls(&quot;recurse-ok&quot;)
        assert expected_in_output in ret


def test_running_dictionary_consistency(state):
    &quot;&quot;&quot;
    Test the structure of the running dictionary so we don't change it
    without deprecating/documenting the change
    &quot;&quot;&quot;
    running_dict_fields = {
        &quot;__id__&quot;,
        &quot;__run_num__&quot;,
        &quot;__sls__&quot;,
        &quot;changes&quot;,
        &quot;comment&quot;,
        &quot;duration&quot;,
        &quot;name&quot;,
        &quot;result&quot;,
        &quot;start_time&quot;,
    }

    sls = state.single(&quot;test.succeed_without_changes&quot;, name=&quot;gndn&quot;)
    ret_values_set = set(sls.full_return.keys())
    assert running_dict_fields.issubset(ret_values_set)


def test_running_dictionary_key_sls(state, state_tree):
    &quot;&quot;&quot;
    Ensure the __sls__ key is either null or a string
    &quot;&quot;&quot;
    sls1 = state.single(&quot;test.succeed_with_changes&quot;, name=&quot;gndn&quot;)
    assert &quot;__sls__&quot; in sls1.full_return
    assert sls1.full_return[&quot;__sls__&quot;] is None

    sls_contents = &quot;&quot;&quot;
    gndn:
      test.succeed_with_changes
    &quot;&quot;&quot;
    with pytest.helpers.temp_file(&quot;gndn.sls&quot;, sls_contents, state_tree):
        sls2 = state.sls(mods=&quot;gndn&quot;)

    for state_return in sls2:
        assert &quot;__sls__&quot; in state_return.full_return
        assert isinstance(state_return.full_return[&quot;__sls__&quot;], str)


@pytest.fixture
def requested_sls_key(minion_opts, state_tree):
    if not salt.utils.platform.is_windows():
        sls_contents = &quot;&quot;&quot;
        count_root_dir_contents:
          cmd.run:
            - name: 'ls -a / | wc -l'
        &quot;&quot;&quot;
        sls_key = &quot;cmd_|-count_root_dir_contents_|-ls -a / | wc -l_|-run&quot;
    else:
        sls_contents = r&quot;&quot;&quot;
        count_root_dir_contents:
          cmd.run:
            - name: 'Get-ChildItem C:\ | Measure-Object | %{$_.Count}'
            - shell: powershell
        &quot;&quot;&quot;
        sls_key = (
            r&quot;cmd_|-count_root_dir_contents_|-Get-ChildItem C:\ | Measure-Object |&quot;
            r&quot; %{$_.Count}_|-run&quot;
        )
    try:
        with pytest.helpers.temp_file(
            &quot;requested.sls&quot;, sls_contents, state_tree
        ) as sls_path:
            yield sls_key
    finally:
        cache_file = os.path.join(minion_opts[&quot;cachedir&quot;], &quot;req_state.p&quot;)
        if os.path.exists(cache_file):
            os.remove(cache_file)


def test_request(state, requested_sls_key):
    &quot;&quot;&quot;
    verify sending a state request to the minion(s)
    &quot;&quot;&quot;
    ret = state.request(&quot;requested&quot;)
    assert ret[requested_sls_key][&quot;result&quot;] is None


def test_check_request(state, requested_sls_key):
    &quot;&quot;&quot;
    verify checking a state request sent to the minion(s)
    &quot;&quot;&quot;
    ret = state.request(&quot;requested&quot;)
    assert ret[requested_sls_key][&quot;result&quot;] is None

    ret = state.check_request()
    assert ret[&quot;default&quot;][&quot;test_run&quot;][requested_sls_key][&quot;result&quot;] is None


def test_clear_request(state, requested_sls_key):
    &quot;&quot;&quot;
    verify clearing a state request sent to the minion(s)
    &quot;&quot;&quot;
    ret = state.request(&quot;requested&quot;)
    assert ret[requested_sls_key][&quot;result&quot;] is None

    ret = state.clear_request()
    assert ret is True


def test_run_request_succeeded(state, requested_sls_key):
    &quot;&quot;&quot;
    verify running a state request sent to the minion(s)
    &quot;&quot;&quot;
    ret = state.request(&quot;requested&quot;)
    assert ret[requested_sls_key][&quot;result&quot;] is None

    ret = state.run_request()
    assert ret[requested_sls_key][&quot;result&quot;] is True


def test_run_request_failed_no_request_staged(state, requested_sls_key):
    &quot;&quot;&quot;
    verify not running a state request sent to the minion(s)
    &quot;&quot;&quot;
    ret = state.request(&quot;requested&quot;)
    assert ret[requested_sls_key][&quot;result&quot;] is None

    ret = state.clear_request()
    assert ret is True

    ret = state.run_request()
    assert ret == {}


def test_issue_1876_syntax_error(state, state_tree, tmp_path):
    &quot;&quot;&quot;
    verify that we catch the following syntax error::

        /tmp/salttest/issue-1876:

          file:
            - managed
            - source: salt://testfile

          file.append:
            - text: foo

    &quot;&quot;&quot;
    testfile = tmp_path / &quot;issue-1876.txt&quot;
    sls_contents = &quot;&quot;&quot;
    {}:
      file:
        - managed
        - source: salt://testfile

      file.append:
        - text: foo
    &quot;&quot;&quot;.format(
        testfile
    )
    with pytest.helpers.temp_file(&quot;issue-1876.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;issue-1876&quot;)
        assert ret.failed
        errmsg = (
            &quot;ID '{}' in SLS 'issue-1876' contains multiple state declarations of the&quot;
            &quot; same type&quot;.format(testfile)
        )
        assert errmsg in ret.errors
<A NAME="0"></A>

def test_issue_1879_too_simple_contains_check(state, state_tree, tmp_path):
    testfile <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match274491-1.html#0',3,'match274491-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= tmp_path / &quot;issue-1979.txt&quot;
    init_sls_contents = &quot;&quot;&quot;
    {}:
      file:
        - touch
    &quot;&quot;&quot;.format(
        testfile
    )
    step1_sls_contents = &quot;&quot;&quot;
    {}:
      file.append:
        - text: |
            # set variable identifying the chroot you work in (used in the prompt below)
            if [ -z &quot;$debian_chroot&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then
                debian_chroot=$(cat /etc/debian_chroot)
            fi

    &quot;&quot;&quot;.format(
        testfile
    )
    step2_sls_contents = &quot;&quot;&quot;
    {}:
      file.append:
        - text: |
            # enable bash completion in interactive shells
            if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
                . /etc/bash_completion
            fi

    &quot;&quot;&quot;.format(
        testfile
    )

    expected = textwrap.dedent(
        &quot;&quot;&quot;\
        # set variable identifying the chroot you work in (used in the prompt below)
        if [ -z &quot;$debian_chroot&quot; ] &amp;&amp; [ -r /etc/debian_chroot ]; then
            debian_chroot=$(cat /etc/debian_chroot)
        fi
        # enable bash completion in interactive shells
        if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then
            . /etc/bash_completion
        fi
        &quot;&quot;&quot;
    )

    issue_1879_dir =</B></FONT> state_tree / &quot;issue-1879&quot;
    with pytest.helpers.temp_file(
        &quot;init.sls&quot;, init_sls_contents, issue_1879_dir
    ), pytest.helpers.temp_file(
        &quot;step-1.sls&quot;, step1_sls_contents, issue_1879_dir
    ), pytest.helpers.temp_file(
        &quot;step-2.sls&quot;, step2_sls_contents, issue_1879_dir
    ):
        # Create the file
        ret = state.sls(&quot;issue-1879&quot;)
        for staterun in ret:
            assert staterun.result is True

        # The first append
        ret = state.sls(&quot;issue-1879.step-1&quot;)
        for staterun in ret:
            assert staterun.result is True

        # The second append
        ret = state.sls(&quot;issue-1879.step-2&quot;)
        for staterun in ret:
            assert staterun.result is True

        # Does it match?
        contents = testfile.read_text()
        assert contents == expected

        # Make sure we don't re-append existing text
        ret = state.sls(&quot;issue-1879.step-1&quot;)
        for staterun in ret:
            assert staterun.result is True

        ret = state.sls(&quot;issue-1879.step-2&quot;)
        for staterun in ret:
            assert staterun.result is True

        # Does it match?
        contents = testfile.read_text()
        assert contents == expected


def test_include(state, state_tree, tmp_path):
    testfile_path = tmp_path / &quot;testfile&quot;
    testfile_path.write_text(&quot;foo&quot;)
    include_test_path = tmp_path / &quot;include-test.txt&quot;
    to_include_test_path = tmp_path / &quot;to-include-test.txt&quot;
    exclude_test_path = tmp_path / &quot;exclude-test.txt&quot;
    to_include_sls_contents = &quot;&quot;&quot;
    {}:
      file.managed:
        - source: salt://testfile
    &quot;&quot;&quot;.format(
        to_include_test_path
    )
    include_sls_contents = &quot;&quot;&quot;
    include:
      - to-include-test

    {}:
      file.managed:
        - source: salt://testfile
    &quot;&quot;&quot;.format(
        include_test_path
    )
    with pytest.helpers.temp_file(
        &quot;testfile&quot;, &quot;foo&quot;, state_tree
    ), pytest.helpers.temp_file(
        &quot;to-include-test.sls&quot;, to_include_sls_contents, state_tree
    ), pytest.helpers.temp_file(
        &quot;include-test.sls&quot;, include_sls_contents, state_tree
    ):
        ret = state.sls(&quot;include-test&quot;)
        for staterun in ret:
            assert staterun.result is True

    assert include_test_path.exists()
    assert to_include_test_path.exists()
    assert exclude_test_path.exists() is False


def test_exclude(state, state_tree, tmp_path):
    testfile_path = tmp_path / &quot;testfile&quot;
    testfile_path.write_text(&quot;foo&quot;)
    include_test_path = tmp_path / &quot;include-test.txt&quot;
    to_include_test_path = tmp_path / &quot;to-include-test.txt&quot;
    exclude_test_path = tmp_path / &quot;exclude-test.txt&quot;
    to_include_sls_contents = &quot;&quot;&quot;
    {}:
      file.managed:
        - source: salt://testfile
    &quot;&quot;&quot;.format(
        to_include_test_path
    )
    include_sls_contents = &quot;&quot;&quot;
    include:
      - to-include-test

    {}:
      file.managed:
        - source: salt://testfile
    &quot;&quot;&quot;.format(
        include_test_path
    )
    exclude_sls_contents = &quot;&quot;&quot;
    exclude:
      - to-include-test

    include:
      - include-test

    {}:
      file.managed:
        - source: salt://testfile
<A NAME="1"></A>    &quot;&quot;&quot;.format(
        exclude_test_path
    )
    with pytest<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match274491-1.html#1',3,'match274491-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.helpers.temp_file(
        &quot;testfile&quot;, &quot;foo&quot;, state_tree
    ), pytest.helpers.temp_file(
        &quot;to-include-test.sls&quot;, to_include_sls_contents, state_tree
    ), pytest.helpers.temp_file(
        &quot;include-test.sls&quot;, include_sls_contents, state_tree
    ), pytest.helpers.temp_file(</B></FONT>
        &quot;exclude-test.sls&quot;, exclude_sls_contents, state_tree
    ):
        ret = state.sls(&quot;exclude-test&quot;)
        for staterun in ret:
            assert staterun.result is True

    assert include_test_path.exists()
    assert exclude_test_path.exists()
    assert to_include_test_path.exists() is False


def test_issue_2068_template_str(state, state_tree):
    template_str_no_dot_sls_contents = &quot;&quot;&quot;
    required_state:
      test:
        - succeed_without_changes

    requiring_state:
      test:
        - succeed_without_changes
        - require:
          - test: required_state
    &quot;&quot;&quot;
    template_str_sls_contents = &quot;&quot;&quot;
    required_state: test.succeed_without_changes

    requiring_state:
      test.succeed_without_changes:
        - require:
          - test: required_state
    &quot;&quot;&quot;
    with pytest.helpers.temp_file(
        &quot;issue-2068-no-dot.sls&quot;, template_str_no_dot_sls_contents, state_tree
    ) as template_str_no_dot_path, pytest.helpers.temp_file(
        &quot;issue-2068.sls&quot;, template_str_sls_contents, state_tree
    ) as template_str_path:
        # If running this state with state.sls works, so should using state.template_str
        ret = state.sls(&quot;issue-2068-no-dot&quot;)
        for staterun in ret:
            assert staterun.result is True

        template_str_no_dot_contents = template_str_no_dot_path.read_text()
        ret = state.template_str(template_str_no_dot_contents)
        for staterun in ret:
            assert staterun.result is True

        # Now using state.template
        ret = state.template(str(template_str_no_dot_path))
        for staterun in ret:
            assert staterun.result is True

        # Now the problematic #2068 including dot's
        ret = state.sls(&quot;issue-2068&quot;)
        for staterun in ret:
            assert staterun.result is True

        template_str_contents = template_str_path.read_text()
        ret = state.template_str(template_str_contents)
        for staterun in ret:
            assert staterun.result is True

        # Now using state.template
        ret = state.template(str(template_str_path))
        for staterun in ret:
            assert staterun.result is True


@pytest.mark.parametrize(&quot;item&quot;, (&quot;include&quot;, &quot;exclude&quot;, &quot;extends&quot;))
def test_template_str_invalid_items(state, item):
    TEMPLATE = textwrap.dedent(
        &quot;&quot;&quot;\
        {}:
          - existing-state

        /tmp/test-template-invalid-items:
          file:
            - managed
            - source: salt://testfile
        &quot;&quot;&quot;.format(
            item
        )
    )

    ret = state.template_str(TEMPLATE.format(item))
    assert ret.failed
    errmsg = (
        &quot;The '{}' declaration found on '&lt;template-str&gt;' is invalid when &quot;
        &quot;rendering single templates&quot;.format(item)
    )
    assert errmsg in ret.errors


@pytest.mark.skip_on_windows(
    reason=(
        &quot;Functional testing this on windows raises unicode errors. &quot;
        &quot;Tested in tests/pytests/integration/modules/state/test_state.py&quot;
    )
)
def test_pydsl(state, state_tree, tmp_path):
    &quot;&quot;&quot;
    Test the basics of the pydsl
    &quot;&quot;&quot;
    testfile = tmp_path / &quot;testfile&quot;
    sls_contents = &quot;&quot;&quot;
    #!pydsl

    state(&quot;{}&quot;).file(&quot;touch&quot;)
    &quot;&quot;&quot;.format(
        testfile
    )
    with pytest.helpers.temp_file(&quot;pydsl.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;pydsl&quot;)
        for staterun in ret:
            assert staterun.result is True
        assert testfile.exists()


def test_issues_7905_and_8174_sls_syntax_error(state, state_tree):
    &quot;&quot;&quot;
    Call sls file with yaml syntax error.

    Ensure theses errors are detected and presented to the user without
    stack traces.
    &quot;&quot;&quot;
    badlist_1_sls_contents = &quot;&quot;&quot;
    # Missing &quot; &quot; between &quot;-&quot; and &quot;foo&quot; or &quot;name&quot;
    A:
      cmd.run:
        -name: echo foo
        -foo:
          - bar
    &quot;&quot;&quot;
    badlist_2_sls_contents = &quot;&quot;&quot;
    # C should fail with bad list error message
    B:
      # ok
      file.exist:
        - name: /foo/bar/foobar
    # ok
    /foo/bar/foobar:
      file.exist

    # nok
    C:
      /foo/bar/foobar:
        file.exist
    &quot;&quot;&quot;
    with pytest.helpers.temp_file(
        &quot;badlist1.sls&quot;, badlist_1_sls_contents, state_tree
    ), pytest.helpers.temp_file(&quot;badlist2.sls&quot;, badlist_2_sls_contents, state_tree):
        ret = state.sls(&quot;badlist1&quot;)
        assert ret.failed
        assert ret.errors == [&quot;State 'A' in SLS 'badlist1' is not formed as a list&quot;]

        ret = state.sls(&quot;badlist2&quot;)
        assert ret.failed
        assert ret.errors == [&quot;State 'C' in SLS 'badlist2' is not formed as a list&quot;]


@pytest.mark.slow_test
def test_retry_option(state, state_tree):
    &quot;&quot;&quot;
    test the retry option on a simple state with defaults
    ensure comment is as expected
    ensure state duration is greater than configured the passed (interval * attempts)
    &quot;&quot;&quot;
    sls_contents = &quot;&quot;&quot;
    file_test:
      file.exists:
        - name: /path/to/a/non-existent/file.txt
        - retry:
            until: True
            attempts: 3
            interval: 1
            splay: 0
    &quot;&quot;&quot;
    expected_comment = (
        'Attempt 1: Returned a result of &quot;False&quot;, with the following '
        'comment: &quot;Specified path /path/to/a/non-existent/file.txt does not exist&quot;'
    )
    with pytest.helpers.temp_file(&quot;retry.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;retry&quot;)
        for state_return in ret:
            assert state_return.result is False
            assert expected_comment in state_return.comment
            assert state_return.full_return[&quot;duration&quot;] &gt;= 3


def test_retry_option_success(state, state_tree, tmp_path):
    &quot;&quot;&quot;
    test a state with the retry option that should return True immediately (i.e. no retries)
    &quot;&quot;&quot;
    testfile = tmp_path / &quot;testfile&quot;
    testfile.touch()
    sls_contents = &quot;&quot;&quot;
    file_test:
      file.exists:
        - name: {}
        - retry:
            until: True
            attempts: 5
            interval: 2
            splay: 0
    &quot;&quot;&quot;.format(
        testfile
    )
    duration = 4
    if salt.utils.platform.is_windows():
        duration = 16

    with pytest.helpers.temp_file(&quot;retry.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;retry&quot;)
        for state_return in ret:
            assert state_return.result is True
            assert state_return.full_return[&quot;duration&quot;] &lt; duration
            # It should not take 2 attempts
            assert &quot;Attempt 2&quot; not in state_return.comment


@pytest.mark.slow_test
def test_retry_option_eventual_success(state, state_tree, tmp_path):
    &quot;&quot;&quot;
    test a state with the retry option that should return True, eventually
    &quot;&quot;&quot;
    testfile1 = tmp_path / &quot;testfile-1&quot;
    testfile2 = tmp_path / &quot;testfile-2&quot;

    def create_testfile(testfile1, testfile2):
        while True:
            if testfile1.exists():
                break
        time.sleep(2)
        testfile2.touch()

    thread = threading.Thread(target=create_testfile, args=(testfile1, testfile2))
    sls_contents = &quot;&quot;&quot;
    file_test_a:
      file.managed:
        - name: {}
        - content: 'a'

    file_test:
      file.exists:
        - name: {}
        - retry:
            until: True
            attempts: 5
            interval: 2
            splay: 0
        - require:
          - file_test_a
    &quot;&quot;&quot;.format(
        testfile1, testfile2
    )
    with pytest.helpers.temp_file(&quot;retry.sls&quot;, sls_contents, state_tree):
        thread.start()
        ret = state.sls(&quot;retry&quot;)
        for state_return in ret:
            assert state_return.result is True
            assert state_return.full_return[&quot;duration&quot;] &gt; 4
            # It should not take 5 attempts
            assert &quot;Attempt 5&quot; not in state_return.comment


@pytest.mark.slow_test
def test_state_non_base_environment(state, state_tree_prod, tmp_path):
    &quot;&quot;&quot;
    test state.sls with saltenv using a nonbase environment
    with a salt source
    &quot;&quot;&quot;
    testfile = tmp_path / &quot;testfile&quot;
    sls_contents = &quot;&quot;&quot;
    {}:
      file.managed:
        - content: foo
    &quot;&quot;&quot;.format(
        testfile
    )
    with pytest.helpers.temp_file(&quot;non-base-env.sls&quot;, sls_contents, state_tree_prod):
        ret = state.sls(&quot;non-base-env&quot;, saltenv=&quot;prod&quot;)
        for state_return in ret:
            assert state_return.result is True
        assert testfile.exists()


@pytest.mark.skip_on_windows(
    reason=&quot;Skipped until parallel states can be fixed on Windows&quot;
)
def test_parallel_state_with_long_tag(state, state_tree):
    &quot;&quot;&quot;
    This tests the case where the state being executed has a long ID dec or
    name and states are being run in parallel. The filenames used for the
    parallel state cache were previously based on the tag for each chunk,
    and longer ID decs or name params can cause the cache file to be longer
    than the operating system's max file name length. To counter this we
    instead generate a SHA1 hash of the chunk's tag to use as the cache
    filename. This test will ensure that long tags don't cause caching
    failures.

    See https://github.com/saltstack/salt/issues/49738 for more info.
    &quot;&quot;&quot;
    short_command = &quot;helloworld&quot;
    long_command = short_command * 25
    sls_contents = &quot;&quot;&quot;
    test_cmd_short:
      cmd.run:
        - name: {}
        - parallel: True

    test_cmd_long:
      cmd.run:
        - name: {}
        - parallel: True
    &quot;&quot;&quot;.format(
        short_command, long_command
    )
    with pytest.helpers.temp_file(&quot;issue-49738.sls&quot;, sls_contents, state_tree):
        ret = state.sls(
            &quot;issue-49738&quot;,
            __pub_jid=&quot;1&quot;,  # Because these run in parallel we need a fake JID
        )

    comments = sorted(x.comment for x in ret)
    expected = sorted(
        'Command &quot;{}&quot; run'.format(x) for x in (short_command, long_command)
    )
    assert comments == expected, &quot;{} != {}&quot;.format(comments, expected)


@pytest.mark.skip_on_darwin(reason=&quot;Test is broken on macosx&quot;)
@pytest.mark.skip_on_windows(
    reason=(
        &quot;Functional testing this on windows raises unicode errors. &quot;
        &quot;Tested in tests/pytests/integration/modules/state/test_state.py&quot;
    )
)
def test_state_sls_unicode_characters(state, state_tree):
    &quot;&quot;&quot;
    test state.sls when state file contains non-ascii characters
    &quot;&quot;&quot;
    sls_contents = &quot;&quot;&quot;
    echo1:
      cmd.run:
        - name: &quot;echo 'This is Æ test!'&quot;
    &quot;&quot;&quot;
    with pytest.helpers.temp_file(&quot;issue-46672.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;issue-46672&quot;)
        expected = &quot;cmd_|-echo1_|-echo 'This is Æ test!'_|-run&quot;
        assert expected in ret


def test_state_sls_integer_name(state, state_tree):
    &quot;&quot;&quot;
    This tests the case where the state file is named
    only with integers
    &quot;&quot;&quot;
    sls_contents = &quot;&quot;&quot;
    always-passes:
      test.succeed_without_changes
    &quot;&quot;&quot;
    state_id = &quot;test_|-always-passes_|-always-passes_|-succeed_without_changes&quot;
    with pytest.helpers.temp_file(&quot;12345.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;12345&quot;)
        assert state_id in ret
        for state_return in ret:
            assert state_return.result is True
            assert &quot;Success!&quot; in state_return.comment

        ret = state.sls(mods=12345)
        assert state_id in ret
        for state_return in ret:
            assert state_return.result is True
            assert &quot;Success!&quot; in state_return.comment


def test_state_sls_lazyloader_allows_recursion(state, state_tree):
    &quot;&quot;&quot;
    This tests that referencing dunders like __salt__ work
    context: https://github.com/saltstack/salt/pull/51499
    &quot;&quot;&quot;
    sls_contents = &quot;&quot;&quot;
    {% if 'nonexistent_module.function' in salt %}
    {% do salt.log.warning(&quot;Module is available&quot;) %}
    {% endif %}
    always-passes:
      test.succeed_without_changes:
        - name: foo
    &quot;&quot;&quot;
    state_id = &quot;test_|-always-passes_|-foo_|-succeed_without_changes&quot;
    with pytest.helpers.temp_file(&quot;issue-51499.sls&quot;, sls_contents, state_tree):
        ret = state.sls(&quot;issue-51499&quot;)
        assert state_id in ret
        for state_return in ret:
            assert state_return.result is True
            assert &quot;Success!&quot; in state_return.comment
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_ipaddress.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# Copyright 2007 Google Inc.
#  Licensed to PSF under a Contributor Agreement.
#
#

# This is test_ipaddress.py from Python 3.9.5, verbatim, with minor compatility changes
#    https://github.com/python/cpython/blob/v3.9.5/Lib/test/test_ipaddress.py
#
# Modifications:
#  - Switch the ipaddress import to salt._compat
#  - Copy the `LARGEST` and `SMALLEST` implementation, from 3.9.1
#  - Adjust IpaddrUnitTest.testNetworkElementCaching because we're not using cached_property

&quot;&quot;&quot;Unittest for ipaddress module.&quot;&quot;&quot;

# pylint: disable=string-substitution-usage-error,pointless-statement,abstract-method,cell-var-from-loop

import contextlib
import functools
import operator
import pickle
import re
import sys
import weakref

import pytest
from salt._compat import ipaddress
from tests.support.unit import TestCase, skipIf


@functools.total_ordering
class _LARGEST:
    &quot;&quot;&quot;
    Object that is greater than anything (except itself).
    &quot;&quot;&quot;

    def __eq__(self, other):
        return isinstance(other, _LARGEST)

    def __lt__(self, other):
        return False


LARGEST = _LARGEST()


@functools.total_ordering
class _SMALLEST:
    &quot;&quot;&quot;
    Object that is less than anything (except itself).
    &quot;&quot;&quot;

    def __eq__(self, other):
        return isinstance(other, _SMALLEST)

    def __gt__(self, other):
        return False


SMALLEST = _SMALLEST()


class BaseTestCase(TestCase):
    # One big change in ipaddress over the original ipaddr module is
    # error reporting that tries to assume users *don't know the rules*
    # for what constitutes an RFC compliant IP address

    # Ensuring these errors are emitted correctly in all relevant cases
    # meant moving to a more systematic test structure that allows the
    # test structure to map more directly to the module structure

    # Note that if the constructors are refactored so that addresses with
    # multiple problems get classified differently, that's OK - just
    # move the affected examples to the newly appropriate test case.

    # There is some duplication between the original relatively ad hoc
    # test suite and the new systematic tests. While some redundancy in
    # testing is considered preferable to accidentally deleting a valid
    # test, the original test suite will likely be reduced over time as
    # redundant tests are identified.

    @property
    def factory(self):
        raise NotImplementedError

    @contextlib.contextmanager
    def assertCleanError(self, exc_type, details, *args):
        &quot;&quot;&quot;
        Ensure exception does not display a context by default

        Wraps unittest.TestCase.assertRaisesRegex
        &quot;&quot;&quot;
        if args:
            details = details % args
        cm = self.assertRaisesRegex(exc_type, details)
        with cm as exc:
            yield exc
        # Ensure we produce clean tracebacks on failure
        if exc.exception.__context__ is not None:
            self.assertTrue(exc.exception.__suppress_context__)

    def assertAddressError(self, details, *args):
        &quot;&quot;&quot;Ensure a clean AddressValueError&quot;&quot;&quot;
        return self.assertCleanError(ipaddress.AddressValueError, details, *args)

    def assertNetmaskError(self, details, *args):
        &quot;&quot;&quot;Ensure a clean NetmaskValueError&quot;&quot;&quot;
        return self.assertCleanError(ipaddress.NetmaskValueError, details, *args)

    def assertInstancesEqual(self, lhs, rhs):
        &quot;&quot;&quot;Check constructor arguments produce equivalent instances&quot;&quot;&quot;
        self.assertEqual(self.factory(lhs), self.factory(rhs))


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class CommonTestMixin:
    def test_empty_address(self):
        with self.assertAddressError(&quot;Address cannot be empty&quot;):
            self.factory(&quot;&quot;)

    def test_floats_rejected(self):
        with self.assertAddressError(re.escape(repr(&quot;1.0&quot;))):
            self.factory(1.0)

    def test_not_an_index_issue15559(self):
        # Implementing __index__ makes for a very nasty interaction with the
        # bytes constructor. Thus, we disallow implicit use as an integer
        self.assertRaises(TypeError, operator.index, self.factory(1))
        self.assertRaises(TypeError, hex, self.factory(1))
        self.assertRaises(TypeError, bytes, self.factory(1))

    def pickle_test(self, addr):
        for proto in range(pickle.HIGHEST_PROTOCOL + 1):
            with self.subTest(proto=proto):
                x = self.factory(addr)
                y = pickle.loads(pickle.dumps(x, proto))
                self.assertEqual(y, x)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class CommonTestMixin_v4(CommonTestMixin):
    def test_leading_zeros(self):
        # bpo-36384: no leading zeros to avoid ambiguity with octal notation
        msg = r&quot;Leading zeros are not permitted in '\d+'&quot;
        addresses = [
            &quot;000.000.000.000&quot;,
            &quot;192.168.000.001&quot;,
            &quot;016.016.016.016&quot;,
            &quot;192.168.000.001&quot;,
            &quot;001.000.008.016&quot;,
            &quot;01.2.3.40&quot;,
            &quot;1.02.3.40&quot;,
            &quot;1.2.03.40&quot;,
            &quot;1.2.3.040&quot;,
        ]
        for address in addresses:
            with self.subTest(address=address):
                with self.assertAddressError(msg):
                    self.factory(address)

    def test_int(self):
        self.assertInstancesEqual(0, &quot;0.0.0.0&quot;)
        self.assertInstancesEqual(3232235521, &quot;192.168.0.1&quot;)

    def test_packed(self):
        self.assertInstancesEqual(bytes.fromhex(&quot;00000000&quot;), &quot;0.0.0.0&quot;)
        self.assertInstancesEqual(bytes.fromhex(&quot;c0a80001&quot;), &quot;192.168.0.1&quot;)

    def test_negative_ints_rejected(self):
        msg = &quot;-1 (&lt; 0) is not permitted as an IPv4 address&quot;
        with self.assertAddressError(re.escape(msg)):
            self.factory(-1)

    def test_large_ints_rejected(self):
        msg = &quot;%d (&gt;= 2**32) is not permitted as an IPv4 address&quot;
        with self.assertAddressError(re.escape(msg % 2 ** 32)):
            self.factory(2 ** 32)

    def test_bad_packed_length(self):
        def assertBadLength(length):
            addr = b&quot;\0&quot; * length
            msg = &quot;%r (len %d != 4) is not permitted as an IPv4 address&quot;
            with self.assertAddressError(re.escape(msg % (addr, length))):
                self.factory(addr)

        assertBadLength(3)
        assertBadLength(5)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class CommonTestMixin_v6(CommonTestMixin):
    def test_leading_zeros(self):
        self.assertInstancesEqual(&quot;0000::0000&quot;, &quot;::&quot;)
        self.assertInstancesEqual(&quot;000::c0a8:0001&quot;, &quot;::c0a8:1&quot;)

    def test_int(self):
        self.assertInstancesEqual(0, &quot;::&quot;)
        self.assertInstancesEqual(3232235521, &quot;::c0a8:1&quot;)

    def test_packed(self):
        addr = b&quot;\0&quot; * 12 + bytes.fromhex(&quot;00000000&quot;)
        self.assertInstancesEqual(addr, &quot;::&quot;)
        addr = b&quot;\0&quot; * 12 + bytes.fromhex(&quot;c0a80001&quot;)
        self.assertInstancesEqual(addr, &quot;::c0a8:1&quot;)
        addr = bytes.fromhex(&quot;c0a80001&quot;) + b&quot;\0&quot; * 12
        self.assertInstancesEqual(addr, &quot;c0a8:1::&quot;)

    def test_negative_ints_rejected(self):
        msg = &quot;-1 (&lt; 0) is not permitted as an IPv6 address&quot;
        with self.assertAddressError(re.escape(msg)):
            self.factory(-1)

    def test_large_ints_rejected(self):
        msg = &quot;%d (&gt;= 2**128) is not permitted as an IPv6 address&quot;
        with self.assertAddressError(re.escape(msg % 2 ** 128)):
            self.factory(2 ** 128)

    def test_bad_packed_length(self):
        def assertBadLength(length):
            addr = b&quot;\0&quot; * length
            msg = &quot;%r (len %d != 16) is not permitted as an IPv6 address&quot;
            with self.assertAddressError(re.escape(msg % (addr, length))):
                self.factory(addr)
                self.factory(addr)

        assertBadLength(15)
        assertBadLength(17)

    def test_blank_scope_id(self):
        address = &quot;::1%&quot;
        with self.assertAddressError('Invalid IPv6 address: &quot;%r&quot;', address):
            self.factory(address)

    def test_invalid_scope_id_with_percent(self):
        address = &quot;::1%scope%&quot;
        with self.assertAddressError('Invalid IPv6 address: &quot;%r&quot;', address):
            self.factory(address)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class AddressTestCase_v4(BaseTestCase, CommonTestMixin_v4):
    factory = ipaddress.IPv4Address

    @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason=&quot;Don't run on Py3.5&quot;)
    def test_format(self):
        v4 = ipaddress.IPv4Address(&quot;1.2.3.42&quot;)
        v4_pairs = [
            (&quot;b&quot;, &quot;00000001000000100000001100101010&quot;),
            (&quot;n&quot;, &quot;00000001000000100000001100101010&quot;),
            (&quot;x&quot;, &quot;0102032a&quot;),
            (&quot;X&quot;, &quot;0102032A&quot;),
            (&quot;_b&quot;, &quot;0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;_n&quot;, &quot;0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;_x&quot;, &quot;0102_032a&quot;),
            (&quot;_X&quot;, &quot;0102_032A&quot;),
            (&quot;#b&quot;, &quot;0b00000001000000100000001100101010&quot;),
            (&quot;#n&quot;, &quot;0b00000001000000100000001100101010&quot;),
            (&quot;#x&quot;, &quot;0x0102032a&quot;),
            (&quot;#X&quot;, &quot;0X0102032A&quot;),
            (&quot;#_b&quot;, &quot;0b0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;#_n&quot;, &quot;0b0000_0001_0000_0010_0000_0011_0010_1010&quot;),
            (&quot;#_x&quot;, &quot;0x0102_032a&quot;),
            (&quot;#_X&quot;, &quot;0X0102_032A&quot;),
            (&quot;s&quot;, &quot;1.2.3.42&quot;),
            (&quot;&quot;, &quot;1.2.3.42&quot;),
        ]
        for (fmt, txt) in v4_pairs:
            self.assertEqual(txt, format(v4, fmt))

    def test_network_passed_as_address(self):
        addr = &quot;127.0.0.1/24&quot;
        with self.assertAddressError(&quot;Unexpected '/' in %r&quot;, addr):
            ipaddress.IPv4Address(addr)

    def test_bad_address_split(self):
        def assertBadSplit(addr):
            with self.assertAddressError(&quot;Expected 4 octets in %r&quot;, addr):
                ipaddress.IPv4Address(addr)

        assertBadSplit(&quot;127.0.1&quot;)
        assertBadSplit(&quot;42.42.42.42.42&quot;)
        assertBadSplit(&quot;42.42.42&quot;)
        assertBadSplit(&quot;42.42&quot;)
        assertBadSplit(&quot;42&quot;)
        assertBadSplit(&quot;42..42.42.42&quot;)
        assertBadSplit(&quot;42.42.42.42.&quot;)
        assertBadSplit(&quot;42.42.42.42...&quot;)
        assertBadSplit(&quot;.42.42.42.42&quot;)
        assertBadSplit(&quot;...42.42.42.42&quot;)
        assertBadSplit(&quot;016.016.016&quot;)
        assertBadSplit(&quot;016.016&quot;)
        assertBadSplit(&quot;016&quot;)
        assertBadSplit(&quot;000&quot;)
        assertBadSplit(&quot;0x0a.0x0a.0x0a&quot;)
        assertBadSplit(&quot;0x0a.0x0a&quot;)
        assertBadSplit(&quot;0x0a&quot;)
        assertBadSplit(&quot;.&quot;)
        assertBadSplit(&quot;bogus&quot;)
        assertBadSplit(&quot;bogus.com&quot;)
        assertBadSplit(&quot;1000&quot;)
        assertBadSplit(&quot;1000000000000000&quot;)
        assertBadSplit(&quot;192.168.0.1.com&quot;)

    def test_empty_octet(self):
        def assertBadOctet(addr):
            with self.assertAddressError(&quot;Empty octet not permitted in %r&quot;, addr):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;42..42.42&quot;)
        assertBadOctet(&quot;...&quot;)

    def test_invalid_characters(self):
        def assertBadOctet(addr, octet):
            msg = &quot;Only decimal digits permitted in {!r} in {!r}&quot;.format(octet, addr)
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;0x0a.0x0a.0x0a.0x0a&quot;, &quot;0x0a&quot;)
        assertBadOctet(&quot;0xa.0x0a.0x0a.0x0a&quot;, &quot;0xa&quot;)
        assertBadOctet(&quot;42.42.42.-0&quot;, &quot;-0&quot;)
        assertBadOctet(&quot;42.42.42.+0&quot;, &quot;+0&quot;)
        assertBadOctet(&quot;42.42.42.-42&quot;, &quot;-42&quot;)
        assertBadOctet(&quot;+1.+2.+3.4&quot;, &quot;+1&quot;)
        assertBadOctet(&quot;1.2.3.4e0&quot;, &quot;4e0&quot;)
        assertBadOctet(&quot;1.2.3.4::&quot;, &quot;4::&quot;)
        assertBadOctet(&quot;1.a.2.3&quot;, &quot;a&quot;)

    def test_octet_length(self):
        def assertBadOctet(addr, octet):
            msg = &quot;At most 3 characters permitted in %r in %r&quot;
            with self.assertAddressError(re.escape(msg % (octet, addr))):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;0000.000.000.000&quot;, &quot;0000&quot;)
        assertBadOctet(&quot;12345.67899.-54321.-98765&quot;, &quot;12345&quot;)

    def test_octet_limit(self):
        def assertBadOctet(addr, octet):
            msg = &quot;Octet %d (&gt; 255) not permitted in %r&quot; % (octet, addr)
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv4Address(addr)

        assertBadOctet(&quot;257.0.0.0&quot;, 257)
        assertBadOctet(&quot;192.168.0.999&quot;, 999)

    def test_pickle(self):
        self.pickle_test(&quot;192.0.2.1&quot;)

    def test_weakref(self):
        weakref.ref(self.factory(&quot;192.0.2.1&quot;))


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class AddressTestCase_v6(BaseTestCase, CommonTestMixin_v6):
    factory = ipaddress.IPv6Address

    @pytest.mark.skipif(sys.version_info &lt; (3, 6), reason=&quot;Don't run on Py3.5&quot;)
    def test_format(self):

        v6 = ipaddress.IPv6Address(&quot;::1.2.3.42&quot;)
        v6_pairs = [
            (
                &quot;b&quot;,
                &quot;000000000000000000000000000000000000000000000000000000&quot;
                &quot;000000000000000000000000000000000000000000000000010000&quot;
                &quot;00100000001100101010&quot;,
            ),
            (&quot;n&quot;, &quot;0000000000000000000000000102032a&quot;),
            (&quot;x&quot;, &quot;0000000000000000000000000102032a&quot;),
            (&quot;X&quot;, &quot;0000000000000000000000000102032A&quot;),
            (
                &quot;_b&quot;,
                &quot;0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0001_0000_0010_0000_0011_0010&quot;
                &quot;_1010&quot;,
            ),
            (&quot;_n&quot;, &quot;0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;_x&quot;, &quot;0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;_X&quot;, &quot;0000_0000_0000_0000_0000_0000_0102_032A&quot;),
            (
                &quot;#b&quot;,
                &quot;0b0000000000000000000000000000000000000000000000000000&quot;
                &quot;000000000000000000000000000000000000000000000000000100&quot;
                &quot;0000100000001100101010&quot;,
            ),
            (&quot;#n&quot;, &quot;0x0000000000000000000000000102032a&quot;),
            (&quot;#x&quot;, &quot;0x0000000000000000000000000102032a&quot;),
            (&quot;#X&quot;, &quot;0X0000000000000000000000000102032A&quot;),
            (
                &quot;#_b&quot;,
                &quot;0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000&quot;
                &quot;_0000_0000_0000_0000_0000_0001_0000_0010_0000_0011&quot;
                &quot;_0010_1010&quot;,
            ),
            (&quot;#_n&quot;, &quot;0x0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;#_x&quot;, &quot;0x0000_0000_0000_0000_0000_0000_0102_032a&quot;),
            (&quot;#_X&quot;, &quot;0X0000_0000_0000_0000_0000_0000_0102_032A&quot;),
            (&quot;s&quot;, &quot;::102:32a&quot;),
            (&quot;&quot;, &quot;::102:32a&quot;),
        ]

        for (fmt, txt) in v6_pairs:
            self.assertEqual(txt, format(v6, fmt))

    def test_network_passed_as_address(self):
        def assertBadSplit(addr):
            msg = &quot;Unexpected '/' in %r&quot;
            with self.assertAddressError(msg, addr):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;::1/24&quot;)
        assertBadSplit(&quot;::1%scope_id/24&quot;)

    def test_bad_address_split_v6_not_enough_parts(self):
        def assertBadSplit(addr):
            msg = &quot;At least 3 parts expected in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;:&quot;)
        assertBadSplit(&quot;:1&quot;)
        assertBadSplit(&quot;FEDC:9878&quot;)
        assertBadSplit(&quot;:%scope&quot;)
        assertBadSplit(&quot;:1%scope&quot;)
        assertBadSplit(&quot;FEDC:9878%scope&quot;)

    def test_bad_address_split_v6_too_many_colons(self):
        def assertBadSplit(addr):
            msg = &quot;At most 8 colons permitted in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;9:8:7:6:5:4:3::2:1&quot;)
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:2:1&quot;)
        assertBadSplit(&quot;::8:7:6:5:4:3:2:1&quot;)
        assertBadSplit(&quot;8:7:6:5:4:3:2:1::&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:42.42.42.42&quot;)

        assertBadSplit(&quot;9:8:7:6:5:4:3::2:1%scope&quot;)
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:2:1%scope&quot;)
        assertBadSplit(&quot;::8:7:6:5:4:3:2:1%scope&quot;)
        assertBadSplit(&quot;8:7:6:5:4:3:2:1::%scope&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;10:9:8:7:6:5:4:3:42.42.42.42%scope&quot;)

    def test_bad_address_split_v6_too_many_parts(self):
        def assertBadSplit(addr):
            msg = &quot;Exactly 8 parts expected without '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;3ffe:0:0:0:0:0:0:0:1&quot;)
        assertBadSplit(&quot;9:8:7:6:5:4:3:2:1&quot;)
        assertBadSplit(&quot;7:6:5:4:3:2:1&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;9:8:7:6:5:4:3:42.42.42.42&quot;)
        assertBadSplit(&quot;7:6:5:4:3:42.42.42.42&quot;)

        assertBadSplit(&quot;3ffe:0:0:0:0:0:0:0:1%scope&quot;)
        assertBadSplit(&quot;9:8:7:6:5:4:3:2:1%scope&quot;)
        assertBadSplit(&quot;7:6:5:4:3:2:1%scope&quot;)
        # A trailing IPv4 address is two parts
        assertBadSplit(&quot;9:8:7:6:5:4:3:42.42.42.42%scope&quot;)
        assertBadSplit(&quot;7:6:5:4:3:42.42.42.42%scope&quot;)

    def test_bad_address_split_v6_too_many_parts_with_double_colon(self):
        def assertBadSplit(addr):
            msg = &quot;Expected at most 7 other parts with '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;1:2:3:4::5:6:7:8&quot;)
        assertBadSplit(&quot;1:2:3:4::5:6:7:8%scope&quot;)

    def test_bad_address_split_v6_repeated_double_colon(self):
        def assertBadSplit(addr):
            msg = &quot;At most one '::' permitted in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;3ffe::1::1&quot;)
        assertBadSplit(&quot;1::2::3::4:5&quot;)
        assertBadSplit(&quot;2001::db:::1&quot;)
        assertBadSplit(&quot;3ffe::1::&quot;)
        assertBadSplit(&quot;::3ffe::1&quot;)
        assertBadSplit(&quot;:3ffe::1::1&quot;)
        assertBadSplit(&quot;3ffe::1::1:&quot;)
        assertBadSplit(&quot;:3ffe::1::1:&quot;)
        assertBadSplit(&quot;:::&quot;)
        assertBadSplit(&quot;2001:db8:::1&quot;)

        assertBadSplit(&quot;3ffe::1::1%scope&quot;)
        assertBadSplit(&quot;1::2::3::4:5%scope&quot;)
        assertBadSplit(&quot;2001::db:::1%scope&quot;)
        assertBadSplit(&quot;3ffe::1::%scope&quot;)
        assertBadSplit(&quot;::3ffe::1%scope&quot;)
        assertBadSplit(&quot;:3ffe::1::1%scope&quot;)
        assertBadSplit(&quot;3ffe::1::1:%scope&quot;)
        assertBadSplit(&quot;:3ffe::1::1:%scope&quot;)
        assertBadSplit(&quot;:::%scope&quot;)
        assertBadSplit(&quot;2001:db8:::1%scope&quot;)

    def test_bad_address_split_v6_leading_colon(self):
        def assertBadSplit(addr):
            msg = &quot;Leading ':' only permitted as part of '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;:2001:db8::1&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:7&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:&quot;)
        assertBadSplit(&quot;:6:5:4:3:2:1::&quot;)

        assertBadSplit(&quot;:2001:db8::1%scope&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:7%scope&quot;)
        assertBadSplit(&quot;:1:2:3:4:5:6:%scope&quot;)
        assertBadSplit(&quot;:6:5:4:3:2:1::%scope&quot;)

    def test_bad_address_split_v6_trailing_colon(self):
        def assertBadSplit(addr):
            msg = &quot;Trailing ':' only permitted as part of '::' in %r&quot;
            with self.assertAddressError(msg, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadSplit(&quot;2001:db8::1:&quot;)
        assertBadSplit(&quot;1:2:3:4:5:6:7:&quot;)
        assertBadSplit(&quot;::1.2.3.4:&quot;)
        assertBadSplit(&quot;::7:6:5:4:3:2:&quot;)

        assertBadSplit(&quot;2001:db8::1:%scope&quot;)
        assertBadSplit(&quot;1:2:3:4:5:6:7:%scope&quot;)
        assertBadSplit(&quot;::1.2.3.4:%scope&quot;)
        assertBadSplit(&quot;::7:6:5:4:3:2:%scope&quot;)

    def test_bad_v4_part_in(self):
        def assertBadAddressPart(addr, v4_error):
            with self.assertAddressError(&quot;%s in %r&quot;, v4_error, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadAddressPart(&quot;3ffe::1.net&quot;, &quot;Expected 4 octets in '1.net'&quot;)
        assertBadAddressPart(&quot;3ffe::127.0.1&quot;, &quot;Expected 4 octets in '127.0.1'&quot;)
        assertBadAddressPart(&quot;::1.2.3&quot;, &quot;Expected 4 octets in '1.2.3'&quot;)
        assertBadAddressPart(&quot;::1.2.3.4.5&quot;, &quot;Expected 4 octets in '1.2.3.4.5'&quot;)
        assertBadAddressPart(
            &quot;3ffe::1.1.1.net&quot;,
            &quot;Only decimal digits permitted in 'net' in '1.1.1.net'&quot;,
        )

        assertBadAddressPart(&quot;3ffe::1.net%scope&quot;, &quot;Expected 4 octets in '1.net'&quot;)
        assertBadAddressPart(&quot;3ffe::127.0.1%scope&quot;, &quot;Expected 4 octets in '127.0.1'&quot;)
        assertBadAddressPart(&quot;::1.2.3%scope&quot;, &quot;Expected 4 octets in '1.2.3'&quot;)
        assertBadAddressPart(&quot;::1.2.3.4.5%scope&quot;, &quot;Expected 4 octets in '1.2.3.4.5'&quot;)
        assertBadAddressPart(
            &quot;3ffe::1.1.1.net%scope&quot;,
            &quot;Only decimal digits permitted in 'net' in '1.1.1.net'&quot;,
        )

    def test_invalid_characters(self):
        def assertBadPart(addr, part):
            msg = &quot;Only hex digits permitted in {!r} in {!r}&quot;.format(
                part, addr.split(&quot;%&quot;)[0]
            )
            with self.assertAddressError(re.escape(msg)):
                ipaddress.IPv6Address(addr)

        assertBadPart(&quot;3ffe::goog&quot;, &quot;goog&quot;)
        assertBadPart(&quot;3ffe::-0&quot;, &quot;-0&quot;)
        assertBadPart(&quot;3ffe::+0&quot;, &quot;+0&quot;)
        assertBadPart(&quot;3ffe::-1&quot;, &quot;-1&quot;)
        assertBadPart(&quot;1.2.3.4::&quot;, &quot;1.2.3.4&quot;)
        assertBadPart(&quot;1234:axy::b&quot;, &quot;axy&quot;)

        assertBadPart(&quot;3ffe::goog%scope&quot;, &quot;goog&quot;)
        assertBadPart(&quot;3ffe::-0%scope&quot;, &quot;-0&quot;)
        assertBadPart(&quot;3ffe::+0%scope&quot;, &quot;+0&quot;)
        assertBadPart(&quot;3ffe::-1%scope&quot;, &quot;-1&quot;)
        assertBadPart(&quot;1.2.3.4::%scope&quot;, &quot;1.2.3.4&quot;)
        assertBadPart(&quot;1234:axy::b%scope&quot;, &quot;axy&quot;)

    def test_part_length(self):
        def assertBadPart(addr, part):
            msg = &quot;At most 4 characters permitted in %r in %r&quot;
            with self.assertAddressError(msg, part, addr.split(&quot;%&quot;)[0]):
                ipaddress.IPv6Address(addr)

        assertBadPart(&quot;::00000&quot;, &quot;00000&quot;)
        assertBadPart(&quot;3ffe::10000&quot;, &quot;10000&quot;)
        assertBadPart(&quot;02001:db8::&quot;, &quot;02001&quot;)
        assertBadPart(&quot;2001:888888::1&quot;, &quot;888888&quot;)

        assertBadPart(&quot;::00000%scope&quot;, &quot;00000&quot;)
        assertBadPart(&quot;3ffe::10000%scope&quot;, &quot;10000&quot;)
        assertBadPart(&quot;02001:db8::%scope&quot;, &quot;02001&quot;)
        assertBadPart(&quot;2001:888888::1%scope&quot;, &quot;888888&quot;)

    def test_pickle(self):
        self.pickle_test(&quot;2001:db8::&quot;)

    def test_weakref(self):
        weakref.ref(self.factory(&quot;2001:db8::&quot;))
        weakref.ref(self.factory(&quot;2001:db8::%scope&quot;))


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetmaskTestMixin_v4(CommonTestMixin_v4):
    &quot;&quot;&quot;Input validation on interfaces and networks is very similar&quot;&quot;&quot;

    def test_no_mask(self):
        for address in (&quot;1.2.3.4&quot;, 0x01020304, b&quot;\x01\x02\x03\x04&quot;):
            net = self.factory(address)
            self.assertEqual(str(net), &quot;1.2.3.4/32&quot;)
            self.assertEqual(str(net.netmask), &quot;255.255.255.255&quot;)
            self.assertEqual(str(net.hostmask), &quot;0.0.0.0&quot;)
            # IPv4Network has prefixlen, but IPv4Interface doesn't.
            # Should we add it to IPv4Interface too? (bpo-36392)

    def test_split_netmask(self):
        addr = &quot;1.2.3.4/32/24&quot;
        with self.assertAddressError(&quot;Only one '/' permitted in %r&quot; % addr):
            self.factory(addr)

    def test_address_errors(self):
        def assertBadAddress(addr, details):
            with self.assertAddressError(details):
                self.factory(addr)

        assertBadAddress(&quot;/&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;/8&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;bogus&quot;, &quot;Expected 4 octets&quot;)
        assertBadAddress(&quot;google.com&quot;, &quot;Expected 4 octets&quot;)
        assertBadAddress(&quot;10/8&quot;, &quot;Expected 4 octets&quot;)
        assertBadAddress(&quot;::1.2.3.4&quot;, &quot;Only decimal digits&quot;)
        assertBadAddress(&quot;1.2.3.256&quot;, re.escape(&quot;256 (&gt; 255)&quot;))

    def test_valid_netmask(self):
        self.assertEqual(str(self.factory(&quot;192.0.2.0/255.255.255.0&quot;)), &quot;192.0.2.0/24&quot;)
        for i in range(0, 33):
            # Generate and re-parse the CIDR format (trivial).
            net_str = &quot;0.0.0.0/%d&quot; % i
            net = self.factory(net_str)
            self.assertEqual(str(net), net_str)
            # Generate and re-parse the expanded netmask.
            self.assertEqual(str(self.factory(&quot;0.0.0.0/%s&quot; % net.netmask)), net_str)
            # Zero prefix is treated as decimal.
            self.assertEqual(str(self.factory(&quot;0.0.0.0/0%d&quot; % i)), net_str)
            # Generate and re-parse the expanded hostmask.  The ambiguous
            # cases (/0 and /32) are treated as netmasks.
            if i in (32, 0):
                net_str = &quot;0.0.0.0/%d&quot; % (32 - i)
            self.assertEqual(str(self.factory(&quot;0.0.0.0/%s&quot; % net.hostmask)), net_str)

    def test_netmask_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory(&quot;{}/{}&quot;.format(addr, netmask))

        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;-1&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;+1&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot; 1 &quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;0x1&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;33&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;254.254.255.256&quot;)
        assertBadNetmask(&quot;1.2.3.4&quot;, &quot;1.a.2.3&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;254.xyz.2.3&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;240.255.0.0&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;255.254.128.0&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;0.1.127.255&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;pudding&quot;)
        assertBadNetmask(&quot;1.1.1.1&quot;, &quot;::&quot;)

    def test_netmask_in_tuple_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory((addr, netmask))

        assertBadNetmask(&quot;1.1.1.1&quot;, -1)
        assertBadNetmask(&quot;1.1.1.1&quot;, 33)

    def test_pickle(self):
        self.pickle_test(&quot;192.0.2.0/27&quot;)
        self.pickle_test(&quot;192.0.2.0/31&quot;)  # IPV4LENGTH - 1
        self.pickle_test(&quot;192.0.2.0&quot;)  # IPV4LENGTH


class InterfaceTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
    factory = ipaddress.IPv4Interface


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetworkTestCase_v4(BaseTestCase, NetmaskTestMixin_v4):
    factory = ipaddress.IPv4Network

    def test_subnet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).subnet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee inside container
        self.assertTrue(
            self.factory(&quot;10.0.0.0/30&quot;).subnet_of(self.factory(&quot;10.0.0.0/24&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).subnet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee larger than container
        self.assertFalse(
            self.factory(&quot;10.0.1.0/24&quot;).subnet_of(self.factory(&quot;10.0.0.0/30&quot;))
        )

    def test_supernet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).supernet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee inside container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).supernet_of(self.factory(&quot;10.0.0.0/24&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;10.0.0.0/30&quot;).supernet_of(self.factory(&quot;10.0.1.0/24&quot;))
        )
        # containee larger than container
        self.assertTrue(
            self.factory(&quot;10.0.0.0/24&quot;).supernet_of(self.factory(&quot;10.0.0.0/30&quot;))
        )

    def test_subnet_of_mixed_types(self):
        with self.assertRaises(TypeError):
            ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;).supernet_of(
                ipaddress.IPv6Network(&quot;::1/128&quot;)
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv6Network(&quot;::1/128&quot;).supernet_of(
                ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;)
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;).subnet_of(
                ipaddress.IPv6Network(&quot;::1/128&quot;)
            )
        with self.assertRaises(TypeError):
            ipaddress.IPv6Network(&quot;::1/128&quot;).subnet_of(
                ipaddress.IPv4Network(&quot;10.0.0.0/30&quot;)
            )


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetmaskTestMixin_v6(CommonTestMixin_v6):
    &quot;&quot;&quot;Input validation on interfaces and networks is very similar&quot;&quot;&quot;

    def test_no_mask(self):
        for address in (&quot;::1&quot;, 1, b&quot;\x00&quot; * 15 + b&quot;\x01&quot;):
            net = self.factory(address)
            self.assertEqual(str(net), &quot;::1/128&quot;)
            self.assertEqual(
                str(net.netmask), &quot;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;
            )
            self.assertEqual(str(net.hostmask), &quot;::&quot;)
            # IPv6Network has prefixlen, but IPv6Interface doesn't.
            # Should we add it to IPv4Interface too? (bpo-36392)

        scoped_net = self.factory(&quot;::1%scope&quot;)
        self.assertEqual(str(scoped_net), &quot;::1%scope/128&quot;)
        self.assertEqual(
            str(scoped_net.netmask), &quot;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;
        )
        self.assertEqual(str(scoped_net.hostmask), &quot;::&quot;)

    def test_split_netmask(self):
        addr = &quot;cafe:cafe::/128/190&quot;
        with self.assertAddressError(&quot;Only one '/' permitted in %r&quot; % addr):
            self.factory(addr)

        scoped_addr = &quot;cafe:cafe::%scope/128/190&quot;
        with self.assertAddressError(&quot;Only one '/' permitted in %r&quot; % scoped_addr):
            self.factory(scoped_addr)

    def test_address_errors(self):
        def assertBadAddress(addr, details):
            with self.assertAddressError(details):
                self.factory(addr)

        assertBadAddress(&quot;/&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;/8&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;google.com&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1.2.3.4&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;10/8&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1234:axy::b&quot;, &quot;Only hex digits&quot;)

        assertBadAddress(&quot;/%scope&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;/%scope8&quot;, &quot;Address cannot be empty&quot;)
        assertBadAddress(&quot;google.com%scope&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1.2.3.4%scope&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;10%scope/8&quot;, &quot;At least 3 parts&quot;)
        assertBadAddress(&quot;1234:axy::b%scope&quot;, &quot;Only hex digits&quot;)

    def test_valid_netmask(self):
        # We only support CIDR for IPv6, because expanded netmasks are not
        # standard notation.
        self.assertEqual(str(self.factory(&quot;2001:db8::/32&quot;)), &quot;2001:db8::/32&quot;)
        for i in range(0, 129):
            # Generate and re-parse the CIDR format (trivial).
            net_str = &quot;::/%d&quot; % i
            self.assertEqual(str(self.factory(net_str)), net_str)
            # Zero prefix is treated as decimal.
            self.assertEqual(str(self.factory(&quot;::/0%d&quot; % i)), net_str)

        self.assertEqual(
            str(self.factory(&quot;2001:db8::%scope/32&quot;)), &quot;2001:db8::%scope/32&quot;
        )
        for i in range(0, 129):
            # Generate and re-parse the CIDR format (trivial).
            net_str = &quot;::/%d&quot; % i
            self.assertEqual(str(self.factory(net_str)), net_str)
            # Zero prefix is treated as decimal.
            self.assertEqual(str(self.factory(&quot;::/0%d&quot; % i)), net_str)

    def test_netmask_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory(&quot;{}/{}&quot;.format(addr, netmask))

        assertBadNetmask(&quot;::1&quot;, &quot;&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;::1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;1::&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;-1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;+1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot; 1 &quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;0x1&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;129&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;1.2.3.4&quot;)
        assertBadNetmask(&quot;::1&quot;, &quot;pudding&quot;)
        assertBadNetmask(&quot;::&quot;, &quot;::&quot;)

        assertBadNetmask(&quot;::1%scope&quot;, &quot;pudding&quot;)

    def test_netmask_in_tuple_errors(self):
        def assertBadNetmask(addr, netmask):
            msg = &quot;%r is not a valid netmask&quot; % netmask
            with self.assertNetmaskError(re.escape(msg)):
                self.factory((addr, netmask))

        assertBadNetmask(&quot;::1&quot;, -1)
        assertBadNetmask(&quot;::1&quot;, 129)
        assertBadNetmask(&quot;::1%scope&quot;, 129)

    def test_pickle(self):
        self.pickle_test(&quot;2001:db8::1000/124&quot;)
        self.pickle_test(&quot;2001:db8::1000/127&quot;)  # IPV6LENGTH - 1
        self.pickle_test(&quot;2001:db8::1000&quot;)  # IPV6LENGTH

        self.pickle_test(&quot;2001:db8::1000%scope&quot;)  # IPV6LENGTH


class InterfaceTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
    factory = ipaddress.IPv6Interface


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class NetworkTestCase_v6(BaseTestCase, NetmaskTestMixin_v6):
    factory = ipaddress.IPv6Network

    def test_subnet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;2000:999::/56&quot;).subnet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee inside container
        self.assertTrue(
            self.factory(&quot;2000:aaa::/56&quot;).subnet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;2000:bbb::/56&quot;).subnet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee larger than container
        self.assertFalse(
            self.factory(&quot;2000:aaa::/48&quot;).subnet_of(self.factory(&quot;2000:aaa::/56&quot;))
        )

        self.assertFalse(
            self.factory(&quot;2000:999::%scope/56&quot;).subnet_of(
                self.factory(&quot;2000:aaa::%scope/48&quot;)
            )
        )
        self.assertTrue(
            self.factory(&quot;2000:aaa::%scope/56&quot;).subnet_of(
                self.factory(&quot;2000:aaa::%scope/48&quot;)
            )
        )

    def test_supernet_of(self):
        # containee left of container
        self.assertFalse(
            self.factory(&quot;2000:999::/56&quot;).supernet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee inside container
        self.assertFalse(
            self.factory(&quot;2000:aaa::/56&quot;).supernet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee right of container
        self.assertFalse(
            self.factory(&quot;2000:bbb::/56&quot;).supernet_of(self.factory(&quot;2000:aaa::/48&quot;))
        )
        # containee larger than container
        self.assertTrue(
            self.factory(&quot;2000:aaa::/48&quot;).supernet_of(self.factory(&quot;2000:aaa::/56&quot;))
        )


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class FactoryFunctionErrors(BaseTestCase):
    def assertFactoryError(self, factory, kind):
        &quot;&quot;&quot;Ensure a clean ValueError with the expected message&quot;&quot;&quot;
        addr = &quot;camelot&quot;
        msg = &quot;%r does not appear to be an IPv4 or IPv6 %s&quot;
        with self.assertCleanError(ValueError, msg, addr, kind):
            factory(addr)

    def test_ip_address(self):
        self.assertFactoryError(ipaddress.ip_address, &quot;address&quot;)

    def test_ip_interface(self):
        self.assertFactoryError(ipaddress.ip_interface, &quot;interface&quot;)

    def test_ip_network(self):
        self.assertFactoryError(ipaddress.ip_network, &quot;network&quot;)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class ComparisonTests(TestCase):

    v4addr = ipaddress.IPv4Address(1)
    v4net = ipaddress.IPv4Network(1)
    v4intf = ipaddress.IPv4Interface(1)
    v6addr = ipaddress.IPv6Address(1)
    v6net = ipaddress.IPv6Network(1)
    v6intf = ipaddress.IPv6Interface(1)
    v6addr_scoped = ipaddress.IPv6Address(&quot;::1%scope&quot;)
    v6net_scoped = ipaddress.IPv6Network(&quot;::1%scope&quot;)
    v6intf_scoped = ipaddress.IPv6Interface(&quot;::1%scope&quot;)

    v4_addresses = [v4addr, v4intf]
    v4_objects = v4_addresses + [v4net]
    v6_addresses = [v6addr, v6intf]
    v6_objects = v6_addresses + [v6net]
    v6_scoped_addresses = [v6addr_scoped, v6intf_scoped]
<A NAME="0"></A>    v6_scoped_objects = v6_scoped_addresses + [v6net_scoped]

    objects = v4_objects + v6_objects
    objects_with_scoped <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match274491-0.html#0',2,'match274491-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= objects + v6_scoped_objects

    v4addr2 = ipaddress.IPv4Address(2)
    v4net2 = ipaddress.IPv4Network(2)
    v4intf2 = ipaddress.IPv4Interface(2)
    v6addr2 = ipaddress.IPv6Address(2)
    v6net2 =</B></FONT> ipaddress.IPv6Network(2)
    v6intf2 = ipaddress.IPv6Interface(2)
    v6addr2_scoped = ipaddress.IPv6Address(&quot;::2%scope&quot;)
    v6net2_scoped = ipaddress.IPv6Network(&quot;::2%scope&quot;)
    v6intf2_scoped = ipaddress.IPv6Interface(&quot;::2%scope&quot;)

    def test_foreign_type_equality(self):
        # __eq__ should never raise TypeError directly
        other = object()
        for obj in self.objects_with_scoped:
            self.assertNotEqual(obj, other)
            self.assertFalse(obj == other)
            self.assertEqual(obj.__eq__(other), NotImplemented)
            self.assertEqual(obj.__ne__(other), NotImplemented)

    def test_mixed_type_equality(self):
        # Ensure none of the internal objects accidentally
        # expose the right set of attributes to become &quot;equal&quot;
        for lhs in self.objects:
            for rhs in self.objects:
                if lhs is rhs:
                    continue
                self.assertNotEqual(lhs, rhs)

    def test_scoped_ipv6_equality(self):
        for lhs, rhs in zip(self.v6_objects, self.v6_scoped_objects):
            self.assertNotEqual(lhs, rhs)

    def test_v4_with_v6_scoped_equality(self):
        for lhs in self.v4_objects:
            for rhs in self.v6_scoped_objects:
                self.assertNotEqual(lhs, rhs)

    def test_same_type_equality(self):
        for obj in self.objects_with_scoped:
            self.assertEqual(obj, obj)
            self.assertLessEqual(obj, obj)
            self.assertGreaterEqual(obj, obj)

    def test_same_type_ordering(self):
        for lhs, rhs in (
            (self.v4addr, self.v4addr2),
            (self.v4net, self.v4net2),
            (self.v4intf, self.v4intf2),
            (self.v6addr, self.v6addr2),
            (self.v6net, self.v6net2),
            (self.v6intf, self.v6intf2),
            (self.v6addr_scoped, self.v6addr2_scoped),
            (self.v6net_scoped, self.v6net2_scoped),
            (self.v6intf_scoped, self.v6intf2_scoped),
        ):
            self.assertNotEqual(lhs, rhs)
            self.assertLess(lhs, rhs)
            self.assertLessEqual(lhs, rhs)
            self.assertGreater(rhs, lhs)
            self.assertGreaterEqual(rhs, lhs)
            self.assertFalse(lhs &gt; rhs)
            self.assertFalse(rhs &lt; lhs)
            self.assertFalse(lhs &gt;= rhs)
            self.assertFalse(rhs &lt;= lhs)

    def test_containment(self):
        for obj in self.v4_addresses:
            self.assertIn(obj, self.v4net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net)
        for obj in self.v6_addresses + self.v6_scoped_addresses:
            self.assertIn(obj, self.v6net_scoped)

        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net)
        for obj in self.v4_objects + [self.v6net, self.v6net_scoped]:
            self.assertNotIn(obj, self.v6net_scoped)
        for obj in self.v6_objects + self.v6_scoped_objects + [self.v4net]:
            self.assertNotIn(obj, self.v4net)

    def test_mixed_type_ordering(self):
        for lhs in self.objects_with_scoped:
            for rhs in self.objects_with_scoped:
                if isinstance(lhs, type(rhs)) or isinstance(rhs, type(lhs)):
                    continue
                self.assertRaises(TypeError, lambda: lhs &lt; rhs)
                self.assertRaises(TypeError, lambda: lhs &gt; rhs)
                self.assertRaises(TypeError, lambda: lhs &lt;= rhs)
                self.assertRaises(TypeError, lambda: lhs &gt;= rhs)

    def test_foreign_type_ordering(self):
        other = object()
        for obj in self.objects_with_scoped:
            with self.assertRaises(TypeError):
                obj &lt; other
            with self.assertRaises(TypeError):
                obj &gt; other
            with self.assertRaises(TypeError):
                obj &lt;= other
            with self.assertRaises(TypeError):
                obj &gt;= other
            self.assertTrue(obj &lt; LARGEST)
            self.assertFalse(obj &gt; LARGEST)
            self.assertTrue(obj &lt;= LARGEST)
            self.assertFalse(obj &gt;= LARGEST)
            self.assertFalse(obj &lt; SMALLEST)
            self.assertTrue(obj &gt; SMALLEST)
            self.assertFalse(obj &lt;= SMALLEST)
            self.assertTrue(obj &gt;= SMALLEST)

    def test_mixed_type_key(self):
        # with get_mixed_type_key, you can sort addresses and network.
        v4_ordered = [self.v4addr, self.v4net, self.v4intf]
        v6_ordered = [self.v6addr, self.v6net, self.v6intf]
        v6_scoped_ordered = [self.v6addr_scoped, self.v6net_scoped, self.v6intf_scoped]
        self.assertEqual(
            v4_ordered, sorted(self.v4_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_ordered, sorted(self.v6_objects, key=ipaddress.get_mixed_type_key)
        )
        self.assertEqual(
            v6_scoped_ordered,
            sorted(self.v6_scoped_objects, key=ipaddress.get_mixed_type_key),
        )
        self.assertEqual(
            v4_ordered + v6_scoped_ordered,
            sorted(
                self.v4_objects + self.v6_scoped_objects,
                key=ipaddress.get_mixed_type_key,
            ),
        )
        self.assertEqual(NotImplemented, ipaddress.get_mixed_type_key(object))

    def test_incompatible_versions(self):
        # These should always raise TypeError
        v4addr = ipaddress.ip_address(&quot;1.1.1.1&quot;)
        v4net = ipaddress.ip_network(&quot;1.1.1.1&quot;)
        v6addr = ipaddress.ip_address(&quot;::1&quot;)
        v6net = ipaddress.ip_network(&quot;::1&quot;)
<A NAME="1"></A>        v6addr_scoped = ipaddress.ip_address(&quot;::1%scope&quot;)
        v6net_scoped = ipaddress.ip_network(&quot;::1%scope&quot;)

        self.assertRaises(TypeError, v4addr<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match274491-0.html#1',2,'match274491-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.__lt__, v6addr)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr)
        self.assertRaises(TypeError, v4net.__lt__, v6net)
        self.assertRaises(TypeError, v4net.__gt__, v6net)

        self.assertRaises(</B></FONT>TypeError, v6addr.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr.__gt__, v4addr)
        self.assertRaises(TypeError, v6net.__lt__, v4net)
        self.assertRaises(TypeError, v6net.__gt__, v4net)

        self.assertRaises(TypeError, v4addr.__lt__, v6addr_scoped)
        self.assertRaises(TypeError, v4addr.__gt__, v6addr_scoped)
        self.assertRaises(TypeError, v4net.__lt__, v6net_scoped)
        self.assertRaises(TypeError, v4net.__gt__, v6net_scoped)

        self.assertRaises(TypeError, v6addr_scoped.__lt__, v4addr)
        self.assertRaises(TypeError, v6addr_scoped.__gt__, v4addr)
        self.assertRaises(TypeError, v6net_scoped.__lt__, v4net)
        self.assertRaises(TypeError, v6net_scoped.__gt__, v4net)


@skipIf(sys.version_info &gt;= (3, 9, 5), &quot;We use builtin ipaddress on Python &gt;= 3.9.5&quot;)
class IpaddrUnitTest(TestCase):
    def setUp(self):
        self.ipv4_address = ipaddress.IPv4Address(&quot;1.2.3.4&quot;)
        self.ipv4_interface = ipaddress.IPv4Interface(&quot;1.2.3.4/24&quot;)
        self.ipv4_network = ipaddress.IPv4Network(&quot;1.2.3.0/24&quot;)
        # self.ipv4_hostmask = ipaddress.IPv4Interface('10.0.0.1/0.255.255.255')
        self.ipv6_address = ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:1&quot;)
        self.ipv6_interface = ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:1/64&quot;)
        self.ipv6_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::/64&quot;)
        self.ipv6_scoped_address = ipaddress.IPv6Interface(
            &quot;2001:658:22a:cafe:200:0:0:1%scope&quot;
        )
        self.ipv6_scoped_interface = ipaddress.IPv6Interface(
            &quot;2001:658:22a:cafe:200:0:0:1%scope/64&quot;
        )
        self.ipv6_scoped_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::%scope/64&quot;)

    def testRepr(self):
        self.assertEqual(
            &quot;IPv4Interface('1.2.3.4/32')&quot;, repr(ipaddress.IPv4Interface(&quot;1.2.3.4&quot;))
        )
        self.assertEqual(
            &quot;IPv6Interface('::1/128')&quot;, repr(ipaddress.IPv6Interface(&quot;::1&quot;))
        )
        self.assertEqual(
            &quot;IPv6Interface('::1%scope/128')&quot;, repr(ipaddress.IPv6Interface(&quot;::1%scope&quot;))
        )

    # issue #16531: constructing IPv4Network from an (address, mask) tuple
    def testIPv4Tuple(self):
        # /32
        ip = ipaddress.IPv4Address(&quot;192.0.2.1&quot;)
        net = ipaddress.IPv4Network(&quot;192.0.2.1/32&quot;)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.1&quot;, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 32)), net)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.1&quot;, &quot;255.255.255.255&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, &quot;255.255.255.255&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, &quot;255.255.255.255&quot;)), net)
        # strict=True and host bits set
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((&quot;192.0.2.1&quot;, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, 24))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((&quot;192.0.2.1&quot;, &quot;255.255.255.0&quot;))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((ip, &quot;255.255.255.0&quot;))
        with self.assertRaises(ValueError):
            ipaddress.IPv4Network((3221225985, &quot;255.255.255.0&quot;))
        # strict=False and host bits set
        net = ipaddress.IPv4Network(&quot;192.0.2.0/24&quot;)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.1&quot;, 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24), strict=False), net)
        self.assertEqual(ipaddress.IPv4Network((3221225985, 24), strict=False), net)
        self.assertEqual(
            ipaddress.IPv4Network((&quot;192.0.2.1&quot;, &quot;255.255.255.0&quot;), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((ip, &quot;255.255.255.0&quot;), strict=False), net
        )
        self.assertEqual(
            ipaddress.IPv4Network((3221225985, &quot;255.255.255.0&quot;), strict=False), net
        )

        # /24
        ip = ipaddress.IPv4Address(&quot;192.0.2.0&quot;)
        net = ipaddress.IPv4Network(&quot;192.0.2.0/24&quot;)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.0&quot;, &quot;255.255.255.0&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, &quot;255.255.255.0&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, &quot;255.255.255.0&quot;)), net)
        self.assertEqual(ipaddress.IPv4Network((&quot;192.0.2.0&quot;, 24)), net)
        self.assertEqual(ipaddress.IPv4Network((ip, 24)), net)
        self.assertEqual(ipaddress.IPv4Network((3221225984, 24)), net)

        self.assertEqual(
            ipaddress.IPv4Interface((&quot;192.0.2.1&quot;, 24)),
            ipaddress.IPv4Interface(&quot;192.0.2.1/24&quot;),
        )
        self.assertEqual(
            ipaddress.IPv4Interface((3221225985, 24)),
            ipaddress.IPv4Interface(&quot;192.0.2.1/24&quot;),
        )

    # issue #16531: constructing IPv6Network from an (address, mask) tuple
    def testIPv6Tuple(self):
        # /128
        ip = ipaddress.IPv6Address(&quot;2001:db8::&quot;)
        net = ipaddress.IPv6Network(&quot;2001:db8::/128&quot;)
        self.assertEqual(ipaddress.IPv6Network((&quot;2001:db8::&quot;, &quot;128&quot;)), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 128)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, &quot;128&quot;)), net)
        ip = ipaddress.IPv6Address(&quot;2001:db8::&quot;)
        net = ipaddress.IPv6Network(&quot;2001:db8::/96&quot;)
        self.assertEqual(ipaddress.IPv6Network((&quot;2001:db8::&quot;, &quot;96&quot;)), net)
        self.assertEqual(
            ipaddress.IPv6Network((42540766411282592856903984951653826560, 96)), net
        )
        self.assertEqual(ipaddress.IPv6Network((ip, &quot;96&quot;)), net)

        ip_scoped = ipaddress.IPv6Address(&quot;2001:db8::%scope&quot;)

        # strict=True and host bits set
        ip = ipaddress.IPv6Address(&quot;2001:db8::1&quot;)
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((&quot;2001:db8::1&quot;, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((42540766411282592856903984951653826561, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip, 96))
        # strict=False and host bits set
        net = ipaddress.IPv6Network(&quot;2001:db8::/96&quot;)
        self.assertEqual(ipaddress.IPv6Network((&quot;2001:db8::1&quot;, 96), strict=False), net)
        self.assertEqual(
            ipaddress.IPv6Network(
                (42540766411282592856903984951653826561, 96), strict=False
            ),
            net,
        )
        self.assertEqual(ipaddress.IPv6Network((ip, 96), strict=False), net)

        # /96
        self.assertEqual(
            ipaddress.IPv6Interface((&quot;2001:db8::1&quot;, &quot;96&quot;)),
            ipaddress.IPv6Interface(&quot;2001:db8::1/96&quot;),
        )
        self.assertEqual(
            ipaddress.IPv6Interface((42540766411282592856903984951653826561, &quot;96&quot;)),
            ipaddress.IPv6Interface(&quot;2001:db8::1/96&quot;),
        )

        ip_scoped = ipaddress.IPv6Address(&quot;2001:db8::1%scope&quot;)
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((&quot;2001:db8::1%scope&quot;, 96))
        with self.assertRaises(ValueError):
            ipaddress.IPv6Network((ip_scoped, 96))
        # strict=False and host bits set

    # issue57
    def testAddressIntMath(self):
        self.assertEqual(
            ipaddress.IPv4Address(&quot;1.1.1.1&quot;) + 255, ipaddress.IPv4Address(&quot;1.1.2.0&quot;)
        )
        self.assertEqual(
            ipaddress.IPv4Address(&quot;1.1.1.1&quot;) - 256, ipaddress.IPv4Address(&quot;1.1.0.1&quot;)
        )
        self.assertEqual(
            ipaddress.IPv6Address(&quot;::1&quot;) + (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::ffff&quot;),
        )
        self.assertEqual(
            ipaddress.IPv6Address(&quot;::ffff&quot;) - (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::1&quot;),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address(&quot;::1%scope&quot;) + (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::ffff%scope&quot;),
        )
        self.assertNotEqual(
            ipaddress.IPv6Address(&quot;::ffff%scope&quot;) - (2 ** 16 - 2),
            ipaddress.IPv6Address(&quot;::1%scope&quot;),
        )

    def testInvalidIntToBytes(self):
        self.assertRaises(ValueError, ipaddress.v4_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v4_int_to_packed, 2 ** ipaddress.IPV4LENGTH
        )
        self.assertRaises(ValueError, ipaddress.v6_int_to_packed, -1)
        self.assertRaises(
            ValueError, ipaddress.v6_int_to_packed, 2 ** ipaddress.IPV6LENGTH
        )

    def testInternals(self):
        ip1 = ipaddress.IPv4Address(&quot;10.10.10.10&quot;)
        ip2 = ipaddress.IPv4Address(&quot;10.10.10.11&quot;)
        ip3 = ipaddress.IPv4Address(&quot;10.10.10.12&quot;)
        self.assertEqual(list(ipaddress._find_address_range([ip1])), [(ip1, ip1)])
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip3])), [(ip1, ip1), (ip3, ip3)]
        )
        self.assertEqual(
            list(ipaddress._find_address_range([ip1, ip2, ip3])), [(ip1, ip3)]
        )
        self.assertEqual(128, ipaddress._count_righthand_zero_bits(0, 128))
        self.assertEqual(&quot;IPv4Network('1.2.3.0/24')&quot;, repr(self.ipv4_network))

    def testGetNetwork(self):
        self.assertEqual(int(self.ipv4_network.network_address), 16909056)
        self.assertEqual(str(self.ipv4_network.network_address), &quot;1.2.3.0&quot;)

        self.assertEqual(
            int(self.ipv6_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(str(self.ipv6_network.network_address), &quot;2001:658:22a:cafe::&quot;)
        self.assertEqual(str(self.ipv6_network.hostmask), &quot;::ffff:ffff:ffff:ffff&quot;)
        self.assertEqual(
            int(self.ipv6_scoped_network.network_address),
            42540616829182469433403647294022090752,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address), &quot;2001:658:22a:cafe::%scope&quot;
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.hostmask), &quot;::ffff:ffff:ffff:ffff&quot;
        )

    def testIpFromInt(self):
        self.assertEqual(self.ipv4_interface._ip, ipaddress.IPv4Interface(16909060)._ip)

        ipv4 = ipaddress.ip_network(&quot;1.2.3.4&quot;)
        ipv6 = ipaddress.ip_network(&quot;2001:658:22a:cafe:200:0:0:1&quot;)
        ipv6_scoped = ipaddress.ip_network(&quot;2001:658:22a:cafe:200:0:0:1%scope&quot;)
        self.assertEqual(ipv4, ipaddress.ip_network(int(ipv4.network_address)))
        self.assertEqual(ipv6, ipaddress.ip_network(int(ipv6.network_address)))
        self.assertNotEqual(
            ipv6_scoped, ipaddress.ip_network(int(ipv6_scoped.network_address))
        )

        v6_int = 42540616829182469433547762482097946625
        self.assertEqual(self.ipv6_interface._ip, ipaddress.IPv6Interface(v6_int)._ip)
        self.assertEqual(
            self.ipv6_scoped_interface._ip, ipaddress.IPv6Interface(v6_int)._ip
        )

        self.assertEqual(ipaddress.ip_network(self.ipv4_address._ip).version, 4)
        self.assertEqual(ipaddress.ip_network(self.ipv6_address._ip).version, 6)
        self.assertEqual(ipaddress.ip_network(self.ipv6_scoped_address._ip).version, 6)

    def testIpFromPacked(self):
        address = ipaddress.ip_address
        self.assertEqual(
            self.ipv4_interface._ip, ipaddress.ip_interface(b&quot;\x01\x02\x03\x04&quot;)._ip
        )
        self.assertEqual(address(&quot;255.254.253.252&quot;), address(b&quot;\xff\xfe\xfd\xfc&quot;))
        self.assertEqual(
            self.ipv6_interface.ip,
            ipaddress.ip_interface(
                b&quot;\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01&quot;
            ).ip,
        )
        self.assertEqual(
            address(&quot;ffff:2:3:4:ffff::&quot;),
            address(b&quot;\xff\xff\x00\x02\x00\x03\x00\x04&quot; + b&quot;\xff\xff&quot; + b&quot;\x00&quot; * 6),
        )
        self.assertEqual(address(&quot;::&quot;), address(b&quot;\x00&quot; * 16))

    def testGetIp(self):
        self.assertEqual(int(self.ipv4_interface.ip), 16909060)
        self.assertEqual(str(self.ipv4_interface.ip), &quot;1.2.3.4&quot;)

        self.assertEqual(
            int(self.ipv6_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_interface.ip), &quot;2001:658:22a:cafe:200::1&quot;)
        self.assertEqual(
            int(self.ipv6_scoped_interface.ip), 42540616829182469433547762482097946625
        )
        self.assertEqual(str(self.ipv6_scoped_interface.ip), &quot;2001:658:22a:cafe:200::1&quot;)

    def testGetScopeId(self):
        self.assertEqual(self.ipv6_address.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_address.scope_id), &quot;scope&quot;)
        self.assertEqual(self.ipv6_interface.scope_id, None)
        self.assertEqual(str(self.ipv6_scoped_interface.scope_id), &quot;scope&quot;)
        self.assertEqual(self.ipv6_network.network_address.scope_id, None)
        self.assertEqual(
            str(self.ipv6_scoped_network.network_address.scope_id), &quot;scope&quot;
        )

    def testGetNetmask(self):
        self.assertEqual(int(self.ipv4_network.netmask), 4294967040)
        self.assertEqual(str(self.ipv4_network.netmask), &quot;255.255.255.0&quot;)
        self.assertEqual(
            int(self.ipv6_network.netmask), 340282366920938463444927863358058659840
        )
        self.assertEqual(self.ipv6_network.prefixlen, 64)
        self.assertEqual(
            int(self.ipv6_scoped_network.netmask),
            340282366920938463444927863358058659840,
        )
        self.assertEqual(self.ipv6_scoped_network.prefixlen, 64)

    def testZeroNetmask(self):
        ipv4_zero_netmask = ipaddress.IPv4Interface(&quot;1.2.3.4/0&quot;)
        self.assertEqual(int(ipv4_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv4_zero_netmask._prefix_from_prefix_string(&quot;0&quot;), 0)

        ipv6_zero_netmask = ipaddress.IPv6Interface(&quot;::1/0&quot;)
        self.assertEqual(int(ipv6_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_zero_netmask._prefix_from_prefix_string(&quot;0&quot;), 0)

        ipv6_scoped_zero_netmask = ipaddress.IPv6Interface(&quot;::1%scope/0&quot;)
        self.assertEqual(int(ipv6_scoped_zero_netmask.network.netmask), 0)
        self.assertEqual(ipv6_scoped_zero_netmask._prefix_from_prefix_string(&quot;0&quot;), 0)

    def testIPv4Net(self):
        net = ipaddress.IPv4Network(&quot;127.0.0.0/0.0.0.255&quot;)
        self.assertEqual(net.prefixlen, 24)

    def testGetBroadcast(self):
        self.assertEqual(int(self.ipv4_network.broadcast_address), 16909311)
        self.assertEqual(str(self.ipv4_network.broadcast_address), &quot;1.2.3.255&quot;)

        self.assertEqual(
            int(self.ipv6_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_network.broadcast_address),
            &quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;,
        )

        self.assertEqual(
            int(self.ipv6_scoped_network.broadcast_address),
            42540616829182469451850391367731642367,
        )
        self.assertEqual(
            str(self.ipv6_scoped_network.broadcast_address),
            &quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;,
        )

    def testGetPrefixlen(self):
        self.assertEqual(self.ipv4_interface.network.prefixlen, 24)
        self.assertEqual(self.ipv6_interface.network.prefixlen, 64)
        self.assertEqual(self.ipv6_scoped_interface.network.prefixlen, 64)

    def testGetSupernet(self):
        self.assertEqual(self.ipv4_network.supernet().prefixlen, 23)
        self.assertEqual(str(self.ipv4_network.supernet().network_address), &quot;1.2.2.0&quot;)
        self.assertEqual(
            ipaddress.IPv4Interface(&quot;0.0.0.0/0&quot;).network.supernet(),
            ipaddress.IPv4Network(&quot;0.0.0.0/0&quot;),
        )

        self.assertEqual(self.ipv6_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_network.supernet().network_address), &quot;2001:658:22a:cafe::&quot;
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;::0/0&quot;).network.supernet(),
            ipaddress.IPv6Network(&quot;::0/0&quot;),
        )
        self.assertEqual(self.ipv6_scoped_network.supernet().prefixlen, 63)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet().network_address),
            &quot;2001:658:22a:cafe::&quot;,
        )

    def testGetSupernet3(self):
        self.assertEqual(self.ipv4_network.supernet(3).prefixlen, 21)
        self.assertEqual(str(self.ipv4_network.supernet(3).network_address), &quot;1.2.0.0&quot;)

        self.assertEqual(self.ipv6_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_network.supernet(3).network_address), &quot;2001:658:22a:caf8::&quot;
        )
        self.assertEqual(self.ipv6_scoped_network.supernet(3).prefixlen, 61)
        self.assertEqual(
            str(self.ipv6_scoped_network.supernet(3).network_address),
            &quot;2001:658:22a:caf8::&quot;,
        )

    def testGetSupernet4(self):
        self.assertRaises(
            ValueError, self.ipv4_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv4_network.supernet, new_prefix=25)
        self.assertEqual(
            self.ipv4_network.supernet(prefixlen_diff=2),
            self.ipv4_network.supernet(new_prefix=22),
        )

        self.assertRaises(
            ValueError, self.ipv6_network.supernet, prefixlen_diff=2, new_prefix=1
        )
        self.assertRaises(ValueError, self.ipv6_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_network.supernet(prefixlen_diff=2),
            self.ipv6_network.supernet(new_prefix=62),
        )
        self.assertRaises(
            ValueError,
            self.ipv6_scoped_network.supernet,
            prefixlen_diff=2,
            new_prefix=1,
        )
        self.assertRaises(ValueError, self.ipv6_scoped_network.supernet, new_prefix=65)
        self.assertEqual(
            self.ipv6_scoped_network.supernet(prefixlen_diff=2),
            self.ipv6_scoped_network.supernet(new_prefix=62),
        )

    def testHosts(self):
        hosts = list(self.ipv4_network.hosts())
        self.assertEqual(254, len(hosts))
        self.assertEqual(ipaddress.IPv4Address(&quot;1.2.3.1&quot;), hosts[0])
        self.assertEqual(ipaddress.IPv4Address(&quot;1.2.3.254&quot;), hosts[-1])

        ipv6_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::/120&quot;)
        hosts = list(ipv6_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;), hosts[0])
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::ff&quot;), hosts[-1])

        ipv6_scoped_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::%scope/120&quot;)
        hosts = list(ipv6_scoped_network.hosts())
        self.assertEqual(255, len(hosts))
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;), hosts[0])
        self.assertEqual(ipaddress.IPv6Address(&quot;2001:658:22a:cafe::ff&quot;), hosts[-1])

        # special case where only 1 bit is left for address
        addrs = [ipaddress.IPv4Address(&quot;2.0.0.0&quot;), ipaddress.IPv4Address(&quot;2.0.0.1&quot;)]
        str_args = &quot;2.0.0.0/31&quot;
        tpl_args = (&quot;2.0.0.0&quot;, 31)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

        # special case where the network is a /32
        addrs = [ipaddress.IPv4Address(&quot;1.2.3.4&quot;)]
        str_args = &quot;1.2.3.4/32&quot;
        tpl_args = (&quot;1.2.3.4&quot;, 32)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

        addrs = [
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::&quot;),
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;),
        ]
        str_args = &quot;2001:658:22a:cafe::/127&quot;
        tpl_args = (&quot;2001:658:22a:cafe::&quot;, 127)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

        addrs = [
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::1&quot;),
        ]
        str_args = &quot;2001:658:22a:cafe::1/128&quot;
        tpl_args = (&quot;2001:658:22a:cafe::1&quot;, 128)
        self.assertEqual(addrs, list(ipaddress.ip_network(str_args).hosts()))
        self.assertEqual(addrs, list(ipaddress.ip_network(tpl_args).hosts()))
        self.assertEqual(
            list(ipaddress.ip_network(str_args).hosts()),
            list(ipaddress.ip_network(tpl_args).hosts()),
        )

    def testFancySubnetting(self):
        self.assertEqual(
            sorted(self.ipv4_network.subnets(prefixlen_diff=3)),
            sorted(self.ipv4_network.subnets(new_prefix=27)),
        )
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(new_prefix=23))
        self.assertRaises(
            ValueError, list, self.ipv4_network.subnets(prefixlen_diff=3, new_prefix=27)
        )
        self.assertEqual(
            sorted(self.ipv6_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_network.subnets(new_prefix=68)),
        )
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(new_prefix=63))
        self.assertRaises(
            ValueError, list, self.ipv6_network.subnets(prefixlen_diff=4, new_prefix=68)
        )
        self.assertEqual(
            sorted(self.ipv6_scoped_network.subnets(prefixlen_diff=4)),
            sorted(self.ipv6_scoped_network.subnets(new_prefix=68)),
        )
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_network.subnets(new_prefix=63)
        )
        self.assertRaises(
            ValueError,
            list,
            self.ipv6_scoped_network.subnets(prefixlen_diff=4, new_prefix=68),
        )

    def testGetSubnets(self):
        self.assertEqual(list(self.ipv4_network.subnets())[0].prefixlen, 25)
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[0].network_address), &quot;1.2.3.0&quot;
        )
        self.assertEqual(
            str(list(self.ipv4_network.subnets())[1].network_address), &quot;1.2.3.128&quot;
        )

        self.assertEqual(list(self.ipv6_network.subnets())[0].prefixlen, 65)
        self.assertEqual(list(self.ipv6_scoped_network.subnets())[0].prefixlen, 65)

    def testGetSubnetForSingle32(self):
        ip = ipaddress.IPv4Network(&quot;1.2.3.4/32&quot;)
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, [&quot;1.2.3.4/32&quot;])
        self.assertEqual(subnets1, subnets2)

    def testGetSubnetForSingle128(self):
        ip = ipaddress.IPv6Network(&quot;::1/128&quot;)
        subnets1 = [str(x) for x in ip.subnets()]
        subnets2 = [str(x) for x in ip.subnets(2)]
        self.assertEqual(subnets1, [&quot;::1/128&quot;])
        self.assertEqual(subnets1, subnets2)

        ip_scoped = ipaddress.IPv6Network(&quot;::1%scope/128&quot;)
        subnets1 = [str(x) for x in ip_scoped.subnets()]
        subnets2 = [str(x) for x in ip_scoped.subnets(2)]
        self.assertEqual(subnets1, [&quot;::1%scope/128&quot;])
        self.assertEqual(subnets1, subnets2)

    def testSubnet2(self):
        ips = [str(x) for x in self.ipv4_network.subnets(2)]
        self.assertEqual(
            ips, [&quot;1.2.3.0/26&quot;, &quot;1.2.3.64/26&quot;, &quot;1.2.3.128/26&quot;, &quot;1.2.3.192/26&quot;]
        )

        ipsv6 = [str(x) for x in self.ipv6_network.subnets(2)]
        self.assertEqual(
            ipsv6,
            [
                &quot;2001:658:22a:cafe::/66&quot;,
                &quot;2001:658:22a:cafe:4000::/66&quot;,
                &quot;2001:658:22a:cafe:8000::/66&quot;,
                &quot;2001:658:22a:cafe:c000::/66&quot;,
            ],
        )

    def testGetSubnets3(self):
        subnets = [str(x) for x in self.ipv4_network.subnets(8)]
        self.assertEqual(subnets[:3], [&quot;1.2.3.0/32&quot;, &quot;1.2.3.1/32&quot;, &quot;1.2.3.2/32&quot;])
        self.assertEqual(subnets[-3:], [&quot;1.2.3.253/32&quot;, &quot;1.2.3.254/32&quot;, &quot;1.2.3.255/32&quot;])
        self.assertEqual(len(subnets), 256)

        ipv6_network = ipaddress.IPv6Network(&quot;2001:658:22a:cafe::/120&quot;)
        subnets = [str(x) for x in ipv6_network.subnets(8)]
        self.assertEqual(
            subnets[:3],
            [
                &quot;2001:658:22a:cafe::/128&quot;,
                &quot;2001:658:22a:cafe::1/128&quot;,
                &quot;2001:658:22a:cafe::2/128&quot;,
            ],
        )
        self.assertEqual(
            subnets[-3:],
            [
                &quot;2001:658:22a:cafe::fd/128&quot;,
                &quot;2001:658:22a:cafe::fe/128&quot;,
                &quot;2001:658:22a:cafe::ff/128&quot;,
            ],
        )
        self.assertEqual(len(subnets), 256)

    def testSubnetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(9))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(65))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(65))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(65)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(65))

    def testSupernetFailsForLargeCidrDiff(self):
        self.assertRaises(ValueError, self.ipv4_interface.network.supernet, 25)
        self.assertRaises(ValueError, self.ipv6_interface.network.supernet, 65)
        self.assertRaises(ValueError, self.ipv6_scoped_interface.network.supernet, 65)

    def testSubnetFailsForNegativeCidrDiff(self):
        self.assertRaises(ValueError, list, self.ipv4_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv4_network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_interface.network.subnets(-1))
        self.assertRaises(ValueError, list, self.ipv6_network.subnets(-1))
        self.assertRaises(
            ValueError, list, self.ipv6_scoped_interface.network.subnets(-1)
        )
        self.assertRaises(ValueError, list, self.ipv6_scoped_network.subnets(-1))

    def testGetNum_Addresses(self):
        self.assertEqual(self.ipv4_network.num_addresses, 256)
        self.assertEqual(list(self.ipv4_network.subnets())[0].num_addresses, 128)
        self.assertEqual(self.ipv4_network.supernet().num_addresses, 512)

        self.assertEqual(self.ipv6_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_network.subnets())[0].num_addresses, 9223372036854775808
        )
        self.assertEqual(
            self.ipv6_network.supernet().num_addresses, 36893488147419103232
        )
        self.assertEqual(self.ipv6_scoped_network.num_addresses, 18446744073709551616)
        self.assertEqual(
            list(self.ipv6_scoped_network.subnets())[0].num_addresses,
            9223372036854775808,
        )
        self.assertEqual(
            self.ipv6_scoped_network.supernet().num_addresses, 36893488147419103232
        )

    def testContains(self):
        self.assertIn(ipaddress.IPv4Interface(&quot;1.2.3.128/25&quot;), self.ipv4_network)
        self.assertNotIn(ipaddress.IPv4Interface(&quot;1.2.4.1/24&quot;), self.ipv4_network)
        # We can test addresses and string as well.
        addr1 = ipaddress.IPv4Address(&quot;1.2.3.37&quot;)
        self.assertIn(addr1, self.ipv4_network)
        # issue 61, bad network comparison on like-ip'd network objects
        # with identical broadcast addresses.
        self.assertFalse(
            ipaddress.IPv4Network(&quot;1.1.0.0/16&quot;).__contains__(
                ipaddress.IPv4Network(&quot;1.0.0.0/15&quot;)
            )
        )

    def testNth(self):
        self.assertEqual(str(self.ipv4_network[5]), &quot;1.2.3.5&quot;)
        self.assertRaises(IndexError, self.ipv4_network.__getitem__, 256)

        self.assertEqual(str(self.ipv6_network[5]), &quot;2001:658:22a:cafe::5&quot;)
        self.assertRaises(IndexError, self.ipv6_network.__getitem__, 1 &lt;&lt; 64)
        self.assertEqual(str(self.ipv6_scoped_network[5]), &quot;2001:658:22a:cafe::5&quot;)
        self.assertRaises(IndexError, self.ipv6_scoped_network.__getitem__, 1 &lt;&lt; 64)

    def testGetitem(self):
        # http://code.google.com/p/ipaddr-py/issues/detail?id=15
        addr = ipaddress.IPv4Network(&quot;172.31.255.128/255.255.255.240&quot;)
        self.assertEqual(28, addr.prefixlen)
        addr_list = list(addr)
        self.assertEqual(&quot;172.31.255.128&quot;, str(addr_list[0]))
        self.assertEqual(&quot;172.31.255.128&quot;, str(addr[0]))
        self.assertEqual(&quot;172.31.255.143&quot;, str(addr_list[-1]))
        self.assertEqual(&quot;172.31.255.143&quot;, str(addr[-1]))
        self.assertEqual(addr_list[-1], addr[-1])

    def testEqual(self):
        self.assertTrue(self.ipv4_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/24&quot;))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertFalse(self.ipv4_interface == ipaddress.IPv6Interface(&quot;::1.2.3.4/24&quot;))
        self.assertFalse(
            self.ipv4_interface == ipaddress.IPv6Interface(&quot;::1.2.3.4%scope/24&quot;)
        )
        self.assertFalse(self.ipv4_interface == &quot;&quot;)
        self.assertFalse(self.ipv4_interface == [])
        self.assertFalse(self.ipv4_interface == 2)

        self.assertTrue(
            self.ipv6_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertFalse(
            self.ipv6_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertFalse(self.ipv6_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertFalse(self.ipv6_interface == &quot;&quot;)
        self.assertFalse(self.ipv6_interface == [])
        self.assertFalse(self.ipv6_interface == 2)

        self.assertTrue(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/64&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/63&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface
            == ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertFalse(
            self.ipv6_scoped_interface == ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;)
        )
        self.assertFalse(self.ipv6_scoped_interface == &quot;&quot;)
        self.assertFalse(self.ipv6_scoped_interface == [])
        self.assertFalse(self.ipv6_scoped_interface == 2)

    def testNotEqual(self):
        self.assertFalse(self.ipv4_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/24&quot;))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertTrue(self.ipv4_interface != ipaddress.IPv6Interface(&quot;::1.2.3.4/24&quot;))
        self.assertTrue(
            self.ipv4_interface != ipaddress.IPv6Interface(&quot;::1.2.3.4%scope/24&quot;)
        )
        self.assertTrue(self.ipv4_interface != &quot;&quot;)
        self.assertTrue(self.ipv4_interface != [])
        self.assertTrue(self.ipv4_interface != 2)

        self.assertTrue(self.ipv4_address != ipaddress.IPv4Address(&quot;1.2.3.5&quot;))
        self.assertTrue(self.ipv4_address != &quot;&quot;)
        self.assertTrue(self.ipv4_address != [])
        self.assertTrue(self.ipv4_address != 2)

        self.assertFalse(
            self.ipv6_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertTrue(
            self.ipv6_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertTrue(self.ipv6_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;))
        self.assertTrue(self.ipv6_interface != &quot;&quot;)
        self.assertTrue(self.ipv6_interface != [])
        self.assertTrue(self.ipv6_interface != 2)

        self.assertTrue(self.ipv6_address != ipaddress.IPv4Address(&quot;1.2.3.4&quot;))
        self.assertTrue(self.ipv6_address != &quot;&quot;)
        self.assertTrue(self.ipv6_address != [])
        self.assertTrue(self.ipv6_address != 2)

        self.assertFalse(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/64&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1%scope/63&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface
            != ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200::1/63&quot;)
        )
        self.assertTrue(
            self.ipv6_scoped_interface != ipaddress.IPv4Interface(&quot;1.2.3.4/23&quot;)
        )
        self.assertTrue(self.ipv6_scoped_interface != &quot;&quot;)
        self.assertTrue(self.ipv6_scoped_interface != [])
        self.assertTrue(self.ipv6_scoped_interface != 2)

        self.assertTrue(self.ipv6_scoped_address != ipaddress.IPv4Address(&quot;1.2.3.4&quot;))
        self.assertTrue(self.ipv6_scoped_address != &quot;&quot;)
        self.assertTrue(self.ipv6_scoped_address != [])
        self.assertTrue(self.ipv6_scoped_address != 2)

    def testSlash32Constructor(self):
        self.assertEqual(
            str(ipaddress.IPv4Interface(&quot;1.2.3.4/255.255.255.255&quot;)), &quot;1.2.3.4/32&quot;
        )

    def testSlash128Constructor(self):
        self.assertEqual(str(ipaddress.IPv6Interface(&quot;::1/128&quot;)), &quot;::1/128&quot;)
        self.assertEqual(str(ipaddress.IPv6Interface(&quot;::1%scope/128&quot;)), &quot;::1%scope/128&quot;)

    def testSlash0Constructor(self):
        self.assertEqual(str(ipaddress.IPv4Interface(&quot;1.2.3.4/0.0.0.0&quot;)), &quot;1.2.3.4/0&quot;)

    def testCollapsing(self):
        # test only IP addresses including some duplicates
        ip1 = ipaddress.IPv4Address(&quot;1.1.1.0&quot;)
        ip2 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        ip3 = ipaddress.IPv4Address(&quot;1.1.1.2&quot;)
        ip4 = ipaddress.IPv4Address(&quot;1.1.1.3&quot;)
        ip5 = ipaddress.IPv4Address(&quot;1.1.1.4&quot;)
        ip6 = ipaddress.IPv4Address(&quot;1.1.1.0&quot;)
        # check that addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network(&quot;1.1.1.0/30&quot;), ipaddress.IPv4Network(&quot;1.1.1.4/32&quot;)],
        )

        # test a mix of IP addresses and networks including some duplicates
        ip1 = ipaddress.IPv4Address(&quot;1.1.1.0&quot;)
        ip2 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        ip3 = ipaddress.IPv4Address(&quot;1.1.1.2&quot;)
        ip4 = ipaddress.IPv4Address(&quot;1.1.1.3&quot;)
        # ip5 = ipaddress.IPv4Interface('1.1.1.4/30')
        # ip6 = ipaddress.IPv4Interface('1.1.1.4/30')
        # check that addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network(&quot;1.1.1.0/30&quot;)])

        # test only IP networks
        ip1 = ipaddress.IPv4Network(&quot;1.1.0.0/24&quot;)
        ip2 = ipaddress.IPv4Network(&quot;1.1.1.0/24&quot;)
        ip3 = ipaddress.IPv4Network(&quot;1.1.2.0/24&quot;)
        ip4 = ipaddress.IPv4Network(&quot;1.1.3.0/24&quot;)
        ip5 = ipaddress.IPv4Network(&quot;1.1.4.0/24&quot;)
        # stored in no particular order b/c we want CollapseAddr to call
        # [].sort
        ip6 = ipaddress.IPv4Network(&quot;1.1.0.0/22&quot;)
        # check that addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3, ip4, ip5, ip6])
        self.assertEqual(
            list(collapsed),
            [ipaddress.IPv4Network(&quot;1.1.0.0/22&quot;), ipaddress.IPv4Network(&quot;1.1.4.0/24&quot;)],
        )

        # test that two addresses are supernet'ed properly
        collapsed = ipaddress.collapse_addresses([ip1, ip2])
        self.assertEqual(list(collapsed), [ipaddress.IPv4Network(&quot;1.1.0.0/23&quot;)])

        # test same IP networks
        ip_same1 = ip_same2 = ipaddress.IPv4Network(&quot;1.1.1.1/32&quot;)
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])), [ip_same1]
        )

        # test same IP addresses
        ip_same1 = ip_same2 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        self.assertEqual(
            list(ipaddress.collapse_addresses([ip_same1, ip_same2])),
            [ipaddress.ip_network(&quot;1.1.1.1/32&quot;)],
        )
        ip1 = ipaddress.IPv6Network(&quot;2001::/100&quot;)
        ip2 = ipaddress.IPv6Network(&quot;2001::/120&quot;)
        ip3 = ipaddress.IPv6Network(&quot;2001::/96&quot;)
        # test that ipv6 addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])

        ip1 = ipaddress.IPv6Network(&quot;2001::%scope/100&quot;)
        ip2 = ipaddress.IPv6Network(&quot;2001::%scope/120&quot;)
        ip3 = ipaddress.IPv6Network(&quot;2001::%scope/96&quot;)
        # test that ipv6 addresses are subsumed properly.
        collapsed = ipaddress.collapse_addresses([ip1, ip2, ip3])
        self.assertEqual(list(collapsed), [ip3])

        # the toejam test
        addr_tuples = [
            (ipaddress.ip_address(&quot;1.1.1.1&quot;), ipaddress.ip_address(&quot;::1&quot;)),
            (ipaddress.IPv4Network(&quot;1.1.0.0/24&quot;), ipaddress.IPv6Network(&quot;2001::/120&quot;)),
            (ipaddress.IPv4Network(&quot;1.1.0.0/32&quot;), ipaddress.IPv6Network(&quot;2001::/128&quot;)),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])

        addr_tuples = [
            (ipaddress.ip_address(&quot;1.1.1.1&quot;), ipaddress.ip_address(&quot;::1%scope&quot;)),
            (
                ipaddress.IPv4Network(&quot;1.1.0.0/24&quot;),
                ipaddress.IPv6Network(&quot;2001::%scope/120&quot;),
            ),
            (
                ipaddress.IPv4Network(&quot;1.1.0.0/32&quot;),
                ipaddress.IPv6Network(&quot;2001::%scope/128&quot;),
            ),
        ]
        for ip1, ip2 in addr_tuples:
            self.assertRaises(TypeError, ipaddress.collapse_addresses, [ip1, ip2])

    def testSummarizing(self):
        # ip = ipaddress.ip_address
        # ipnet = ipaddress.ip_network
        summarize = ipaddress.summarize_address_range
        ip1 = ipaddress.ip_address(&quot;1.1.1.0&quot;)
        ip2 = ipaddress.ip_address(&quot;1.1.1.255&quot;)

        # summarize works only for IPv4 &amp; IPv6
        class IPv7Address(ipaddress.IPv6Address):
            @property
            def version(self):
                return 7

        ip_invalid1 = IPv7Address(&quot;::1&quot;)
        ip_invalid2 = IPv7Address(&quot;::1&quot;)
        self.assertRaises(ValueError, list, summarize(ip_invalid1, ip_invalid2))
        # test that a summary over ip4 &amp; ip6 fails
        self.assertRaises(TypeError, list, summarize(ip1, ipaddress.IPv6Address(&quot;::1&quot;)))
        self.assertRaises(
            TypeError, list, summarize(ip1, ipaddress.IPv6Address(&quot;::1%scope&quot;))
        )
        # test a /24 is summarized properly
        self.assertEqual(
            list(summarize(ip1, ip2))[0], ipaddress.ip_network(&quot;1.1.1.0/24&quot;)
        )
        # test an IPv4 range that isn't on a network byte boundary
        ip2 = ipaddress.ip_address(&quot;1.1.1.8&quot;)
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network(&quot;1.1.1.0/29&quot;), ipaddress.ip_network(&quot;1.1.1.8&quot;)],
        )
        # all!
        ip1 = ipaddress.IPv4Address(0)
        ip2 = ipaddress.IPv4Address(ipaddress.IPv4Address._ALL_ONES)
        self.assertEqual(
            [ipaddress.IPv4Network(&quot;0.0.0.0/0&quot;)], list(summarize(ip1, ip2))
        )

        ip1 = ipaddress.ip_address(&quot;1::&quot;)
        ip2 = ipaddress.ip_address(&quot;1:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;)
        # test an IPv6 is summarized properly
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network(&quot;1::/16&quot;))
        # test an IPv6 range that isn't on a network byte boundary
        ip2 = ipaddress.ip_address(&quot;2::&quot;)
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network(&quot;1::/16&quot;), ipaddress.ip_network(&quot;2::/128&quot;)],
        )

        ip1 = ipaddress.ip_address(&quot;1::%scope&quot;)
        ip2 = ipaddress.ip_address(&quot;1:ffff:ffff:ffff:ffff:ffff:ffff:ffff%scope&quot;)
        # test an IPv6 is summarized properly
        self.assertEqual(list(summarize(ip1, ip2))[0], ipaddress.ip_network(&quot;1::/16&quot;))
        # test an IPv6 range that isn't on a network byte boundary
        ip2 = ipaddress.ip_address(&quot;2::%scope&quot;)
        self.assertEqual(
            list(summarize(ip1, ip2)),
            [ipaddress.ip_network(&quot;1::/16&quot;), ipaddress.ip_network(&quot;2::/128&quot;)],
        )

        # test exception raised when first is greater than last
        self.assertRaises(
            ValueError,
            list,
            summarize(ipaddress.ip_address(&quot;1.1.1.0&quot;), ipaddress.ip_address(&quot;1.1.0.0&quot;)),
        )
        # test exception raised when first and last aren't IP addresses
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network(&quot;1.1.1.0&quot;), ipaddress.ip_network(&quot;1.1.0.0&quot;)),
        )
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_network(&quot;1.1.1.0&quot;), ipaddress.ip_network(&quot;1.1.0.0&quot;)),
        )
        # test exception raised when first and last are not same version
        self.assertRaises(
            TypeError,
            list,
            summarize(ipaddress.ip_address(&quot;::&quot;), ipaddress.ip_network(&quot;1.1.0.0&quot;)),
        )

    def testAddressComparison(self):
        self.assertTrue(
            ipaddress.ip_address(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_address(&quot;1.1.1.1&quot;)
        )
        self.assertTrue(
            ipaddress.ip_address(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_address(&quot;1.1.1.2&quot;)
        )
        self.assertTrue(ipaddress.ip_address(&quot;::1&quot;) &lt;= ipaddress.ip_address(&quot;::1&quot;))
        self.assertTrue(ipaddress.ip_address(&quot;::1&quot;) &lt;= ipaddress.ip_address(&quot;::2&quot;))
        self.assertTrue(
            ipaddress.ip_address(&quot;::1%scope&quot;) &lt;= ipaddress.ip_address(&quot;::1%scope&quot;)
        )
        self.assertTrue(
            ipaddress.ip_address(&quot;::1%scope&quot;) &lt;= ipaddress.ip_address(&quot;::2%scope&quot;)
        )

    def testInterfaceComparison(self):
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) == ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/16&quot;) &lt; ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) &lt; ipaddress.ip_interface(&quot;1.1.1.2/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.2/16&quot;) &lt; ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) &gt; ipaddress.ip_interface(&quot;1.1.1.1/16&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.2/24&quot;) &gt; ipaddress.ip_interface(&quot;1.1.1.1/24&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;1.1.1.1/24&quot;) &gt; ipaddress.ip_interface(&quot;1.1.1.2/16&quot;)
        )

        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) == ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::1/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::2/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/48&quot;) &lt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/80&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/64&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &gt; ipaddress.ip_interface(&quot;::2/48&quot;)
        )

        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            == ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            &lt; ipaddress.ip_interface(&quot;::1%scope/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            &lt; ipaddress.ip_interface(&quot;::2%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/48&quot;)
            &lt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/80&quot;)
            &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/64&quot;)
            &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;)
            &gt; ipaddress.ip_interface(&quot;::2%scope/48&quot;)
        )

        self.assertFalse(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) == ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) &lt; ipaddress.ip_interface(&quot;::1/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) &lt; ipaddress.ip_interface(&quot;::2/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/48&quot;) &lt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/80&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2%scope/64&quot;) &gt; ipaddress.ip_interface(&quot;::1/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1%scope/64&quot;) &gt; ipaddress.ip_interface(&quot;::2/48&quot;)
        )

        self.assertFalse(
            ipaddress.ip_interface(&quot;::1/64&quot;) == ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::1%scope/80&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &lt; ipaddress.ip_interface(&quot;::2%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/48&quot;) &lt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/80&quot;) &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::2/64&quot;) &gt; ipaddress.ip_interface(&quot;::1%scope/64&quot;)
        )
        self.assertTrue(
            ipaddress.ip_interface(&quot;::1/64&quot;) &gt; ipaddress.ip_interface(&quot;::2%scope/48&quot;)
        )

    def testNetworkComparison(self):
        # ip1 and ip2 have the same network address
        ip1 = ipaddress.IPv4Network(&quot;1.1.1.0/24&quot;)
        ip2 = ipaddress.IPv4Network(&quot;1.1.1.0/32&quot;)
        ip3 = ipaddress.IPv4Network(&quot;1.1.2.0/24&quot;)

        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)

        self.assertEqual(ip1.compare_networks(ip1), 0)

        # if addresses are the same, sort by netmask
        self.assertEqual(ip1.compare_networks(ip2), -1)
        self.assertEqual(ip2.compare_networks(ip1), 1)

        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertEqual(ip3.compare_networks(ip1), 1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())

        ip1 = ipaddress.IPv6Network(&quot;2001:2000::/96&quot;)
        ip2 = ipaddress.IPv6Network(&quot;2001:2001::/96&quot;)
        ip3 = ipaddress.IPv6Network(&quot;2001:ffff:2000::/96&quot;)

        self.assertTrue(ip1 &lt; ip3)
        self.assertTrue(ip3 &gt; ip2)
        self.assertEqual(ip1.compare_networks(ip3), -1)
        self.assertTrue(ip1._get_networks_key() &lt; ip3._get_networks_key())

        # Test comparing different protocols.
        # Should always raise a TypeError.
        self.assertRaises(
            TypeError, self.ipv4_network.compare_networks, self.ipv6_network
        )
        ipv6 = ipaddress.IPv6Interface(&quot;::/0&quot;)
        ipv4 = ipaddress.IPv4Interface(&quot;0.0.0.0/0&quot;)
        self.assertRaises(TypeError, ipv4.__lt__, ipv6)
        self.assertRaises(TypeError, ipv4.__gt__, ipv6)
        self.assertRaises(TypeError, ipv6.__lt__, ipv4)
        self.assertRaises(TypeError, ipv6.__gt__, ipv4)

        # Regression test for issue 19.
        ip1 = ipaddress.ip_network(&quot;10.1.2.128/25&quot;)
        self.assertFalse(ip1 &lt; ip1)
        self.assertFalse(ip1 &gt; ip1)
        ip2 = ipaddress.ip_network(&quot;10.1.3.0/24&quot;)
        self.assertTrue(ip1 &lt; ip2)
        self.assertFalse(ip2 &lt; ip1)
        self.assertFalse(ip1 &gt; ip2)
        self.assertTrue(ip2 &gt; ip1)
        ip3 = ipaddress.ip_network(&quot;10.1.3.0/25&quot;)
        self.assertTrue(ip2 &lt; ip3)
        self.assertFalse(ip3 &lt; ip2)
        self.assertFalse(ip2 &gt; ip3)
        self.assertTrue(ip3 &gt; ip2)

        # Regression test for issue 28.
        ip1 = ipaddress.ip_network(&quot;10.10.10.0/31&quot;)
        ip2 = ipaddress.ip_network(&quot;10.10.10.0&quot;)
        ip3 = ipaddress.ip_network(&quot;10.10.10.2/31&quot;)
        ip4 = ipaddress.ip_network(&quot;10.10.10.2&quot;)
        sorted = [ip1, ip2, ip3, ip4]
        unsorted = [ip2, ip4, ip1, ip3]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        unsorted = [ip4, ip1, ip3, ip2]
        unsorted.sort()
        self.assertEqual(sorted, unsorted)
        self.assertIs(ip1.__lt__(ipaddress.ip_address(&quot;10.10.10.0&quot;)), NotImplemented)
        self.assertIs(ip2.__lt__(ipaddress.ip_address(&quot;10.10.10.0&quot;)), NotImplemented)

        # &lt;=, &gt;=
        self.assertTrue(
            ipaddress.ip_network(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_network(&quot;1.1.1.1&quot;)
        )
        self.assertTrue(
            ipaddress.ip_network(&quot;1.1.1.1&quot;) &lt;= ipaddress.ip_network(&quot;1.1.1.2&quot;)
        )
        self.assertFalse(
            ipaddress.ip_network(&quot;1.1.1.2&quot;) &lt;= ipaddress.ip_network(&quot;1.1.1.1&quot;)
        )

        self.assertTrue(ipaddress.ip_network(&quot;::1&quot;) &lt;= ipaddress.ip_network(&quot;::1&quot;))
        self.assertTrue(ipaddress.ip_network(&quot;::1&quot;) &lt;= ipaddress.ip_network(&quot;::2&quot;))
        self.assertFalse(ipaddress.ip_network(&quot;::2&quot;) &lt;= ipaddress.ip_network(&quot;::1&quot;))

    def testStrictNetworks(self):
        self.assertRaises(ValueError, ipaddress.ip_network, &quot;192.168.1.1/24&quot;)
        self.assertRaises(ValueError, ipaddress.ip_network, &quot;::1/120&quot;)
        self.assertRaises(ValueError, ipaddress.ip_network, &quot;::1%scope/120&quot;)

    def testOverlaps(self):
        other = ipaddress.IPv4Network(&quot;1.2.3.0/30&quot;)
        other2 = ipaddress.IPv4Network(&quot;1.2.2.0/24&quot;)
        other3 = ipaddress.IPv4Network(&quot;1.2.2.64/26&quot;)
        self.assertTrue(self.ipv4_network.overlaps(other))
        self.assertFalse(self.ipv4_network.overlaps(other2))
        self.assertTrue(other2.overlaps(other3))

    def testEmbeddedIpv4(self):
        ipv4_string = &quot;192.168.0.1&quot;
        ipv4 = ipaddress.IPv4Interface(ipv4_string)
        v4compat_ipv6 = ipaddress.IPv6Interface(&quot;::%s&quot; % ipv4_string)
        self.assertEqual(int(v4compat_ipv6.ip), int(ipv4.ip))
        v4mapped_ipv6 = ipaddress.IPv6Interface(&quot;::ffff:%s&quot; % ipv4_string)
        self.assertNotEqual(v4mapped_ipv6.ip, ipv4.ip)
        self.assertRaises(
            ipaddress.AddressValueError, ipaddress.IPv6Interface, &quot;2001:1.1.1.1:1.1.1.1&quot;
        )

    # Issue 67: IPv6 with embedded IPv4 address not recognized.
    def testIPv6AddressTooLarge(self):
        # RFC4291 2.5.5.2
        self.assertEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201&quot;),
        )
        # RFC4291 2.2 (part 3) x::d.d.d.d
        self.assertEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201&quot;),
        )

        self.assertEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201%scope&quot;),
        )
        self.assertEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201%scope&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1%scope&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;::FFFF:192.0.2.1&quot;),
            ipaddress.ip_address(&quot;::FFFF:c000:201%scope&quot;),
        )
        self.assertNotEqual(
            ipaddress.ip_address(&quot;FFFF::192.0.2.1&quot;),
            ipaddress.ip_address(&quot;FFFF::c000:201%scope&quot;),
        )

    def testIPVersion(self):
        self.assertEqual(self.ipv4_address.version, 4)
        self.assertEqual(self.ipv6_address.version, 6)
        self.assertEqual(self.ipv6_scoped_address.version, 6)

    def testMaxPrefixLength(self):
        self.assertEqual(self.ipv4_interface.max_prefixlen, 32)
        self.assertEqual(self.ipv6_interface.max_prefixlen, 128)
        self.assertEqual(self.ipv6_scoped_interface.max_prefixlen, 128)

    def testPacked(self):
        self.assertEqual(self.ipv4_address.packed, b&quot;\x01\x02\x03\x04&quot;)
        self.assertEqual(
            ipaddress.IPv4Interface(&quot;255.254.253.252&quot;).packed, b&quot;\xff\xfe\xfd\xfc&quot;
        )
        self.assertEqual(
            self.ipv6_address.packed,
            b&quot;\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01&quot;,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;ffff:2:3:4:ffff::&quot;).packed,
            b&quot;\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff&quot; + b&quot;\x00&quot; * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;::1:0:0:0:0&quot;).packed,
            b&quot;\x00&quot; * 6 + b&quot;\x00\x01&quot; + b&quot;\x00&quot; * 8,
        )
        self.assertEqual(
            self.ipv6_scoped_address.packed,
            b&quot;\x20\x01\x06\x58\x02\x2a\xca\xfe\x02\x00\x00\x00\x00\x00\x00\x01&quot;,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;ffff:2:3:4:ffff::%scope&quot;).packed,
            b&quot;\xff\xff\x00\x02\x00\x03\x00\x04\xff\xff&quot; + b&quot;\x00&quot; * 6,
        )
        self.assertEqual(
            ipaddress.IPv6Interface(&quot;::1:0:0:0:0%scope&quot;).packed,
            b&quot;\x00&quot; * 6 + b&quot;\x00\x01&quot; + b&quot;\x00&quot; * 8,
        )

    def testIpType(self):
        ipv4net = ipaddress.ip_network(&quot;1.2.3.4&quot;)
        ipv4addr = ipaddress.ip_address(&quot;1.2.3.4&quot;)
        ipv6net = ipaddress.ip_network(&quot;::1.2.3.4&quot;)
        ipv6addr = ipaddress.ip_address(&quot;::1.2.3.4&quot;)
        self.assertEqual(ipaddress.IPv4Network, type(ipv4net))
        self.assertEqual(ipaddress.IPv4Address, type(ipv4addr))
        self.assertEqual(ipaddress.IPv6Network, type(ipv6net))
        self.assertEqual(ipaddress.IPv6Address, type(ipv6addr))

    def testReservedIpv4(self):
        # test networks
        self.assertEqual(True, ipaddress.ip_interface(&quot;224.1.1.1/31&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_network(&quot;240.0.0.0&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_network(&quot;240.0.0.0&quot;).is_reserved)

        self.assertEqual(True, ipaddress.ip_interface(&quot;192.168.1.1/17&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;192.169.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;10.255.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;11.0.0.0&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;11.0.0.0&quot;).is_reserved)
        self.assertEqual(True, ipaddress.ip_network(&quot;172.31.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;172.32.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;169.254.1.0/24&quot;).is_link_local)

        self.assertEqual(
            True, ipaddress.ip_interface(&quot;169.254.100.200/24&quot;).is_link_local
        )
        self.assertEqual(
            False, ipaddress.ip_interface(&quot;169.255.100.200/24&quot;).is_link_local
        )

        self.assertEqual(True, ipaddress.ip_network(&quot;127.100.200.254/32&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_network(&quot;127.42.0.0/16&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;128.0.0.0&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;100.64.0.0/10&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;100.64.0.0/10&quot;).is_global)

        self.assertEqual(True, ipaddress.ip_network(&quot;192.0.2.128/25&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;192.0.3.0/24&quot;).is_global)

        # test addresses
        self.assertEqual(True, ipaddress.ip_address(&quot;0.0.0.0&quot;).is_unspecified)
        self.assertEqual(True, ipaddress.ip_address(&quot;224.1.1.1&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_address(&quot;240.0.0.0&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_address(&quot;240.0.0.1&quot;).is_reserved)
        self.assertEqual(False, ipaddress.ip_address(&quot;239.255.255.255&quot;).is_reserved)

        self.assertEqual(True, ipaddress.ip_address(&quot;192.168.1.1&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;192.169.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_address(&quot;10.255.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;11.0.0.0&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_address(&quot;172.31.255.255&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;172.32.0.0&quot;).is_private)

        self.assertEqual(True, ipaddress.ip_address(&quot;169.254.100.200&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;169.255.100.200&quot;).is_link_local)

        self.assertTrue(ipaddress.ip_address(&quot;192.0.7.1&quot;).is_global)
        self.assertFalse(ipaddress.ip_address(&quot;203.0.113.1&quot;).is_global)

        self.assertEqual(True, ipaddress.ip_address(&quot;127.100.200.254&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_address(&quot;127.42.0.0&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_address(&quot;128.0.0.0&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_network(&quot;0.0.0.0&quot;).is_unspecified)

    def testReservedIpv6(self):

        self.assertEqual(True, ipaddress.ip_network(&quot;ffff::&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_network(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_network(&quot;ff00::&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_network(&quot;fdff::&quot;).is_multicast)

        self.assertEqual(True, ipaddress.ip_network(&quot;fecf::&quot;).is_site_local)
        self.assertEqual(
            True, ipaddress.ip_network(&quot;feff:ffff:ffff:ffff::&quot;).is_site_local
        )
        self.assertEqual(False, ipaddress.ip_network(&quot;fbf:ffff::&quot;).is_site_local)
        self.assertEqual(False, ipaddress.ip_network(&quot;ff00::&quot;).is_site_local)

        self.assertEqual(True, ipaddress.ip_network(&quot;fc00::&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;fc00:ffff:ffff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;fbff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_network(&quot;fe00::&quot;).is_private)

        self.assertEqual(True, ipaddress.ip_network(&quot;fea0::&quot;).is_link_local)
        self.assertEqual(True, ipaddress.ip_network(&quot;febf:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_network(&quot;fe7f:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_network(&quot;fec0::&quot;).is_link_local)

        self.assertEqual(True, ipaddress.ip_interface(&quot;0:0::0:01&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_interface(&quot;::1/127&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;::&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_network(&quot;::2&quot;).is_loopback)

        self.assertEqual(True, ipaddress.ip_network(&quot;0::0&quot;).is_unspecified)
        self.assertEqual(False, ipaddress.ip_network(&quot;::1&quot;).is_unspecified)
        self.assertEqual(False, ipaddress.ip_network(&quot;::/127&quot;).is_unspecified)

        self.assertEqual(True, ipaddress.ip_network(&quot;2001::1/128&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_network(&quot;200::1/128&quot;).is_global)
        # test addresses
        self.assertEqual(True, ipaddress.ip_address(&quot;ffff::&quot;).is_multicast)
        self.assertEqual(True, ipaddress.ip_address(2 ** 128 - 1).is_multicast)
        self.assertEqual(True, ipaddress.ip_address(&quot;ff00::&quot;).is_multicast)
        self.assertEqual(False, ipaddress.ip_address(&quot;fdff::&quot;).is_multicast)

        self.assertEqual(True, ipaddress.ip_address(&quot;fecf::&quot;).is_site_local)
        self.assertEqual(
            True, ipaddress.ip_address(&quot;feff:ffff:ffff:ffff::&quot;).is_site_local
        )
        self.assertEqual(False, ipaddress.ip_address(&quot;fbf:ffff::&quot;).is_site_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;ff00::&quot;).is_site_local)

        self.assertEqual(True, ipaddress.ip_address(&quot;fc00::&quot;).is_private)
        self.assertEqual(True, ipaddress.ip_address(&quot;fc00:ffff:ffff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;fbff:ffff::&quot;).is_private)
        self.assertEqual(False, ipaddress.ip_address(&quot;fe00::&quot;).is_private)

        self.assertEqual(True, ipaddress.ip_address(&quot;fea0::&quot;).is_link_local)
        self.assertEqual(True, ipaddress.ip_address(&quot;febf:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;fe7f:ffff::&quot;).is_link_local)
        self.assertEqual(False, ipaddress.ip_address(&quot;fec0::&quot;).is_link_local)

        self.assertEqual(True, ipaddress.ip_address(&quot;0:0::0:01&quot;).is_loopback)
        self.assertEqual(True, ipaddress.ip_address(&quot;::1&quot;).is_loopback)
        self.assertEqual(False, ipaddress.ip_address(&quot;::2&quot;).is_loopback)

        self.assertEqual(True, ipaddress.ip_address(&quot;0::0&quot;).is_unspecified)
        self.assertEqual(False, ipaddress.ip_address(&quot;::1&quot;).is_unspecified)

        # some generic IETF reserved addresses
        self.assertEqual(True, ipaddress.ip_address(&quot;100::&quot;).is_reserved)
        self.assertEqual(True, ipaddress.ip_network(&quot;4000::1/128&quot;).is_reserved)

    def testIpv4Mapped(self):
        self.assertEqual(
            ipaddress.ip_address(&quot;::ffff:192.168.1.1&quot;).ipv4_mapped,
            ipaddress.ip_address(&quot;192.168.1.1&quot;),
        )
        self.assertEqual(ipaddress.ip_address(&quot;::c0a8:101&quot;).ipv4_mapped, None)
        self.assertEqual(
            ipaddress.ip_address(&quot;::ffff:c0a8:101&quot;).ipv4_mapped,
            ipaddress.ip_address(&quot;192.168.1.1&quot;),
        )

    def testAddrExclude(self):
        addr1 = ipaddress.ip_network(&quot;10.1.1.0/24&quot;)
        addr2 = ipaddress.ip_network(&quot;10.1.1.0/26&quot;)
        addr3 = ipaddress.ip_network(&quot;10.2.1.0/24&quot;)
        addr4 = ipaddress.ip_address(&quot;10.1.1.0&quot;)
        addr5 = ipaddress.ip_network(&quot;2001:db8::0/32&quot;)
        addr6 = ipaddress.ip_network(&quot;10.1.1.5/32&quot;)
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr2))),
            [
                ipaddress.ip_network(&quot;10.1.1.64/26&quot;),
                ipaddress.ip_network(&quot;10.1.1.128/25&quot;),
            ],
        )
        self.assertRaises(ValueError, list, addr1.address_exclude(addr3))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr4))
        self.assertRaises(TypeError, list, addr1.address_exclude(addr5))
        self.assertEqual(list(addr1.address_exclude(addr1)), [])
        self.assertEqual(
            sorted(list(addr1.address_exclude(addr6))),
            [
                ipaddress.ip_network(&quot;10.1.1.0/30&quot;),
                ipaddress.ip_network(&quot;10.1.1.4/32&quot;),
                ipaddress.ip_network(&quot;10.1.1.6/31&quot;),
                ipaddress.ip_network(&quot;10.1.1.8/29&quot;),
                ipaddress.ip_network(&quot;10.1.1.16/28&quot;),
                ipaddress.ip_network(&quot;10.1.1.32/27&quot;),
                ipaddress.ip_network(&quot;10.1.1.64/26&quot;),
                ipaddress.ip_network(&quot;10.1.1.128/25&quot;),
            ],
        )

    def testHash(self):
        self.assertEqual(
            hash(ipaddress.ip_interface(&quot;10.1.1.0/24&quot;)),
            hash(ipaddress.ip_interface(&quot;10.1.1.0/24&quot;)),
        )
        self.assertEqual(
            hash(ipaddress.ip_network(&quot;10.1.1.0/24&quot;)),
            hash(ipaddress.ip_network(&quot;10.1.1.0/24&quot;)),
        )
        self.assertEqual(
            hash(ipaddress.ip_address(&quot;10.1.1.0&quot;)),
            hash(ipaddress.ip_address(&quot;10.1.1.0&quot;)),
        )
        # i70
        self.assertEqual(
            hash(ipaddress.ip_address(&quot;1.2.3.4&quot;)),
            hash(ipaddress.ip_address(int(ipaddress.ip_address(&quot;1.2.3.4&quot;)._ip))),
        )
        ip1 = ipaddress.ip_address(&quot;10.1.1.0&quot;)
        ip2 = ipaddress.ip_address(&quot;1::&quot;)
        dummy = {}
        dummy[self.ipv4_address] = None
        dummy[self.ipv6_address] = None
        dummy[ip1] = None
        dummy[ip2] = None
        self.assertIn(self.ipv4_address, dummy)
        self.assertIn(ip2, dummy)

    def testIPBases(self):
        net = self.ipv4_network
        self.assertEqual(&quot;1.2.3.0/24&quot;, net.compressed)
        net = self.ipv6_network
        self.assertRaises(ValueError, net._string_from_ip_int, 2 ** 128 + 1)

    def testIPv6NetworkHelpers(self):
        net = self.ipv6_network
        self.assertEqual(&quot;2001:658:22a:cafe::/64&quot;, net.with_prefixlen)
        self.assertEqual(&quot;2001:658:22a:cafe::/ffff:ffff:ffff:ffff::&quot;, net.with_netmask)
        self.assertEqual(&quot;2001:658:22a:cafe::/::ffff:ffff:ffff:ffff&quot;, net.with_hostmask)
        self.assertEqual(&quot;2001:658:22a:cafe::/64&quot;, str(net))

    def testIPv4NetworkHelpers(self):
        net = self.ipv4_network
        self.assertEqual(&quot;1.2.3.0/24&quot;, net.with_prefixlen)
        self.assertEqual(&quot;1.2.3.0/255.255.255.0&quot;, net.with_netmask)
        self.assertEqual(&quot;1.2.3.0/0.0.0.255&quot;, net.with_hostmask)
        self.assertEqual(&quot;1.2.3.0/24&quot;, str(net))

    def testCopyConstructor(self):
        addr1 = ipaddress.ip_network(&quot;10.1.1.0/24&quot;)
        addr2 = ipaddress.ip_network(addr1)
        addr3 = ipaddress.ip_interface(&quot;2001:658:22a:cafe:200::1/64&quot;)
        addr4 = ipaddress.ip_interface(addr3)
        addr5 = ipaddress.IPv4Address(&quot;1.1.1.1&quot;)
        addr6 = ipaddress.IPv6Address(&quot;2001:658:22a:cafe:200::1&quot;)

        self.assertEqual(addr1, addr2)
        self.assertEqual(addr3, addr4)
        self.assertEqual(addr5, ipaddress.IPv4Address(addr5))
        self.assertEqual(addr6, ipaddress.IPv6Address(addr6))

    def testCompressIPv6Address(self):
        test_addresses = {
            &quot;1:2:3:4:5:6:7:8&quot;: &quot;1:2:3:4:5:6:7:8/128&quot;,
            &quot;2001:0:0:4:0:0:0:8&quot;: &quot;2001:0:0:4::8/128&quot;,
            &quot;2001:0:0:4:5:6:7:8&quot;: &quot;2001::4:5:6:7:8/128&quot;,
            &quot;2001:0:3:4:5:6:7:8&quot;: &quot;2001:0:3:4:5:6:7:8/128&quot;,
            &quot;0:0:3:0:0:0:0:ffff&quot;: &quot;0:0:3::ffff/128&quot;,
            &quot;0:0:0:4:0:0:0:ffff&quot;: &quot;::4:0:0:0:ffff/128&quot;,
            &quot;0:0:0:0:5:0:0:ffff&quot;: &quot;::5:0:0:ffff/128&quot;,
            &quot;1:0:0:4:0:0:7:8&quot;: &quot;1::4:0:0:7:8/128&quot;,
            &quot;0:0:0:0:0:0:0:0&quot;: &quot;::/128&quot;,
            &quot;0:0:0:0:0:0:0:0/0&quot;: &quot;::/0&quot;,
            &quot;0:0:0:0:0:0:0:1&quot;: &quot;::1/128&quot;,
            &quot;2001:0658:022a:cafe:0000:0000:0000:0000/66&quot;: &quot;2001:658:22a:cafe::/66&quot;,
            &quot;::1.2.3.4&quot;: &quot;::102:304/128&quot;,
            &quot;1:2:3:4:5:ffff:1.2.3.4&quot;: &quot;1:2:3:4:5:ffff:102:304/128&quot;,
            &quot;::7:6:5:4:3:2:1&quot;: &quot;0:7:6:5:4:3:2:1/128&quot;,
            &quot;::7:6:5:4:3:2:0&quot;: &quot;0:7:6:5:4:3:2:0/128&quot;,
            &quot;7:6:5:4:3:2:1::&quot;: &quot;7:6:5:4:3:2:1:0/128&quot;,
            &quot;0:6:5:4:3:2:1::&quot;: &quot;0:6:5:4:3:2:1:0/128&quot;,
        }
        for uncompressed, compressed in list(test_addresses.items()):
            self.assertEqual(compressed, str(ipaddress.IPv6Interface(uncompressed)))

    def testExplodeShortHandIpStr(self):
        addr1 = ipaddress.IPv6Interface(&quot;2001::1&quot;)
        addr2 = ipaddress.IPv6Address(&quot;2001:0:5ef5:79fd:0:59d:a0e5:ba1&quot;)
        addr3 = ipaddress.IPv6Network(&quot;2001::/96&quot;)
        addr4 = ipaddress.IPv4Address(&quot;192.168.178.1&quot;)
        self.assertEqual(&quot;2001:0000:0000:0000:0000:0000:0000:0001/128&quot;, addr1.exploded)
        self.assertEqual(
            &quot;0000:0000:0000:0000:0000:0000:0000:0001/128&quot;,
            ipaddress.IPv6Interface(&quot;::1/128&quot;).exploded,
        )
        # issue 77
        self.assertEqual(&quot;2001:0000:5ef5:79fd:0000:059d:a0e5:0ba1&quot;, addr2.exploded)
        self.assertEqual(&quot;2001:0000:0000:0000:0000:0000:0000:0000/96&quot;, addr3.exploded)
        self.assertEqual(&quot;192.168.178.1&quot;, addr4.exploded)

    def testReversePointer(self):
        addr1 = ipaddress.IPv4Address(&quot;127.0.0.1&quot;)
        addr2 = ipaddress.IPv6Address(&quot;2001:db8::1&quot;)
        self.assertEqual(&quot;1.0.0.127.in-addr.arpa&quot;, addr1.reverse_pointer)
        self.assertEqual(
            &quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.&quot;
            + &quot;b.d.0.1.0.0.2.ip6.arpa&quot;,
            addr2.reverse_pointer,
        )

    def testIntRepresentation(self):
        self.assertEqual(16909060, int(self.ipv4_address))
        self.assertEqual(42540616829182469433547762482097946625, int(self.ipv6_address))

    def testForceVersion(self):
        self.assertEqual(ipaddress.ip_network(1).version, 4)
        self.assertEqual(ipaddress.IPv6Network(1).version, 6)

    def testWithStar(self):
        self.assertEqual(self.ipv4_interface.with_prefixlen, &quot;1.2.3.4/24&quot;)
        self.assertEqual(self.ipv4_interface.with_netmask, &quot;1.2.3.4/255.255.255.0&quot;)
        self.assertEqual(self.ipv4_interface.with_hostmask, &quot;1.2.3.4/0.0.0.255&quot;)

        self.assertEqual(
            self.ipv6_interface.with_prefixlen, &quot;2001:658:22a:cafe:200::1/64&quot;
        )
        self.assertEqual(
            self.ipv6_interface.with_netmask,
            &quot;2001:658:22a:cafe:200::1/ffff:ffff:ffff:ffff::&quot;,
        )
        # this probably don't make much sense, but it's included for
        # compatibility with ipv4
        self.assertEqual(
            self.ipv6_interface.with_hostmask,
            &quot;2001:658:22a:cafe:200::1/::ffff:ffff:ffff:ffff&quot;,
        )

    def testNetworkElementCaching(self):
        # V4 - make sure we're empty
        self.assertNotIn(&quot;broadcast_address&quot;, self.ipv4_network._cache)
        self.assertNotIn(&quot;hostmask&quot;, self.ipv4_network._cache)

        # V4 - populate and test
        self.assertEqual(
            self.ipv4_network.broadcast_address, ipaddress.IPv4Address(&quot;1.2.3.255&quot;)
        )
        self.assertEqual(self.ipv4_network.hostmask, ipaddress.IPv4Address(&quot;0.0.0.255&quot;))

        # V4 - check we're cached
        self.assertIn(&quot;broadcast_address&quot;, self.ipv4_network._cache)
        self.assertIn(&quot;hostmask&quot;, self.ipv4_network._cache)

        # V6 - make sure we're empty
        self.assertNotIn(&quot;broadcast_address&quot;, self.ipv6_network._cache)
        self.assertNotIn(&quot;hostmask&quot;, self.ipv6_network._cache)

        # V6 - populate and test
        self.assertEqual(
            self.ipv6_network.network_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::&quot;),
        )
        self.assertEqual(
            self.ipv6_interface.network.network_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe::&quot;),
        )

        self.assertEqual(
            self.ipv6_network.broadcast_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;),
        )
        self.assertEqual(
            self.ipv6_network.hostmask, ipaddress.IPv6Address(&quot;::ffff:ffff:ffff:ffff&quot;)
        )
        self.assertEqual(
            self.ipv6_interface.network.broadcast_address,
            ipaddress.IPv6Address(&quot;2001:658:22a:cafe:ffff:ffff:ffff:ffff&quot;),
        )
        self.assertEqual(
            self.ipv6_interface.network.hostmask,
            ipaddress.IPv6Address(&quot;::ffff:ffff:ffff:ffff&quot;),
        )

        # V6 - check we're cached
        self.assertIn(&quot;broadcast_address&quot;, self.ipv6_network._cache)
        self.assertIn(&quot;hostmask&quot;, self.ipv6_network._cache)
        self.assertIn(&quot;broadcast_address&quot;, self.ipv6_interface.network._cache)
        self.assertIn(&quot;hostmask&quot;, self.ipv6_interface.network._cache)

    def testTeredo(self):
        # stolen from wikipedia
        server = ipaddress.IPv4Address(&quot;65.54.227.120&quot;)
        client = ipaddress.IPv4Address(&quot;192.0.2.45&quot;)
        teredo_addr = &quot;2001:0000:4136:e378:8000:63bf:3fff:fdd2&quot;
        self.assertEqual((server, client), ipaddress.ip_address(teredo_addr).teredo)
        bad_addr = &quot;2000::4136:e378:8000:63bf:3fff:fdd2&quot;
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)
        bad_addr = &quot;2001:0001:4136:e378:8000:63bf:3fff:fdd2&quot;
        self.assertFalse(ipaddress.ip_address(bad_addr).teredo)

        # i77
        teredo_addr = ipaddress.IPv6Address(&quot;2001:0:5ef5:79fd:0:59d:a0e5:ba1&quot;)
        self.assertEqual(
            (
                ipaddress.IPv4Address(&quot;94.245.121.253&quot;),
                ipaddress.IPv4Address(&quot;95.26.244.94&quot;),
            ),
            teredo_addr.teredo,
        )

    def testsixtofour(self):
        sixtofouraddr = ipaddress.ip_address(&quot;2002:ac1d:2d64::1&quot;)
        bad_addr = ipaddress.ip_address(&quot;2000:ac1d:2d64::1&quot;)
        self.assertEqual(
            ipaddress.IPv4Address(&quot;172.29.45.100&quot;), sixtofouraddr.sixtofour
        )
        self.assertFalse(bad_addr.sixtofour)

    # issue41004 Hash collisions in IPv4Interface and IPv6Interface
    def testV4HashIsNotConstant(self):
        ipv4_address1 = ipaddress.IPv4Interface(&quot;1.2.3.4&quot;)
        ipv4_address2 = ipaddress.IPv4Interface(&quot;2.3.4.5&quot;)
        self.assertNotEqual(ipv4_address1.__hash__(), ipv4_address2.__hash__())

    # issue41004 Hash collisions in IPv4Interface and IPv6Interface
    def testV6HashIsNotConstant(self):
        ipv6_address1 = ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:1&quot;)
        ipv6_address2 = ipaddress.IPv6Interface(&quot;2001:658:22a:cafe:200:0:0:2&quot;)
        self.assertNotEqual(ipv6_address1.__hash__(), ipv6_address2.__hash__())
</PRE>
</div>
  </div>
</body>
</html>
