
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.802292263610315%, Tokens: 9</h2>
        <div class="column">
            <h3>Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-stickertools.py</h3>
            <pre><code><span onclick='openModal()' class='match'>1  import glob
2  import io
3  import os
4  import random
5  from os import remove
6  try:
7      import cv2
8  except ImportError:
</span>9      cv2 = None
10  try:
11      import numpy as np
12  except ImportError:
13      np = None
14  try:
15      from PIL import Image, ImageDraw
16  except ImportError:
17      pass
18  from telethon.errors import PeerIdInvalidError, YouBlockedUserError
19  from telethon.tl.functions.messages import UploadMediaRequest
20  from telethon.tl.types import (
21      DocumentAttributeFilename,
22      DocumentAttributeSticker,
23      InputPeerSelf,
24  )
25  from telethon.utils import get_input_document
26  from . import (
27      KANGING_STR,
28      LOGS,
29      asst,
30      async_searcher,
31      bash,
32      con,
33      functions,
34      get_string,
35      inline_mention,
36      mediainfo,
37      quotly,
38      types,
39      udB,
40      ultroid_cmd,
41  )
42  @ultroid_cmd(pattern="packkang")
43  async def pack_kangish(_):
44      _e = await _.get_reply_message()
45      local = None
46      try:
47          cmdtext = _.text.split(maxsplit=1)[1]
48      except IndexError:
49          cmdtext = None
50      if cmdtext and os.path.isdir(cmdtext):
51          local = True
52      elif not (_e and _e.sticker and _e.file.mime_type == "image/webp"):
53          return await _.eor(get_string("sts_4"))
54      msg = await _.eor(get_string("com_1"))
55      _packname = cmdtext or f"Ultroid Kang Pack By {_.sender_id}"
56      typee = None
57      if not local:
58          _id = _e.media.document.attributes[1].stickerset.id
59          _hash = _e.media.document.attributes[1].stickerset.access_hash
60          _get_stiks = await _.client(
61              functions.messages.GetStickerSetRequest(
62                  stickerset=types.InputStickerSetID(id=_id, access_hash=_hash), hash=0
63              )
64          )
65          docs = _get_stiks.documents
66      else:
67          docs = []
68          exte = files[-1]
69          if exte.endswith(".tgs"):
70              typee = "anim"
71          elif exte.endswith(".webm"):
72              typee = "vid"
73          count = 0
74          for file in files:
75              if file.endswith((".tgs", ".webm")):
76                  count += 1
77                  upl = await asst.upload_file(file)
78                  docs.append(await asst(UploadMediaRequest(InputPeerSelf(), upl)))
79                  if count % 5 == 0:
80                      await msg.edit(f"`Uploaded {count} files.`")
81      stiks = []
82      for i in docs:
83          x = get_input_document(i)
84          stiks.append(
85              types.InputStickerSetItem(
86                  document=x,
87                  emoji=random.choice(["üòê", "üëç", "üòÇ"])
88                  if local
89                  else (i.attributes[1]).alt,
90              )
91          )
92      try:
93          short_name = "ult_" + _packname.replace(" ", "_") + str(_.id)
94          _r_e_s = await asst(
95              functions.stickers.CreateStickerSetRequest(
96                  user_id=_.sender_id,
97                  title=_packname,
98                  short_name=f"{short_name}_by_{asst.me.username}",
99                  animated=typee == "anim",
100                  videos=typee == "vid",
101                  stickers=stiks,
102              )
103          )
104      except PeerIdInvalidError:
105          return await msg.eor(
106              f"Hey {inline_mention(_.sender)} send `/start` to @{asst.me.username} and later try this command again.."
107          )
108      except BaseException as er:
109          LOGS.exception(er)
110          return await msg.eor(str(er))
111      await msg.eor(
112          get_string("sts_5").format(f"https://t.me/addstickers/{_r_e_s.set.short_name}"),
113      )
114  @ultroid_cmd(
115      pattern="kang",
116  )
117  async def hehe(args):
118      ultroid_bot = args.client
119      xx = await args.eor(get_string("com_1"))
120      user = ultroid_bot.me
121      username = user.username
122      username = f"@{username}" if username else user.first_name
123      message = await args.get_reply_message()
124      photo = None
125      is_anim, is_vid = False, False
126      emoji = None
127      if not message:
128          return await xx.eor(get_string("sts_6"))
129      if message.photo:
130          photo = io.BytesIO()
131          photo = await ultroid_bot.download_media(message.photo, photo)
132      elif message.file and "image" in message.file.mime_type.split("/"):
133          photo = io.BytesIO()
134          await ultroid_bot.download_file(message.media.document, photo)
135          if (
136              DocumentAttributeFilename(file_name="sticker.webp")
137              in message.media.document.attributes
138          ):
139              emoji = message.media.document.attributes[1].alt
140      elif message.file and "video" in message.file.mime_type.split("/"):
141          xy = await message.download_media()
142          if (message.file.duration or 0) <= 10:
143              is_vid = True
144              photo = await con.create_webm(xy)
145          else:
146              y = cv2.VideoCapture(xy)
147              heh, lol = y.read()
148              cv2.imwrite("ult.webp", lol)
149              photo = "ult.webp"
150      elif message.file and "tgsticker" in message.file.mime_type:
151          await ultroid_bot.download_file(
152              message.media.document,
153              "AnimatedSticker.tgs",
154          )
155          attributes = message.media.document.attributes
156          for attribute in attributes:
157              if isinstance(attribute, DocumentAttributeSticker):
158                  emoji = attribute.alt
159          is_anim = True
160          photo = 1
161      elif message.message:
162          photo = await quotly.create_quotly(message)
163      else:
164          return await xx.edit(get_string("com_4"))
165      if not udB.get_key("language") or udB.get_key("language") == "en":
166          ra = random.choice(KANGING_STR)
167      else:
168          ra = get_string("sts_11")
169      await xx.edit(f"`{ra}`")
170      if photo:
171          splat = args.text.split()
172          pack = 1
173          if not emoji:
174              emoji = "üèµ"
175          if len(splat) == 3:
176              pack = splat[2]  # User sent ultroid_both
177              emoji = splat[1]
178          elif len(splat) == 2:
179              if splat[1].isnumeric():
180                  pack = int(splat[1])
181              else:
182                  emoji = splat[1]
183          packname = f"ult_{user.id}_{pack}"
184          packnick = f"{username}'s Pack {pack}"
185          cmd = "/newpack"
186          file = io.BytesIO()
187          if is_vid:
188              packname += "_vid"
189              packnick += " (Video)"
190              cmd = "/newvideo"
191          elif is_anim:
192              packname += "_anim"
193              packnick += " (Animated)"
194              cmd = "/newanimated"
195          else:
196              image = con.resize_photo_sticker(photo)
197              file.name = "sticker.png"
198              image.save(file, "PNG")
199          response = await async_searcher(f"http://t.me/addstickers/{packname}")
200          htmlstr = response.split("\n")
201          if (
202              "  A <strong>Telegram</strong> user has created the <strong>Sticker&nbsp;Set</strong>."
203              not in htmlstr
204          ):
205              async with ultroid_bot.conversation("@Stickers") as conv:
206                  try:
207                      await conv.send_message("/addsticker")
208                  except YouBlockedUserError:
209                      LOGS.info("Unblocking @Stickers for kang...")
210                      await ultroid_bot(functions.contacts.UnblockRequest("stickers"))
211                      await conv.send_message("/addsticker")
212                  await conv.get_response()
213                  await conv.send_message(packname)
214                  x = await conv.get_response()
215                  if x.text.startswith("Alright! Now send me the video sticker."):
216                      await conv.send_file(photo, force_document=True)
217                      x = await conv.get_response()
218                  t = "50" if (is_anim or is_vid) else "120"
219                  while t in x.message:
220                      pack += 1
221                      packname = f"ult_{user.id}_{pack}"
222                      packnick = f"{username}'s Pack {pack}"
223                      if is_anim:
224                          packname += "_anim"
225                          packnick += " (Animated)"
226                      elif is_vid:
227                          packnick += " (Video)"
228                          packname += "_vid"
229                      await xx.edit(get_string("sts_13").format(pack))
230                      await conv.send_message("/addsticker")
231                      await conv.get_response()
232                      await conv.send_message(packname)
233                      x = await conv.get_response()
234                      if x.text.startswith("Alright! Now send me the video sticker."):
235                          await conv.send_file(photo, force_document=True)
236                          x = await conv.get_response()
237                      if x.text in ["Invalid pack selected.", "Invalid set selected."]:
238                          await conv.send_message(cmd)
239                          await conv.get_response()
240                          await conv.send_message(packnick)
241                          await conv.get_response()
242                          if is_anim:
243                              await conv.send_file("AnimatedSticker.tgs")
244                              remove("AnimatedSticker.tgs")
245                          else:
246                              if is_vid:
247                                  file = photo
248                              else:
249                                  file.seek(0)
250                              await conv.send_file(file, force_document=True)
251                          await conv.get_response()
252                          await conv.send_message(emoji)
253                          await conv.get_response()
254                          await conv.send_message("/publish")
255                          if is_anim:
256                              await conv.get_response()
257                              await conv.send_message(f"<{packnick}>")
258                          await conv.get_response()
259                          await conv.send_message("/skip")
260                          await conv.get_response()
261                          await conv.send_message(packname)
262                          await conv.get_response()
263                          await xx.edit(
264                              get_string("sts_7").format(packname),
265                              parse_mode="md",
266                          )
267                          return
268                  if is_anim:
269                      await conv.send_file("AnimatedSticker.tgs")
270                      remove("AnimatedSticker.tgs")
271                  elif "send me an emoji" not in x.message:
272                      if is_vid:
273                          file = photo
274                      else:
275                          file.seek(0)
276                      await conv.send_file(file, force_document=True)
277                      rsp = await conv.get_response()
278                      if "Sorry, the file type is invalid." in rsp.text:
279                          await xx.edit(
280                              get_string("sts_8"),
281                          )
282                          return
283                  await conv.send_message(emoji)
284                  await conv.get_response()
285                  await conv.send_message("/done")
286                  await conv.get_response()
287                  await ultroid_bot.send_read_acknowledge(conv.chat_id)
288          else:
289              await xx.edit("`Brewing a new Pack...`")
290              async with ultroid_bot.conversation("Stickers") as conv:
291                  await conv.send_message(cmd)
292                  await conv.get_response()
293                  await conv.send_message(packnick)
294                  await conv.get_response()
295                  if is_anim:
296                      await conv.send_file("AnimatedSticker.tgs")
297                      remove("AnimatedSticker.tgs")
298                  else:
299                      if is_vid:
300                          file = photo
301                      else:
302                          file.seek(0)
303                      await conv.send_file(file, force_document=True)
304                  rsp = await conv.get_response()
305                  if "Sorry, the file type is invalid." in rsp.text:
306                      await xx.edit(
307                          get_string("sts_8"),
308                      )
309                      return
310                  await conv.send_message(emoji)
311                  await conv.get_response()
312                  await conv.send_message("/publish")
313                  if is_anim:
314                      await conv.get_response()
315                      await conv.send_message(f"<{packnick}>")
316                  await conv.get_response()
317                  await conv.send_message("/skip")
318                  await conv.get_response()
319                  await conv.send_message(packname)
320                  await conv.get_response()
321                  await ultroid_bot.send_read_acknowledge(conv.chat_id)
322          await xx.edit(
323              get_string("sts_12").format(emoji, packname),
324              parse_mode="md",
325          )
326          try:
327              os.remove(photo)
328          except BaseException:
329              pass
330  @ultroid_cmd(
331      pattern="round$",
332  )
333  async def ultdround(event):
334      ureply = await event.get_reply_message()
335      xx = await event.eor(get_string("com_1"))
336      if not (ureply and (ureply.media)):
337          await xx.edit(get_string("sts_10"))
338          return
339      ultt = await ureply.download_media()
340      file = await con.convert(
341          ultt,
342          convert_to="png",
343          allowed_formats=["jpg", "jpeg", "png"],
344          outname="round",
345          remove_old=True,
346      )
347      img = Image.open(file).convert("RGB")
348      npImage = np.array(img)
349      h, w = img.size
350      alpha = Image.new("L", img.size, 0)
351      draw = ImageDraw.Draw(alpha)
352      draw.pieslice([0, 0, h, w], 0, 360, fill=255)
353      npAlpha = np.array(alpha)
354      npImage = np.dstack((npImage, npAlpha))
355      Image.fromarray(npImage).save("ult.webp")
356      await event.client.send_file(
357          event.chat_id,
358          "ult.webp",
359          force_document=False,
360          reply_to=event.reply_to_msg_id,
361      )
362      await xx.delete()
363      os.remove(file)
364      os.remove("ult.webp")
365  @ultroid_cmd(
366      pattern="destroy$",
367  )
368  async def ultdestroy(event):
369      ult = await event.get_reply_message()
370      if not (ult and ult.media and "animated" in mediainfo(ult.media)):
371          return await event.eor(get_string("sts_2"))
372      await event.client.download_media(ult, "ultroid.tgs")
373      xx = await event.eor(get_string("com_1"))
374      await bash("lottie_convert.py ultroid.tgs json.json")
375      with open("json.json") as json:
376          jsn = json.read()
377      jsn = (
378          jsn.replace("[100]", "[200]")
379          .replace("[10]", "[40]")
380          .replace("[-1]", "[-10]")
381          .replace("[0]", "[15]")
382          .replace("[1]", "[20]")
383          .replace("[2]", "[17]")
384          .replace("[3]", "[40]")
385          .replace("[4]", "[37]")
386          .replace("[5]", "[60]")
387          .replace("[6]", "[70]")
388          .replace("[7]", "[40]")
389          .replace("[8]", "[37]")
390          .replace("[9]", "[110]")
391      )
392      open("json.json", "w").write(jsn)
393      file = await con.animated_sticker("json.json", "ultroid.tgs")
394      if file:
395          await event.client.send_file(
396              event.chat_id,
397              file="ultroid.tgs",
398              force_document=False,
399              reply_to=event.reply_to_msg_id,
400          )
401      await xx.delete()
402      os.remove("json.json")
403  @ultroid_cmd(
404      pattern="tiny$",
405  )
406  async def ultiny(event):
407      reply = await event.get_reply_message()
408      if not (reply and (reply.media)):
409          await event.eor(get_string("sts_10"))
410          return
411      xx = await event.eor(get_string("com_1"))
412      ik = await reply.download_media()
413      im1 = Image.open("resources/extras/ultroid_blank.png")
414      if ik.endswith(".tgs"):
415          await con.animated_sticker(ik, "json.json")
416          with open("json.json") as json:
417              jsn = json.read()
418          jsn = jsn.replace("512", "2000")
419          open("json.json", "w").write(jsn)
420          await con.animated_sticker("json.json", "ult.tgs")
421          file = "ult.tgs"
422          os.remove("json.json")
423      elif ik.endswith((".gif", ".webm", ".mp4")):
424          iik = cv2.VideoCapture(ik)
425          dani, busy = iik.read()
426          cv2.imwrite("i.png", busy)
427          fil = "i.png"
428          im = Image.open(fil)
429          z, d = im.size
430          if z == d:
431              xxx, yyy = 200, 200
432          else:
433              t = z + d
434              a = z / t
435              b = d / t
436              aa = (a * 100) - 50
437              bb = (b * 100) - 50
438              xxx = 200 + 5 * aa
439              yyy = 200 + 5 * bb
440          k = im.resize((int(xxx), int(yyy)))
441          k.save("k.png", format="PNG", optimize=True)
442          im2 = Image.open("k.png")
443          back_im = im1.copy()
444          back_im.paste(im2, (150, 0))
445          back_im.save("o.webp", "WEBP", quality=95)
446          file = "o.webp"
447          os.remove(fil)
448          os.remove("k.png")
449      else:
450          im = Image.open(ik)
451          z, d = im.size
452          if z == d:
453              xxx, yyy = 200, 200
454          else:
455              t = z + d
456              a = z / t
457              b = d / t
458              aa = (a * 100) - 50
459              bb = (b * 100) - 50
460              xxx = 200 + 5 * aa
461              yyy = 200 + 5 * bb
462          k = im.resize((int(xxx), int(yyy)))
463          k.save("k.png", format="PNG", optimize=True)
464          im2 = Image.open("k.png")
465          back_im = im1.copy()
466          back_im.paste(im2, (150, 0))
467          back_im.save("o.webp", "WEBP", quality=95)
468          file = "o.webp"
469          os.remove("k.png")
470      if os.path.exists(file):
471          await event.client.send_file(
472              event.chat_id, file, reply_to=event.reply_to_msg_id
473          )
474          os.remove(file)
475      await xx.delete()
476      os.remove(ik)
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</h3>
            <pre><code>1  import base64
2  import hashlib
3  import itertools
4  import json
5  import os
6  import re
7  import string
8  import struct
9  import sys
<span onclick='openModal()' class='match'>10  import time
11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
20  from .util import FatalError, NotImplementedInROMError, UnsupportedCommandError
21  from .util import byte, hexify, mask_to_shift, pad_to, strip_chip_name
22  try:
23      import serial
24  except ImportError:
</span>25      print(
26          "Pyserial is not installed for %s. "
27          "Check the README for installation instructions." % (sys.executable)
28      )
29      raise
30  try:
31      if "serialization" in serial.__doc__ and "deserialization" in serial.__doc__:
32          raise ImportError(
33              "esptool.py depends on pyserial, but there is a conflict with a currently "
34              "installed package named 'serial'.\n"
35              "You may work around this by 'pip uninstall serial; pip install pyserial' "
36              "but this may break other installed Python software "
37              "that depends on 'serial'.\n"
38              "There is no good fix for this right now, "
39              "apart from configuring virtualenvs. "
40              "See https://github.com/espressif/esptool/issues/269#issuecomment-385298196"
41              " for discussion of the underlying issue(s)."
42          )
43  except TypeError:
44      pass  # __doc__ returns None for pyserial
45  try:
46      import serial.tools.list_ports as list_ports
47  except ImportError:
48      print(
49          "The installed version (%s) of pyserial appears to be too old for esptool.py "
50          "(Python interpreter %s). Check the README for installation instructions."
51          % (sys.VERSION, sys.executable)
52      )
53      raise
54  except Exception:
55      if sys.platform == "darwin":
56          list_ports = None
57      else:
58          raise
59  cfg, _ = load_config_file()
60  cfg = cfg["esptool"]
61  DEFAULT_TIMEOUT = cfg.getfloat("timeout", 3)
62  CHIP_ERASE_TIMEOUT = cfg.getfloat("chip_erase_timeout", 120)
63  MAX_TIMEOUT = cfg.getfloat("max_timeout", CHIP_ERASE_TIMEOUT * 2)
64  SYNC_TIMEOUT = cfg.getfloat("sync_timeout", 0.1)
65  MD5_TIMEOUT_PER_MB = cfg.getfloat("md5_timeout_per_mb", 8)
66  ERASE_REGION_TIMEOUT_PER_MB = cfg.getfloat("erase_region_timeout_per_mb", 30)
67  ERASE_WRITE_TIMEOUT_PER_MB = cfg.getfloat("erase_write_timeout_per_mb", 40)
68  MEM_END_ROM_TIMEOUT = cfg.getfloat("mem_end_rom_timeout", 0.2)
69  DEFAULT_SERIAL_WRITE_TIMEOUT = cfg.getfloat("serial_write_timeout", 10)
70  DEFAULT_CONNECT_ATTEMPTS = cfg.getint("connect_attempts", 7)
71  WRITE_BLOCK_ATTEMPTS = cfg.getint("write_block_attempts", 3)
72  STUBS_DIR = os.path.join(os.path.dirname(__file__), "targets", "stub_flasher")
73  def get_stub_json_path(chip_name):
74      chip_name = strip_chip_name(chip_name)
75      chip_name = chip_name.replace("esp", "")
76      return os.path.join(STUBS_DIR, f"stub_flasher_{chip_name}.json")
77  def timeout_per_mb(seconds_per_mb, size_bytes):
78      result = seconds_per_mb * (size_bytes / 1e6)
79      if result < DEFAULT_TIMEOUT:
80          return DEFAULT_TIMEOUT
81      return result
82  def check_supported_function(func, check_func):
83      def inner(*args, **kwargs):
84          obj = args[0]
85          if check_func(obj):
86              return func(*args, **kwargs)
87          else:
88              raise NotImplementedInROMError(obj, func)
89      return inner
90  def stub_function_only(func):
91      return check_supported_function(func, lambda o: o.IS_STUB)
92  def stub_and_esp32_function_only(func):
93      return check_supported_function(
94          func, lambda o: o.IS_STUB or o.CHIP_NAME not in ["ESP8266"]
95      )
96  def esp32s3_or_newer_function_only(func):
97      return check_supported_function(
98          func, lambda o: o.CHIP_NAME not in ["ESP8266", "ESP32", "ESP32-S2"]
99      )
100  class StubFlasher:
101      def __init__(self, json_path):
102          with open(json_path) as json_file:
103              stub = json.load(json_file)
104          self.text = base64.b64decode(stub["text"])
105          self.text_start = stub["text_start"]
106          self.entry = stub["entry"]
107          try:
108              self.data = base64.b64decode(stub["data"])
109              self.data_start = stub["data_start"]
110          except KeyError:
111              self.data = None
112              self.data_start = None
113  class ESPLoader(object):
114      CHIP_NAME = "Espressif device"
115      IS_STUB = False
116      FPGA_SLOW_BOOT = False
117      DEFAULT_PORT = "/dev/ttyUSB0"
118      USES_RFC2217 = False
119      ESP_FLASH_BEGIN = 0x02
120      ESP_FLASH_DATA = 0x03
121      ESP_FLASH_END = 0x04
122      ESP_MEM_BEGIN = 0x05
123      ESP_MEM_END = 0x06
124      ESP_MEM_DATA = 0x07
125      ESP_SYNC = 0x08
126      ESP_WRITE_REG = 0x09
127      ESP_READ_REG = 0x0A
128      ESP_SPI_SET_PARAMS = 0x0B
129      ESP_SPI_ATTACH = 0x0D
130      ESP_READ_FLASH_SLOW = 0x0E  # ROM only, much slower than the stub flash read
131      ESP_CHANGE_BAUDRATE = 0x0F
132      ESP_FLASH_DEFL_BEGIN = 0x10
133      ESP_FLASH_DEFL_DATA = 0x11
134      ESP_FLASH_DEFL_END = 0x12
135      ESP_SPI_FLASH_MD5 = 0x13
136      ESP_GET_SECURITY_INFO = 0x14
137      ESP_ERASE_FLASH = 0xD0
138      ESP_ERASE_REGION = 0xD1
139      ESP_READ_FLASH = 0xD2
140      ESP_RUN_USER_CODE = 0xD3
141      ESP_FLASH_ENCRYPT_DATA = 0xD4
142      ROM_INVALID_RECV_MSG = 0x05  # response if an invalid message is received
143      ESP_RAM_BLOCK = 0x1800
144      FLASH_WRITE_SIZE = 0x400
145      ESP_ROM_BAUD = 115200
146      ESP_IMAGE_MAGIC = 0xE9
147      ESP_CHECKSUM_MAGIC = 0xEF
148      FLASH_SECTOR_SIZE = 0x1000
149      UART_DATE_REG_ADDR = 0x60000078
150      CHIP_DETECT_MAGIC_REG_ADDR = 0x40001000
151      UART_CLKDIV_MASK = 0xFFFFF
152      IROM_MAP_START = 0x40200000
153      IROM_MAP_END = 0x40300000
154      STATUS_BYTES_LENGTH = 2
155      BOOTLOADER_FLASH_OFFSET = 0x0
156      SUPPORTS_ENCRYPTED_FLASH = False
157      sync_stub_detected = False
158      USB_JTAG_SERIAL_PID = 0x1001
159      UNSUPPORTED_CHIPS = {6: "ESP32-S3(beta 3)"}
160      def __init__(self, port=DEFAULT_PORT, baud=ESP_ROM_BAUD, trace_enabled=False):
161          self.secure_download_mode = False
162          self.stub_is_disabled = False
163          self.cache = {
164              "flash_id": None,
165              "chip_id": None,
166              "uart_no": None,
167          }
168          if isinstance(port, str):
169              try:
170                  self._port = serial.serial_for_url(port)
171              except serial.serialutil.SerialException:
172                  raise FatalError(f"Could not open {port}, the port doesn't exist")
173          else:
174              self._port = port
175          self._slip_reader = slip_reader(self._port, self.trace)
176          self._set_port_baudrate(baud)
177          self._trace_enabled = trace_enabled
178          try:
179              self._port.write_timeout = DEFAULT_SERIAL_WRITE_TIMEOUT
180          except NotImplementedError:
181              self._port.write_timeout = None
182      @property
183      def serial_port(self):
184          return self._port.port
185      def _set_port_baudrate(self, baud):
186          try:
187              self._port.baudrate = baud
188          except IOError:
189              raise FatalError(
190                  "Failed to set baud rate %d. The driver may not support this rate."
191                  % baud
192              )
193      def read(self):
194          return next(self._slip_reader)
195      def write(self, packet):
196          buf = (
197              b"\xc0"
198              + (packet.replace(b"\xdb", b"\xdb\xdd").replace(b"\xc0", b"\xdb\xdc"))
199              + b"\xc0"
200          )
201          self.trace("Write %d bytes: %s", len(buf), HexFormatter(buf))
202          self._port.write(buf)
203      def trace(self, message, *format_args):
204          if self._trace_enabled:
205              now = time.time()
206              try:
207                  delta = now - self._last_trace
208              except AttributeError:
209                  delta = 0.0
210              self._last_trace = now
211              prefix = "TRACE +%.3f " % delta
212              print(prefix + (message % format_args))
213      @staticmethod
214      def checksum(data, state=ESP_CHECKSUM_MAGIC):
215          for b in data:
216              state ^= b
217          return state
218      def command(
219          self,
220          op=None,
221          data=b"",
222          chk=0,
223          wait_response=True,
224          timeout=DEFAULT_TIMEOUT,
225      ):
226          saved_timeout = self._port.timeout
227          new_timeout = min(timeout, MAX_TIMEOUT)
228          if new_timeout != saved_timeout:
229              self._port.timeout = new_timeout
230          try:
231              if op is not None:
232                  self.trace(
233                      "command op=0x%02x data len=%s wait_response=%d "
234                      "timeout=%.3f data=%s",
235                      op,
236                      len(data),
237                      1 if wait_response else 0,
238                      timeout,
239                      HexFormatter(data),
240                  )
241                  pkt = struct.pack(b"<BBHI", 0x00, op, len(data), chk) + data
242                  self.write(pkt)
243              if not wait_response:
244                  return
245              for retry in range(100):
246                  p = self.read()
247                  if len(p) < 8:
248                      continue
249                  (resp, op_ret, len_ret, val) = struct.unpack("<BBHI", p[:8])
250                  if resp != 1:
251                      continue
252                  data = p[8:]
253                  if op is None or op_ret == op:
254                      return val, data
255                  if byte(data, 0) != 0 and byte(data, 1) == self.ROM_INVALID_RECV_MSG:
256                      self.flush_input()
257                      raise UnsupportedCommandError(self, op)
258          finally:
259              if new_timeout != saved_timeout:
260                  self._port.timeout = saved_timeout
261          raise FatalError("Response doesn't match request")
262      def check_command(
263          self, op_description, op=None, data=b"", chk=0, timeout=DEFAULT_TIMEOUT
264      ):
265          val, data = self.command(op, data, chk, timeout=timeout)
266          if len(data) < self.STATUS_BYTES_LENGTH:
267              raise FatalError(
268                  "Failed to %s. Only got %d byte status response."
269                  % (op_description, len(data))
270              )
271          status_bytes = data[-self.STATUS_BYTES_LENGTH :]
272          if byte(status_bytes, 0) != 0:
273              raise FatalError.WithResult("Failed to %s" % op_description, status_bytes)
274          if len(data) > self.STATUS_BYTES_LENGTH:
275              return data[: -self.STATUS_BYTES_LENGTH]
276          else:
277              return val
278      def flush_input(self):
279          self._port.flushInput()
280          self._slip_reader = slip_reader(self._port, self.trace)
281      def sync(self):
282          val, _ = self.command(
283              self.ESP_SYNC, b"\x07\x07\x12\x20" + 32 * b"\x55", timeout=SYNC_TIMEOUT
284          )
285          self.sync_stub_detected = val == 0
286          for _ in range(7):
287              val, _ = self.command()
288              self.sync_stub_detected &= val == 0
289      def _get_pid(self):
290          if list_ports is None:
291              print(
292                  "\nListing all serial ports is currently not available. "
293                  "Can't get device PID."
294              )
295              return
296          active_port = self._port.port
297          if not active_port.lower().startswith(("com", "/dev/")):
298              print(
299                  "\nDevice PID identification is only supported on "
300                  "COM and /dev/ serial ports."
301              )
302              return
303          if active_port.startswith("/dev/") and os.path.islink(active_port):
304              active_port = os.path.realpath(active_port)
305          active_ports = [active_port]
306          if sys.platform == "darwin" and "tty" in active_port:
307              active_ports.append(active_port.replace("tty", "cu"))
308          ports = list_ports.comports()
309          for p in ports:
310              if p.device in active_ports:
311                  return p.pid
312          print(
313              "\nFailed to get PID of a device on {}, "
314              "using standard reset sequence.".format(active_port)
315          )
316      def _connect_attempt(self, reset_strategy, mode="default_reset"):
317          last_error = None
318          boot_log_detected = False
319          download_mode = False
320          if mode == "no_reset_no_sync":
321              return last_error
322          if mode != "no_reset":
323              if not self.USES_RFC2217:  # Might block on rfc2217 ports
324                  self._port.reset_input_buffer()
325              reset_strategy()  # Reset the chip to bootloader (download mode)
326              waiting = self._port.inWaiting()
327              read_bytes = self._port.read(waiting)
328              data = re.search(
329                  b"boot:(0x[0-9a-fA-F]+)(.*waiting for download)?", read_bytes, re.DOTALL
330              )
331              if data is not None:
332                  boot_log_detected = True
333                  boot_mode = data.group(1)
334                  download_mode = data.group(2) is not None
335          for _ in range(5):
336              try:
337                  self.flush_input()
338                  self._port.flushOutput()
339                  self.sync()
340                  return None
341              except FatalError as e:
342                  print(".", end="")
343                  sys.stdout.flush()
344                  time.sleep(0.05)
345                  last_error = e
346          if boot_log_detected:
347              last_error = FatalError(
348                  "Wrong boot mode detected ({})! "
349                  "The chip needs to be in download mode.".format(
350                      boot_mode.decode("utf-8")
351                  )
352              )
353              if download_mode:
354                  last_error = FatalError(
355                      "Download mode successfully detected, but getting no sync reply: "
356                      "The serial TX path seems to be down."
357                  )
358          return last_error
359      def get_memory_region(self, name):
360          try:
361              return [(start, end) for (start, end, n) in self.MEMORY_MAP if n == name][0]
362          except IndexError:
363              return None
364      def _construct_reset_strategy_sequence(self, mode):
365          cfg_custom_reset_sequence = cfg.get("custom_reset_sequence")
366          if cfg_custom_reset_sequence is not None:
367              return (CustomReset(self._port, cfg_custom_reset_sequence),)
368          cfg_reset_delay = cfg.getfloat("reset_delay")
369          if cfg_reset_delay is not None:
370              delay = extra_delay = cfg_reset_delay
371          else:
372              delay = DEFAULT_RESET_DELAY
373              extra_delay = DEFAULT_RESET_DELAY + 0.5
374          if (
375              self.FPGA_SLOW_BOOT
376              and os.environ.get("ESPTOOL_ENV_FPGA", "").strip() == "1"
377          ):
378              delay = extra_delay = 7
379          if mode == "usb_reset" or self._get_pid() == self.USB_JTAG_SERIAL_PID:
380              return (USBJTAGSerialReset(self._port),)
381          if os.name != "nt" and not self._port.name.startswith("rfc2217:"):
382              return (
383                  UnixTightReset(self._port, delay),
384                  UnixTightReset(self._port, extra_delay),
385                  ClassicReset(self._port, delay),
386                  ClassicReset(self._port, extra_delay),
387              )
388          return (
389              ClassicReset(self._port, delay),
390              ClassicReset(self._port, extra_delay),
391          )
392      def connect(
393          self,
394          mode="default_reset",
395          attempts=DEFAULT_CONNECT_ATTEMPTS,
396          detecting=False,
397          warnings=True,
398      ):
399          if warnings and mode in ["no_reset", "no_reset_no_sync"]:
400              print(
401                  'WARNING: Pre-connection option "{}" was selected.'.format(mode),
402                  "Connection may fail if the chip is not in bootloader "
403                  "or flasher stub mode.",
404              )
405          print("Connecting...", end="")
406          sys.stdout.flush()
407          last_error = None
408          reset_sequence = self._construct_reset_strategy_sequence(mode)
409          try:
410              for _, reset_strategy in zip(
411                  range(attempts) if attempts > 0 else itertools.count(),
412                  itertools.cycle(reset_sequence),
413              ):
414                  last_error = self._connect_attempt(reset_strategy, mode)
415                  if last_error is None:
416                      break
417          finally:
418              print("")  # end 'Connecting...' line
419          if last_error is not None:
420              raise FatalError(
421                  "Failed to connect to {}: {}"
422                  "\nFor troubleshooting steps visit: "
423                  "https://docs.espressif.com/projects/esptool/en/latest/troubleshooting.html".format(  # noqa E501
424                      self.CHIP_NAME, last_error
425                  )
426              )
427          if not detecting:
428              try:
429                  from .targets import ROM_LIST
430                  chip_magic_value = self.read_reg(ESPLoader.CHIP_DETECT_MAGIC_REG_ADDR)
431                  if chip_magic_value not in self.CHIP_DETECT_MAGIC_VALUE:
432                      actually = None
433                      for cls in ROM_LIST:
434                          if chip_magic_value in cls.CHIP_DETECT_MAGIC_VALUE:
435                              actually = cls
436                              break
437                      if warnings and actually is None:
438                          print(
439                              "WARNING: This chip doesn't appear to be a %s "
440                              "(chip magic value 0x%08x). "
441                              "Probably it is unsupported by this version of esptool."
442                              % (self.CHIP_NAME, chip_magic_value)
443                          )
444                      else:
445                          raise FatalError(
446                              "This chip is %s not %s. Wrong --chip argument?"
447                              % (actually.CHIP_NAME, self.CHIP_NAME)
448                          )
449              except UnsupportedCommandError:
450                  self.secure_download_mode = True
451              try:
452                  self.check_chip_id()
453              except UnsupportedCommandError:
454                  if self.secure_download_mode:
455                      self._connect_attempt(mode, reset_sequence[0])
456                      self.check_chip_id()
457                  else:
458                      raise
459              self._post_connect()
460      def _post_connect(self):
461          pass
462      def read_reg(self, addr, timeout=DEFAULT_TIMEOUT):
463          val, data = self.command(
464              self.ESP_READ_REG, struct.pack("<I", addr), timeout=timeout
465          )
466          if byte(data, 0) != 0:
467              raise FatalError.WithResult(
468                  "Failed to read register address %08x" % addr, data
469              )
470          return val
471      def write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0, delay_after_us=0):
472          command = struct.pack("<IIII", addr, value, mask, delay_us)
473          if delay_after_us > 0:
474              command += struct.pack(
475                  "<IIII", self.UART_DATE_REG_ADDR, 0, 0, delay_after_us
476              )
477          return self.check_command("write target memory", self.ESP_WRITE_REG, command)
478      def update_reg(self, addr, mask, new_val):
479          shift = mask_to_shift(mask)
480          val = self.read_reg(addr)
481          val &= ~mask
482          val |= (new_val << shift) & mask
483          self.write_reg(addr, val)
484          return val
485      def mem_begin(self, size, blocks, blocksize, offset):
486          if self.IS_STUB:
487              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
488              load_start = offset
489              load_end = offset + size
490              for start, end in [
491                  (stub.data_start, stub.data_start + len(stub.data)),
492                  (stub.text_start, stub.text_start + len(stub.text)),
493              ]:
494                  if load_start < end and load_end > start:
495                      raise FatalError(
496                          "Software loader is resident at 0x%08x-0x%08x. "
497                          "Can't load binary at overlapping address range 0x%08x-0x%08x. "
498                          "Either change binary loading address, or use the --no-stub "
499                          "option to disable the software loader."
500                          % (start, end, load_start, load_end)
501                      )
502          return self.check_command(
503              "enter RAM download mode",
504              self.ESP_MEM_BEGIN,
505              struct.pack("<IIII", size, blocks, blocksize, offset),
506          )
507      def mem_block(self, data, seq):
508          return self.check_command(
509              "write to target RAM",
510              self.ESP_MEM_DATA,
511              struct.pack("<IIII", len(data), seq, 0, 0) + data,
512              self.checksum(data),
513          )
514      def mem_finish(self, entrypoint=0):
515          timeout = DEFAULT_TIMEOUT if self.IS_STUB else MEM_END_ROM_TIMEOUT
516          data = struct.pack("<II", int(entrypoint == 0), entrypoint)
517          try:
518              return self.check_command(
519                  "leave RAM download mode", self.ESP_MEM_END, data=data, timeout=timeout
520              )
521          except FatalError:
522              if self.IS_STUB:
523                  raise
524              pass
525      def flash_begin(self, size, offset, begin_rom_encrypted=False):
526          num_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
527          erase_size = self.get_erase_size(offset, size)
528          t = time.time()
529          if self.IS_STUB:
530              timeout = DEFAULT_TIMEOUT
531          else:
532              timeout = timeout_per_mb(
533                  ERASE_REGION_TIMEOUT_PER_MB, size
534              )  # ROM performs the erase up front
535          params = struct.pack(
536              "<IIII", erase_size, num_blocks, self.FLASH_WRITE_SIZE, offset
537          )
538          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
539              params += struct.pack("<I", 1 if begin_rom_encrypted else 0)
540          self.check_command(
541              "enter Flash download mode", self.ESP_FLASH_BEGIN, params, timeout=timeout
542          )
543          if size != 0 and not self.IS_STUB:
544              print("Took %.2fs to erase flash block" % (time.time() - t))
545          return num_blocks
546      def flash_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
547          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
548              try:
549                  self.check_command(
550                      "write to target Flash after seq %d" % seq,
551                      self.ESP_FLASH_DATA,
552                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
553                      self.checksum(data),
554                      timeout=timeout,
555                  )
556                  break
557              except FatalError:
558                  if attempts_left:
559                      self.trace(
560                          "Block write failed, "
561                          f"retrying with {attempts_left} attempts left"
562                      )
563                  else:
564                      raise
565      def flash_encrypt_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
566          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
567              return self.flash_block(data, seq, timeout)
568          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
569              try:
570                  self.check_command(
571                      "Write encrypted to target Flash after seq %d" % seq,
572                      self.ESP_FLASH_ENCRYPT_DATA,
573                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
574                      self.checksum(data),
575                      timeout=timeout,
576                  )
577                  break
578              except FatalError:
579                  if attempts_left:
580                      self.trace(
581                          "Encrypted block write failed, "
582                          f"retrying with {attempts_left} attempts left"
583                      )
584                  else:
585                      raise
586      def flash_finish(self, reboot=False):
587          pkt = struct.pack("<I", int(not reboot))
588          self.check_command("leave Flash mode", self.ESP_FLASH_END, pkt)
589      def run(self, reboot=False):
590          self.flash_begin(0, 0)
591          self.flash_finish(reboot)
592      def flash_id(self):
593          if self.cache["flash_id"] is None:
594              SPIFLASH_RDID = 0x9F
595              self.cache["flash_id"] = self.run_spiflash_command(SPIFLASH_RDID, b"", 24)
596          return self.cache["flash_id"]
597      def flash_type(self):
598          return None  # not implemented for all chip targets
599      def get_security_info(self):
600          res = self.check_command("get security info", self.ESP_GET_SECURITY_INFO, b"")
601          esp32s2 = True if len(res) == 12 else False
602          res = struct.unpack("<IBBBBBBBB" if esp32s2 else "<IBBBBBBBBII", res)
603          return {
604              "flags": res[0],
605              "flash_crypt_cnt": res[1],
606              "key_purposes": res[2:9],
607              "chip_id": None if esp32s2 else res[9],
608              "api_version": None if esp32s2 else res[10],
609          }
610      @esp32s3_or_newer_function_only
611      def get_chip_id(self):
612          if self.cache["chip_id"] is None:
613              res = self.check_command(
614                  "get security info", self.ESP_GET_SECURITY_INFO, b""
615              )
616              res = struct.unpack(
617                  "<IBBBBBBBBI", res[:16]
618              )  # 4b flags, 1b flash_crypt_cnt, 7*1b key_purposes, 4b chip_id
619              self.cache["chip_id"] = res[9]  # 2/4 status bytes invariant
620          return self.cache["chip_id"]
621      def get_uart_no(self):
622          if self.cache["uart_no"] is None:
623              self.cache["uart_no"] = self.read_reg(self.UARTDEV_BUF_NO) & 0xFF
624          return self.cache["uart_no"]
625      @classmethod
626      def parse_flash_size_arg(cls, arg):
627          try:
628              return cls.FLASH_SIZES[arg]
629          except KeyError:
630              raise FatalError(
631                  "Flash size '%s' is not supported by this chip type. "
632                  "Supported sizes: %s" % (arg, ", ".join(cls.FLASH_SIZES.keys()))
633              )
634      @classmethod
635      def parse_flash_freq_arg(cls, arg):
636          if arg is None:
637              return 0
638          try:
639              return cls.FLASH_FREQUENCY[arg]
640          except KeyError:
641              raise FatalError(
642                  "Flash frequency '%s' is not supported by this chip type. "
643                  "Supported frequencies: %s"
644                  % (arg, ", ".join(cls.FLASH_FREQUENCY.keys()))
645              )
646      def run_stub(self, stub=None):
647          if stub is None:
648              stub = StubFlasher(get_stub_json_path(self.CHIP_NAME))
649          if self.sync_stub_detected:
650              print("Stub is already running. No upload is necessary.")
651              return self.STUB_CLASS(self)
652          print("Uploading stub...")
653          for field in [stub.text, stub.data]:
654              if field is not None:
655                  offs = stub.text_start if field == stub.text else stub.data_start
656                  length = len(field)
657                  blocks = (length + self.ESP_RAM_BLOCK - 1) // self.ESP_RAM_BLOCK
658                  self.mem_begin(length, blocks, self.ESP_RAM_BLOCK, offs)
659                  for seq in range(blocks):
660                      from_offs = seq * self.ESP_RAM_BLOCK
661                      to_offs = from_offs + self.ESP_RAM_BLOCK
662                      self.mem_block(field[from_offs:to_offs], seq)
663          print("Running stub...")
664          self.mem_finish(stub.entry)
665          try:
666              p = self.read()
667          except StopIteration:
668              raise FatalError(
669                  "Failed to start stub. There was no response."
670                  "\nTry increasing timeouts, for more information see: "
671                  "https://docs.espressif.com/projects/esptool/en/latest/esptool/configuration-file.html"  # noqa E501
672              )
673          if p != b"OHAI":
674              raise FatalError(f"Failed to start stub. Unexpected response: {p}")
675          print("Stub running...")
676          return self.STUB_CLASS(self)
677      @stub_and_esp32_function_only
678      def flash_defl_begin(self, size, compsize, offset):
679          num_blocks = (compsize + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
680          erase_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE
681          t = time.time()
682          if self.IS_STUB:
683              write_size = (
684                  size  # stub expects number of bytes here, manages erasing internally
685              )
686              timeout = DEFAULT_TIMEOUT
687          else:
688              write_size = (
689                  erase_blocks * self.FLASH_WRITE_SIZE
690              )  # ROM expects rounded up to erase block size
691              timeout = timeout_per_mb(
692                  ERASE_REGION_TIMEOUT_PER_MB, write_size
693              )  # ROM performs the erase up front
694          print("Compressed %d bytes to %d..." % (size, compsize))
695          params = struct.pack(
696              "<IIII", write_size, num_blocks, self.FLASH_WRITE_SIZE, offset
697          )
698          if self.SUPPORTS_ENCRYPTED_FLASH and not self.IS_STUB:
699              params += struct.pack("<I", 0)
700          self.check_command(
701              "enter compressed flash mode",
702              self.ESP_FLASH_DEFL_BEGIN,
703              params,
704              timeout=timeout,
705          )
706          if size != 0 and not self.IS_STUB:
707              print("Took %.2fs to erase flash block" % (time.time() - t))
708          return num_blocks
709      @stub_and_esp32_function_only
710      def flash_defl_block(self, data, seq, timeout=DEFAULT_TIMEOUT):
711          for attempts_left in range(WRITE_BLOCK_ATTEMPTS - 1, -1, -1):
712              try:
713                  self.check_command(
714                      "write compressed data to flash after seq %d" % seq,
715                      self.ESP_FLASH_DEFL_DATA,
716                      struct.pack("<IIII", len(data), seq, 0, 0) + data,
717                      self.checksum(data),
718                      timeout=timeout,
719                  )
720                  break
721              except FatalError:
722                  if attempts_left:
723                      self.trace(
724                          "Compressed block write failed, "
725                          f"retrying with {attempts_left} attempts left"
726                      )
727                  else:
728                      raise
729      @stub_and_esp32_function_only
730      def flash_defl_finish(self, reboot=False):
731          if not reboot and not self.IS_STUB:
732              return
733          pkt = struct.pack("<I", int(not reboot))
734          self.check_command("leave compressed flash mode", self.ESP_FLASH_DEFL_END, pkt)
735          self.in_bootloader = False
736      @stub_and_esp32_function_only
737      def flash_md5sum(self, addr, size):
738          timeout = timeout_per_mb(MD5_TIMEOUT_PER_MB, size)
739          res = self.check_command(
740              "calculate md5sum",
741              self.ESP_SPI_FLASH_MD5,
742              struct.pack("<IIII", addr, size, 0, 0),
743              timeout=timeout,
744          )
745          if len(res) == 32:
746              return res.decode("utf-8")  # already hex formatted
747          elif len(res) == 16:
748              return hexify(res).lower()
749          else:
750              raise FatalError("MD5Sum command returned unexpected result: %r" % res)
751      @stub_and_esp32_function_only
752      def change_baud(self, baud):
753          print("Changing baud rate to %d" % baud)
754          second_arg = self._port.baudrate if self.IS_STUB else 0
755          self.command(self.ESP_CHANGE_BAUDRATE, struct.pack("<II", baud, second_arg))
756          print("Changed.")
757          self._set_port_baudrate(baud)
758          time.sleep(0.05)  # get rid of crap sent during baud rate change
759          self.flush_input()
760      @stub_function_only
761      def erase_flash(self):
762          self.check_command(
763              "erase flash", self.ESP_ERASE_FLASH, timeout=CHIP_ERASE_TIMEOUT
764          )
765      @stub_function_only
766      def erase_region(self, offset, size):
767          if offset % self.FLASH_SECTOR_SIZE != 0:
768              raise FatalError("Offset to erase from must be a multiple of 4096")
769          if size % self.FLASH_SECTOR_SIZE != 0:
770              raise FatalError("Size of data to erase must be a multiple of 4096")
771          timeout = timeout_per_mb(ERASE_REGION_TIMEOUT_PER_MB, size)
772          self.check_command(
773              "erase region",
774              self.ESP_ERASE_REGION,
775              struct.pack("<II", offset, size),
776              timeout=timeout,
777          )
778      def read_flash_slow(self, offset, length, progress_fn):
779          raise NotImplementedInROMError(self, self.read_flash_slow)
780      def read_flash(self, offset, length, progress_fn=None):
781          if not self.IS_STUB:
782              return self.read_flash_slow(offset, length, progress_fn)  # ROM-only routine
783          self.check_command(
784              "read flash",
785              self.ESP_READ_FLASH,
786              struct.pack("<IIII", offset, length, self.FLASH_SECTOR_SIZE, 64),
787          )
788          data = b""
789          while len(data) < length:
790              p = self.read()
791              data += p
792              if len(data) < length and len(p) < self.FLASH_SECTOR_SIZE:
793                  raise FatalError(
794                      "Corrupt data, expected 0x%x bytes but received 0x%x bytes"
795                      % (self.FLASH_SECTOR_SIZE, len(p))
796                  )
797              self.write(struct.pack("<I", len(data)))
798              if progress_fn and (len(data) % 1024 == 0 or len(data) == length):
799                  progress_fn(len(data), length)
800          if progress_fn:
801              progress_fn(len(data), length)
802          if len(data) > length:
803              raise FatalError("Read more than expected")
804          digest_frame = self.read()
805          if len(digest_frame) != 16:
806              raise FatalError("Expected digest, got: %s" % hexify(digest_frame))
807          expected_digest = hexify(digest_frame).upper()
808          digest = hashlib.md5(data).hexdigest().upper()
809          if digest != expected_digest:
810              raise FatalError(
811                  "Digest mismatch: expected %s, got %s" % (expected_digest, digest)
812              )
813          return data
814      def flash_spi_attach(self, hspi_arg):
815          arg = struct.pack("<I", hspi_arg)
816          if not self.IS_STUB:
817              is_legacy = 0
818              arg += struct.pack("BBBB", is_legacy, 0, 0, 0)
819          self.check_command("configure SPI flash pins", self.ESP_SPI_ATTACH, arg)
820      def flash_set_parameters(self, size):
821          fl_id = 0
822          total_size = size
823          block_size = 64 * 1024
824          sector_size = 4 * 1024
825          page_size = 256
826          status_mask = 0xFFFF
827          self.check_command(
828              "set SPI params",
829              self.ESP_SPI_SET_PARAMS,
830              struct.pack(
831                  "<IIIIII",
832                  fl_id,
833                  total_size,
834                  block_size,
835                  sector_size,
836                  page_size,
837                  status_mask,
838              ),
839          )
840      def run_spiflash_command(
841          self,
842          spiflash_command,
843          data=b"",
844          read_bits=0,
845          addr=None,
846          addr_len=0,
847          dummy_len=0,
848      ):
849          SPI_USR_COMMAND = 1 << 31
850          SPI_USR_ADDR = 1 << 30
851          SPI_USR_DUMMY = 1 << 29
852          SPI_USR_MISO = 1 << 28
853          SPI_USR_MOSI = 1 << 27
854          base = self.SPI_REG_BASE
855          SPI_CMD_REG = base + 0x00
856          SPI_ADDR_REG = base + 0x04
857          SPI_USR_REG = base + self.SPI_USR_OFFS
858          SPI_USR1_REG = base + self.SPI_USR1_OFFS
859          SPI_USR2_REG = base + self.SPI_USR2_OFFS
860          SPI_W0_REG = base + self.SPI_W0_OFFS
861          if self.SPI_MOSI_DLEN_OFFS is not None:
862              def set_data_lengths(mosi_bits, miso_bits):
863                  SPI_MOSI_DLEN_REG = base + self.SPI_MOSI_DLEN_OFFS
864                  SPI_MISO_DLEN_REG = base + self.SPI_MISO_DLEN_OFFS
865                  if mosi_bits > 0:
866                      self.write_reg(SPI_MOSI_DLEN_REG, mosi_bits - 1)
867                  if miso_bits > 0:
868                      self.write_reg(SPI_MISO_DLEN_REG, miso_bits - 1)
869                  flags = 0
870                  if dummy_len > 0:
871                      flags |= dummy_len - 1
872                  if addr_len > 0:
873                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
874                  if flags:
875                      self.write_reg(SPI_USR1_REG, flags)
876          else:
877              def set_data_lengths(mosi_bits, miso_bits):
878                  SPI_DATA_LEN_REG = SPI_USR1_REG
879                  SPI_MOSI_BITLEN_S = 17
880                  SPI_MISO_BITLEN_S = 8
881                  mosi_mask = 0 if (mosi_bits == 0) else (mosi_bits - 1)
882                  miso_mask = 0 if (miso_bits == 0) else (miso_bits - 1)
883                  flags = (miso_mask << SPI_MISO_BITLEN_S) | (
884                      mosi_mask << SPI_MOSI_BITLEN_S
885                  )
886                  if dummy_len > 0:
887                      flags |= dummy_len - 1
888                  if addr_len > 0:
889                      flags |= (addr_len - 1) << SPI_USR_ADDR_LEN_SHIFT
890                  self.write_reg(SPI_DATA_LEN_REG, flags)
891          SPI_CMD_USR = 1 << 18
892          SPI_USR2_COMMAND_LEN_SHIFT = 28
893          SPI_USR_ADDR_LEN_SHIFT = 26
894          if read_bits > 32:
895              raise FatalError(
896                  "Reading more than 32 bits back from a SPI flash "
897                  "operation is unsupported"
898              )
899          if len(data) > 64:
900              raise FatalError(
901                  "Writing more than 64 bytes of data with one SPI "
902                  "command is unsupported"
903              )
904          data_bits = len(data) * 8
905          old_spi_usr = self.read_reg(SPI_USR_REG)
906          old_spi_usr2 = self.read_reg(SPI_USR2_REG)
907          flags = SPI_USR_COMMAND
908          if read_bits > 0:
909              flags |= SPI_USR_MISO
910          if data_bits > 0:
911              flags |= SPI_USR_MOSI
912          if addr_len > 0:
913              flags |= SPI_USR_ADDR
914          if dummy_len > 0:
915              flags |= SPI_USR_DUMMY
916          set_data_lengths(data_bits, read_bits)
917          self.write_reg(SPI_USR_REG, flags)
918          self.write_reg(
919              SPI_USR2_REG, (7 << SPI_USR2_COMMAND_LEN_SHIFT) | spiflash_command
920          )
921          if addr and addr_len > 0:
922              self.write_reg(SPI_ADDR_REG, addr)
923          if data_bits == 0:
924              self.write_reg(SPI_W0_REG, 0)  # clear data register before we read it
925          else:
926              data = pad_to(data, 4, b"\00")  # pad to 32-bit multiple
927              words = struct.unpack("I" * (len(data) // 4), data)
928              next_reg = SPI_W0_REG
929              for word in words:
930                  self.write_reg(next_reg, word)
931                  next_reg += 4
932          self.write_reg(SPI_CMD_REG, SPI_CMD_USR)
933          def wait_done():
934              for _ in range(10):
935                  if (self.read_reg(SPI_CMD_REG) & SPI_CMD_USR) == 0:
936                      return
937              raise FatalError("SPI command did not complete in time")
938          wait_done()
939          status = self.read_reg(SPI_W0_REG)
940          self.write_reg(SPI_USR_REG, old_spi_usr)
941          self.write_reg(SPI_USR2_REG, old_spi_usr2)
942          return status
943      def read_spiflash_sfdp(self, addr, read_bits):
944          CMD_RDSFDP = 0x5A
945          return self.run_spiflash_command(
946              CMD_RDSFDP, read_bits=read_bits, addr=addr, addr_len=24, dummy_len=8
947          )
948      def read_status(self, num_bytes=2):
949          SPIFLASH_RDSR = 0x05
950          SPIFLASH_RDSR2 = 0x35
951          SPIFLASH_RDSR3 = 0x15
952          status = 0
953          shift = 0
954          for cmd in [SPIFLASH_RDSR, SPIFLASH_RDSR2, SPIFLASH_RDSR3][0:num_bytes]:
955              status += self.run_spiflash_command(cmd, read_bits=8) << shift
956              shift += 8
957          return status
958      def write_status(self, new_status, num_bytes=2, set_non_volatile=False):
959          SPIFLASH_WRSR = 0x01
960          SPIFLASH_WRSR2 = 0x31
961          SPIFLASH_WRSR3 = 0x11
962          SPIFLASH_WEVSR = 0x50
963          SPIFLASH_WREN = 0x06
964          SPIFLASH_WRDI = 0x04
965          enable_cmd = SPIFLASH_WREN if set_non_volatile else SPIFLASH_WEVSR
966          if num_bytes == 2:
967              self.run_spiflash_command(enable_cmd)
968              self.run_spiflash_command(SPIFLASH_WRSR, struct.pack("<H", new_status))
969          for cmd in [SPIFLASH_WRSR, SPIFLASH_WRSR2, SPIFLASH_WRSR3][0:num_bytes]:
970              self.run_spiflash_command(enable_cmd)
971              self.run_spiflash_command(cmd, struct.pack("B", new_status & 0xFF))
972              new_status >>= 8
973          self.run_spiflash_command(SPIFLASH_WRDI)
974      def get_crystal_freq(self):
975          uart_div = self.read_reg(self.UART_CLKDIV_REG) & self.UART_CLKDIV_MASK
976          est_xtal = (self._port.baudrate * uart_div) / 1e6 / self.XTAL_CLK_DIVIDER
977          norm_xtal = 40 if est_xtal > 33 else 26
978          if abs(norm_xtal - est_xtal) > 1:
979              print(
980                  "WARNING: Detected crystal freq %.2fMHz is quite different to "
981                  "normalized freq %dMHz. Unsupported crystal in use?"
982                  % (est_xtal, norm_xtal)
983              )
984          return norm_xtal
985      def hard_reset(self):
986          print("Hard resetting via RTS pin...")
987          HardReset(self._port)()
988      def soft_reset(self, stay_in_bootloader):
989          if not self.IS_STUB:
990              if stay_in_bootloader:
991                  return  # ROM bootloader is already in bootloader!
992              else:
993                  self.flash_begin(0, 0)
994                  self.flash_finish(False)
995          else:
996              if stay_in_bootloader:
997                  self.flash_begin(0, 0)
998                  self.flash_finish(True)
999              elif self.CHIP_NAME != "ESP8266":
1000                  raise FatalError(
1001                      "Soft resetting is currently only supported on ESP8266"
1002                  )
1003              else:
1004                  self.command(self.ESP_RUN_USER_CODE, wait_response=False)
1005      def check_chip_id(self):
1006          try:
1007              chip_id = self.get_chip_id()
1008              if chip_id != self.IMAGE_CHIP_ID:
1009                  print(
1010                      "WARNING: Chip ID {} ({}) doesn't match expected Chip ID {}. "
1011                      "esptool may not work correctly.".format(
1012                          chip_id,
1013                          self.UNSUPPORTED_CHIPS.get(chip_id, "Unknown"),
1014                          self.IMAGE_CHIP_ID,
1015                      )
1016                  )
1017                  self.stub_is_disabled = True
1018          except NotImplementedInROMError:
1019              pass
1020  def slip_reader(port, trace_function):
1021      def detect_panic_handler(input):
1022          guru_meditation = (
1023              rb"G?uru Meditation Error: (?:Core \d panic'ed \(([a-zA-Z ]*)\))?"
1024          )
1025          fatal_exception = rb"F?atal exception \(\d+\): (?:([a-zA-Z ]*)?.*epc)?"
1026          data = re.search(
1027              rb"".join([rb"(?:", guru_meditation, rb"|", fatal_exception, rb")"]),
1028              input,
1029              re.DOTALL,
1030          )
1031          if data is not None:
1032              cause = [
1033                  "({})".format(i.decode("utf-8"))
1034                  for i in [data.group(1), data.group(2)]
1035                  if i is not None
1036              ]
1037              cause = f" {cause[0]}" if len(cause) else ""
1038              msg = f"Guru Meditation Error detected{cause}"
1039              raise FatalError(msg)
1040      partial_packet = None
1041      in_escape = False
1042      successful_slip = False
1043      while True:
1044          waiting = port.inWaiting()
1045          read_bytes = port.read(1 if waiting == 0 else waiting)
1046          if read_bytes == b"":
1047              if partial_packet is None:  # fail due to no data
1048                  msg = (
1049                      "Serial data stream stopped: Possible serial noise or corruption."
1050                      if successful_slip
1051                      else "No serial data received."
1052                  )
1053              else:  # fail during packet transfer
1054                  msg = "Packet content transfer stopped (received {} bytes)".format(
1055                      len(partial_packet)
1056                  )
1057              trace_function(msg)
1058              raise FatalError(msg)
1059          trace_function("Read %d bytes: %s", len(read_bytes), HexFormatter(read_bytes))
1060          for b in read_bytes:
1061              b = bytes([b])
1062              if partial_packet is None:  # waiting for packet header
1063                  if b == b"\xc0":
1064                      partial_packet = b""
1065                  else:
1066                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1067                      remaining_data = port.read(port.inWaiting())
1068                      trace_function(
1069                          "Remaining data in serial buffer: %s",
1070                          HexFormatter(remaining_data),
1071                      )
1072                      detect_panic_handler(read_bytes + remaining_data)
1073                      raise FatalError(
1074                          "Invalid head of packet (0x%s): "
1075                          "Possible serial noise or corruption." % hexify(b)
1076                      )
1077              elif in_escape:  # part-way through escape sequence
1078                  in_escape = False
1079                  if b == b"\xdc":
1080                      partial_packet += b"\xc0"
1081                  elif b == b"\xdd":
1082                      partial_packet += b"\xdb"
1083                  else:
1084                      trace_function("Read invalid data: %s", HexFormatter(read_bytes))
1085                      remaining_data = port.read(port.inWaiting())
1086                      trace_function(
1087                          "Remaining data in serial buffer: %s",
1088                          HexFormatter(remaining_data),
1089                      )
1090                      detect_panic_handler(read_bytes + remaining_data)
1091                      raise FatalError("Invalid SLIP escape (0xdb, 0x%s)" % (hexify(b)))
1092              elif b == b"\xdb":  # start of escape sequence
1093                  in_escape = True
1094              elif b == b"\xc0":  # end of packet
1095                  trace_function("Received full packet: %s", HexFormatter(partial_packet))
1096                  yield partial_packet
1097                  partial_packet = None
1098                  successful_slip = True
1099              else:  # normal byte in packet
1100                  partial_packet += b
1101  class HexFormatter(object):
1102      def __init__(self, binary_string, auto_split=True):
1103          self._s = binary_string
1104          self._auto_split = auto_split
1105      def __str__(self):
1106          if self._auto_split and len(self._s) > 16:
1107              result = ""
1108              s = self._s
1109              while len(s) > 0:
1110                  line = s[:16]
1111                  ascii_line = "".join(
1112                      c
1113                      if (
1114                          c == " "
1115                          or (c in string.printable and c not in string.whitespace)
1116                      )
1117                      else "."
1118                      for c in line.decode("ascii", "replace")
1119                  )
1120                  s = s[16:]
1121                  result += "\n    %-16s %-16s | %s" % (
1122                      hexify(line[:8], False),
1123                      hexify(line[8:], False),
1124                      ascii_line,
1125                  )
1126              return result
1127          else:
1128              return hexify(self._s, False)
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Ultroid-MDEwOlJlcG9zaXRvcnkzNDEwMzg2MDI=-flat-stickertools.py</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-loader.py</div>
                <div class="column column_space"><pre><code>1  import glob
2  import io
3  import os
4  import random
5  from os import remove
6  try:
7      import cv2
8  except ImportError:
</pre></code></div>
                <div class="column column_space"><pre><code>10  import time
11  from .config import load_config_file
12  from .reset import (
13      ClassicReset,
14      CustomReset,
15      DEFAULT_RESET_DELAY,
16      HardReset,
17      USBJTAGSerialReset,
18      UnixTightReset,
19  )
20  from .util import FatalError, NotImplementedInROMError, UnsupportedCommandError
21  from .util import byte, hexify, mask_to_shift, pad_to, strip_chip_name
22  try:
23      import serial
24  except ImportError:
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    