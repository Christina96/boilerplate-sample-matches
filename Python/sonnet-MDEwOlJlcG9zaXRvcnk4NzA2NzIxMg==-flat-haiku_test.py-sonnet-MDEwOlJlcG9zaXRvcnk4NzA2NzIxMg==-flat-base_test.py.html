
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.5459940652819%, Tokens: 10</h2>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-haiku_test.py</h3>
            <pre><code>1  from absl.testing import parameterized
2  import sonnet as snt
3  from sonnet.src import test_utils
4  from sonnet.src.functional import haiku as hk
5  import tensorflow as tf
6  import tree
7  class TensorVariableTest(test_utils.TestCase, parameterized.TestCase):
8    def test_initial_value(self):
9      with hk.variables():
10        v = tf.Variable(tf.ones([]))
11      self.assertIsInstance(v, hk.TensorVariable)
12      self.assertAllEqual(v, 1)
13      self.assertAllEqual(v.read_value(), 1)
14      self.assertAllEqual(v.tensor_value, 1)
15    @parameterized.parameters(None, True, False)
16    def test_trainable(self, trainable):
17      with hk.variables():
18        v = tf.Variable(1., trainable=trainable)
19      if trainable is None:
20        self.assertTrue(v.trainable)
21      else:
22        self.assertEqual(v.trainable, trainable)
23    def test_name(self):
24      with hk.variables():
25        v = tf.Variable(tf.ones([]), name="v")
26      self.assertEqual(v.name, "v:0")
27    def test_name_with_scope(self):
28      with hk.variables(), tf.name_scope("foo"), tf.name_scope("bar"):
29        v = tf.Variable(tf.ones([]), name="v")
30      self.assertEqual(v.name, "foo/bar/v:0")
31    @parameterized.parameters(([],), ([1, 2, 3],))
32    def test_shape(self, shape):
33      with hk.variables():
34        v = tf.Variable(tf.ones(shape))
35      self.assertEqual(shape, v.shape.as_list())
36    @parameterized.parameters(tf.float32, tf.int32)
37    def test_dtype(self, dtype):
38      with hk.variables():
39        v = tf.Variable(tf.ones([], dtype=dtype))
40      self.assertEqual(dtype, v.dtype)
41    def test_attributes_do_not_notify(self):
42      with hk.variables():
43        v = tf.Variable(1.)
44        s = tf.Variable(1., trainable=False)
45      def f():
46        for c in (v, s):
47          self.assertIsNotNone(c.shape)
48          self.assertIsNotNone(c.dtype)
49          self.assertIsNotNone(c.trainable)
50          self.assertIsNotNone(c.name)
51          self.assertIsNotNone(c.device)
52      f = hk.transform_with_state(f)
53      params, state = f.init()
54      self.assertEmpty(params)
55      self.assertEmpty(state)
56      out, state = f.apply(params, state)
57      self.assertIsNone(out)
58      self.assertEmpty(state)
59    def test_read_captured_variables_included(self):
60      with hk.variables():
61        v = tf.Variable(1.)
62        s = tf.Variable(1., trainable=False)
63      f = hk.transform_with_state(lambda: (v.read_value() + s.read_value()))
64      params, state = f.init()
65      self.assertEqual(params, {v.ref(): v.tensor_value})
66      self.assertEqual(state, {s.ref(): s.tensor_value})
67    def test_captured_variable_from_other_function_raises(self):
68      def f(model):
69        if not model:
70          model.append(tf.Variable(1.))
71          model.append(tf.Variable(1., trainable=False))
72        return sum(model)
73      f = hk.transform_with_state(f)
74      model = []
75      params, state = f.init(model)
76      self.assertLen(params, 1)
77      self.assertLen(state, 1)
78      with self.assertRaisesRegex(ValueError, "TensorVariable .* has no value"):
79        f.init(model)
80    def test_assign(self):
81      with hk.variables():
82        v = tf.Variable(tf.ones([]))
83      v.assign(tf.zeros([]))
84      self.assertAllEqual(v.numpy(), 0)
85      self.assertAllEqual(v.read_value().numpy(), 0)
86      self.assertAllEqual(v.tensor_value.numpy(), 0)
87    def test_assign_add(self):
88      with hk.variables():
89        v = tf.Variable(tf.ones([]))
90      v.assign_add(1.)
91      self.assertAllEqual(v.numpy(), 2)
92      self.assertAllEqual(v.read_value().numpy(), 2)
93      self.assertAllEqual(v.tensor_value.numpy(), 2)
94    def test_assign_sub(self):
95      with hk.variables():
96        v = tf.Variable(tf.ones([]))
97      v.assign_sub(1.)
98      self.assertAllEqual(v.numpy(), 0)
99      self.assertAllEqual(v.read_value().numpy(), 0)
100      self.assertAllEqual(v.tensor_value.numpy(), 0)
101  class NetworkTest(test_utils.TestCase, parameterized.TestCase):
102    def test_transform(self):
103      mod = snt.Linear(1, w_init=tf.ones)
104      snt.allow_empty_variables(mod)
105      self.assertEmpty(mod.variables)
106      f = hk.transform(mod)
107      x = tf.ones([1, 1])
108      params = f.init(x)
109      self.assertLen(params.items(), 2)
110      self.assertAllEqual(params[mod.w.ref()], [[1.]])
111      self.assertAllEqual(params[mod.b.ref()], [0.])
112      y = f.apply(params, x)
113      self.assertEqual(y, [[1.]])
114      params = tree.map_structure(lambda p: p + 1, params)
115      y = f.apply(params, x)
116      self.assertEqual(y, [[3.]])
117    def test_initial_values_preserved(self):
118      with hk.variables():
119        v = tf.Variable(0)
120        v.assign(1)
121      def assert_values():
122        self.assertEqual(v.initial_tensor_value.numpy(), 0)
123        self.assertEqual(v.tensor_value.numpy(), 1)
124      assert_values()
125      f = hk.transform(lambda: v.assign(2))
126      assert_values()
127      params = f.init()
128      assert_values()
129      f.apply(params)
130      assert_values()
131    def test_variables_in_transform_set_to_none(self):
132      mod = snt.Bias()
133      f = hk.transform(mod)
134      params = f.init(tf.ones([1, 1]))  # Will create `mod.b`.
135      self.assertIsNone(mod.b.tensor_value)
136      self.assertIsNone(mod.b.initial_tensor_value)
137      y = f.apply(params, tf.ones([1, 1]))
138      self.assertAllEqual(y.numpy(), [[1.]])
139      self.assertIsNone(mod.b.tensor_value)
140      self.assertIsNone(mod.b.initial_tensor_value)
141    def test_disallows_variables_in_apply(self):
142      _, apply_fn = hk.transform(lambda: tf.Variable(1))
143      with self.assertRaisesRegex(ValueError,
144                                  "Apply function cannot create new variables"):
145        apply_fn({})
<span onclick='openModal()' class='match'>146    def test_state_returns_initial_value(self):
147      with hk.variables():
148        v = tf.Variable(0, trainable=False)
149      f = hk.transform_with_state(lambda: v.assign(1))
150      params, state = f.init()
151      initial_v = state[v.ref()]
152      self.assertEqual(initial_v.numpy(), 0)
153      y, state = f.apply(params, state)
154      final_v = state[v.ref()]
155      self.assertEqual(y.numpy(), 1)
156      self.assertEqual(final_v.numpy(), 1)
157    def test_state_counter(self):
158      with hk.variables():
159        v = tf.Variable(0, trainable=False)
</span>160      f = hk.transform_with_state(lambda: v.assign_add(1))
161      params, initial_state = f.init()
162      for _ in range(2):
163        state = initial_state
164        for i in range(10):
165          y, state = f.apply(params, state)
166          self.assertEqual(y.numpy(), i + 1)
167    def test_state_ema(self):
168      with hk.variables():
169        ema = snt.ExponentialMovingAverage(decay=0.5)
170      ema = hk.transform_with_state(ema)
171      params, state = ema.init(3.0)
172      y, state = ema.apply(params, state, 3.0)
173      self.assertAllClose(y.numpy(), 3.0)
174      y, state = ema.apply(params, state, 6.0)
175      self.assertAllClose(y.numpy(), 5.0)
176  if __name__ == "__main__":
177    tf.test.main()
</code></pre>
        </div>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-base_test.py</h3>
            <pre><code>1  import abc
2  from absl.testing import parameterized
3  import numpy as np
4  from sonnet.src import base
5  from sonnet.src import test_utils
6  import tensorflow as tf
7  import wrapt
8  class BaseTest(test_utils.TestCase):
9    def test_basic(self):
10      m = LambdaModule()
11      self.assertIsNone(m(None))
12    def testWrappedMethod(self):
13      mod = WraptModule()
14      scope_name, y = mod(3)
15      self.assertEqual(scope_name, "wrapt_module/")
16      self.assertEqual(y, (3**2)**2)
17    def testControlFlow(self):
18      mod = ControlFlowModule()
19      f = tf.function(mod).get_concrete_function(tf.TensorSpec([]))
20      self.assertEqual(f(tf.constant(1.)).numpy(), 1.)
21      self.assertEqual(f(tf.constant(11.)).numpy(), 11.**2)
22  class TestModuleNaming(tf.test.TestCase):
23    def test_single_name(self):
24      mod = base.Module(name="simple")
25      self.assertEqual(mod.name, "simple")
26      self.assertEqual(mod.name_scope.name, "simple/")
27    def test_construct_in_scope(self):
28      with tf.name_scope("foo"):
29        mod = base.Module(name="bar")
30      self.assertEqual(mod.name, "bar")
31      self.assertEqual(mod.name_scope.name, "foo/bar/")
32    def test_enters_name_scope_in_call(self):
33      mod = ReturnsNameScopeModule()
34      for _ in range(3):
35        self.assertEqual(mod(), mod.name_scope.name)
36    def test_enters_name_scope_in_other_method(self):
37      mod = ReturnsNameScopeModule()
38      for _ in range(3):
39        self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
40    def test_subclassed_module(self):
41      mod = SubclassedReturnsNameScopeModule()
42      for _ in range(3):
43        self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
44        self.assertEqual(mod.alternative_alternative_forward(),
45                         mod.name_scope.name)
46    def test_submodule_created_late(self):
47      m = TreeModule()
48      self.assertEqual(m.name, "tree_module")
49      self.assertEqual(m.name_scope.name, "tree_module/")
50      leaf1 = m.new_leaf()
51      self.assertEqual(leaf1.name, "tree_module")
52      self.assertEqual(leaf1.name_scope.name, "tree_module/tree_module/")
53    def test_does_not_evaluate_property_methods(self):
54      mod = PropertyThrowsWhenCalledModule()
55      with self.assertRaises(AssertionError):
56        mod.raise_assertion_error  # pylint: disable=pointless-statement
<span onclick='openModal()' class='match'>57    def test_overridden_name_scope(self):
58      mod = ModuleOverridingNameScope()
59      self.assertEqual(mod(), mod.name_scope.name)
60      self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
61    def test_patched_callable(self):
62      with tf.name_scope("foo"):
63        mod = base.Module(name="bar")
</span>64      mod.foo = get_name_scope
65      self.assertEqual(mod.foo(), "")
66    def test_property(self):
67      mod = PropertyModule()
68      mod.some_property = None, None  # None, None for the linter.
69      getter_scope_name, setter_scope_name = mod.some_property
70      self.assertEqual(getter_scope_name, "property_module/")
71      self.assertEqual(setter_scope_name, "property_module/")
72    def test_property_no_name_scope(self):
73      mod = PropertyModule()
74      mod.no_name_scope_property = None, None  # None, None for the linter.
75      getter_scope_name, setter_scope_name = mod.no_name_scope_property
76      self.assertEqual(getter_scope_name, "")
77      self.assertEqual(setter_scope_name, "")
78    def test_ctor_no_name_scope(self):
79      mod = CtorNoNameScope()
80      self.assertEqual(mod.ctor_name_scope, "")
81      self.assertEqual(mod.w.name, "w:0")
82    def test_ctor_no_name_scope_no_super(self):
83      msg = ("Constructing a snt.Module without calling the super constructor is "
84             "not supported")
85      with self.assertRaisesRegex(ValueError, msg):
86        CtorNoNameScopeNoSuper()
87    def test_invalid_name(self):
88      msg = ".* is not a valid module name"
89      with self.assertRaisesRegex(ValueError, msg):
90        base.Module(name="$Foo")
91    def test_modules_not_numbered_in_eager(self):
92      mod = RecursiveModule(2)
93      self.assertEqual(mod.name_scope.name, "badger/")
94      self.assertEqual(mod.child.name_scope.name, "badger/badger/")
95      mod = RecursiveModule(2)
96      self.assertEqual(mod.name_scope.name, "badger/")
97      self.assertEqual(mod.child.name_scope.name, "badger/badger/")
98    def test_module_numbering_in_graph(self):
99      with tf.Graph().as_default():
100        mod = RecursiveModule(2)
101        self.assertEqual(mod.name_scope.name, "badger/")
102        self.assertEqual(mod.child.name_scope.name, "badger/badger/")
103        mod = RecursiveModule(2)
104        self.assertEqual(mod.name_scope.name, "badger_1/")
105        self.assertEqual(mod.child.name_scope.name, "badger_1/badger/")
106    def test_ctor_error_closes_name_scope(self):
107      with self.assertRaises(ErrorModuleError):
108        ErrorModule(call_super=True)
109      self.assertEqual("", get_name_scope())
110    def test_ctor_error_handles_ctor_not_opening_name_scope(self):
111      with self.assertRaises(ErrorModuleError):
112        ErrorModule(call_super=False)
113      self.assertEqual("", get_name_scope())
114    def test_forward_method_closes_name_scope(self):
115      mod = ErrorModule(call_super=True, raise_in_constructor=False)
116      with self.assertRaises(ErrorModuleError):
117        mod()
118      self.assertEqual("", get_name_scope())
119    def test_get_attr_doesnt_enter_name_scope(self):
120      scope_names = []
121      class GetAttrModule(base.Module):
122        def __getattr__(self, name):
123          scope_names.append((name, get_name_scope()))
124          return super().__getattr__(name)
125      mod = GetAttrModule()
126      with self.assertRaises(AttributeError):
127        mod.does_not_exist  # pylint: disable=pointless-statement
128      self.assertIn(("does_not_exist", ""), scope_names)
129    def test_get_attribute_doesnt_enter_name_scope(self):
130      scope_names = []
131      class GetAttributeModule(base.Module):
132        def __getattribute__(self, name):
133          scope_names.append((name, get_name_scope()))
134          return super().__getattribute__(name)
135      mod = GetAttributeModule()
136      with self.assertRaises(AttributeError):
137        mod.does_not_exist  # pylint: disable=pointless-statement
138      self.assertIn(("does_not_exist", ""), scope_names)
139  class VariableNamingTest(tf.test.TestCase):
140    def test_variable_names(self):
141      mod = RecursiveModule(3)
142      self.assertEqual(mod.w.name, "badger/mushroom:0")
143      self.assertEqual(mod.child.w.name, "badger/badger/mushroom:0")
144      self.assertEqual(mod.child.child.w.name, "badger/badger/badger/mushroom:0")
145  class AutoReprTest(tf.test.TestCase):
146    def test_order_matches_argspec(self):
147      module = RecursiveModule(trainable=False, depth=2)
148      self.assertEqual(repr(module), "RecursiveModule(depth=2, trainable=False)")
149    def test_defaults_ignored(self):
150      module = RecursiveModule(1)
151      self.assertEqual(repr(module), "RecursiveModule(depth=1)")
152    def test_does_not_fail_with_hostile_input(self):
153      r = RaisesOnEquality()
154      self.assertFalse(r.equality_checked)
155      module = NoopModule(r)
156      self.assertEqual(repr(module), "NoopModule(a=hostile)")
157      self.assertTrue(r.equality_checked)
158    def test_args_are_repred(self):
159      module = TreeModule(name="TreeModule")
160      self.assertEqual(repr(module), "TreeModule(name='TreeModule')")
161      module = TreeModule("TreeModule")
162      self.assertEqual(repr(module), "TreeModule(name='TreeModule')")
163    def test_long_repr_multi_line(self):
164      module = TakesSubmodules([TreeModule() for _ in range(6)], name="hai")
165      self.assertEqual(
166          repr(module), "\n".join([
167              "TakesSubmodules(",
168              "    submodules=[TreeModule(),",
169              "                TreeModule(),",
170              "                TreeModule(),",
171              "                TreeModule(),",
172              "                TreeModule(),",
173              "                TreeModule()],",
174              "    name='hai',",
175              ")",
176          ]))
177    def test_repr_wildcard(self):
178      module = WildcardInit(1, 2, 3, foo="bar")
179      self.assertEqual(repr(module), "WildcardInit(a=1, b=2, 3, foo='bar')")
180    def test_repr_non_bool_equality(self):
181      class FooModule(base.Module):
182        def __init__(self, a=((-1., -1.))):
183          super().__init__()
184      foo = FooModule(a=np.array([[2., 2.]]))
185      self.assertEqual(repr(foo), "FooModule(a=array([[2., 2.]]))")
186      foo = FooModule(a=np.array([[-1., -1.]]))
187      self.assertEqual(repr(foo), "FooModule(a=array([[-1., -1.]]))")
188  class ForwardMethodsTest(tf.test.TestCase):
189    def testFunctionType(self):
190      mod = ModuleWithFunctionAnnotatedCall()
191      self.assertIsInstance(mod.forward, base.TFFunctionType)
192      self.assertIsInstance(mod.forward_ag, base.TFFunctionType)
193    def testEntersNameScope_call(self):
194      mod = ModuleWithFunctionAnnotatedCall()
195      self.assertEqual(mod.forward().numpy(),
196                       b"module_with_function_annotated_call/")
197    def testEntersNameScope_concreteFunction(self):
198      mod = ModuleWithFunctionAnnotatedCall()
199      self.assertEqual(mod.forward.get_concrete_function()().numpy(),
200                       b"module_with_function_annotated_call/")
201  class AbcTest(tf.test.TestCase):
202    def testAbstract(self):
203      msg = "Can't instantiate .* abstract method"
204      with self.assertRaisesRegex(TypeError, msg):
205        AbstractModule()  # pylint: disable=abstract-class-instantiated
206    def testConcrete(self):
207      mod = ConcreteModule()
208      x, scope_name = mod(2.)
209      self.assertEqual(x, 4.)
210      self.assertEqual(scope_name, "concrete_module/")
211      self.assertEqual(get_name_scope(), "")
212    def testCallMethodsOnParent(self):
213      mod = ConcreteModule()
214      self.assertEqual(mod.foo(), True)
215  class CustomGradientTest(test_utils.TestCase):
216    def test_custom_gradient(self):
217      if tf.version.GIT_VERSION != "unknown":
218        self.skipTest("Requires TF > 2.0.0")
219      mod = ZeroGradModule()
220      with tf.GradientTape() as tape:
221        y = mod(2.)
222      g = tape.gradient(y, mod.w)
223      self.assertAllEqual(g, tf.zeros([2, 2]))
224  class ZeroGradModule(base.Module):
225    @tf.custom_gradient
226    def __call__(self, x):
227      if not hasattr(self, "w"):
228        self.w = tf.Variable(tf.ones([2, 2]), name="w")
229      with tf.GradientTape() as tape:
230        y = tf.reduce_sum(self.w ** x)
231      dw = tape.gradient(y, self.w)
232      def grad(dy, variables=None):
233        assert variables
234        return dy * 0, [dw * 0]
235      return y, grad
236  class LambdaModule(base.Module):
237    def __call__(self, x):
238      return x
239  def get_name_scope():
240    with tf.name_scope("x") as scope_name:
241      return scope_name[:-2]
242  @wrapt.decorator
243  def wrapt_decorator(method, instance, args, kwargs):
244    if instance is None:
245      raise ValueError("Expected instance to be non-null.")
246    scope_name, y = method(*args, **kwargs)
247    return scope_name, y**2
248  class WraptModule(base.Module):
249    @wrapt_decorator
250    def __call__(self, x):
251      return get_name_scope(), x**2
252  class ControlFlowModule(base.Module):
253    def __call__(self, x):
254      if x < 10:
255        return x
256      else:
257        return x**2
258  class ErrorModuleError(Exception):
259    pass
260  class ErrorModule(base.Module):
261    def __init__(self, call_super, raise_in_constructor=True):
262      if call_super:
263        super().__init__()
264      if raise_in_constructor:
265        raise ErrorModuleError("Deliberate error!")
266    def __call__(self):
267      raise ErrorModuleError("Deliberate error!")
268  class RecursiveModule(base.Module):
269    def __init__(self, depth, trainable=True):
270      super().__init__(name="badger")
271      self.child = None
272      if depth > 1:
273        self.child = RecursiveModule(depth - 1, trainable=trainable)
274      self.w = tf.Variable(1.0, trainable=trainable, name="mushroom")
275  class AbstractModule(base.Module, metaclass=abc.ABCMeta):
276    @abc.abstractmethod
277    def __call__(self, x):
278      pass
279    def foo(self):
280      return True
281  class ConcreteModule(AbstractModule):
282    def __call__(self, x):
283      return x**2, get_name_scope()
284  class TreeModule(base.Module):
285    def __init__(self, name=None):
286      super().__init__(name=name)
287      self._leaves = []
288    def new_leaf(self, name=None):
289      leaf = TreeModule(name=name)
290      self._leaves.append(leaf)
291      return leaf
292  class ReturnsNameScopeModule(base.Module):
293    def alternative_forward(self):
294      return get_name_scope()
295    def __call__(self):
296      return get_name_scope()
297  class SubclassedReturnsNameScopeModule(ReturnsNameScopeModule):
298    def alternative_alternative_forward(self):
299      return get_name_scope()
300  class PropertyThrowsWhenCalledModule(base.Module):
301    @property
302    def raise_assertion_error(self):
303      raise AssertionError
304  class ModuleOverridingNameScope(ReturnsNameScopeModule):
305    @property
306    def name_scope(self):
307      return tf.name_scope("yolo/")
308  class CommonErrorsTest(test_utils.TestCase, parameterized.TestCase):
309    def test_not_calling_super_constructor(self):
310      msg = ("Constructing a snt.Module without calling the super constructor is "
311             "not supported")
312      with self.assertRaisesRegex(ValueError, msg):
313        DoesNotCallSuperConstructorModule()
314    def test_calls_method_before_super(self):
315      msg = "super constructor must be called before any other methods"
316      with self.assertRaisesRegex(AttributeError, msg):
317        CallsMethodBeforeSuperConstructorModule(allowed_method=False)
318    def test_annotated_method_is_allowed(self):
319      self.assertIsNotNone(
320          CallsMethodBeforeSuperConstructorModule(allowed_method=True))
321    @parameterized.parameters("trainable_variables", "variables")
322    def test_requests_variables_before_they_exist(self, property_name):
323      class MyModule(base.Module):
324        pass
325      mod = MyModule()
326      err = "MyModule.* does not currently contain any {}".format(property_name)
327      with self.assertRaisesRegex(ValueError, err):
328        getattr(mod, property_name)
329    @parameterized.parameters("trainable_variables", "variables")
330    def test_allow_empty_variables_instance(self, property_name):
331      mod = base.Module()
332      mod = base.allow_empty_variables(mod)
333      self.assertEmpty(getattr(mod, property_name))
334    @parameterized.parameters("trainable_variables", "variables")
335    def test_allow_empty_variables_class(self, property_name):
336      mod = NeverCreatesVariables()
337      self.assertEmpty(getattr(mod, property_name))
338  class NoopModule(base.Module):
339    def __init__(self, a=None):
340      super().__init__()
341      self.a = a
342  class RaisesOnEquality:
343    equality_checked = False
344    def __repr__(self):
345      return "hostile"
346    def __eq__(self, other):
347      self.equality_checked = True
348      raise ValueError("== not supported")
349    def __ne__(self, other):
350      self.equality_checked = True
351      raise ValueError("!= not supported")
352  @base.allow_empty_variables
353  class NeverCreatesVariables(base.Module):
354    pass
355  class ModuleWithFunctionAnnotatedCall(base.Module):
356    @tf.function(autograph=False)
357    def forward(self):
358      return get_name_scope()
359    @tf.function(autograph=True)
360    def forward_ag(self):
361      return get_name_scope()
362  class CtorNoNameScope(base.Module):
363    @base.no_name_scope
364    def __init__(self):
365      super().__init__()
366      self.ctor_name_scope = get_name_scope()
367      self.w = tf.Variable(1., name="w")
368  class CtorNoNameScopeNoSuper(base.Module):
369    @base.no_name_scope
370    def __init__(self):
371      pass
372  class PropertyModule(base.Module):
373    def __init__(self):
374      super().__init__()
375      self._setter_scope_name = None
376    @property
377    def some_property(self):
378      getter_scope_name = get_name_scope()
379      return getter_scope_name, self._setter_scope_name
380    @some_property.setter
381    def some_property(self, my_property):
382      self._setter_scope_name = get_name_scope()
383    @property
384    @base.no_name_scope
385    def no_name_scope_property(self):
386      getter_scope_name = get_name_scope()
387      return getter_scope_name, self._setter_scope_name
388    @no_name_scope_property.setter
389    @base.no_name_scope
390    def no_name_scope_property(self, my_property):
391      self._setter_scope_name = get_name_scope()
392  class DoesNotCallSuperConstructorModule(base.Module):
393    def __init__(self):
394      pass
395  class CallsMethodBeforeSuperConstructorModule(base.Module):
396    def __init__(self, allowed_method):
397      if allowed_method:
398        self.no_name_scope()
399      else:
400        self.with_name_scope()
401      super().__init__()
402    @base.no_name_scope
403    def no_name_scope(self):
404      pass
405    def with_name_scope(self):
406      pass
407  class CustomMetaclass(type):
408    TAG = "__custom_metaclass__"
409    def __new__(cls, name, bases, clsdict):
410      new_type = super(CustomMetaclass, cls).__new__(cls, name, bases, clsdict)
411      setattr(new_type, CustomMetaclass.TAG, True)
412      return new_type
413  class CombiningMetaclass(base.ModuleMetaclass, CustomMetaclass):
414    TAG = "__combining_metaclass__"
415    def __new__(cls, name, bases, clsdict):
416      new_type = super(CombiningMetaclass, cls).__new__(cls, name, bases, clsdict)  # pylint: disable=too-many-function-args
417      setattr(new_type, CombiningMetaclass.TAG, True)
418      return new_type
419  class ModuleWithCustomMetaclass(base.Module, metaclass=CombiningMetaclass):
420    def __init__(self):
421      super(ModuleWithCustomMetaclass, self).__init__()
422      self.init_name_scope = get_name_scope()
423  class CustomMetaclassTest(tf.test.TestCase):
424    def testSupportsCustomMetaclass(self):
425      m = ModuleWithCustomMetaclass()
426      self.assertEqual(m.init_name_scope, "module_with_custom_metaclass/")
427      self.assertTrue(getattr(ModuleWithCustomMetaclass, CombiningMetaclass.TAG))
428      self.assertTrue(getattr(ModuleWithCustomMetaclass, CustomMetaclass.TAG))
429  class TakesSubmodules(base.Module):
430    def __init__(self, submodules, name=None):
431      super().__init__(name=name)
432  class WildcardInit(base.Module):
433    def __init__(self, a, b, *args, **kwargs):
434      super().__init__()
435      del args, kwargs
436  if __name__ == "__main__":
437    tf.test.main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-haiku_test.py</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-base_test.py</div>
                </div>
                <div class="column column_space"><pre><code>146    def test_state_returns_initial_value(self):
147      with hk.variables():
148        v = tf.Variable(0, trainable=False)
149      f = hk.transform_with_state(lambda: v.assign(1))
150      params, state = f.init()
151      initial_v = state[v.ref()]
152      self.assertEqual(initial_v.numpy(), 0)
153      y, state = f.apply(params, state)
154      final_v = state[v.ref()]
155      self.assertEqual(y.numpy(), 1)
156      self.assertEqual(final_v.numpy(), 1)
157    def test_state_counter(self):
158      with hk.variables():
159        v = tf.Variable(0, trainable=False)
</pre></code></div>
                <div class="column column_space"><pre><code>57    def test_overridden_name_scope(self):
58      mod = ModuleOverridingNameScope()
59      self.assertEqual(mod(), mod.name_scope.name)
60      self.assertEqual(mod.alternative_forward(), mod.name_scope.name)
61    def test_patched_callable(self):
62      with tf.name_scope("foo"):
63        mod = base.Module(name="bar")
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    