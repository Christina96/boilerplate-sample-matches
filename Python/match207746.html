<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_sqs.py &amp; test_git_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_sqs.py &amp; test_git_1.py
      </h3>
<h1 align="center">
        1.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_sqs.py (6.936416%)<th>test_git_1.py (0.88691795%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(78-86)<td><a href="#" name="0">(301-304)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_sqs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import textwrap
2 import pytest
3 import salt.config
4 import salt.loader
5 import salt.states.boto_sqs as boto_sqs
6 from tests.support.mock import MagicMock, patch
7 @pytest.fixture
8 def configure_loader_modules():
9     opts = salt.config.DEFAULT_MINION_OPTS.copy()
10     utils = salt.loader.utils(
11         opts,
12         whitelist=["boto3", "yaml", "args", "systemd", "path", "platform"],
13         context={},
14     )
15     return {boto_sqs: {"__utils__": utils}}
16 def test_present():
17     name = "mysqs"
18     attributes = {"DelaySeconds": 20}
19     base_ret = {"name": name, "changes": {}}
20     mock = MagicMock(
21         side_effect=[{"result": b} for b in [False, False, True, True]],
22     )
23     mock_bool = MagicMock(return_value={"error": "create error"})
24     mock_attr = MagicMock(return_value={"result": {}})
25     with patch.dict(
26         boto_sqs.__salt__,
27         {
28             "boto_sqs.exists": mock,
29             "boto_sqs.create": mock_bool,
30             "boto_sqs.get_attributes": mock_attr,
31         },
32     ):
33         with patch.dict(boto_sqs.__opts__, {"test": False}):
34             comt = [
35                 "Failed to create SQS queue {}: create error".format(
36                     name,
37                 )
38             ]
39             ret = base_ret.copy()
40             ret.update({"result": False, "comment": comt})
41             assert boto_sqs.present(name) == ret
42         with patch.dict(boto_sqs.__opts__, {"test": True}):
43             comt = ["SQS queue {} is set to be created.".format(name)]
44             ret = base_ret.copy()
45             ret.update(
46                 {
47                     "result": None,
48                     "comment": comt,
49                     "changes": {"old": None, "new": "mysqs"},
50                 }
51             )
52             assert boto_sqs.present(name) == ret
53             diff = textwrap.dedent(
54 <a name="0"></a>            ).splitlines()
55             for idx in (0, 1):
56                 diff[idx] += " "
57             diff <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "\n".join(diff)
58             comt = [
59                 "SQS queue mysqs present.",
60                 "Attribute(s) DelaySeconds set to be updated:\n{}".format(
61                     diff,
62                 ),
63             ]
64             ret.update({"comment": comt, "changes": {"attributes": {"diff"</b></font>: diff}}})
65             assert boto_sqs.present(name, attributes) == ret
66         comt = ["SQS queue mysqs present."]
67         ret = base_ret.copy()
68         ret.update({"result": True, "comment": comt})
69         assert boto_sqs.present(name) == ret
70 def test_absent():
71     name = "test.example.com."
72     base_ret = {"name": name, "changes": {}}
73     mock = MagicMock(side_effect=[{"result": False}, {"result": True}])
74     with patch.dict(boto_sqs.__salt__, {"boto_sqs.exists": mock}):
75         comt = "SQS queue {} does not exist in None.".format(name)
76         ret = base_ret.copy()
77         ret.update({"result": True, "comment": comt})
78         assert boto_sqs.absent(name) == ret
79         with patch.dict(boto_sqs.__opts__, {"test": True}):
80             comt = "SQS queue {} is set to be removed.".format(name)
81             ret = base_ret.copy()
82             ret.update(
83                 {
84                     "result": None,
85                     "comment": comt,
86                     "changes": {"old": name, "new": None},
87                 }
88             )
89             assert boto_sqs.absent(name) == ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_git_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import pathlib
4 import re
5 import shutil
6 import subprocess
7 import tarfile
8 import tempfile
9 from contextlib import closing
10 import pytest
11 import salt.utils.data
12 import salt.utils.files
13 import salt.utils.platform
14 from salt.utils.versions import LooseVersion
15 from tests.support.case import ModuleCase
16 from tests.support.helpers import change_cwd
17 from tests.support.runtests import RUNTIME_VARS
18 from tests.support.unit import skipIf
19 log = logging.getLogger(__name__)
20 def _git_version():
21     try:
22         git_version = subprocess.Popen(
23             ["git", "--version"],
24             shell=False,
25             close_fds=False if salt.utils.platform.is_windows() else True,
26             stdout=subprocess.PIPE,
27             stderr=subprocess.PIPE,
28         ).communicate()[0]
29     except OSError:
30         return False
31     if not git_version:
32         log.debug("Git not installed")
33         return False
34     git_version = git_version.strip().split()[-1]
35     git_version = git_version.decode(__salt_system_encoding__)
36     log.debug("Detected git version: %s", git_version)
37     return LooseVersion(git_version)
38 def _worktrees_supported():
39     try:
40         return _git_version() &gt;= LooseVersion("2.5.0")
41     except AttributeError:
42         return False
43 @pytest.mark.windows_whitelisted
44 @pytest.mark.skip_if_binaries_missing("git")
45 class GitModuleTest(ModuleCase):
46     def setUp(self):
47         super().setUp()
48         self.repo = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
49         self.addCleanup(shutil.rmtree, self.repo, ignore_errors=True)
50         self.addCleanup(delattr, self, "repo")
51         self.files = ("foo", "bar", "baz", "питон")
52         self.addCleanup(delattr, self, "files")
53         self.dirs = ("", "qux")
54         self.addCleanup(delattr, self, "dirs")
55         self.branches = ("master", "iamanewbranch")
56         self.addCleanup(delattr, self, "branches")
57         self.tags = ("git_testing",)
58         self.addCleanup(delattr, self, "tags")
59         for dirname in self.dirs:
60             dir_path = pathlib.Path(self.repo) / dirname
61             dir_path.mkdir(parents=True, exist_ok=True)
62             for filename in self.files:
63                 with salt.utils.files.fopen(str(dir_path / filename), "wb") as fp_:
64                     fp_.write(
65                         "This is a test file named {}.".format(filename).encode("utf-8")
66                     )
67         with change_cwd(self.repo):
68             subprocess.check_call(["git", "init", "--quiet", self.repo])
69             for key, value in (
70                 ("user.name", "Jenkins"),
71                 ("user.email", "qa@saltstack.com"),
72             ):
73                 keycheck = subprocess.Popen(
74                     ["git", "config", "--get", "--global", key],
75                     stdout=subprocess.PIPE,
76                     stderr=subprocess.PIPE,
77                 )
78                 if keycheck.wait() != 0:
79                     subprocess.check_call(["git", "config", "--global", key, value])
80             subprocess.check_call(["git", "add", "."])
81             subprocess.check_call(
82                 ["git", "commit", "--quiet", "--message", "Initial commit"]
83             )
84             subprocess.check_call(["git", "tag", "-a", self.tags[0], "-m", "Add tag"])
85             subprocess.check_call(
86                 ["git", "checkout", "--quiet", "-b", self.branches[1]]
87             )
88             with salt.utils.files.fopen(self.files[0], "a") as fp_:
89                 fp_.write(salt.utils.stringutils.to_str("Added a line\n"))
90             subprocess.check_call(
91                 [
92                     "git",
93                     "commit",
94                     "--quiet",
95                     "--message",
96                     "Added a line to " + self.files[0],
97                     self.files[0],
98                 ]
99             )
100             subprocess.check_call(["git", "checkout", "--quiet", "master"])
101     def run_function(self, *args, **kwargs):  # pylint: disable=arguments-differ
102         return salt.utils.data.decode(super().run_function(*args, **kwargs))
103     @pytest.mark.slow_test
104     def test_add_dir(self):
105         newdir = "quux"
106         newdir_path = pathlib.Path(self.repo) / newdir
107         newdir_path.mkdir(parents=True, exist_ok=True)
108         files = [str(newdir_path / x) for x in self.files]
109         files_relpath = [os.path.join(newdir, x) for x in self.files]
110         for path in files:
111             with salt.utils.files.fopen(path, "wb") as fp_:
112                 fp_.write(
113                     "This is a test file with relative path {}.\n".format(path).encode(
114                         "utf-8"
115                     )
116                 )
117         ret = self.run_function("git.add", [self.repo, newdir])
118         res = "\n".join(sorted("add '{}'".format(x) for x in files_relpath))
119         if salt.utils.platform.is_windows():
120             res = res.replace("\\", "/")
121         self.assertEqual(ret, res)
122     @pytest.mark.slow_test
123     def test_add_file(self):
124         filename = "quux"
125         file_path = os.path.join(self.repo, filename)
126         with salt.utils.files.fopen(file_path, "w") as fp_:
127             fp_.write(
128                 salt.utils.stringutils.to_str(
129                     "This is a test file named {}.\n".format(filename)
130                 )
131             )
132         ret = self.run_function("git.add", [self.repo, filename])
133         self.assertEqual(ret, "add '{}'".format(filename))
134     @pytest.mark.slow_test
135     def test_archive(self):
136         tar_archive = os.path.join(RUNTIME_VARS.TMP, "test_archive.tar.gz")
137         try:
138             self.assertTrue(
139                 self.run_function(
140                     "git.archive", [self.repo, tar_archive], prefix="foo/"
141                 )
142             )
143             self.assertTrue(tarfile.is_tarfile(tar_archive))
144             self.run_function("cmd.run", ["cp " + tar_archive + " /root/"])
145             with closing(tarfile.open(tar_archive, "r")) as tar_obj:
146                 self.assertEqual(
147                     sorted(salt.utils.data.decode(tar_obj.getnames())),
148                     sorted(
149                         [
150                             "foo",
151                             "foo/bar",
152                             "foo/baz",
153                             "foo/foo",
154                             "foo/питон",
155                             "foo/qux",
156                             "foo/qux/bar",
157                             "foo/qux/baz",
158                             "foo/qux/foo",
159                             "foo/qux/питон",
160                         ]
161                     ),
162                 )
163         finally:
164             try:
165                 os.unlink(tar_archive)
166             except OSError:
167                 pass
168     @pytest.mark.slow_test
169     def test_archive_subdir(self):
170         tar_archive = os.path.join(RUNTIME_VARS.TMP, "test_archive.tar.gz")
171         try:
172             self.assertTrue(
173                 self.run_function(
174                     "git.archive",
175                     [os.path.join(self.repo, "qux"), tar_archive],
176                     prefix="foo/",
177                 )
178             )
179             self.assertTrue(tarfile.is_tarfile(tar_archive))
180             with closing(tarfile.open(tar_archive, "r")) as tar_obj:
181                 self.assertEqual(
182                     sorted(salt.utils.data.decode(tar_obj.getnames())),
183                     sorted(["foo", "foo/bar", "foo/baz", "foo/foo", "foo/питон"]),
184                 )
185         finally:
186             try:
187                 os.unlink(tar_archive)
188             except OSError:
189                 pass
190     @pytest.mark.slow_test
191     def test_branch(self):
192         renamed_branch = "ihavebeenrenamed"
193         self.assertTrue(self.run_function("git.branch", [self.repo, self.branches[1]]))
194         self.assertTrue(
195             self.run_function(
196                 "git.branch", [self.repo, renamed_branch], opts="-m " + self.branches[1]
197             )
198         )
199         self.assertTrue(
200             self.run_function("git.branch", [self.repo, renamed_branch], opts="-D")
201         )
202     @pytest.mark.slow_test
203     def test_checkout(self):
204         new_branch = "iamanothernewbranch"
205         self.assertEqual(
206             self.run_function(
207                 "git.checkout", [self.repo, "HEAD"], opts="-b " + new_branch
208             ),
209             "Switched to a new branch '" + new_branch + "'",
210         )
211         self.assertTrue(
212             "Switched to branch 'master'"
213             in self.run_function("git.checkout", [self.repo, "master"]),
214         )
215     @pytest.mark.slow_test
216     def test_checkout_no_rev(self):
217         new_branch = "iamanothernewbranch"
218         self.assertEqual(
219             self.run_function(
220                 "git.checkout", [self.repo], rev=None, opts="-b " + new_branch
221             ),
222             "Switched to a new branch '" + new_branch + "'",
223         )
224         self.assertTrue(
225             "'rev' argument is required unless -b or -B in opts"
226             in self.run_function("git.checkout", [self.repo])
227         )
228     @pytest.mark.slow_test
229     def test_clone(self):
230 <a name="0"></a>        """
231         Test cloning an existing repo
232         clone_parent_dir <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
233         self.assertTrue(self.run_function("git.clone", [clone_parent_dir, self.repo]))
234         shutil.</b></font>rmtree(clone_parent_dir, True)
235     @pytest.mark.slow_test
236     def test_clone_with_alternate_name(self):
237         clone_parent_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
238         clone_name = os.path.basename(self.repo)
239         self.assertTrue(
240             self.run_function(
241                 "git.clone", [clone_parent_dir, self.repo], name=clone_name
242             )
243         )
244         shutil.rmtree(clone_parent_dir, True)
245     @pytest.mark.slow_test
246     def test_commit(self):
247         filename = "foo"
248         commit_re_prefix = r"^\[master [0-9a-f]+\] "
249         with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
250             fp_.write("Added a line\n")
251         self.run_function("git.add", [self.repo, filename])
252         commit_msg = "Add a line to " + filename
253         ret = self.run_function("git.commit", [self.repo, commit_msg])
254         self.assertTrue(bool(re.search(commit_re_prefix + commit_msg, ret)))
255         with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
256             fp_.write("Added another line\n")
257         commit_msg = "Add another line to " + filename
258         ret = self.run_function(
259             "git.commit", [self.repo, commit_msg], filename=filename
260         )
261         self.assertTrue(bool(re.search(commit_re_prefix + commit_msg, ret)))
262     @pytest.mark.slow_test
263     def test_config(self):
264         def _clear_config():
265             cmds = (
266                 ["git", "config", "--remove-section", "foo"],
267                 ["git", "config", "--global", "--remove-section", "foo"],
268             )
269             for cmd in cmds:
270                 with salt.utils.files.fopen(os.devnull, "w") as devnull:
271                     try:
272                         subprocess.check_call(cmd, stderr=devnull)
273                     except subprocess.CalledProcessError:
274                         pass
275         cfg_local = {"foo.single": ["foo"], "foo.multi": ["foo", "bar", "baz"]}
276         cfg_global = {"foo.single": ["abc"], "foo.multi": ["abc", "def", "ghi"]}
277         _clear_config()
278         try:
279             log.debug("Try to specify both single and multivar (should raise error)")
280             self.assertTrue(
281                 "Only one of 'value' and 'multivar' is permitted"
282                 in self.run_function(
283                     "git.config_set",
284                     ["foo.single"],
285                     value=cfg_local["foo.single"][0],
286                     multivar=cfg_local["foo.multi"],
287                     cwd=self.repo,
288                 )
289             )
290             log.debug("Try to set single local value without cwd (should raise error)")
291             self.assertTrue(
292                 "'cwd' argument required unless global=True"
293                 in self.run_function(
294                     "git.config_set",
295                     ["foo.single"],
296                     value=cfg_local["foo.single"][0],
297                 )
298             )
299             log.debug("Set single local value")
300             self.assertEqual(
301                 self.run_function(
302                     "git.config_set",
303                     ["foo.single"],
304                     value=cfg_local["foo.single"][0],
305                     cwd=self.repo,
306                 ),
307                 cfg_local["foo.single"],
308             )
309             log.debug("Set single global value")
310             self.assertEqual(
311                 self.run_function(
312                     "git.config_set",
313                     ["foo.single"],
314                     value=cfg_global["foo.single"][0],
315                     **{"global": True}
316                 ),
317                 cfg_global["foo.single"],
318             )
319             log.debug("Set local multivar")
320             self.assertEqual(
321                 self.run_function(
322                     "git.config_set",
323                     ["foo.multi"],
324                     multivar=cfg_local["foo.multi"],
325                     cwd=self.repo,
326                 ),
327                 cfg_local["foo.multi"],
328             )
329             log.debug("Set global multivar")
330             self.assertEqual(
331                 self.run_function(
332                     "git.config_set",
333                     ["foo.multi"],
334                     multivar=cfg_global["foo.multi"],
335                     **{"global": True}
336                 ),
337                 cfg_global["foo.multi"],
338             )
339             log.debug("Get single local value")
340             self.assertEqual(
341                 self.run_function("git.config_get", ["foo.single"], cwd=self.repo),
342                 cfg_local["foo.single"][0],
343             )
344             log.debug("Get single value from local multivar")
345             self.assertEqual(
346                 self.run_function("git.config_get", ["foo.multi"], cwd=self.repo),
347                 cfg_local["foo.multi"][-1],
348             )
349             log.debug("Get all values from multivar (includes globals)")
350             self.assertEqual(
351                 self.run_function(
352                     "git.config_get", ["foo.multi"], cwd=self.repo, **{"all": True}
353                 ),
354                 cfg_local["foo.multi"],
355             )
356             log.debug("Get single global value")
357             self.assertEqual(
358                 self.run_function("git.config_get", ["foo.single"], **{"global": True}),
359                 cfg_global["foo.single"][0],
360             )
361             log.debug("Get single value from global multivar")
362             self.assertEqual(
363                 self.run_function("git.config_get", ["foo.multi"], **{"global": True}),
364                 cfg_global["foo.multi"][-1],
365             )
366             log.debug("Get all values from global multivar")
367             self.assertEqual(
368                 self.run_function(
369                     "git.config_get", ["foo.multi"], **{"all": True, "global": True}
370                 ),
371                 cfg_global["foo.multi"],
372             )
373             log.debug("Get all local keys/values using regex")
374             self.assertEqual(
375                 self.run_function(
376                     "git.config_get_regexp", ["foo.(single|multi)"], cwd=self.repo
377                 ),
378                 cfg_local,
379             )
380             log.debug("Get all global keys/values using regex")
381             self.assertEqual(
382                 self.run_function(
383                     "git.config_get_regexp",
384                     ["foo.(single|multi)"],
385                     cwd=self.repo,
386                     **{"global": True}
387                 ),
388                 cfg_global,
389             )
390             log.debug("Get just the local foo.multi values containing 'a'")
391             self.assertEqual(
392                 self.run_function(
393                     "git.config_get_regexp",
394                     ["foo.multi"],
395                     value_regex="a",
396                     cwd=self.repo,
397                 ),
398                 {"foo.multi": [x for x in cfg_local["foo.multi"] if "a" in x]},
399             )
400             log.debug("Get just the global foo.multi values containing 'a'")
401             self.assertEqual(
402                 self.run_function(
403                     "git.config_get_regexp",
404                     ["foo.multi"],
405                     value_regex="a",
406                     cwd=self.repo,
407                     **{"global": True}
408                 ),
409                 {"foo.multi": [x for x in cfg_global["foo.multi"] if "a" in x]},
410             )
411             log.debug("Unset a single local value")
412             self.assertTrue(
413                 self.run_function(
414                     "git.config_unset",
415                     ["foo.single"],
416                     cwd=self.repo,
417                 )
418             )
419             log.debug("Unset an entire local multivar")
420             self.assertTrue(
421                 self.run_function(
422                     "git.config_unset", ["foo.multi"], cwd=self.repo, **{"all": True}
423                 )
424             )
425             log.debug("Unset a single global value")
426             self.assertTrue(
427                 self.run_function(
428                     "git.config_unset", ["foo.single"], **{"global": True}
429                 )
430             )
431             log.debug("Unset an entire local multivar")
432             self.assertTrue(
433                 self.run_function(
434                     "git.config_unset", ["foo.multi"], **{"all": True, "global": True}
435                 )
436             )
437         finally:
438             _clear_config()
439     @pytest.mark.slow_test
440     def test_current_branch(self):
441         self.assertEqual(self.run_function("git.current_branch", [self.repo]), "master")
442     @pytest.mark.slow_test
443     def test_describe(self):
444         self.assertEqual(self.run_function("git.describe", [self.repo]), self.tags[0])
445     @pytest.mark.slow_test
446     def test_init(self):
447         new_repo = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
448         if salt.utils.platform.is_windows():
449             new_repo = new_repo.replace("\\", "/")
450             tmp_dir = os.path.basename(new_repo)
451             git_ret = self.run_function("git.init", [new_repo]).lower()
452             self.assertIn("Initialized empty Git repository in".lower(), git_ret)
453             self.assertIn(tmp_dir, git_ret)
454         else:
455             self.assertEqual(
456                 self.run_function("git.init", [new_repo]).lower(),
457                 "Initialized empty Git repository in {}/.git/".format(new_repo).lower(),
458             )
459         shutil.rmtree(new_repo)
460     @pytest.mark.slow_test
461     def test_list_branches(self):
462         self.assertEqual(
463             self.run_function("git.list_branches", [self.repo]), sorted(self.branches)
464         )
465     @pytest.mark.slow_test
466     def test_list_tags(self):
467         self.assertEqual(
468             self.run_function("git.list_tags", [self.repo]), sorted(self.tags)
469         )
470     @pytest.mark.slow_test
471     def test_merge(self):
472         ret = self.run_function("git.merge", [self.repo], rev=self.branches[1])
473         self.assertTrue("Fast-forward" in ret.splitlines())
474     @pytest.mark.slow_test
475     def test_merge_base_and_tree(self):
476         head_rev = self.run_function("git.revision", [self.repo], rev="HEAD")
477         self.assertTrue(len(head_rev) == 40)
478         second_rev = self.run_function(
479             "git.revision", [self.repo], rev=self.branches[1], timeout=120
480         )
481         self.assertTrue(len(second_rev) == 40)
482         self.assertEqual(
483             self.run_function(
484                 "git.merge_base", [self.repo], refs=",".join((head_rev, second_rev))
485             ),
486             head_rev,
487         )
488         ret = self.run_function(
489             "git.merge_tree", [self.repo, head_rev, second_rev]
490         ).splitlines()
491         self.assertTrue(len([x for x in ret if x.startswith("@@")]) == 1)
492     @pytest.mark.slow_test
493     def test_rebase(self):
494         self.assertNotIn(
495             "ERROR",
496             self.run_function("git.checkout", [self.repo], rev=self.branches[0]),
497         )
498         file_path = os.path.join(self.repo, self.files[1])
499         with salt.utils.files.fopen(file_path, "a") as fp_:
500             fp_.write("Added a line\n")
501         self.assertNotIn(
502             "ERROR",
503             self.run_function(
504                 "git.commit",
505                 [self.repo, "Added a line to " + self.files[1]],
506                 filename=self.files[1],
507             ),
508         )
509         self.assertNotIn(
510             "ERROR",
511             self.run_function("git.checkout", [self.repo], rev=self.branches[1]),
512         )
513         ret = self.run_function("git.rebase", [self.repo], opts="-vvv")
514         self.assertNotIn("ERROR", ret)
515         self.assertNotIn("up to date", ret)
516     @pytest.mark.slow_test
517     def test_remotes(self):
518         remotes = {
519             "first": {"fetch": "/dev/null", "push": "/dev/null"},
520             "second": {"fetch": "/dev/null", "push": "/dev/stdout"},
521         }
522         self.assertEqual(
523             self.run_function(
524                 "git.remote_set", [self.repo, remotes["first"]["fetch"]], remote="first"
525             ),
526             remotes["first"],
527         )
528         self.assertEqual(
529             self.run_function(
530                 "git.remote_set",
531                 [self.repo, remotes["second"]["fetch"]],
532                 remote="second",
533                 push_url=remotes["second"]["push"],
534             ),
535             remotes["second"],
536         )
537         self.assertEqual(self.run_function("git.remotes", [self.repo]), remotes)
538     @pytest.mark.slow_test
539     def test_reset(self):
540         self.assertTrue(
541             "ERROR"
542             not in self.run_function("git.checkout", [self.repo], rev=self.branches[1])
543         )
544         self.run_function("git.reset", [self.repo], opts="--hard HEAD~1")
545         head_rev = self.run_function("git.revision", [self.repo], rev="HEAD")
546         self.assertTrue(len(head_rev) == 40)
547         master_rev = self.run_function("git.revision", [self.repo], rev="master")
548         self.assertTrue(len(master_rev) == 40)
549         self.assertEqual(head_rev, master_rev)
550     @pytest.mark.slow_test
551     def test_rev_parse(self):
552         self.assertEqual(
553             self.run_function(
554                 "git.rev_parse", [self.repo, "HEAD"], opts="--abbrev-ref"
555             ),
556             "master",
557         )
558     @pytest.mark.slow_test
559     def test_rm(self):
560         single_file = self.files[0]
561         entire_dir = self.dirs[1]
562         self.assertEqual(
563             self.run_function("git.rm", [self.repo, single_file]),
564             "rm '" + single_file + "'",
565         )
566         expected = "\n".join(
567             sorted("rm '" + os.path.join(entire_dir, x) + "'" for x in self.files)
568         )
569         if salt.utils.platform.is_windows():
570             expected = expected.replace("\\", "/")
571         self.assertEqual(
572             self.run_function("git.rm", [self.repo, entire_dir], opts="-r"), expected
573         )
574     @pytest.mark.slow_test
575     def test_stash(self):
576         file_path = os.path.join(self.repo, self.files[0])
577         with salt.utils.files.fopen(file_path, "a") as fp_:
578             fp_.write("Temp change to be stashed")
579         self.assertTrue("ERROR" not in self.run_function("git.stash", [self.repo]))
580         ret = self.run_function("git.stash", [self.repo], action="list")
581         self.assertTrue("ERROR" not in ret)
582         self.assertTrue(len(ret.splitlines()) == 1)
583         self.assertTrue(
584             "ERROR"
585             not in self.run_function(
586                 "git.stash", [self.repo], action="apply", opts="stash@{0}"
587             )
588         )
589         self.assertTrue(
590             "ERROR"
591             not in self.run_function(
592                 "git.stash", [self.repo], action="drop", opts="stash@{0}"
593             )
594         )
595     @pytest.mark.slow_test
596     def test_status(self):
597         changes = {
598             "modified": ["foo"],
599             "new": ["thisisdefinitelyanewfile"],
600             "deleted": ["bar"],
601             "untracked": ["thisisalsoanewfile"],
602         }
603         for filename in changes["modified"]:
604             with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
605                 fp_.write("Added a line\n")
606         for filename in changes["new"]:
607             with salt.utils.files.fopen(os.path.join(self.repo, filename), "w") as fp_:
608                 fp_.write(
609                     salt.utils.stringutils.to_str(
610                         "This is a new file named {}.".format(filename)
611                     )
612                 )
613             self.assertTrue(
614                 "ERROR" not in self.run_function("git.add", [self.repo, filename])
615             )
616         for filename in changes["deleted"]:
617             self.run_function("git.rm", [self.repo, filename])
618         for filename in changes["untracked"]:
619             with salt.utils.files.fopen(os.path.join(self.repo, filename), "w") as fp_:
620                 fp_.write(
621                     salt.utils.stringutils.to_str(
622                         "This is a new file named {}.".format(filename)
623                     )
624                 )
625         self.assertEqual(self.run_function("git.status", [self.repo]), changes)
626     @pytest.mark.slow_test
627     def test_symbolic_ref(self):
628         self.assertEqual(
629             self.run_function("git.symbolic_ref", [self.repo, "HEAD"], opts="--quiet"),
630             "refs/heads/master",
631         )
632     @skipIf(
633         not _worktrees_supported(), "Git 2.5 or newer required for worktree support"
634     )
635     @pytest.mark.slow_test
636     def test_worktree_add_rm(self):
637         git_version = _git_version()
638         if git_version &gt;= LooseVersion("2.6.0"):
639             worktree_add_prefix = "Preparing "
640         else:
641             worktree_add_prefix = "Enter "
642         worktree_path = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
643         worktree_basename = os.path.basename(worktree_path)
644         worktree_path2 = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
645         worktree_basename2 = os.path.basename(worktree_path2)
646         if salt.utils.platform.is_windows():
647             worktree_path = worktree_path.replace("\\", "/")
648             worktree_path2 = worktree_path2.replace("\\", "/")
649         ret = self.run_function(
650             "git.worktree_add",
651             [self.repo, worktree_path],
652         )
653         self.assertTrue(worktree_add_prefix in ret)
654         self.assertTrue(worktree_basename in ret)
655         ret = self.run_function("git.worktree_add", [self.repo, worktree_path2])
656         self.assertTrue(worktree_add_prefix in ret)
657         self.assertTrue(worktree_basename2 in ret)
658         self.assertTrue(self.run_function("git.is_worktree", [worktree_path]))
659         self.assertFalse(self.run_function("git.is_worktree", [self.repo]))
660         empty_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
661         self.assertFalse(self.run_function("git.is_worktree", [empty_dir]))
662         shutil.rmtree(empty_dir)
663         self.assertTrue(self.run_function("git.worktree_rm", [worktree_path]))
664         prune_message = (
665             "Removing worktrees/{}: gitdir file points to non-existent location".format(
666                 worktree_basename
667             )
668         )
669         result = self.run_function("git.worktree_prune", [self.repo], dry_run=True)
670         self.assertEqual(result, prune_message)
671         self.assertEqual(
672             self.run_function("git.worktree_prune", [self.repo]), prune_message
673         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
