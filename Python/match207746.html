<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_sqs.py &amp; test_git_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_sqs.py &amp; test_git_1.py
      </h3>
<h1 align="center">
        1.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_sqs.py (6.936416%)<th>test_git_1.py (0.88691795%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(78-86)<td><a href="#" name="0">(301-304)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_sqs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import textwrap
import pytest
import salt.config
import salt.loader
import salt.states.boto_sqs as boto_sqs
from tests.support.mock import MagicMock, patch
@pytest.fixture
def configure_loader_modules():
    opts = salt.config.DEFAULT_MINION_OPTS.copy()
    utils = salt.loader.utils(
        opts,
        whitelist=["boto3", "yaml", "args", "systemd", "path", "platform"],
        context={},
    )
    return {boto_sqs: {"__utils__": utils}}
def test_present():
    name = "mysqs"
    attributes = {"DelaySeconds": 20}
    base_ret = {"name": name, "changes": {}}
    mock = MagicMock(
        side_effect=[{"result": b} for b in [False, False, True, True]],
    )
    mock_bool = MagicMock(return_value={"error": "create error"})
    mock_attr = MagicMock(return_value={"result": {}})
    with patch.dict(
        boto_sqs.__salt__,
        {
            "boto_sqs.exists": mock,
            "boto_sqs.create": mock_bool,
            "boto_sqs.get_attributes": mock_attr,
        },
    ):
        with patch.dict(boto_sqs.__opts__, {"test": False}):
            comt = [
                "Failed to create SQS queue {}: create error".format(
                    name,
                )
            ]
            ret = base_ret.copy()
            ret.update({"result": False, "comment": comt})
            assert boto_sqs.present(name) == ret
        with patch.dict(boto_sqs.__opts__, {"test": True}):
            comt = ["SQS queue {} is set to be created.".format(name)]
            ret = base_ret.copy()
            ret.update(
                {
                    "result": None,
                    "comment": comt,
                    "changes": {"old": None, "new": "mysqs"},
                }
            )
            assert boto_sqs.present(name) == ret
            diff = textwrap.dedent(
<a name="0"></a>            ).splitlines()
            for idx in (0, 1):
                diff[idx] += " "
            diff <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "\n".join(diff)
            comt = [
                "SQS queue mysqs present.",
                "Attribute(s) DelaySeconds set to be updated:\n{}".format(
                    diff,
                ),
            ]
            ret.update({"comment": comt, "changes": {"attributes": {"diff"</b></font>: diff}}})
            assert boto_sqs.present(name, attributes) == ret
        comt = ["SQS queue mysqs present."]
        ret = base_ret.copy()
        ret.update({"result": True, "comment": comt})
        assert boto_sqs.present(name) == ret
def test_absent():
    name = "test.example.com."
    base_ret = {"name": name, "changes": {}}
    mock = MagicMock(side_effect=[{"result": False}, {"result": True}])
    with patch.dict(boto_sqs.__salt__, {"boto_sqs.exists": mock}):
        comt = "SQS queue {} does not exist in None.".format(name)
        ret = base_ret.copy()
        ret.update({"result": True, "comment": comt})
        assert boto_sqs.absent(name) == ret
        with patch.dict(boto_sqs.__opts__, {"test": True}):
            comt = "SQS queue {} is set to be removed.".format(name)
            ret = base_ret.copy()
            ret.update(
                {
                    "result": None,
                    "comment": comt,
                    "changes": {"old": name, "new": None},
                }
            )
            assert boto_sqs.absent(name) == ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_git_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import os
import pathlib
import re
import shutil
import subprocess
import tarfile
import tempfile
from contextlib import closing
import pytest
import salt.utils.data
import salt.utils.files
import salt.utils.platform
from salt.utils.versions import LooseVersion
from tests.support.case import ModuleCase
from tests.support.helpers import change_cwd
from tests.support.runtests import RUNTIME_VARS
from tests.support.unit import skipIf
log = logging.getLogger(__name__)
def _git_version():
    try:
        git_version = subprocess.Popen(
            ["git", "--version"],
            shell=False,
            close_fds=False if salt.utils.platform.is_windows() else True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        ).communicate()[0]
    except OSError:
        return False
    if not git_version:
        log.debug("Git not installed")
        return False
    git_version = git_version.strip().split()[-1]
    git_version = git_version.decode(__salt_system_encoding__)
    log.debug("Detected git version: %s", git_version)
    return LooseVersion(git_version)
def _worktrees_supported():
    try:
        return _git_version() &gt;= LooseVersion("2.5.0")
    except AttributeError:
        return False
@pytest.mark.windows_whitelisted
@pytest.mark.skip_if_binaries_missing("git")
class GitModuleTest(ModuleCase):
    def setUp(self):
        super().setUp()
        self.repo = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        self.addCleanup(shutil.rmtree, self.repo, ignore_errors=True)
        self.addCleanup(delattr, self, "repo")
        self.files = ("foo", "bar", "baz", "питон")
        self.addCleanup(delattr, self, "files")
        self.dirs = ("", "qux")
        self.addCleanup(delattr, self, "dirs")
        self.branches = ("master", "iamanewbranch")
        self.addCleanup(delattr, self, "branches")
        self.tags = ("git_testing",)
        self.addCleanup(delattr, self, "tags")
        for dirname in self.dirs:
            dir_path = pathlib.Path(self.repo) / dirname
            dir_path.mkdir(parents=True, exist_ok=True)
            for filename in self.files:
                with salt.utils.files.fopen(str(dir_path / filename), "wb") as fp_:
                    fp_.write(
                        "This is a test file named {}.".format(filename).encode("utf-8")
                    )
        with change_cwd(self.repo):
            subprocess.check_call(["git", "init", "--quiet", self.repo])
            for key, value in (
                ("user.name", "Jenkins"),
                ("user.email", "qa@saltstack.com"),
            ):
                keycheck = subprocess.Popen(
                    ["git", "config", "--get", "--global", key],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                )
                if keycheck.wait() != 0:
                    subprocess.check_call(["git", "config", "--global", key, value])
            subprocess.check_call(["git", "add", "."])
            subprocess.check_call(
                ["git", "commit", "--quiet", "--message", "Initial commit"]
            )
            subprocess.check_call(["git", "tag", "-a", self.tags[0], "-m", "Add tag"])
            subprocess.check_call(
                ["git", "checkout", "--quiet", "-b", self.branches[1]]
            )
            with salt.utils.files.fopen(self.files[0], "a") as fp_:
                fp_.write(salt.utils.stringutils.to_str("Added a line\n"))
            subprocess.check_call(
                [
                    "git",
                    "commit",
                    "--quiet",
                    "--message",
                    "Added a line to " + self.files[0],
                    self.files[0],
                ]
            )
            subprocess.check_call(["git", "checkout", "--quiet", "master"])
    def run_function(self, *args, **kwargs):  # pylint: disable=arguments-differ
        return salt.utils.data.decode(super().run_function(*args, **kwargs))
    @pytest.mark.slow_test
    def test_add_dir(self):
        newdir = "quux"
        newdir_path = pathlib.Path(self.repo) / newdir
        newdir_path.mkdir(parents=True, exist_ok=True)
        files = [str(newdir_path / x) for x in self.files]
        files_relpath = [os.path.join(newdir, x) for x in self.files]
        for path in files:
            with salt.utils.files.fopen(path, "wb") as fp_:
                fp_.write(
                    "This is a test file with relative path {}.\n".format(path).encode(
                        "utf-8"
                    )
                )
        ret = self.run_function("git.add", [self.repo, newdir])
        res = "\n".join(sorted("add '{}'".format(x) for x in files_relpath))
        if salt.utils.platform.is_windows():
            res = res.replace("\\", "/")
        self.assertEqual(ret, res)
    @pytest.mark.slow_test
    def test_add_file(self):
        filename = "quux"
        file_path = os.path.join(self.repo, filename)
        with salt.utils.files.fopen(file_path, "w") as fp_:
            fp_.write(
                salt.utils.stringutils.to_str(
                    "This is a test file named {}.\n".format(filename)
                )
            )
        ret = self.run_function("git.add", [self.repo, filename])
        self.assertEqual(ret, "add '{}'".format(filename))
    @pytest.mark.slow_test
    def test_archive(self):
        tar_archive = os.path.join(RUNTIME_VARS.TMP, "test_archive.tar.gz")
        try:
            self.assertTrue(
                self.run_function(
                    "git.archive", [self.repo, tar_archive], prefix="foo/"
                )
            )
            self.assertTrue(tarfile.is_tarfile(tar_archive))
            self.run_function("cmd.run", ["cp " + tar_archive + " /root/"])
            with closing(tarfile.open(tar_archive, "r")) as tar_obj:
                self.assertEqual(
                    sorted(salt.utils.data.decode(tar_obj.getnames())),
                    sorted(
                        [
                            "foo",
                            "foo/bar",
                            "foo/baz",
                            "foo/foo",
                            "foo/питон",
                            "foo/qux",
                            "foo/qux/bar",
                            "foo/qux/baz",
                            "foo/qux/foo",
                            "foo/qux/питон",
                        ]
                    ),
                )
        finally:
            try:
                os.unlink(tar_archive)
            except OSError:
                pass
    @pytest.mark.slow_test
    def test_archive_subdir(self):
        tar_archive = os.path.join(RUNTIME_VARS.TMP, "test_archive.tar.gz")
        try:
            self.assertTrue(
                self.run_function(
                    "git.archive",
                    [os.path.join(self.repo, "qux"), tar_archive],
                    prefix="foo/",
                )
            )
            self.assertTrue(tarfile.is_tarfile(tar_archive))
            with closing(tarfile.open(tar_archive, "r")) as tar_obj:
                self.assertEqual(
                    sorted(salt.utils.data.decode(tar_obj.getnames())),
                    sorted(["foo", "foo/bar", "foo/baz", "foo/foo", "foo/питон"]),
                )
        finally:
            try:
                os.unlink(tar_archive)
            except OSError:
                pass
    @pytest.mark.slow_test
    def test_branch(self):
        renamed_branch = "ihavebeenrenamed"
        self.assertTrue(self.run_function("git.branch", [self.repo, self.branches[1]]))
        self.assertTrue(
            self.run_function(
                "git.branch", [self.repo, renamed_branch], opts="-m " + self.branches[1]
            )
        )
        self.assertTrue(
            self.run_function("git.branch", [self.repo, renamed_branch], opts="-D")
        )
    @pytest.mark.slow_test
    def test_checkout(self):
        new_branch = "iamanothernewbranch"
        self.assertEqual(
            self.run_function(
                "git.checkout", [self.repo, "HEAD"], opts="-b " + new_branch
            ),
            "Switched to a new branch '" + new_branch + "'",
        )
        self.assertTrue(
            "Switched to branch 'master'"
            in self.run_function("git.checkout", [self.repo, "master"]),
        )
    @pytest.mark.slow_test
    def test_checkout_no_rev(self):
        new_branch = "iamanothernewbranch"
        self.assertEqual(
            self.run_function(
                "git.checkout", [self.repo], rev=None, opts="-b " + new_branch
            ),
            "Switched to a new branch '" + new_branch + "'",
        )
        self.assertTrue(
            "'rev' argument is required unless -b or -B in opts"
            in self.run_function("git.checkout", [self.repo])
        )
    @pytest.mark.slow_test
    def test_clone(self):
<a name="0"></a>        """
        Test cloning an existing repo
        clone_parent_dir <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        self.assertTrue(self.run_function("git.clone", [clone_parent_dir, self.repo]))
        shutil.</b></font>rmtree(clone_parent_dir, True)
    @pytest.mark.slow_test
    def test_clone_with_alternate_name(self):
        clone_parent_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        clone_name = os.path.basename(self.repo)
        self.assertTrue(
            self.run_function(
                "git.clone", [clone_parent_dir, self.repo], name=clone_name
            )
        )
        shutil.rmtree(clone_parent_dir, True)
    @pytest.mark.slow_test
    def test_commit(self):
        filename = "foo"
        commit_re_prefix = r"^\[master [0-9a-f]+\] "
        with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
            fp_.write("Added a line\n")
        self.run_function("git.add", [self.repo, filename])
        commit_msg = "Add a line to " + filename
        ret = self.run_function("git.commit", [self.repo, commit_msg])
        self.assertTrue(bool(re.search(commit_re_prefix + commit_msg, ret)))
        with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
            fp_.write("Added another line\n")
        commit_msg = "Add another line to " + filename
        ret = self.run_function(
            "git.commit", [self.repo, commit_msg], filename=filename
        )
        self.assertTrue(bool(re.search(commit_re_prefix + commit_msg, ret)))
    @pytest.mark.slow_test
    def test_config(self):
        def _clear_config():
            cmds = (
                ["git", "config", "--remove-section", "foo"],
                ["git", "config", "--global", "--remove-section", "foo"],
            )
            for cmd in cmds:
                with salt.utils.files.fopen(os.devnull, "w") as devnull:
                    try:
                        subprocess.check_call(cmd, stderr=devnull)
                    except subprocess.CalledProcessError:
                        pass
        cfg_local = {"foo.single": ["foo"], "foo.multi": ["foo", "bar", "baz"]}
        cfg_global = {"foo.single": ["abc"], "foo.multi": ["abc", "def", "ghi"]}
        _clear_config()
        try:
            log.debug("Try to specify both single and multivar (should raise error)")
            self.assertTrue(
                "Only one of 'value' and 'multivar' is permitted"
                in self.run_function(
                    "git.config_set",
                    ["foo.single"],
                    value=cfg_local["foo.single"][0],
                    multivar=cfg_local["foo.multi"],
                    cwd=self.repo,
                )
            )
            log.debug("Try to set single local value without cwd (should raise error)")
            self.assertTrue(
                "'cwd' argument required unless global=True"
                in self.run_function(
                    "git.config_set",
                    ["foo.single"],
                    value=cfg_local["foo.single"][0],
                )
            )
            log.debug("Set single local value")
            self.assertEqual(
                self.run_function(
                    "git.config_set",
                    ["foo.single"],
                    value=cfg_local["foo.single"][0],
                    cwd=self.repo,
                ),
                cfg_local["foo.single"],
            )
            log.debug("Set single global value")
            self.assertEqual(
                self.run_function(
                    "git.config_set",
                    ["foo.single"],
                    value=cfg_global["foo.single"][0],
                    **{"global": True}
                ),
                cfg_global["foo.single"],
            )
            log.debug("Set local multivar")
            self.assertEqual(
                self.run_function(
                    "git.config_set",
                    ["foo.multi"],
                    multivar=cfg_local["foo.multi"],
                    cwd=self.repo,
                ),
                cfg_local["foo.multi"],
            )
            log.debug("Set global multivar")
            self.assertEqual(
                self.run_function(
                    "git.config_set",
                    ["foo.multi"],
                    multivar=cfg_global["foo.multi"],
                    **{"global": True}
                ),
                cfg_global["foo.multi"],
            )
            log.debug("Get single local value")
            self.assertEqual(
                self.run_function("git.config_get", ["foo.single"], cwd=self.repo),
                cfg_local["foo.single"][0],
            )
            log.debug("Get single value from local multivar")
            self.assertEqual(
                self.run_function("git.config_get", ["foo.multi"], cwd=self.repo),
                cfg_local["foo.multi"][-1],
            )
            log.debug("Get all values from multivar (includes globals)")
            self.assertEqual(
                self.run_function(
                    "git.config_get", ["foo.multi"], cwd=self.repo, **{"all": True}
                ),
                cfg_local["foo.multi"],
            )
            log.debug("Get single global value")
            self.assertEqual(
                self.run_function("git.config_get", ["foo.single"], **{"global": True}),
                cfg_global["foo.single"][0],
            )
            log.debug("Get single value from global multivar")
            self.assertEqual(
                self.run_function("git.config_get", ["foo.multi"], **{"global": True}),
                cfg_global["foo.multi"][-1],
            )
            log.debug("Get all values from global multivar")
            self.assertEqual(
                self.run_function(
                    "git.config_get", ["foo.multi"], **{"all": True, "global": True}
                ),
                cfg_global["foo.multi"],
            )
            log.debug("Get all local keys/values using regex")
            self.assertEqual(
                self.run_function(
                    "git.config_get_regexp", ["foo.(single|multi)"], cwd=self.repo
                ),
                cfg_local,
            )
            log.debug("Get all global keys/values using regex")
            self.assertEqual(
                self.run_function(
                    "git.config_get_regexp",
                    ["foo.(single|multi)"],
                    cwd=self.repo,
                    **{"global": True}
                ),
                cfg_global,
            )
            log.debug("Get just the local foo.multi values containing 'a'")
            self.assertEqual(
                self.run_function(
                    "git.config_get_regexp",
                    ["foo.multi"],
                    value_regex="a",
                    cwd=self.repo,
                ),
                {"foo.multi": [x for x in cfg_local["foo.multi"] if "a" in x]},
            )
            log.debug("Get just the global foo.multi values containing 'a'")
            self.assertEqual(
                self.run_function(
                    "git.config_get_regexp",
                    ["foo.multi"],
                    value_regex="a",
                    cwd=self.repo,
                    **{"global": True}
                ),
                {"foo.multi": [x for x in cfg_global["foo.multi"] if "a" in x]},
            )
            log.debug("Unset a single local value")
            self.assertTrue(
                self.run_function(
                    "git.config_unset",
                    ["foo.single"],
                    cwd=self.repo,
                )
            )
            log.debug("Unset an entire local multivar")
            self.assertTrue(
                self.run_function(
                    "git.config_unset", ["foo.multi"], cwd=self.repo, **{"all": True}
                )
            )
            log.debug("Unset a single global value")
            self.assertTrue(
                self.run_function(
                    "git.config_unset", ["foo.single"], **{"global": True}
                )
            )
            log.debug("Unset an entire local multivar")
            self.assertTrue(
                self.run_function(
                    "git.config_unset", ["foo.multi"], **{"all": True, "global": True}
                )
            )
        finally:
            _clear_config()
    @pytest.mark.slow_test
    def test_current_branch(self):
        self.assertEqual(self.run_function("git.current_branch", [self.repo]), "master")
    @pytest.mark.slow_test
    def test_describe(self):
        self.assertEqual(self.run_function("git.describe", [self.repo]), self.tags[0])
    @pytest.mark.slow_test
    def test_init(self):
        new_repo = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        if salt.utils.platform.is_windows():
            new_repo = new_repo.replace("\\", "/")
            tmp_dir = os.path.basename(new_repo)
            git_ret = self.run_function("git.init", [new_repo]).lower()
            self.assertIn("Initialized empty Git repository in".lower(), git_ret)
            self.assertIn(tmp_dir, git_ret)
        else:
            self.assertEqual(
                self.run_function("git.init", [new_repo]).lower(),
                "Initialized empty Git repository in {}/.git/".format(new_repo).lower(),
            )
        shutil.rmtree(new_repo)
    @pytest.mark.slow_test
    def test_list_branches(self):
        self.assertEqual(
            self.run_function("git.list_branches", [self.repo]), sorted(self.branches)
        )
    @pytest.mark.slow_test
    def test_list_tags(self):
        self.assertEqual(
            self.run_function("git.list_tags", [self.repo]), sorted(self.tags)
        )
    @pytest.mark.slow_test
    def test_merge(self):
        ret = self.run_function("git.merge", [self.repo], rev=self.branches[1])
        self.assertTrue("Fast-forward" in ret.splitlines())
    @pytest.mark.slow_test
    def test_merge_base_and_tree(self):
        head_rev = self.run_function("git.revision", [self.repo], rev="HEAD")
        self.assertTrue(len(head_rev) == 40)
        second_rev = self.run_function(
            "git.revision", [self.repo], rev=self.branches[1], timeout=120
        )
        self.assertTrue(len(second_rev) == 40)
        self.assertEqual(
            self.run_function(
                "git.merge_base", [self.repo], refs=",".join((head_rev, second_rev))
            ),
            head_rev,
        )
        ret = self.run_function(
            "git.merge_tree", [self.repo, head_rev, second_rev]
        ).splitlines()
        self.assertTrue(len([x for x in ret if x.startswith("@@")]) == 1)
    @pytest.mark.slow_test
    def test_rebase(self):
        self.assertNotIn(
            "ERROR",
            self.run_function("git.checkout", [self.repo], rev=self.branches[0]),
        )
        file_path = os.path.join(self.repo, self.files[1])
        with salt.utils.files.fopen(file_path, "a") as fp_:
            fp_.write("Added a line\n")
        self.assertNotIn(
            "ERROR",
            self.run_function(
                "git.commit",
                [self.repo, "Added a line to " + self.files[1]],
                filename=self.files[1],
            ),
        )
        self.assertNotIn(
            "ERROR",
            self.run_function("git.checkout", [self.repo], rev=self.branches[1]),
        )
        ret = self.run_function("git.rebase", [self.repo], opts="-vvv")
        self.assertNotIn("ERROR", ret)
        self.assertNotIn("up to date", ret)
    @pytest.mark.slow_test
    def test_remotes(self):
        remotes = {
            "first": {"fetch": "/dev/null", "push": "/dev/null"},
            "second": {"fetch": "/dev/null", "push": "/dev/stdout"},
        }
        self.assertEqual(
            self.run_function(
                "git.remote_set", [self.repo, remotes["first"]["fetch"]], remote="first"
            ),
            remotes["first"],
        )
        self.assertEqual(
            self.run_function(
                "git.remote_set",
                [self.repo, remotes["second"]["fetch"]],
                remote="second",
                push_url=remotes["second"]["push"],
            ),
            remotes["second"],
        )
        self.assertEqual(self.run_function("git.remotes", [self.repo]), remotes)
    @pytest.mark.slow_test
    def test_reset(self):
        self.assertTrue(
            "ERROR"
            not in self.run_function("git.checkout", [self.repo], rev=self.branches[1])
        )
        self.run_function("git.reset", [self.repo], opts="--hard HEAD~1")
        head_rev = self.run_function("git.revision", [self.repo], rev="HEAD")
        self.assertTrue(len(head_rev) == 40)
        master_rev = self.run_function("git.revision", [self.repo], rev="master")
        self.assertTrue(len(master_rev) == 40)
        self.assertEqual(head_rev, master_rev)
    @pytest.mark.slow_test
    def test_rev_parse(self):
        self.assertEqual(
            self.run_function(
                "git.rev_parse", [self.repo, "HEAD"], opts="--abbrev-ref"
            ),
            "master",
        )
    @pytest.mark.slow_test
    def test_rm(self):
        single_file = self.files[0]
        entire_dir = self.dirs[1]
        self.assertEqual(
            self.run_function("git.rm", [self.repo, single_file]),
            "rm '" + single_file + "'",
        )
        expected = "\n".join(
            sorted("rm '" + os.path.join(entire_dir, x) + "'" for x in self.files)
        )
        if salt.utils.platform.is_windows():
            expected = expected.replace("\\", "/")
        self.assertEqual(
            self.run_function("git.rm", [self.repo, entire_dir], opts="-r"), expected
        )
    @pytest.mark.slow_test
    def test_stash(self):
        file_path = os.path.join(self.repo, self.files[0])
        with salt.utils.files.fopen(file_path, "a") as fp_:
            fp_.write("Temp change to be stashed")
        self.assertTrue("ERROR" not in self.run_function("git.stash", [self.repo]))
        ret = self.run_function("git.stash", [self.repo], action="list")
        self.assertTrue("ERROR" not in ret)
        self.assertTrue(len(ret.splitlines()) == 1)
        self.assertTrue(
            "ERROR"
            not in self.run_function(
                "git.stash", [self.repo], action="apply", opts="stash@{0}"
            )
        )
        self.assertTrue(
            "ERROR"
            not in self.run_function(
                "git.stash", [self.repo], action="drop", opts="stash@{0}"
            )
        )
    @pytest.mark.slow_test
    def test_status(self):
        changes = {
            "modified": ["foo"],
            "new": ["thisisdefinitelyanewfile"],
            "deleted": ["bar"],
            "untracked": ["thisisalsoanewfile"],
        }
        for filename in changes["modified"]:
            with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
                fp_.write("Added a line\n")
        for filename in changes["new"]:
            with salt.utils.files.fopen(os.path.join(self.repo, filename), "w") as fp_:
                fp_.write(
                    salt.utils.stringutils.to_str(
                        "This is a new file named {}.".format(filename)
                    )
                )
            self.assertTrue(
                "ERROR" not in self.run_function("git.add", [self.repo, filename])
            )
        for filename in changes["deleted"]:
            self.run_function("git.rm", [self.repo, filename])
        for filename in changes["untracked"]:
            with salt.utils.files.fopen(os.path.join(self.repo, filename), "w") as fp_:
                fp_.write(
                    salt.utils.stringutils.to_str(
                        "This is a new file named {}.".format(filename)
                    )
                )
        self.assertEqual(self.run_function("git.status", [self.repo]), changes)
    @pytest.mark.slow_test
    def test_symbolic_ref(self):
        self.assertEqual(
            self.run_function("git.symbolic_ref", [self.repo, "HEAD"], opts="--quiet"),
            "refs/heads/master",
        )
    @skipIf(
        not _worktrees_supported(), "Git 2.5 or newer required for worktree support"
    )
    @pytest.mark.slow_test
    def test_worktree_add_rm(self):
        git_version = _git_version()
        if git_version &gt;= LooseVersion("2.6.0"):
            worktree_add_prefix = "Preparing "
        else:
            worktree_add_prefix = "Enter "
        worktree_path = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        worktree_basename = os.path.basename(worktree_path)
        worktree_path2 = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        worktree_basename2 = os.path.basename(worktree_path2)
        if salt.utils.platform.is_windows():
            worktree_path = worktree_path.replace("\\", "/")
            worktree_path2 = worktree_path2.replace("\\", "/")
        ret = self.run_function(
            "git.worktree_add",
            [self.repo, worktree_path],
        )
        self.assertTrue(worktree_add_prefix in ret)
        self.assertTrue(worktree_basename in ret)
        ret = self.run_function("git.worktree_add", [self.repo, worktree_path2])
        self.assertTrue(worktree_add_prefix in ret)
        self.assertTrue(worktree_basename2 in ret)
        self.assertTrue(self.run_function("git.is_worktree", [worktree_path]))
        self.assertFalse(self.run_function("git.is_worktree", [self.repo]))
        empty_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
        self.assertFalse(self.run_function("git.is_worktree", [empty_dir]))
        shutil.rmtree(empty_dir)
        self.assertTrue(self.run_function("git.worktree_rm", [worktree_path]))
        prune_message = (
            "Removing worktrees/{}: gitdir file points to non-existent location".format(
                worktree_basename
            )
        )
        result = self.run_function("git.worktree_prune", [self.repo], dry_run=True)
        self.assertEqual(result, prune_message)
        self.assertEqual(
            self.run_function("git.worktree_prune", [self.repo]), prune_message
        )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
