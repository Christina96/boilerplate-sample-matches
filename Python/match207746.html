<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_sqs.py &amp; test_git_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_sqs.py &amp; test_git_1.py
      </h3>
<h1 align="center">
        1.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_sqs.py (6.936416%)<th>test_git_1.py (0.88691795%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(78-86)<td><a href="#" name="0">(301-304)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_sqs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import textwrap
2 import pytest
3 import salt.config
4 import salt.loader
5 import salt.states.boto_sqs as boto_sqs
6 from tests.support.mock import MagicMock, patch
7 @pytest.fixture
8 def configure_loader_modules():
9     opts = salt.config.DEFAULT_MINION_OPTS.copy()
10     utils = salt.loader.utils(
11         opts,
12         whitelist=["boto3", "yaml", "args", "systemd", "path", "platform"],
13         context={},
14     )
15     return {boto_sqs: {"__utils__": utils}}
16 def test_present():
17     name = "mysqs"
18     attributes = {"DelaySeconds": 20}
19     base_ret = {"name": name, "changes": {}}
20     mock = MagicMock(
21         side_effect=[{"result": b} for b in [False, False, True, True]],
22     )
23     mock_bool = MagicMock(return_value={"error": "create error"})
24     mock_attr = MagicMock(return_value={"result": {}})
25     with patch.dict(
26         boto_sqs.__salt__,
27         {
28             "boto_sqs.exists": mock,
29             "boto_sqs.create": mock_bool,
30             "boto_sqs.get_attributes": mock_attr,
31         },
32     ):
33         with patch.dict(boto_sqs.__opts__, {"test": False}):
34             comt = [
35                 "Failed to create SQS queue {}: create error".format(
36                     name,
37                 )
38             ]
39             ret = base_ret.copy()
40             ret.update({"result": False, "comment": comt})
41             assert boto_sqs.present(name) == ret
42         with patch.dict(boto_sqs.__opts__, {"test": True}):
43             comt = ["SQS queue {} is set to be created.".format(name)]
44             ret = base_ret.copy()
45             ret.update(
46                 {
47                     "result": None,
48                     "comment": comt,
49                     "changes": {"old": None, "new": "mysqs"},
50                 }
51             )
52             assert boto_sqs.present(name) == ret
53             diff = textwrap.dedent(
54             for idx in (0, 1):
55                 diff[idx] += " "
56             diff <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= "\n".join(diff)
57             comt = [
58                 "SQS queue mysqs present.",
59                 "Attribute(s) DelaySeconds set to be updated:\n{}".format(
60                     diff,
61                 ),
62             ]
63             ret.update({"comment": comt, "changes": {"attributes": {"diff"</b></font>: diff}}})
64             assert boto_sqs.present(name, attributes) == ret
65         comt = ["SQS queue mysqs present."]
66         ret = base_ret.copy()
67         ret.update({"result": True, "comment": comt})
68         assert boto_sqs.present(name) == ret
69 def test_absent():
70     name = "test.example.com."
71     base_ret = {"name": name, "changes": {}}
72     mock = MagicMock(side_effect=[{"result": False}, {"result": True}])
73     with patch.dict(boto_sqs.__salt__, {"boto_sqs.exists": mock}):
74         comt = "SQS queue {} does not exist in None.".format(name)
75         ret = base_ret.copy()
76         ret.update({"result": True, "comment": comt})
77         assert boto_sqs.absent(name) == ret
78         with patch.dict(boto_sqs.__opts__, {"test": True}):
79             comt = "SQS queue {} is set to be removed.".format(name)
80             ret = base_ret.copy()
81             ret.update(
82                 {
83                     "result": None,
84                     "comment": comt,
85                     "changes": {"old": name, "new": None},
86                 }
87             )
88             assert boto_sqs.absent(name) == ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_git_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import pathlib
4 import re
5 import shutil
6 import subprocess
7 import tarfile
8 import tempfile
9 from contextlib import closing
10 import pytest
11 import salt.utils.data
12 import salt.utils.files
13 import salt.utils.platform
14 from salt.utils.versions import LooseVersion
15 from tests.support.case import ModuleCase
16 from tests.support.helpers import change_cwd
17 from tests.support.runtests import RUNTIME_VARS
18 from tests.support.unit import skipIf
19 log = logging.getLogger(__name__)
20 def _git_version():
21     try:
22         git_version = subprocess.Popen(
23             ["git", "--version"],
24             shell=False,
25             close_fds=False if salt.utils.platform.is_windows() else True,
26             stdout=subprocess.PIPE,
27             stderr=subprocess.PIPE,
28         ).communicate()[0]
29     except OSError:
30         return False
31     if not git_version:
32         log.debug("Git not installed")
33         return False
34     git_version = git_version.strip().split()[-1]
35     git_version = git_version.decode(__salt_system_encoding__)
36     log.debug("Detected git version: %s", git_version)
37     return LooseVersion(git_version)
38 def _worktrees_supported():
39     try:
40         return _git_version() &gt;= LooseVersion("2.5.0")
41     except AttributeError:
42         return False
43 @pytest.mark.windows_whitelisted
44 @pytest.mark.skip_if_binaries_missing("git")
45 class GitModuleTest(ModuleCase):
46     def setUp(self):
47         super().setUp()
48         self.repo = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
49         self.addCleanup(shutil.rmtree, self.repo, ignore_errors=True)
50         self.addCleanup(delattr, self, "repo")
51         self.files = ("foo", "bar", "baz", "питон")
52         self.addCleanup(delattr, self, "files")
53         self.dirs = ("", "qux")
54         self.addCleanup(delattr, self, "dirs")
55         self.branches = ("master", "iamanewbranch")
56         self.addCleanup(delattr, self, "branches")
57         self.tags = ("git_testing",)
58         self.addCleanup(delattr, self, "tags")
59         for dirname in self.dirs:
60             dir_path = pathlib.Path(self.repo) / dirname
61             dir_path.mkdir(parents=True, exist_ok=True)
62             for filename in self.files:
63                 with salt.utils.files.fopen(str(dir_path / filename), "wb") as fp_:
64                     fp_.write(
65                         "This is a test file named {}.".format(filename).encode("utf-8")
66                     )
67         with change_cwd(self.repo):
68             subprocess.check_call(["git", "init", "--quiet", self.repo])
69             for key, value in (
70                 ("user.name", "Jenkins"),
71                 ("user.email", "qa@saltstack.com"),
72             ):
73                 keycheck = subprocess.Popen(
74                     ["git", "config", "--get", "--global", key],
75                     stdout=subprocess.PIPE,
76                     stderr=subprocess.PIPE,
77                 )
78                 if keycheck.wait() != 0:
79                     subprocess.check_call(["git", "config", "--global", key, value])
80             subprocess.check_call(["git", "add", "."])
81             subprocess.check_call(
82                 ["git", "commit", "--quiet", "--message", "Initial commit"]
83             )
84             subprocess.check_call(["git", "tag", "-a", self.tags[0], "-m", "Add tag"])
85             subprocess.check_call(
86                 ["git", "checkout", "--quiet", "-b", self.branches[1]]
87             )
88             with salt.utils.files.fopen(self.files[0], "a") as fp_:
89                 fp_.write(salt.utils.stringutils.to_str("Added a line\n"))
90             subprocess.check_call(
91                 [
92                     "git",
93                     "commit",
94                     "--quiet",
95                     "--message",
96                     "Added a line to " + self.files[0],
97                     self.files[0],
98                 ]
99             )
100             subprocess.check_call(["git", "checkout", "--quiet", "master"])
101     def run_function(self, *args, **kwargs):  # pylint: disable=arguments-differ
102         return salt.utils.data.decode(super().run_function(*args, **kwargs))
103     @pytest.mark.slow_test
104     def test_add_dir(self):
105         newdir = "quux"
106         newdir_path = pathlib.Path(self.repo) / newdir
107         newdir_path.mkdir(parents=True, exist_ok=True)
108         files = [str(newdir_path / x) for x in self.files]
109         files_relpath = [os.path.join(newdir, x) for x in self.files]
110         for path in files:
111             with salt.utils.files.fopen(path, "wb") as fp_:
112                 fp_.write(
113                     "This is a test file with relative path {}.\n".format(path).encode(
114                         "utf-8"
115                     )
116                 )
117         ret = self.run_function("git.add", [self.repo, newdir])
118         res = "\n".join(sorted("add '{}'".format(x) for x in files_relpath))
119         if salt.utils.platform.is_windows():
120             res = res.replace("\\", "/")
121         self.assertEqual(ret, res)
122     @pytest.mark.slow_test
123     def test_add_file(self):
124         filename = "quux"
125         file_path = os.path.join(self.repo, filename)
126         with salt.utils.files.fopen(file_path, "w") as fp_:
127             fp_.write(
128                 salt.utils.stringutils.to_str(
129                     "This is a test file named {}.\n".format(filename)
130                 )
131             )
132         ret = self.run_function("git.add", [self.repo, filename])
133         self.assertEqual(ret, "add '{}'".format(filename))
134     @pytest.mark.slow_test
135     def test_archive(self):
136         tar_archive = os.path.join(RUNTIME_VARS.TMP, "test_archive.tar.gz")
137         try:
138             self.assertTrue(
139                 self.run_function(
140                     "git.archive", [self.repo, tar_archive], prefix="foo/"
141                 )
142             )
143             self.assertTrue(tarfile.is_tarfile(tar_archive))
144             self.run_function("cmd.run", ["cp " + tar_archive + " /root/"])
145             with closing(tarfile.open(tar_archive, "r")) as tar_obj:
146                 self.assertEqual(
147                     sorted(salt.utils.data.decode(tar_obj.getnames())),
148                     sorted(
149                         [
150                             "foo",
151                             "foo/bar",
152                             "foo/baz",
153                             "foo/foo",
154                             "foo/питон",
155                             "foo/qux",
156                             "foo/qux/bar",
157                             "foo/qux/baz",
158                             "foo/qux/foo",
159                             "foo/qux/питон",
160                         ]
161                     ),
162                 )
163         finally:
164             try:
165                 os.unlink(tar_archive)
166             except OSError:
167                 pass
168     @pytest.mark.slow_test
169     def test_archive_subdir(self):
170         tar_archive = os.path.join(RUNTIME_VARS.TMP, "test_archive.tar.gz")
171         try:
172             self.assertTrue(
173                 self.run_function(
174                     "git.archive",
175                     [os.path.join(self.repo, "qux"), tar_archive],
176                     prefix="foo/",
177                 )
178             )
179             self.assertTrue(tarfile.is_tarfile(tar_archive))
180             with closing(tarfile.open(tar_archive, "r")) as tar_obj:
181                 self.assertEqual(
182                     sorted(salt.utils.data.decode(tar_obj.getnames())),
183                     sorted(["foo", "foo/bar", "foo/baz", "foo/foo", "foo/питон"]),
184                 )
185         finally:
186             try:
187                 os.unlink(tar_archive)
188             except OSError:
189                 pass
190     @pytest.mark.slow_test
191     def test_branch(self):
192         renamed_branch = "ihavebeenrenamed"
193         self.assertTrue(self.run_function("git.branch", [self.repo, self.branches[1]]))
194         self.assertTrue(
195             self.run_function(
196                 "git.branch", [self.repo, renamed_branch], opts="-m " + self.branches[1]
197             )
198         )
199         self.assertTrue(
200             self.run_function("git.branch", [self.repo, renamed_branch], opts="-D")
201         )
202     @pytest.mark.slow_test
203     def test_checkout(self):
204         new_branch = "iamanothernewbranch"
205         self.assertEqual(
206             self.run_function(
207                 "git.checkout", [self.repo, "HEAD"], opts="-b " + new_branch
208             ),
209             "Switched to a new branch '" + new_branch + "'",
210         )
211         self.assertTrue(
212             "Switched to branch 'master'"
213             in self.run_function("git.checkout", [self.repo, "master"]),
214         )
215     @pytest.mark.slow_test
216     def test_checkout_no_rev(self):
217         new_branch = "iamanothernewbranch"
218         self.assertEqual(
219             self.run_function(
220                 "git.checkout", [self.repo], rev=None, opts="-b " + new_branch
221             ),
222             "Switched to a new branch '" + new_branch + "'",
223         )
224         self.assertTrue(
225             "'rev' argument is required unless -b or -B in opts"
226             in self.run_function("git.checkout", [self.repo])
227         )
228     @pytest.mark.slow_test
229     def test_clone(self):
230         Test cloning an existing repo
231         """
232         clone_parent_dir <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
233         self.assertTrue(self.run_function("git.clone", [clone_parent_dir, self.repo]))
234         shutil.</b></font>rmtree(clone_parent_dir, True)
235     @pytest.mark.slow_test
236     def test_clone_with_alternate_name(self):
237         """
238         Test cloning an existing repo with an alternate name for the repo dir
239         """
240         clone_parent_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
241         clone_name = os.path.basename(self.repo)
242         self.assertTrue(
243             self.run_function(
244                 "git.clone", [clone_parent_dir, self.repo], name=clone_name
245             )
246         )
247         shutil.rmtree(clone_parent_dir, True)
248     @pytest.mark.slow_test
249     def test_commit(self):
250         """
251         Test git.commit two ways:
252             1) First using git.add, then git.commit
253             2) Using git.commit with the 'filename' argument to skip staging
254         """
255         filename = "foo"
256         commit_re_prefix = r"^\[master [0-9a-f]+\] "
257         with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
258             fp_.write("Added a line\n")
259         self.run_function("git.add", [self.repo, filename])
260         commit_msg = "Add a line to " + filename
261         ret = self.run_function("git.commit", [self.repo, commit_msg])
262         self.assertTrue(bool(re.search(commit_re_prefix + commit_msg, ret)))
263         with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
264             fp_.write("Added another line\n")
265         commit_msg = "Add another line to " + filename
266         ret = self.run_function(
267             "git.commit", [self.repo, commit_msg], filename=filename
268         )
269         self.assertTrue(bool(re.search(commit_re_prefix + commit_msg, ret)))
270     @pytest.mark.slow_test
271     def test_config(self):
272         """
273         Test setting, getting, and unsetting config values
274         WARNING: This test will modify and completely remove a config section
275         'foo', both in the repo created in setUp() and in the user's global
276         .gitconfig.
277         """
278         def _clear_config():
279             cmds = (
280                 ["git", "config", "--remove-section", "foo"],
281                 ["git", "config", "--global", "--remove-section", "foo"],
282             )
283             for cmd in cmds:
284                 with salt.utils.files.fopen(os.devnull, "w") as devnull:
285                     try:
286                         subprocess.check_call(cmd, stderr=devnull)
287                     except subprocess.CalledProcessError:
288                         pass
289         cfg_local = {"foo.single": ["foo"], "foo.multi": ["foo", "bar", "baz"]}
290         cfg_global = {"foo.single": ["abc"], "foo.multi": ["abc", "def", "ghi"]}
291         _clear_config()
292         try:
293             log.debug("Try to specify both single and multivar (should raise error)")
294             self.assertTrue(
295                 "Only one of 'value' and 'multivar' is permitted"
296                 in self.run_function(
297                     "git.config_set",
298                     ["foo.single"],
299                     value=cfg_local["foo.single"][0],
300                     multivar=cfg_local["foo.multi"],
301                     cwd=self.repo,
302                 )
303             )
304             log.debug("Try to set single local value without cwd (should raise error)")
305             self.assertTrue(
306                 "'cwd' argument required unless global=True"
307                 in self.run_function(
308                     "git.config_set",
309                     ["foo.single"],
310                     value=cfg_local["foo.single"][0],
311                 )
312             )
313             log.debug("Set single local value")
314             self.assertEqual(
315                 self.run_function(
316                     "git.config_set",
317                     ["foo.single"],
318                     value=cfg_local["foo.single"][0],
319                     cwd=self.repo,
320                 ),
321                 cfg_local["foo.single"],
322             )
323             log.debug("Set single global value")
324             self.assertEqual(
325                 self.run_function(
326                     "git.config_set",
327                     ["foo.single"],
328                     value=cfg_global["foo.single"][0],
329                     **{"global": True}
330                 ),
331                 cfg_global["foo.single"],
332             )
333             log.debug("Set local multivar")
334             self.assertEqual(
335                 self.run_function(
336                     "git.config_set",
337                     ["foo.multi"],
338                     multivar=cfg_local["foo.multi"],
339                     cwd=self.repo,
340                 ),
341                 cfg_local["foo.multi"],
342             )
343             log.debug("Set global multivar")
344             self.assertEqual(
345                 self.run_function(
346                     "git.config_set",
347                     ["foo.multi"],
348                     multivar=cfg_global["foo.multi"],
349                     **{"global": True}
350                 ),
351                 cfg_global["foo.multi"],
352             )
353             log.debug("Get single local value")
354             self.assertEqual(
355                 self.run_function("git.config_get", ["foo.single"], cwd=self.repo),
356                 cfg_local["foo.single"][0],
357             )
358             log.debug("Get single value from local multivar")
359             self.assertEqual(
360                 self.run_function("git.config_get", ["foo.multi"], cwd=self.repo),
361                 cfg_local["foo.multi"][-1],
362             )
363             log.debug("Get all values from multivar (includes globals)")
364             self.assertEqual(
365                 self.run_function(
366                     "git.config_get", ["foo.multi"], cwd=self.repo, **{"all": True}
367                 ),
368                 cfg_local["foo.multi"],
369             )
370             log.debug("Get single global value")
371             self.assertEqual(
372                 self.run_function("git.config_get", ["foo.single"], **{"global": True}),
373                 cfg_global["foo.single"][0],
374             )
375             log.debug("Get single value from global multivar")
376             self.assertEqual(
377                 self.run_function("git.config_get", ["foo.multi"], **{"global": True}),
378                 cfg_global["foo.multi"][-1],
379             )
380             log.debug("Get all values from global multivar")
381             self.assertEqual(
382                 self.run_function(
383                     "git.config_get", ["foo.multi"], **{"all": True, "global": True}
384                 ),
385                 cfg_global["foo.multi"],
386             )
387             log.debug("Get all local keys/values using regex")
388             self.assertEqual(
389                 self.run_function(
390                     "git.config_get_regexp", ["foo.(single|multi)"], cwd=self.repo
391                 ),
392                 cfg_local,
393             )
394             log.debug("Get all global keys/values using regex")
395             self.assertEqual(
396                 self.run_function(
397                     "git.config_get_regexp",
398                     ["foo.(single|multi)"],
399                     cwd=self.repo,
400                     **{"global": True}
401                 ),
402                 cfg_global,
403             )
404             log.debug("Get just the local foo.multi values containing 'a'")
405             self.assertEqual(
406                 self.run_function(
407                     "git.config_get_regexp",
408                     ["foo.multi"],
409                     value_regex="a",
410                     cwd=self.repo,
411                 ),
412                 {"foo.multi": [x for x in cfg_local["foo.multi"] if "a" in x]},
413             )
414             log.debug("Get just the global foo.multi values containing 'a'")
415             self.assertEqual(
416                 self.run_function(
417                     "git.config_get_regexp",
418                     ["foo.multi"],
419                     value_regex="a",
420                     cwd=self.repo,
421                     **{"global": True}
422                 ),
423                 {"foo.multi": [x for x in cfg_global["foo.multi"] if "a" in x]},
424             )
425             log.debug("Unset a single local value")
426             self.assertTrue(
427                 self.run_function(
428                     "git.config_unset",
429                     ["foo.single"],
430                     cwd=self.repo,
431                 )
432             )
433             log.debug("Unset an entire local multivar")
434             self.assertTrue(
435                 self.run_function(
436                     "git.config_unset", ["foo.multi"], cwd=self.repo, **{"all": True}
437                 )
438             )
439             log.debug("Unset a single global value")
440             self.assertTrue(
441                 self.run_function(
442                     "git.config_unset", ["foo.single"], **{"global": True}
443                 )
444             )
445             log.debug("Unset an entire local multivar")
446             self.assertTrue(
447                 self.run_function(
448                     "git.config_unset", ["foo.multi"], **{"all": True, "global": True}
449                 )
450             )
451         finally:
452             _clear_config()
453     @pytest.mark.slow_test
454     def test_current_branch(self):
455         """
456         Test git.current_branch
457         """
458         self.assertEqual(self.run_function("git.current_branch", [self.repo]), "master")
459     @pytest.mark.slow_test
460     def test_describe(self):
461         """
462         Test git.describe
463         """
464         self.assertEqual(self.run_function("git.describe", [self.repo]), self.tags[0])
465     @pytest.mark.slow_test
466     def test_init(self):
467         """
468         Use git.init to init a new repo
469         """
470         new_repo = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
471         if salt.utils.platform.is_windows():
472             new_repo = new_repo.replace("\\", "/")
473             tmp_dir = os.path.basename(new_repo)
474             git_ret = self.run_function("git.init", [new_repo]).lower()
475             self.assertIn("Initialized empty Git repository in".lower(), git_ret)
476             self.assertIn(tmp_dir, git_ret)
477         else:
478             self.assertEqual(
479                 self.run_function("git.init", [new_repo]).lower(),
480                 "Initialized empty Git repository in {}/.git/".format(new_repo).lower(),
481             )
482         shutil.rmtree(new_repo)
483     @pytest.mark.slow_test
484     def test_list_branches(self):
485         """
486         Test git.list_branches
487         """
488         self.assertEqual(
489             self.run_function("git.list_branches", [self.repo]), sorted(self.branches)
490         )
491     @pytest.mark.slow_test
492     def test_list_tags(self):
493         """
494         Test git.list_tags
495         """
496         self.assertEqual(
497             self.run_function("git.list_tags", [self.repo]), sorted(self.tags)
498         )
499     @pytest.mark.slow_test
500     def test_merge(self):
501         """
502         Test git.merge
503         """
504         ret = self.run_function("git.merge", [self.repo], rev=self.branches[1])
505         self.assertTrue("Fast-forward" in ret.splitlines())
506     @pytest.mark.slow_test
507     def test_merge_base_and_tree(self):
508         """
509         Test git.merge_base, git.merge_tree and git.revision
510         TODO: Test all of the arguments
511         """
512         head_rev = self.run_function("git.revision", [self.repo], rev="HEAD")
513         self.assertTrue(len(head_rev) == 40)
514         second_rev = self.run_function(
515             "git.revision", [self.repo], rev=self.branches[1], timeout=120
516         )
517         self.assertTrue(len(second_rev) == 40)
518         self.assertEqual(
519             self.run_function(
520                 "git.merge_base", [self.repo], refs=",".join((head_rev, second_rev))
521             ),
522             head_rev,
523         )
524         ret = self.run_function(
525             "git.merge_tree", [self.repo, head_rev, second_rev]
526         ).splitlines()
527         self.assertTrue(len([x for x in ret if x.startswith("@@")]) == 1)
528     @pytest.mark.slow_test
529     def test_rebase(self):
530         """
531         Test git.rebase
532         """
533         self.assertNotIn(
534             "ERROR",
535             self.run_function("git.checkout", [self.repo], rev=self.branches[0]),
536         )
537         file_path = os.path.join(self.repo, self.files[1])
538         with salt.utils.files.fopen(file_path, "a") as fp_:
539             fp_.write("Added a line\n")
540         self.assertNotIn(
541             "ERROR",
542             self.run_function(
543                 "git.commit",
544                 [self.repo, "Added a line to " + self.files[1]],
545                 filename=self.files[1],
546             ),
547         )
548         self.assertNotIn(
549             "ERROR",
550             self.run_function("git.checkout", [self.repo], rev=self.branches[1]),
551         )
552         ret = self.run_function("git.rebase", [self.repo], opts="-vvv")
553         self.assertNotIn("ERROR", ret)
554         self.assertNotIn("up to date", ret)
555     @pytest.mark.slow_test
556     def test_remotes(self):
557         """
558         Test setting a remote (git.remote_set), and getting a remote
559         (git.remote_get and git.remotes)
560         TODO: Properly mock fetching a remote (git.fetch), and build out more
561         robust testing that confirms that the https auth bits work.
562         """
563         remotes = {
564             "first": {"fetch": "/dev/null", "push": "/dev/null"},
565             "second": {"fetch": "/dev/null", "push": "/dev/stdout"},
566         }
567         self.assertEqual(
568             self.run_function(
569                 "git.remote_set", [self.repo, remotes["first"]["fetch"]], remote="first"
570             ),
571             remotes["first"],
572         )
573         self.assertEqual(
574             self.run_function(
575                 "git.remote_set",
576                 [self.repo, remotes["second"]["fetch"]],
577                 remote="second",
578                 push_url=remotes["second"]["push"],
579             ),
580             remotes["second"],
581         )
582         self.assertEqual(self.run_function("git.remotes", [self.repo]), remotes)
583     @pytest.mark.slow_test
584     def test_reset(self):
585         """
586         Test git.reset
587         TODO: Test more than just a hard reset
588         """
589         self.assertTrue(
590             "ERROR"
591             not in self.run_function("git.checkout", [self.repo], rev=self.branches[1])
592         )
593         self.run_function("git.reset", [self.repo], opts="--hard HEAD~1")
594         head_rev = self.run_function("git.revision", [self.repo], rev="HEAD")
595         self.assertTrue(len(head_rev) == 40)
596         master_rev = self.run_function("git.revision", [self.repo], rev="master")
597         self.assertTrue(len(master_rev) == 40)
598         self.assertEqual(head_rev, master_rev)
599     @pytest.mark.slow_test
600     def test_rev_parse(self):
601         """
602         Test git.rev_parse
603         """
604         self.assertEqual(
605             self.run_function(
606                 "git.rev_parse", [self.repo, "HEAD"], opts="--abbrev-ref"
607             ),
608             "master",
609         )
610     @pytest.mark.slow_test
611     def test_rm(self):
612         """
613         Test git.rm
614         """
615         single_file = self.files[0]
616         entire_dir = self.dirs[1]
617         self.assertEqual(
618             self.run_function("git.rm", [self.repo, single_file]),
619             "rm '" + single_file + "'",
620         )
621         expected = "\n".join(
622             sorted("rm '" + os.path.join(entire_dir, x) + "'" for x in self.files)
623         )
624         if salt.utils.platform.is_windows():
625             expected = expected.replace("\\", "/")
626         self.assertEqual(
627             self.run_function("git.rm", [self.repo, entire_dir], opts="-r"), expected
628         )
629     @pytest.mark.slow_test
630     def test_stash(self):
631         """
632         Test git.stash
633         """
634         file_path = os.path.join(self.repo, self.files[0])
635         with salt.utils.files.fopen(file_path, "a") as fp_:
636             fp_.write("Temp change to be stashed")
637         self.assertTrue("ERROR" not in self.run_function("git.stash", [self.repo]))
638         ret = self.run_function("git.stash", [self.repo], action="list")
639         self.assertTrue("ERROR" not in ret)
640         self.assertTrue(len(ret.splitlines()) == 1)
641         self.assertTrue(
642             "ERROR"
643             not in self.run_function(
644                 "git.stash", [self.repo], action="apply", opts="stash@{0}"
645             )
646         )
647         self.assertTrue(
648             "ERROR"
649             not in self.run_function(
650                 "git.stash", [self.repo], action="drop", opts="stash@{0}"
651             )
652         )
653     @pytest.mark.slow_test
654     def test_status(self):
655         """
656         Test git.status
657         """
658         changes = {
659             "modified": ["foo"],
660             "new": ["thisisdefinitelyanewfile"],
661             "deleted": ["bar"],
662             "untracked": ["thisisalsoanewfile"],
663         }
664         for filename in changes["modified"]:
665             with salt.utils.files.fopen(os.path.join(self.repo, filename), "a") as fp_:
666                 fp_.write("Added a line\n")
667         for filename in changes["new"]:
668             with salt.utils.files.fopen(os.path.join(self.repo, filename), "w") as fp_:
669                 fp_.write(
670                     salt.utils.stringutils.to_str(
671                         "This is a new file named {}.".format(filename)
672                     )
673                 )
674             self.assertTrue(
675                 "ERROR" not in self.run_function("git.add", [self.repo, filename])
676             )
677         for filename in changes["deleted"]:
678             self.run_function("git.rm", [self.repo, filename])
679         for filename in changes["untracked"]:
680             with salt.utils.files.fopen(os.path.join(self.repo, filename), "w") as fp_:
681                 fp_.write(
682                     salt.utils.stringutils.to_str(
683                         "This is a new file named {}.".format(filename)
684                     )
685                 )
686         self.assertEqual(self.run_function("git.status", [self.repo]), changes)
687     @pytest.mark.slow_test
688     def test_symbolic_ref(self):
689         """
690         Test git.symbolic_ref
691         """
692         self.assertEqual(
693             self.run_function("git.symbolic_ref", [self.repo, "HEAD"], opts="--quiet"),
694             "refs/heads/master",
695         )
696     @skipIf(
697         not _worktrees_supported(), "Git 2.5 or newer required for worktree support"
698     )
699     @pytest.mark.slow_test
700     def test_worktree_add_rm(self):
701         """
702         This tests git.worktree_add, git.is_worktree, git.worktree_rm, and
703         git.worktree_prune. Tests for 'git worktree list' are covered in
704         tests.unit.modules.git_test.
705         """
706         git_version = _git_version()
707         if git_version &gt;= LooseVersion("2.6.0"):
708             worktree_add_prefix = "Preparing "
709         else:
710             worktree_add_prefix = "Enter "
711         worktree_path = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
712         worktree_basename = os.path.basename(worktree_path)
713         worktree_path2 = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
714         worktree_basename2 = os.path.basename(worktree_path2)
715         if salt.utils.platform.is_windows():
716             worktree_path = worktree_path.replace("\\", "/")
717             worktree_path2 = worktree_path2.replace("\\", "/")
718         ret = self.run_function(
719             "git.worktree_add",
720             [self.repo, worktree_path],
721         )
722         self.assertTrue(worktree_add_prefix in ret)
723         self.assertTrue(worktree_basename in ret)
724         ret = self.run_function("git.worktree_add", [self.repo, worktree_path2])
725         self.assertTrue(worktree_add_prefix in ret)
726         self.assertTrue(worktree_basename2 in ret)
727         self.assertTrue(self.run_function("git.is_worktree", [worktree_path]))
728         self.assertFalse(self.run_function("git.is_worktree", [self.repo]))
729         empty_dir = tempfile.mkdtemp(dir=RUNTIME_VARS.TMP)
730         self.assertFalse(self.run_function("git.is_worktree", [empty_dir]))
731         shutil.rmtree(empty_dir)
732         self.assertTrue(self.run_function("git.worktree_rm", [worktree_path]))
733         prune_message = (
734             "Removing worktrees/{}: gitdir file points to non-existent location".format(
735                 worktree_basename
736             )
737         )
738         result = self.run_function("git.worktree_prune", [self.repo], dry_run=True)
739         self.assertEqual(result, prune_message)
740         self.assertEqual(
741             self.run_function("git.worktree_prune", [self.repo]), prune_message
742         )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
