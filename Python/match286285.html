<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mac_brew_pkg.py &amp; postgres_2.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mac_brew_pkg.py &amp; postgres_2.py
      </h3>
<h1 align="center">
        0.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mac_brew_pkg.py (1.6689847%)<th>postgres_2.py (0.41855597%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(115-119)<td><a href="#" name="0">(1221-1224)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mac_brew_pkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import functools
3 import logging
4 import re
5 import salt.utils.data
6 import salt.utils.functools
7 import salt.utils.json
8 import salt.utils.path
9 import salt.utils.pkg
10 import salt.utils.versions
11 from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
12 log = logging.getLogger(__name__)
13 __virtualname__ = "pkg"
14 def __virtual__():
15     if __grains__["os"] != "MacOS":
16         return False, "brew module is macos specific"
17     if not salt.utils.path.which("brew"):
18         return False, "The 'brew' binary was not found"
19     return __virtualname__
20 def _list_taps():
21     return _call_brew("tap")["stdout"].splitlines()
22 def _list_pinned():
23     return _call_brew("list", "--pinned")["stdout"].splitlines()
24 def _pin(pkg, runas=None):
25     try:
26         _call_brew("pin", pkg)
27     except CommandExecutionError:
28         log.error('Failed to pin "%s"', pkg)
29         return False
30     return True
31 def _unpin(pkg, runas=None):
32     try:
33         _call_brew("unpin", pkg)
34     except CommandExecutionError:
35         log.error('Failed to unpin "%s"', pkg)
36         return False
37     return True
38 def _tap(tap, runas=None):
39     if tap in _list_taps():
40         return True
41     try:
42         _call_brew("tap", tap)
43     except CommandExecutionError:
44         log.error('Failed to tap "%s"', tap)
45         return False
46     return True
47 def _homebrew_bin():
48     ret = __salt__["cmd.run"]("brew --prefix", output_loglevel="trace")
49     ret += "/bin/brew"
50     return ret
51 def _call_brew(*cmd, failhard=True):
52     user = __salt__["file.get_user"](_homebrew_bin())
53     _cmd = []
54     if runas:
55         _cmd = ["sudo -i -n -H -u {} -- ".format<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(runas)]
56     _cmd = _cmd + [salt.utils.path.which("brew")] + list(cmd)
57     _cmd = " ".join(_cmd)
58     runas =</b></font> None
59     result = __salt__["cmd.run_all"](
60         cmd=_cmd,
61         runas=runas,
62         output_loglevel="trace",
63         python_shell=False,
64     )
65     if failhard and result["retcode"] != 0:
66         raise CommandExecutionError("Brew command failed", info={"result": result})
67     return result
68 def _list_pkgs_from_context(versions_as_list):
69     if versions_as_list:
70         return __context__["pkg.list_pkgs"]
71     else:
72         ret = copy.deepcopy(__context__["pkg.list_pkgs"])
73         __salt__["pkg_resource.stringify"](ret)
74         return ret
75 def list_pkgs(versions_as_list=False, **kwargs):
76     versions_as_list = salt.utils.data.is_true(versions_as_list)
77     if any(
78         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
79     ):
80         return {}
81     if "pkg.list_pkgs" in __context__ and kwargs.get("use_context", True):
82         return _list_pkgs_from_context(versions_as_list)
83     ret = {}
84     package_info = salt.utils.json.loads(
85         _call_brew("info", "--json=v2", "--installed")["stdout"]
86     )
87     for package in package_info["formulae"]:
88         versions = [v["version"] for v in package["installed"]]
89         names = package["aliases"] + [package["name"], package["full_name"]]
90         combinations = [(n, v) for n in names for v in versions]
91         for name, version in combinations:
92             __salt__["pkg_resource.add_pkg"](ret, name, version)
93     try:
94         out = _call_brew("list", "--cask", "--versions")["stdout"]
95         for line in out.splitlines():
96             try:
97                 name_and_versions = line.split(" ")
98                 pkg_name = name_and_versions[0]
99                 match = re.search(
100                     r"^From: .*/(.+?)/homebrew-(.+?)/.*$",
101                     _call_brew("info", "--cask", pkg_name)["stdout"],
102                     re.MULTILINE,
103                 )
104                 if match:
105                     namespace = "/".join(
106                         (match.group(1).lower(), match.group(2).lower())
107                     )
108                 else:
109                     namespace = "homebrew/cask"
110                 name = "/".join((namespace, pkg_name))
111                 installed_versions = name_and_versions[1:]
112                 key_func = functools.cmp_to_key(salt.utils.versions.version_cmp)
113                 newest_version = sorted(installed_versions, key=key_func).pop()
114             except ValueError:
115                 continue
116             __salt__["pkg_resource.add_pkg"](ret, name, newest_version)
117     except CommandExecutionError:
118         pass
119     __salt__["pkg_resource.sort_pkglist"](ret)
120     __context__["pkg.list_pkgs"] = copy.deepcopy(ret)
121     if not versions_as_list:
122         __salt__["pkg_resource.stringify"](ret)
123     return ret
124 def version(*names, **kwargs):
125     return __salt__["pkg_resource.version"](*names, **kwargs)
126 def latest_version(*names, **kwargs):
127     refresh = salt.utils.data.is_true(kwargs.pop("refresh", True))
128     if refresh:
129         refresh_db()
130     def get_version(pkg_info):
131         return pkg_info["versions"]["stable"] or pkg_info["versions"]["devel"]
132     versions_dict = {key: get_version(val) for key, val in _info(*names).items()}
133     if len(names) == 1:
134         return next(iter(versions_dict.values()))
135     else:
136         return versions_dict
137 available_version = salt.utils.functools.alias_function(
138     latest_version, "available_version"
139 )
140 def remove(name=None, pkgs=None, **kwargs):
141     try:
142         pkg_params = __salt__["pkg_resource.parse_targets"](name, pkgs, **kwargs)[0]
143     except MinionError as exc:
144         raise CommandExecutionError(exc)
145     old = list_pkgs()
146     targets = [x for x in pkg_params if x in old]
147     if not targets:
148         return {}
149     out = _call_brew("uninstall", *targets)
150     if out["retcode"] != 0 and out["stderr"]:
151         errors = [out["stderr"]]
152     else:
153         errors = []
154     __context__.pop("pkg.list_pkgs", None)
155     new = list_pkgs()
156     ret = salt.utils.data.compare_dicts(old, new)
157     if errors:
158         raise CommandExecutionError(
159             "Problem encountered removing package(s)",
160             info={"errors": errors, "changes": ret},
161         )
162     return ret
163 def refresh_db(**kwargs):
164     salt.utils.pkg.clear_rtag(__opts__)
165     if _call_brew("update")["retcode"]:
166         log.error("Failed to update")
167         return False
168     return True
169 def _info(*pkgs):
170     brew_result = _call_brew("info", "--json=v2", *pkgs)
171     if brew_result["retcode"]:
172         log.error("Failed to get info about packages: %s", " ".join(pkgs))
173         return {}
174     output = salt.utils.json.loads(brew_result["stdout"])
175     return dict(zip(pkgs, output["formulae"]))
176 def install(name=None, pkgs=None, taps=None, options=None, **kwargs):
177     try:
178         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
179             name, pkgs, kwargs.get("sources", {})
180         )
181     except MinionError as exc:
182         raise CommandExecutionError(exc)
183     if not pkg_params:
184         return {}
185     cmd = ["install"]
186     cmd.extend(list(pkg_params))
187     old = list_pkgs()
188     if taps:
189         if not isinstance(taps, list):
190             taps = [taps]
191         for tap in taps:
192             _tap(tap)
193     if options:
194         cmd.extend(options)
195     out = _call_brew(*cmd)
196     if out["retcode"] != 0 and out["stderr"]:
197         errors = [out["stderr"]]
198     else:
199         errors = []
200     __context__.pop("pkg.list_pkgs", None)
201     new = list_pkgs()
202     ret = salt.utils.data.compare_dicts(old, new)
203     if errors:
204         raise CommandExecutionError(
205             "Problem encountered installing package(s)",
206             info={"errors": errors, "changes": ret},
207         )
208     return ret
209 def list_upgrades(refresh=True, **kwargs):  # pylint: disable=W0613
210     if refresh:
211         refresh_db()
212     res = _call_brew("outdated", "--json=v2")
213     ret = {}
214     try:
215         data = salt.utils.json.loads(res["stdout"])["formulae"]
216     except ValueError as err:
217         msg = 'unable to interpret output from "brew outdated": {}'.format(err)
218         log.error(msg)
219         raise CommandExecutionError(msg)
220     for pkg in data:
221         ret[pkg["name"]] = pkg["current_version"]
222     return ret
223 def upgrade_available(pkg, **kwargs):
224     return pkg in list_upgrades()
225 def upgrade(refresh=True, **kwargs):
226     ret = {
227         "changes": {},
228         "result": True,
229         "comment": "",
230     }
231     old = list_pkgs()
232     if salt.utils.data.is_true(refresh):
233         refresh_db()
234     result = _call_brew("upgrade", failhard=False)
235     __context__.pop("pkg.list_pkgs", None)
236     new = list_pkgs()
237     ret = salt.utils.data.compare_dicts(old, new)
238     if result["retcode"] != 0:
239         raise CommandExecutionError(
240             "Problem encountered upgrading packages",
241             info={"changes": ret, "result": result},
242         )
243     return ret
244 def info_installed(*names, **kwargs):
245     return _info(*names)
246 def hold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
247     if not name and not pkgs and not sources:
248         raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
249     if pkgs and sources:
250         raise SaltInvocationError("Only one of pkgs or sources can be specified.")
251     targets = []
252     if pkgs:
253         targets.extend(pkgs)
254     elif sources:
255         for source in sources:
256             targets.append(next(iter(source)))
257     else:
258         targets.append(name)
259     ret = {}
260     pinned = _list_pinned()
261     installed = list_pkgs()
262     for target in targets:
263         if isinstance(target, dict):
264             target = next(iter(target))
265         ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
266         if target not in installed:
267             ret[target]["comment"] = "Package {} does not have a state.".format(target)
268         elif target not in pinned:
269             if "test" in __opts__ and __opts__["test"]:
270                 ret[target].update(result=None)
271                 ret[target]["comment"] = "Package {} is set to be held.".format(target)
272             else:
273                 result = _pin(target)
274                 if result:
275                     changes = {"old": "install", "new": "hold"}
276                     ret[target].update(changes=changes, result=True)
277                     ret[target]["comment"] = "Package {} is now being held.".format(
278                         target
279                     )
280                 else:
281                     ret[target].update(result=False)
282                     ret[target]["comment"] = "Unable to hold package {}.".format(target)
283         else:
284             ret[target].update(result=True)
285             ret[target]["comment"] = "Package {} is already set to be held.".format(
286                 target
287             )
288     return ret
289 pin = hold
290 def unhold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
291     if not name and not pkgs and not sources:
292         raise SaltInvocationError("One of name, pkgs, or sources must be specified.")
293     if pkgs and sources:
294         raise SaltInvocationError("Only one of pkgs or sources can be specified.")
295     targets = []
296     if pkgs:
297         targets.extend(pkgs)
298     elif sources:
299         for source in sources:
300             targets.append(next(iter(source)))
301     else:
302         targets.append(name)
303     ret = {}
304     pinned = _list_pinned()
305     installed = list_pkgs()
306     for target in targets:
307         if isinstance(target, dict):
308             target = next(iter(target))
309         ret[target] = {"name": target, "changes": {}, "result": False, "comment": ""}
310         if target not in installed:
311             ret[target]["comment"] = "Package {} does not have a state.".format(target)
312         elif target in pinned:
313             if "test" in __opts__ and __opts__["test"]:
314                 ret[target].update(result=None)
315                 ret[target]["comment"] = "Package {} is set to be unheld.".format(
316                     target
317                 )
318             else:
319                 result = _unpin(target)
320                 if result:
321                     changes = {"old": "hold", "new": "install"}
322                     ret[target].update(changes=changes, result=True)
323                     ret[target][
324                         "comment"
325                     ] = "Package {} is no longer being held.".format(target)
326                 else:
327                     ret[target].update(result=False)
328                     ret[target]["comment"] = "Unable to unhold package {}.".format(
329                         target
330                     )
331         else:
332             ret[target].update(result=True)
333             ret[target]["comment"] = "Package {} is already set not to be held.".format(
334                 target
335             )
336     return ret
337 unpin = unhold
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import datetime
3 import hashlib
4 import hmac
5 import io
6 import logging
7 import os
8 import pipes
9 import re
10 import tempfile
11 import salt.utils.files
12 import salt.utils.itertools
13 import salt.utils.odict
14 import salt.utils.path
15 import salt.utils.stringutils
16 from salt.exceptions import CommandExecutionError, SaltInvocationError
17 from salt.ext.saslprep import saslprep
18 from salt.utils.versions import LooseVersion as _LooseVersion
19 try:
20     import csv
21     HAS_CSV = True
22 except ImportError:
23     HAS_CSV = False
24 try:
25     from secrets import token_bytes
26 except ImportError:
27     from os import urandom as token_bytes
28 log = logging.getLogger(__name__)
29 _DEFAULT_PASSWORDS_ENCRYPTION = "md5"
30 _EXTENSION_NOT_INSTALLED = "EXTENSION NOT INSTALLED"
31 _EXTENSION_INSTALLED = "EXTENSION INSTALLED"
32 _EXTENSION_TO_UPGRADE = "EXTENSION TO UPGRADE"
33 _EXTENSION_TO_MOVE = "EXTENSION TO MOVE"
34 _EXTENSION_FLAGS = (
35     _EXTENSION_NOT_INSTALLED,
36     _EXTENSION_INSTALLED,
37     _EXTENSION_TO_UPGRADE,
38     _EXTENSION_TO_MOVE,
39 )
40 _PRIVILEGES_MAP = {
41     "a": "INSERT",
42     "C": "CREATE",
43     "D": "TRUNCATE",
44     "c": "CONNECT",
45     "t": "TRIGGER",
46     "r": "SELECT",
47     "U": "USAGE",
48     "T": "TEMPORARY",
49     "w": "UPDATE",
50     "X": "EXECUTE",
51     "x": "REFERENCES",
52     "d": "DELETE",
53     "*": "GRANT",
54 }
55 _PRIVILEGES_OBJECTS = frozenset(
56     (
57         "schema",
58         "tablespace",
59         "language",
60         "sequence",
61         "table",
62         "group",
63         "database",
64         "function",
65     )
66 )
67 _PRIVILEGE_TYPE_MAP = {
68     "table": "arwdDxt",
69     "tablespace": "C",
70     "language": "U",
71     "sequence": "rwU",
72     "schema": "UC",
73     "database": "CTc",
74     "function": "X",
75 }
76 def __virtual__():
77     utils = ["psql"]
78     if not HAS_CSV:
79         return False
80     for util in utils:
81         if not salt.utils.path.which(util):
82             if not _find_pg_binary(util):
83                 return (False, "{} was not found".format(util))
84     return True
85 def _find_pg_binary(util):
86     pg_bin_dir = __salt__["config.option"]("postgres.bins_dir")
87     util_bin = salt.utils.path.which(util)
88     if not util_bin:
89         if pg_bin_dir:
90             return salt.utils.path.which(os.path.join(pg_bin_dir, util))
91     else:
92         return util_bin
93 def _run_psql(cmd, runas=None, password=None, host=None, port=None, user=None):
94     kwargs = {
95         "reset_system_locale": False,
96         "clean_env": True,
97     }
98     if runas is None:
99         if not host:
100             host = __salt__["config.option"]("postgres.host")
101         if not host or host.startswith("/"):
102             if "FreeBSD" in __grains__["os_family"]:
103                 runas = "postgres"
104             elif "OpenBSD" in __grains__["os_family"]:
105                 runas = "_postgresql"
106             else:
107                 runas = "postgres"
108     if user is None:
109         user = runas
110     if runas:
111         kwargs["runas"] = runas
112     if password is None:
113         password = __salt__["config.option"]("postgres.pass")
114     if password is not None:
115         pgpassfile = salt.utils.files.mkstemp(text=True)
116         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
117             fp_.write(
118                 salt.utils.stringutils.to_str(
119                     "{}:{}:*:{}:{}".format(
120                         "localhost" if not host or host.startswith("/") else host,
121                         port if port else "*",
122                         user if user else "*",
123                         password,
124                     )
125                 )
126             )
127             __salt__["file.chown"](pgpassfile, runas, "")
128             kwargs["env"] = {"PGPASSFILE": pgpassfile}
129     ret = __salt__["cmd.run_all"](cmd, python_shell=False, **kwargs)
130     if ret.get("retcode", 0) != 0:
131         log.error("Error connecting to Postgresql server")
132     if password is not None and not __salt__["file.remove"](pgpassfile):
133         log.warning("Remove PGPASSFILE failed")
134     return ret
135 def _run_initdb(
136     name,
137     auth="password",
138     user=None,
139     password=None,
140     encoding="UTF8",
141     locale=None,
142     runas=None,
143     waldir=None,
144     checksums=False,
145 ):
146     if runas is None:
147         if "FreeBSD" in __grains__["os_family"]:
148             runas = "postgres"
149         elif "OpenBSD" in __grains__["os_family"]:
150             runas = "_postgresql"
151         else:
152             runas = "postgres"
153     if user is None:
154         user = runas
155     _INITDB_BIN = _find_pg_binary("initdb")
156     if not _INITDB_BIN:
157         raise CommandExecutionError("initdb executable not found.")
158     cmd = [
159         _INITDB_BIN,
160         "--pgdata={}".format(name),
161         "--username={}".format(user),
162         "--auth={}".format(auth),
163         "--encoding={}".format(encoding),
164     ]
165     if locale is not None:
166         cmd.append("--locale={}".format(locale))
167     if waldir is not None:
168         cmd.append("-X")
169         cmd.append(waldir)
170     if checksums:
171         cmd.append("--data-checksums")
172     if password is not None:
173         pgpassfile = salt.utils.files.mkstemp(text=True)
174         with salt.utils.files.fopen(pgpassfile, "w") as fp_:
175             fp_.write(salt.utils.stringutils.to_str("{}".format(password)))
176             __salt__["file.chown"](pgpassfile, runas, "")
177         cmd.extend(["--pwfile={}".format(pgpassfile)])
178     kwargs = dict(runas=runas, clean_env=True)
179     cmdstr = " ".join([pipes.quote(c) for c in cmd])
180     ret = __salt__["cmd.run_all"](cmdstr, python_shell=False, **kwargs)
181     if ret.get("retcode", 0) != 0:
182         log.error("Error initilizing the postgres data directory")
183     if password is not None and not __salt__["file.remove"](pgpassfile):
184         log.warning("Removal of PGPASSFILE failed")
185     return ret
186 def version(
187     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
188 ):
189     query = "SELECT setting FROM pg_catalog.pg_settings WHERE name = 'server_version'"
190     cmd = _psql_cmd(
191         "-c",
192         query,
193         "-t",
194         host=host,
195         user=user,
196         port=port,
197         maintenance_db=maintenance_db,
198         password=password,
199     )
200     ret = _run_psql(
201         cmd, runas=runas, password=password, host=host, port=port, user=user
202     )
203     for line in salt.utils.itertools.split(ret["stdout"], "\n"):
204         return line
205 def _parsed_version(
206     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
207 ):
208     psql_version = version(
209         user,
210         host=host,
211         port=port,
212         maintenance_db=maintenance_db,
213         password=password,
214         runas=runas,
215     )
216     if psql_version:
217         return _LooseVersion(psql_version)
218     else:
219         log.warning(
220             "Attempt to parse version of Postgres server failed. "
221             "Is the server responding?"
222         )
223         return None
224 def _connection_defaults(user=None, host=None, port=None, maintenance_db=None):
225     if not user:
226         user = __salt__["config.option"]("postgres.user")
227     if not host:
228         host = __salt__["config.option"]("postgres.host")
229     if not port:
230         port = __salt__["config.option"]("postgres.port")
231     if not maintenance_db:
232         maintenance_db = __salt__["config.option"]("postgres.maintenance_db")
233     return (user, host, port, maintenance_db)
234 def _psql_cmd(*args, **kwargs):
235     (user, host, port, maintenance_db) = _connection_defaults(
236         kwargs.get("user"),
237         kwargs.get("host"),
238         kwargs.get("port"),
239         kwargs.get("maintenance_db"),
240     )
241     _PSQL_BIN = _find_pg_binary("psql")
242     cmd = [
243         _PSQL_BIN,
244         "--no-align",
245         "--no-readline",
246         "--no-psqlrc",
247         "--no-password",
248     ]  # Never prompt, handled in _run_psql.
249     if user:
250         cmd += ["--username", user]
251     if host:
252         cmd += ["--host", host]
253     if port:
254         cmd += ["--port", str(port)]
255     if not maintenance_db:
256         maintenance_db = "postgres"
257     cmd.extend(["--dbname", maintenance_db])
258     cmd.extend(args)
259     return cmd
260 def _psql_prepare_and_run(
261     cmd, host=None, port=None, maintenance_db=None, password=None, runas=None, user=None
262 ):
263     rcmd = _psql_cmd(
264         host=host, user=user, port=port, maintenance_db=maintenance_db, *cmd
265     )
266     cmdret = _run_psql(
267         rcmd, runas=runas, password=password, host=host, port=port, user=user
268     )
269     return cmdret
270 def psql_query(
271     query,
272     user=None,
273     host=None,
274     port=None,
275     maintenance_db=None,
276     password=None,
277     runas=None,
278     write=False,
279 ):
280     ret = []
281     csv_query = "COPY ({}) TO STDOUT WITH CSV HEADER".format(query.strip().rstrip(";"))
282     if write:
283         csv_query = "START TRANSACTION READ WRITE; {}; COMMIT TRANSACTION;".format(
284             csv_query
285         )
286     cmdret = _psql_prepare_and_run(
287         ["-v", "datestyle=ISO,MDY", "-c", csv_query],
288         runas=runas,
289         host=host,
290         user=user,
291         port=port,
292         maintenance_db=maintenance_db,
293         password=password,
294     )
295     if cmdret["retcode"] &gt; 0:
296         return ret
297     csv_file = io.StringIO(cmdret["stdout"])
298     header = {}
299     for row in csv.reader(
300         csv_file,
301         delimiter=salt.utils.stringutils.to_str(","),
302         quotechar=salt.utils.stringutils.to_str('"'),
303     ):
304         if not row:
305             continue
306         if not header:
307             header = row
308             continue
309         ret.append(dict(zip(header, row)))
310     if write:
311         ret = ret[0:-1]
312     return ret
313 def db_list(
314     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
315 ):
316     ret = {}
317     query = (
318         'SELECT datname as "Name", pga.rolname as "Owner", '
319         'pg_encoding_to_char(encoding) as "Encoding", '
320         'datcollate as "Collate", datctype as "Ctype", '
321         'datacl as "Access privileges", spcname as "Tablespace" '
322         "FROM pg_database pgd, pg_roles pga, pg_tablespace pgts "
323         "WHERE pga.oid = pgd.datdba AND pgts.oid = pgd.dattablespace"
324     )
325     rows = psql_query(
326         query,
327         runas=runas,
328         host=host,
329         user=user,
330         port=port,
331         maintenance_db=maintenance_db,
332         password=password,
333     )
334     for row in rows:
335         ret[row["Name"]] = row
336         ret[row["Name"]].pop("Name")
337     return ret
338 def db_exists(
339     name,
340     user=None,
341     host=None,
342     port=None,
343     maintenance_db=None,
344     password=None,
345     runas=None,
346 ):
347     databases = db_list(
348         user=user,
349         host=host,
350         port=port,
351         maintenance_db=maintenance_db,
352         password=password,
353         runas=runas,
354     )
355     return name in databases
356 def _quote_ddl_value(value, quote="'"):
357     if value is None:
358         return None
359     if quote in value:  # detect trivial sqli
360         raise SaltInvocationError(
361             "Unsupported character {} in value: {}".format(quote, value)
362         )
363     return "{quote}{value}{quote}".format(quote=quote, value=value)
364 def db_create(
365     name,
366     user=None,
367     host=None,
368     port=None,
369     maintenance_db=None,
370     password=None,
371     tablespace=None,
372     encoding=None,
373     lc_collate=None,
374     lc_ctype=None,
375     owner=None,
376     template=None,
377     runas=None,
378 ):
379     query = 'CREATE DATABASE "{}"'.format(name)
380     with_args = salt.utils.odict.OrderedDict(
381         [
382             ("TABLESPACE", _quote_ddl_value(tablespace, '"')),
383             ("OWNER", _quote_ddl_value(owner, '"')),
384             ("TEMPLATE", template),
385             ("ENCODING", _quote_ddl_value(encoding)),
386             ("LC_COLLATE", _quote_ddl_value(lc_collate)),
387             ("LC_CTYPE", _quote_ddl_value(lc_ctype)),
388         ]
389     )
390     with_chunks = []
391     for key, value in with_args.items():
392         if value is not None:
393             with_chunks += [key, "=", value]
394     if with_chunks:
395         with_chunks.insert(0, " WITH")
396         query += " ".join(with_chunks)
397     ret = _psql_prepare_and_run(
398         ["-c", query],
399         user=user,
400         host=host,
401         port=port,
402         maintenance_db=maintenance_db,
403         password=password,
404         runas=runas,
405     )
406     return ret["retcode"] == 0
407 def db_alter(
408     name,
409     user=None,
410     host=None,
411     port=None,
412     maintenance_db=None,
413     password=None,
414     tablespace=None,
415     owner=None,
416     owner_recurse=False,
417     runas=None,
418 ):
419     if not any((tablespace, owner)):
420         return True  # Nothing todo?
421     if owner and owner_recurse:
422         ret = owner_to(
423             name, owner, user=user, host=host, port=port, password=password, runas=runas
424         )
425     else:
426         queries = []
427         if owner:
428             queries.append('ALTER DATABASE "{}" OWNER TO "{}"'.format(name, owner))
429         if tablespace:
430             queries.append(
431                 'ALTER DATABASE "{}" SET TABLESPACE "{}"'.format(name, tablespace)
432             )
433         for query in queries:
434             ret = _psql_prepare_and_run(
435                 ["-c", query],
436                 user=user,
437                 host=host,
438                 port=port,
439                 maintenance_db=maintenance_db,
440                 password=password,
441                 runas=runas,
442             )
443     if ret["retcode"] != 0:
444         return False
445     return True
446 def db_remove(
447     name,
448     user=None,
449     host=None,
450     port=None,
451     maintenance_db=None,
452     password=None,
453     runas=None,
454 ):
455     for query in [
456         'REVOKE CONNECT ON DATABASE "{db}" FROM public;'.format(db=name),
457         "SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname ="
458         " '{db}' AND pid &lt;&gt; pg_backend_pid();".format(db=name),
459         'DROP DATABASE "{db}";'.format(db=name),
460     ]:
461         ret = _psql_prepare_and_run(
462             ["-c", query],
463             user=user,
464             host=host,
465             port=port,
466             runas=runas,
467             maintenance_db=maintenance_db,
468             password=password,
469         )
470         if ret["retcode"] != 0:
471             raise Exception("Failed: ret={}".format(ret))
472     return True
473 def tablespace_list(
474     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
475 ):
476     ret = {}
477     query = (
478         'SELECT spcname as "Name", pga.rolname as "Owner", spcacl as "ACL", '
479         'spcoptions as "Opts", pg_tablespace_location(pgts.oid) as "Location" '
480         "FROM pg_tablespace pgts, pg_roles pga WHERE pga.oid = pgts.spcowner"
481     )
482     rows = __salt__["postgres.psql_query"](
483         query,
484         runas=runas,
485         host=host,
486         user=user,
487         port=port,
488         maintenance_db=maintenance_db,
489         password=password,
490     )
491     for row in rows:
492         ret[row["Name"]] = row
493         ret[row["Name"]].pop("Name")
494     return ret
495 def tablespace_exists(
496     name,
497     user=None,
498     host=None,
499     port=None,
500     maintenance_db=None,
501     password=None,
502     runas=None,
503 ):
504     tablespaces = tablespace_list(
505         user=user,
506         host=host,
507         port=port,
508         maintenance_db=maintenance_db,
509         password=password,
510         runas=runas,
511     )
512     return name in tablespaces
513 def tablespace_create(
514     name,
515     location,
516     options=None,
517     owner=None,
518     user=None,
519     host=None,
520     port=None,
521     maintenance_db=None,
522     password=None,
523     runas=None,
524 ):
525     owner_query = ""
526     options_query = ""
527     if owner:
528         owner_query = 'OWNER "{}"'.format(owner)
529     if options:
530         optionstext = ["{} = {}".format(k, v) for k, v in options.items()]
531         options_query = "WITH ( {} )".format(", ".join(optionstext))
532     query = "CREATE TABLESPACE \"{}\" {} LOCATION '{}' {}".format(
533         name, owner_query, location, options_query
534     )
535     ret = _psql_prepare_and_run(
536         ["-c", query],
537         user=user,
538         host=host,
539         port=port,
540         maintenance_db=maintenance_db,
541         password=password,
542         runas=runas,
543     )
544     return ret["retcode"] == 0
545 def tablespace_alter(
546     name,
547     user=None,
548     host=None,
549     port=None,
550     maintenance_db=None,
551     password=None,
552     new_name=None,
553     new_owner=None,
554     set_option=None,
555     reset_option=None,
556     runas=None,
557 ):
558     if not any([new_name, new_owner, set_option, reset_option]):
559         return True  # Nothing todo?
560     queries = []
561     if new_name:
562         queries.append('ALTER TABLESPACE "{}" RENAME TO "{}"'.format(name, new_name))
563     if new_owner:
564         queries.append('ALTER TABLESPACE "{}" OWNER TO "{}"'.format(name, new_owner))
565     if set_option:
566         queries.append(
567             'ALTER TABLESPACE "{}" SET ({} = {})'.format(
568                 name, *(next(iter(set_option.items())))
569             )
570         )
571     if reset_option:
572         queries.append('ALTER TABLESPACE "{}" RESET ({})'.format(name, reset_option))
573     for query in queries:
574         ret = _psql_prepare_and_run(
575             ["-c", query],
576             user=user,
577             host=host,
578             port=port,
579             maintenance_db=maintenance_db,
580             password=password,
581             runas=runas,
582         )
583         if ret["retcode"] != 0:
584             return False
585     return True
586 def tablespace_remove(
587     name,
588     user=None,
589     host=None,
590     port=None,
591     maintenance_db=None,
592     password=None,
593     runas=None,
594 ):
595     query = 'DROP TABLESPACE "{}"'.format(name)
596     ret = _psql_prepare_and_run(
597         ["-c", query],
598         user=user,
599         host=host,
600         port=port,
601         runas=runas,
602         maintenance_db=maintenance_db,
603         password=password,
604     )
605     return ret["retcode"] == 0
606 def user_list(
607     user=None,
608     host=None,
609     port=None,
610     maintenance_db=None,
611     password=None,
612     runas=None,
613     return_password=False,
614 ):
615     ret = {}
616     ver = _parsed_version(
617         user=user,
618         host=host,
619         port=port,
620         maintenance_db=maintenance_db,
621         password=password,
622         runas=runas,
623     )
624     if ver:
625         if ver &gt;= _LooseVersion("9.1"):
626             replication_column = "pg_roles.rolreplication"
627         else:
628             replication_column = "NULL"
629         if ver &gt;= _LooseVersion("9.5"):
630             rolcatupdate_column = "NULL"
631         else:
632             rolcatupdate_column = "pg_roles.rolcatupdate"
633     else:
634         log.error("Could not retrieve Postgres version. Is Postgresql server running?")
635         return False
636     _x = lambda s: s if return_password else ""
637     query = "".join(
638         [
639             'SELECT pg_roles.rolname as "name",pg_roles.rolsuper as "superuser",'
640             ' pg_roles.rolinherit as "inherits privileges", pg_roles.rolcreaterole as'
641             ' "can create roles", pg_roles.rolcreatedb as "can create databases", {0}'
642             ' as "can update system catalogs", pg_roles.rolcanlogin as "can login", {1}'
643             ' as "replication", pg_roles.rolconnlimit as "connections", (SELECT'
644             " array_agg(pg_roles2.rolname)    FROM pg_catalog.pg_auth_members    JOIN"
645             " pg_catalog.pg_roles pg_roles2 ON (pg_auth_members.roleid = pg_roles2.oid)"
646             "    WHERE pg_auth_members.member = pg_roles.oid) as"
647             ' "groups",pg_roles.rolvaliduntil::timestamp(0) as "expiry time",'
648             ' pg_roles.rolconfig  as "defaults variables" ',
649             _x(', COALESCE(pg_shadow.passwd, pg_authid.rolpassword) as "password" '),
650             "FROM pg_roles ",
651             _x("LEFT JOIN pg_authid ON pg_roles.oid = pg_authid.oid "),
652             _x("LEFT JOIN pg_shadow ON pg_roles.oid = pg_shadow.usesysid"),
653         ]
654     ).format(rolcatupdate_column, replication_column)
655     rows = psql_query(
656         query,
657         runas=runas,
658         host=host,
659         user=user,
660         port=port,
661         maintenance_db=maintenance_db,
662         password=password,
663     )
664     def get_bool(rowdict, key):
665         if rowdict[key] == "t":
666             return True
667         elif rowdict[key] == "f":
668             return False
669         else:
670             return None
671     for row in rows:
672         retrow = {}
673         for key in (
674             "superuser",
675             "inherits privileges",
676             "can create roles",
677             "can create databases",
678             "can update system catalogs",
679             "can login",
680             "replication",
681             "connections",
682         ):
683             retrow[key] = get_bool(row, key)
684         for date_key in ("expiry time",):
685             try:
686                 retrow[date_key] = datetime.datetime.strptime(
687                     row[date_key], "%Y-%m-%d %H:%M:%S"
688                 )
689             except ValueError:
690                 retrow[date_key] = None
691         retrow["defaults variables"] = row["defaults variables"]
692         if return_password:
693             retrow["password"] = row["password"]
694         retrow["groups"] = list(csv.reader([row["groups"].strip("{}")]))[0]
695         ret[row["name"]] = retrow
696     return ret
697 def role_get(
698     name,
699     user=None,
700     host=None,
701     port=None,
702     maintenance_db=None,
703     password=None,
704     runas=None,
705     return_password=False,
706 ):
707     all_users = user_list(
708         user=user,
709         host=host,
710         port=port,
711         maintenance_db=maintenance_db,
712         password=password,
713         runas=runas,
714         return_password=return_password,
715     )
716     try:
717         return all_users.get(name, None)
718     except AttributeError:
719         log.error("Could not retrieve Postgres role. Is Postgres running?")
720         return None
721 def user_exists(
722     name,
723     user=None,
724     host=None,
725     port=None,
726     maintenance_db=None,
727     password=None,
728     runas=None,
729 ):
730     return bool(
731         role_get(
732             name,
733             user=user,
734             host=host,
735             port=port,
736             maintenance_db=maintenance_db,
737             password=password,
738             runas=runas,
739             return_password=False,
740         )
741     )
742 def _add_role_flag(string, test, flag, cond=None, prefix="NO", addtxt="", skip=False):
743     if not skip:
744         if cond is None:
745             cond = test
746         if test is not None:
747             if cond:
748                 string = "{} {}".format(string, flag)
749             else:
750                 string = "{0} {2}{1}".format(string, flag, prefix)
751         if addtxt:
752             string = "{} {}".format(string, addtxt)
753     return string
754 def _maybe_encrypt_password(role, password, encrypted=_DEFAULT_PASSWORDS_ENCRYPTION):
755     if password is not None:
756         password = str(password)
757     else:
758         return None
759     if encrypted is True:
760         encrypted = "md5"
761     if encrypted not in (False, "md5", "scram-sha-256"):
762         raise ValueError("Unknown password algorithm: " + str(encrypted))
763     if encrypted == "scram-sha-256" and not password.startswith("SCRAM-SHA-256"):
764         password = _scram_sha_256(password)
765     elif encrypted == "md5" and not password.startswith("md5"):
766         log.warning("The md5 password algorithm was deprecated in PostgreSQL 10")
767         password = _md5_password(role, password)
768     elif encrypted is False:
769         log.warning("Unencrypted passwords were removed in PostgreSQL 10")
770     return password
771 def _verify_password(role, password, verifier, method):
772     if method == "md5" or method is True:
773         if password.startswith("md5"):
774             expected = password
775         else:
776             expected = _md5_password(role, password)
777     elif method == "scram-sha-256":
778         if password.startswith("SCRAM-SHA-256"):
779             expected = password
780         else:
781             match = re.match(r"^SCRAM-SHA-256\$(\d+):([^\$]+?)\$", verifier)
782             if match:
783                 iterations = int(match.group(1))
784                 salt_bytes = base64.b64decode(match.group(2))
785                 expected = _scram_sha_256(
786                     password, salt_bytes=salt_bytes, iterations=iterations
787                 )
788             else:
789                 expected = object()
790     elif method is False:
791         expected = password
792     else:
793         expected = object()
794     return verifier == expected
795 def _md5_password(role, password):
796     return "md5{}".format(
797         hashlib.md5(
798             salt.utils.stringutils.to_bytes("{}{}".format(password, role))
799         ).hexdigest()
800     )
801 def _scram_sha_256(password, salt_bytes=None, iterations=4096):
802     if salt_bytes is None:
803         salt_bytes = token_bytes<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(16)
804     password = salt.utils.stringutils.to_bytes(saslprep(password))
805     salted_password = hashlib.pbkdf2_hmac("sha256", password, salt_bytes, iterations)
806     stored_key =</b></font> hmac.new(salted_password, b"Client Key", "sha256").digest()
807     stored_key = hashlib.sha256(stored_key).digest()
808     server_key = hmac.new(salted_password, b"Server Key", "sha256").digest()
809     return "SCRAM-SHA-256${}:{}${}:{}".format(
810         iterations,
811         base64.b64encode(salt_bytes).decode("ascii"),
812         base64.b64encode(stored_key).decode("ascii"),
813         base64.b64encode(server_key).decode("ascii"),
814     )
815 def _role_cmd_args(
816     name,
817     sub_cmd="",
818     typ_="role",
819     encrypted=None,
820     login=None,
821     connlimit=None,
822     inherit=None,
823     createdb=None,
824     createroles=None,
825     superuser=None,
826     groups=None,
827     replication=None,
828     rolepassword=None,
829     valid_until=None,
830     db_role=None,
831 ):
832     if inherit is None:
833         if typ_ in ["user", "group"]:
834             inherit = True
835     if login is None:
836         if typ_ == "user":
837             login = True
838         if typ_ == "group":
839             login = False
840     if encrypted is None:
841         encrypted = _DEFAULT_PASSWORDS_ENCRYPTION
842     skip_passwd = False
843     escaped_password = ""
844     escaped_valid_until = ""
845     if not (
846         rolepassword is not None
847         and (isinstance(rolepassword, str) and bool(rolepassword))
848         or (isinstance(rolepassword, bool))
849     ):
850         skip_passwd = True
851     if isinstance(rolepassword, str) and bool(rolepassword):
852         escaped_password = "'{}'".format(
853             _maybe_encrypt_password(
854                 name, rolepassword.replace("'", "''"), encrypted=encrypted
855             )
856         )
857     if isinstance(valid_until, str) and bool(valid_until):
858         escaped_valid_until = "'{}'".format(
859             valid_until.replace("'", "''"),
860         )
861     skip_superuser = False
862     if bool(db_role) and bool(superuser) == bool(db_role["superuser"]):
863         skip_superuser = True
864     flags = (
865         {"flag": "INHERIT", "test": inherit},
866         {"flag": "CREATEDB", "test": createdb},
867         {"flag": "CREATEROLE", "test": createroles},
868         {"flag": "SUPERUSER", "test": superuser, "skip": skip_superuser},
869         {"flag": "REPLICATION", "test": replication},
870         {"flag": "LOGIN", "test": login},
871         {
872             "flag": "CONNECTION LIMIT",
873             "test": bool(connlimit),
874             "addtxt": str(connlimit),
875             "skip": connlimit is None,
876         },
877         {
878             "flag": "ENCRYPTED",
879             "test": (encrypted is not None and bool(rolepassword)),
880             "skip": skip_passwd or isinstance(rolepassword, bool),
881             "cond": bool(encrypted),
882             "prefix": "UN",
883         },
884         {
885             "flag": "PASSWORD",
886             "test": bool(rolepassword),
887             "skip": skip_passwd,
888             "addtxt": escaped_password,
889         },
890         {
891             "flag": "VALID UNTIL",
892             "test": bool(valid_until),
893             "skip": valid_until is None,
894             "addtxt": escaped_valid_until,
895         },
896     )
897     for data in flags:
898         sub_cmd = _add_role_flag(sub_cmd, **data)
899     if sub_cmd.endswith("WITH"):
900         sub_cmd = sub_cmd.replace(" WITH", "")
901     if groups:
902         if isinstance(groups, list):
903             groups = ",".join(groups)
904         for group in groups.split(","):
905             sub_cmd = '{}; GRANT "{}" TO "{}"'.format(sub_cmd, group, name)
906     return sub_cmd
907 def _role_create(
908     name,
909     user=None,
910     host=None,
911     port=None,
912     maintenance_db=None,
913     password=None,
914     createdb=None,
915     createroles=None,
916     encrypted=None,
917     superuser=None,
918     login=None,
919     connlimit=None,
920     inherit=None,
921     replication=None,
922     rolepassword=None,
923     valid_until=None,
924     typ_="role",
925     groups=None,
926     runas=None,
927 ):
928     if user_exists(
929         name, user, host, port, maintenance_db, password=password, runas=runas
930     ):
931         log.info("%s '%s' already exists", typ_.capitalize(), name)
932         return False
933     sub_cmd = 'CREATE ROLE "{}" WITH'.format(name)
934     sub_cmd = "{} {}".format(
935         sub_cmd,
936         _role_cmd_args(
937             name,
938             typ_=typ_,
939             encrypted=encrypted,
940             login=login,
941             connlimit=connlimit,
942             inherit=inherit,
943             createdb=createdb,
944             createroles=createroles,
945             superuser=superuser,
946             groups=groups,
947             replication=replication,
948             rolepassword=rolepassword,
949             valid_until=valid_until,
950         ),
951     )
952     ret = _psql_prepare_and_run(
953         ["-c", sub_cmd],
954         runas=runas,
955         host=host,
956         user=user,
957         port=port,
958         maintenance_db=maintenance_db,
959         password=password,
960     )
961     return ret["retcode"] == 0
962 def user_create(
963     username,
964     user=None,
965     host=None,
966     port=None,
967     maintenance_db=None,
968     password=None,
969     createdb=None,
970     createroles=None,
971     inherit=None,
972     login=None,
973     connlimit=None,
974     encrypted=None,
975     superuser=None,
976     replication=None,
977     rolepassword=None,
978     valid_until=None,
979     groups=None,
980     runas=None,
981 ):
982     return _role_create(
983         username,
984         typ_="user",
985         user=user,
986         host=host,
987         port=port,
988         maintenance_db=maintenance_db,
989         password=password,
990         createdb=createdb,
991         createroles=createroles,
992         inherit=inherit,
993         login=login,
994         connlimit=connlimit,
995         encrypted=encrypted,
996         superuser=superuser,
997         replication=replication,
998         rolepassword=rolepassword,
999         valid_until=valid_until,
1000         groups=groups,
1001         runas=runas,
1002     )
1003 def _role_update(
1004     name,
1005     user=None,
1006     host=None,
1007     port=None,
1008     maintenance_db=None,
1009     password=None,
1010     createdb=None,
1011     typ_="role",
1012     createroles=None,
1013     inherit=None,
1014     login=None,
1015     connlimit=None,
1016     encrypted=None,
1017     superuser=None,
1018     replication=None,
1019     rolepassword=None,
1020     valid_until=None,
1021     groups=None,
1022     runas=None,
1023 ):
1024     role = role_get(
1025         name,
1026         user=user,
1027         host=host,
1028         port=port,
1029         maintenance_db=maintenance_db,
1030         password=password,
1031         runas=runas,
1032         return_password=False,
1033     )
1034     if not bool(role):
1035         log.info("%s '%s' could not be found", typ_.capitalize(), name)
1036         return False
1037     sub_cmd = 'ALTER ROLE "{}" WITH'.format(name)
1038     sub_cmd = "{} {}".format(
1039         sub_cmd,
1040         _role_cmd_args(
1041             name,
1042             encrypted=encrypted,
1043             login=login,
1044             connlimit=connlimit,
1045             inherit=inherit,
1046             createdb=createdb,
1047             createroles=createroles,
1048             superuser=superuser,
1049             groups=groups,
1050             replication=replication,
1051             rolepassword=rolepassword,
1052             valid_until=valid_until,
1053             db_role=role,
1054         ),
1055     )
1056     ret = _psql_prepare_and_run(
1057         ["-c", sub_cmd],
1058         runas=runas,
1059         host=host,
1060         user=user,
1061         port=port,
1062         maintenance_db=maintenance_db,
1063         password=password,
1064     )
1065     return ret["retcode"] == 0
1066 def user_update(
1067     username,
1068     user=None,
1069     host=None,
1070     port=None,
1071     maintenance_db=None,
1072     password=None,
1073     createdb=None,
1074     createroles=None,
1075     encrypted=None,
1076     superuser=None,
1077     inherit=None,
1078     login=None,
1079     connlimit=None,
1080     replication=None,
1081     rolepassword=None,
1082     valid_until=None,
1083     groups=None,
1084     runas=None,
1085 ):
1086     return _role_update(
1087         username,
1088         user=user,
1089         host=host,
1090         port=port,
1091         maintenance_db=maintenance_db,
1092         password=password,
1093         typ_="user",
1094         inherit=inherit,
1095         login=login,
1096         connlimit=connlimit,
1097         createdb=createdb,
1098         createroles=createroles,
1099         encrypted=encrypted,
1100         superuser=superuser,
1101         replication=replication,
1102         rolepassword=rolepassword,
1103         valid_until=valid_until,
1104         groups=groups,
1105         runas=runas,
1106     )
1107 def _role_remove(
1108     name,
1109     user=None,
1110     host=None,
1111     port=None,
1112     maintenance_db=None,
1113     password=None,
1114     runas=None,
1115 ):
1116     if not user_exists(
1117         name, user, host, port, maintenance_db, password=password, runas=runas
1118     ):
1119         log.info("User '%s' does not exist", name)
1120         return False
1121     sub_cmd = 'DROP ROLE "{}"'.format(name)
1122     _psql_prepare_and_run(
1123         ["-c", sub_cmd],
1124         runas=runas,
1125         host=host,
1126         user=user,
1127         port=port,
1128         maintenance_db=maintenance_db,
1129         password=password,
1130     )
1131     if not user_exists(
1132         name, user, host, port, maintenance_db, password=password, runas=runas
1133     ):
1134         return True
1135     else:
1136         log.info("Failed to delete user '%s'.", name)
1137         return False
1138 def available_extensions(
1139     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1140 ):
1141     exts = []
1142     query = "select * from pg_available_extensions();"
1143     ret = psql_query(
1144         query,
1145         user=user,
1146         host=host,
1147         port=port,
1148         maintenance_db=maintenance_db,
1149         password=password,
1150         runas=runas,
1151     )
1152     exts = {}
1153     for row in ret:
1154         if "default_version" in row and "name" in row:
1155             exts[row["name"]] = row
1156     return exts
1157 def installed_extensions(
1158     user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
1159 ):
1160     exts = []
1161     query = (
1162         "select a.*, b.nspname as schema_name "
1163         "from pg_extension a,  pg_namespace b where a.extnamespace = b.oid;"
1164     )
1165     ret = psql_query(
1166         query,
1167         user=user,
1168         host=host,
1169         port=port,
1170         maintenance_db=maintenance_db,
1171         password=password,
1172         runas=runas,
1173     )
1174     exts = {}
1175     for row in ret:
1176         if "extversion" in row and "extname" in row:
1177             exts[row["extname"]] = row
1178     return exts
1179 def get_available_extension(
1180     name,
1181     user=None,
1182     host=None,
1183     port=None,
1184     maintenance_db=None,
1185     password=None,
1186     runas=None,
1187 ):
1188     return available_extensions(
1189         user=user,
1190         host=host,
1191         port=port,
1192         maintenance_db=maintenance_db,
1193         password=password,
1194         runas=runas,
1195     ).get(name, None)
1196 def get_installed_extension(
1197     name,
1198     user=None,
1199     host=None,
1200     port=None,
1201     maintenance_db=None,
1202     password=None,
1203     runas=None,
1204 ):
1205     return installed_extensions(
1206         user=user,
1207         host=host,
1208         port=port,
1209         maintenance_db=maintenance_db,
1210         password=password,
1211         runas=runas,
1212     ).get(name, None)
1213 def is_available_extension(
1214     name,
1215     user=None,
1216     host=None,
1217     port=None,
1218     maintenance_db=None,
1219     password=None,
1220     runas=None,
1221 ):
1222     exts = available_extensions(
1223         user=user,
1224         host=host,
1225         port=port,
1226         maintenance_db=maintenance_db,
1227         password=password,
1228         runas=runas,
1229     )
1230     if name.lower() in [a.lower() for a in exts]:
1231         return True
1232     return False
1233 def _pg_is_older_ext_ver(a, b):
1234     return _LooseVersion(a) &lt; _LooseVersion(b)
1235 def is_installed_extension(
1236     name,
1237     user=None,
1238     host=None,
1239     port=None,
1240     maintenance_db=None,
1241     password=None,
1242     runas=None,
1243 ):
1244     installed_ext = get_installed_extension(
1245         name,
1246         user=user,
1247         host=host,
1248         port=port,
1249         maintenance_db=maintenance_db,
1250         password=password,
1251         runas=runas,
1252     )
1253     return bool(installed_ext)
1254 def create_metadata(
1255     name,
1256     ext_version=None,
1257     schema=None,
1258     user=None,
1259     host=None,
1260     port=None,
1261     maintenance_db=None,
1262     password=None,
1263     runas=None,
1264 ):
1265     installed_ext = get_installed_extension(
1266         name,
1267         user=user,
1268         host=host,
1269         port=port,
1270         maintenance_db=maintenance_db,
1271         password=password,
1272         runas=runas,
1273     )
1274     ret = [_EXTENSION_NOT_INSTALLED]
1275     if installed_ext:
1276         ret = [_EXTENSION_INSTALLED]
1277         if ext_version is not None and _pg_is_older_ext_ver(
1278             installed_ext.get("extversion", ext_version), ext_version
1279         ):
1280             ret.append(_EXTENSION_TO_UPGRADE)
1281         if (
1282             schema is not None
1283             and installed_ext.get("extrelocatable", "f") == "t"
1284             and installed_ext.get("schema_name", schema) != schema
1285         ):
1286             ret.append(_EXTENSION_TO_MOVE)
1287     return ret
1288 def drop_extension(
1289     name,
1290     if_exists=None,
1291     restrict=None,
1292     cascade=None,
1293     user=None,
1294     host=None,
1295     port=None,
1296     maintenance_db=None,
1297     password=None,
1298     runas=None,
1299 ):
1300     if cascade is None:
1301         cascade = True
1302     if if_exists is None:
1303         if_exists = False
1304     if restrict is None:
1305         restrict = False
1306     args = ["DROP EXTENSION"]
1307     if if_exists:
1308         args.append("IF EXISTS")
1309     args.append(name)
1310     if cascade:
1311         args.append("CASCADE")
1312     if restrict:
1313         args.append("RESTRICT")
1314     args.append(";")
1315     cmd = " ".join(args)
1316     if is_installed_extension(
1317         name,
1318         user=user,
1319         host=host,
1320         port=port,
1321         maintenance_db=maintenance_db,
1322         password=password,
1323         runas=runas,
1324     ):
1325         _psql_prepare_and_run(
1326             ["-c", cmd],
1327             runas=runas,
1328             host=host,
1329             user=user,
1330             port=port,
1331             maintenance_db=maintenance_db,
1332             password=password,
1333         )
1334     ret = not is_installed_extension(
1335         name,
1336         user=user,
1337         host=host,
1338         port=port,
1339         maintenance_db=maintenance_db,
1340         password=password,
1341         runas=runas,
1342     )
1343     if not ret:
1344         log.info("Failed to drop ext: %s", name)
1345     return ret
1346 def create_extension(
1347     name,
1348     if_not_exists=None,
1349     schema=None,
1350     ext_version=None,
1351     from_version=None,
1352     user=None,
1353     host=None,
1354     port=None,
1355     maintenance_db=None,
1356     password=None,
1357     runas=None,
1358 ):
1359     if if_not_exists is None:
1360         if_not_exists = True
1361     mtdata = create_metadata(
1362         name,
1363         ext_version=ext_version,
1364         schema=schema,
1365         user=user,
1366         host=host,
1367         port=port,
1368         maintenance_db=maintenance_db,
1369         password=password,
1370         runas=runas,
1371     )
1372     installed = _EXTENSION_NOT_INSTALLED not in mtdata
1373     installable = is_available_extension(
1374         name,
1375         user=user,
1376         host=host,
1377         port=port,
1378         maintenance_db=maintenance_db,
1379         password=password,
1380         runas=runas,
1381     )
1382     if installable:
1383         if not installed:
1384             args = ["CREATE EXTENSION"]
1385             if if_not_exists:
1386                 args.append("IF NOT EXISTS")
1387             args.append('"{}"'.format(name))
1388             sargs = []
1389             if schema:
1390                 sargs.append('SCHEMA "{}"'.format(schema))
1391             if ext_version:
1392                 sargs.append("VERSION {}".format(ext_version))
1393             if from_version:
1394                 sargs.append("FROM {}".format(from_version))
1395             if sargs:
1396                 args.append("WITH")
1397                 args.extend(sargs)
1398             args.append(";")
1399             cmd = " ".join(args).strip()
1400         else:
1401             args = []
1402             if schema and _EXTENSION_TO_MOVE in mtdata:
1403                 args.append(
1404                     'ALTER EXTENSION "{}" SET SCHEMA "{}";'.format(name, schema)
1405                 )
1406             if ext_version and _EXTENSION_TO_UPGRADE in mtdata:
1407                 args.append(
1408                     'ALTER EXTENSION "{}" UPDATE TO {};'.format(name, ext_version)
1409                 )
1410             cmd = " ".join(args).strip()
1411         if cmd:
1412             _psql_prepare_and_run(
1413                 ["-c", cmd],
1414                 runas=runas,
1415                 host=host,
1416                 user=user,
1417                 port=port,
1418                 maintenance_db=maintenance_db,
1419                 password=password,
1420             )
1421     mtdata = create_metadata(
1422         name,
1423         ext_version=ext_version,
1424         schema=schema,
1425         user=user,
1426         host=host,
1427         port=port,
1428         maintenance_db=maintenance_db,
1429         password=password,
1430         runas=runas,
1431     )
1432     ret = True
1433     for i in _EXTENSION_FLAGS:
1434         if (i in mtdata) and (i != _EXTENSION_INSTALLED):
1435             ret = False
1436     if not ret:
1437         log.info("Failed to create ext: %s", name)
1438     return ret
1439 def user_remove(
1440     username,
1441     user=None,
1442     host=None,
1443     port=None,
1444     maintenance_db=None,
1445     password=None,
1446     runas=None,
1447 ):
1448     return _role_remove(
1449         username,
1450         user=user,
1451         host=host,
1452         port=port,
1453         maintenance_db=maintenance_db,
1454         password=password,
1455         runas=runas,
1456     )
1457 def group_create(
1458     groupname,
1459     user=None,
1460     host=None,
1461     port=None,
1462     maintenance_db=None,
1463     password=None,
1464     createdb=None,
1465     createroles=None,
1466     encrypted=None,
1467     login=None,
1468     inherit=None,
1469     superuser=None,
1470     replication=None,
1471     rolepassword=None,
1472     groups=None,
1473     runas=None,
1474 ):
1475     return _role_create(
1476         groupname,
1477         user=user,
1478         typ_="group",
1479         host=host,
1480         port=port,
1481         maintenance_db=maintenance_db,
1482         password=password,
1483         createdb=createdb,
1484         createroles=createroles,
1485         encrypted=encrypted,
1486         login=login,
1487         inherit=inherit,
1488         superuser=superuser,
1489         replication=replication,
1490         rolepassword=rolepassword,
1491         groups=groups,
1492         runas=runas,
1493     )
1494 def group_update(
1495     groupname,
1496     user=None,
1497     host=None,
1498     port=None,
1499     maintenance_db=None,
1500     password=None,
1501     createdb=None,
1502     createroles=None,
1503     encrypted=None,
1504     inherit=None,
1505     login=None,
1506     superuser=None,
1507     replication=None,
1508     rolepassword=None,
1509     groups=None,
1510     runas=None,
1511 ):
1512     return _role_update(
1513         groupname,
1514         user=user,
1515         host=host,
1516         port=port,
1517         maintenance_db=maintenance_db,
1518         password=password,
1519         createdb=createdb,
1520         typ_="group",
1521         createroles=createroles,
1522         encrypted=encrypted,
1523         login=login,
1524         inherit=inherit,
1525         superuser=superuser,
1526         replication=replication,
1527         rolepassword=rolepassword,
1528         groups=groups,
1529         runas=runas,
1530     )
1531 def group_remove(
1532     groupname,
1533     user=None,
1534     host=None,
1535     port=None,
1536     maintenance_db=None,
1537     password=None,
1538     runas=None,
1539 ):
1540     return _role_remove(
1541         groupname,
1542         user=user,
1543         host=host,
1544         port=port,
1545         maintenance_db=maintenance_db,
1546         password=password,
1547         runas=runas,
1548     )
1549 def owner_to(
1550     dbname, ownername, user=None, host=None, port=None, password=None, runas=None
1551 ):
1552     sqlfile = tempfile.NamedTemporaryFile()
1553     sqlfile.write("begin;\n")
1554     sqlfile.write('alter database "{}" owner to "{}";\n'.format(dbname, ownername))
1555     queries = (
1556         (
1557             "alter schema {n} owner to {owner};",
1558             "select quote_ident(schema_name) as n from information_schema.schemata;",
1559         ),
1560         (
1561             "alter table {n} owner to {owner};",
1562             "select quote_ident(table_schema)||'.'||quote_ident(table_name) as "
1563             "n from information_schema.tables where table_schema not in "
1564             "('pg_catalog', 'information_schema');",
1565         ),
1566         (
1567             "alter function {n} owner to {owner};",
1568             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1569             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1570             "ns.nspname not in ('pg_catalog', 'information_schema') "
1571             " and not p.proisagg;",
1572         ),
1573         (
1574             "alter aggregate {n} owner to {owner};",
1575             "select p.oid::regprocedure::text as n from pg_catalog.pg_proc p "
1576             "join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where "
1577             "ns.nspname not in ('pg_catalog', 'information_schema') "
1578             "and p.proisagg;",
1579         ),
1580         (
1581             "alter sequence {n} owner to {owner};",
1582             "select quote_ident(sequence_schema)||'.'||"
1583             "quote_ident(sequence_name) as n from information_schema.sequences;",
1584         ),
1585     )
1586     for fmt, query in queries:
1587         ret = psql_query(
1588             query,
1589             user=user,
1590             host=host,
1591             port=port,
1592             maintenance_db=dbname,
1593             password=password,
1594             runas=runas,
1595         )
1596         for row in ret:
1597             sqlfile.write(fmt.format(owner=ownername, n=row["n"]) + "\n")
1598     sqlfile.write("commit;\n")
1599     sqlfile.flush()
1600     os.chmod(sqlfile.name, 0o644)  # ensure psql can read the file
1601     cmdret = _psql_prepare_and_run(
1602         ["-f", sqlfile.name],
1603         user=user,
1604         runas=runas,
1605         host=host,
1606         port=port,
1607         password=password,
1608         maintenance_db=dbname,
1609     )
1610     return cmdret
1611 def schema_create(
1612     dbname,
1613     name,
1614     owner=None,
1615     user=None,
1616     db_user=None,
1617     db_password=None,
1618     db_host=None,
1619     db_port=None,
1620 ):
1621     if schema_exists(
1622         dbname,
1623         name,
1624         user=user,
1625         db_user=db_user,
1626         db_password=db_password,
1627         db_host=db_host,
1628         db_port=db_port,
1629     ):
1630         log.info("'%s' already exists in '%s'", name, dbname)
1631         return False
1632     sub_cmd = 'CREATE SCHEMA "{}"'.format(name)
1633     if owner is not None:
1634         sub_cmd = '{} AUTHORIZATION "{}"'.format(sub_cmd, owner)
1635     ret = _psql_prepare_and_run(
1636         ["-c", sub_cmd],
1637         user=db_user,
1638         password=db_password,
1639         port=db_port,
1640         host=db_host,
1641         maintenance_db=dbname,
1642         runas=user,
1643     )
1644     return ret["retcode"] == 0
1645 def schema_remove(
1646     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1647 ):
1648     if not schema_exists(
1649         dbname,
1650         name,
1651         user=None,
1652         db_user=db_user,
1653         db_password=db_password,
1654         db_host=db_host,
1655         db_port=db_port,
1656     ):
1657         log.info("Schema '%s' does not exist in '%s'", name, dbname)
1658         return False
1659     sub_cmd = 'DROP SCHEMA "{}"'.format(name)
1660     _psql_prepare_and_run(
1661         ["-c", sub_cmd],
1662         runas=user,
1663         maintenance_db=dbname,
1664         host=db_host,
1665         user=db_user,
1666         port=db_port,
1667         password=db_password,
1668     )
1669     if not schema_exists(
1670         dbname,
1671         name,
1672         user,
1673         db_user=db_user,
1674         db_password=db_password,
1675         db_host=db_host,
1676         db_port=db_port,
1677     ):
1678         return True
1679     else:
1680         log.info("Failed to delete schema '%s'.", name)
1681         return False
1682 def schema_exists(
1683     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1684 ):
1685     return bool(
1686         schema_get(
1687             dbname,
1688             name,
1689             user=user,
1690             db_user=db_user,
1691             db_host=db_host,
1692             db_port=db_port,
1693             db_password=db_password,
1694         )
1695     )
1696 def schema_get(
1697     dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1698 ):
1699     all_schemas = schema_list(
1700         dbname,
1701         user=user,
1702         db_user=db_user,
1703         db_host=db_host,
1704         db_port=db_port,
1705         db_password=db_password,
1706     )
1707     try:
1708         return all_schemas.get(name, None)
1709     except AttributeError:
1710         log.error("Could not retrieve Postgres schema. Is Postgres running?")
1711         return False
1712 def schema_list(
1713     dbname, user=None, db_user=None, db_password=None, db_host=None, db_port=None
1714 ):
1715     ret = {}
1716     query = "".join(
1717         [
1718             "SELECT "
1719             'pg_namespace.nspname as "name",'
1720             'pg_namespace.nspacl as "acl", '
1721             'pg_roles.rolname as "owner" '
1722             "FROM pg_namespace "
1723             "LEFT JOIN pg_roles ON pg_roles.oid = pg_namespace.nspowner "
1724         ]
1725     )
1726     rows = psql_query(
1727         query,
1728         runas=user,
1729         host=db_host,
1730         user=db_user,
1731         port=db_port,
1732         maintenance_db=dbname,
1733         password=db_password,
1734     )
1735     for row in rows:
1736         retrow = {}
1737         for key in ("owner", "acl"):
1738             retrow[key] = row[key]
1739         ret[row["name"]] = retrow
1740     return ret
1741 def language_list(
1742     maintenance_db, user=None, host=None, port=None, password=None, runas=None
1743 ):
1744     ret = {}
1745     query = 'SELECT lanname AS "Name" FROM pg_language'
1746     rows = psql_query(
1747         query,
1748         runas=runas,
1749         host=host,
1750         user=user,
1751         port=port,
1752         maintenance_db=maintenance_db,
1753         password=password,
1754     )
1755     for row in rows:
1756         ret[row["Name"]] = row["Name"]
1757     return ret
1758 def language_exists(
1759     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1760 ):
1761     languages = language_list(
1762         maintenance_db, user=user, host=host, port=port, password=password, runas=runas
1763     )
1764     return name in languages
1765 def language_create(
1766     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1767 ):
1768     if language_exists(name, maintenance_db):
1769         log.info("Language %s already exists in %s", name, maintenance_db)
1770         return False
1771     query = "CREATE LANGUAGE {}".format(name)
1772     ret = _psql_prepare_and_run(
1773         ["-c", query],
1774         user=user,
1775         host=host,
1776         port=port,
1777         maintenance_db=maintenance_db,
1778         password=password,
1779         runas=runas,
1780     )
1781     return ret["retcode"] == 0
1782 def language_remove(
1783     name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
1784 ):
1785     if not language_exists(name, maintenance_db):
1786         log.info("Language %s does not exist in %s", name, maintenance_db)
1787         return False
1788     query = "DROP LANGUAGE {}".format(name)
1789     ret = _psql_prepare_and_run(
1790         ["-c", query],
1791         user=user,
1792         host=host,
1793         port=port,
1794         runas=runas,
1795         maintenance_db=maintenance_db,
1796         password=password,
1797     )
1798     return ret["retcode"] == 0
1799 def _make_privileges_list_query(name, object_type, prepend):
1800     if object_type == "table":
1801         query = (
1802             " ".join(
1803                 [
1804                     "SELECT relacl AS name",
1805                     "FROM pg_catalog.pg_class c",
1806                     "JOIN pg_catalog.pg_namespace n",
1807                     "ON n.oid = c.relnamespace",
1808                     "WHERE nspname = '{0}'",
1809                     "AND relname = '{1}'",
1810                     "AND relkind = 'r'",
1811                     "ORDER BY relname",
1812                 ]
1813             )
1814         ).format(prepend, name)
1815     elif object_type == "sequence":
1816         query = (
1817             " ".join(
1818                 [
1819                     "SELECT relacl AS name",
1820                     "FROM pg_catalog.pg_class c",
1821                     "JOIN pg_catalog.pg_namespace n",
1822                     "ON n.oid = c.relnamespace",
1823                     "WHERE nspname = '{0}'",
1824                     "AND relname = '{1}'",
1825                     "AND relkind = 'S'",
1826                     "ORDER BY relname",
1827                 ]
1828             )
1829         ).format(prepend, name)
1830     elif object_type == "schema":
1831         query = (
1832             " ".join(
1833                 [
1834                     "SELECT nspacl AS name",
1835                     "FROM pg_catalog.pg_namespace",
1836                     "WHERE nspname = '{0}'",
1837                     "ORDER BY nspname",
1838                 ]
1839             )
1840         ).format(name)
1841     elif object_type == "function":
1842         query = (
1843             " ".join(
1844                 [
1845                     "SELECT proacl AS name",
1846                     "FROM pg_catalog.pg_proc p",
1847                     "JOIN pg_catalog.pg_namespace n",
1848                     "ON n.oid = p.pronamespace",
1849                     "WHERE nspname = '{0}'",
1850                     "AND p.oid::regprocedure::text = '{1}'",
1851                     "ORDER BY proname, proargtypes",
1852                 ]
1853             )
1854         ).format(prepend, name)
1855     elif object_type == "tablespace":
1856         query = (
1857             " ".join(
1858                 [
1859                     "SELECT spcacl AS name",
1860                     "FROM pg_catalog.pg_tablespace",
1861                     "WHERE spcname = '{0}'",
1862                     "ORDER BY spcname",
1863                 ]
1864             )
1865         ).format(name)
1866     elif object_type == "language":
1867         query = (
1868             " ".join(
1869                 [
1870                     "SELECT lanacl AS name",
1871                     "FROM pg_catalog.pg_language",
1872                     "WHERE lanname = '{0}'",
1873                     "ORDER BY lanname",
1874                 ]
1875             )
1876         ).format(name)
1877     elif object_type == "database":
1878         query = (
1879             " ".join(
1880                 [
1881                     "SELECT datacl AS name",
1882                     "FROM pg_catalog.pg_database",
1883                     "WHERE datname = '{0}'",
1884                     "ORDER BY datname",
1885                 ]
1886             )
1887         ).format(name)
1888     elif object_type == "group":
1889         query = (
1890             " ".join(
1891                 [
1892                     "SELECT rolname, admin_option",
1893                     "FROM pg_catalog.pg_auth_members m",
1894                     "JOIN pg_catalog.pg_roles r",
1895                     "ON m.member=r.oid",
1896                     "WHERE m.roleid IN",
1897                     "(SELECT oid",
1898                     "FROM pg_catalog.pg_roles",
1899                     "WHERE rolname='{0}')",
1900                     "ORDER BY rolname",
1901                 ]
1902             )
1903         ).format(name)
1904     return query
1905 def _get_object_owner(
1906     name,
1907     object_type,
1908     prepend="public",
1909     maintenance_db=None,
1910     user=None,
1911     host=None,
1912     port=None,
1913     password=None,
1914     runas=None,
1915 ):
1916     if object_type == "table":
1917         query = (
1918             " ".join(
1919                 [
1920                     "SELECT tableowner AS name",
1921                     "FROM pg_tables",
1922                     "WHERE schemaname = '{0}'",
1923                     "AND tablename = '{1}'",
1924                 ]
1925             )
1926         ).format(prepend, name)
1927     elif object_type == "sequence":
1928         query = (
1929             " ".join(
1930                 [
1931                     "SELECT rolname AS name",
1932                     "FROM pg_catalog.pg_class c",
1933                     "JOIN pg_roles r",
1934                     "ON c.relowner = r.oid",
1935                     "JOIN pg_catalog.pg_namespace n",
1936                     "ON n.oid = c.relnamespace",
1937                     "WHERE relkind='S'",
1938                     "AND nspname='{0}'",
1939                     "AND relname = '{1}'",
1940                 ]
1941             )
1942         ).format(prepend, name)
1943     elif object_type == "schema":
1944         query = (
1945             " ".join(
1946                 [
1947                     "SELECT rolname AS name",
1948                     "FROM pg_namespace n",
1949                     "JOIN pg_roles r",
1950                     "ON n.nspowner = r.oid",
1951                     "WHERE nspname = '{0}'",
1952                 ]
1953             )
1954         ).format(name)
1955     elif object_type == "function":
1956         query = (
1957             " ".join(
1958                 [
1959                     "SELECT rolname AS name",
1960                     "FROM pg_catalog.pg_proc p",
1961                     "JOIN pg_catalog.pg_namespace n",
1962                     "ON n.oid = p.pronamespace",
1963                     "WHERE nspname = '{0}'",
1964                     "AND p.oid::regprocedure::text = '{1}'",
1965                     "ORDER BY proname, proargtypes",
1966                 ]
1967             )
1968         ).format(prepend, name)
1969     elif object_type == "tablespace":
1970         query = (
1971             " ".join(
1972                 [
1973                     "SELECT rolname AS name",
1974                     "FROM pg_tablespace t",
1975                     "JOIN pg_roles r",
1976                     "ON t.spcowner = r.oid",
1977                     "WHERE spcname = '{0}'",
1978                 ]
1979             )
1980         ).format(name)
1981     elif object_type == "language":
1982         query = (
1983             " ".join(
1984                 [
1985                     "SELECT rolname AS name",
1986                     "FROM pg_language l",
1987                     "JOIN pg_roles r",
1988                     "ON l.lanowner = r.oid",
1989                     "WHERE lanname = '{0}'",
1990                 ]
1991             )
1992         ).format(name)
1993     elif object_type == "database":
1994         query = (
1995             " ".join(
1996                 [
1997                     "SELECT rolname AS name",
1998                     "FROM pg_database d",
1999                     "JOIN pg_roles r",
2000                     "ON d.datdba = r.oid",
2001                     "WHERE datname = '{0}'",
2002                 ]
2003             )
2004         ).format(name)
2005     rows = psql_query(
2006         query,
2007         runas=runas,
2008         host=host,
2009         user=user,
2010         port=port,
2011         maintenance_db=maintenance_db,
2012         password=password,
2013     )
2014     try:
2015         ret = rows[0]["name"]
2016     except IndexError:
2017         ret = None
2018     return ret
2019 def _validate_privileges(object_type, privs, privileges):
2020     if object_type != "group":
2021         _perms = [_PRIVILEGES_MAP[perm] for perm in _PRIVILEGE_TYPE_MAP[object_type]]
2022         _perms.append("ALL")
2023         if object_type not in _PRIVILEGES_OBJECTS:
2024             raise SaltInvocationError(
2025                 "Invalid object_type: {} provided".format(object_type)
2026             )
2027         if not set(privs).issubset(set(_perms)):
2028             raise SaltInvocationError(
2029                 "Invalid privilege(s): {} provided for object {}".format(
2030                     privileges, object_type
2031                 )
2032             )
2033     else:
2034         if privileges:
2035             raise SaltInvocationError(
2036                 "The privileges option should not be set for object_type group"
2037             )
2038 def _mod_priv_opts(object_type, privileges):
2039     object_type = object_type.lower()
2040     privileges = "" if privileges is None else privileges
2041     _privs = re.split(r"\s?,\s?", privileges.upper())
2042     return object_type, privileges, _privs
2043 def _process_priv_part(perms):
2044     _tmp = {}
2045     previous = None
2046     for perm in perms:
2047         if previous is None:
2048             _tmp[_PRIVILEGES_MAP[perm]] = False
2049             previous = _PRIVILEGES_MAP[perm]
2050         else:
2051             if perm == "*":
2052                 _tmp[previous] = True
2053             else:
2054                 _tmp[_PRIVILEGES_MAP[perm]] = False
2055                 previous = _PRIVILEGES_MAP[perm]
2056     return _tmp
2057 def privileges_list(
2058     name,
2059     object_type,
2060     prepend="public",
2061     maintenance_db=None,
2062     user=None,
2063     host=None,
2064     port=None,
2065     password=None,
2066     runas=None,
2067 ):
2068     object_type = object_type.lower()
2069     query = _make_privileges_list_query(name, object_type, prepend)
2070     if object_type not in _PRIVILEGES_OBJECTS:
2071         raise SaltInvocationError(
2072             "Invalid object_type: {} provided".format(object_type)
2073         )
2074     rows = psql_query(
2075         query,
2076         runas=runas,
2077         host=host,
2078         user=user,
2079         port=port,
2080         maintenance_db=maintenance_db,
2081         password=password,
2082     )
2083     ret = {}
2084     for row in rows:
2085         if object_type != "group":
2086             result = row["name"]
2087             result = result.strip("{}")
2088             parts = result.split(",")
2089             for part in parts:
2090                 perms_part, _ = part.split("/")
2091                 rolename, perms = perms_part.split("=")
2092                 if rolename == "":
2093                     rolename = "public"
2094                 _tmp = _process_priv_part(perms)
2095                 ret[rolename] = _tmp
2096         else:
2097             if row["admin_option"] == "t":
2098                 admin_option = True
2099             else:
2100                 admin_option = False
2101             ret[row["rolname"]] = admin_option
2102     return ret
2103 def has_privileges(
2104     name,
2105     object_name,
2106     object_type,
2107     privileges=None,
2108     grant_option=None,
2109     prepend="public",
2110     maintenance_db=None,
2111     user=None,
2112     host=None,
2113     port=None,
2114     password=None,
2115     runas=None,
2116 ):
2117     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2118     _validate_privileges(object_type, _privs, privileges)
2119     if object_type != "group":
2120         owner = _get_object_owner(
2121             object_name,
2122             object_type,
2123             prepend=prepend,
2124             maintenance_db=maintenance_db,
2125             user=user,
2126             host=host,
2127             port=port,
2128             password=password,
2129             runas=runas,
2130         )
2131         if owner is not None and name == owner:
2132             return True
2133     _privileges = privileges_list(
2134         object_name,
2135         object_type,
2136         prepend=prepend,
2137         maintenance_db=maintenance_db,
2138         user=user,
2139         host=host,
2140         port=port,
2141         password=password,
2142         runas=runas,
2143     )
2144     if name in _privileges:
2145         if object_type == "group":
2146             if grant_option:
2147                 retval = _privileges[name]
2148             else:
2149                 retval = True
2150             return retval
2151         else:
2152             _perms = _PRIVILEGE_TYPE_MAP[object_type]
2153             if grant_option:
2154                 perms = {_PRIVILEGES_MAP[perm]: True for perm in _perms}
2155                 retval = perms == _privileges[name]
2156             else:
2157                 perms = [_PRIVILEGES_MAP[perm] for perm in _perms]
2158                 if "ALL" in _privs:
2159                     retval = sorted(perms) == sorted(_privileges[name])
2160                 else:
2161                     retval = set(_privs).issubset(set(_privileges[name]))
2162             return retval
2163     return False
2164 def privileges_grant(
2165     name,
2166     object_name,
2167     object_type,
2168     privileges=None,
2169     grant_option=None,
2170     prepend="public",
2171     maintenance_db=None,
2172     user=None,
2173     host=None,
2174     port=None,
2175     password=None,
2176     runas=None,
2177 ):
2178     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2179     _validate_privileges(object_type, _privs, privileges)
2180     if has_privileges(
2181         name,
2182         object_name,
2183         object_type,
2184         privileges,
2185         prepend=prepend,
2186         maintenance_db=maintenance_db,
2187         user=user,
2188         host=host,
2189         port=port,
2190         password=password,
2191         runas=runas,
2192     ):
2193         log.info(
2194             "The object: %s of type: %s already has privileges: %s set",
2195             object_name,
2196             object_type,
2197             privileges,
2198         )
2199         return False
2200     _grants = ",".join(_privs)
2201     if object_type in ["table", "sequence"]:
2202         on_part = '{}."{}"'.format(prepend, object_name)
2203     elif object_type == "function":
2204         on_part = "{}".format(object_name)
2205     else:
2206         on_part = '"{}"'.format(object_name)
2207     if grant_option:
2208         if object_type == "group":
2209             query = 'GRANT {} TO "{}" WITH ADMIN OPTION'.format(object_name, name)
2210         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2211             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}" WITH GRANT OPTION'.format(
2212                 _grants, object_type.upper(), prepend, name
2213             )
2214         else:
2215             query = 'GRANT {} ON {} {} TO "{}" WITH GRANT OPTION'.format(
2216                 _grants, object_type.upper(), on_part, name
2217             )
2218     else:
2219         if object_type == "group":
2220             query = 'GRANT {} TO "{}"'.format(object_name, name)
2221         elif object_type in ("table", "sequence") and object_name.upper() == "ALL":
2222             query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO "{}"'.format(
2223                 _grants, object_type.upper(), prepend, name
2224             )
2225         else:
2226             query = 'GRANT {} ON {} {} TO "{}"'.format(
2227                 _grants, object_type.upper(), on_part, name
2228             )
2229     ret = _psql_prepare_and_run(
2230         ["-c", query],
2231         user=user,
2232         host=host,
2233         port=port,
2234         maintenance_db=maintenance_db,
2235         password=password,
2236         runas=runas,
2237     )
2238     return ret["retcode"] == 0
2239 def privileges_revoke(
2240     name,
2241     object_name,
2242     object_type,
2243     privileges=None,
2244     prepend="public",
2245     maintenance_db=None,
2246     user=None,
2247     host=None,
2248     port=None,
2249     password=None,
2250     runas=None,
2251 ):
2252     object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)
2253     _validate_privileges(object_type, _privs, privileges)
2254     if not has_privileges(
2255         name,
2256         object_name,
2257         object_type,
2258         privileges,
2259         prepend=prepend,
2260         maintenance_db=maintenance_db,
2261         user=user,
2262         host=host,
2263         port=port,
2264         password=password,
2265         runas=runas,
2266     ):
2267         log.info(
2268             "The object: %s of type: %s does not have privileges: %s set",
2269             object_name,
2270             object_type,
2271             privileges,
2272         )
2273         return False
2274     _grants = ",".join(_privs)
2275     if object_type in ["table", "sequence"]:
2276         on_part = "{}.{}".format(prepend, object_name)
2277     else:
2278         on_part = object_name
2279     if object_type == "group":
2280         query = "REVOKE {} FROM {}".format(object_name, name)
2281     else:
2282         query = "REVOKE {} ON {} {} FROM {}".format(
2283             _grants, object_type.upper(), on_part, name
2284         )
2285     ret = _psql_prepare_and_run(
2286         ["-c", query],
2287         user=user,
2288         host=host,
2289         port=port,
2290         maintenance_db=maintenance_db,
2291         password=password,
2292         runas=runas,
2293     )
2294     return ret["retcode"] == 0
2295 def datadir_init(
2296     name,
2297     auth="password",
2298     user=None,
2299     password=None,
2300     encoding="UTF8",
2301     locale=None,
2302     waldir=None,
2303     checksums=False,
2304     runas=None,
2305 ):
2306     if datadir_exists(name):
2307         log.info("%s already exists", name)
2308         return False
2309     ret = _run_initdb(
2310         name,
2311         auth=auth,
2312         user=user,
2313         password=password,
2314         encoding=encoding,
2315         locale=locale,
2316         waldir=waldir,
2317         checksums=checksums,
2318         runas=runas,
2319     )
2320     return ret["retcode"] == 0
2321 def datadir_exists(name):
2322     _version_file = os.path.join(name, "PG_VERSION")
2323     _config_file = os.path.join(name, "postgresql.conf")
2324     return os.path.isfile(_version_file) and os.path.isfile(_config_file)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
