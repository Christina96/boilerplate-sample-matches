<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mac_brew_pkg.py & postgres_2.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mac_brew_pkg.py & postgres_2.py
      </h3>
      <h1 align="center">
        0.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mac_brew_pkg.py (1.6689847%)<TH>postgres_2.py (0.41855597%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match286285-0.html#0',2,'match286285-1.html#0',3)" NAME="0">(115-119)<TD><A HREF="javascript:ZweiFrames('match286285-0.html#0',2,'match286285-1.html#0',3)" NAME="0">(1221-1224)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mac_brew_pkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Homebrew for macOS

.. important::
    If you feel that Salt should be using this module to manage packages on a
    minion, and it is using a different module (or gives an error similar to
    *'pkg.install' is not available*), see :ref:`here
    &lt;module-provider-override&gt;`.
&quot;&quot;&quot;

import copy
import functools
import logging
import re

import salt.utils.data
import salt.utils.functools
import salt.utils.json
import salt.utils.path
import salt.utils.pkg
import salt.utils.versions
from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError

log = logging.getLogger(__name__)

# Define the module's virtual name
__virtualname__ = &quot;pkg&quot;


def __virtual__():
    &quot;&quot;&quot;
    Confine this module to Mac OS with Homebrew.
    &quot;&quot;&quot;
    if __grains__[&quot;os&quot;] != &quot;MacOS&quot;:
        return False, &quot;brew module is macos specific&quot;
    if not salt.utils.path.which(&quot;brew&quot;):
        return False, &quot;The 'brew' binary was not found&quot;
    return __virtualname__


def _list_taps():
    &quot;&quot;&quot;
    List currently installed brew taps
    &quot;&quot;&quot;
    return _call_brew(&quot;tap&quot;)[&quot;stdout&quot;].splitlines()


def _list_pinned():
    &quot;&quot;&quot;
    List currently pinned formulas
    &quot;&quot;&quot;
    return _call_brew(&quot;list&quot;, &quot;--pinned&quot;)[&quot;stdout&quot;].splitlines()


def _pin(pkg, runas=None):
    &quot;&quot;&quot;
    Pin pkg
    &quot;&quot;&quot;
    try:
        _call_brew(&quot;pin&quot;, pkg)
    except CommandExecutionError:
        log.error('Failed to pin &quot;%s&quot;', pkg)
        return False

    return True


def _unpin(pkg, runas=None):
    &quot;&quot;&quot;
    Pin pkg
    &quot;&quot;&quot;
    try:
        _call_brew(&quot;unpin&quot;, pkg)
    except CommandExecutionError:
        log.error('Failed to unpin &quot;%s&quot;', pkg)
        return False

    return True


def _tap(tap, runas=None):
    &quot;&quot;&quot;
    Add unofficial GitHub repos to the list of formulas that brew tracks,
    updates, and installs from.
    &quot;&quot;&quot;
    if tap in _list_taps():
        return True

    try:
        _call_brew(&quot;tap&quot;, tap)
    except CommandExecutionError:
        log.error('Failed to tap &quot;%s&quot;', tap)
        return False

    return True


def _homebrew_bin():
    &quot;&quot;&quot;
    Returns the full path to the homebrew binary in the PATH
    &quot;&quot;&quot;
    ret = __salt__[&quot;cmd.run&quot;](&quot;brew --prefix&quot;, output_loglevel=&quot;trace&quot;)
    ret += &quot;/bin/brew&quot;
    return ret


def _call_brew(*cmd, failhard=True):
    &quot;&quot;&quot;
    Calls the brew command with the user account of brew
    &quot;&quot;&quot;
    user = __salt__[&quot;file.get_user&quot;](_homebrew_bin())
<A NAME="0"></A>    runas = user if user != __opts__[&quot;user&quot;] else None
    _cmd = []
    if runas:
        _cmd = [&quot;sudo -i -n -H -u {} -- &quot;.format<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match286285-1.html#0',3,'match286285-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(runas)]
    _cmd = _cmd + [salt.utils.path.which(&quot;brew&quot;)] + list(cmd)
    _cmd = &quot; &quot;.join(_cmd)

    runas =</B></FONT> None
    result = __salt__[&quot;cmd.run_all&quot;](
        cmd=_cmd,
        runas=runas,
        output_loglevel=&quot;trace&quot;,
        python_shell=False,
    )
    if failhard and result[&quot;retcode&quot;] != 0:
        raise CommandExecutionError(&quot;Brew command failed&quot;, info={&quot;result&quot;: result})
    return result


def _list_pkgs_from_context(versions_as_list):
    &quot;&quot;&quot;
    Use pkg list from __context__
    &quot;&quot;&quot;
    if versions_as_list:
        return __context__[&quot;pkg.list_pkgs&quot;]
    else:
        ret = copy.deepcopy(__context__[&quot;pkg.list_pkgs&quot;])
        __salt__[&quot;pkg_resource.stringify&quot;](ret)
        return ret


def list_pkgs(versions_as_list=False, **kwargs):
    &quot;&quot;&quot;
    List the packages currently installed in a dict::

        {'&lt;package_name&gt;': '&lt;version&gt;'}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.list_pkgs
    &quot;&quot;&quot;
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    # not yet implemented or not applicable
    if any(
        [salt.utils.data.is_true(kwargs.get(x)) for x in (&quot;removed&quot;, &quot;purge_desired&quot;)]
    ):
        return {}

    if &quot;pkg.list_pkgs&quot; in __context__ and kwargs.get(&quot;use_context&quot;, True):
        return _list_pkgs_from_context(versions_as_list)

    ret = {}
    package_info = salt.utils.json.loads(
        _call_brew(&quot;info&quot;, &quot;--json=v2&quot;, &quot;--installed&quot;)[&quot;stdout&quot;]
    )

    for package in package_info[&quot;formulae&quot;]:
        # Brew allows multiple versions of the same package to be installed.
        # Salt allows for this, so it must be accounted for.
        versions = [v[&quot;version&quot;] for v in package[&quot;installed&quot;]]
        # Brew allows for aliasing of packages, all of which will be
        # installable from a Salt call, so all names must be accounted for.
        names = package[&quot;aliases&quot;] + [package[&quot;name&quot;], package[&quot;full_name&quot;]]
        # Create a list of tuples containing all possible combinations of
        # names and versions, because all are valid.
        combinations = [(n, v) for n in names for v in versions]

        for name, version in combinations:
            __salt__[&quot;pkg_resource.add_pkg&quot;](ret, name, version)

    # Grab packages from brew cask, if available.
    # Brew Cask doesn't provide a JSON interface, must be parsed the old way.
    try:
        out = _call_brew(&quot;list&quot;, &quot;--cask&quot;, &quot;--versions&quot;)[&quot;stdout&quot;]

        for line in out.splitlines():
            try:
                name_and_versions = line.split(&quot; &quot;)
                pkg_name = name_and_versions[0]

                # Get cask namespace
                match = re.search(
                    r&quot;^From: .*/(.+?)/homebrew-(.+?)/.*$&quot;,
                    _call_brew(&quot;info&quot;, &quot;--cask&quot;, pkg_name)[&quot;stdout&quot;],
                    re.MULTILINE,
                )
                if match:
                    namespace = &quot;/&quot;.join(
                        (match.group(1).lower(), match.group(2).lower())
                    )
                else:
                    namespace = &quot;homebrew/cask&quot;

                name = &quot;/&quot;.join((namespace, pkg_name))
                installed_versions = name_and_versions[1:]
                key_func = functools.cmp_to_key(salt.utils.versions.version_cmp)
                newest_version = sorted(installed_versions, key=key_func).pop()
            except ValueError:
                continue
            __salt__[&quot;pkg_resource.add_pkg&quot;](ret, name, newest_version)
    except CommandExecutionError:
        pass

    __salt__[&quot;pkg_resource.sort_pkglist&quot;](ret)
    __context__[&quot;pkg.list_pkgs&quot;] = copy.deepcopy(ret)
    if not versions_as_list:
        __salt__[&quot;pkg_resource.stringify&quot;](ret)
    return ret


def version(*names, **kwargs):
    &quot;&quot;&quot;
    Returns a string representing the package version or an empty string if not
    installed. If more than one package name is specified, a dict of
    name/version pairs is returned.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.version &lt;package name&gt;
        salt '*' pkg.version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt;
    &quot;&quot;&quot;
    return __salt__[&quot;pkg_resource.version&quot;](*names, **kwargs)


def latest_version(*names, **kwargs):
    &quot;&quot;&quot;
    Return the latest version of the named package available for upgrade or
    installation

    Currently chooses stable versions, falling back to devel if that does not
    exist.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.latest_version &lt;package name&gt;
        salt '*' pkg.latest_version &lt;package1&gt; &lt;package2&gt; &lt;package3&gt;
    &quot;&quot;&quot;
    refresh = salt.utils.data.is_true(kwargs.pop(&quot;refresh&quot;, True))
    if refresh:
        refresh_db()

    def get_version(pkg_info):
        # Perhaps this will need an option to pick devel by default
        return pkg_info[&quot;versions&quot;][&quot;stable&quot;] or pkg_info[&quot;versions&quot;][&quot;devel&quot;]

    versions_dict = {key: get_version(val) for key, val in _info(*names).items()}

    if len(names) == 1:
        return next(iter(versions_dict.values()))
    else:
        return versions_dict


# available_version is being deprecated
available_version = salt.utils.functools.alias_function(
    latest_version, &quot;available_version&quot;
)


def remove(name=None, pkgs=None, **kwargs):
    &quot;&quot;&quot;
    Removes packages with ``brew uninstall``.

    name
        The name of the package to be deleted.


    Multiple Package Options:

    pkgs
        A list of packages to delete. Must be passed as a python list. The
        ``name`` parameter will be ignored if this option is passed.

    .. versionadded:: 0.16.0


    Returns a dict containing the changes.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.remove &lt;package name&gt;
        salt '*' pkg.remove &lt;package1&gt;,&lt;package2&gt;,&lt;package3&gt;
        salt '*' pkg.remove pkgs='[&quot;foo&quot;, &quot;bar&quot;]'
    &quot;&quot;&quot;
    try:
        pkg_params = __salt__[&quot;pkg_resource.parse_targets&quot;](name, pkgs, **kwargs)[0]
    except MinionError as exc:
        raise CommandExecutionError(exc)

    old = list_pkgs()
    targets = [x for x in pkg_params if x in old]
    if not targets:
        return {}

    out = _call_brew(&quot;uninstall&quot;, *targets)
    if out[&quot;retcode&quot;] != 0 and out[&quot;stderr&quot;]:
        errors = [out[&quot;stderr&quot;]]
    else:
        errors = []

    __context__.pop(&quot;pkg.list_pkgs&quot;, None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)

    if errors:
        raise CommandExecutionError(
            &quot;Problem encountered removing package(s)&quot;,
            info={&quot;errors&quot;: errors, &quot;changes&quot;: ret},
        )

    return ret


def refresh_db(**kwargs):
    &quot;&quot;&quot;
    Update the homebrew package repository.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.refresh_db
    &quot;&quot;&quot;
    # Remove rtag file to keep multiple refreshes from happening in pkg states
    salt.utils.pkg.clear_rtag(__opts__)
    if _call_brew(&quot;update&quot;)[&quot;retcode&quot;]:
        log.error(&quot;Failed to update&quot;)
        return False

    return True


def _info(*pkgs):
    &quot;&quot;&quot;
    Get all info brew can provide about a list of packages.

    Does not do any kind of processing, so the format depends entirely on
    the output brew gives. This may change if a new version of the format is
    requested.

    On failure, returns an empty dict and logs failure.
    On success, returns a dict mapping each item in pkgs to its corresponding
    object in the output of 'brew info'.

    Caveat: If one of the packages does not exist, no packages will be
            included in the output.
    &quot;&quot;&quot;
    brew_result = _call_brew(&quot;info&quot;, &quot;--json=v2&quot;, *pkgs)
    if brew_result[&quot;retcode&quot;]:
        log.error(&quot;Failed to get info about packages: %s&quot;, &quot; &quot;.join(pkgs))
        return {}
    output = salt.utils.json.loads(brew_result[&quot;stdout&quot;])
    return dict(zip(pkgs, output[&quot;formulae&quot;]))


def install(name=None, pkgs=None, taps=None, options=None, **kwargs):
    &quot;&quot;&quot;
    Install the passed package(s) with ``brew install``

    name
        The name of the formula to be installed. Note that this parameter is
        ignored if &quot;pkgs&quot; is passed.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install &lt;package name&gt;

    taps
        Unofficial GitHub repos to use when updating and installing formulas.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install &lt;package name&gt; tap='&lt;tap&gt;'
            salt '*' pkg.install zlib taps='homebrew/dupes'
            salt '*' pkg.install php54 taps='[&quot;josegonzalez/php&quot;, &quot;homebrew/dupes&quot;]'

    options
        Options to pass to brew. Only applies to initial install. Due to how brew
        works, modifying chosen options requires a full uninstall followed by a
        fresh install. Note that if &quot;pkgs&quot; is used, all options will be passed
        to all packages. Unrecognized options for a package will be silently
        ignored by brew.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install &lt;package name&gt; tap='&lt;tap&gt;'
            salt '*' pkg.install php54 taps='[&quot;josegonzalez/php&quot;, &quot;homebrew/dupes&quot;]' options='[&quot;--with-fpm&quot;]'

    Multiple Package Installation Options:

    pkgs
        A list of formulas to install. Must be passed as a python list.

        CLI Example:

        .. code-block:: bash

            salt '*' pkg.install pkgs='[&quot;foo&quot;,&quot;bar&quot;]'


    Returns a dict containing the new package names and versions::

        {'&lt;package&gt;': {'old': '&lt;old-version&gt;',
                       'new': '&lt;new-version&gt;'}}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.install 'package package package'
    &quot;&quot;&quot;
    try:
        pkg_params, pkg_type = __salt__[&quot;pkg_resource.parse_targets&quot;](
            name, pkgs, kwargs.get(&quot;sources&quot;, {})
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)

    if not pkg_params:
        return {}

    cmd = [&quot;install&quot;]
    cmd.extend(list(pkg_params))

    old = list_pkgs()

    # Ensure we've tapped the repo if necessary
    if taps:
        if not isinstance(taps, list):
            # Feels like there is a better way to allow for tap being
            # specified as both a string and a list
            taps = [taps]

        for tap in taps:
            _tap(tap)

    if options:
        cmd.extend(options)

    out = _call_brew(*cmd)
    if out[&quot;retcode&quot;] != 0 and out[&quot;stderr&quot;]:
        errors = [out[&quot;stderr&quot;]]
    else:
        errors = []

    __context__.pop(&quot;pkg.list_pkgs&quot;, None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)

    if errors:
        raise CommandExecutionError(
            &quot;Problem encountered installing package(s)&quot;,
            info={&quot;errors&quot;: errors, &quot;changes&quot;: ret},
        )

    return ret


def list_upgrades(refresh=True, **kwargs):  # pylint: disable=W0613
    &quot;&quot;&quot;
    Check whether or not an upgrade is available for all packages

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.list_upgrades
    &quot;&quot;&quot;
    if refresh:
        refresh_db()

    res = _call_brew(&quot;outdated&quot;, &quot;--json=v2&quot;)
    ret = {}

    try:
        data = salt.utils.json.loads(res[&quot;stdout&quot;])[&quot;formulae&quot;]
    except ValueError as err:
        msg = 'unable to interpret output from &quot;brew outdated&quot;: {}'.format(err)
        log.error(msg)
        raise CommandExecutionError(msg)

    for pkg in data:
        # current means latest available to brew
        ret[pkg[&quot;name&quot;]] = pkg[&quot;current_version&quot;]
    return ret


def upgrade_available(pkg, **kwargs):
    &quot;&quot;&quot;
    Check whether or not an upgrade is available for a given package

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.upgrade_available &lt;package name&gt;
    &quot;&quot;&quot;
    return pkg in list_upgrades()


def upgrade(refresh=True, **kwargs):
    &quot;&quot;&quot;
    Upgrade outdated, unpinned brews.

    refresh
        Fetch the newest version of Homebrew and all formulae from GitHub before installing.

    Returns a dictionary containing the changes:

    .. code-block:: python

        {'&lt;package&gt;':  {'old': '&lt;old-version&gt;',
                        'new': '&lt;new-version&gt;'}}

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.upgrade
    &quot;&quot;&quot;
    ret = {
        &quot;changes&quot;: {},
        &quot;result&quot;: True,
        &quot;comment&quot;: &quot;&quot;,
    }

    old = list_pkgs()

    if salt.utils.data.is_true(refresh):
        refresh_db()

    result = _call_brew(&quot;upgrade&quot;, failhard=False)
    __context__.pop(&quot;pkg.list_pkgs&quot;, None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)

    if result[&quot;retcode&quot;] != 0:
        raise CommandExecutionError(
            &quot;Problem encountered upgrading packages&quot;,
            info={&quot;changes&quot;: ret, &quot;result&quot;: result},
        )

    return ret


def info_installed(*names, **kwargs):
    &quot;&quot;&quot;
    Return the information of the named package(s) installed on the system.

    .. versionadded:: 2016.3.1

    names
        The names of the packages for which to return information.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.info_installed &lt;package1&gt;
        salt '*' pkg.info_installed &lt;package1&gt; &lt;package2&gt; &lt;package3&gt; ...
    &quot;&quot;&quot;
    return _info(*names)


def hold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
    &quot;&quot;&quot;
    Set package in 'hold' state, meaning it will not be upgraded.

    .. versionadded:: 3001

    name
        The name of the package, e.g., 'tmux'

    CLI Example:

     .. code-block:: bash

        salt '*' pkg.hold &lt;package name&gt;

    pkgs
        A list of packages to hold. Must be passed as a python list.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.hold pkgs='[&quot;foo&quot;, &quot;bar&quot;]'
    &quot;&quot;&quot;
    if not name and not pkgs and not sources:
        raise SaltInvocationError(&quot;One of name, pkgs, or sources must be specified.&quot;)
    if pkgs and sources:
        raise SaltInvocationError(&quot;Only one of pkgs or sources can be specified.&quot;)

    targets = []
    if pkgs:
        targets.extend(pkgs)
    elif sources:
        for source in sources:
            targets.append(next(iter(source)))
    else:
        targets.append(name)

    ret = {}
    pinned = _list_pinned()
    installed = list_pkgs()
    for target in targets:
        if isinstance(target, dict):
            target = next(iter(target))

        ret[target] = {&quot;name&quot;: target, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

        if target not in installed:
            ret[target][&quot;comment&quot;] = &quot;Package {} does not have a state.&quot;.format(target)
        elif target not in pinned:
            if &quot;test&quot; in __opts__ and __opts__[&quot;test&quot;]:
                ret[target].update(result=None)
                ret[target][&quot;comment&quot;] = &quot;Package {} is set to be held.&quot;.format(target)
            else:
                result = _pin(target)
                if result:
                    changes = {&quot;old&quot;: &quot;install&quot;, &quot;new&quot;: &quot;hold&quot;}
                    ret[target].update(changes=changes, result=True)
                    ret[target][&quot;comment&quot;] = &quot;Package {} is now being held.&quot;.format(
                        target
                    )
                else:
                    ret[target].update(result=False)
                    ret[target][&quot;comment&quot;] = &quot;Unable to hold package {}.&quot;.format(target)
        else:
            ret[target].update(result=True)
            ret[target][&quot;comment&quot;] = &quot;Package {} is already set to be held.&quot;.format(
                target
            )
    return ret


pin = hold


def unhold(name=None, pkgs=None, sources=None, **kwargs):  # pylint: disable=W0613
    &quot;&quot;&quot;
    Set package current in 'hold' state to install state,
    meaning it will be upgraded.

    .. versionadded:: 3001

    name
        The name of the package, e.g., 'tmux'

     CLI Example:

     .. code-block:: bash

        salt '*' pkg.unhold &lt;package name&gt;

    pkgs
        A list of packages to unhold. Must be passed as a python list.

    CLI Example:

    .. code-block:: bash

        salt '*' pkg.unhold pkgs='[&quot;foo&quot;, &quot;bar&quot;]'
    &quot;&quot;&quot;
    if not name and not pkgs and not sources:
        raise SaltInvocationError(&quot;One of name, pkgs, or sources must be specified.&quot;)
    if pkgs and sources:
        raise SaltInvocationError(&quot;Only one of pkgs or sources can be specified.&quot;)

    targets = []
    if pkgs:
        targets.extend(pkgs)
    elif sources:
        for source in sources:
            targets.append(next(iter(source)))
    else:
        targets.append(name)

    ret = {}
    pinned = _list_pinned()
    installed = list_pkgs()
    for target in targets:
        if isinstance(target, dict):
            target = next(iter(target))

        ret[target] = {&quot;name&quot;: target, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

        if target not in installed:
            ret[target][&quot;comment&quot;] = &quot;Package {} does not have a state.&quot;.format(target)
        elif target in pinned:
            if &quot;test&quot; in __opts__ and __opts__[&quot;test&quot;]:
                ret[target].update(result=None)
                ret[target][&quot;comment&quot;] = &quot;Package {} is set to be unheld.&quot;.format(
                    target
                )
            else:
                result = _unpin(target)
                if result:
                    changes = {&quot;old&quot;: &quot;hold&quot;, &quot;new&quot;: &quot;install&quot;}
                    ret[target].update(changes=changes, result=True)
                    ret[target][
                        &quot;comment&quot;
                    ] = &quot;Package {} is no longer being held.&quot;.format(target)
                else:
                    ret[target].update(result=False)
                    ret[target][&quot;comment&quot;] = &quot;Unable to unhold package {}.&quot;.format(
                        target
                    )
        else:
            ret[target].update(result=True)
            ret[target][&quot;comment&quot;] = &quot;Package {} is already set not to be held.&quot;.format(
                target
            )
    return ret


unpin = unhold
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>postgres_2.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Module to provide Postgres compatibility to salt.

:configuration: In order to connect to Postgres, certain configuration is
    required in /etc/salt/minion on the relevant minions. Some sample configs
    might look like::

        postgres.host: 'localhost'
        postgres.port: '5432'
        postgres.user: 'postgres' -&gt; db user
        postgres.pass: ''
        postgres.maintenance_db: 'postgres'

    The default for the maintenance_db is 'postgres' and in most cases it can
    be left at the default setting.
    This data can also be passed into pillar. Options passed into opts will
    overwrite options passed into pillar

:note: This module uses MD5 hashing which may not be compliant with certain
    security audits.

:note: When installing postgres from the official postgres repos, on certain
    linux distributions, either the psql or the initdb binary is *not*
    automatically placed on the path. Add a configuration to the location
    of the postgres bin's path to the relevant minion for this module::

        postgres.bins_dir: '/usr/pgsql-9.5/bin/'
&quot;&quot;&quot;

# This pylint error is popping up where there are no colons?
# pylint: disable=E8203


import base64
import datetime
import hashlib
import hmac
import io
import logging
import os
import pipes
import re
import tempfile

import salt.utils.files
import salt.utils.itertools
import salt.utils.odict
import salt.utils.path
import salt.utils.stringutils
from salt.exceptions import CommandExecutionError, SaltInvocationError
from salt.ext.saslprep import saslprep
from salt.utils.versions import LooseVersion as _LooseVersion

try:
    import csv

    HAS_CSV = True
except ImportError:
    HAS_CSV = False

try:
    from secrets import token_bytes
except ImportError:
    # python &lt;3.6
    from os import urandom as token_bytes

log = logging.getLogger(__name__)


_DEFAULT_PASSWORDS_ENCRYPTION = &quot;md5&quot;
_EXTENSION_NOT_INSTALLED = &quot;EXTENSION NOT INSTALLED&quot;
_EXTENSION_INSTALLED = &quot;EXTENSION INSTALLED&quot;
_EXTENSION_TO_UPGRADE = &quot;EXTENSION TO UPGRADE&quot;
_EXTENSION_TO_MOVE = &quot;EXTENSION TO MOVE&quot;
_EXTENSION_FLAGS = (
    _EXTENSION_NOT_INSTALLED,
    _EXTENSION_INSTALLED,
    _EXTENSION_TO_UPGRADE,
    _EXTENSION_TO_MOVE,
)
_PRIVILEGES_MAP = {
    &quot;a&quot;: &quot;INSERT&quot;,
    &quot;C&quot;: &quot;CREATE&quot;,
    &quot;D&quot;: &quot;TRUNCATE&quot;,
    &quot;c&quot;: &quot;CONNECT&quot;,
    &quot;t&quot;: &quot;TRIGGER&quot;,
    &quot;r&quot;: &quot;SELECT&quot;,
    &quot;U&quot;: &quot;USAGE&quot;,
    &quot;T&quot;: &quot;TEMPORARY&quot;,
    &quot;w&quot;: &quot;UPDATE&quot;,
    &quot;X&quot;: &quot;EXECUTE&quot;,
    &quot;x&quot;: &quot;REFERENCES&quot;,
    &quot;d&quot;: &quot;DELETE&quot;,
    &quot;*&quot;: &quot;GRANT&quot;,
}
_PRIVILEGES_OBJECTS = frozenset(
    (
        &quot;schema&quot;,
        &quot;tablespace&quot;,
        &quot;language&quot;,
        &quot;sequence&quot;,
        &quot;table&quot;,
        &quot;group&quot;,
        &quot;database&quot;,
        &quot;function&quot;,
    )
)
_PRIVILEGE_TYPE_MAP = {
    &quot;table&quot;: &quot;arwdDxt&quot;,
    &quot;tablespace&quot;: &quot;C&quot;,
    &quot;language&quot;: &quot;U&quot;,
    &quot;sequence&quot;: &quot;rwU&quot;,
    &quot;schema&quot;: &quot;UC&quot;,
    &quot;database&quot;: &quot;CTc&quot;,
    &quot;function&quot;: &quot;X&quot;,
}


def __virtual__():
    &quot;&quot;&quot;
    Only load this module if the psql bin exist.
    initdb bin might also be used, but its presence will be detected on runtime.
    &quot;&quot;&quot;
    utils = [&quot;psql&quot;]
    if not HAS_CSV:
        return False
    for util in utils:
        if not salt.utils.path.which(util):
            if not _find_pg_binary(util):
                return (False, &quot;{} was not found&quot;.format(util))
    return True


def _find_pg_binary(util):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.2

    Helper function to locate various psql related binaries
    &quot;&quot;&quot;
    pg_bin_dir = __salt__[&quot;config.option&quot;](&quot;postgres.bins_dir&quot;)
    util_bin = salt.utils.path.which(util)
    if not util_bin:
        if pg_bin_dir:
            return salt.utils.path.which(os.path.join(pg_bin_dir, util))
    else:
        return util_bin


def _run_psql(cmd, runas=None, password=None, host=None, port=None, user=None):
    &quot;&quot;&quot;
    Helper function to call psql, because the password requirement
    makes this too much code to be repeated in each function below
    &quot;&quot;&quot;
    kwargs = {
        &quot;reset_system_locale&quot;: False,
        &quot;clean_env&quot;: True,
    }
    if runas is None:
        if not host:
            host = __salt__[&quot;config.option&quot;](&quot;postgres.host&quot;)
        if not host or host.startswith(&quot;/&quot;):
            if &quot;FreeBSD&quot; in __grains__[&quot;os_family&quot;]:
                runas = &quot;postgres&quot;
            elif &quot;OpenBSD&quot; in __grains__[&quot;os_family&quot;]:
                runas = &quot;_postgresql&quot;
            else:
                runas = &quot;postgres&quot;

    if user is None:
        user = runas

    if runas:
        kwargs[&quot;runas&quot;] = runas

    if password is None:
        password = __salt__[&quot;config.option&quot;](&quot;postgres.pass&quot;)
    if password is not None:
        pgpassfile = salt.utils.files.mkstemp(text=True)
        with salt.utils.files.fopen(pgpassfile, &quot;w&quot;) as fp_:
            fp_.write(
                salt.utils.stringutils.to_str(
                    &quot;{}:{}:*:{}:{}&quot;.format(
                        &quot;localhost&quot; if not host or host.startswith(&quot;/&quot;) else host,
                        port if port else &quot;*&quot;,
                        user if user else &quot;*&quot;,
                        password,
                    )
                )
            )
            __salt__[&quot;file.chown&quot;](pgpassfile, runas, &quot;&quot;)
            kwargs[&quot;env&quot;] = {&quot;PGPASSFILE&quot;: pgpassfile}

    ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False, **kwargs)

    if ret.get(&quot;retcode&quot;, 0) != 0:
        log.error(&quot;Error connecting to Postgresql server&quot;)
    if password is not None and not __salt__[&quot;file.remove&quot;](pgpassfile):
        log.warning(&quot;Remove PGPASSFILE failed&quot;)

    return ret


def _run_initdb(
    name,
    auth=&quot;password&quot;,
    user=None,
    password=None,
    encoding=&quot;UTF8&quot;,
    locale=None,
    runas=None,
    waldir=None,
    checksums=False,
):
    &quot;&quot;&quot;
    Helper function to call initdb
    &quot;&quot;&quot;
    if runas is None:
        if &quot;FreeBSD&quot; in __grains__[&quot;os_family&quot;]:
            runas = &quot;postgres&quot;
        elif &quot;OpenBSD&quot; in __grains__[&quot;os_family&quot;]:
            runas = &quot;_postgresql&quot;
        else:
            runas = &quot;postgres&quot;

    if user is None:
        user = runas
    _INITDB_BIN = _find_pg_binary(&quot;initdb&quot;)
    if not _INITDB_BIN:
        raise CommandExecutionError(&quot;initdb executable not found.&quot;)
    cmd = [
        _INITDB_BIN,
        &quot;--pgdata={}&quot;.format(name),
        &quot;--username={}&quot;.format(user),
        &quot;--auth={}&quot;.format(auth),
        &quot;--encoding={}&quot;.format(encoding),
    ]

    if locale is not None:
        cmd.append(&quot;--locale={}&quot;.format(locale))

    # intentionally use short option, as the long option name has been
    # renamed from &quot;xlogdir&quot; to &quot;waldir&quot; in PostgreSQL 10
    if waldir is not None:
        cmd.append(&quot;-X&quot;)
        cmd.append(waldir)

    if checksums:
        cmd.append(&quot;--data-checksums&quot;)

    if password is not None:
        pgpassfile = salt.utils.files.mkstemp(text=True)
        with salt.utils.files.fopen(pgpassfile, &quot;w&quot;) as fp_:
            fp_.write(salt.utils.stringutils.to_str(&quot;{}&quot;.format(password)))
            __salt__[&quot;file.chown&quot;](pgpassfile, runas, &quot;&quot;)
        cmd.extend([&quot;--pwfile={}&quot;.format(pgpassfile)])

    kwargs = dict(runas=runas, clean_env=True)
    cmdstr = &quot; &quot;.join([pipes.quote(c) for c in cmd])
    ret = __salt__[&quot;cmd.run_all&quot;](cmdstr, python_shell=False, **kwargs)

    if ret.get(&quot;retcode&quot;, 0) != 0:
        log.error(&quot;Error initilizing the postgres data directory&quot;)

    if password is not None and not __salt__[&quot;file.remove&quot;](pgpassfile):
        log.warning(&quot;Removal of PGPASSFILE failed&quot;)

    return ret


def version(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    &quot;&quot;&quot;
    Return the version of a Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.version
    &quot;&quot;&quot;
    query = &quot;SELECT setting FROM pg_catalog.pg_settings WHERE name = 'server_version'&quot;
    cmd = _psql_cmd(
        &quot;-c&quot;,
        query,
        &quot;-t&quot;,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    ret = _run_psql(
        cmd, runas=runas, password=password, host=host, port=port, user=user
    )

    for line in salt.utils.itertools.split(ret[&quot;stdout&quot;], &quot;\n&quot;):
        # Just return the first line
        return line


def _parsed_version(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    &quot;&quot;&quot;
    Returns the server version properly parsed and int casted for internal use.

    If the Postgres server does not respond, None will be returned.
    &quot;&quot;&quot;

    psql_version = version(
        user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )

    if psql_version:
        return _LooseVersion(psql_version)
    else:
        log.warning(
            &quot;Attempt to parse version of Postgres server failed. &quot;
            &quot;Is the server responding?&quot;
        )
        return None


def _connection_defaults(user=None, host=None, port=None, maintenance_db=None):
    &quot;&quot;&quot;
    Returns a tuple of (user, host, port, db) with config, pillar, or default
    values assigned to missing values.
    &quot;&quot;&quot;
    if not user:
        user = __salt__[&quot;config.option&quot;](&quot;postgres.user&quot;)
    if not host:
        host = __salt__[&quot;config.option&quot;](&quot;postgres.host&quot;)
    if not port:
        port = __salt__[&quot;config.option&quot;](&quot;postgres.port&quot;)
    if not maintenance_db:
        maintenance_db = __salt__[&quot;config.option&quot;](&quot;postgres.maintenance_db&quot;)

    return (user, host, port, maintenance_db)


def _psql_cmd(*args, **kwargs):
    &quot;&quot;&quot;
    Return string with fully composed psql command.

    Accepts optional keyword arguments: user, host, port and maintenance_db,
    as well as any number of positional arguments to be added to the end of
    the command.
    &quot;&quot;&quot;
    (user, host, port, maintenance_db) = _connection_defaults(
        kwargs.get(&quot;user&quot;),
        kwargs.get(&quot;host&quot;),
        kwargs.get(&quot;port&quot;),
        kwargs.get(&quot;maintenance_db&quot;),
    )
    _PSQL_BIN = _find_pg_binary(&quot;psql&quot;)
    cmd = [
        _PSQL_BIN,
        &quot;--no-align&quot;,
        &quot;--no-readline&quot;,
        &quot;--no-psqlrc&quot;,
        &quot;--no-password&quot;,
    ]  # Never prompt, handled in _run_psql.
    if user:
        cmd += [&quot;--username&quot;, user]
    if host:
        cmd += [&quot;--host&quot;, host]
    if port:
        cmd += [&quot;--port&quot;, str(port)]
    if not maintenance_db:
        maintenance_db = &quot;postgres&quot;
    cmd.extend([&quot;--dbname&quot;, maintenance_db])
    cmd.extend(args)
    return cmd


def _psql_prepare_and_run(
    cmd, host=None, port=None, maintenance_db=None, password=None, runas=None, user=None
):
    rcmd = _psql_cmd(
        host=host, user=user, port=port, maintenance_db=maintenance_db, *cmd
    )
    cmdret = _run_psql(
        rcmd, runas=runas, password=password, host=host, port=port, user=user
    )
    return cmdret


def psql_query(
    query,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
    write=False,
):
    &quot;&quot;&quot;
    Run an SQL-Query and return the results as a list. This command
    only supports SELECT statements.  This limitation can be worked around
    with a query like this:

    WITH updated AS (UPDATE pg_authid SET rolconnlimit = 2000 WHERE
    rolname = 'rolename' RETURNING rolconnlimit) SELECT * FROM updated;

    query
        The query string.

    user
        Database username, if different from config or default.

    host
        Database host, if different from config or default.

    port
        Database port, if different from the config or default.

    maintenance_db
        The database to run the query against.

    password
        User password, if different from the config or default.

    runas
        User to run the command as.

    write
        Mark query as READ WRITE transaction.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.psql_query 'select * from pg_stat_activity'
    &quot;&quot;&quot;
    ret = []

    csv_query = &quot;COPY ({}) TO STDOUT WITH CSV HEADER&quot;.format(query.strip().rstrip(&quot;;&quot;))

    # Mark transaction as R/W to achieve write will be allowed
    # Commit is necessary due to transaction
    if write:
        csv_query = &quot;START TRANSACTION READ WRITE; {}; COMMIT TRANSACTION;&quot;.format(
            csv_query
        )

    # always use the same datestyle settings to allow parsing dates
    # regardless what server settings are configured
    cmdret = _psql_prepare_and_run(
        [&quot;-v&quot;, &quot;datestyle=ISO,MDY&quot;, &quot;-c&quot;, csv_query],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    if cmdret[&quot;retcode&quot;] &gt; 0:
        return ret

    csv_file = io.StringIO(cmdret[&quot;stdout&quot;])
    header = {}
    for row in csv.reader(
        csv_file,
        delimiter=salt.utils.stringutils.to_str(&quot;,&quot;),
        quotechar=salt.utils.stringutils.to_str('&quot;'),
    ):
        if not row:
            continue
        if not header:
            header = row
            continue
        ret.append(dict(zip(header, row)))

    # Remove 'COMMIT' message if query is inside R/W transction
    if write:
        ret = ret[0:-1]

    return ret


# Database related actions


def db_list(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    &quot;&quot;&quot;
    Return dictionary with information about databases of a Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.db_list
    &quot;&quot;&quot;

    ret = {}

    query = (
        'SELECT datname as &quot;Name&quot;, pga.rolname as &quot;Owner&quot;, '
        'pg_encoding_to_char(encoding) as &quot;Encoding&quot;, '
        'datcollate as &quot;Collate&quot;, datctype as &quot;Ctype&quot;, '
        'datacl as &quot;Access privileges&quot;, spcname as &quot;Tablespace&quot; '
        &quot;FROM pg_database pgd, pg_roles pga, pg_tablespace pgts &quot;
        &quot;WHERE pga.oid = pgd.datdba AND pgts.oid = pgd.dattablespace&quot;
    )

    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    for row in rows:
        ret[row[&quot;Name&quot;]] = row
        ret[row[&quot;Name&quot;]].pop(&quot;Name&quot;)

    return ret


def db_exists(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Checks if a database exists on the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.db_exists 'dbname'
    &quot;&quot;&quot;

    databases = db_list(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return name in databases


# TODO properly implemented escaping
def _quote_ddl_value(value, quote=&quot;'&quot;):
    if value is None:
        return None
    if quote in value:  # detect trivial sqli
        raise SaltInvocationError(
            &quot;Unsupported character {} in value: {}&quot;.format(quote, value)
        )
    return &quot;{quote}{value}{quote}&quot;.format(quote=quote, value=value)


def db_create(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    tablespace=None,
    encoding=None,
    lc_collate=None,
    lc_ctype=None,
    owner=None,
    template=None,
    runas=None,
):
    &quot;&quot;&quot;
    Adds a databases to the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.db_create 'dbname'

        salt '*' postgres.db_create 'dbname' template=template_postgis

    &quot;&quot;&quot;

    # Base query to create a database
    query = 'CREATE DATABASE &quot;{}&quot;'.format(name)

    # &quot;With&quot;-options to create a database
    with_args = salt.utils.odict.OrderedDict(
        [
            (&quot;TABLESPACE&quot;, _quote_ddl_value(tablespace, '&quot;')),
            # owner needs to be enclosed in double quotes so postgres
            # doesn't get thrown by dashes in the name
            (&quot;OWNER&quot;, _quote_ddl_value(owner, '&quot;')),
            (&quot;TEMPLATE&quot;, template),
            (&quot;ENCODING&quot;, _quote_ddl_value(encoding)),
            (&quot;LC_COLLATE&quot;, _quote_ddl_value(lc_collate)),
            (&quot;LC_CTYPE&quot;, _quote_ddl_value(lc_ctype)),
        ]
    )
    with_chunks = []
    for key, value in with_args.items():
        if value is not None:
            with_chunks += [key, &quot;=&quot;, value]
    # Build a final query
    if with_chunks:
        with_chunks.insert(0, &quot; WITH&quot;)
        query += &quot; &quot;.join(with_chunks)

    # Execute the command
    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return ret[&quot;retcode&quot;] == 0


def db_alter(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    tablespace=None,
    owner=None,
    owner_recurse=False,
    runas=None,
):
    &quot;&quot;&quot;
    Change tablespace or/and owner of database.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.db_alter dbname owner=otheruser
    &quot;&quot;&quot;
    if not any((tablespace, owner)):
        return True  # Nothing todo?

    if owner and owner_recurse:
        ret = owner_to(
            name, owner, user=user, host=host, port=port, password=password, runas=runas
        )
    else:
        queries = []
        if owner:
            queries.append('ALTER DATABASE &quot;{}&quot; OWNER TO &quot;{}&quot;'.format(name, owner))
        if tablespace:
            queries.append(
                'ALTER DATABASE &quot;{}&quot; SET TABLESPACE &quot;{}&quot;'.format(name, tablespace)
            )
        for query in queries:
            ret = _psql_prepare_and_run(
                [&quot;-c&quot;, query],
                user=user,
                host=host,
                port=port,
                maintenance_db=maintenance_db,
                password=password,
                runas=runas,
            )

    if ret[&quot;retcode&quot;] != 0:
        return False

    return True


def db_remove(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Removes a databases from the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.db_remove 'dbname'
    &quot;&quot;&quot;
    for query in [
        'REVOKE CONNECT ON DATABASE &quot;{db}&quot; FROM public;'.format(db=name),
        &quot;SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname =&quot;
        &quot; '{db}' AND pid &lt;&gt; pg_backend_pid();&quot;.format(db=name),
        'DROP DATABASE &quot;{db}&quot;;'.format(db=name),
    ]:
        ret = _psql_prepare_and_run(
            [&quot;-c&quot;, query],
            user=user,
            host=host,
            port=port,
            runas=runas,
            maintenance_db=maintenance_db,
            password=password,
        )
        if ret[&quot;retcode&quot;] != 0:
            raise Exception(&quot;Failed: ret={}&quot;.format(ret))
    return True


# Tablespace related actions


def tablespace_list(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    &quot;&quot;&quot;
    Return dictionary with information about tablespaces of a Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.tablespace_list

    .. versionadded:: 2015.8.0
    &quot;&quot;&quot;

    ret = {}

    query = (
        'SELECT spcname as &quot;Name&quot;, pga.rolname as &quot;Owner&quot;, spcacl as &quot;ACL&quot;, '
        'spcoptions as &quot;Opts&quot;, pg_tablespace_location(pgts.oid) as &quot;Location&quot; '
        &quot;FROM pg_tablespace pgts, pg_roles pga WHERE pga.oid = pgts.spcowner&quot;
    )

    rows = __salt__[&quot;postgres.psql_query&quot;](
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    for row in rows:
        ret[row[&quot;Name&quot;]] = row
        ret[row[&quot;Name&quot;]].pop(&quot;Name&quot;)

    return ret


def tablespace_exists(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Checks if a tablespace exists on the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.tablespace_exists 'dbname'

    .. versionadded:: 2015.8.0
    &quot;&quot;&quot;

    tablespaces = tablespace_list(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return name in tablespaces


def tablespace_create(
    name,
    location,
    options=None,
    owner=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Adds a tablespace to the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.tablespace_create tablespacename '/path/datadir'

    .. versionadded:: 2015.8.0
    &quot;&quot;&quot;
    owner_query = &quot;&quot;
    options_query = &quot;&quot;
    if owner:
        owner_query = 'OWNER &quot;{}&quot;'.format(owner)
        # should come out looking like: 'OWNER postgres'
    if options:
        optionstext = [&quot;{} = {}&quot;.format(k, v) for k, v in options.items()]
        options_query = &quot;WITH ( {} )&quot;.format(&quot;, &quot;.join(optionstext))
        # should come out looking like: 'WITH ( opt1 = 1.0, opt2 = 4.0 )'
    query = &quot;CREATE TABLESPACE \&quot;{}\&quot; {} LOCATION '{}' {}&quot;.format(
        name, owner_query, location, options_query
    )

    # Execute the command
    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return ret[&quot;retcode&quot;] == 0


def tablespace_alter(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    new_name=None,
    new_owner=None,
    set_option=None,
    reset_option=None,
    runas=None,
):
    &quot;&quot;&quot;
    Change tablespace name, owner, or options.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.tablespace_alter tsname new_owner=otheruser
        salt '*' postgres.tablespace_alter index_space new_name=fast_raid
        salt '*' postgres.tablespace_alter test set_option=&quot;{'seq_page_cost': '1.1'}&quot;
        salt '*' postgres.tablespace_alter tsname reset_option=seq_page_cost

    .. versionadded:: 2015.8.0
    &quot;&quot;&quot;
    if not any([new_name, new_owner, set_option, reset_option]):
        return True  # Nothing todo?

    queries = []

    if new_name:
        queries.append('ALTER TABLESPACE &quot;{}&quot; RENAME TO &quot;{}&quot;'.format(name, new_name))
    if new_owner:
        queries.append('ALTER TABLESPACE &quot;{}&quot; OWNER TO &quot;{}&quot;'.format(name, new_owner))
    if set_option:
        queries.append(
            'ALTER TABLESPACE &quot;{}&quot; SET ({} = {})'.format(
                name, *(next(iter(set_option.items())))
            )
        )
    if reset_option:
        queries.append('ALTER TABLESPACE &quot;{}&quot; RESET ({})'.format(name, reset_option))

    for query in queries:
        ret = _psql_prepare_and_run(
            [&quot;-c&quot;, query],
            user=user,
            host=host,
            port=port,
            maintenance_db=maintenance_db,
            password=password,
            runas=runas,
        )
        if ret[&quot;retcode&quot;] != 0:
            return False

    return True


def tablespace_remove(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Removes a tablespace from the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.tablespace_remove tsname

    .. versionadded:: 2015.8.0
    &quot;&quot;&quot;
    query = 'DROP TABLESPACE &quot;{}&quot;'.format(name)
    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, query],
        user=user,
        host=host,
        port=port,
        runas=runas,
        maintenance_db=maintenance_db,
        password=password,
    )
    return ret[&quot;retcode&quot;] == 0


# User related actions


def user_list(
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
    return_password=False,
):
    &quot;&quot;&quot;
    Return a dict with information about users of a Postgres server.

    Set return_password to True to get password hash in the result.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.user_list
    &quot;&quot;&quot;

    ret = {}

    ver = _parsed_version(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if ver:
        if ver &gt;= _LooseVersion(&quot;9.1&quot;):
            replication_column = &quot;pg_roles.rolreplication&quot;
        else:
            replication_column = &quot;NULL&quot;
        if ver &gt;= _LooseVersion(&quot;9.5&quot;):
            rolcatupdate_column = &quot;NULL&quot;
        else:
            rolcatupdate_column = &quot;pg_roles.rolcatupdate&quot;
    else:
        log.error(&quot;Could not retrieve Postgres version. Is Postgresql server running?&quot;)
        return False

    # will return empty string if return_password = False
    _x = lambda s: s if return_password else &quot;&quot;

    query = &quot;&quot;.join(
        [
            'SELECT pg_roles.rolname as &quot;name&quot;,pg_roles.rolsuper as &quot;superuser&quot;,'
            ' pg_roles.rolinherit as &quot;inherits privileges&quot;, pg_roles.rolcreaterole as'
            ' &quot;can create roles&quot;, pg_roles.rolcreatedb as &quot;can create databases&quot;, {0}'
            ' as &quot;can update system catalogs&quot;, pg_roles.rolcanlogin as &quot;can login&quot;, {1}'
            ' as &quot;replication&quot;, pg_roles.rolconnlimit as &quot;connections&quot;, (SELECT'
            &quot; array_agg(pg_roles2.rolname)    FROM pg_catalog.pg_auth_members    JOIN&quot;
            &quot; pg_catalog.pg_roles pg_roles2 ON (pg_auth_members.roleid = pg_roles2.oid)&quot;
            &quot;    WHERE pg_auth_members.member = pg_roles.oid) as&quot;
            ' &quot;groups&quot;,pg_roles.rolvaliduntil::timestamp(0) as &quot;expiry time&quot;,'
            ' pg_roles.rolconfig  as &quot;defaults variables&quot; ',
            _x(', COALESCE(pg_shadow.passwd, pg_authid.rolpassword) as &quot;password&quot; '),
            &quot;FROM pg_roles &quot;,
            _x(&quot;LEFT JOIN pg_authid ON pg_roles.oid = pg_authid.oid &quot;),
            _x(&quot;LEFT JOIN pg_shadow ON pg_roles.oid = pg_shadow.usesysid&quot;),
        ]
    ).format(rolcatupdate_column, replication_column)

    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    def get_bool(rowdict, key):
        &quot;&quot;&quot;
        Returns the boolean value of the key, instead of 't' and 'f' strings.
        &quot;&quot;&quot;
        if rowdict[key] == &quot;t&quot;:
            return True
        elif rowdict[key] == &quot;f&quot;:
            return False
        else:
            return None

    for row in rows:
        retrow = {}
        for key in (
            &quot;superuser&quot;,
            &quot;inherits privileges&quot;,
            &quot;can create roles&quot;,
            &quot;can create databases&quot;,
            &quot;can update system catalogs&quot;,
            &quot;can login&quot;,
            &quot;replication&quot;,
            &quot;connections&quot;,
        ):
            retrow[key] = get_bool(row, key)
        for date_key in (&quot;expiry time&quot;,):
            try:
                retrow[date_key] = datetime.datetime.strptime(
                    row[date_key], &quot;%Y-%m-%d %H:%M:%S&quot;
                )
            except ValueError:
                retrow[date_key] = None
        retrow[&quot;defaults variables&quot;] = row[&quot;defaults variables&quot;]
        if return_password:
            retrow[&quot;password&quot;] = row[&quot;password&quot;]
        # use csv reader to handle quoted roles correctly
        retrow[&quot;groups&quot;] = list(csv.reader([row[&quot;groups&quot;].strip(&quot;{}&quot;)]))[0]
        ret[row[&quot;name&quot;]] = retrow

    return ret


def role_get(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
    return_password=False,
):
    &quot;&quot;&quot;
    Return a dict with information about users of a Postgres server.

    Set return_password to True to get password hash in the result.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.role_get postgres
    &quot;&quot;&quot;
    all_users = user_list(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
        return_password=return_password,
    )
    try:
        return all_users.get(name, None)
    except AttributeError:
        log.error(&quot;Could not retrieve Postgres role. Is Postgres running?&quot;)
        return None


def user_exists(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Checks if a user exists on the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.user_exists 'username'
    &quot;&quot;&quot;
    return bool(
        role_get(
            name,
            user=user,
            host=host,
            port=port,
            maintenance_db=maintenance_db,
            password=password,
            runas=runas,
            return_password=False,
        )
    )


def _add_role_flag(string, test, flag, cond=None, prefix=&quot;NO&quot;, addtxt=&quot;&quot;, skip=False):
    if not skip:
        if cond is None:
            cond = test
        if test is not None:
            if cond:
                string = &quot;{} {}&quot;.format(string, flag)
            else:
                string = &quot;{0} {2}{1}&quot;.format(string, flag, prefix)
        if addtxt:
            string = &quot;{} {}&quot;.format(string, addtxt)
    return string


def _maybe_encrypt_password(role, password, encrypted=_DEFAULT_PASSWORDS_ENCRYPTION):
    if password is not None:
        password = str(password)
    else:
        return None

    if encrypted is True:
        encrypted = &quot;md5&quot;
    if encrypted not in (False, &quot;md5&quot;, &quot;scram-sha-256&quot;):
        raise ValueError(&quot;Unknown password algorithm: &quot; + str(encrypted))

    if encrypted == &quot;scram-sha-256&quot; and not password.startswith(&quot;SCRAM-SHA-256&quot;):
        password = _scram_sha_256(password)
    elif encrypted == &quot;md5&quot; and not password.startswith(&quot;md5&quot;):
        log.warning(&quot;The md5 password algorithm was deprecated in PostgreSQL 10&quot;)
        password = _md5_password(role, password)
    elif encrypted is False:
        log.warning(&quot;Unencrypted passwords were removed in PostgreSQL 10&quot;)

    return password


def _verify_password(role, password, verifier, method):
    &quot;&quot;&quot;
    Test the given password against the verifier.

    The given password may already be a verifier, in which case test for
     simple equality.
    &quot;&quot;&quot;
    if method == &quot;md5&quot; or method is True:
        if password.startswith(&quot;md5&quot;):
            expected = password
        else:
            expected = _md5_password(role, password)
    elif method == &quot;scram-sha-256&quot;:
        if password.startswith(&quot;SCRAM-SHA-256&quot;):
            expected = password
        else:
            match = re.match(r&quot;^SCRAM-SHA-256\$(\d+):([^\$]+?)\$&quot;, verifier)
            if match:
                iterations = int(match.group(1))
                salt_bytes = base64.b64decode(match.group(2))
                expected = _scram_sha_256(
                    password, salt_bytes=salt_bytes, iterations=iterations
                )
            else:
                expected = object()
    elif method is False:
        expected = password
    else:
        expected = object()

    return verifier == expected


def _md5_password(role, password):
    return &quot;md5{}&quot;.format(
        hashlib.md5(
            salt.utils.stringutils.to_bytes(&quot;{}{}&quot;.format(password, role))
        ).hexdigest()
    )


def _scram_sha_256(password, salt_bytes=None, iterations=4096):
    &quot;&quot;&quot;
    Build a SCRAM-SHA-256 password verifier.

<A NAME="0"></A>    Ported from https://doxygen.postgresql.org/scram-common_8c.html
    &quot;&quot;&quot;
    if salt_bytes is None:
        salt_bytes = token_bytes<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match286285-0.html#0',2,'match286285-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(16)
    password = salt.utils.stringutils.to_bytes(saslprep(password))
    salted_password = hashlib.pbkdf2_hmac(&quot;sha256&quot;, password, salt_bytes, iterations)
    stored_key =</B></FONT> hmac.new(salted_password, b&quot;Client Key&quot;, &quot;sha256&quot;).digest()
    stored_key = hashlib.sha256(stored_key).digest()
    server_key = hmac.new(salted_password, b&quot;Server Key&quot;, &quot;sha256&quot;).digest()
    return &quot;SCRAM-SHA-256${}:{}${}:{}&quot;.format(
        iterations,
        base64.b64encode(salt_bytes).decode(&quot;ascii&quot;),
        base64.b64encode(stored_key).decode(&quot;ascii&quot;),
        base64.b64encode(server_key).decode(&quot;ascii&quot;),
    )


def _role_cmd_args(
    name,
    sub_cmd=&quot;&quot;,
    typ_=&quot;role&quot;,
    encrypted=None,
    login=None,
    connlimit=None,
    inherit=None,
    createdb=None,
    createroles=None,
    superuser=None,
    groups=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    db_role=None,
):
    if inherit is None:
        if typ_ in [&quot;user&quot;, &quot;group&quot;]:
            inherit = True
    if login is None:
        if typ_ == &quot;user&quot;:
            login = True
        if typ_ == &quot;group&quot;:
            login = False
    # defaults to encrypted passwords
    if encrypted is None:
        encrypted = _DEFAULT_PASSWORDS_ENCRYPTION
    skip_passwd = False
    escaped_password = &quot;&quot;
    escaped_valid_until = &quot;&quot;
    if not (
        rolepassword is not None
        # first is passwd set
        # second is for handling NOPASSWD
        and (isinstance(rolepassword, str) and bool(rolepassword))
        or (isinstance(rolepassword, bool))
    ):
        skip_passwd = True
    if isinstance(rolepassword, str) and bool(rolepassword):
        escaped_password = &quot;'{}'&quot;.format(
            _maybe_encrypt_password(
                name, rolepassword.replace(&quot;'&quot;, &quot;''&quot;), encrypted=encrypted
            )
        )
    if isinstance(valid_until, str) and bool(valid_until):
        escaped_valid_until = &quot;'{}'&quot;.format(
            valid_until.replace(&quot;'&quot;, &quot;''&quot;),
        )
    skip_superuser = False
    if bool(db_role) and bool(superuser) == bool(db_role[&quot;superuser&quot;]):
        skip_superuser = True
    flags = (
        {&quot;flag&quot;: &quot;INHERIT&quot;, &quot;test&quot;: inherit},
        {&quot;flag&quot;: &quot;CREATEDB&quot;, &quot;test&quot;: createdb},
        {&quot;flag&quot;: &quot;CREATEROLE&quot;, &quot;test&quot;: createroles},
        {&quot;flag&quot;: &quot;SUPERUSER&quot;, &quot;test&quot;: superuser, &quot;skip&quot;: skip_superuser},
        {&quot;flag&quot;: &quot;REPLICATION&quot;, &quot;test&quot;: replication},
        {&quot;flag&quot;: &quot;LOGIN&quot;, &quot;test&quot;: login},
        {
            &quot;flag&quot;: &quot;CONNECTION LIMIT&quot;,
            &quot;test&quot;: bool(connlimit),
            &quot;addtxt&quot;: str(connlimit),
            &quot;skip&quot;: connlimit is None,
        },
        {
            &quot;flag&quot;: &quot;ENCRYPTED&quot;,
            &quot;test&quot;: (encrypted is not None and bool(rolepassword)),
            &quot;skip&quot;: skip_passwd or isinstance(rolepassword, bool),
            &quot;cond&quot;: bool(encrypted),
            &quot;prefix&quot;: &quot;UN&quot;,
        },
        {
            &quot;flag&quot;: &quot;PASSWORD&quot;,
            &quot;test&quot;: bool(rolepassword),
            &quot;skip&quot;: skip_passwd,
            &quot;addtxt&quot;: escaped_password,
        },
        {
            &quot;flag&quot;: &quot;VALID UNTIL&quot;,
            &quot;test&quot;: bool(valid_until),
            &quot;skip&quot;: valid_until is None,
            &quot;addtxt&quot;: escaped_valid_until,
        },
    )
    for data in flags:
        sub_cmd = _add_role_flag(sub_cmd, **data)
    if sub_cmd.endswith(&quot;WITH&quot;):
        sub_cmd = sub_cmd.replace(&quot; WITH&quot;, &quot;&quot;)
    if groups:
        if isinstance(groups, list):
            groups = &quot;,&quot;.join(groups)
        for group in groups.split(&quot;,&quot;):
            sub_cmd = '{}; GRANT &quot;{}&quot; TO &quot;{}&quot;'.format(sub_cmd, group, name)
    return sub_cmd


def _role_create(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    superuser=None,
    login=None,
    connlimit=None,
    inherit=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    typ_=&quot;role&quot;,
    groups=None,
    runas=None,
):
    &quot;&quot;&quot;
    Creates a Postgres role. Users and Groups are both roles in postgres.
    However, users can login, groups cannot.
    &quot;&quot;&quot;

    # check if role exists
    if user_exists(
        name, user, host, port, maintenance_db, password=password, runas=runas
    ):
        log.info(&quot;%s '%s' already exists&quot;, typ_.capitalize(), name)
        return False

    sub_cmd = 'CREATE ROLE &quot;{}&quot; WITH'.format(name)
    sub_cmd = &quot;{} {}&quot;.format(
        sub_cmd,
        _role_cmd_args(
            name,
            typ_=typ_,
            encrypted=encrypted,
            login=login,
            connlimit=connlimit,
            inherit=inherit,
            createdb=createdb,
            createroles=createroles,
            superuser=superuser,
            groups=groups,
            replication=replication,
            rolepassword=rolepassword,
            valid_until=valid_until,
        ),
    )
    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, sub_cmd],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    return ret[&quot;retcode&quot;] == 0


def user_create(
    username,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    inherit=None,
    login=None,
    connlimit=None,
    encrypted=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    groups=None,
    runas=None,
):
    &quot;&quot;&quot;
    Creates a Postgres user.

    CLI Examples:

    .. code-block:: bash

        salt '*' postgres.user_create 'username' user='user' \\
                host='hostname' port='port' password='password' \\
                rolepassword='rolepassword' valid_until='valid_until'
    &quot;&quot;&quot;
    return _role_create(
        username,
        typ_=&quot;user&quot;,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        createdb=createdb,
        createroles=createroles,
        inherit=inherit,
        login=login,
        connlimit=connlimit,
        encrypted=encrypted,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        valid_until=valid_until,
        groups=groups,
        runas=runas,
    )


def _role_update(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    typ_=&quot;role&quot;,
    createroles=None,
    inherit=None,
    login=None,
    connlimit=None,
    encrypted=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    groups=None,
    runas=None,
):
    &quot;&quot;&quot;
    Updates a postgres role.
    &quot;&quot;&quot;
    role = role_get(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
        return_password=False,
    )

    # check if user exists
    if not bool(role):
        log.info(&quot;%s '%s' could not be found&quot;, typ_.capitalize(), name)
        return False

    sub_cmd = 'ALTER ROLE &quot;{}&quot; WITH'.format(name)
    sub_cmd = &quot;{} {}&quot;.format(
        sub_cmd,
        _role_cmd_args(
            name,
            encrypted=encrypted,
            login=login,
            connlimit=connlimit,
            inherit=inherit,
            createdb=createdb,
            createroles=createroles,
            superuser=superuser,
            groups=groups,
            replication=replication,
            rolepassword=rolepassword,
            valid_until=valid_until,
            db_role=role,
        ),
    )
    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, sub_cmd],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    return ret[&quot;retcode&quot;] == 0


def user_update(
    username,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    superuser=None,
    inherit=None,
    login=None,
    connlimit=None,
    replication=None,
    rolepassword=None,
    valid_until=None,
    groups=None,
    runas=None,
):
    &quot;&quot;&quot;
    Updates a Postgres user.

    CLI Examples:

    .. code-block:: bash

        salt '*' postgres.user_update 'username' user='user' \\
                host='hostname' port='port' password='password' \\
                rolepassword='rolepassword' valid_until='valid_until'
    &quot;&quot;&quot;
    return _role_update(
        username,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        typ_=&quot;user&quot;,
        inherit=inherit,
        login=login,
        connlimit=connlimit,
        createdb=createdb,
        createroles=createroles,
        encrypted=encrypted,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        valid_until=valid_until,
        groups=groups,
        runas=runas,
    )


def _role_remove(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Removes a role from the Postgres Server
    &quot;&quot;&quot;

    # check if user exists
    if not user_exists(
        name, user, host, port, maintenance_db, password=password, runas=runas
    ):
        log.info(&quot;User '%s' does not exist&quot;, name)
        return False

    # user exists, proceed
    sub_cmd = 'DROP ROLE &quot;{}&quot;'.format(name)
    _psql_prepare_and_run(
        [&quot;-c&quot;, sub_cmd],
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    if not user_exists(
        name, user, host, port, maintenance_db, password=password, runas=runas
    ):
        return True
    else:
        log.info(&quot;Failed to delete user '%s'.&quot;, name)
        return False


def available_extensions(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    &quot;&quot;&quot;
    List available postgresql extensions

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.available_extensions

    &quot;&quot;&quot;
    exts = []
    query = &quot;select * from pg_available_extensions();&quot;
    ret = psql_query(
        query,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    exts = {}
    for row in ret:
        if &quot;default_version&quot; in row and &quot;name&quot; in row:
            exts[row[&quot;name&quot;]] = row
    return exts


def installed_extensions(
    user=None, host=None, port=None, maintenance_db=None, password=None, runas=None
):
    &quot;&quot;&quot;
    List installed postgresql extensions

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.installed_extensions

    &quot;&quot;&quot;
    exts = []
    query = (
        &quot;select a.*, b.nspname as schema_name &quot;
        &quot;from pg_extension a,  pg_namespace b where a.extnamespace = b.oid;&quot;
    )
    ret = psql_query(
        query,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    exts = {}
    for row in ret:
        if &quot;extversion&quot; in row and &quot;extname&quot; in row:
            exts[row[&quot;extname&quot;]] = row
    return exts


def get_available_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Get info about an available postgresql extension

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.get_available_extension plpgsql

    &quot;&quot;&quot;
    return available_extensions(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    ).get(name, None)


def get_installed_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Get info about an installed postgresql extension

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.get_installed_extension plpgsql

    &quot;&quot;&quot;
    return installed_extensions(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    ).get(name, None)


def is_available_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Test if a specific extension is available

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.is_available_extension

    &quot;&quot;&quot;
    exts = available_extensions(
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if name.lower() in [a.lower() for a in exts]:
        return True
    return False


def _pg_is_older_ext_ver(a, b):
    &quot;&quot;&quot;
    Compare versions of extensions using salt.utils.versions.LooseVersion.

    Returns ``True`` if version a is lesser than b.
    &quot;&quot;&quot;
    return _LooseVersion(a) &lt; _LooseVersion(b)


def is_installed_extension(
    name,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Test if a specific extension is installed

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.is_installed_extension

    &quot;&quot;&quot;
    installed_ext = get_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    return bool(installed_ext)


def create_metadata(
    name,
    ext_version=None,
    schema=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Get lifecycle information about an extension

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.create_metadata adminpack

    &quot;&quot;&quot;
    installed_ext = get_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    ret = [_EXTENSION_NOT_INSTALLED]
    if installed_ext:
        ret = [_EXTENSION_INSTALLED]
        if ext_version is not None and _pg_is_older_ext_ver(
            installed_ext.get(&quot;extversion&quot;, ext_version), ext_version
        ):
            ret.append(_EXTENSION_TO_UPGRADE)
        if (
            schema is not None
            and installed_ext.get(&quot;extrelocatable&quot;, &quot;f&quot;) == &quot;t&quot;
            and installed_ext.get(&quot;schema_name&quot;, schema) != schema
        ):
            ret.append(_EXTENSION_TO_MOVE)
    return ret


def drop_extension(
    name,
    if_exists=None,
    restrict=None,
    cascade=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Drop an installed postgresql extension

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.drop_extension 'adminpack'

    &quot;&quot;&quot;
    if cascade is None:
        cascade = True
    if if_exists is None:
        if_exists = False
    if restrict is None:
        restrict = False
    args = [&quot;DROP EXTENSION&quot;]
    if if_exists:
        args.append(&quot;IF EXISTS&quot;)
    args.append(name)
    if cascade:
        args.append(&quot;CASCADE&quot;)
    if restrict:
        args.append(&quot;RESTRICT&quot;)
    args.append(&quot;;&quot;)
    cmd = &quot; &quot;.join(args)
    if is_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    ):
        _psql_prepare_and_run(
            [&quot;-c&quot;, cmd],
            runas=runas,
            host=host,
            user=user,
            port=port,
            maintenance_db=maintenance_db,
            password=password,
        )
    ret = not is_installed_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if not ret:
        log.info(&quot;Failed to drop ext: %s&quot;, name)
    return ret


def create_extension(
    name,
    if_not_exists=None,
    schema=None,
    ext_version=None,
    from_version=None,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Install a postgresql extension

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.create_extension 'adminpack'

    &quot;&quot;&quot;
    if if_not_exists is None:
        if_not_exists = True
    mtdata = create_metadata(
        name,
        ext_version=ext_version,
        schema=schema,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    installed = _EXTENSION_NOT_INSTALLED not in mtdata
    installable = is_available_extension(
        name,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    if installable:
        if not installed:
            args = [&quot;CREATE EXTENSION&quot;]
            if if_not_exists:
                args.append(&quot;IF NOT EXISTS&quot;)
            args.append('&quot;{}&quot;'.format(name))
            sargs = []
            if schema:
                sargs.append('SCHEMA &quot;{}&quot;'.format(schema))
            if ext_version:
                sargs.append(&quot;VERSION {}&quot;.format(ext_version))
            if from_version:
                sargs.append(&quot;FROM {}&quot;.format(from_version))
            if sargs:
                args.append(&quot;WITH&quot;)
                args.extend(sargs)
            args.append(&quot;;&quot;)
            cmd = &quot; &quot;.join(args).strip()
        else:
            args = []
            if schema and _EXTENSION_TO_MOVE in mtdata:
                args.append(
                    'ALTER EXTENSION &quot;{}&quot; SET SCHEMA &quot;{}&quot;;'.format(name, schema)
                )
            if ext_version and _EXTENSION_TO_UPGRADE in mtdata:
                args.append(
                    'ALTER EXTENSION &quot;{}&quot; UPDATE TO {};'.format(name, ext_version)
                )
            cmd = &quot; &quot;.join(args).strip()
        if cmd:
            _psql_prepare_and_run(
                [&quot;-c&quot;, cmd],
                runas=runas,
                host=host,
                user=user,
                port=port,
                maintenance_db=maintenance_db,
                password=password,
            )
    mtdata = create_metadata(
        name,
        ext_version=ext_version,
        schema=schema,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )
    ret = True
    for i in _EXTENSION_FLAGS:
        if (i in mtdata) and (i != _EXTENSION_INSTALLED):
            ret = False
    if not ret:
        log.info(&quot;Failed to create ext: %s&quot;, name)
    return ret


def user_remove(
    username,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Removes a user from the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.user_remove 'username'
    &quot;&quot;&quot;
    return _role_remove(
        username,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )


# Group related actions


def group_create(
    groupname,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    login=None,
    inherit=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    groups=None,
    runas=None,
):
    &quot;&quot;&quot;
    Creates a Postgres group. A group is postgres is similar to a user, but
    cannot login.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.group_create 'groupname' user='user' \\
                host='hostname' port='port' password='password' \\
                rolepassword='rolepassword'
    &quot;&quot;&quot;
    return _role_create(
        groupname,
        user=user,
        typ_=&quot;group&quot;,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        createdb=createdb,
        createroles=createroles,
        encrypted=encrypted,
        login=login,
        inherit=inherit,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        groups=groups,
        runas=runas,
    )


def group_update(
    groupname,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    createdb=None,
    createroles=None,
    encrypted=None,
    inherit=None,
    login=None,
    superuser=None,
    replication=None,
    rolepassword=None,
    groups=None,
    runas=None,
):
    &quot;&quot;&quot;
    Updates a postgres group

    CLI Examples:

    .. code-block:: bash

        salt '*' postgres.group_update 'username' user='user' \\
                host='hostname' port='port' password='password' \\
                rolepassword='rolepassword'
    &quot;&quot;&quot;
    return _role_update(
        groupname,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        createdb=createdb,
        typ_=&quot;group&quot;,
        createroles=createroles,
        encrypted=encrypted,
        login=login,
        inherit=inherit,
        superuser=superuser,
        replication=replication,
        rolepassword=rolepassword,
        groups=groups,
        runas=runas,
    )


def group_remove(
    groupname,
    user=None,
    host=None,
    port=None,
    maintenance_db=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Removes a group from the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.group_remove 'groupname'
    &quot;&quot;&quot;
    return _role_remove(
        groupname,
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )


def owner_to(
    dbname, ownername, user=None, host=None, port=None, password=None, runas=None
):
    &quot;&quot;&quot;
    Set the owner of all schemas, functions, tables, views and sequences to
    the given username.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.owner_to 'dbname' 'username'
    &quot;&quot;&quot;

    sqlfile = tempfile.NamedTemporaryFile()
    sqlfile.write(&quot;begin;\n&quot;)
    sqlfile.write('alter database &quot;{}&quot; owner to &quot;{}&quot;;\n'.format(dbname, ownername))

    queries = (
        # schemas
        (
            &quot;alter schema {n} owner to {owner};&quot;,
            &quot;select quote_ident(schema_name) as n from information_schema.schemata;&quot;,
        ),
        # tables and views
        (
            &quot;alter table {n} owner to {owner};&quot;,
            &quot;select quote_ident(table_schema)||'.'||quote_ident(table_name) as &quot;
            &quot;n from information_schema.tables where table_schema not in &quot;
            &quot;('pg_catalog', 'information_schema');&quot;,
        ),
        # functions
        (
            &quot;alter function {n} owner to {owner};&quot;,
            &quot;select p.oid::regprocedure::text as n from pg_catalog.pg_proc p &quot;
            &quot;join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where &quot;
            &quot;ns.nspname not in ('pg_catalog', 'information_schema') &quot;
            &quot; and not p.proisagg;&quot;,
        ),
        # aggregate functions
        (
            &quot;alter aggregate {n} owner to {owner};&quot;,
            &quot;select p.oid::regprocedure::text as n from pg_catalog.pg_proc p &quot;
            &quot;join pg_catalog.pg_namespace ns on p.pronamespace=ns.oid where &quot;
            &quot;ns.nspname not in ('pg_catalog', 'information_schema') &quot;
            &quot;and p.proisagg;&quot;,
        ),
        # sequences
        (
            &quot;alter sequence {n} owner to {owner};&quot;,
            &quot;select quote_ident(sequence_schema)||'.'||&quot;
            &quot;quote_ident(sequence_name) as n from information_schema.sequences;&quot;,
        ),
    )

    for fmt, query in queries:
        ret = psql_query(
            query,
            user=user,
            host=host,
            port=port,
            maintenance_db=dbname,
            password=password,
            runas=runas,
        )
        for row in ret:
            sqlfile.write(fmt.format(owner=ownername, n=row[&quot;n&quot;]) + &quot;\n&quot;)

    sqlfile.write(&quot;commit;\n&quot;)
    sqlfile.flush()
    os.chmod(sqlfile.name, 0o644)  # ensure psql can read the file

    # run the generated sqlfile in the db
    cmdret = _psql_prepare_and_run(
        [&quot;-f&quot;, sqlfile.name],
        user=user,
        runas=runas,
        host=host,
        port=port,
        password=password,
        maintenance_db=dbname,
    )
    return cmdret


# Schema related actions


def schema_create(
    dbname,
    name,
    owner=None,
    user=None,
    db_user=None,
    db_password=None,
    db_host=None,
    db_port=None,
):
    &quot;&quot;&quot;
    Creates a Postgres schema.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.schema_create dbname name owner='owner' \\
                user='user' \\
                db_user='user' db_password='password'
                db_host='hostname' db_port='port'
    &quot;&quot;&quot;

    # check if schema exists
    if schema_exists(
        dbname,
        name,
        user=user,
        db_user=db_user,
        db_password=db_password,
        db_host=db_host,
        db_port=db_port,
    ):
        log.info(&quot;'%s' already exists in '%s'&quot;, name, dbname)
        return False

    sub_cmd = 'CREATE SCHEMA &quot;{}&quot;'.format(name)
    if owner is not None:
        sub_cmd = '{} AUTHORIZATION &quot;{}&quot;'.format(sub_cmd, owner)

    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, sub_cmd],
        user=db_user,
        password=db_password,
        port=db_port,
        host=db_host,
        maintenance_db=dbname,
        runas=user,
    )

    return ret[&quot;retcode&quot;] == 0


def schema_remove(
    dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    &quot;&quot;&quot;
    Removes a schema from the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.schema_remove dbname schemaname

    dbname
        Database name we work on

    schemaname
        The schema's name we'll remove

    user
        System user all operations should be performed on behalf of

    db_user
        database username if different from config or default

    db_password
        user password if any password for a specified user

    db_host
        Database host if different from config or default

    db_port
        Database port if different from config or default

    &quot;&quot;&quot;

    # check if schema exists
    if not schema_exists(
        dbname,
        name,
        user=None,
        db_user=db_user,
        db_password=db_password,
        db_host=db_host,
        db_port=db_port,
    ):
        log.info(&quot;Schema '%s' does not exist in '%s'&quot;, name, dbname)
        return False

    # schema exists, proceed
    sub_cmd = 'DROP SCHEMA &quot;{}&quot;'.format(name)
    _psql_prepare_and_run(
        [&quot;-c&quot;, sub_cmd],
        runas=user,
        maintenance_db=dbname,
        host=db_host,
        user=db_user,
        port=db_port,
        password=db_password,
    )

    if not schema_exists(
        dbname,
        name,
        user,
        db_user=db_user,
        db_password=db_password,
        db_host=db_host,
        db_port=db_port,
    ):
        return True
    else:
        log.info(&quot;Failed to delete schema '%s'.&quot;, name)
        return False


def schema_exists(
    dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    &quot;&quot;&quot;
    Checks if a schema exists on the Postgres server.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.schema_exists dbname schemaname

    dbname
        Database name we query on

    name
       Schema name we look for

    user
        The system user the operation should be performed on behalf of

    db_user
        database username if different from config or default

    db_password
        user password if any password for a specified user

    db_host
        Database host if different from config or default

    db_port
        Database port if different from config or default

    &quot;&quot;&quot;
    return bool(
        schema_get(
            dbname,
            name,
            user=user,
            db_user=db_user,
            db_host=db_host,
            db_port=db_port,
            db_password=db_password,
        )
    )


def schema_get(
    dbname, name, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    &quot;&quot;&quot;
    Return a dict with information about schemas in a database.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.schema_get dbname name

    dbname
        Database name we query on

    name
       Schema name we look for

    user
        The system user the operation should be performed on behalf of

    db_user
        database username if different from config or default

    db_password
        user password if any password for a specified user

    db_host
        Database host if different from config or default

    db_port
        Database port if different from config or default
    &quot;&quot;&quot;
    all_schemas = schema_list(
        dbname,
        user=user,
        db_user=db_user,
        db_host=db_host,
        db_port=db_port,
        db_password=db_password,
    )
    try:
        return all_schemas.get(name, None)
    except AttributeError:
        log.error(&quot;Could not retrieve Postgres schema. Is Postgres running?&quot;)
        return False


def schema_list(
    dbname, user=None, db_user=None, db_password=None, db_host=None, db_port=None
):
    &quot;&quot;&quot;
    Return a dict with information about schemas in a Postgres database.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.schema_list dbname

    dbname
        Database name we query on

    user
        The system user the operation should be performed on behalf of

    db_user
        database username if different from config or default

    db_password
        user password if any password for a specified user

    db_host
        Database host if different from config or default

    db_port
        Database port if different from config or default
    &quot;&quot;&quot;

    ret = {}

    query = &quot;&quot;.join(
        [
            &quot;SELECT &quot;
            'pg_namespace.nspname as &quot;name&quot;,'
            'pg_namespace.nspacl as &quot;acl&quot;, '
            'pg_roles.rolname as &quot;owner&quot; '
            &quot;FROM pg_namespace &quot;
            &quot;LEFT JOIN pg_roles ON pg_roles.oid = pg_namespace.nspowner &quot;
        ]
    )

    rows = psql_query(
        query,
        runas=user,
        host=db_host,
        user=db_user,
        port=db_port,
        maintenance_db=dbname,
        password=db_password,
    )

    for row in rows:
        retrow = {}
        for key in (&quot;owner&quot;, &quot;acl&quot;):
            retrow[key] = row[key]
        ret[row[&quot;name&quot;]] = retrow

    return ret


def language_list(
    maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Return a list of languages in a database.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.language_list dbname

    maintenance_db
        The database to check

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of
    &quot;&quot;&quot;

    ret = {}
    query = 'SELECT lanname AS &quot;Name&quot; FROM pg_language'

    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    for row in rows:
        ret[row[&quot;Name&quot;]] = row[&quot;Name&quot;]

    return ret


def language_exists(
    name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Checks if language exists in a database.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.language_exists plpgsql dbname

    name
       Language to check for

    maintenance_db
        The database to check in

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of

    &quot;&quot;&quot;

    languages = language_list(
        maintenance_db, user=user, host=host, port=port, password=password, runas=runas
    )

    return name in languages


def language_create(
    name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Installs a language into a database

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.language_create plpgsql dbname

    name
       Language to install

    maintenance_db
        The database to install the language in

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of
    &quot;&quot;&quot;

    if language_exists(name, maintenance_db):
        log.info(&quot;Language %s already exists in %s&quot;, name, maintenance_db)
        return False

    query = &quot;CREATE LANGUAGE {}&quot;.format(name)

    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )

    return ret[&quot;retcode&quot;] == 0


def language_remove(
    name, maintenance_db, user=None, host=None, port=None, password=None, runas=None
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Removes a language from a database

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.language_remove plpgsql dbname

    name
       Language to remove

    maintenance_db
        The database to install the language in

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of
    &quot;&quot;&quot;

    if not language_exists(name, maintenance_db):
        log.info(&quot;Language %s does not exist in %s&quot;, name, maintenance_db)
        return False

    query = &quot;DROP LANGUAGE {}&quot;.format(name)

    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, query],
        user=user,
        host=host,
        port=port,
        runas=runas,
        maintenance_db=maintenance_db,
        password=password,
    )

    return ret[&quot;retcode&quot;] == 0


def _make_privileges_list_query(name, object_type, prepend):
    &quot;&quot;&quot;
    Generate the SQL required for specific object type
    &quot;&quot;&quot;
    if object_type == &quot;table&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT relacl AS name&quot;,
                    &quot;FROM pg_catalog.pg_class c&quot;,
                    &quot;JOIN pg_catalog.pg_namespace n&quot;,
                    &quot;ON n.oid = c.relnamespace&quot;,
                    &quot;WHERE nspname = '{0}'&quot;,
                    &quot;AND relname = '{1}'&quot;,
                    &quot;AND relkind = 'r'&quot;,
                    &quot;ORDER BY relname&quot;,
                ]
            )
        ).format(prepend, name)
    elif object_type == &quot;sequence&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT relacl AS name&quot;,
                    &quot;FROM pg_catalog.pg_class c&quot;,
                    &quot;JOIN pg_catalog.pg_namespace n&quot;,
                    &quot;ON n.oid = c.relnamespace&quot;,
                    &quot;WHERE nspname = '{0}'&quot;,
                    &quot;AND relname = '{1}'&quot;,
                    &quot;AND relkind = 'S'&quot;,
                    &quot;ORDER BY relname&quot;,
                ]
            )
        ).format(prepend, name)
    elif object_type == &quot;schema&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT nspacl AS name&quot;,
                    &quot;FROM pg_catalog.pg_namespace&quot;,
                    &quot;WHERE nspname = '{0}'&quot;,
                    &quot;ORDER BY nspname&quot;,
                ]
            )
        ).format(name)
    elif object_type == &quot;function&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT proacl AS name&quot;,
                    &quot;FROM pg_catalog.pg_proc p&quot;,
                    &quot;JOIN pg_catalog.pg_namespace n&quot;,
                    &quot;ON n.oid = p.pronamespace&quot;,
                    &quot;WHERE nspname = '{0}'&quot;,
                    &quot;AND p.oid::regprocedure::text = '{1}'&quot;,
                    &quot;ORDER BY proname, proargtypes&quot;,
                ]
            )
        ).format(prepend, name)
    elif object_type == &quot;tablespace&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT spcacl AS name&quot;,
                    &quot;FROM pg_catalog.pg_tablespace&quot;,
                    &quot;WHERE spcname = '{0}'&quot;,
                    &quot;ORDER BY spcname&quot;,
                ]
            )
        ).format(name)
    elif object_type == &quot;language&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT lanacl AS name&quot;,
                    &quot;FROM pg_catalog.pg_language&quot;,
                    &quot;WHERE lanname = '{0}'&quot;,
                    &quot;ORDER BY lanname&quot;,
                ]
            )
        ).format(name)
    elif object_type == &quot;database&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT datacl AS name&quot;,
                    &quot;FROM pg_catalog.pg_database&quot;,
                    &quot;WHERE datname = '{0}'&quot;,
                    &quot;ORDER BY datname&quot;,
                ]
            )
        ).format(name)
    elif object_type == &quot;group&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT rolname, admin_option&quot;,
                    &quot;FROM pg_catalog.pg_auth_members m&quot;,
                    &quot;JOIN pg_catalog.pg_roles r&quot;,
                    &quot;ON m.member=r.oid&quot;,
                    &quot;WHERE m.roleid IN&quot;,
                    &quot;(SELECT oid&quot;,
                    &quot;FROM pg_catalog.pg_roles&quot;,
                    &quot;WHERE rolname='{0}')&quot;,
                    &quot;ORDER BY rolname&quot;,
                ]
            )
        ).format(name)

    return query


def _get_object_owner(
    name,
    object_type,
    prepend=&quot;public&quot;,
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    Return the owner of a postgres object
    &quot;&quot;&quot;
    if object_type == &quot;table&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT tableowner AS name&quot;,
                    &quot;FROM pg_tables&quot;,
                    &quot;WHERE schemaname = '{0}'&quot;,
                    &quot;AND tablename = '{1}'&quot;,
                ]
            )
        ).format(prepend, name)
    elif object_type == &quot;sequence&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT rolname AS name&quot;,
                    &quot;FROM pg_catalog.pg_class c&quot;,
                    &quot;JOIN pg_roles r&quot;,
                    &quot;ON c.relowner = r.oid&quot;,
                    &quot;JOIN pg_catalog.pg_namespace n&quot;,
                    &quot;ON n.oid = c.relnamespace&quot;,
                    &quot;WHERE relkind='S'&quot;,
                    &quot;AND nspname='{0}'&quot;,
                    &quot;AND relname = '{1}'&quot;,
                ]
            )
        ).format(prepend, name)
    elif object_type == &quot;schema&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT rolname AS name&quot;,
                    &quot;FROM pg_namespace n&quot;,
                    &quot;JOIN pg_roles r&quot;,
                    &quot;ON n.nspowner = r.oid&quot;,
                    &quot;WHERE nspname = '{0}'&quot;,
                ]
            )
        ).format(name)
    elif object_type == &quot;function&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT rolname AS name&quot;,
                    &quot;FROM pg_catalog.pg_proc p&quot;,
                    &quot;JOIN pg_catalog.pg_namespace n&quot;,
                    &quot;ON n.oid = p.pronamespace&quot;,
                    &quot;WHERE nspname = '{0}'&quot;,
                    &quot;AND p.oid::regprocedure::text = '{1}'&quot;,
                    &quot;ORDER BY proname, proargtypes&quot;,
                ]
            )
        ).format(prepend, name)
    elif object_type == &quot;tablespace&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT rolname AS name&quot;,
                    &quot;FROM pg_tablespace t&quot;,
                    &quot;JOIN pg_roles r&quot;,
                    &quot;ON t.spcowner = r.oid&quot;,
                    &quot;WHERE spcname = '{0}'&quot;,
                ]
            )
        ).format(name)
    elif object_type == &quot;language&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT rolname AS name&quot;,
                    &quot;FROM pg_language l&quot;,
                    &quot;JOIN pg_roles r&quot;,
                    &quot;ON l.lanowner = r.oid&quot;,
                    &quot;WHERE lanname = '{0}'&quot;,
                ]
            )
        ).format(name)
    elif object_type == &quot;database&quot;:
        query = (
            &quot; &quot;.join(
                [
                    &quot;SELECT rolname AS name&quot;,
                    &quot;FROM pg_database d&quot;,
                    &quot;JOIN pg_roles r&quot;,
                    &quot;ON d.datdba = r.oid&quot;,
                    &quot;WHERE datname = '{0}'&quot;,
                ]
            )
        ).format(name)

    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )
    try:
        ret = rows[0][&quot;name&quot;]
    except IndexError:
        ret = None

    return ret


def _validate_privileges(object_type, privs, privileges):
    &quot;&quot;&quot;
    Validate the supplied privileges
    &quot;&quot;&quot;
    if object_type != &quot;group&quot;:
        _perms = [_PRIVILEGES_MAP[perm] for perm in _PRIVILEGE_TYPE_MAP[object_type]]
        _perms.append(&quot;ALL&quot;)

        if object_type not in _PRIVILEGES_OBJECTS:
            raise SaltInvocationError(
                &quot;Invalid object_type: {} provided&quot;.format(object_type)
            )

        if not set(privs).issubset(set(_perms)):
            raise SaltInvocationError(
                &quot;Invalid privilege(s): {} provided for object {}&quot;.format(
                    privileges, object_type
                )
            )
    else:
        if privileges:
            raise SaltInvocationError(
                &quot;The privileges option should not be set for object_type group&quot;
            )


def _mod_priv_opts(object_type, privileges):
    &quot;&quot;&quot;
    Format options
    &quot;&quot;&quot;
    object_type = object_type.lower()
    privileges = &quot;&quot; if privileges is None else privileges
    _privs = re.split(r&quot;\s?,\s?&quot;, privileges.upper())

    return object_type, privileges, _privs


def _process_priv_part(perms):
    &quot;&quot;&quot;
    Process part
    &quot;&quot;&quot;
    _tmp = {}
    previous = None
    for perm in perms:
        if previous is None:
            _tmp[_PRIVILEGES_MAP[perm]] = False
            previous = _PRIVILEGES_MAP[perm]
        else:
            if perm == &quot;*&quot;:
                _tmp[previous] = True
            else:
                _tmp[_PRIVILEGES_MAP[perm]] = False
                previous = _PRIVILEGES_MAP[perm]
    return _tmp


def privileges_list(
    name,
    object_type,
    prepend=&quot;public&quot;,
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Return a list of privileges for the specified object.

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.privileges_list table_name table maintenance_db=db_name

    name
       Name of the object for which the permissions should be returned

    object_type
       The object type, which can be one of the following:

       - table
       - sequence
       - schema
       - tablespace
       - language
       - database
       - group
       - function

    prepend
        Table and Sequence object types live under a schema so this should be
        provided if the object is not under the default `public` schema

    maintenance_db
        The database to connect to

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of
    &quot;&quot;&quot;
    object_type = object_type.lower()
    query = _make_privileges_list_query(name, object_type, prepend)

    if object_type not in _PRIVILEGES_OBJECTS:
        raise SaltInvocationError(
            &quot;Invalid object_type: {} provided&quot;.format(object_type)
        )

    rows = psql_query(
        query,
        runas=runas,
        host=host,
        user=user,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
    )

    ret = {}

    for row in rows:
        if object_type != &quot;group&quot;:
            result = row[&quot;name&quot;]
            result = result.strip(&quot;{}&quot;)
            parts = result.split(&quot;,&quot;)
            for part in parts:
                perms_part, _ = part.split(&quot;/&quot;)
                rolename, perms = perms_part.split(&quot;=&quot;)
                if rolename == &quot;&quot;:
                    rolename = &quot;public&quot;
                _tmp = _process_priv_part(perms)
                ret[rolename] = _tmp
        else:
            if row[&quot;admin_option&quot;] == &quot;t&quot;:
                admin_option = True
            else:
                admin_option = False

            ret[row[&quot;rolname&quot;]] = admin_option

    return ret


def has_privileges(
    name,
    object_name,
    object_type,
    privileges=None,
    grant_option=None,
    prepend=&quot;public&quot;,
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Check if a role has the specified privileges on an object

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.has_privileges user_name table_name table \\
        SELECT,INSERT maintenance_db=db_name

    name
       Name of the role whose privileges should be checked on object_type

    object_name
       Name of the object on which the check is to be performed

    object_type
       The object type, which can be one of the following:

       - table
       - sequence
       - schema
       - tablespace
       - language
       - database
       - group
       - function

    privileges
       Comma separated list of privileges to check, from the list below:

       - INSERT
       - CREATE
       - TRUNCATE
       - CONNECT
       - TRIGGER
       - SELECT
       - USAGE
       - TEMPORARY
       - UPDATE
       - EXECUTE
       - REFERENCES
       - DELETE
       - ALL

    grant_option
        If grant_option is set to True, the grant option check is performed

    prepend
        Table and Sequence object types live under a schema so this should be
        provided if the object is not under the default `public` schema

    maintenance_db
        The database to connect to

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of
    &quot;&quot;&quot;
    object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)

    _validate_privileges(object_type, _privs, privileges)

    if object_type != &quot;group&quot;:
        owner = _get_object_owner(
            object_name,
            object_type,
            prepend=prepend,
            maintenance_db=maintenance_db,
            user=user,
            host=host,
            port=port,
            password=password,
            runas=runas,
        )
        if owner is not None and name == owner:
            return True

    _privileges = privileges_list(
        object_name,
        object_type,
        prepend=prepend,
        maintenance_db=maintenance_db,
        user=user,
        host=host,
        port=port,
        password=password,
        runas=runas,
    )

    if name in _privileges:
        if object_type == &quot;group&quot;:
            if grant_option:
                retval = _privileges[name]
            else:
                retval = True
            return retval
        else:
            _perms = _PRIVILEGE_TYPE_MAP[object_type]
            if grant_option:
                perms = {_PRIVILEGES_MAP[perm]: True for perm in _perms}
                retval = perms == _privileges[name]
            else:
                perms = [_PRIVILEGES_MAP[perm] for perm in _perms]
                if &quot;ALL&quot; in _privs:
                    retval = sorted(perms) == sorted(_privileges[name])
                else:
                    retval = set(_privs).issubset(set(_privileges[name]))
            return retval

    return False


def privileges_grant(
    name,
    object_name,
    object_type,
    privileges=None,
    grant_option=None,
    prepend=&quot;public&quot;,
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Grant privileges on a postgres object

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.privileges_grant user_name table_name table \\
        SELECT,UPDATE maintenance_db=db_name

    name
       Name of the role to which privileges should be granted

    object_name
       Name of the object on which the grant is to be performed

    object_type
       The object type, which can be one of the following:

       - table
       - sequence
       - schema
       - tablespace
       - language
       - database
       - group
       - function

    privileges
       Comma separated list of privileges to grant, from the list below:

       - INSERT
       - CREATE
       - TRUNCATE
       - CONNECT
       - TRIGGER
       - SELECT
       - USAGE
       - TEMPORARY
       - UPDATE
       - EXECUTE
       - REFERENCES
       - DELETE
       - ALL

    grant_option
        If grant_option is set to True, the recipient of the privilege can
        in turn grant it to others

    prepend
        Table and Sequence object types live under a schema so this should be
        provided if the object is not under the default `public` schema

    maintenance_db
        The database to connect to

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of
    &quot;&quot;&quot;
    object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)

    _validate_privileges(object_type, _privs, privileges)

    if has_privileges(
        name,
        object_name,
        object_type,
        privileges,
        prepend=prepend,
        maintenance_db=maintenance_db,
        user=user,
        host=host,
        port=port,
        password=password,
        runas=runas,
    ):
        log.info(
            &quot;The object: %s of type: %s already has privileges: %s set&quot;,
            object_name,
            object_type,
            privileges,
        )
        return False

    _grants = &quot;,&quot;.join(_privs)

    if object_type in [&quot;table&quot;, &quot;sequence&quot;]:
        on_part = '{}.&quot;{}&quot;'.format(prepend, object_name)
    elif object_type == &quot;function&quot;:
        on_part = &quot;{}&quot;.format(object_name)
    else:
        on_part = '&quot;{}&quot;'.format(object_name)

    if grant_option:
        if object_type == &quot;group&quot;:
            query = 'GRANT {} TO &quot;{}&quot; WITH ADMIN OPTION'.format(object_name, name)
        elif object_type in (&quot;table&quot;, &quot;sequence&quot;) and object_name.upper() == &quot;ALL&quot;:
            query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO &quot;{}&quot; WITH GRANT OPTION'.format(
                _grants, object_type.upper(), prepend, name
            )
        else:
            query = 'GRANT {} ON {} {} TO &quot;{}&quot; WITH GRANT OPTION'.format(
                _grants, object_type.upper(), on_part, name
            )
    else:
        if object_type == &quot;group&quot;:
            query = 'GRANT {} TO &quot;{}&quot;'.format(object_name, name)
        elif object_type in (&quot;table&quot;, &quot;sequence&quot;) and object_name.upper() == &quot;ALL&quot;:
            query = 'GRANT {} ON ALL {}S IN SCHEMA {} TO &quot;{}&quot;'.format(
                _grants, object_type.upper(), prepend, name
            )
        else:
            query = 'GRANT {} ON {} {} TO &quot;{}&quot;'.format(
                _grants, object_type.upper(), on_part, name
            )

    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )

    return ret[&quot;retcode&quot;] == 0


def privileges_revoke(
    name,
    object_name,
    object_type,
    privileges=None,
    prepend=&quot;public&quot;,
    maintenance_db=None,
    user=None,
    host=None,
    port=None,
    password=None,
    runas=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Revoke privileges on a postgres object

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.privileges_revoke user_name table_name table \\
        SELECT,UPDATE maintenance_db=db_name

    name
       Name of the role whose privileges should be revoked

    object_name
       Name of the object on which the revoke is to be performed

    object_type
       The object type, which can be one of the following:

       - table
       - sequence
       - schema
       - tablespace
       - language
       - database
       - group
       - function

    privileges
       Comma separated list of privileges to revoke, from the list below:

       - INSERT
       - CREATE
       - TRUNCATE
       - CONNECT
       - TRIGGER
       - SELECT
       - USAGE
       - TEMPORARY
       - UPDATE
       - EXECUTE
       - REFERENCES
       - DELETE
       - ALL

    maintenance_db
        The database to connect to

    user
        database username if different from config or default

    password
        user password if any password for a specified user

    host
        Database host if different from config or default

    port
        Database port if different from config or default

    runas
        System user all operations should be performed on behalf of
    &quot;&quot;&quot;
    object_type, privileges, _privs = _mod_priv_opts(object_type, privileges)

    _validate_privileges(object_type, _privs, privileges)

    if not has_privileges(
        name,
        object_name,
        object_type,
        privileges,
        prepend=prepend,
        maintenance_db=maintenance_db,
        user=user,
        host=host,
        port=port,
        password=password,
        runas=runas,
    ):
        log.info(
            &quot;The object: %s of type: %s does not have privileges: %s set&quot;,
            object_name,
            object_type,
            privileges,
        )
        return False

    _grants = &quot;,&quot;.join(_privs)

    if object_type in [&quot;table&quot;, &quot;sequence&quot;]:
        on_part = &quot;{}.{}&quot;.format(prepend, object_name)
    else:
        on_part = object_name

    if object_type == &quot;group&quot;:
        query = &quot;REVOKE {} FROM {}&quot;.format(object_name, name)
    else:
        query = &quot;REVOKE {} ON {} {} FROM {}&quot;.format(
            _grants, object_type.upper(), on_part, name
        )

    ret = _psql_prepare_and_run(
        [&quot;-c&quot;, query],
        user=user,
        host=host,
        port=port,
        maintenance_db=maintenance_db,
        password=password,
        runas=runas,
    )

    return ret[&quot;retcode&quot;] == 0


def datadir_init(
    name,
    auth=&quot;password&quot;,
    user=None,
    password=None,
    encoding=&quot;UTF8&quot;,
    locale=None,
    waldir=None,
    checksums=False,
    runas=None,
):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Initializes a postgres data directory

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.datadir_init '/var/lib/pgsql/data'

    name
        The name of the directory to initialize

    auth
        The default authentication method for local connections

    password
        The password to set for the postgres user

    user
        The database superuser name

    encoding
        The default encoding for new databases

    locale
        The default locale for new databases

    waldir
        The transaction log (WAL) directory (default is to keep WAL
        inside the data directory)

        .. versionadded:: 2019.2.0

    checksums
        If True, the cluster will be created with data page checksums.

        .. note:: Data page checksums are supported since PostgreSQL 9.3.

        .. versionadded:: 2019.2.0

    runas
        The system user the operation should be performed on behalf of

    &quot;&quot;&quot;
    if datadir_exists(name):
        log.info(&quot;%s already exists&quot;, name)
        return False

    ret = _run_initdb(
        name,
        auth=auth,
        user=user,
        password=password,
        encoding=encoding,
        locale=locale,
        waldir=waldir,
        checksums=checksums,
        runas=runas,
    )
    return ret[&quot;retcode&quot;] == 0


def datadir_exists(name):
    &quot;&quot;&quot;
    .. versionadded:: 2016.3.0

    Checks if postgres data directory has been initialized

    CLI Example:

    .. code-block:: bash

        salt '*' postgres.datadir_exists '/var/lib/pgsql/data'

    name
        Name of the directory to check
    &quot;&quot;&quot;
    _version_file = os.path.join(name, &quot;PG_VERSION&quot;)
    _config_file = os.path.join(name, &quot;postgresql.conf&quot;)

    return os.path.isfile(_version_file) and os.path.isfile(_config_file)
</PRE>
</div>
  </div>
</body>
</html>
