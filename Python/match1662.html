<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for authentication_1.py &amp; theme.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for authentication_1.py &amp; theme.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>authentication_1.py (13.069909%)<th>theme.py (2.0197275%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(29-51)<td><a href="#" name="0">(46-67)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(126-135)<td><a href="#" name="1">(1064-1068)</a><td align="center"><font color="#b80000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(59-65)<td><a href="#" name="2">(152-159)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>authentication_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import binascii
2 import json
3 import logging
4 import os
5 import time
6 from typing import Any, Callable, Dict, List, Optional, cast
7 import pyramid.request
8 from Crypto.Cipher import AES  # nosec
9 from pyramid.authentication import (
10     AuthTktAuthenticationPolicy,
11     BasicAuthAuthenticationPolicy,
12     CallbackAuthenticationPolicy,
13 )
14 from pyramid.interfaces import IAuthenticationPolicy
15 from pyramid.security import remember
16 from pyramid_multiauth import MultiAuthenticationPolicy
17 from zope.interface import implementer
18 from c2cgeoportal_geoportal.lib import oauth2
19 from c2cgeoportal_geoportal.resources import defaultgroupsfinder
20 LOG = logging.getLogger(</b></font>__name__)
21 @implementer(IAuthenticationPolicy)
22 class UrlAuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
23 <a name="2"></a>    """An authentication policy based on information given in the URL."""
24     def __init__(
25         self, aes_key: str, callback: Optional[Callable[[str, Any], List[str]]] = None, debug: bool <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= False
26     ):
27         self.aeskey = aes_key
28         self.callback = callback
29         self.debug = debug
30     def unauthenticated_userid(self, request: pyramid.request.Request) -&gt; Optional[</b></font>str]:
31         if not request.method == "GET" or "auth" not in request.params:
32             return None
33         auth_enc = request.params.get("auth")
34         if auth_enc is None:
35             return None
36         try:
37             if self.aeskey is None:  # pragma: nocover
38                 raise Exception("urllogin is not configured")
39             now = int(time.time())
40             data = binascii.unhexlify(auth_enc.encode("ascii"))
41             nonce = data[0:16]
42             tag = data[16:32]
43             ciphertext = data[32:]
44             cipher = AES.new(self.aeskey.encode("ascii"), AES.MODE_EAX, nonce)
45             auth = json.loads(cipher.decrypt_and_verify(ciphertext, tag).decode("utf-8"))  # type: ignore
46             if "t" in auth and "u" in auth and "p" in auth:
47                 timestamp = int(auth["t"])
48                 if now &lt; timestamp and request.registry.validate_user(request, auth["u"], auth["p"]):
49                     headers = remember(request, auth["u"])
50                     request.response.headerlist.extend(headers)
51                     return cast(str, auth["u"])
52         except Exception as e:
53             LOG.error("URL login error: %s.", e, exc_info=True)
54         return None
55     def remember(  # pylint: disable=no-self-use
56         self, request: pyramid.request.Request, userid: str, **kw: Any
57     ) -&gt; List[Dict[str, str]]:
58         del request, userid, kw
59         return []
60     def forget(self, request: pyramid.request.Request) -&gt; List[Dict[str, str]]:  # pylint: disable=no-self-use
61         del request
62         return []
63 @implementer(IAuthenticationPolicy)
64 class OAuth2AuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
65     @staticmethod
66     def unauthenticated_userid(request: pyramid.request.Request) -&gt; Optional[str]:
67         route_url = ""
68         try:
69             route_url = request.current_route_url(_query=request.GET)
70         except ValueError:
71             route_url = request.route_url("base", _query=request.GET)
72         LOG.debug(
73             "Call OAuth verify_request with:\nurl: %s\nmethod: %s\nbody:\n%s",
74             route_url,
75 <a name="1"></a>            request.method,
76             request.body,
77         )
78         valid, oauth2_request = oauth2<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_oauth_client(request.registry.settings).verify_request(
79             route_url,
80             request.method,
81             request.body,
82             request.headers,
83             [],
84         )
85         LOG.debug("OAuth verify_request: %s", valid)
86         if valid:
87             request.</b></font>user_ = oauth2_request.user
88             return cast(str, request.user_.username)
89         return None
90     def remember(  # pylint: disable=no-self-use
91         self, request: pyramid.request.Request, userid: str, **kw: Any
92     ) -&gt; List[Dict[str, str]]:
93         del request, userid, kw
94         return []
95     def forget(self, request: pyramid.request.Request) -&gt; List[Dict[str, str]]:  # pylint: disable=no-self-use
96         del request
97         return []
98 @implementer(IAuthenticationPolicy)
99 class DevAuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
100     @staticmethod
101     def unauthenticated_userid(request: pyramid.request.Request) -&gt; Optional[str]:
102         del request
103         return os.environ["DEV_LOGINNAME"]
104 def create_authentication(settings: Dict[str, Any]) -&gt; MultiAuthenticationPolicy:
105     timeout = settings.get("authtkt_timeout")
106     timeout = None if timeout is None or timeout.lower() == "none" else int(timeout)
107     reissue_time = settings.get("authtkt_reissue_time")
108     reissue_time = None if reissue_time is None or reissue_time.lower() == "none" else int(reissue_time)
109     max_age = settings.get("authtkt_max_age")
110     max_age = None if max_age is None or max_age.lower() == "none" else int(max_age)
111     http_only = settings.get("authtkt_http_only", "True")
112     http_only = http_only.lower() in ("true", "yes", "1")
113     secure = settings.get("authtkt_secure", "True")
114     secure = secure.lower() in ("true", "yes", "1")
115     samesite = settings.get("authtkt_samesite", "Lax")
116     secret = settings["authtkt_secret"]
117     basicauth = settings.get("basicauth", "False").lower() in ("true", "yes", "1")
118     if len(secret) &lt; 64:
119         raise Exception(
120             '"authtkt_secret should be at least 64 characters.'
121             "See https://docs.pylonsproject.org/projects/pyramid/en/latest/api/session.html"
122         )
123     policies = []
124     policies.append(
125         UrlAuthenticationPolicy(
126             settings.get("urllogin", {}).get("aes_key"),
127             defaultgroupsfinder,
128         )
129     )
130     policies.append(
131         AuthTktAuthenticationPolicy(
132             secret,
133             callback=defaultgroupsfinder,
134             cookie_name=settings["authtkt_cookie_name"],
135             samesite=None if samesite == "" else samesite,
136             timeout=timeout,
137             max_age=max_age,
138             reissue_time=reissue_time,
139             hashalg="sha512",
140             http_only=http_only,
141             secure=secure,
142         )
143     )
144     policies.append(OAuth2AuthenticationPolicy())
145     if basicauth:
146         if settings["authentication"].get("two_factor", False):
147             LOG.warning(
148                 "Basic auth and tow factor auth should not be enable toogether, "
149                 "you should use OAuth2 instead of Basic auth"
150             )
151         basic_authentication_policy = BasicAuthAuthenticationPolicy(c2cgeoportal_check)
152         policies.append(basic_authentication_policy)
153     if "DEV_LOGINNAME" in os.environ and os.environ["DEV_LOGINNAME"]:
154         policies.append(DevAuthenticationPolicy())
155     return MultiAuthenticationPolicy(policies)
156 def c2cgeoportal_check(username: str, password: str, request: pyramid.request.Request) -&gt; Optional[List[str]]:
157     if request.registry.validate_user(request, username, password):
158         return defaultgroupsfinder(username, request)
159     return None
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>theme.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import asyncio
2 import gc
3 import logging
4 import os
5 import re
6 import sys
7 import time
8 from collections import Counter
9 from math import sqrt
10 from typing import Any, Dict, List, Optional, Set, Tuple, Union, cast
11 import pyramid.request
12 import requests
13 import sqlalchemy
14 <a name="0"></a>import sqlalchemy.orm.query
15 from c2cwsgiutils.auth import auth_view
16 from defusedxml import lxml
17 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from lxml import etree  # nosec
18 from owslib.wms import WebMapService
19 from pyramid.view import view_config
20 from sqlalchemy.orm import subqueryload
21 from sqlalchemy.orm.exc import NoResultFound
22 from c2cgeoportal_commons import models
23 from c2cgeoportal_commons.lib.url import Url, get_url2
24 from c2cgeoportal_commons.models import main
25 from c2cgeoportal_geoportal.lib import get_roles_id, get_typed, get_types_map, is_intranet
26 from c2cgeoportal_geoportal.lib.caching import Cache, get_region, set_common_headers
27 from c2cgeoportal_geoportal.lib.functionality import get_mapserver_substitution_params
28 from c2cgeoportal_geoportal.lib.layers import (
29     get_private_layers,
30     get_protected_layers,
31     get_protected_layers_query,
32 )
33 from c2cgeoportal_geoportal.lib.wmstparsing import TimeInformation, parse_extent
34 from c2cgeoportal_geoportal.views import restrict_headers
35 from c2cgeoportal_geoportal.views.layers import get_layer_metadata
36 LOG = logging.getLogger(</b></font>__name__)
37 CACHE_REGION = get_region("std")
38 TIMEOUT = int(os.environ.get("C2CGEOPORTAL_THEME_TIMEOUT", "300"))
39 Metadata = Union[str, int, float, bool, List[Any], Dict[str, Any]]
40 def get_http_cached(http_options: Dict[str, Any], url: str, headers: Dict[str, str]) -&gt; Tuple[bytes, str]:
41     @CACHE_REGION.cache_on_arguments()  # type: ignore
42     def do_get_http_cached(url: str) -&gt; Tuple[bytes, str]:
43         response = requests.get(url, headers=headers, timeout=TIMEOUT, **http_options)
44         response.raise_for_status()
45         LOG.info("Get url '%s' in %.1fs.", url, response.elapsed.total_seconds())
46         return response.content, response.headers.get("Content-Type", "")
47     return do_get_http_cached(url)  # type: ignore
48 class DimensionInformation:
49     URL_PART_RE = re.compile(r"[a-zA-Z0-9_\-\+~\.]*$")
50     def __init__(self) -&gt; None:
51         self._dimensions: Dict[str, str] = {}
52     def merge(self, layer: main.Layer, layer_node: Dict[str, Any], mixed: bool) -&gt; Set[str]:
53         errors = set()
54         dimensions: Dict[str, str] = {}
55         dimensions_filters = {}
56         for dimension in layer.dimensions:
57             if (
58                 not isinstance(layer, main.LayerWMS)
59                 and dimension.value is not None
60                 and not self.URL_PART_RE.match(dimension.value)
61             ):
62                 errors.add(
63                     f"The layer '{layer.name}' has an unsupported dimension value "
64                     f"'{dimension.value}' ('{dimension.name}')."
65                 )
66             elif dimension.name in dimensions:  # pragma: nocover
67                 errors.add(f"The layer '{layer.name}' has a duplicated dimension name '{dimension.name}'.")
68             else:
69                 if dimension.field:
70                     dimensions_filters[dimension.name] = {"field": dimension.field, "value": dimension.value}
71                 else:
72                     dimensions[dimension.name] = dimension.value
73         if dimensions_filters:
74             layer_node["dimensionsFilters"] = dimensions_filters
75         if mixed:
76             layer_node["dimensions"] = dimensions
77         else:
78             for name, value in list(dimensions.items()):
79                 if name not in self._dimensions or self._dimensions[name] is None:
80                     self._dimensions[name] = value
81                 elif self._dimensions[name] != value and value is not None:
82                     errors.add(
83                         f"The layer '{layer.name}' has a wrong dimension value '{value}' for '{name}', "
84                         f"expected '{self._dimensions[name]}' or empty."
85                     )
86         return errors
87     def get_dimensions(self) -&gt; Dict[str, str]:
88         return self._dimensions
89 class Theme:
90     def __init__(self, request: pyramid.request.Request):
91         self.request = request
92         self.settings = request.registry.settings
93         self.http_options = self.settings.get("http_options", {})
94         self.headers_whitelist = self.settings.get("headers_whitelist", [])
95         self.headers_blacklist = self.settings.get("headers_blacklist", [])
96         self.metadata_type = get_types_map(
97             self.settings.get("admin_interface", {}).get("available_metadata", [])
98         )
99 <a name="2"></a>
100         self._ogcservers_cache = None
101         self._treeitems_cache = None
102         self._layerswms_cache <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= None
103         self._layerswmts_cache = None
104         self._layergroup_cache = None
105         self._themes_cache = None
106     def _get_metadata(
107         self, item: main.TreeItem, metadata: str, errors: Set[str]
108     ) -&gt; Union[</b></font>None, str, int, float, bool, List[Any], Dict[str, Any]]:
109         metadatas = item.get_metadata(metadata)
110         return (
111             None
112             if not metadatas
113             else get_typed(
114                 metadata, metadatas[0].value, self.metadata_type, self.request, errors, layer_name=item.name
115             )
116         )
117     def _get_metadata_list(self, item: main.TreeItem, errors: Set[str]) -&gt; Dict[str, Metadata]:
118         metadatas: Dict[str, Metadata] = {}
119         metadata: main.Metadata
120         for metadata in item.metadatas:
121             value = get_typed(metadata.name, metadata.value, self.metadata_type, self.request, errors)
122             if value is not None:
123                 metadatas[metadata.name] = value
124         return metadatas
125     async def _wms_getcap(
126         self, ogc_server: main.OGCServer, preload: bool = False
127     ) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
128         try:
129             url, content, errors = await self._wms_getcap_cached(ogc_server)
130         except requests.exceptions.RequestException as exception:
131             error = (
132                 f"Unable to get the WMS Capabilities for OGC server '{ogc_server.name}', "
133                 f"return the error: {exception.response.status_code} {exception.response.reason}"
134             )
135             LOG.exception(error)
136             return None, {error}
137         if errors or preload:
138             return None, errors
139         @CACHE_REGION.cache_on_arguments()  # type: ignore
140         def build_web_map_service(ogc_server_id: int) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
141             del ogc_server_id  # Just for cache
142             if url is None:
143                 raise RuntimeError("Url is None")
144             version = url.query.get("VERSION", "1.1.1")
145             layers = {}
146             try:
147                 wms = WebMapService(None, xml=content, version=version)
148             except Exception as e:
149                 error = (
150                     f"WARNING! an error '{e!s}' occurred while trying to read the mapfile and "
151                     "recover the themes."
152                     f"\nURL: {url}\n{content.decode() if content else None}"
153                 )
154                 LOG.error(error, exc_info=True)
155                 return None, {error}
156             wms_layers_name = list(wms.contents)
157             for layer_name in wms_layers_name:
158                 wms_layer = wms[layer_name]
159                 resolution = self._get_layer_resolution_hint(wms_layer)
160                 info = {
161                     "name": wms_layer.name,
162                     "minResolutionHint": float(f"{resolution[0]:0.2f}"),
163                     "maxResolutionHint": float(f"{resolution[1]:0.2f}"),
164                 }
165                 if hasattr(wms_layer, "queryable"):
166                     info["queryable"] = wms_layer.queryable == 1
167                 layers[layer_name] = {
168                     "info": info,
169                     "timepositions": wms_layer.timepositions,
170                     "defaulttimeposition": wms_layer.defaulttimeposition,
171                     "children": [layer.name for layer in wms_layer.layers],
172                 }
173             del wms
174             LOG.debug("Run garbage collection: %s", ", ".join([str(gc.collect(n)) for n in range(3)]))
175             return {"layers": layers}, set()
176         return build_web_map_service(ogc_server.id)  # type: ignore
177     async def _wms_getcap_cached(
178         self, ogc_server: main.OGCServer
179     ) -&gt; Tuple[Optional[Url], Optional[bytes], Set[str]]:
180         errors: Set[str] = set()
181         url = get_url2(f"The OGC server '{ogc_server.name}'", ogc_server.url, self.request, errors)
182         if errors or url is None:
183             return url, None, errors
184         if (
185             ogc_server.auth == main.OGCSERVER_AUTH_STANDARD
186             and ogc_server.type == main.OGCSERVER_TYPE_MAPSERVER
187         ):
188             url.add_query(get_mapserver_substitution_params(self.request))
189         url.add_query(
190             {
191                 "SERVICE": "WMS",
192                 "VERSION": "1.1.1",
193                 "REQUEST": "GetCapabilities",
194                 "ROLE_IDS": "0",
195                 "USER_ID": "0",
196             },
197         )
198         LOG.debug("Get WMS GetCapabilities for URL: %s", url)
199         headers = dict(self.request.headers)
200         if ogc_server.auth == main.OGCSERVER_AUTH_GEOSERVER:
201             headers["sec-username"] = "root"
202             headers["sec-roles"] = "root"
203         if url.hostname != "localhost" and "Host" in headers:
204             headers.pop("Host")
205         headers = restrict_headers(headers, self.headers_whitelist, self.headers_blacklist)
206         try:
207             content, content_type = await asyncio.get_event_loop().run_in_executor(
208                 None, get_http_cached, self.http_options, url, headers
209             )
210         except Exception:
211             error = f"Unable to GetCapabilities from URL {url}"
212             errors.add(error)
213             LOG.error(error, exc_info=True)
214             return url, None, errors
215         if content_type.split(";")[0].strip() not in [
216             "application/vnd.ogc.wms_xml",
217             "text/xml",
218         ]:
219             error = (
220                 f"GetCapabilities from URL '{url}' returns a wrong Content-Type: {content_type}\n"
221                 f"{content.decode()}"
222             )
223             errors.add(error)
224             LOG.error(error)
225             return url, None, errors
226         return url, content, errors
227     def _create_layer_query(self, interface: str) -&gt; sqlalchemy.orm.query.Query:
228         query = models.DBSession.query(main.Layer.name).filter(main.Layer.public.is_(True))
229         if interface is not None:
230             query = query.join(main.Layer.interfaces)
231             query = query.filter(main.Interface.name == interface)
232         query2 = get_protected_layers_query(self.request, None, what=main.LayerWMS.name)
233         if interface is not None:
234             query2 = query2.join(main.Layer.interfaces)
235             query2 = query2.filter(main.Interface.name == interface)
236         query = query.union(query2)
237         query3 = get_protected_layers_query(self.request, None, what=main.LayerWMTS.name)
238         if interface is not None:
239             query3 = query3.join(main.Layer.interfaces)
240             query3 = query3.filter(main.Interface.name == interface)
241         query = query.union(query3)
242         return query
243     def _get_layer_metadata_urls(self, layer: main.Layer) -&gt; List[str]:
244         metadata_urls: List[str] = []
245         if layer.metadataUrls:
246             metadata_urls = layer.metadataUrls
247         for child_layer in layer.layers:
248             metadata_urls.extend(self._get_layer_metadata_urls(child_layer))
249         return metadata_urls
250     def _get_layer_resolution_hint_raw(self, layer: main.Layer) -&gt; Tuple[Optional[float], Optional[float]]:
251         resolution_hint_min = None
252         resolution_hint_max = None
253         if layer.scaleHint:
254             resolution_hint_min = float(layer.scaleHint["min"]) / sqrt(2)
255             resolution_hint_max = (
256                 float(layer.scaleHint["max"]) / sqrt(2)
257                 if layer.scaleHint["max"] not in ("0", "Infinity")
258                 else 999999999
259             )
260         for child_layer in layer.layers:
261             resolution = self._get_layer_resolution_hint_raw(child_layer)
262             resolution_hint_min = (
263                 resolution[0]
264                 if resolution_hint_min is None
265                 else (
266                     resolution_hint_min if resolution[0] is None else min(resolution_hint_min, resolution[0])
267                 )
268             )
269             resolution_hint_max = (
270                 resolution[1]
271                 if resolution_hint_max is None
272                 else (
273                     resolution_hint_max if resolution[1] is None else max(resolution_hint_max, resolution[1])
274                 )
275             )
276         return (resolution_hint_min, resolution_hint_max)
277     def _get_layer_resolution_hint(self, layer: main.Layer) -&gt; Tuple[float, float]:
278         resolution_hint_min, resolution_hint_max = self._get_layer_resolution_hint_raw(layer)
279         return (
280             0.0 if resolution_hint_min is None else resolution_hint_min,
281             999999999 if resolution_hint_max is None else resolution_hint_max,
282         )
283     def _layer(
284         self,
285         layer: main.Layer,
286         time_: Optional[TimeInformation] = None,
287         dim: Optional[DimensionInformation] = None,
288         mixed: bool = True,
289     ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
290         errors: Set[str] = set()
291         layer_info = {"id": layer.id, "name": layer.name, "metadata": self._get_metadata_list(layer, errors)}
292         if re.search("[/?#]", layer.name):
293             errors.add(f"The layer has an unsupported name '{layer.name}'.")
294         if isinstance(layer, main.LayerWMS) and re.search("[/?#]", layer.layer):
295             errors.add(f"The layer has an unsupported layers '{layer.layer}'.")
296         if layer.geo_table:
297             errors |= self._fill_editable(layer_info, layer)
298         if mixed:
299             assert time_ is None
300             time_ = TimeInformation()
301         assert time_ is not None
302         assert dim is not None
303         errors |= dim.merge(layer, layer_info, mixed)
304         if isinstance(layer, main.LayerWMS):
305             wms, wms_errors = self._wms_layers(layer.ogc_server)
306             errors |= wms_errors
307             if wms is None:
308                 return None if errors else layer_info, errors
309             if layer.layer is None or layer.layer == "":
310                 errors.add(f"The layer '{layer.name}' do not have any layers")
311                 return None, errors
312             layer_info["type"] = "WMS"
313             layer_info["layers"] = layer.layer
314             self._fill_wms(layer_info, layer, errors, mixed=mixed)
315             errors |= self._merge_time(time_, layer_info, layer, wms)
316         elif isinstance(layer, main.LayerWMTS):
317             layer_info["type"] = "WMTS"
318             self._fill_wmts(layer_info, layer, errors)
319         elif isinstance(layer, main.LayerVectorTiles):
320             layer_info["type"] = "VectorTiles"
321             self._vectortiles_layers(layer_info, layer, errors)
322         return None if errors else layer_info, errors
323     @staticmethod
324     def _merge_time(
325         time_: TimeInformation, layer_theme: Dict[str, Any], layer: main.Layer, wms: Dict[str, Dict[str, Any]]
326     ) -&gt; Set[str]:
327         errors = set()
328         wmslayer = layer.layer
329         def merge_time(wms_layer_obj: Dict[str, Any]) -&gt; None:
330             extent = parse_extent(wms_layer_obj["timepositions"], wms_layer_obj["defaulttimeposition"])
331             time_.merge(layer_theme, extent, layer.time_mode, layer.time_widget)
332         try:
333             if wmslayer in wms["layers"]:
334                 wms_layer_obj = wms["layers"][wmslayer]
335                 if layer.time_mode != "disabled":
336                     has_time = False
337                     if wms_layer_obj["timepositions"]:
338                         merge_time(wms_layer_obj)
339                         has_time = True
340                     else:
341                         for child_layer_name in wms_layer_obj["children"]:
342                             child_layer = wms["layers"][child_layer_name]
343                             if child_layer["timepositions"]:
344                                 merge_time(child_layer)  # The time mode comes from the wms layer group
345                                 has_time = True
346                     if not has_time:
347                         errors.add(
348                             f"Error: time layer '{layer.name}' has no time information in capabilities"
349                         )
350         except ValueError:  # pragma no cover
351             errors.add(f"Error while handling time for layer '{layer.name}': {sys.exc_info()[1]}")
352         return errors
353     def _fill_editable(self, layer_theme: Dict[str, Any], layer: main.Layer) -&gt; Set[str]:
354         errors = set()
355         try:
356             if self.request.user:
357                 count = (
358                     models.DBSession.query(main.RestrictionArea)
359                     .join(main.RestrictionArea.roles)
360                     .filter(main.Role.id.in_(get_roles_id(self.request)))
361                     .filter(main.RestrictionArea.layers.any(main.Layer.id == layer.id))
362                     .filter(main.RestrictionArea.readwrite.is_(True))
363                     .count()
364                 )
365                 if count &gt; 0:
366                     layer_theme["edit_columns"] = get_layer_metadata(layer)
367                     layer_theme["editable"] = True
368         except Exception as exception:
369             LOG.exception(str(exception))
370             errors.add(str(exception))
371         return errors
372     def _fill_child_layer(
373         self,
374         layer_theme: Dict[str, Any],
375         layer_name: str,
376         wms: Dict[str, Dict[str, Any]],
377     ) -&gt; None:
378         wms_layer_obj = wms["layers"][layer_name]
379         if not wms_layer_obj["children"]:
380             layer_theme["childLayers"].append(wms["layers"][layer_name]["info"])
381         else:
382             for child_layer in wms_layer_obj["children"]:
383                 self._fill_child_layer(layer_theme, child_layer, wms)
384     def _fill_wms(
385         self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str], mixed: bool
386     ) -&gt; None:
387         wms, wms_errors = self._wms_layers(layer.ogc_server)
388         errors |= wms_errors
389         if wms is None:
390             return
391         layer_theme["imageType"] = layer.ogc_server.image_type
392         if layer.style:
393             layer_theme["style"] = layer.style
394         layer_theme["childLayers"] = []
395         for layer_name in layer.layer.split(","):
396             if layer_name in wms["layers"]:
397                 self._fill_child_layer(layer_theme, layer_name, wms)
398             else:
399                 errors.add(
400                     f"The layer '{layer_name}' ({layer.name}) is not defined in WMS capabilities "
401                     f"from '{layer.ogc_server.name}'"
402                 )
403         if "minResolutionHint" not in layer_theme:
404             resolution_min = self._get_metadata(layer, "minResolution", errors)
405             if resolution_min is not None:
406                 layer_theme["minResolutionHint"] = resolution_min
407             else:
408                 min_resolutions_hint = [
409                     l_["minResolutionHint"] for l_ in layer_theme["childLayers"] if "minResolutionHint" in l_
410                 ]
411                 if min_resolutions_hint:
412                     layer_theme["minResolutionHint"] = min(min_resolutions_hint)
413         if "maxResolutionHint" not in layer_theme:
414             resolution_max = self._get_metadata(layer, "maxResolution", errors)
415             if resolution_max is not None:
416                 layer_theme["maxResolutionHint"] = resolution_max
417             else:
418                 max_resolutions_hint = [
419                     l_["maxResolutionHint"] for l_ in layer_theme["childLayers"] if "maxResolutionHint" in l_
420                 ]
421                 if max_resolutions_hint:
422                     layer_theme["maxResolutionHint"] = max(max_resolutions_hint)
423         if mixed:
424             layer_theme["ogcServer"] = layer.ogc_server.name
425     def _fill_wmts(self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str]) -&gt; None:
426         url = get_url2(f"The WMTS layer '{layer.name}'", layer.url, self.request, errors=errors)
427         layer_theme["url"] = url.url() if url is not None else None
428         if layer.style:
429             layer_theme["style"] = layer.style
430         if layer.matrix_set:
431             layer_theme["matrixSet"] = layer.matrix_set
432         layer_theme["layer"] = layer.layer
433         layer_theme["imageType"] = layer.image_type
434     def _vectortiles_layers(self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str]) -&gt; None:
435         style = get_url2(f"The VectorTiles layer '{layer.name}'", layer.style, self.request, errors=errors)
436         layer_theme["style"] = style.url() if style is not None else None
437         if layer.xyz:
438             layer_theme["xyz"] = layer.xyz
439     @staticmethod
440     def _layer_included(tree_item: main.TreeItem) -&gt; bool:
441         return isinstance(tree_item, main.Layer)
442     def _get_ogc_servers(self, group: main.LayerGroup, depth: int) -&gt; Set[Union[str, bool]]:
443         ogc_servers: Set[Union[str, bool]] = set()
444         if depth &gt; 30:
445             LOG.error("Error: too many recursions with group '%s'", group.name)
446             return ogc_servers
447         if isinstance(group, main.LayerGroup) and group.children:
448             for tree_item in group.children:
449                 ogc_servers.update(self._get_ogc_servers(tree_item, depth + 1))
450         if isinstance(group, main.LayerWMS):
451             ogc_servers.add(group.ogc_server.name)
452         if isinstance(group, main.LayerWMTS):
453             ogc_servers.add(False)
454         return ogc_servers
455     @staticmethod
456     def is_mixed(ogc_servers: List[Union[str, bool]]) -&gt; bool:
457         return len(ogc_servers) != 1 or ogc_servers[0] is False
458     def _group(
459         self,
460         path: str,
461         group: main.LayerGroup,
462         layers: List[str],
463         depth: int = 1,
464         min_levels: int = 1,
465         mixed: bool = True,
466         time_: Optional[TimeInformation] = None,
467         dim: Optional[DimensionInformation] = None,
468         wms_layers: Optional[List[str]] = None,
469         layers_name: Optional[List[str]] = None,
470         **kwargs: Any,
471     ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
472         if wms_layers is None:
473             wms_layers = []
474         if layers_name is None:
475             layers_name = []
476         children = []
477         errors = set()
478         if re.search("[/?#]", group.name):
479             errors.add(f"The group has an unsupported name '{group.name}'.")
480         if depth &gt; 30:
481             errors.add(f"Too many recursions with group '{group.name}'")
482             return None, errors
483         ogc_servers = None
484         org_depth = depth
485         if depth == 1:
486             ogc_servers = list(self._get_ogc_servers(group, 1))
487             mixed = self.is_mixed(ogc_servers)
488             if not mixed:
489                 time_ = TimeInformation()
490             dim = DimensionInformation()
491         for tree_item in group.children:
492             if isinstance(tree_item, main.LayerGroup):
493                 group_theme, gp_errors = self._group(
494                     f"{path}/{tree_item.name}",
495                     tree_item,
496                     layers,
497                     depth=depth + 1,
498                     min_levels=min_levels,
499                     mixed=mixed,
500                     time_=time_,
501                     dim=dim,
502                     wms_layers=wms_layers,
503                     layers_name=layers_name,
504                     **kwargs,
505                 )
506                 errors |= gp_errors
507                 if group_theme is not None:
508                     children.append(group_theme)
509             elif self._layer_included(tree_item):
510                 if tree_item.name in layers:
511                     layers_name.append(tree_item.name)
512                     if isinstance(tree_item, main.LayerWMS):
513                         wms_layers.extend(tree_item.layer.split(","))
514                     layer_theme, l_errors = self._layer(tree_item, mixed=mixed, time_=time_, dim=dim)
515                     errors |= l_errors
516                     if layer_theme is not None:
517                         if depth &lt; min_levels:
518                             errors.add(
519                                 f"The Layer '{path + '/' + tree_item.name}' is under indented "
520                                 f"({depth:d}/{min_levels:d})."
521                             )
522                         else:
523                             children.append(layer_theme)
524         if children:
525             group_theme = {
526                 "id": group.id,
527                 "name": group.name,
528                 "children": children,
529                 "metadata": self._get_metadata_list(group, errors),
530                 "mixed": False,
531             }
532             if not mixed:
533                 name: str
534                 for name, nb in Counter(layers_name).items():
535                     if nb &gt; 1:
536                         errors.add(
537                             f"The GeoMapFish layer name '{name}', cannot be two times "
538                             "in the same block (first level group)."
539                         )
540             group_theme["mixed"] = mixed
541             if org_depth == 1:
542                 if not mixed:
543                     assert time_ is not None
544                     assert dim is not None
545                     group_theme["ogcServer"] = cast(List[Any], ogc_servers)[0]
546                     if time_.has_time() and time_.layer is None:
547                         group_theme["time"] = time_.to_dict()
548                     group_theme["dimensions"] = dim.get_dimensions()
549             return group_theme, errors
550         return None, errors
551     def _layers(self, interface: str) -&gt; List[str]:
552         query = self._create_layer_query(interface=interface)
553         return [name for (name,) in query.all()]
554     def _wms_layers(self, ogc_server: main.OGCServer) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
555         wms, wms_errors = asyncio.run(self._wms_getcap(ogc_server))
556         if wms_errors:
557             return None, wms_errors
558         return wms, set()
559     def _load_tree_items(self) -&gt; None:
560         self._ogcservers_cache = models.DBSession.query(main.OGCServer).all()
561         self._treeitems_cache = models.DBSession.query(main.TreeItem).all()
562         self._layerswms_cache = (
563             models.DBSession.query(main.LayerWMS)
564             .options(subqueryload(main.LayerWMS.dimensions), subqueryload(main.LayerWMS.metadatas))
565             .all()
566         )
567         self._layerswmts_cache = (
568             models.DBSession.query(main.LayerWMTS)
569             .options(subqueryload(main.LayerWMTS.dimensions), subqueryload(main.LayerWMTS.metadatas))
570             .all()
571         )
572         self._layergroup_cache = (
573             models.DBSession.query(main.LayerGroup)
574             .options(subqueryload(main.LayerGroup.metadatas), subqueryload(main.LayerGroup.children_relation))
575             .all()
576         )
577         self._themes_cache = (
578             models.DBSession.query(main.Theme)
579             .options(
580                 subqueryload(main.Theme.functionalities),
581                 subqueryload(main.Theme.metadatas),
582                 subqueryload(main.Theme.children_relation),
583             )
584             .all()
585         )
586     def _themes(
587         self, interface: str = "desktop", filter_themes: bool = True, min_levels: int = 1
588     ) -&gt; Tuple[List[Dict[str, Any]], Set[str]]:
589         self._load_tree_items()
590         errors = set()
591         layers = self._layers(interface)
592         themes = models.DBSession.query(main.Theme)
593         themes = themes.filter(main.Theme.public.is_(True))
594         auth_themes = models.DBSession.query(main.Theme)
595         auth_themes = auth_themes.filter(main.Theme.public.is_(False))
596         auth_themes = auth_themes.join(main.Theme.restricted_roles)
597         auth_themes = auth_themes.filter(main.Role.id.in_(get_roles_id(self.request)))
598         themes = themes.union(auth_themes)
599         themes = themes.order_by(main.Theme.ordering.asc())
600         if filter_themes and interface is not None:
601             themes = themes.join(main.Theme.interfaces)
602             themes = themes.filter(main.Interface.name == interface)
603         export_themes = []
604         for theme in themes.all():
605             if re.search("[/?#]", theme.name):
606                 errors.add(f"The theme has an unsupported name '{theme.name}'.")
607                 continue
608             children, children_errors = self._get_children(theme, layers, min_levels)
609             errors |= children_errors
610             if children:
611                 url = (
612                     get_url2(f"The Theme '{theme.name}'", theme.icon, self.request, errors)
613                     if theme.icon is not None and theme.icon
614                     else None
615                 )
616                 icon = (
617                     url.url()
618                     if url is not None
619                     else self.request.static_url("/etc/geomapfish/static/images/blank.png")
620                 )
621                 theme_theme = {
622                     "id": theme.id,
623                     "name": theme.name,
624                     "icon": icon,
625                     "children": children,
626                     "functionalities": self._get_functionalities(theme),
627                     "metadata": self._get_metadata_list(theme, errors),
628                 }
629                 export_themes.append(theme_theme)
630         return export_themes, errors
631     @staticmethod
632     def _get_functionalities(theme: main.Theme) -&gt; Dict[str, List[str]]:
633         result: Dict[str, List[str]] = {}
634         for functionality in theme.functionalities:
635             if functionality.name in result:
636                 result[functionality.name].append(functionality.value)
637             else:
638                 result[functionality.name] = [functionality.value]
639         return result
640     @view_config(route_name="invalidate", renderer="json")  # type: ignore
641     def invalidate_cache(self) -&gt; Dict[str, bool]:
642         auth_view(self.request)
643         models.cache_invalidate_cb()
644         return {"success": True}
645     def _get_children(
646         self, theme: main.Theme, layers: List[str], min_levels: int
647     ) -&gt; Tuple[List[Dict[str, Any]], Set[str]]:
648         children = []
649         errors: Set[str] = set()
650         for item in theme.children:
651             if isinstance(item, main.LayerGroup):
652                 group_theme, gp_errors = self._group(
653                     f"{theme.name}/{item.name}", item, layers, min_levels=min_levels
654                 )
655                 errors |= gp_errors
656                 if group_theme is not None:
657                     children.append(group_theme)
658             elif self._layer_included(item):
659                 if min_levels &gt; 0:
660                     errors.add(
661                         f"The Layer '{item.name}' cannot be directly in the theme '{theme.name}' "
662                         f"(0/{min_levels:d})."
663                     )
664                 elif item.name in layers:
665                     layer_theme, l_errors = self._layer(item, dim=DimensionInformation())
666                     errors |= l_errors
667                     if layer_theme is not None:
668                         children.append(layer_theme)
669         return children, errors
670     @CACHE_REGION.cache_on_arguments()  # type: ignore
671     def _get_layers_enum(self) -&gt; Dict[str, Dict[str, str]]:
672         layers_enum = {}
673         if "enum" in self.settings.get("layers", {}):
674             for layer_name, layer in list(self.settings["layers"]["enum"].items()):
675                 layer_enum: Dict[str, str] = {}
676                 layers_enum[layer_name] = layer_enum
677                 for attribute in list(layer["attributes"].keys()):
678                     layer_enum[attribute] = self.request.route_url(
679                         "layers_enumerate_attribute_values",
680                         layer_name=layer_name,
681                         field_name=attribute,
682                         path="",
683                     )
684         return layers_enum
685     def _get_role_ids(self) -&gt; Optional[Set[int]]:
686         return None if self.request.user is None else {role.id for role in self.request.user.roles}
687     async def _wfs_get_features_type(
688         self, wfs_url: Url, ogc_server_name: str, preload: bool = False
689     ) -&gt; Tuple[Optional[etree.Element], Set[str]]:
690         errors = set()
691         wfs_url.add_query(
692             {
693                 "SERVICE": "WFS",
694                 "VERSION": "1.0.0",
695                 "REQUEST": "DescribeFeatureType",
696                 "ROLE_IDS": "0",
697                 "USER_ID": "0",
698             }
699         )
700         LOG.debug("WFS DescribeFeatureType for the URL: %s", wfs_url)
701         headers = dict(self.request.headers)
702         if wfs_url.hostname != "localhost" and "Host" in headers:
703             headers.pop("Host")
704         headers = restrict_headers(headers, self.headers_whitelist, self.headers_blacklist)
705         try:
706             content, _ = await asyncio.get_event_loop().run_in_executor(
707                 None, get_http_cached, self.http_options, wfs_url, headers
708             )
709         except requests.exceptions.RequestException as exception:
710             error = (
711                 f"Unable to get WFS DescribeFeatureType from the URL '{wfs_url.url()}' for "
712                 f"OGC server {ogc_server_name}, "
713                 + (
714                     f"return the error: {exception.response.status_code} {exception.response.reason}"
715                     if exception.response is not None
716                     else f"{exception}"
717                 )
718             )
719             errors.add(error)
720             LOG.exception(error)
721             return None, errors
722         except Exception:
723             error = (
724                 f"Unable to get WFS DescribeFeatureType from the URL {wfs_url} for "
725                 f"OGC server {ogc_server_name}"
726             )
727             errors.add(error)
728             LOG.exception(error)
729             return None, errors
730         if preload:
731             return None, errors
732         try:
733             return lxml.XML(content), errors
734         except Exception as e:
735             errors.add(
736                 f"Error '{e!s}' on reading DescribeFeatureType from URL {wfs_url}:\n{content.decode()}"
737             )
738             return None, errors
739     def get_url_internal_wfs(
740         self, ogc_server: main.OGCServer, errors: Set[str]
741     ) -&gt; Tuple[Optional[Url], Optional[Url], Optional[Url]]:
742         if ogc_server.auth != main.OGCSERVER_AUTH_NOAUTH:
743             url: Optional[Url] = Url(
744                 self.request.route_url("mapserverproxy", _query={"ogcserver": ogc_server.name})
745             )
746             url_wfs: Optional[Url] = url
747             url_internal_wfs = get_url2(
748                 f"The OGC server (WFS) '{ogc_server.name}'",
749                 ogc_server.url_wfs or ogc_server.url,
750                 self.request,
751                 errors=errors,
752             )
753         else:
754             url = get_url2(f"The OGC server '{ogc_server.name}'", ogc_server.url, self.request, errors=errors)
755             url_wfs = (
756                 get_url2(
757                     f"The OGC server (WFS) '{ogc_server.name}'",
758                     ogc_server.url_wfs,
759                     self.request,
760                     errors=errors,
761                 )
762                 if ogc_server.url_wfs is not None
763                 else url
764             )
765             url_internal_wfs = url_wfs
766         return url_internal_wfs, url, url_wfs
767     async def preload(self, errors: Set[str]) -&gt; None:
768         tasks = set()
769         for ogc_server in models.DBSession.query(main.OGCServer).all():
770             nb_layers = (
771                 models.DBSession.query(sqlalchemy.func.count(main.LayerWMS.id))
772                 .filter(main.LayerWMS.ogc_server_id == ogc_server.id)
773                 .one()
774             )
775             LOG.debug("%i layers for OGC server '%s'", nb_layers[0], ogc_server.name)
776             if nb_layers[0] &gt; 0:
777                 LOG.debug("Preload OGC server '%s'", ogc_server.name)
778                 url_internal_wfs, _, _ = self.get_url_internal_wfs(ogc_server, errors)
779                 if url_internal_wfs is not None:
780                     if ogc_server.wfs_support:
781                         tasks.add(self._wfs_get_features_type(url_internal_wfs, ogc_server.name, True))
782                     tasks.add(self._wms_getcap(ogc_server, True))
783         await asyncio.gather(*tasks)
784     @CACHE_REGION.cache_on_arguments()  # type: ignore
785     def _get_features_attributes(
786         self, url_internal_wfs: Url, ogc_server_name: str
787     ) -&gt; Tuple[Optional[Dict[str, Dict[Any, Dict[str, Any]]]], Optional[str], Set[str]]:
788         all_errors: Set[str] = set()
789         feature_type, errors = asyncio.run(self._wfs_get_features_type(url_internal_wfs, ogc_server_name))
790         LOG.debug("Run garbage collection: %s", ", ".join([str(gc.collect(n)) for n in range(3)]))
791         if errors:
792             all_errors |= errors
793             return None, None, all_errors
794         assert feature_type
795         namespace: str = feature_type.attrib.get("targetNamespace")
796         types: Dict[Any, Dict[str, Any]] = {}
797         elements = {}
798         for child in feature_type.getchildren():
799             if child.tag == "{http://www.w3.org/2001/XMLSchema}element":
800                 name = child.attrib["name"]
801                 type_namespace, type_ = child.attrib["type"].split(":")
802                 if type_namespace not in child.nsmap:
803                     LOG.info(
804                         "The namespace '%s' of the type '%s' is not found in the available namespaces: %s",
805                         type_namespace,
806                         name,
807                         ", ".join(child.nsmap.keys()),
808                     )
809                 if child.nsmap[type_namespace] != namespace:
810                     LOG.info(
811                         "The namespace '%s' of the thye '%s' should be '%s'.",
812                         child.nsmap[type_namespace],
813                         name,
814                         namespace,
815                     )
816                 elements[name] = type_
817             if child.tag == "{http://www.w3.org/2001/XMLSchema}complexType":
818                 sequence = child.find(".//{http://www.w3.org/2001/XMLSchema}sequence")
819                 attrib = {}
820                 for children in sequence.getchildren():
821                     type_namespace = None
822                     type_ = children.attrib["type"]
823                     if len(type_.split(":")) == 2:
824                         type_namespace, type_ = type_.split(":")
825                     type_namespace = children.nsmap[type_namespace]
826                     name = children.attrib["name"]
827                     attrib[name] = {"namespace": type_namespace, "type": type_}
828                     for key, value in children.attrib.items():
829                         if key not in ("name", "type", "namespace"):
830                             attrib[name][key] = value
831                 types[child.attrib["name"]] = attrib
832         attributes: Dict[str, Dict[Any, Dict[str, Any]]] = {}
833         for name, type_ in elements.items():
834             if type_ in types:
835                 attributes[name] = types[type_]
836             elif (type_ == "Character") and (name + "Type") in types:
837                 LOG.debug(
838                     "Due mapserver strange result the type 'ms:Character' is fallbacked to type '%sType'"
839                     " for feature '%s', This is a strange comportement of mapserver when we use the "
840                     'METADATA "gml_types" "auto"',
841                     name,
842                     name,
843                 )
844                 attributes[name] = types[name + "Type"]
845             else:
846                 LOG.warning(
847                     "The provided type '%s' does not exist, available types are %s.",
848                     type_,
849                     ", ".join(types.keys()),
850                 )
851         return attributes, namespace, all_errors
852     @view_config(route_name="themes", renderer="json")  # type: ignore
853     def themes(self) -&gt; Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]]:
854         interface = self.request.params.get("interface", "desktop")
855         sets = self.request.params.get("set", "all")
856         min_levels = int(self.request.params.get("min_levels", 1))
857         group = self.request.params.get("group")
858         background_layers_group = self.request.params.get("background")
859         set_common_headers(self.request, "themes", Cache.PRIVATE)
860         def get_theme() -&gt; Dict[str, Union[Dict[str, Any], List[str]]]:
861             export_themes = sets in ("all", "themes")
862             export_group = group is not None and sets in ("all", "group")
863             export_background = background_layers_group is not None and sets in ("all", "background")
864             result: Dict[str, Union[Dict[str, Any], List[Any]]] = {}
865             all_errors: Set[str] = set()
866             LOG.debug("Start preload")
867             start_time = time.time()
868             asyncio.run(self.preload(all_errors))
869             LOG.debug("End preload")
870             if (time.time() - start_time) &gt; 1:
871                 LOG.info("Do preload in %.3fs.", time.time() - start_time)
872 <a name="1"></a>            result["ogcServers"] = {}
873             for ogc_server in models.DBSession.query(main.OGCServer).all():
874                 nb_layers = (
875                     models.DBSession.query(sqlalchemy.func<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.count(main.LayerWMS.id))
876                     .filter(main.LayerWMS.ogc_server_id == ogc_server.id)
877                     .one()
878                 )
879                 if nb_layers[</b></font>0] == 0:
880                     continue
881                 url_internal_wfs, url, url_wfs = self.get_url_internal_wfs(ogc_server, all_errors)
882                 attributes = None
883                 namespace = None
884                 if ogc_server.wfs_support:
885                     attributes, namespace, errors = self._get_features_attributes(
886                         url_internal_wfs, ogc_server.name
887                     )
888                     if attributes is not None:
889                         attributes = dict(attributes)
890                     all_errors |= errors
891                     all_private_layers = get_private_layers([ogc_server.id]).values()
892                     protected_layers_name = [
893                         layer.name for layer in get_protected_layers(self.request, [ogc_server.id]).values()
894                     ]
895                     private_layers_name: List[str] = []
896                     for layers in [
897                         v.layer for v in all_private_layers if v.name not in protected_layers_name
898                     ]:
899                         private_layers_name.extend(layers.split(","))
900                     if attributes is not None:
901                         for name in private_layers_name:
902                             if name in attributes:
903                                 del attributes[name]
904                 result["ogcServers"][ogc_server.name] = {
905                     "url": url.url() if url else None,
906                     "urlWfs": url_wfs.url() if url_wfs else None,
907                     "type": ogc_server.type,
908                     "credential": ogc_server.auth != main.OGCSERVER_AUTH_NOAUTH,
909                     "imageType": ogc_server.image_type,
910                     "wfsSupport": ogc_server.wfs_support,
911                     "isSingleTile": ogc_server.is_single_tile,
912                     "namespace": namespace,
913                     "attributes": attributes,
914                 }
915             if export_themes:
916                 themes, errors = self._themes(interface, True, min_levels)
917                 result["themes"] = themes
918                 all_errors |= errors
919             if export_group:
920                 exported_group, errors = self._get_group(group, interface)
921                 if exported_group is not None:
922                     result["group"] = exported_group
923                 all_errors |= errors
924             if export_background:
925                 exported_group, errors = self._get_group(background_layers_group, interface)
926                 result["background_layers"] = exported_group["children"] if exported_group is not None else []
927                 all_errors |= errors
928             result["errors"] = list(all_errors)
929             if all_errors:
930                 LOG.info("Theme errors:\n%s", "\n".join(all_errors))
931             return result
932         @CACHE_REGION.cache_on_arguments()  # type: ignore
933         def get_theme_anonymous(
934             intranet: bool,
935             interface: str,
936             sets: str,
937             min_levels: str,
938             group: str,
939             background_layers_group: str,
940             host: str,
941         ) -&gt; Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]]:
942             del intranet, interface, sets, min_levels, group, background_layers_group, host
943             return get_theme()
944         if self.request.user is None:
945             return cast(
946                 Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]],
947                 get_theme_anonymous(
948                     is_intranet(self.request),
949                     interface,
950                     sets,
951                     min_levels,
952                     group,
953                     background_layers_group,
954                     self.request.headers.get("Host"),
955                 ),
956             )
957         return get_theme()
958     def _get_group(
959         self, group: main.LayerGroup, interface: main.Interface
960     ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
961         layers = self._layers(interface)
962         try:
963             group_db = models.DBSession.query(main.LayerGroup).filter(main.LayerGroup.name == group).one()
964             return self._group(group_db.name, group_db, layers, depth=2, dim=DimensionInformation())
965         except NoResultFound:
966             return (
967                 None,
968                 {
969                     f"Unable to find the Group named: {group}, Available Groups: "
970                     f"{', '.join([i[0] for i in models.DBSession.query(main.LayerGroup.name).all()])}"
971                 },
972             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
