<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for authentication_1.py &amp; theme.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for authentication_1.py &amp; theme.py
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>authentication_1.py (13.069909%)<th>theme.py (2.0197275%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(29-51)<td><a href="#" name="0">(46-67)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(126-135)<td><a href="#" name="1">(1064-1068)</a><td align="center"><font color="#b80000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(59-65)<td><a href="#" name="2">(152-159)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>authentication_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import binascii
2 import json
3 import logging
4 import os
5 import time
6 from typing import Any, Callable, Dict, List, Optional, cast
7 import pyramid.request
8 from Crypto.Cipher import AES  # nosec
9 from pyramid.authentication import (
10     AuthTktAuthenticationPolicy,
11     BasicAuthAuthenticationPolicy,
12     CallbackAuthenticationPolicy,
13 )
14 from pyramid.interfaces import IAuthenticationPolicy
15 from pyramid.security import remember
16 from pyramid_multiauth import MultiAuthenticationPolicy
17 from zope.interface import implementer
18 from c2cgeoportal_geoportal.lib import oauth2
19 from c2cgeoportal_geoportal.resources import defaultgroupsfinder
20 LOG = logging.getLogger(</b></font>__name__)
21 @implementer(IAuthenticationPolicy)
22 class UrlAuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
23     def __init__(
24         self, aes_key: str, callback: Optional[Callable[[str, Any], List[str]]] = None, debug: bool <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= False
25     ):
26         self.aeskey = aes_key
27         self.callback = callback
28         self.debug = debug
29     def unauthenticated_userid(self, request: pyramid.request.Request) -&gt; Optional[</b></font>str]:
30         if not request.method == "GET" or "auth" not in request.params:
31             return None
32         auth_enc = request.params.get("auth")
33         if auth_enc is None:
34             return None
35         try:
36             if self.aeskey is None:  # pragma: nocover
37                 raise Exception("urllogin is not configured")
38             now = int(time.time())
39             data = binascii.unhexlify(auth_enc.encode("ascii"))
40             nonce = data[0:16]
41             tag = data[16:32]
42             ciphertext = data[32:]
43             cipher = AES.new(self.aeskey.encode("ascii"), AES.MODE_EAX, nonce)
44             auth = json.loads(cipher.decrypt_and_verify(ciphertext, tag).decode("utf-8"))  # type: ignore
45             if "t" in auth and "u" in auth and "p" in auth:
46                 timestamp = int(auth["t"])
47                 if now &lt; timestamp and request.registry.validate_user(request, auth["u"], auth["p"]):
48                     headers = remember(request, auth["u"])
49                     request.response.headerlist.extend(headers)
50                     return cast(str, auth["u"])
51         except Exception as e:
52             LOG.error("URL login error: %s.", e, exc_info=True)
53         return None
54     def remember(  # pylint: disable=no-self-use
55         self, request: pyramid.request.Request, userid: str, **kw: Any
56     ) -&gt; List[Dict[str, str]]:
57         del request, userid, kw
58         return []
59     def forget(self, request: pyramid.request.Request) -&gt; List[Dict[str, str]]:  # pylint: disable=no-self-use
60         del request
61         return []
62 @implementer(IAuthenticationPolicy)
63 class OAuth2AuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
64     @staticmethod
65     def unauthenticated_userid(request: pyramid.request.Request) -&gt; Optional[str]:
66         route_url = ""
67         try:
68             route_url = request.current_route_url(_query=request.GET)
69         except ValueError:
70             route_url = request.route_url("base", _query=request.GET)
71         LOG.debug(
72             "Call OAuth verify_request with:\nurl: %s\nmethod: %s\nbody:\n%s",
73             route_url,
74             request.body,
75         )
76         valid, oauth2_request = oauth2<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.get_oauth_client(request.registry.settings).verify_request(
77             route_url,
78             request.method,
79             request.body,
80             request.headers,
81             [],
82         )
83         LOG.debug("OAuth verify_request: %s", valid)
84         if valid:
85             request.</b></font>user_ = oauth2_request.user
86             return cast(str, request.user_.username)
87         return None
88     def remember(  # pylint: disable=no-self-use
89         self, request: pyramid.request.Request, userid: str, **kw: Any
90     ) -&gt; List[Dict[str, str]]:
91         del request, userid, kw
92         return []
93     def forget(self, request: pyramid.request.Request) -&gt; List[Dict[str, str]]:  # pylint: disable=no-self-use
94         del request
95         return []
96 @implementer(IAuthenticationPolicy)
97 class DevAuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
98     @staticmethod
99     def unauthenticated_userid(request: pyramid.request.Request) -&gt; Optional[str]:
100         del request
101         return os.environ["DEV_LOGINNAME"]
102 def create_authentication(settings: Dict[str, Any]) -&gt; MultiAuthenticationPolicy:
103     timeout = settings.get("authtkt_timeout")
104     timeout = None if timeout is None or timeout.lower() == "none" else int(timeout)
105     reissue_time = settings.get("authtkt_reissue_time")
106     reissue_time = None if reissue_time is None or reissue_time.lower() == "none" else int(reissue_time)
107     max_age = settings.get("authtkt_max_age")
108     max_age = None if max_age is None or max_age.lower() == "none" else int(max_age)
109     http_only = settings.get("authtkt_http_only", "True")
110     http_only = http_only.lower() in ("true", "yes", "1")
111     secure = settings.get("authtkt_secure", "True")
112     secure = secure.lower() in ("true", "yes", "1")
113     samesite = settings.get("authtkt_samesite", "Lax")
114     secret = settings["authtkt_secret"]
115     basicauth = settings.get("basicauth", "False").lower() in ("true", "yes", "1")
116     if len(secret) &lt; 64:
117         raise Exception(
118             '"authtkt_secret should be at least 64 characters.'
119             "See https://docs.pylonsproject.org/projects/pyramid/en/latest/api/session.html"
120         )
121     policies = []
122     policies.append(
123         UrlAuthenticationPolicy(
124             settings.get("urllogin", {}).get("aes_key"),
125             defaultgroupsfinder,
126         )
127     )
128     policies.append(
129         AuthTktAuthenticationPolicy(
130             secret,
131             callback=defaultgroupsfinder,
132             cookie_name=settings["authtkt_cookie_name"],
133             samesite=None if samesite == "" else samesite,
134             timeout=timeout,
135             max_age=max_age,
136             reissue_time=reissue_time,
137             hashalg="sha512",
138             http_only=http_only,
139             secure=secure,
140         )
141     )
142     policies.append(OAuth2AuthenticationPolicy())
143     if basicauth:
144         if settings["authentication"].get("two_factor", False):
145             LOG.warning(
146                 "Basic auth and tow factor auth should not be enable toogether, "
147                 "you should use OAuth2 instead of Basic auth"
148             )
149         basic_authentication_policy = BasicAuthAuthenticationPolicy(c2cgeoportal_check)
150         policies.append(basic_authentication_policy)
151     if "DEV_LOGINNAME" in os.environ and os.environ["DEV_LOGINNAME"]:
152         policies.append(DevAuthenticationPolicy())
153     return MultiAuthenticationPolicy(policies)
154 def c2cgeoportal_check(username: str, password: str, request: pyramid.request.Request) -&gt; Optional[List[str]]:
155     if request.registry.validate_user(request, username, password):
156         return defaultgroupsfinder(username, request)
157     return None
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>theme.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import asyncio
2 import gc
3 import logging
4 import os
5 import re
6 import sys
7 import time
8 from collections import Counter
9 from math import sqrt
10 from typing import Any, Dict, List, Optional, Set, Tuple, Union, cast
11 import pyramid.request
12 import requests
13 import sqlalchemy
14 from c2cwsgiutils.auth import auth_view
15 from defusedxml import lxml
16 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from lxml import etree  # nosec
17 from owslib.wms import WebMapService
18 from pyramid.view import view_config
19 from sqlalchemy.orm import subqueryload
20 from sqlalchemy.orm.exc import NoResultFound
21 from c2cgeoportal_commons import models
22 from c2cgeoportal_commons.lib.url import Url, get_url2
23 from c2cgeoportal_commons.models import main
24 from c2cgeoportal_geoportal.lib import get_roles_id, get_typed, get_types_map, is_intranet
25 from c2cgeoportal_geoportal.lib.caching import Cache, get_region, set_common_headers
26 from c2cgeoportal_geoportal.lib.functionality import get_mapserver_substitution_params
27 from c2cgeoportal_geoportal.lib.layers import (
28     get_private_layers,
29     get_protected_layers,
30     get_protected_layers_query,
31 )
32 from c2cgeoportal_geoportal.lib.wmstparsing import TimeInformation, parse_extent
33 from c2cgeoportal_geoportal.views import restrict_headers
34 from c2cgeoportal_geoportal.views.layers import get_layer_metadata
35 LOG = logging.getLogger(</b></font>__name__)
36 CACHE_REGION = get_region("std")
37 TIMEOUT = int(os.environ.get("C2CGEOPORTAL_THEME_TIMEOUT", "300"))
38 Metadata = Union[str, int, float, bool, List[Any], Dict[str, Any]]
39 def get_http_cached(http_options: Dict[str, Any], url: str, headers: Dict[str, str]) -&gt; Tuple[bytes, str]:
40     @CACHE_REGION.cache_on_arguments()  # type: ignore
41     def do_get_http_cached(url: str) -&gt; Tuple[bytes, str]:
42         response = requests.get(url, headers=headers, timeout=TIMEOUT, **http_options)
43         response.raise_for_status()
44         LOG.info("Get url '%s' in %.1fs.", url, response.elapsed.total_seconds())
45         return response.content, response.headers.get("Content-Type", "")
46     return do_get_http_cached(url)  # type: ignore
47 class DimensionInformation:
48     URL_PART_RE = re.compile(r"[a-zA-Z0-9_\-\+~\.]*$")
49     def __init__(self) -&gt; None:
50         self._dimensions: Dict[str, str] = {}
51     def merge(self, layer: main.Layer, layer_node: Dict[str, Any], mixed: bool) -&gt; Set[str]:
52         errors = set()
53         dimensions: Dict[str, str] = {}
54         dimensions_filters = {}
55         for dimension in layer.dimensions:
56             if (
57                 not isinstance(layer, main.LayerWMS)
58                 and dimension.value is not None
59                 and not self.URL_PART_RE.match(dimension.value)
60             ):
61                 errors.add(
62                     f"The layer '{layer.name}' has an unsupported dimension value "
63                     f"'{dimension.value}' ('{dimension.name}')."
64                 )
65             elif dimension.name in dimensions:  # pragma: nocover
66                 errors.add(f"The layer '{layer.name}' has a duplicated dimension name '{dimension.name}'.")
67             else:
68                 if dimension.field:
69                     dimensions_filters[dimension.name] = {"field": dimension.field, "value": dimension.value}
70                 else:
71                     dimensions[dimension.name] = dimension.value
72         if dimensions_filters:
73             layer_node["dimensionsFilters"] = dimensions_filters
74         if mixed:
75             layer_node["dimensions"] = dimensions
76         else:
77             for name, value in list(dimensions.items()):
78                 if name not in self._dimensions or self._dimensions[name] is None:
79                     self._dimensions[name] = value
80                 elif self._dimensions[name] != value and value is not None:
81                     errors.add(
82                         f"The layer '{layer.name}' has a wrong dimension value '{value}' for '{name}', "
83                         f"expected '{self._dimensions[name]}' or empty."
84                     )
85         return errors
86     def get_dimensions(self) -&gt; Dict[str, str]:
87         return self._dimensions
88 class Theme:
89     def __init__(self, request: pyramid.request.Request):
90         self.request = request
91         self.settings = request.registry.settings
92         self.http_options = self.settings.get("http_options", {})
93         self.headers_whitelist = self.settings.get("headers_whitelist", [])
94         self.headers_blacklist = self.settings.get("headers_blacklist", [])
95         self.metadata_type = get_types_map(
96             self.settings.get("admin_interface", {}).get("available_metadata", [])
97         )
98         self._ogcservers_cache = None
99         self._treeitems_cache = None
100         self._layerswms_cache <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= None
101         self._layerswmts_cache = None
102         self._layergroup_cache = None
103         self._themes_cache = None
104     def _get_metadata(
105         self, item: main.TreeItem, metadata: str, errors: Set[str]
106     ) -&gt; Union[</b></font>None, str, int, float, bool, List[Any], Dict[str, Any]]:
107         metadatas = item.get_metadata(metadata)
108         return (
109             None
110             if not metadatas
111             else get_typed(
112                 metadata, metadatas[0].value, self.metadata_type, self.request, errors, layer_name=item.name
113             )
114         )
115     def _get_metadata_list(self, item: main.TreeItem, errors: Set[str]) -&gt; Dict[str, Metadata]:
116         metadatas: Dict[str, Metadata] = {}
117         metadata: main.Metadata
118         for metadata in item.metadatas:
119             value = get_typed(metadata.name, metadata.value, self.metadata_type, self.request, errors)
120             if value is not None:
121                 metadatas[metadata.name] = value
122         return metadatas
123     async def _wms_getcap(
124         self, ogc_server: main.OGCServer, preload: bool = False
125     ) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
126         try:
127             url, content, errors = await self._wms_getcap_cached(ogc_server)
128         except requests.exceptions.RequestException as exception:
129             error = (
130                 f"Unable to get the WMS Capabilities for OGC server '{ogc_server.name}', "
131                 f"return the error: {exception.response.status_code} {exception.response.reason}"
132             )
133             LOG.exception(error)
134             return None, {error}
135         if errors or preload:
136             return None, errors
137         @CACHE_REGION.cache_on_arguments()  # type: ignore
138         def build_web_map_service(ogc_server_id: int) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
139             del ogc_server_id  # Just for cache
140             if url is None:
141                 raise RuntimeError("Url is None")
142             version = url.query.get("VERSION", "1.1.1")
143             layers = {}
144             try:
145                 wms = WebMapService(None, xml=content, version=version)
146             except Exception as e:
147                 error = (
148                     f"WARNING! an error '{e!s}' occurred while trying to read the mapfile and "
149                     "recover the themes."
150                     f"\nURL: {url}\n{content.decode() if content else None}"
151                 )
152                 LOG.error(error, exc_info=True)
153                 return None, {error}
154             wms_layers_name = list(wms.contents)
155             for layer_name in wms_layers_name:
156                 wms_layer = wms[layer_name]
157                 resolution = self._get_layer_resolution_hint(wms_layer)
158                 info = {
159                     "name": wms_layer.name,
160                     "minResolutionHint": float(f"{resolution[0]:0.2f}"),
161                     "maxResolutionHint": float(f"{resolution[1]:0.2f}"),
162                 }
163                 if hasattr(wms_layer, "queryable"):
164                     info["queryable"] = wms_layer.queryable == 1
165                 layers[layer_name] = {
166                     "info": info,
167                     "timepositions": wms_layer.timepositions,
168                     "defaulttimeposition": wms_layer.defaulttimeposition,
169                     "children": [layer.name for layer in wms_layer.layers],
170                 }
171             del wms
172             LOG.debug("Run garbage collection: %s", ", ".join([str(gc.collect(n)) for n in range(3)]))
173             return {"layers": layers}, set()
174         return build_web_map_service(ogc_server.id)  # type: ignore
175     async def _wms_getcap_cached(
176         self, ogc_server: main.OGCServer
177     ) -&gt; Tuple[Optional[Url], Optional[bytes], Set[str]]:
178         errors: Set[str] = set()
179         url = get_url2(f"The OGC server '{ogc_server.name}'", ogc_server.url, self.request, errors)
180         if errors or url is None:
181             return url, None, errors
182         if (
183             ogc_server.auth == main.OGCSERVER_AUTH_STANDARD
184             and ogc_server.type == main.OGCSERVER_TYPE_MAPSERVER
185         ):
186             url.add_query(get_mapserver_substitution_params(self.request))
187         url.add_query(
188             {
189                 "SERVICE": "WMS",
190                 "VERSION": "1.1.1",
191                 "REQUEST": "GetCapabilities",
192                 "ROLE_IDS": "0",
193                 "USER_ID": "0",
194             },
195         )
196         LOG.debug("Get WMS GetCapabilities for URL: %s", url)
197         headers = dict(self.request.headers)
198         if ogc_server.auth == main.OGCSERVER_AUTH_GEOSERVER:
199             headers["sec-username"] = "root"
200             headers["sec-roles"] = "root"
201         if url.hostname != "localhost" and "Host" in headers:
202             headers.pop("Host")
203         headers = restrict_headers(headers, self.headers_whitelist, self.headers_blacklist)
204         try:
205             content, content_type = await asyncio.get_event_loop().run_in_executor(
206                 None, get_http_cached, self.http_options, url, headers
207             )
208         except Exception:
209             error = f"Unable to GetCapabilities from URL {url}"
210             errors.add(error)
211             LOG.error(error, exc_info=True)
212             return url, None, errors
213         if content_type.split(";")[0].strip() not in [
214             "application/vnd.ogc.wms_xml",
215             "text/xml",
216         ]:
217             error = (
218                 f"GetCapabilities from URL '{url}' returns a wrong Content-Type: {content_type}\n"
219                 f"{content.decode()}"
220             )
221             errors.add(error)
222             LOG.error(error)
223             return url, None, errors
224         return url, content, errors
225     def _create_layer_query(self, interface: str) -&gt; sqlalchemy.orm.query.Query:
226         query = models.DBSession.query(main.Layer.name).filter(main.Layer.public.is_(True))
227         if interface is not None:
228             query = query.join(main.Layer.interfaces)
229             query = query.filter(main.Interface.name == interface)
230         query2 = get_protected_layers_query(self.request, None, what=main.LayerWMS.name)
231         if interface is not None:
232             query2 = query2.join(main.Layer.interfaces)
233             query2 = query2.filter(main.Interface.name == interface)
234         query = query.union(query2)
235         query3 = get_protected_layers_query(self.request, None, what=main.LayerWMTS.name)
236         if interface is not None:
237             query3 = query3.join(main.Layer.interfaces)
238             query3 = query3.filter(main.Interface.name == interface)
239         query = query.union(query3)
240         return query
241     def _get_layer_metadata_urls(self, layer: main.Layer) -&gt; List[str]:
242         metadata_urls: List[str] = []
243         if layer.metadataUrls:
244             metadata_urls = layer.metadataUrls
245         for child_layer in layer.layers:
246             metadata_urls.extend(self._get_layer_metadata_urls(child_layer))
247         return metadata_urls
248     def _get_layer_resolution_hint_raw(self, layer: main.Layer) -&gt; Tuple[Optional[float], Optional[float]]:
249         resolution_hint_min = None
250         resolution_hint_max = None
251         if layer.scaleHint:
252             resolution_hint_min = float(layer.scaleHint["min"]) / sqrt(2)
253             resolution_hint_max = (
254                 float(layer.scaleHint["max"]) / sqrt(2)
255                 if layer.scaleHint["max"] not in ("0", "Infinity")
256                 else 999999999
257             )
258         for child_layer in layer.layers:
259             resolution = self._get_layer_resolution_hint_raw(child_layer)
260             resolution_hint_min = (
261                 resolution[0]
262                 if resolution_hint_min is None
263                 else (
264                     resolution_hint_min if resolution[0] is None else min(resolution_hint_min, resolution[0])
265                 )
266             )
267             resolution_hint_max = (
268                 resolution[1]
269                 if resolution_hint_max is None
270                 else (
271                     resolution_hint_max if resolution[1] is None else max(resolution_hint_max, resolution[1])
272                 )
273             )
274         return (resolution_hint_min, resolution_hint_max)
275     def _get_layer_resolution_hint(self, layer: main.Layer) -&gt; Tuple[float, float]:
276         resolution_hint_min, resolution_hint_max = self._get_layer_resolution_hint_raw(layer)
277         return (
278             0.0 if resolution_hint_min is None else resolution_hint_min,
279             999999999 if resolution_hint_max is None else resolution_hint_max,
280         )
281     def _layer(
282         self,
283         layer: main.Layer,
284         time_: Optional[TimeInformation] = None,
285         dim: Optional[DimensionInformation] = None,
286         mixed: bool = True,
287     ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
288         errors: Set[str] = set()
289         layer_info = {"id": layer.id, "name": layer.name, "metadata": self._get_metadata_list(layer, errors)}
290         if re.search("[/?#]", layer.name):
291             errors.add(f"The layer has an unsupported name '{layer.name}'.")
292         if isinstance(layer, main.LayerWMS) and re.search("[/?#]", layer.layer):
293             errors.add(f"The layer has an unsupported layers '{layer.layer}'.")
294         if layer.geo_table:
295             errors |= self._fill_editable(layer_info, layer)
296         if mixed:
297             assert time_ is None
298             time_ = TimeInformation()
299         assert time_ is not None
300         assert dim is not None
301         errors |= dim.merge(layer, layer_info, mixed)
302         if isinstance(layer, main.LayerWMS):
303             wms, wms_errors = self._wms_layers(layer.ogc_server)
304             errors |= wms_errors
305             if wms is None:
306                 return None if errors else layer_info, errors
307             if layer.layer is None or layer.layer == "":
308                 errors.add(f"The layer '{layer.name}' do not have any layers")
309                 return None, errors
310             layer_info["type"] = "WMS"
311             layer_info["layers"] = layer.layer
312             self._fill_wms(layer_info, layer, errors, mixed=mixed)
313             errors |= self._merge_time(time_, layer_info, layer, wms)
314         elif isinstance(layer, main.LayerWMTS):
315             layer_info["type"] = "WMTS"
316             self._fill_wmts(layer_info, layer, errors)
317         elif isinstance(layer, main.LayerVectorTiles):
318             layer_info["type"] = "VectorTiles"
319             self._vectortiles_layers(layer_info, layer, errors)
320         return None if errors else layer_info, errors
321     @staticmethod
322     def _merge_time(
323         time_: TimeInformation, layer_theme: Dict[str, Any], layer: main.Layer, wms: Dict[str, Dict[str, Any]]
324     ) -&gt; Set[str]:
325         errors = set()
326         wmslayer = layer.layer
327         def merge_time(wms_layer_obj: Dict[str, Any]) -&gt; None:
328             extent = parse_extent(wms_layer_obj["timepositions"], wms_layer_obj["defaulttimeposition"])
329             time_.merge(layer_theme, extent, layer.time_mode, layer.time_widget)
330         try:
331             if wmslayer in wms["layers"]:
332                 wms_layer_obj = wms["layers"][wmslayer]
333                 if layer.time_mode != "disabled":
334                     has_time = False
335                     if wms_layer_obj["timepositions"]:
336                         merge_time(wms_layer_obj)
337                         has_time = True
338                     else:
339                         for child_layer_name in wms_layer_obj["children"]:
340                             child_layer = wms["layers"][child_layer_name]
341                             if child_layer["timepositions"]:
342                                 merge_time(child_layer)  # The time mode comes from the wms layer group
343                                 has_time = True
344                     if not has_time:
345                         errors.add(
346                             f"Error: time layer '{layer.name}' has no time information in capabilities"
347                         )
348         except ValueError:  # pragma no cover
349             errors.add(f"Error while handling time for layer '{layer.name}': {sys.exc_info()[1]}")
350         return errors
351     def _fill_editable(self, layer_theme: Dict[str, Any], layer: main.Layer) -&gt; Set[str]:
352         errors = set()
353         try:
354             if self.request.user:
355                 count = (
356                     models.DBSession.query(main.RestrictionArea)
357                     .join(main.RestrictionArea.roles)
358                     .filter(main.Role.id.in_(get_roles_id(self.request)))
359                     .filter(main.RestrictionArea.layers.any(main.Layer.id == layer.id))
360                     .filter(main.RestrictionArea.readwrite.is_(True))
361                     .count()
362                 )
363                 if count &gt; 0:
364                     layer_theme["edit_columns"] = get_layer_metadata(layer)
365                     layer_theme["editable"] = True
366         except Exception as exception:
367             LOG.exception(str(exception))
368             errors.add(str(exception))
369         return errors
370     def _fill_child_layer(
371         self,
372         layer_theme: Dict[str, Any],
373         layer_name: str,
374         wms: Dict[str, Dict[str, Any]],
375     ) -&gt; None:
376         wms_layer_obj = wms["layers"][layer_name]
377         if not wms_layer_obj["children"]:
378             layer_theme["childLayers"].append(wms["layers"][layer_name]["info"])
379         else:
380             for child_layer in wms_layer_obj["children"]:
381                 self._fill_child_layer(layer_theme, child_layer, wms)
382     def _fill_wms(
383         self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str], mixed: bool
384     ) -&gt; None:
385         wms, wms_errors = self._wms_layers(layer.ogc_server)
386         errors |= wms_errors
387         if wms is None:
388             return
389         layer_theme["imageType"] = layer.ogc_server.image_type
390         if layer.style:
391             layer_theme["style"] = layer.style
392         layer_theme["childLayers"] = []
393         for layer_name in layer.layer.split(","):
394             if layer_name in wms["layers"]:
395                 self._fill_child_layer(layer_theme, layer_name, wms)
396             else:
397                 errors.add(
398                     f"The layer '{layer_name}' ({layer.name}) is not defined in WMS capabilities "
399                     f"from '{layer.ogc_server.name}'"
400                 )
401         if "minResolutionHint" not in layer_theme:
402             resolution_min = self._get_metadata(layer, "minResolution", errors)
403             if resolution_min is not None:
404                 layer_theme["minResolutionHint"] = resolution_min
405             else:
406                 min_resolutions_hint = [
407                     l_["minResolutionHint"] for l_ in layer_theme["childLayers"] if "minResolutionHint" in l_
408                 ]
409                 if min_resolutions_hint:
410                     layer_theme["minResolutionHint"] = min(min_resolutions_hint)
411         if "maxResolutionHint" not in layer_theme:
412             resolution_max = self._get_metadata(layer, "maxResolution", errors)
413             if resolution_max is not None:
414                 layer_theme["maxResolutionHint"] = resolution_max
415             else:
416                 max_resolutions_hint = [
417                     l_["maxResolutionHint"] for l_ in layer_theme["childLayers"] if "maxResolutionHint" in l_
418                 ]
419                 if max_resolutions_hint:
420                     layer_theme["maxResolutionHint"] = max(max_resolutions_hint)
421         if mixed:
422             layer_theme["ogcServer"] = layer.ogc_server.name
423     def _fill_wmts(self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str]) -&gt; None:
424         url = get_url2(f"The WMTS layer '{layer.name}'", layer.url, self.request, errors=errors)
425         layer_theme["url"] = url.url() if url is not None else None
426         if layer.style:
427             layer_theme["style"] = layer.style
428         if layer.matrix_set:
429             layer_theme["matrixSet"] = layer.matrix_set
430         layer_theme["layer"] = layer.layer
431         layer_theme["imageType"] = layer.image_type
432     def _vectortiles_layers(self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str]) -&gt; None:
433         style = get_url2(f"The VectorTiles layer '{layer.name}'", layer.style, self.request, errors=errors)
434         layer_theme["style"] = style.url() if style is not None else None
435         if layer.xyz:
436             layer_theme["xyz"] = layer.xyz
437     @staticmethod
438     def _layer_included(tree_item: main.TreeItem) -&gt; bool:
439         return isinstance(tree_item, main.Layer)
440     def _get_ogc_servers(self, group: main.LayerGroup, depth: int) -&gt; Set[Union[str, bool]]:
441         ogc_servers: Set[Union[str, bool]] = set()
442         if depth &gt; 30:
443             LOG.error("Error: too many recursions with group '%s'", group.name)
444             return ogc_servers
445         if isinstance(group, main.LayerGroup) and group.children:
446             for tree_item in group.children:
447                 ogc_servers.update(self._get_ogc_servers(tree_item, depth + 1))
448         if isinstance(group, main.LayerWMS):
449             ogc_servers.add(group.ogc_server.name)
450         if isinstance(group, main.LayerWMTS):
451             ogc_servers.add(False)
452         return ogc_servers
453     @staticmethod
454     def is_mixed(ogc_servers: List[Union[str, bool]]) -&gt; bool:
455         return len(ogc_servers) != 1 or ogc_servers[0] is False
456     def _group(
457         self,
458         path: str,
459         group: main.LayerGroup,
460         layers: List[str],
461         depth: int = 1,
462         min_levels: int = 1,
463         mixed: bool = True,
464         time_: Optional[TimeInformation] = None,
465         dim: Optional[DimensionInformation] = None,
466         wms_layers: Optional[List[str]] = None,
467         layers_name: Optional[List[str]] = None,
468         **kwargs: Any,
469     ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
470         if wms_layers is None:
471             wms_layers = []
472         if layers_name is None:
473             layers_name = []
474         children = []
475         errors = set()
476         if re.search("[/?#]", group.name):
477             errors.add(f"The group has an unsupported name '{group.name}'.")
478         if depth &gt; 30:
479             errors.add(f"Too many recursions with group '{group.name}'")
480             return None, errors
481         ogc_servers = None
482         org_depth = depth
483         if depth == 1:
484             ogc_servers = list(self._get_ogc_servers(group, 1))
485             mixed = self.is_mixed(ogc_servers)
486             if not mixed:
487                 time_ = TimeInformation()
488             dim = DimensionInformation()
489         for tree_item in group.children:
490             if isinstance(tree_item, main.LayerGroup):
491                 group_theme, gp_errors = self._group(
492                     f"{path}/{tree_item.name}",
493                     tree_item,
494                     layers,
495                     depth=depth + 1,
496                     min_levels=min_levels,
497                     mixed=mixed,
498                     time_=time_,
499                     dim=dim,
500                     wms_layers=wms_layers,
501                     layers_name=layers_name,
502                     **kwargs,
503                 )
504                 errors |= gp_errors
505                 if group_theme is not None:
506                     children.append(group_theme)
507             elif self._layer_included(tree_item):
508                 if tree_item.name in layers:
509                     layers_name.append(tree_item.name)
510                     if isinstance(tree_item, main.LayerWMS):
511                         wms_layers.extend(tree_item.layer.split(","))
512                     layer_theme, l_errors = self._layer(tree_item, mixed=mixed, time_=time_, dim=dim)
513                     errors |= l_errors
514                     if layer_theme is not None:
515                         if depth &lt; min_levels:
516                             errors.add(
517                                 f"The Layer '{path + '/' + tree_item.name}' is under indented "
518                                 f"({depth:d}/{min_levels:d})."
519                             )
520                         else:
521                             children.append(layer_theme)
522         if children:
523             group_theme = {
524                 "id": group.id,
525                 "name": group.name,
526                 "children": children,
527                 "metadata": self._get_metadata_list(group, errors),
528                 "mixed": False,
529             }
530             if not mixed:
531                 name: str
532                 for name, nb in Counter(layers_name).items():
533                     if nb &gt; 1:
534                         errors.add(
535                             f"The GeoMapFish layer name '{name}', cannot be two times "
536                             "in the same block (first level group)."
537                         )
538             group_theme["mixed"] = mixed
539             if org_depth == 1:
540                 if not mixed:
541                     assert time_ is not None
542                     assert dim is not None
543                     group_theme["ogcServer"] = cast(List[Any], ogc_servers)[0]
544                     if time_.has_time() and time_.layer is None:
545                         group_theme["time"] = time_.to_dict()
546                     group_theme["dimensions"] = dim.get_dimensions()
547             return group_theme, errors
548         return None, errors
549     def _layers(self, interface: str) -&gt; List[str]:
550         query = self._create_layer_query(interface=interface)
551         return [name for (name,) in query.all()]
552     def _wms_layers(self, ogc_server: main.OGCServer) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
553         wms, wms_errors = asyncio.run(self._wms_getcap(ogc_server))
554         if wms_errors:
555             return None, wms_errors
556         return wms, set()
557     def _load_tree_items(self) -&gt; None:
558         self._ogcservers_cache = models.DBSession.query(main.OGCServer).all()
559         self._treeitems_cache = models.DBSession.query(main.TreeItem).all()
560         self._layerswms_cache = (
561             models.DBSession.query(main.LayerWMS)
562             .options(subqueryload(main.LayerWMS.dimensions), subqueryload(main.LayerWMS.metadatas))
563             .all()
564         )
565         self._layerswmts_cache = (
566             models.DBSession.query(main.LayerWMTS)
567             .options(subqueryload(main.LayerWMTS.dimensions), subqueryload(main.LayerWMTS.metadatas))
568             .all()
569         )
570         self._layergroup_cache = (
571             models.DBSession.query(main.LayerGroup)
572             .options(subqueryload(main.LayerGroup.metadatas), subqueryload(main.LayerGroup.children_relation))
573             .all()
574         )
575         self._themes_cache = (
576             models.DBSession.query(main.Theme)
577             .options(
578                 subqueryload(main.Theme.functionalities),
579                 subqueryload(main.Theme.metadatas),
580                 subqueryload(main.Theme.children_relation),
581             )
582             .all()
583         )
584     def _themes(
585         self, interface: str = "desktop", filter_themes: bool = True, min_levels: int = 1
586     ) -&gt; Tuple[List[Dict[str, Any]], Set[str]]:
587         self._load_tree_items()
588         errors = set()
589         layers = self._layers(interface)
590         themes = models.DBSession.query(main.Theme)
591         themes = themes.filter(main.Theme.public.is_(True))
592         auth_themes = models.DBSession.query(main.Theme)
593         auth_themes = auth_themes.filter(main.Theme.public.is_(False))
594         auth_themes = auth_themes.join(main.Theme.restricted_roles)
595         auth_themes = auth_themes.filter(main.Role.id.in_(get_roles_id(self.request)))
596         themes = themes.union(auth_themes)
597         themes = themes.order_by(main.Theme.ordering.asc())
598         if filter_themes and interface is not None:
599             themes = themes.join(main.Theme.interfaces)
600             themes = themes.filter(main.Interface.name == interface)
601         export_themes = []
602         for theme in themes.all():
603             if re.search("[/?#]", theme.name):
604                 errors.add(f"The theme has an unsupported name '{theme.name}'.")
605                 continue
606             children, children_errors = self._get_children(theme, layers, min_levels)
607             errors |= children_errors
608             if children:
609                 url = (
610                     get_url2(f"The Theme '{theme.name}'", theme.icon, self.request, errors)
611                     if theme.icon is not None and theme.icon
612                     else None
613                 )
614                 icon = (
615                     url.url()
616                     if url is not None
617                     else self.request.static_url("/etc/geomapfish/static/images/blank.png")
618                 )
619                 theme_theme = {
620                     "id": theme.id,
621                     "name": theme.name,
622                     "icon": icon,
623                     "children": children,
624                     "functionalities": self._get_functionalities(theme),
625                     "metadata": self._get_metadata_list(theme, errors),
626                 }
627                 export_themes.append(theme_theme)
628         return export_themes, errors
629     @staticmethod
630     def _get_functionalities(theme: main.Theme) -&gt; Dict[str, List[str]]:
631         result: Dict[str, List[str]] = {}
632         for functionality in theme.functionalities:
633             if functionality.name in result:
634                 result[functionality.name].append(functionality.value)
635             else:
636                 result[functionality.name] = [functionality.value]
637         return result
638     @view_config(route_name="invalidate", renderer="json")  # type: ignore
639     def invalidate_cache(self) -&gt; Dict[str, bool]:
640         auth_view(self.request)
641         models.cache_invalidate_cb()
642         return {"success": True}
643     def _get_children(
644         self, theme: main.Theme, layers: List[str], min_levels: int
645     ) -&gt; Tuple[List[Dict[str, Any]], Set[str]]:
646         children = []
647         errors: Set[str] = set()
648         for item in theme.children:
649             if isinstance(item, main.LayerGroup):
650                 group_theme, gp_errors = self._group(
651                     f"{theme.name}/{item.name}", item, layers, min_levels=min_levels
652                 )
653                 errors |= gp_errors
654                 if group_theme is not None:
655                     children.append(group_theme)
656             elif self._layer_included(item):
657                 if min_levels &gt; 0:
658                     errors.add(
659                         f"The Layer '{item.name}' cannot be directly in the theme '{theme.name}' "
660                         f"(0/{min_levels:d})."
661                     )
662                 elif item.name in layers:
663                     layer_theme, l_errors = self._layer(item, dim=DimensionInformation())
664                     errors |= l_errors
665                     if layer_theme is not None:
666                         children.append(layer_theme)
667         return children, errors
668     @CACHE_REGION.cache_on_arguments()  # type: ignore
669     def _get_layers_enum(self) -&gt; Dict[str, Dict[str, str]]:
670         layers_enum = {}
671         if "enum" in self.settings.get("layers", {}):
672             for layer_name, layer in list(self.settings["layers"]["enum"].items()):
673                 layer_enum: Dict[str, str] = {}
674                 layers_enum[layer_name] = layer_enum
675                 for attribute in list(layer["attributes"].keys()):
676                     layer_enum[attribute] = self.request.route_url(
677                         "layers_enumerate_attribute_values",
678                         layer_name=layer_name,
679                         field_name=attribute,
680                         path="",
681                     )
682         return layers_enum
683     def _get_role_ids(self) -&gt; Optional[Set[int]]:
684         return None if self.request.user is None else {role.id for role in self.request.user.roles}
685     async def _wfs_get_features_type(
686         self, wfs_url: Url, ogc_server_name: str, preload: bool = False
687     ) -&gt; Tuple[Optional[etree.Element], Set[str]]:
688         errors = set()
689         wfs_url.add_query(
690             {
691                 "SERVICE": "WFS",
692                 "VERSION": "1.0.0",
693                 "REQUEST": "DescribeFeatureType",
694                 "ROLE_IDS": "0",
695                 "USER_ID": "0",
696             }
697         )
698         LOG.debug("WFS DescribeFeatureType for the URL: %s", wfs_url)
699         headers = dict(self.request.headers)
700         if wfs_url.hostname != "localhost" and "Host" in headers:
701             headers.pop("Host")
702         headers = restrict_headers(headers, self.headers_whitelist, self.headers_blacklist)
703         try:
704             content, _ = await asyncio.get_event_loop().run_in_executor(
705                 None, get_http_cached, self.http_options, wfs_url, headers
706             )
707         except requests.exceptions.RequestException as exception:
708             error = (
709                 f"Unable to get WFS DescribeFeatureType from the URL '{wfs_url.url()}' for "
710                 f"OGC server {ogc_server_name}, "
711                 + (
712                     f"return the error: {exception.response.status_code} {exception.response.reason}"
713                     if exception.response is not None
714                     else f"{exception}"
715                 )
716             )
717             errors.add(error)
718             LOG.exception(error)
719             return None, errors
720         except Exception:
721             error = (
722                 f"Unable to get WFS DescribeFeatureType from the URL {wfs_url} for "
723                 f"OGC server {ogc_server_name}"
724             )
725             errors.add(error)
726             LOG.exception(error)
727             return None, errors
728         if preload:
729             return None, errors
730         try:
731             return lxml.XML(content), errors
732         except Exception as e:
733             errors.add(
734                 f"Error '{e!s}' on reading DescribeFeatureType from URL {wfs_url}:\n{content.decode()}"
735             )
736             return None, errors
737     def get_url_internal_wfs(
738         self, ogc_server: main.OGCServer, errors: Set[str]
739     ) -&gt; Tuple[Optional[Url], Optional[Url], Optional[Url]]:
740         if ogc_server.auth != main.OGCSERVER_AUTH_NOAUTH:
741             url: Optional[Url] = Url(
742                 self.request.route_url("mapserverproxy", _query={"ogcserver": ogc_server.name})
743             )
744             url_wfs: Optional[Url] = url
745             url_internal_wfs = get_url2(
746                 f"The OGC server (WFS) '{ogc_server.name}'",
747                 ogc_server.url_wfs or ogc_server.url,
748                 self.request,
749                 errors=errors,
750             )
751         else:
752             url = get_url2(f"The OGC server '{ogc_server.name}'", ogc_server.url, self.request, errors=errors)
753             url_wfs = (
754                 get_url2(
755                     f"The OGC server (WFS) '{ogc_server.name}'",
756                     ogc_server.url_wfs,
757                     self.request,
758                     errors=errors,
759                 )
760                 if ogc_server.url_wfs is not None
761                 else url
762             )
763             url_internal_wfs = url_wfs
764         return url_internal_wfs, url, url_wfs
765     async def preload(self, errors: Set[str]) -&gt; None:
766         tasks = set()
767         for ogc_server in models.DBSession.query(main.OGCServer).all():
768             nb_layers = (
769                 models.DBSession.query(sqlalchemy.func.count(main.LayerWMS.id))
770                 .filter(main.LayerWMS.ogc_server_id == ogc_server.id)
771                 .one()
772             )
773             LOG.debug("%i layers for OGC server '%s'", nb_layers[0], ogc_server.name)
774             if nb_layers[0] &gt; 0:
775                 LOG.debug("Preload OGC server '%s'", ogc_server.name)
776                 url_internal_wfs, _, _ = self.get_url_internal_wfs(ogc_server, errors)
777                 if url_internal_wfs is not None:
778                     if ogc_server.wfs_support:
779                         tasks.add(self._wfs_get_features_type(url_internal_wfs, ogc_server.name, True))
780                     tasks.add(self._wms_getcap(ogc_server, True))
781         await asyncio.gather(*tasks)
782     @CACHE_REGION.cache_on_arguments()  # type: ignore
783     def _get_features_attributes(
784         self, url_internal_wfs: Url, ogc_server_name: str
785     ) -&gt; Tuple[Optional[Dict[str, Dict[Any, Dict[str, Any]]]], Optional[str], Set[str]]:
786         all_errors: Set[str] = set()
787         feature_type, errors = asyncio.run(self._wfs_get_features_type(url_internal_wfs, ogc_server_name))
788         LOG.debug("Run garbage collection: %s", ", ".join([str(gc.collect(n)) for n in range(3)]))
789         if errors:
790             all_errors |= errors
791             return None, None, all_errors
792         assert feature_type
793         namespace: str = feature_type.attrib.get("targetNamespace")
794         types: Dict[Any, Dict[str, Any]] = {}
795         elements = {}
796         for child in feature_type.getchildren():
797             if child.tag == "{http://www.w3.org/2001/XMLSchema}element":
798                 name = child.attrib["name"]
799                 type_namespace, type_ = child.attrib["type"].split(":")
800                 if type_namespace not in child.nsmap:
801                     LOG.info(
802                         "The namespace '%s' of the type '%s' is not found in the available namespaces: %s",
803                         type_namespace,
804                         name,
805                         ", ".join(child.nsmap.keys()),
806                     )
807                 if child.nsmap[type_namespace] != namespace:
808                     LOG.info(
809                         "The namespace '%s' of the thye '%s' should be '%s'.",
810                         child.nsmap[type_namespace],
811                         name,
812                         namespace,
813                     )
814                 elements[name] = type_
815             if child.tag == "{http://www.w3.org/2001/XMLSchema}complexType":
816                 sequence = child.find(".//{http://www.w3.org/2001/XMLSchema}sequence")
817                 attrib = {}
818                 for children in sequence.getchildren():
819                     type_namespace = None
820                     type_ = children.attrib["type"]
821                     if len(type_.split(":")) == 2:
822                         type_namespace, type_ = type_.split(":")
823                     type_namespace = children.nsmap[type_namespace]
824                     name = children.attrib["name"]
825                     attrib[name] = {"namespace": type_namespace, "type": type_}
826                     for key, value in children.attrib.items():
827                         if key not in ("name", "type", "namespace"):
828                             attrib[name][key] = value
829                 types[child.attrib["name"]] = attrib
830         attributes: Dict[str, Dict[Any, Dict[str, Any]]] = {}
831         for name, type_ in elements.items():
832             if type_ in types:
833                 attributes[name] = types[type_]
834             elif (type_ == "Character") and (name + "Type") in types:
835                 LOG.debug(
836                     "Due mapserver strange result the type 'ms:Character' is fallbacked to type '%sType'"
837                     " for feature '%s', This is a strange comportement of mapserver when we use the "
838                     'METADATA "gml_types" "auto"',
839                     name,
840                     name,
841                 )
842                 attributes[name] = types[name + "Type"]
843             else:
844                 LOG.warning(
845                     "The provided type '%s' does not exist, available types are %s.",
846                     type_,
847                     ", ".join(types.keys()),
848                 )
849         return attributes, namespace, all_errors
850     @view_config(route_name="themes", renderer="json")  # type: ignore
851     def themes(self) -&gt; Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]]:
852         interface = self.request.params.get("interface", "desktop")
853         sets = self.request.params.get("set", "all")
854         min_levels = int(self.request.params.get("min_levels", 1))
855         group = self.request.params.get("group")
856         background_layers_group = self.request.params.get("background")
857         set_common_headers(self.request, "themes", Cache.PRIVATE)
858         def get_theme() -&gt; Dict[str, Union[Dict[str, Any], List[str]]]:
859             export_themes = sets in ("all", "themes")
860             export_group = group is not None and sets in ("all", "group")
861             export_background = background_layers_group is not None and sets in ("all", "background")
862             result: Dict[str, Union[Dict[str, Any], List[Any]]] = {}
863             all_errors: Set[str] = set()
864             LOG.debug("Start preload")
865             start_time = time.time()
866             asyncio.run(self.preload(all_errors))
867             LOG.debug("End preload")
868             if (time.time() - start_time) &gt; 1:
869                 LOG.info("Do preload in %.3fs.", time.time() - start_time)
870             for ogc_server in models.DBSession.query(main.OGCServer).all():
871                 nb_layers = (
872                     models.DBSession.query(sqlalchemy.func<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.count(main.LayerWMS.id))
873                     .filter(main.LayerWMS.ogc_server_id == ogc_server.id)
874                     .one()
875                 )
876                 if nb_layers[</b></font>0] == 0:
877                     continue
878                 url_internal_wfs, url, url_wfs = self.get_url_internal_wfs(ogc_server, all_errors)
879                 attributes = None
880                 namespace = None
881                 if ogc_server.wfs_support:
882                     attributes, namespace, errors = self._get_features_attributes(
883                         url_internal_wfs, ogc_server.name
884                     )
885                     if attributes is not None:
886                         attributes = dict(attributes)
887                     all_errors |= errors
888                     all_private_layers = get_private_layers([ogc_server.id]).values()
889                     protected_layers_name = [
890                         layer.name for layer in get_protected_layers(self.request, [ogc_server.id]).values()
891                     ]
892                     private_layers_name: List[str] = []
893                     for layers in [
894                         v.layer for v in all_private_layers if v.name not in protected_layers_name
895                     ]:
896                         private_layers_name.extend(layers.split(","))
897                     if attributes is not None:
898                         for name in private_layers_name:
899                             if name in attributes:
900                                 del attributes[name]
901                 result["ogcServers"][ogc_server.name] = {
902                     "url": url.url() if url else None,
903                     "urlWfs": url_wfs.url() if url_wfs else None,
904                     "type": ogc_server.type,
905                     "credential": ogc_server.auth != main.OGCSERVER_AUTH_NOAUTH,
906                     "imageType": ogc_server.image_type,
907                     "wfsSupport": ogc_server.wfs_support,
908                     "isSingleTile": ogc_server.is_single_tile,
909                     "namespace": namespace,
910                     "attributes": attributes,
911                 }
912             if export_themes:
913                 themes, errors = self._themes(interface, True, min_levels)
914                 result["themes"] = themes
915                 all_errors |= errors
916             if export_group:
917                 exported_group, errors = self._get_group(group, interface)
918                 if exported_group is not None:
919                     result["group"] = exported_group
920                 all_errors |= errors
921             if export_background:
922                 exported_group, errors = self._get_group(background_layers_group, interface)
923                 result["background_layers"] = exported_group["children"] if exported_group is not None else []
924                 all_errors |= errors
925             result["errors"] = list(all_errors)
926             if all_errors:
927                 LOG.info("Theme errors:\n%s", "\n".join(all_errors))
928             return result
929         @CACHE_REGION.cache_on_arguments()  # type: ignore
930         def get_theme_anonymous(
931             intranet: bool,
932             interface: str,
933             sets: str,
934             min_levels: str,
935             group: str,
936             background_layers_group: str,
937             host: str,
938         ) -&gt; Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]]:
939             del intranet, interface, sets, min_levels, group, background_layers_group, host
940             return get_theme()
941         if self.request.user is None:
942             return cast(
943                 Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]],
944                 get_theme_anonymous(
945                     is_intranet(self.request),
946                     interface,
947                     sets,
948                     min_levels,
949                     group,
950                     background_layers_group,
951                     self.request.headers.get("Host"),
952                 ),
953             )
954         return get_theme()
955     def _get_group(
956         self, group: main.LayerGroup, interface: main.Interface
957     ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
958         layers = self._layers(interface)
959         try:
960             group_db = models.DBSession.query(main.LayerGroup).filter(main.LayerGroup.name == group).one()
961             return self._group(group_db.name, group_db, layers, depth=2, dim=DimensionInformation())
962         except NoResultFound:
963             return (
964                 None,
965                 {
966                     f"Unable to find the Group named: {group}, Available Groups: "
967                     f"{', '.join([i[0] for i in models.DBSession.query(main.LayerGroup.name).all()])}"
968                 },
969             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
