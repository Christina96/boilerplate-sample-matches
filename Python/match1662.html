<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for authentication_1.py & theme.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for authentication_1.py & theme.py
      </h3>
      <h1 align="center">
        3.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>authentication_1.py (13.069909%)<TH>theme.py (2.0197275%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1662-0.html#0',2,'match1662-1.html#0',3)" NAME="0">(29-51)<TD><A HREF="javascript:ZweiFrames('match1662-0.html#0',2,'match1662-1.html#0',3)" NAME="0">(46-67)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1662-0.html#1',2,'match1662-1.html#1',3)" NAME="1">(126-135)<TD><A HREF="javascript:ZweiFrames('match1662-0.html#1',2,'match1662-1.html#1',3)" NAME="1">(1064-1068)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1662-0.html#2',2,'match1662-1.html#2',3)" NAME="2">(59-65)<TD><A HREF="javascript:ZweiFrames('match1662-0.html#2',2,'match1662-1.html#2',3)" NAME="2">(152-159)</A><TD ALIGN=center><FONT COLOR="#aa0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>authentication_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# Copyright (c) 2014-2021, Camptocamp SA
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies,
<A NAME="0"></A># either expressed or implied, of the FreeBSD Project.


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1662-1.html#0',3,'match1662-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import binascii
import json
import logging
import os
import time
from typing import Any, Callable, Dict, List, Optional, cast

import pyramid.request
from Crypto.Cipher import AES  # nosec
from pyramid.authentication import (
    AuthTktAuthenticationPolicy,
    BasicAuthAuthenticationPolicy,
    CallbackAuthenticationPolicy,
)
from pyramid.interfaces import IAuthenticationPolicy
from pyramid.security import remember
from pyramid_multiauth import MultiAuthenticationPolicy
from zope.interface import implementer

from c2cgeoportal_geoportal.lib import oauth2
from c2cgeoportal_geoportal.resources import defaultgroupsfinder

LOG = logging.getLogger(</B></FONT>__name__)


@implementer(IAuthenticationPolicy)
class UrlAuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
<A NAME="2"></A>    &quot;&quot;&quot;An authentication policy based on information given in the URL.&quot;&quot;&quot;

    def __init__(
        self, aes_key: str, callback: Optional[Callable[[str, Any], List[str]]] = None, debug: bool <FONT color="#980517"><A HREF="javascript:ZweiFrames('match1662-1.html#2',3,'match1662-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= False
    ):
        self.aeskey = aes_key
        self.callback = callback
        self.debug = debug

    def unauthenticated_userid(self, request: pyramid.request.Request) -&gt; Optional[</B></FONT>str]:
        if not request.method == &quot;GET&quot; or &quot;auth&quot; not in request.params:
            return None
        auth_enc = request.params.get(&quot;auth&quot;)
        if auth_enc is None:
            return None
        try:
            if self.aeskey is None:  # pragma: nocover
                raise Exception(&quot;urllogin is not configured&quot;)
            now = int(time.time())
            data = binascii.unhexlify(auth_enc.encode(&quot;ascii&quot;))
            nonce = data[0:16]
            tag = data[16:32]
            ciphertext = data[32:]
            cipher = AES.new(self.aeskey.encode(&quot;ascii&quot;), AES.MODE_EAX, nonce)
            auth = json.loads(cipher.decrypt_and_verify(ciphertext, tag).decode(&quot;utf-8&quot;))  # type: ignore

            if &quot;t&quot; in auth and &quot;u&quot; in auth and &quot;p&quot; in auth:
                timestamp = int(auth[&quot;t&quot;])

                if now &lt; timestamp and request.registry.validate_user(request, auth[&quot;u&quot;], auth[&quot;p&quot;]):
                    headers = remember(request, auth[&quot;u&quot;])
                    request.response.headerlist.extend(headers)
                    return cast(str, auth[&quot;u&quot;])

        except Exception as e:
            LOG.error(&quot;URL login error: %s.&quot;, e, exc_info=True)

        return None

    def remember(  # pylint: disable=no-self-use
        self, request: pyramid.request.Request, userid: str, **kw: Any
    ) -&gt; List[Dict[str, str]]:
        &quot;&quot;&quot;Do no-op.&quot;&quot;&quot;
        del request, userid, kw
        return []

    def forget(self, request: pyramid.request.Request) -&gt; List[Dict[str, str]]:  # pylint: disable=no-self-use
        &quot;&quot;&quot;Do no-op.&quot;&quot;&quot;
        del request
        return []


@implementer(IAuthenticationPolicy)
class OAuth2AuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
    &quot;&quot;&quot;The oauth2 authentication policy.&quot;&quot;&quot;

    @staticmethod
    def unauthenticated_userid(request: pyramid.request.Request) -&gt; Optional[str]:
        route_url = &quot;&quot;
        try:
            route_url = request.current_route_url(_query=request.GET)
        except ValueError:
            route_url = request.route_url(&quot;base&quot;, _query=request.GET)

        LOG.debug(
            &quot;Call OAuth verify_request with:\nurl: %s\nmethod: %s\nbody:\n%s&quot;,
            route_url,
<A NAME="1"></A>            request.method,
            request.body,
        )
        valid, oauth2_request = oauth2<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1662-1.html#1',3,'match1662-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.get_oauth_client(request.registry.settings).verify_request(
            route_url,
            request.method,
            request.body,
            request.headers,
            [],
        )
        LOG.debug(&quot;OAuth verify_request: %s&quot;, valid)
        if valid:
            request.</B></FONT>user_ = oauth2_request.user

            return cast(str, request.user_.username)
        return None

    def remember(  # pylint: disable=no-self-use
        self, request: pyramid.request.Request, userid: str, **kw: Any
    ) -&gt; List[Dict[str, str]]:
        &quot;&quot;&quot;Do no-op.&quot;&quot;&quot;
        del request, userid, kw
        return []

    def forget(self, request: pyramid.request.Request) -&gt; List[Dict[str, str]]:  # pylint: disable=no-self-use
        &quot;&quot;&quot;Do no-op.&quot;&quot;&quot;
        del request
        return []


@implementer(IAuthenticationPolicy)
class DevAuthenticationPolicy(CallbackAuthenticationPolicy):  # type: ignore
    &quot;&quot;&quot;An authentication policy for the dev base on an environment variable.&quot;&quot;&quot;

    @staticmethod
    def unauthenticated_userid(request: pyramid.request.Request) -&gt; Optional[str]:
        &quot;&quot;&quot;Get the user name from the environment variable.&quot;&quot;&quot;
        del request
        return os.environ[&quot;DEV_LOGINNAME&quot;]


def create_authentication(settings: Dict[str, Any]) -&gt; MultiAuthenticationPolicy:
    &quot;&quot;&quot;Create all the authentication policies.&quot;&quot;&quot;
    timeout = settings.get(&quot;authtkt_timeout&quot;)
    timeout = None if timeout is None or timeout.lower() == &quot;none&quot; else int(timeout)
    reissue_time = settings.get(&quot;authtkt_reissue_time&quot;)
    reissue_time = None if reissue_time is None or reissue_time.lower() == &quot;none&quot; else int(reissue_time)
    max_age = settings.get(&quot;authtkt_max_age&quot;)
    max_age = None if max_age is None or max_age.lower() == &quot;none&quot; else int(max_age)
    http_only = settings.get(&quot;authtkt_http_only&quot;, &quot;True&quot;)
    http_only = http_only.lower() in (&quot;true&quot;, &quot;yes&quot;, &quot;1&quot;)
    secure = settings.get(&quot;authtkt_secure&quot;, &quot;True&quot;)
    secure = secure.lower() in (&quot;true&quot;, &quot;yes&quot;, &quot;1&quot;)
    samesite = settings.get(&quot;authtkt_samesite&quot;, &quot;Lax&quot;)
    secret = settings[&quot;authtkt_secret&quot;]
    basicauth = settings.get(&quot;basicauth&quot;, &quot;False&quot;).lower() in (&quot;true&quot;, &quot;yes&quot;, &quot;1&quot;)
    if len(secret) &lt; 64:
        raise Exception(
            '&quot;authtkt_secret should be at least 64 characters.'
            &quot;See https://docs.pylonsproject.org/projects/pyramid/en/latest/api/session.html&quot;
        )

    policies = []

    policies.append(
        UrlAuthenticationPolicy(
            settings.get(&quot;urllogin&quot;, {}).get(&quot;aes_key&quot;),
            defaultgroupsfinder,
        )
    )

    policies.append(
        AuthTktAuthenticationPolicy(
            secret,
            callback=defaultgroupsfinder,
            cookie_name=settings[&quot;authtkt_cookie_name&quot;],
            samesite=None if samesite == &quot;&quot; else samesite,
            timeout=timeout,
            max_age=max_age,
            reissue_time=reissue_time,
            hashalg=&quot;sha512&quot;,
            http_only=http_only,
            secure=secure,
        )
    )

    policies.append(OAuth2AuthenticationPolicy())

    if basicauth:
        if settings[&quot;authentication&quot;].get(&quot;two_factor&quot;, False):
            LOG.warning(
                &quot;Basic auth and tow factor auth should not be enable toogether, &quot;
                &quot;you should use OAuth2 instead of Basic auth&quot;
            )

        basic_authentication_policy = BasicAuthAuthenticationPolicy(c2cgeoportal_check)
        policies.append(basic_authentication_policy)

    # Consider empty string as not configured
    if &quot;DEV_LOGINNAME&quot; in os.environ and os.environ[&quot;DEV_LOGINNAME&quot;]:
        policies.append(DevAuthenticationPolicy())

    return MultiAuthenticationPolicy(policies)


def c2cgeoportal_check(username: str, password: str, request: pyramid.request.Request) -&gt; Optional[List[str]]:
    &quot;&quot;&quot;Check the user authentication.&quot;&quot;&quot;
    if request.registry.validate_user(request, username, password):
        return defaultgroupsfinder(username, request)
    return None
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>theme.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
# Copyright (c) 2011-2022, Camptocamp SA
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# The views and conclusions contained in the software and documentation are those
# of the authors and should not be interpreted as representing official policies,
# either expressed or implied, of the FreeBSD Project.


import asyncio
import gc
import logging
import os
import re
import sys
import time
from collections import Counter
from math import sqrt
from typing import Any, Dict, List, Optional, Set, Tuple, Union, cast

import pyramid.request
import requests
import sqlalchemy
<A NAME="0"></A>import sqlalchemy.orm.query
from c2cwsgiutils.auth import auth_view
from defusedxml import lxml
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1662-0.html#0',2,'match1662-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>from lxml import etree  # nosec
from owslib.wms import WebMapService
from pyramid.view import view_config
from sqlalchemy.orm import subqueryload
from sqlalchemy.orm.exc import NoResultFound

from c2cgeoportal_commons import models
from c2cgeoportal_commons.lib.url import Url, get_url2
from c2cgeoportal_commons.models import main
from c2cgeoportal_geoportal.lib import get_roles_id, get_typed, get_types_map, is_intranet
from c2cgeoportal_geoportal.lib.caching import Cache, get_region, set_common_headers
from c2cgeoportal_geoportal.lib.functionality import get_mapserver_substitution_params
from c2cgeoportal_geoportal.lib.layers import (
    get_private_layers,
    get_protected_layers,
    get_protected_layers_query,
)
from c2cgeoportal_geoportal.lib.wmstparsing import TimeInformation, parse_extent
from c2cgeoportal_geoportal.views import restrict_headers
from c2cgeoportal_geoportal.views.layers import get_layer_metadata

LOG = logging.getLogger(</B></FONT>__name__)
CACHE_REGION = get_region(&quot;std&quot;)
TIMEOUT = int(os.environ.get(&quot;C2CGEOPORTAL_THEME_TIMEOUT&quot;, &quot;300&quot;))

Metadata = Union[str, int, float, bool, List[Any], Dict[str, Any]]


def get_http_cached(http_options: Dict[str, Any], url: str, headers: Dict[str, str]) -&gt; Tuple[bytes, str]:
    &quot;&quot;&quot;Get the content of the URL with a cash (dogpile).&quot;&quot;&quot;

    @CACHE_REGION.cache_on_arguments()  # type: ignore
    def do_get_http_cached(url: str) -&gt; Tuple[bytes, str]:
        response = requests.get(url, headers=headers, timeout=TIMEOUT, **http_options)
        response.raise_for_status()
        LOG.info(&quot;Get url '%s' in %.1fs.&quot;, url, response.elapsed.total_seconds())
        return response.content, response.headers.get(&quot;Content-Type&quot;, &quot;&quot;)

    return do_get_http_cached(url)  # type: ignore


class DimensionInformation:
    &quot;&quot;&quot;Used to collect the dimensions information.&quot;&quot;&quot;

    URL_PART_RE = re.compile(r&quot;[a-zA-Z0-9_\-\+~\.]*$&quot;)

    def __init__(self) -&gt; None:
        self._dimensions: Dict[str, str] = {}

    def merge(self, layer: main.Layer, layer_node: Dict[str, Any], mixed: bool) -&gt; Set[str]:
        errors = set()

        dimensions: Dict[str, str] = {}
        dimensions_filters = {}
        for dimension in layer.dimensions:
            if (
                not isinstance(layer, main.LayerWMS)
                and dimension.value is not None
                and not self.URL_PART_RE.match(dimension.value)
            ):
                errors.add(
                    f&quot;The layer '{layer.name}' has an unsupported dimension value &quot;
                    f&quot;'{dimension.value}' ('{dimension.name}').&quot;
                )
            elif dimension.name in dimensions:  # pragma: nocover
                errors.add(f&quot;The layer '{layer.name}' has a duplicated dimension name '{dimension.name}'.&quot;)
            else:
                if dimension.field:
                    dimensions_filters[dimension.name] = {&quot;field&quot;: dimension.field, &quot;value&quot;: dimension.value}
                else:
                    dimensions[dimension.name] = dimension.value

        if dimensions_filters:
            layer_node[&quot;dimensionsFilters&quot;] = dimensions_filters
        if mixed:
            layer_node[&quot;dimensions&quot;] = dimensions
        else:
            for name, value in list(dimensions.items()):
                if name not in self._dimensions or self._dimensions[name] is None:
                    self._dimensions[name] = value
                elif self._dimensions[name] != value and value is not None:
                    errors.add(
                        f&quot;The layer '{layer.name}' has a wrong dimension value '{value}' for '{name}', &quot;
                        f&quot;expected '{self._dimensions[name]}' or empty.&quot;
                    )
        return errors

    def get_dimensions(self) -&gt; Dict[str, str]:
        return self._dimensions


class Theme:
    &quot;&quot;&quot;All the views concerning the themes.&quot;&quot;&quot;

    def __init__(self, request: pyramid.request.Request):
        self.request = request
        self.settings = request.registry.settings
        self.http_options = self.settings.get(&quot;http_options&quot;, {})
        self.headers_whitelist = self.settings.get(&quot;headers_whitelist&quot;, [])
        self.headers_blacklist = self.settings.get(&quot;headers_blacklist&quot;, [])
        self.metadata_type = get_types_map(
            self.settings.get(&quot;admin_interface&quot;, {}).get(&quot;available_metadata&quot;, [])
        )
<A NAME="2"></A>
        self._ogcservers_cache = None
        self._treeitems_cache = None
        self._layerswms_cache <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1662-0.html#2',2,'match1662-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= None
        self._layerswmts_cache = None
        self._layergroup_cache = None
        self._themes_cache = None

    def _get_metadata(
        self, item: main.TreeItem, metadata: str, errors: Set[str]
    ) -&gt; Union[</B></FONT>None, str, int, float, bool, List[Any], Dict[str, Any]]:
        metadatas = item.get_metadata(metadata)
        return (
            None
            if not metadatas
            else get_typed(
                metadata, metadatas[0].value, self.metadata_type, self.request, errors, layer_name=item.name
            )
        )

    def _get_metadata_list(self, item: main.TreeItem, errors: Set[str]) -&gt; Dict[str, Metadata]:
        metadatas: Dict[str, Metadata] = {}
        metadata: main.Metadata
        for metadata in item.metadatas:
            value = get_typed(metadata.name, metadata.value, self.metadata_type, self.request, errors)
            if value is not None:
                metadatas[metadata.name] = value

        return metadatas

    async def _wms_getcap(
        self, ogc_server: main.OGCServer, preload: bool = False
    ) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:

        try:
            url, content, errors = await self._wms_getcap_cached(ogc_server)
        except requests.exceptions.RequestException as exception:
            error = (
                f&quot;Unable to get the WMS Capabilities for OGC server '{ogc_server.name}', &quot;
                f&quot;return the error: {exception.response.status_code} {exception.response.reason}&quot;
            )
            LOG.exception(error)
            return None, {error}
        if errors or preload:
            return None, errors

        @CACHE_REGION.cache_on_arguments()  # type: ignore
        def build_web_map_service(ogc_server_id: int) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
            del ogc_server_id  # Just for cache

            if url is None:
                raise RuntimeError(&quot;Url is None&quot;)

            version = url.query.get(&quot;VERSION&quot;, &quot;1.1.1&quot;)
            layers = {}
            try:
                wms = WebMapService(None, xml=content, version=version)
            except Exception as e:
                error = (
                    f&quot;WARNING! an error '{e!s}' occurred while trying to read the mapfile and &quot;
                    &quot;recover the themes.&quot;
                    f&quot;\nURL: {url}\n{content.decode() if content else None}&quot;
                )
                LOG.error(error, exc_info=True)
                return None, {error}
            wms_layers_name = list(wms.contents)
            for layer_name in wms_layers_name:
                wms_layer = wms[layer_name]
                resolution = self._get_layer_resolution_hint(wms_layer)
                info = {
                    &quot;name&quot;: wms_layer.name,
                    &quot;minResolutionHint&quot;: float(f&quot;{resolution[0]:0.2f}&quot;),
                    &quot;maxResolutionHint&quot;: float(f&quot;{resolution[1]:0.2f}&quot;),
                }
                if hasattr(wms_layer, &quot;queryable&quot;):
                    info[&quot;queryable&quot;] = wms_layer.queryable == 1

                layers[layer_name] = {
                    &quot;info&quot;: info,
                    &quot;timepositions&quot;: wms_layer.timepositions,
                    &quot;defaulttimeposition&quot;: wms_layer.defaulttimeposition,
                    &quot;children&quot;: [layer.name for layer in wms_layer.layers],
                }

            del wms
            LOG.debug(&quot;Run garbage collection: %s&quot;, &quot;, &quot;.join([str(gc.collect(n)) for n in range(3)]))

            return {&quot;layers&quot;: layers}, set()

        return build_web_map_service(ogc_server.id)  # type: ignore

    async def _wms_getcap_cached(
        self, ogc_server: main.OGCServer
    ) -&gt; Tuple[Optional[Url], Optional[bytes], Set[str]]:
        errors: Set[str] = set()
        url = get_url2(f&quot;The OGC server '{ogc_server.name}'&quot;, ogc_server.url, self.request, errors)
        if errors or url is None:
            return url, None, errors

        # Add functionality params
        if (
            ogc_server.auth == main.OGCSERVER_AUTH_STANDARD
            and ogc_server.type == main.OGCSERVER_TYPE_MAPSERVER
        ):
            url.add_query(get_mapserver_substitution_params(self.request))

        url.add_query(
            {
                &quot;SERVICE&quot;: &quot;WMS&quot;,
                &quot;VERSION&quot;: &quot;1.1.1&quot;,
                &quot;REQUEST&quot;: &quot;GetCapabilities&quot;,
                &quot;ROLE_IDS&quot;: &quot;0&quot;,
                &quot;USER_ID&quot;: &quot;0&quot;,
            },
        )

        LOG.debug(&quot;Get WMS GetCapabilities for URL: %s&quot;, url)

        # Forward request to target (without Host Header)
        headers = dict(self.request.headers)

        # Add headers for Geoserver
        if ogc_server.auth == main.OGCSERVER_AUTH_GEOSERVER:
            headers[&quot;sec-username&quot;] = &quot;root&quot;
            headers[&quot;sec-roles&quot;] = &quot;root&quot;

        if url.hostname != &quot;localhost&quot; and &quot;Host&quot; in headers:
            headers.pop(&quot;Host&quot;)

        headers = restrict_headers(headers, self.headers_whitelist, self.headers_blacklist)

        try:
            content, content_type = await asyncio.get_event_loop().run_in_executor(
                None, get_http_cached, self.http_options, url, headers
            )
        except Exception:
            error = f&quot;Unable to GetCapabilities from URL {url}&quot;
            errors.add(error)
            LOG.error(error, exc_info=True)
            return url, None, errors

        # With wms 1.3 it returns text/xml also in case of error :-(
        if content_type.split(&quot;;&quot;)[0].strip() not in [
            &quot;application/vnd.ogc.wms_xml&quot;,
            &quot;text/xml&quot;,
        ]:
            error = (
                f&quot;GetCapabilities from URL '{url}' returns a wrong Content-Type: {content_type}\n&quot;
                f&quot;{content.decode()}&quot;
            )
            errors.add(error)
            LOG.error(error)
            return url, None, errors

        return url, content, errors

    def _create_layer_query(self, interface: str) -&gt; sqlalchemy.orm.query.Query:
        &quot;&quot;&quot;Create an SQLAlchemy query for Layer and for the role identified to by ``role_id``.&quot;&quot;&quot;
        query = models.DBSession.query(main.Layer.name).filter(main.Layer.public.is_(True))

        if interface is not None:
            query = query.join(main.Layer.interfaces)
            query = query.filter(main.Interface.name == interface)

        query2 = get_protected_layers_query(self.request, None, what=main.LayerWMS.name)
        if interface is not None:
            query2 = query2.join(main.Layer.interfaces)
            query2 = query2.filter(main.Interface.name == interface)
        query = query.union(query2)
        query3 = get_protected_layers_query(self.request, None, what=main.LayerWMTS.name)
        if interface is not None:
            query3 = query3.join(main.Layer.interfaces)
            query3 = query3.filter(main.Interface.name == interface)
        query = query.union(query3)

        return query

    def _get_layer_metadata_urls(self, layer: main.Layer) -&gt; List[str]:
        metadata_urls: List[str] = []
        if layer.metadataUrls:
            metadata_urls = layer.metadataUrls
        for child_layer in layer.layers:
            metadata_urls.extend(self._get_layer_metadata_urls(child_layer))
        return metadata_urls

    def _get_layer_resolution_hint_raw(self, layer: main.Layer) -&gt; Tuple[Optional[float], Optional[float]]:
        resolution_hint_min = None
        resolution_hint_max = None
        if layer.scaleHint:
            # scaleHint is based upon a pixel diagonal length whereas we use
            # resolutions based upon a pixel edge length. There is a sqrt(2)
            # ratio between edge and diagonal of a square.
            resolution_hint_min = float(layer.scaleHint[&quot;min&quot;]) / sqrt(2)
            resolution_hint_max = (
                float(layer.scaleHint[&quot;max&quot;]) / sqrt(2)
                if layer.scaleHint[&quot;max&quot;] not in (&quot;0&quot;, &quot;Infinity&quot;)
                else 999999999
            )
        for child_layer in layer.layers:
            resolution = self._get_layer_resolution_hint_raw(child_layer)
            resolution_hint_min = (
                resolution[0]
                if resolution_hint_min is None
                else (
                    resolution_hint_min if resolution[0] is None else min(resolution_hint_min, resolution[0])
                )
            )
            resolution_hint_max = (
                resolution[1]
                if resolution_hint_max is None
                else (
                    resolution_hint_max if resolution[1] is None else max(resolution_hint_max, resolution[1])
                )
            )

        return (resolution_hint_min, resolution_hint_max)

    def _get_layer_resolution_hint(self, layer: main.Layer) -&gt; Tuple[float, float]:
        resolution_hint_min, resolution_hint_max = self._get_layer_resolution_hint_raw(layer)
        return (
            0.0 if resolution_hint_min is None else resolution_hint_min,
            999999999 if resolution_hint_max is None else resolution_hint_max,
        )

    def _layer(
        self,
        layer: main.Layer,
        time_: Optional[TimeInformation] = None,
        dim: Optional[DimensionInformation] = None,
        mixed: bool = True,
    ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
        errors: Set[str] = set()
        layer_info = {&quot;id&quot;: layer.id, &quot;name&quot;: layer.name, &quot;metadata&quot;: self._get_metadata_list(layer, errors)}
        if re.search(&quot;[/?#]&quot;, layer.name):
            errors.add(f&quot;The layer has an unsupported name '{layer.name}'.&quot;)
        if isinstance(layer, main.LayerWMS) and re.search(&quot;[/?#]&quot;, layer.layer):
            errors.add(f&quot;The layer has an unsupported layers '{layer.layer}'.&quot;)
        if layer.geo_table:
            errors |= self._fill_editable(layer_info, layer)
        if mixed:
            assert time_ is None
            time_ = TimeInformation()
        assert time_ is not None
        assert dim is not None

        errors |= dim.merge(layer, layer_info, mixed)

        if isinstance(layer, main.LayerWMS):
            wms, wms_errors = self._wms_layers(layer.ogc_server)
            errors |= wms_errors
            if wms is None:
                return None if errors else layer_info, errors
            if layer.layer is None or layer.layer == &quot;&quot;:
                errors.add(f&quot;The layer '{layer.name}' do not have any layers&quot;)
                return None, errors
            layer_info[&quot;type&quot;] = &quot;WMS&quot;
            layer_info[&quot;layers&quot;] = layer.layer
            self._fill_wms(layer_info, layer, errors, mixed=mixed)
            errors |= self._merge_time(time_, layer_info, layer, wms)

        elif isinstance(layer, main.LayerWMTS):
            layer_info[&quot;type&quot;] = &quot;WMTS&quot;
            self._fill_wmts(layer_info, layer, errors)

        elif isinstance(layer, main.LayerVectorTiles):
            layer_info[&quot;type&quot;] = &quot;VectorTiles&quot;
            self._vectortiles_layers(layer_info, layer, errors)

        return None if errors else layer_info, errors

    @staticmethod
    def _merge_time(
        time_: TimeInformation, layer_theme: Dict[str, Any], layer: main.Layer, wms: Dict[str, Dict[str, Any]]
    ) -&gt; Set[str]:
        errors = set()
        wmslayer = layer.layer

        def merge_time(wms_layer_obj: Dict[str, Any]) -&gt; None:
            extent = parse_extent(wms_layer_obj[&quot;timepositions&quot;], wms_layer_obj[&quot;defaulttimeposition&quot;])
            time_.merge(layer_theme, extent, layer.time_mode, layer.time_widget)

        try:
            if wmslayer in wms[&quot;layers&quot;]:
                wms_layer_obj = wms[&quot;layers&quot;][wmslayer]

                if layer.time_mode != &quot;disabled&quot;:
                    has_time = False
                    if wms_layer_obj[&quot;timepositions&quot;]:
                        merge_time(wms_layer_obj)
                        has_time = True

                    else:
                        # For wms layer group, get time from the chldren.
                        for child_layer_name in wms_layer_obj[&quot;children&quot;]:
                            child_layer = wms[&quot;layers&quot;][child_layer_name]
                            if child_layer[&quot;timepositions&quot;]:
                                merge_time(child_layer)  # The time mode comes from the wms layer group
                                has_time = True

                    if not has_time:
                        errors.add(
                            f&quot;Error: time layer '{layer.name}' has no time information in capabilities&quot;
                        )

        except ValueError:  # pragma no cover
            errors.add(f&quot;Error while handling time for layer '{layer.name}': {sys.exc_info()[1]}&quot;)

        return errors

    def _fill_editable(self, layer_theme: Dict[str, Any], layer: main.Layer) -&gt; Set[str]:
        errors = set()
        try:
            if self.request.user:
                count = (
                    models.DBSession.query(main.RestrictionArea)
                    .join(main.RestrictionArea.roles)
                    .filter(main.Role.id.in_(get_roles_id(self.request)))
                    .filter(main.RestrictionArea.layers.any(main.Layer.id == layer.id))
                    .filter(main.RestrictionArea.readwrite.is_(True))
                    .count()
                )
                if count &gt; 0:
                    layer_theme[&quot;edit_columns&quot;] = get_layer_metadata(layer)
                    layer_theme[&quot;editable&quot;] = True
        except Exception as exception:
            LOG.exception(str(exception))
            errors.add(str(exception))
        return errors

    def _fill_child_layer(
        self,
        layer_theme: Dict[str, Any],
        layer_name: str,
        wms: Dict[str, Dict[str, Any]],
    ) -&gt; None:
        wms_layer_obj = wms[&quot;layers&quot;][layer_name]
        if not wms_layer_obj[&quot;children&quot;]:
            layer_theme[&quot;childLayers&quot;].append(wms[&quot;layers&quot;][layer_name][&quot;info&quot;])
        else:
            for child_layer in wms_layer_obj[&quot;children&quot;]:
                self._fill_child_layer(layer_theme, child_layer, wms)

    def _fill_wms(
        self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str], mixed: bool
    ) -&gt; None:
        wms, wms_errors = self._wms_layers(layer.ogc_server)
        errors |= wms_errors
        if wms is None:
            return

        layer_theme[&quot;imageType&quot;] = layer.ogc_server.image_type
        if layer.style:
            layer_theme[&quot;style&quot;] = layer.style

        # now look at what is in the WMS capabilities doc
        layer_theme[&quot;childLayers&quot;] = []
        for layer_name in layer.layer.split(&quot;,&quot;):
            if layer_name in wms[&quot;layers&quot;]:
                self._fill_child_layer(layer_theme, layer_name, wms)
            else:
                errors.add(
                    f&quot;The layer '{layer_name}' ({layer.name}) is not defined in WMS capabilities &quot;
                    f&quot;from '{layer.ogc_server.name}'&quot;
                )

        if &quot;minResolutionHint&quot; not in layer_theme:
            resolution_min = self._get_metadata(layer, &quot;minResolution&quot;, errors)

            if resolution_min is not None:
                layer_theme[&quot;minResolutionHint&quot;] = resolution_min
            else:
                min_resolutions_hint = [
                    l_[&quot;minResolutionHint&quot;] for l_ in layer_theme[&quot;childLayers&quot;] if &quot;minResolutionHint&quot; in l_
                ]
                if min_resolutions_hint:
                    layer_theme[&quot;minResolutionHint&quot;] = min(min_resolutions_hint)
        if &quot;maxResolutionHint&quot; not in layer_theme:
            resolution_max = self._get_metadata(layer, &quot;maxResolution&quot;, errors)

            if resolution_max is not None:
                layer_theme[&quot;maxResolutionHint&quot;] = resolution_max
            else:
                max_resolutions_hint = [
                    l_[&quot;maxResolutionHint&quot;] for l_ in layer_theme[&quot;childLayers&quot;] if &quot;maxResolutionHint&quot; in l_
                ]
                if max_resolutions_hint:
                    layer_theme[&quot;maxResolutionHint&quot;] = max(max_resolutions_hint)

        if mixed:
            layer_theme[&quot;ogcServer&quot;] = layer.ogc_server.name

    def _fill_wmts(self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str]) -&gt; None:
        url = get_url2(f&quot;The WMTS layer '{layer.name}'&quot;, layer.url, self.request, errors=errors)
        layer_theme[&quot;url&quot;] = url.url() if url is not None else None

        if layer.style:
            layer_theme[&quot;style&quot;] = layer.style
        if layer.matrix_set:
            layer_theme[&quot;matrixSet&quot;] = layer.matrix_set

        layer_theme[&quot;layer&quot;] = layer.layer
        layer_theme[&quot;imageType&quot;] = layer.image_type

    def _vectortiles_layers(self, layer_theme: Dict[str, Any], layer: main.Layer, errors: Set[str]) -&gt; None:
        style = get_url2(f&quot;The VectorTiles layer '{layer.name}'&quot;, layer.style, self.request, errors=errors)
        layer_theme[&quot;style&quot;] = style.url() if style is not None else None
        if layer.xyz:
            layer_theme[&quot;xyz&quot;] = layer.xyz

    @staticmethod
    def _layer_included(tree_item: main.TreeItem) -&gt; bool:
        return isinstance(tree_item, main.Layer)

    def _get_ogc_servers(self, group: main.LayerGroup, depth: int) -&gt; Set[Union[str, bool]]:
        &quot;&quot;&quot;Get unique identifier for each child by recursing on all the children.&quot;&quot;&quot;

        ogc_servers: Set[Union[str, bool]] = set()

        # escape loop
        if depth &gt; 30:
            LOG.error(&quot;Error: too many recursions with group '%s'&quot;, group.name)
            return ogc_servers

        # recurse on children
        if isinstance(group, main.LayerGroup) and group.children:
            for tree_item in group.children:
                ogc_servers.update(self._get_ogc_servers(tree_item, depth + 1))

        if isinstance(group, main.LayerWMS):
            ogc_servers.add(group.ogc_server.name)

        if isinstance(group, main.LayerWMTS):
            ogc_servers.add(False)

        return ogc_servers

    @staticmethod
    def is_mixed(ogc_servers: List[Union[str, bool]]) -&gt; bool:
        return len(ogc_servers) != 1 or ogc_servers[0] is False

    def _group(
        self,
        path: str,
        group: main.LayerGroup,
        layers: List[str],
        depth: int = 1,
        min_levels: int = 1,
        mixed: bool = True,
        time_: Optional[TimeInformation] = None,
        dim: Optional[DimensionInformation] = None,
        wms_layers: Optional[List[str]] = None,
        layers_name: Optional[List[str]] = None,
        **kwargs: Any,
    ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
        if wms_layers is None:
            wms_layers = []
        if layers_name is None:
            layers_name = []
        children = []
        errors = set()

        if re.search(&quot;[/?#]&quot;, group.name):
            errors.add(f&quot;The group has an unsupported name '{group.name}'.&quot;)

        # escape loop
        if depth &gt; 30:
            errors.add(f&quot;Too many recursions with group '{group.name}'&quot;)
            return None, errors

        ogc_servers = None
        org_depth = depth
        if depth == 1:
            ogc_servers = list(self._get_ogc_servers(group, 1))
            # check if mixed content
            mixed = self.is_mixed(ogc_servers)
            if not mixed:
                time_ = TimeInformation()
            dim = DimensionInformation()

        for tree_item in group.children:
            if isinstance(tree_item, main.LayerGroup):
                group_theme, gp_errors = self._group(
                    f&quot;{path}/{tree_item.name}&quot;,
                    tree_item,
                    layers,
                    depth=depth + 1,
                    min_levels=min_levels,
                    mixed=mixed,
                    time_=time_,
                    dim=dim,
                    wms_layers=wms_layers,
                    layers_name=layers_name,
                    **kwargs,
                )
                errors |= gp_errors
                if group_theme is not None:
                    children.append(group_theme)
            elif self._layer_included(tree_item):
                if tree_item.name in layers:
                    layers_name.append(tree_item.name)
                    if isinstance(tree_item, main.LayerWMS):
                        wms_layers.extend(tree_item.layer.split(&quot;,&quot;))

                    layer_theme, l_errors = self._layer(tree_item, mixed=mixed, time_=time_, dim=dim)
                    errors |= l_errors
                    if layer_theme is not None:
                        if depth &lt; min_levels:
                            errors.add(
                                f&quot;The Layer '{path + '/' + tree_item.name}' is under indented &quot;
                                f&quot;({depth:d}/{min_levels:d}).&quot;
                            )
                        else:
                            children.append(layer_theme)

        if children:
            group_theme = {
                &quot;id&quot;: group.id,
                &quot;name&quot;: group.name,
                &quot;children&quot;: children,
                &quot;metadata&quot;: self._get_metadata_list(group, errors),
                &quot;mixed&quot;: False,
            }
            if not mixed:
                name: str
                for name, nb in Counter(layers_name).items():
                    if nb &gt; 1:
                        errors.add(
                            f&quot;The GeoMapFish layer name '{name}', cannot be two times &quot;
                            &quot;in the same block (first level group).&quot;
                        )

            group_theme[&quot;mixed&quot;] = mixed
            if org_depth == 1:
                if not mixed:
                    assert time_ is not None
                    assert dim is not None
                    group_theme[&quot;ogcServer&quot;] = cast(List[Any], ogc_servers)[0]
                    if time_.has_time() and time_.layer is None:
                        group_theme[&quot;time&quot;] = time_.to_dict()

                    group_theme[&quot;dimensions&quot;] = dim.get_dimensions()

            return group_theme, errors
        return None, errors

    def _layers(self, interface: str) -&gt; List[str]:
        query = self._create_layer_query(interface=interface)
        return [name for (name,) in query.all()]

    def _wms_layers(self, ogc_server: main.OGCServer) -&gt; Tuple[Optional[Dict[str, Dict[str, Any]]], Set[str]]:
        # retrieve layers metadata via GetCapabilities
        wms, wms_errors = asyncio.run(self._wms_getcap(ogc_server))
        if wms_errors:
            return None, wms_errors

        return wms, set()

    def _load_tree_items(self) -&gt; None:
        # Populate sqlalchemy session.identity_map to reduce the number of database requests.
        self._ogcservers_cache = models.DBSession.query(main.OGCServer).all()
        self._treeitems_cache = models.DBSession.query(main.TreeItem).all()
        self._layerswms_cache = (
            models.DBSession.query(main.LayerWMS)
            .options(subqueryload(main.LayerWMS.dimensions), subqueryload(main.LayerWMS.metadatas))
            .all()
        )
        self._layerswmts_cache = (
            models.DBSession.query(main.LayerWMTS)
            .options(subqueryload(main.LayerWMTS.dimensions), subqueryload(main.LayerWMTS.metadatas))
            .all()
        )
        self._layergroup_cache = (
            models.DBSession.query(main.LayerGroup)
            .options(subqueryload(main.LayerGroup.metadatas), subqueryload(main.LayerGroup.children_relation))
            .all()
        )
        self._themes_cache = (
            models.DBSession.query(main.Theme)
            .options(
                subqueryload(main.Theme.functionalities),
                subqueryload(main.Theme.metadatas),
                subqueryload(main.Theme.children_relation),
            )
            .all()
        )

    def _themes(
        self, interface: str = &quot;desktop&quot;, filter_themes: bool = True, min_levels: int = 1
    ) -&gt; Tuple[List[Dict[str, Any]], Set[str]]:
        &quot;&quot;&quot;Return theme information for the role identified by ``role_id``.&quot;&quot;&quot;
        self._load_tree_items()
        errors = set()
        layers = self._layers(interface)

        themes = models.DBSession.query(main.Theme)
        themes = themes.filter(main.Theme.public.is_(True))
        auth_themes = models.DBSession.query(main.Theme)
        auth_themes = auth_themes.filter(main.Theme.public.is_(False))
        auth_themes = auth_themes.join(main.Theme.restricted_roles)
        auth_themes = auth_themes.filter(main.Role.id.in_(get_roles_id(self.request)))

        themes = themes.union(auth_themes)

        themes = themes.order_by(main.Theme.ordering.asc())

        if filter_themes and interface is not None:
            themes = themes.join(main.Theme.interfaces)
            themes = themes.filter(main.Interface.name == interface)

        export_themes = []
        for theme in themes.all():
            if re.search(&quot;[/?#]&quot;, theme.name):
                errors.add(f&quot;The theme has an unsupported name '{theme.name}'.&quot;)
                continue

            children, children_errors = self._get_children(theme, layers, min_levels)
            errors |= children_errors

            # Test if the theme is visible for the current user
            if children:
                url = (
                    get_url2(f&quot;The Theme '{theme.name}'&quot;, theme.icon, self.request, errors)
                    if theme.icon is not None and theme.icon
                    else None
                )
                icon = (
                    url.url()
                    if url is not None
                    else self.request.static_url(&quot;/etc/geomapfish/static/images/blank.png&quot;)
                )

                theme_theme = {
                    &quot;id&quot;: theme.id,
                    &quot;name&quot;: theme.name,
                    &quot;icon&quot;: icon,
                    &quot;children&quot;: children,
                    &quot;functionalities&quot;: self._get_functionalities(theme),
                    &quot;metadata&quot;: self._get_metadata_list(theme, errors),
                }
                export_themes.append(theme_theme)

        return export_themes, errors

    @staticmethod
    def _get_functionalities(theme: main.Theme) -&gt; Dict[str, List[str]]:
        result: Dict[str, List[str]] = {}
        for functionality in theme.functionalities:
            if functionality.name in result:
                result[functionality.name].append(functionality.value)
            else:
                result[functionality.name] = [functionality.value]
        return result

    @view_config(route_name=&quot;invalidate&quot;, renderer=&quot;json&quot;)  # type: ignore
    def invalidate_cache(self) -&gt; Dict[str, bool]:
        auth_view(self.request)
        models.cache_invalidate_cb()
        return {&quot;success&quot;: True}

    def _get_children(
        self, theme: main.Theme, layers: List[str], min_levels: int
    ) -&gt; Tuple[List[Dict[str, Any]], Set[str]]:
        children = []
        errors: Set[str] = set()
        for item in theme.children:
            if isinstance(item, main.LayerGroup):
                group_theme, gp_errors = self._group(
                    f&quot;{theme.name}/{item.name}&quot;, item, layers, min_levels=min_levels
                )
                errors |= gp_errors
                if group_theme is not None:
                    children.append(group_theme)
            elif self._layer_included(item):
                if min_levels &gt; 0:
                    errors.add(
                        f&quot;The Layer '{item.name}' cannot be directly in the theme '{theme.name}' &quot;
                        f&quot;(0/{min_levels:d}).&quot;
                    )
                elif item.name in layers:
                    layer_theme, l_errors = self._layer(item, dim=DimensionInformation())
                    errors |= l_errors
                    if layer_theme is not None:
                        children.append(layer_theme)
        return children, errors

    @CACHE_REGION.cache_on_arguments()  # type: ignore
    def _get_layers_enum(self) -&gt; Dict[str, Dict[str, str]]:
        layers_enum = {}
        if &quot;enum&quot; in self.settings.get(&quot;layers&quot;, {}):
            for layer_name, layer in list(self.settings[&quot;layers&quot;][&quot;enum&quot;].items()):
                layer_enum: Dict[str, str] = {}
                layers_enum[layer_name] = layer_enum
                for attribute in list(layer[&quot;attributes&quot;].keys()):
                    layer_enum[attribute] = self.request.route_url(
                        &quot;layers_enumerate_attribute_values&quot;,
                        layer_name=layer_name,
                        field_name=attribute,
                        path=&quot;&quot;,
                    )
        return layers_enum

    def _get_role_ids(self) -&gt; Optional[Set[int]]:
        return None if self.request.user is None else {role.id for role in self.request.user.roles}

    async def _wfs_get_features_type(
        self, wfs_url: Url, ogc_server_name: str, preload: bool = False
    ) -&gt; Tuple[Optional[etree.Element], Set[str]]:
        errors = set()

        wfs_url.add_query(
            {
                &quot;SERVICE&quot;: &quot;WFS&quot;,
                &quot;VERSION&quot;: &quot;1.0.0&quot;,
                &quot;REQUEST&quot;: &quot;DescribeFeatureType&quot;,
                &quot;ROLE_IDS&quot;: &quot;0&quot;,
                &quot;USER_ID&quot;: &quot;0&quot;,
            }
        )

        LOG.debug(&quot;WFS DescribeFeatureType for the URL: %s&quot;, wfs_url)

        # forward request to target (without Host Header)
        headers = dict(self.request.headers)
        if wfs_url.hostname != &quot;localhost&quot; and &quot;Host&quot; in headers:
            headers.pop(&quot;Host&quot;)

        headers = restrict_headers(headers, self.headers_whitelist, self.headers_blacklist)

        try:
            content, _ = await asyncio.get_event_loop().run_in_executor(
                None, get_http_cached, self.http_options, wfs_url, headers
            )
        except requests.exceptions.RequestException as exception:
            error = (
                f&quot;Unable to get WFS DescribeFeatureType from the URL '{wfs_url.url()}' for &quot;
                f&quot;OGC server {ogc_server_name}, &quot;
                + (
                    f&quot;return the error: {exception.response.status_code} {exception.response.reason}&quot;
                    if exception.response is not None
                    else f&quot;{exception}&quot;
                )
            )
            errors.add(error)
            LOG.exception(error)
            return None, errors
        except Exception:
            error = (
                f&quot;Unable to get WFS DescribeFeatureType from the URL {wfs_url} for &quot;
                f&quot;OGC server {ogc_server_name}&quot;
            )
            errors.add(error)
            LOG.exception(error)
            return None, errors

        if preload:
            return None, errors

        try:
            return lxml.XML(content), errors
        except Exception as e:
            errors.add(
                f&quot;Error '{e!s}' on reading DescribeFeatureType from URL {wfs_url}:\n{content.decode()}&quot;
            )
            return None, errors

    def get_url_internal_wfs(
        self, ogc_server: main.OGCServer, errors: Set[str]
    ) -&gt; Tuple[Optional[Url], Optional[Url], Optional[Url]]:
        # required to do every time to validate the url.
        if ogc_server.auth != main.OGCSERVER_AUTH_NOAUTH:
            url: Optional[Url] = Url(
                self.request.route_url(&quot;mapserverproxy&quot;, _query={&quot;ogcserver&quot;: ogc_server.name})
            )
            url_wfs: Optional[Url] = url
            url_internal_wfs = get_url2(
                f&quot;The OGC server (WFS) '{ogc_server.name}'&quot;,
                ogc_server.url_wfs or ogc_server.url,
                self.request,
                errors=errors,
            )
        else:
            url = get_url2(f&quot;The OGC server '{ogc_server.name}'&quot;, ogc_server.url, self.request, errors=errors)
            url_wfs = (
                get_url2(
                    f&quot;The OGC server (WFS) '{ogc_server.name}'&quot;,
                    ogc_server.url_wfs,
                    self.request,
                    errors=errors,
                )
                if ogc_server.url_wfs is not None
                else url
            )
            url_internal_wfs = url_wfs
        return url_internal_wfs, url, url_wfs

    async def preload(self, errors: Set[str]) -&gt; None:
        tasks = set()
        for ogc_server in models.DBSession.query(main.OGCServer).all():
            # Don't load unused OGC servers, required for Landigpage, because the related OGC server
            # will be on error in those functions.
            nb_layers = (
                models.DBSession.query(sqlalchemy.func.count(main.LayerWMS.id))
                .filter(main.LayerWMS.ogc_server_id == ogc_server.id)
                .one()
            )
            LOG.debug(&quot;%i layers for OGC server '%s'&quot;, nb_layers[0], ogc_server.name)
            if nb_layers[0] &gt; 0:
                LOG.debug(&quot;Preload OGC server '%s'&quot;, ogc_server.name)
                url_internal_wfs, _, _ = self.get_url_internal_wfs(ogc_server, errors)
                if url_internal_wfs is not None:
                    if ogc_server.wfs_support:
                        tasks.add(self._wfs_get_features_type(url_internal_wfs, ogc_server.name, True))
                    tasks.add(self._wms_getcap(ogc_server, True))

        await asyncio.gather(*tasks)

    @CACHE_REGION.cache_on_arguments()  # type: ignore
    def _get_features_attributes(
        self, url_internal_wfs: Url, ogc_server_name: str
    ) -&gt; Tuple[Optional[Dict[str, Dict[Any, Dict[str, Any]]]], Optional[str], Set[str]]:

        all_errors: Set[str] = set()
        feature_type, errors = asyncio.run(self._wfs_get_features_type(url_internal_wfs, ogc_server_name))
        LOG.debug(&quot;Run garbage collection: %s&quot;, &quot;, &quot;.join([str(gc.collect(n)) for n in range(3)]))
        if errors:
            all_errors |= errors
            return None, None, all_errors
        assert feature_type
        namespace: str = feature_type.attrib.get(&quot;targetNamespace&quot;)
        types: Dict[Any, Dict[str, Any]] = {}
        elements = {}
        for child in feature_type.getchildren():
            if child.tag == &quot;{http://www.w3.org/2001/XMLSchema}element&quot;:
                name = child.attrib[&quot;name&quot;]
                type_namespace, type_ = child.attrib[&quot;type&quot;].split(&quot;:&quot;)
                if type_namespace not in child.nsmap:
                    LOG.info(
                        &quot;The namespace '%s' of the type '%s' is not found in the available namespaces: %s&quot;,
                        type_namespace,
                        name,
                        &quot;, &quot;.join(child.nsmap.keys()),
                    )
                if child.nsmap[type_namespace] != namespace:
                    LOG.info(
                        &quot;The namespace '%s' of the thye '%s' should be '%s'.&quot;,
                        child.nsmap[type_namespace],
                        name,
                        namespace,
                    )
                elements[name] = type_

            if child.tag == &quot;{http://www.w3.org/2001/XMLSchema}complexType&quot;:
                sequence = child.find(&quot;.//{http://www.w3.org/2001/XMLSchema}sequence&quot;)
                attrib = {}
                for children in sequence.getchildren():
                    type_namespace = None
                    type_ = children.attrib[&quot;type&quot;]
                    if len(type_.split(&quot;:&quot;)) == 2:
                        type_namespace, type_ = type_.split(&quot;:&quot;)
                    type_namespace = children.nsmap[type_namespace]
                    name = children.attrib[&quot;name&quot;]
                    attrib[name] = {&quot;namespace&quot;: type_namespace, &quot;type&quot;: type_}
                    for key, value in children.attrib.items():
                        if key not in (&quot;name&quot;, &quot;type&quot;, &quot;namespace&quot;):
                            attrib[name][key] = value
                types[child.attrib[&quot;name&quot;]] = attrib
        attributes: Dict[str, Dict[Any, Dict[str, Any]]] = {}
        for name, type_ in elements.items():
            if type_ in types:
                attributes[name] = types[type_]
            elif (type_ == &quot;Character&quot;) and (name + &quot;Type&quot;) in types:
                LOG.debug(
                    &quot;Due mapserver strange result the type 'ms:Character' is fallbacked to type '%sType'&quot;
                    &quot; for feature '%s', This is a strange comportement of mapserver when we use the &quot;
                    'METADATA &quot;gml_types&quot; &quot;auto&quot;',
                    name,
                    name,
                )
                attributes[name] = types[name + &quot;Type&quot;]
            else:
                LOG.warning(
                    &quot;The provided type '%s' does not exist, available types are %s.&quot;,
                    type_,
                    &quot;, &quot;.join(types.keys()),
                )

        return attributes, namespace, all_errors

    @view_config(route_name=&quot;themes&quot;, renderer=&quot;json&quot;)  # type: ignore
    def themes(self) -&gt; Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]]:
        interface = self.request.params.get(&quot;interface&quot;, &quot;desktop&quot;)
        sets = self.request.params.get(&quot;set&quot;, &quot;all&quot;)
        min_levels = int(self.request.params.get(&quot;min_levels&quot;, 1))
        group = self.request.params.get(&quot;group&quot;)
        background_layers_group = self.request.params.get(&quot;background&quot;)

        set_common_headers(self.request, &quot;themes&quot;, Cache.PRIVATE)

        def get_theme() -&gt; Dict[str, Union[Dict[str, Any], List[str]]]:
            export_themes = sets in (&quot;all&quot;, &quot;themes&quot;)
            export_group = group is not None and sets in (&quot;all&quot;, &quot;group&quot;)
            export_background = background_layers_group is not None and sets in (&quot;all&quot;, &quot;background&quot;)

            result: Dict[str, Union[Dict[str, Any], List[Any]]] = {}
            all_errors: Set[str] = set()
            LOG.debug(&quot;Start preload&quot;)
            start_time = time.time()
            asyncio.run(self.preload(all_errors))
            LOG.debug(&quot;End preload&quot;)
            # Don't log if it looks to be already preloaded.
            if (time.time() - start_time) &gt; 1:
                LOG.info(&quot;Do preload in %.3fs.&quot;, time.time() - start_time)
<A NAME="1"></A>            result[&quot;ogcServers&quot;] = {}
            for ogc_server in models.DBSession.query(main.OGCServer).all():
                nb_layers = (
                    models.DBSession.query(sqlalchemy.func<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1662-0.html#1',2,'match1662-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.count(main.LayerWMS.id))
                    .filter(main.LayerWMS.ogc_server_id == ogc_server.id)
                    .one()
                )
                if nb_layers[</B></FONT>0] == 0:
                    # QGIS Server langing page requires an OGC server that can't be used here.
                    continue

                url_internal_wfs, url, url_wfs = self.get_url_internal_wfs(ogc_server, all_errors)

                attributes = None
                namespace = None
                if ogc_server.wfs_support:
                    attributes, namespace, errors = self._get_features_attributes(
                        url_internal_wfs, ogc_server.name
                    )
                    # Create a local copy (don't modify the cache)
                    if attributes is not None:
                        attributes = dict(attributes)
                    all_errors |= errors

                    all_private_layers = get_private_layers([ogc_server.id]).values()
                    protected_layers_name = [
                        layer.name for layer in get_protected_layers(self.request, [ogc_server.id]).values()
                    ]
                    private_layers_name: List[str] = []
                    for layers in [
                        v.layer for v in all_private_layers if v.name not in protected_layers_name
                    ]:
                        private_layers_name.extend(layers.split(&quot;,&quot;))

                    if attributes is not None:
                        for name in private_layers_name:
                            if name in attributes:
                                del attributes[name]

                result[&quot;ogcServers&quot;][ogc_server.name] = {
                    &quot;url&quot;: url.url() if url else None,
                    &quot;urlWfs&quot;: url_wfs.url() if url_wfs else None,
                    &quot;type&quot;: ogc_server.type,
                    &quot;credential&quot;: ogc_server.auth != main.OGCSERVER_AUTH_NOAUTH,
                    &quot;imageType&quot;: ogc_server.image_type,
                    &quot;wfsSupport&quot;: ogc_server.wfs_support,
                    &quot;isSingleTile&quot;: ogc_server.is_single_tile,
                    &quot;namespace&quot;: namespace,
                    &quot;attributes&quot;: attributes,
                }
            if export_themes:
                themes, errors = self._themes(interface, True, min_levels)

                result[&quot;themes&quot;] = themes
                all_errors |= errors

            if export_group:
                exported_group, errors = self._get_group(group, interface)
                if exported_group is not None:
                    result[&quot;group&quot;] = exported_group
                all_errors |= errors

            if export_background:
                exported_group, errors = self._get_group(background_layers_group, interface)
                result[&quot;background_layers&quot;] = exported_group[&quot;children&quot;] if exported_group is not None else []
                all_errors |= errors

            result[&quot;errors&quot;] = list(all_errors)
            if all_errors:
                LOG.info(&quot;Theme errors:\n%s&quot;, &quot;\n&quot;.join(all_errors))
            return result

        @CACHE_REGION.cache_on_arguments()  # type: ignore
        def get_theme_anonymous(
            intranet: bool,
            interface: str,
            sets: str,
            min_levels: str,
            group: str,
            background_layers_group: str,
            host: str,
        ) -&gt; Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]]:
            # Only for cache key
            del intranet, interface, sets, min_levels, group, background_layers_group, host
            return get_theme()

        if self.request.user is None:
            return cast(
                Dict[str, Union[Dict[str, Dict[str, Any]], List[str]]],
                get_theme_anonymous(
                    is_intranet(self.request),
                    interface,
                    sets,
                    min_levels,
                    group,
                    background_layers_group,
                    self.request.headers.get(&quot;Host&quot;),
                ),
            )
        return get_theme()

    def _get_group(
        self, group: main.LayerGroup, interface: main.Interface
    ) -&gt; Tuple[Optional[Dict[str, Any]], Set[str]]:
        layers = self._layers(interface)
        try:
            group_db = models.DBSession.query(main.LayerGroup).filter(main.LayerGroup.name == group).one()
            return self._group(group_db.name, group_db, layers, depth=2, dim=DimensionInformation())
        except NoResultFound:
            return (
                None,
                {
                    f&quot;Unable to find the Group named: {group}, Available Groups: &quot;
                    f&quot;{', '.join([i[0] for i in models.DBSession.query(main.LayerGroup.name).all()])}&quot;
                },
            )
</PRE>
</div>
  </div>
</body>
</html>
