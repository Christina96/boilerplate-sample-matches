<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_pkgutil.py & test_module_3.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_pkgutil.py & test_module_3.py
      </h3>
      <h1 align="center">
        9.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_pkgutil.py (25.0%)<TH>test_module_3.py (5.5135136%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#0',2,'match24703-1.html#0',3)" NAME="0">(243-255)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#0',2,'match24703-1.html#0',3)" NAME="0">(372-377)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#1',2,'match24703-1.html#1',3)" NAME="1">(206-209)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#1',2,'match24703-1.html#1',3)" NAME="1">(529-534)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#2',2,'match24703-1.html#2',3)" NAME="2">(174-186)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#2',2,'match24703-1.html#2',3)" NAME="2">(507-512)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#3',2,'match24703-1.html#3',3)" NAME="3">(99-111)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#3',2,'match24703-1.html#3',3)" NAME="3">(460-465)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#4',2,'match24703-1.html#4',3)" NAME="4">(73-86)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#4',2,'match24703-1.html#4',3)" NAME="4">(438-443)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#5',2,'match24703-1.html#5',3)" NAME="5">(56-61)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#5',2,'match24703-1.html#5',3)" NAME="5">(394-399)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#6',2,'match24703-1.html#6',3)" NAME="6">(214-225)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#6',2,'match24703-1.html#6',3)" NAME="6">(145-148)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match24703-0.html#7',2,'match24703-1.html#7',3)" NAME="7">(25-27)<TD><A HREF="javascript:ZweiFrames('match24703-0.html#7',2,'match24703-1.html#7',3)" NAME="7">(556-560)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_pkgutil.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Jayesh Kariya &lt;jayeshk@saltstack.com&gt;
&quot;&quot;&quot;


import pytest
import salt.modules.pkgutil as pkgutil
import salt.utils.pkg
from salt.exceptions import CommandExecutionError, MinionError
from tests.support.mock import MagicMock, Mock, patch


@pytest.fixture
def configure_loader_modules():
    return {pkgutil: {}}


# 'refresh_db' function tests: 1


def test_refresh_db():
<A NAME="7"></A>    &quot;&quot;&quot;
    Test if it updates the pkgutil repo database (pkgutil -U).
    &quot;&quot;&quot;
    mock <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match24703-1.html#7',3,'match24703-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= MagicMock(return_value=0)
    with patch.dict(pkgutil.__salt__, {&quot;cmd.retcode&quot;: mock}):
        with patch.object(salt.</B></FONT>utils.pkg, &quot;clear_rtag&quot;, Mock()):
            assert pkgutil.refresh_db()


# 'upgrade_available' function tests: 1


def test_upgrade_available():
    &quot;&quot;&quot;
    Test if there is an upgrade available for a certain package.
    &quot;&quot;&quot;
    mock = MagicMock(return_value=&quot;A\n B\n SAME&quot;)
    with patch.dict(pkgutil.__salt__, {&quot;cmd.run_stdout&quot;: mock}):
        assert pkgutil.upgrade_available(&quot;CSWpython&quot;) == &quot;&quot;

    mock = MagicMock(side_effect=[&quot;A\n B\n SALT&quot;, None])
    with patch.dict(pkgutil.__salt__, {&quot;cmd.run_stdout&quot;: mock}):
        assert pkgutil.upgrade_available(&quot;CSWpython&quot;) == &quot;SALT&quot;

        assert pkgutil.upgrade_available(&quot;CSWpython&quot;) == &quot;&quot;


# 'list_upgrades' function tests: 1


def test_list_upgrades():
<A NAME="5"></A>    &quot;&quot;&quot;
    Test if it list all available package upgrades on this system.
    &quot;&quot;&quot;
    mock_run = MagicMock(return_value<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match24703-1.html#5',3,'match24703-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=&quot;A\t B\t SAME&quot;)
    mock_ret = MagicMock(return_value=0)
    with patch.dict(
        pkgutil.__salt__, {&quot;cmd.run_stdout&quot;: mock_run, &quot;cmd.retcode&quot;: mock_ret}
    ):
        with patch.object(salt.</B></FONT>utils.pkg, &quot;clear_rtag&quot;, Mock()):
            assert pkgutil.list_upgrades() == {&quot;A&quot;: &quot; B&quot;}


# 'upgrade' function tests: 1


def test_upgrade():
    &quot;&quot;&quot;
<A NAME="4"></A>    Test if it upgrade all of the packages to the latest available version.
    &quot;&quot;&quot;
    mock_run = MagicMock(return_value=&quot;A\t B\t SAME&quot;)
    mock_ret = MagicMock(return_value<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match24703-1.html#4',3,'match24703-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=0)
    mock_pkg = MagicMock(return_value=&quot;&quot;)
    with patch.dict(
        pkgutil.__salt__,
        {
            &quot;cmd.run_stdout&quot;: mock_run,
            &quot;cmd.retcode&quot;: mock_ret,
            &quot;pkg_resource.stringify&quot;: mock_pkg,
            &quot;pkg_resource.sort_pkglist&quot;: mock_pkg,
            &quot;cmd.run_all&quot;: mock_ret,
            &quot;cmd.run&quot;: mock_run,
        },
    ):
        with patch.dict(pkgutil.</B></FONT>__context__, {&quot;pkg.list_pkgs&quot;: mock_ret}):
            with patch.object(salt.utils.pkg, &quot;clear_rtag&quot;, Mock()):
                assert pkgutil.upgrade() == {}


# 'list_pkgs' function tests: 1


def test_list_pkgs():
    &quot;&quot;&quot;
<A NAME="3"></A>    Test if it list the packages currently installed as a dict.
    &quot;&quot;&quot;
    mock_run = MagicMock(return_value=&quot;A\t B\t SAME&quot;)
    mock_ret = MagicMock(return_value<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match24703-1.html#3',3,'match24703-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=True)
    mock_pkg = MagicMock(return_value=&quot;&quot;)
    with patch.dict(
        pkgutil.__salt__,
        {
            &quot;cmd.run_stdout&quot;: mock_run,
            &quot;cmd.retcode&quot;: mock_ret,
            &quot;pkg_resource.stringify&quot;: mock_pkg,
            &quot;pkg_resource.sort_pkglist&quot;: mock_pkg,
            &quot;cmd.run&quot;: mock_run,
        },
    ):
        with patch.dict(pkgutil.</B></FONT>__context__, {&quot;pkg.list_pkgs&quot;: mock_ret}):
            assert pkgutil.list_pkgs(versions_as_list=True, removed=True) == {}

        assert pkgutil.list_pkgs() == {}

    with patch.dict(pkgutil.__context__, {&quot;pkg.list_pkgs&quot;: True}):
        assert pkgutil.list_pkgs(versions_as_list=True)

        mock_pkg = MagicMock(return_value=True)
        with patch.dict(pkgutil.__salt__, {&quot;pkg_resource.stringify&quot;: mock_pkg}):
            assert pkgutil.list_pkgs()


def test_list_pkgs_no_context():
    &quot;&quot;&quot;
    Test if it list the packages currently installed as a dict.
    &quot;&quot;&quot;
    mock_run = MagicMock(return_value=&quot;A\t B\t SAME&quot;)
    mock_ret = MagicMock(return_value=True)
    mock_pkg = MagicMock(return_value=&quot;&quot;)
    with patch.dict(
        pkgutil.__salt__,
        {
            &quot;cmd.run_stdout&quot;: mock_run,
            &quot;cmd.retcode&quot;: mock_ret,
            &quot;pkg_resource.stringify&quot;: mock_pkg,
            &quot;pkg_resource.sort_pkglist&quot;: mock_pkg,
            &quot;cmd.run&quot;: mock_run,
        },
    ), patch.object(pkgutil, &quot;_list_pkgs_from_context&quot;) as list_pkgs_context_mock:
        pkgs = pkgutil.list_pkgs(versions_as_list=True, removed=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()

        pkgs = pkgutil.list_pkgs(versions_as_list=True, removed=True, use_context=False)
        list_pkgs_context_mock.assert_not_called()
        list_pkgs_context_mock.reset_mock()


# 'version' function tests: 1


def test_version():
    &quot;&quot;&quot;
    Test if it returns a version if the package is installed.
    &quot;&quot;&quot;
    mock_ret = MagicMock(return_value=True)
    with patch.dict(pkgutil.__salt__, {&quot;pkg_resource.version&quot;: mock_ret}):
        assert pkgutil.version(&quot;CSWpython&quot;)


# 'latest_version' function tests: 1


def test_latest_version():
    &quot;&quot;&quot;
    Test if it return the latest version of the named package
    available for upgrade or installation.
    &quot;&quot;&quot;
    assert pkgutil.latest_version() == &quot;&quot;
<A NAME="2"></A>
    mock_run_all = MagicMock(return_value=&quot;A\t B\t SAME&quot;)
    mock_run = MagicMock(return_value={&quot;stdout&quot;: &quot;&quot;})
    mock_ret = MagicMock(return_value<FONT color="#980517"><A HREF="javascript:ZweiFrames('match24703-1.html#2',3,'match24703-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=True)
    mock_pkg = MagicMock(return_value=&quot;&quot;)
    with patch.dict(
        pkgutil.__salt__,
        {
            &quot;cmd.retcode&quot;: mock_ret,
            &quot;pkg_resource.stringify&quot;: mock_pkg,
            &quot;pkg_resource.sort_pkglist&quot;: mock_pkg,
            &quot;cmd.run_all&quot;: mock_run,
            &quot;cmd.run&quot;: mock_run_all,
        },
    ):
        with patch.object(salt.</B></FONT>utils.pkg, &quot;clear_rtag&quot;, Mock()):
            assert pkgutil.latest_version(&quot;CSWpython&quot;) == &quot;&quot;

            assert pkgutil.latest_version(&quot;CSWpython&quot;, &quot;Python&quot;) == {
                &quot;Python&quot;: &quot;&quot;,
                &quot;CSWpython&quot;: &quot;&quot;,
            }


# 'install' function tests: 1


def test_install():
    &quot;&quot;&quot;
    Test if it install packages using the pkgutil tool.
    &quot;&quot;&quot;
    mock_pkg = MagicMock(side_effect=MinionError)
<A NAME="1"></A>    with patch.dict(pkgutil.__salt__, {&quot;pkg_resource.parse_targets&quot;: mock_pkg}):
        pytest.raises(CommandExecutionError, pkgutil.install)

    mock_ret = MagicMock(return_value<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match24703-1.html#1',3,'match24703-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=True)
    mock_pkg = MagicMock(return_value=[&quot;&quot;])
    with patch.dict(pkgutil.__salt__, {&quot;pkg_resource.parse_targets&quot;: mock_pkg}):
        with patch.dict(pkgutil.</B></FONT>__context__, {&quot;pkg.list_pkgs&quot;: mock_ret}):
            assert pkgutil.install() == {}
<A NAME="6"></A>
    mock_run = MagicMock(return_value=&quot;A\t B\t SAME&quot;)
    mock_run_all = MagicMock(return_value={&quot;stdout&quot;: &quot;&quot;})
    mock_pkg <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match24703-1.html#6',3,'match24703-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= MagicMock(return_value=[{&quot;bar&quot;: &quot;1.2.3&quot;}])
    with patch.dict(
        pkgutil.__salt__,
        {
            &quot;pkg_resource.parse_targets&quot;: mock_pkg,
            &quot;pkg_resource.stringify&quot;: mock_pkg,
            &quot;pkg_resource.sort_pkglist&quot;: mock_pkg,
            &quot;cmd.run_all&quot;: mock_run_all,
            &quot;cmd.run&quot;: mock_run,
        },
    ):
        with patch.dict(</B></FONT>pkgutil.__context__, {&quot;pkg.list_pkgs&quot;: mock_ret}):
            assert pkgutil.install(pkgs='[&quot;foo&quot;, {&quot;bar&quot;: &quot;1.2.3&quot;}]') == {}


# 'remove' function tests: 1


def test_remove():
    &quot;&quot;&quot;
    Test if it remove a package and all its dependencies
    which are not in use by other packages.
    &quot;&quot;&quot;
    mock_pkg = MagicMock(side_effect=MinionError)
    with patch.dict(pkgutil.__salt__, {&quot;pkg_resource.parse_targets&quot;: mock_pkg}):
        pytest.raises(CommandExecutionError, pkgutil.remove)
<A NAME="0"></A>
    mock_ret = MagicMock(return_value=True)
    mock_run = MagicMock(return_value=&quot;A\t B\t SAME&quot;)
    mock_run_all = MagicMock(return_value={<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match24703-1.html#0',3,'match24703-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;stdout&quot;: &quot;&quot;})
    mock_pkg = MagicMock(return_value=[&quot;&quot;])
    with patch.dict(
        pkgutil.__salt__,
        {
            &quot;pkg_resource.parse_targets&quot;: mock_pkg,
            &quot;pkg_resource.stringify&quot;: mock_pkg,
            &quot;pkg_resource.sort_pkglist&quot;: mock_pkg,
            &quot;cmd.run_all&quot;: mock_run_all,
            &quot;cmd.run&quot;: mock_run,
        },
    ):
        with patch.dict(pkgutil.</B></FONT>__context__, {&quot;pkg.list_pkgs&quot;: mock_ret}):
            assert pkgutil.remove() == {}

    mock_pkg = MagicMock(return_value=[{&quot;bar&quot;: &quot;1.2.3&quot;}])
    with patch.dict(
        pkgutil.__salt__,
        {
            &quot;pkg_resource.parse_targets&quot;: mock_pkg,
            &quot;pkg_resource.stringify&quot;: mock_pkg,
            &quot;pkg_resource.sort_pkglist&quot;: mock_pkg,
            &quot;cmd.run_all&quot;: mock_run_all,
            &quot;cmd.run&quot;: mock_run,
        },
    ):
        with patch.dict(pkgutil.__context__, {&quot;pkg.list_pkgs&quot;: mock_ret}):
            with patch.object(pkgutil, &quot;list_pkgs&quot;, return_value={&quot;bar&quot;: &quot;1.2.3&quot;}):
                assert pkgutil.remove(pkgs='[&quot;foo&quot;, &quot;bar&quot;]') == {}


# 'purge' function tests: 1


def test_purge():
    &quot;&quot;&quot;
    Test if it package purges are not supported,
    this function is identical to ``remove()``.
    &quot;&quot;&quot;
    mock_pkg = MagicMock(side_effect=MinionError)
    with patch.dict(pkgutil.__salt__, {&quot;pkg_resource.parse_targets&quot;: mock_pkg}):
        pytest.raises(CommandExecutionError, pkgutil.purge)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_module_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Unit tests for the docker module
&quot;&quot;&quot;

import logging

import pytest
import salt.config
import salt.loader
import salt.modules.dockermod as docker_mod
import salt.utils.platform
from salt.exceptions import CommandExecutionError, SaltInvocationError
from tests.support.mock import MagicMock, Mock, call, patch

log = logging.getLogger(__name__)

pytest.importorskip(
    &quot;docker&quot;, reason=&quot;The python 'docker' package must be installed to run these tests&quot;
)


@pytest.fixture
def configure_loader_modules():
    utils = salt.loader.utils(
        salt.config.DEFAULT_MINION_OPTS.copy(),
        whitelist=[
            &quot;args&quot;,
            &quot;docker&quot;,
            &quot;json&quot;,
            &quot;state&quot;,
            &quot;thin&quot;,
            &quot;systemd&quot;,
            &quot;path&quot;,
            &quot;platform&quot;,
        ],
    )
    return {
        docker_mod: {
            &quot;__context__&quot;: {&quot;docker.docker_version&quot;: &quot;&quot;},
            &quot;__utils__&quot;: utils,
        }
    }


def test_failed_login():
    &quot;&quot;&quot;
    Check that when docker.login failed a retcode other then 0
    is part of the return.
    &quot;&quot;&quot;
    client = Mock()
    get_client_mock = MagicMock(return_value=client)
    ref_out = {&quot;stdout&quot;: &quot;&quot;, &quot;stderr&quot;: &quot;login failed&quot;, &quot;retcode&quot;: 1}
    with patch.dict(
        docker_mod.__pillar__,
        {
            &quot;docker-registries&quot;: {
                &quot;portus.example.com:5000&quot;: {
                    &quot;username&quot;: &quot;admin&quot;,
                    &quot;password&quot;: &quot;linux12345&quot;,
                    &quot;email&quot;: &quot;tux@example.com&quot;,
                }
            }
        },
    ):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            dunder_salt = {
                &quot;cmd.run_all&quot;: MagicMock(return_value=ref_out),
                &quot;config.get&quot;: MagicMock(return_value={}),
                &quot;config.option&quot;: MagicMock(return_value={}),
            }
            with patch.dict(docker_mod.__salt__, dunder_salt):
                ret = docker_mod.login(&quot;portus.example.com:5000&quot;)
                assert &quot;retcode&quot; in ret
                assert ret[&quot;retcode&quot;] != 0


def test_logout_calls_docker_cli_logout_single():
    client = Mock()
    get_client_mock = MagicMock(return_value=client)
    ref_out = {&quot;stdout&quot;: &quot;&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;retcode&quot;: 0}
    registry_auth_data = {
        &quot;portus.example.com:5000&quot;: {
            &quot;username&quot;: &quot;admin&quot;,
            &quot;password&quot;: &quot;linux12345&quot;,
            &quot;email&quot;: &quot;tux@example.com&quot;,
        }
    }
    docker_mock = MagicMock(return_value=ref_out)
    with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
        dunder_salt = {
            &quot;config.get&quot;: MagicMock(return_value=registry_auth_data),
            &quot;cmd.run_all&quot;: docker_mock,
            &quot;config.option&quot;: MagicMock(return_value={}),
        }
        with patch.dict(docker_mod.__salt__, dunder_salt):
            ret = docker_mod.logout(&quot;portus.example.com:5000&quot;)
            assert &quot;retcode&quot; in ret
            assert ret[&quot;retcode&quot;] == 0
            docker_mock.assert_called_with(
                [&quot;docker&quot;, &quot;logout&quot;, &quot;portus.example.com:5000&quot;],
                python_shell=False,
                output_loglevel=&quot;quiet&quot;,
            )


def test_logout_calls_docker_cli_logout_all():
    client = Mock()
    get_client_mock = MagicMock(return_value=client)
    ref_out = {&quot;stdout&quot;: &quot;&quot;, &quot;stderr&quot;: &quot;&quot;, &quot;retcode&quot;: 0}
    registry_auth_data = {
        &quot;portus.example.com:5000&quot;: {
            &quot;username&quot;: &quot;admin&quot;,
            &quot;password&quot;: &quot;linux12345&quot;,
            &quot;email&quot;: &quot;tux@example.com&quot;,
        },
        &quot;portus2.example.com:5000&quot;: {
            &quot;username&quot;: &quot;admin&quot;,
            &quot;password&quot;: &quot;linux12345&quot;,
            &quot;email&quot;: &quot;tux@example.com&quot;,
        },
    }

    docker_mock = MagicMock(return_value=ref_out)
    with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
        dunder_salt = {
            &quot;config.get&quot;: MagicMock(return_value=registry_auth_data),
            &quot;cmd.run_all&quot;: docker_mock,
            &quot;config.option&quot;: MagicMock(return_value={}),
        }
        with patch.dict(docker_mod.__salt__, dunder_salt):
            ret = docker_mod.logout()
            assert &quot;retcode&quot; in ret
            assert ret[&quot;retcode&quot;] == 0
            assert docker_mock.call_count == 2


def test_ps_with_host_true():
    &quot;&quot;&quot;
    Check that docker.ps called with host is ``True``,
    include resutlt of ``network.interfaces`` command in returned result.
    &quot;&quot;&quot;
<A NAME="6"></A>    client = Mock()
    client.containers = MagicMock(return_value=[])
    get_client_mock = MagicMock(return_value=client)
    network_interfaces <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#6',2,'match24703-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= Mock(return_value={&quot;mocked&quot;: None})

    with patch.dict(docker_mod.__salt__, {&quot;network.interfaces&quot;: network_interfaces}):
        with patch.object(</B></FONT>docker_mod, &quot;_get_client&quot;, get_client_mock):
            ret = docker_mod.ps_(host=True)
            assert ret == {&quot;host&quot;: {&quot;interfaces&quot;: {&quot;mocked&quot;: None}}}


def test_ps_with_filters():
    &quot;&quot;&quot;
    Check that docker.ps accept filters parameter.
    &quot;&quot;&quot;
    client = Mock()
    client.containers = MagicMock(return_value=[])
    get_client_mock = MagicMock(return_value=client)

    with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
        docker_mod.ps_(filters={&quot;label&quot;: &quot;KEY&quot;})
        client.containers.assert_called_once_with(all=True, filters={&quot;label&quot;: &quot;KEY&quot;})


@pytest.mark.slow_test
@pytest.mark.parametrize(
    &quot;command_name, args&quot;,
    (
        (&quot;create&quot;, ()),
        (&quot;rm_&quot;, ()),
        (&quot;kill&quot;, ()),
        (&quot;pause&quot;, ()),
        (&quot;signal_&quot;, (&quot;KILL&quot;,)),
        (&quot;start_&quot;, ()),
        (&quot;stop&quot;, ()),
        (&quot;unpause&quot;, ()),
        (&quot;_run&quot;, (&quot;command&quot;,)),
        (&quot;_script&quot;, (&quot;command&quot;,)),
    ),
)
def test_check_mine_cache_is_refreshed_on_container_change_event(command_name, args):
    &quot;&quot;&quot;
    Every command that might modify docker containers state.
    Should trig an update on ``mine.send``
    &quot;&quot;&quot;
    if salt.utils.platform.is_windows() and command_name == &quot;_script&quot;:
        pytest.skip(
            &quot;Skipping test since `dockermod._script` will create a temporary file in /tmp &quot;
            &quot;which does not exist on windows&quot;
        )
    with patch.object(docker_mod, &quot;_get_exec_driver&quot;):
        client_args_mock = MagicMock(
            return_value={
                &quot;create_container&quot;: [
                    &quot;image&quot;,
                    &quot;command&quot;,
                    &quot;hostname&quot;,
                    &quot;user&quot;,
                    &quot;detach&quot;,
                    &quot;stdin_open&quot;,
                    &quot;tty&quot;,
                    &quot;ports&quot;,
                    &quot;environment&quot;,
                    &quot;volumes&quot;,
                    &quot;network_disabled&quot;,
                    &quot;name&quot;,
                    &quot;entrypoint&quot;,
                    &quot;working_dir&quot;,
                    &quot;domainname&quot;,
                    &quot;cpuset&quot;,
                    &quot;host_config&quot;,
                    &quot;mac_address&quot;,
                    &quot;labels&quot;,
                    &quot;volume_driver&quot;,
                    &quot;stop_signal&quot;,
                    &quot;networking_config&quot;,
                    &quot;healthcheck&quot;,
                    &quot;stop_timeout&quot;,
                ],
                &quot;host_config&quot;: [
                    &quot;binds&quot;,
                    &quot;port_bindings&quot;,
                    &quot;lxc_conf&quot;,
                    &quot;publish_all_ports&quot;,
                    &quot;links&quot;,
                    &quot;privileged&quot;,
                    &quot;dns&quot;,
                    &quot;dns_search&quot;,
                    &quot;volumes_from&quot;,
                    &quot;network_mode&quot;,
                    &quot;restart_policy&quot;,
                    &quot;cap_add&quot;,
                    &quot;cap_drop&quot;,
                    &quot;devices&quot;,
                    &quot;extra_hosts&quot;,
                    &quot;read_only&quot;,
                    &quot;pid_mode&quot;,
                    &quot;ipc_mode&quot;,
                    &quot;security_opt&quot;,
                    &quot;ulimits&quot;,
                    &quot;log_config&quot;,
                    &quot;mem_limit&quot;,
                    &quot;memswap_limit&quot;,
                    &quot;mem_reservation&quot;,
                    &quot;kernel_memory&quot;,
                    &quot;mem_swappiness&quot;,
                    &quot;cgroup_parent&quot;,
                    &quot;group_add&quot;,
                    &quot;cpu_quota&quot;,
                    &quot;cpu_period&quot;,
                    &quot;blkio_weight&quot;,
                    &quot;blkio_weight_device&quot;,
                    &quot;device_read_bps&quot;,
                    &quot;device_write_bps&quot;,
                    &quot;device_read_iops&quot;,
                    &quot;device_write_iops&quot;,
                    &quot;oom_kill_disable&quot;,
                    &quot;shm_size&quot;,
                    &quot;sysctls&quot;,
                    &quot;tmpfs&quot;,
                    &quot;oom_score_adj&quot;,
                    &quot;dns_opt&quot;,
                    &quot;cpu_shares&quot;,
                    &quot;cpuset_cpus&quot;,
                    &quot;userns_mode&quot;,
                    &quot;pids_limit&quot;,
                    &quot;isolation&quot;,
                    &quot;auto_remove&quot;,
                    &quot;storage_opt&quot;,
                ],
                &quot;networking_config&quot;: [
                    &quot;aliases&quot;,
                    &quot;links&quot;,
                    &quot;ipv4_address&quot;,
                    &quot;ipv6_address&quot;,
                    &quot;link_local_ips&quot;,
                ],
            }
        )

        mine_send = Mock()
        command = getattr(docker_mod, command_name)
        client = MagicMock()
        client.api_version = &quot;1.12&quot;
        with patch.dict(
            docker_mod.__salt__,
            {
                &quot;mine.send&quot;: mine_send,
                &quot;container_resource.run&quot;: MagicMock(),
                &quot;config.get&quot;: MagicMock(return_value=True),
                &quot;config.option&quot;: MagicMock(return_value=True),
                &quot;cp.cache_file&quot;: MagicMock(return_value=False),
            },
        ):
            with patch.dict(
                docker_mod.__utils__,
                {&quot;docker.get_client_args&quot;: client_args_mock},
            ):
                with patch.object(docker_mod, &quot;_get_client&quot;, client):
                    command(&quot;container&quot;, *args)
        try:
            mine_send.assert_called_with(&quot;docker.ps&quot;, verbose=True, all=True, host=True)
        except AssertionError as exc:
            raise Exception(
                &quot;command '{}' did not call docker.ps with expected &quot;
                &quot;arguments: {}&quot;.format(command_name, exc)
            )


def test_update_mine():
    &quot;&quot;&quot;
    Test the docker.update_mine config option
    &quot;&quot;&quot;

    def config_get_disabled(val, default):
        return {
            &quot;base_url&quot;: docker_mod.NOTSET,
            &quot;version&quot;: docker_mod.NOTSET,
            &quot;docker.url&quot;: docker_mod.NOTSET,
            &quot;docker.version&quot;: docker_mod.NOTSET,
            &quot;docker.machine&quot;: docker_mod.NOTSET,
            &quot;docker.update_mine&quot;: False,
        }[val]

    def config_get_enabled(val, default):
        return {
            &quot;base_url&quot;: docker_mod.NOTSET,
            &quot;version&quot;: docker_mod.NOTSET,
            &quot;docker.url&quot;: docker_mod.NOTSET,
            &quot;docker.version&quot;: docker_mod.NOTSET,
            &quot;docker.machine&quot;: docker_mod.NOTSET,
            &quot;docker.update_mine&quot;: True,
        }[val]

    mine_mock = Mock()
    dunder_salt = {
        &quot;config.get&quot;: MagicMock(side_effect=config_get_disabled),
        &quot;config.option&quot;: MagicMock(return_value=False),
        &quot;mine.send&quot;: mine_mock,
    }
    with patch.dict(docker_mod.__salt__, dunder_salt), patch.dict(
        docker_mod.__context__, {&quot;docker.client&quot;: Mock()}
    ), patch.object(docker_mod, &quot;state&quot;, MagicMock(return_value=&quot;stopped&quot;)):
        docker_mod.stop(&quot;foo&quot;, timeout=1)
        mine_mock.assert_not_called()

    with patch.dict(docker_mod.__salt__, dunder_salt), patch.dict(
        docker_mod.__context__, {&quot;docker.client&quot;: Mock()}
    ), patch.object(docker_mod, &quot;state&quot;, MagicMock(return_value=&quot;stopped&quot;)):
        dunder_salt[&quot;config.get&quot;].side_effect = config_get_enabled
        dunder_salt[&quot;config.option&quot;].return_value = True
        docker_mod.stop(&quot;foo&quot;, timeout=1)
        mine_mock.assert_called_once()


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_list_networks():
    &quot;&quot;&quot;
    test list networks.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
        &quot;mine.send&quot;: Mock(),
    }
<A NAME="0"></A>    client = Mock()
    client.api_version = &quot;1.21&quot;
    client.networks = Mock(
        return_value=[{<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#0',2,'match24703-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;Name&quot;: &quot;foo&quot;, &quot;Id&quot;: &quot;01234&quot;, &quot;Containers&quot;: {}}]
    )
    get_client_mock = MagicMock(return_value=client)
    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.</B></FONT>networks(names=[&quot;foo&quot;], ids=[&quot;01234&quot;])
    client.networks.assert_called_once_with(names=[&quot;foo&quot;], ids=[&quot;01234&quot;])


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_create_network():
    &quot;&quot;&quot;
    test create network.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
<A NAME="5"></A>        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#5',2,'match24703-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.</B></FONT>create_network(
                &quot;foo&quot;,
                driver=&quot;bridge&quot;,
                driver_opts={},
                gateway=&quot;192.168.0.1&quot;,
                ip_range=&quot;192.168.0.128/25&quot;,
                subnet=&quot;192.168.0.0/24&quot;,
            )
    client.create_network.assert_called_once_with(
        &quot;foo&quot;,
        driver=&quot;bridge&quot;,
        options={},
        ipam={
            &quot;Config&quot;: [
                {
                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;,
                    &quot;IPRange&quot;: &quot;192.168.0.128/25&quot;,
                    &quot;Subnet&quot;: &quot;192.168.0.0/24&quot;,
                }
            ],
            &quot;Driver&quot;: &quot;default&quot;,
        },
        check_duplicate=True,
    )


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_remove_network():
    &quot;&quot;&quot;
    test remove network.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
<A NAME="4"></A>        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#4',2,'match24703-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.</B></FONT>remove_network(&quot;foo&quot;)
    client.remove_network.assert_called_once_with(&quot;foo&quot;)


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_inspect_network():
    &quot;&quot;&quot;
    test inspect network.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
<A NAME="3"></A>        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#3',2,'match24703-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.</B></FONT>inspect_network(&quot;foo&quot;)
    client.inspect_network.assert_called_once_with(&quot;foo&quot;)


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_connect_container_to_network():
    &quot;&quot;&quot;
    test connect_container_to_network
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version = &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    context = {&quot;docker.exec_driver&quot;: &quot;docker-exec&quot;}

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.dict(docker_mod.__context__, context):
            with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
                docker_mod.connect_container_to_network(&quot;container&quot;, &quot;foo&quot;)
    client.connect_container_to_network.assert_called_once_with(&quot;container&quot;, &quot;foo&quot;)


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_disconnect_container_from_network():
    &quot;&quot;&quot;
    test disconnect_container_from_network
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
<A NAME="2"></A>        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#2',2,'match24703-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.</B></FONT>disconnect_container_from_network(&quot;container&quot;, &quot;foo&quot;)
    client.disconnect_container_from_network.assert_called_once_with(&quot;container&quot;, &quot;foo&quot;)


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_list_volumes():
    &quot;&quot;&quot;
    test list volumes.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
<A NAME="1"></A>        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#1',2,'match24703-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.</B></FONT>volumes(
                filters={&quot;dangling&quot;: [True]},
            )
    client.volumes.assert_called_once_with(
        filters={&quot;dangling&quot;: [True]},
    )


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_create_volume():
    &quot;&quot;&quot;
    test create volume.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
        &quot;mine.send&quot;: Mock(),
<A NAME="7"></A>    }
    client = Mock()
    client.api_version = &quot;1.21&quot;
    get_client_mock <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match24703-0.html#7',2,'match24703-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.</B></FONT>create_volume(
                &quot;foo&quot;,
                driver=&quot;bridge&quot;,
                driver_opts={},
            )
    client.create_volume.assert_called_once_with(
        &quot;foo&quot;,
        driver=&quot;bridge&quot;,
        driver_opts={},
    )


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_remove_volume():
    &quot;&quot;&quot;
    test remove volume.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version = &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.remove_volume(&quot;foo&quot;)
    client.remove_volume.assert_called_once_with(&quot;foo&quot;)


@pytest.mark.skipif(
    docker_mod.docker.version_info &lt; (1, 5, 0),
    reason=&quot;docker module must be installed to run this test or is too old. &gt;=1.5.0&quot;,
)
def test_inspect_volume():
    &quot;&quot;&quot;
    test inspect volume.
    &quot;&quot;&quot;
    __salt__ = {
        &quot;config.get&quot;: Mock(),
        &quot;mine.send&quot;: Mock(),
    }
    client = Mock()
    client.api_version = &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    with patch.dict(docker_mod.__dict__, {&quot;__salt__&quot;: __salt__}):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod.inspect_volume(&quot;foo&quot;)
    client.inspect_volume.assert_called_once_with(&quot;foo&quot;)


def test_wait_success():
    client = Mock()
    client.api_version = &quot;1.21&quot;
    client.wait = Mock(return_value=0)
    get_client_mock = MagicMock(return_value=client)

    docker_inspect_container = Mock(
        side_effect=[{&quot;State&quot;: {&quot;Running&quot;: True}}, {&quot;State&quot;: {&quot;Stopped&quot;: True}}]
    )
    with patch.object(docker_mod, &quot;inspect_container&quot;, docker_inspect_container):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod._clear_context()
            result = docker_mod.wait(&quot;foo&quot;)
    assert result == {
        &quot;result&quot;: True,
        &quot;exit_status&quot;: 0,
        &quot;state&quot;: {&quot;new&quot;: &quot;stopped&quot;, &quot;old&quot;: &quot;running&quot;},
    }


def test_wait_fails_already_stopped():
    client = Mock()
    client.api_version = &quot;1.21&quot;
    client.wait = Mock(return_value=0)
    get_client_mock = MagicMock(return_value=client)

    docker_inspect_container = Mock(
        side_effect=[{&quot;State&quot;: {&quot;Stopped&quot;: True}}, {&quot;State&quot;: {&quot;Stopped&quot;: True}}]
    )
    with patch.object(docker_mod, &quot;inspect_container&quot;, docker_inspect_container):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod._clear_context()
            result = docker_mod.wait(&quot;foo&quot;)
    assert result == {
        &quot;result&quot;: False,
        &quot;comment&quot;: &quot;Container 'foo' already stopped&quot;,
        &quot;exit_status&quot;: 0,
        &quot;state&quot;: {&quot;new&quot;: &quot;stopped&quot;, &quot;old&quot;: &quot;stopped&quot;},
    }


def test_wait_success_already_stopped():
    client = Mock()
    client.api_version = &quot;1.21&quot;
    client.wait = Mock(return_value=0)
    get_client_mock = MagicMock(return_value=client)

    docker_inspect_container = Mock(
        side_effect=[{&quot;State&quot;: {&quot;Stopped&quot;: True}}, {&quot;State&quot;: {&quot;Stopped&quot;: True}}]
    )
    with patch.object(docker_mod, &quot;inspect_container&quot;, docker_inspect_container):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod._clear_context()
            result = docker_mod.wait(&quot;foo&quot;, ignore_already_stopped=True)
    assert result == {
        &quot;result&quot;: True,
        &quot;comment&quot;: &quot;Container 'foo' already stopped&quot;,
        &quot;exit_status&quot;: 0,
        &quot;state&quot;: {&quot;new&quot;: &quot;stopped&quot;, &quot;old&quot;: &quot;stopped&quot;},
    }


def test_wait_success_absent_container():
    client = Mock()
    client.api_version = &quot;1.21&quot;
    get_client_mock = MagicMock(return_value=client)

    docker_inspect_container = Mock(side_effect=CommandExecutionError)
    with patch.object(docker_mod, &quot;inspect_container&quot;, docker_inspect_container):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod._clear_context()
            result = docker_mod.wait(&quot;foo&quot;, ignore_already_stopped=True)
    assert result == {&quot;result&quot;: True, &quot;comment&quot;: &quot;Container 'foo' absent&quot;}


def test_wait_fails_on_exit_status():
    client = Mock()
    client.api_version = &quot;1.21&quot;
    client.wait = Mock(return_value=1)
    get_client_mock = MagicMock(return_value=client)

    docker_inspect_container = Mock(
        side_effect=[{&quot;State&quot;: {&quot;Running&quot;: True}}, {&quot;State&quot;: {&quot;Stopped&quot;: True}}]
    )
    with patch.object(docker_mod, &quot;inspect_container&quot;, docker_inspect_container):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod._clear_context()
            result = docker_mod.wait(&quot;foo&quot;, fail_on_exit_status=True)
    assert result == {
        &quot;result&quot;: False,
        &quot;exit_status&quot;: 1,
        &quot;state&quot;: {&quot;new&quot;: &quot;stopped&quot;, &quot;old&quot;: &quot;running&quot;},
    }


def test_wait_fails_on_exit_status_and_already_stopped():
    client = Mock()
    client.api_version = &quot;1.21&quot;
    client.wait = Mock(return_value=1)
    get_client_mock = MagicMock(return_value=client)

    docker_inspect_container = Mock(
        side_effect=[{&quot;State&quot;: {&quot;Stopped&quot;: True}}, {&quot;State&quot;: {&quot;Stopped&quot;: True}}]
    )
    with patch.object(docker_mod, &quot;inspect_container&quot;, docker_inspect_container):
        with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
            docker_mod._clear_context()
            result = docker_mod.wait(
                &quot;foo&quot;, ignore_already_stopped=True, fail_on_exit_status=True
            )
    assert result == {
        &quot;result&quot;: False,
        &quot;comment&quot;: &quot;Container 'foo' already stopped&quot;,
        &quot;exit_status&quot;: 1,
        &quot;state&quot;: {&quot;new&quot;: &quot;stopped&quot;, &quot;old&quot;: &quot;stopped&quot;},
    }


def test_sls_build():
    &quot;&quot;&quot;
    test build sls image.
    &quot;&quot;&quot;
    docker_start_mock = MagicMock(return_value={})
    docker_create_mock = MagicMock(return_value={&quot;Id&quot;: &quot;ID&quot;, &quot;Name&quot;: &quot;NAME&quot;})
    docker_stop_mock = MagicMock(
        return_value={&quot;state&quot;: {&quot;old&quot;: &quot;running&quot;, &quot;new&quot;: &quot;stopped&quot;}, &quot;result&quot;: True}
    )
    docker_rm_mock = MagicMock(return_value={})
    docker_commit_mock = MagicMock(
        return_value={&quot;Id&quot;: &quot;ID2&quot;, &quot;Image&quot;: &quot;foo&quot;, &quot;Time_Elapsed&quot;: 42}
    )

    docker_sls_mock = MagicMock(
        return_value={
            &quot;file_|-/etc/test.sh_|-/etc/test.sh_|-managed&quot;: {
                &quot;comment&quot;: &quot;File /etc/test.sh is in the correct state&quot;,
                &quot;name&quot;: &quot;/etc/test.sh&quot;,
                &quot;start_time&quot;: &quot;07:04:26.834792&quot;,
                &quot;result&quot;: True,
                &quot;duration&quot;: 13.492,
                &quot;__run_num__&quot;: 0,
                &quot;changes&quot;: {},
            },
            &quot;test_|-always-passes_|-foo_|-succeed_without_changes&quot;: {
                &quot;comment&quot;: &quot;Success!&quot;,
                &quot;name&quot;: &quot;foo&quot;,
                &quot;start_time&quot;: &quot;07:04:26.848915&quot;,
                &quot;result&quot;: True,
                &quot;duration&quot;: 0.363,
                &quot;__run_num__&quot;: 1,
                &quot;changes&quot;: {},
            },
        }
    )

    ret = None
    with patch.object(docker_mod, &quot;start_&quot;, docker_start_mock), patch.object(
        docker_mod, &quot;create&quot;, docker_create_mock
    ), patch.object(docker_mod, &quot;stop&quot;, docker_stop_mock), patch.object(
        docker_mod, &quot;commit&quot;, docker_commit_mock
    ), patch.object(
        docker_mod, &quot;sls&quot;, docker_sls_mock
    ), patch.object(
        docker_mod, &quot;rm_&quot;, docker_rm_mock
    ):
        ret = docker_mod.sls_build(&quot;foo&quot;, mods=&quot;foo&quot;)
    docker_create_mock.assert_called_once_with(
        cmd=&quot;sleep infinity&quot;, image=&quot;opensuse/python&quot;, interactive=True, tty=True
    )
    docker_start_mock.assert_called_once_with(&quot;ID&quot;)
    docker_sls_mock.assert_called_once_with(&quot;ID&quot;, &quot;foo&quot;)
    docker_stop_mock.assert_called_once_with(&quot;ID&quot;)
    docker_rm_mock.assert_called_once_with(&quot;ID&quot;)
    docker_commit_mock.assert_called_once_with(&quot;ID&quot;, &quot;foo&quot;, tag=&quot;latest&quot;)
    assert {&quot;Id&quot;: &quot;ID2&quot;, &quot;Image&quot;: &quot;foo&quot;, &quot;Time_Elapsed&quot;: 42} == ret


def test_sls_build_dryrun():
    &quot;&quot;&quot;
    test build sls image in dryrun mode.
    &quot;&quot;&quot;
    docker_start_mock = MagicMock(return_value={})
    docker_create_mock = MagicMock(return_value={&quot;Id&quot;: &quot;ID&quot;, &quot;Name&quot;: &quot;NAME&quot;})
    docker_stop_mock = MagicMock(
        return_value={&quot;state&quot;: {&quot;old&quot;: &quot;running&quot;, &quot;new&quot;: &quot;stopped&quot;}, &quot;result&quot;: True}
    )
    docker_rm_mock = MagicMock(return_value={})

    docker_sls_mock = MagicMock(
        return_value={
            &quot;file_|-/etc/test.sh_|-/etc/test.sh_|-managed&quot;: {
                &quot;comment&quot;: &quot;File /etc/test.sh is in the correct state&quot;,
                &quot;name&quot;: &quot;/etc/test.sh&quot;,
                &quot;start_time&quot;: &quot;07:04:26.834792&quot;,
                &quot;result&quot;: True,
                &quot;duration&quot;: 13.492,
                &quot;__run_num__&quot;: 0,
                &quot;changes&quot;: {},
            },
            &quot;test_|-always-passes_|-foo_|-succeed_without_changes&quot;: {
                &quot;comment&quot;: &quot;Success!&quot;,
                &quot;name&quot;: &quot;foo&quot;,
                &quot;start_time&quot;: &quot;07:04:26.848915&quot;,
                &quot;result&quot;: True,
                &quot;duration&quot;: 0.363,
                &quot;__run_num__&quot;: 1,
                &quot;changes&quot;: {},
            },
        }
    )

    ret = None
    with patch.object(docker_mod, &quot;start_&quot;, docker_start_mock), patch.object(
        docker_mod, &quot;create&quot;, docker_create_mock
    ), patch.object(docker_mod, &quot;stop&quot;, docker_stop_mock), patch.object(
        docker_mod, &quot;rm_&quot;, docker_rm_mock
    ), patch.object(
        docker_mod, &quot;sls&quot;, docker_sls_mock
    ):
        ret = docker_mod.sls_build(&quot;foo&quot;, mods=&quot;foo&quot;, dryrun=True)
    docker_create_mock.assert_called_once_with(
        cmd=&quot;sleep infinity&quot;, image=&quot;opensuse/python&quot;, interactive=True, tty=True
    )
    docker_start_mock.assert_called_once_with(&quot;ID&quot;)
    docker_sls_mock.assert_called_once_with(&quot;ID&quot;, &quot;foo&quot;)
    docker_stop_mock.assert_called_once_with(&quot;ID&quot;)
    docker_rm_mock.assert_called_once_with(&quot;ID&quot;)
    assert {
        &quot;file_|-/etc/test.sh_|-/etc/test.sh_|-managed&quot;: {
            &quot;comment&quot;: &quot;File /etc/test.sh is in the correct state&quot;,
            &quot;name&quot;: &quot;/etc/test.sh&quot;,
            &quot;start_time&quot;: &quot;07:04:26.834792&quot;,
            &quot;result&quot;: True,
            &quot;duration&quot;: 13.492,
            &quot;__run_num__&quot;: 0,
            &quot;changes&quot;: {},
        },
        &quot;test_|-always-passes_|-foo_|-succeed_without_changes&quot;: {
            &quot;comment&quot;: &quot;Success!&quot;,
            &quot;name&quot;: &quot;foo&quot;,
            &quot;start_time&quot;: &quot;07:04:26.848915&quot;,
            &quot;result&quot;: True,
            &quot;duration&quot;: 0.363,
            &quot;__run_num__&quot;: 1,
            &quot;changes&quot;: {},
        },
    } == ret


@pytest.mark.slow_test
def test_call_success():
    &quot;&quot;&quot;
    test module calling inside containers
    &quot;&quot;&quot;
    ret = None
    docker_run_all_mock = MagicMock(
        return_value={
            &quot;retcode&quot;: 0,
            &quot;stdout&quot;: '{&quot;retcode&quot;: 0, &quot;comment&quot;: &quot;container cmd&quot;}',
            &quot;stderr&quot;: &quot;err&quot;,
        }
    )
    docker_copy_to_mock = MagicMock(return_value={&quot;retcode&quot;: 0})
    docker_config_mock = MagicMock(return_value=&quot;&quot;)
    client = Mock()
    client.put_archive = Mock()
    get_client_mock = MagicMock(return_value=client)

    context = {&quot;docker.exec_driver&quot;: &quot;docker-exec&quot;}
    salt_dunder = {&quot;config.option&quot;: docker_config_mock}

    with patch.object(docker_mod, &quot;run_all&quot;, docker_run_all_mock), patch.object(
        docker_mod, &quot;copy_to&quot;, docker_copy_to_mock
    ), patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock), patch.dict(
        docker_mod.__opts__, {&quot;cachedir&quot;: &quot;/tmp&quot;}
    ), patch.dict(
        docker_mod.__salt__, salt_dunder
    ), patch.dict(
        docker_mod.__context__, context
    ):
        # call twice to verify tmp path later
        for i in range(2):
            ret = docker_mod.call(&quot;ID&quot;, &quot;test.arg&quot;, 1, 2, arg1=&quot;val1&quot;)

    # Check that the directory is different each time
    # [ call(name, [args]), ...
    assert &quot;mkdir&quot; in docker_run_all_mock.mock_calls[0][1][1]
    assert &quot;mkdir&quot; in docker_run_all_mock.mock_calls[5][1][1]
    assert (
        docker_run_all_mock.mock_calls[0][1][1]
        != docker_run_all_mock.mock_calls[5][1][1]
    )

    assert &quot;python3 --version&quot; == docker_run_all_mock.mock_calls[1][1][1]

    assert &quot;salt-call&quot; in docker_run_all_mock.mock_calls[3][1][1]
    assert &quot;salt-call&quot; in docker_run_all_mock.mock_calls[8][1][1]
    assert (
        docker_run_all_mock.mock_calls[3][1][1]
        != docker_run_all_mock.mock_calls[8][1][1]
    )

    # check thin untar
    assert &quot;tarfile&quot; in docker_run_all_mock.mock_calls[2][1][1]
    assert &quot;tarfile&quot; in docker_run_all_mock.mock_calls[7][1][1]
    assert (
        docker_run_all_mock.mock_calls[2][1][1]
        != docker_run_all_mock.mock_calls[7][1][1]
    )

    # check directory cleanup
    assert &quot;rm -rf&quot; in docker_run_all_mock.mock_calls[4][1][1]
    assert &quot;rm -rf&quot; in docker_run_all_mock.mock_calls[9][1][1]
    assert (
        docker_run_all_mock.mock_calls[4][1][1]
        != docker_run_all_mock.mock_calls[9][1][1]
    )

    assert {&quot;retcode&quot;: 0, &quot;comment&quot;: &quot;container cmd&quot;} == ret


def test_images_with_empty_tags():
    &quot;&quot;&quot;
    docker 1.12 reports also images without tags with `null`.
    &quot;&quot;&quot;
    client = Mock()
    client.api_version = &quot;1.24&quot;
    client.images = Mock(
        return_value=[
            {&quot;Id&quot;: &quot;sha256:abcde&quot;, &quot;RepoTags&quot;: None},
            {&quot;Id&quot;: &quot;sha256:abcdef&quot;},
            {&quot;Id&quot;: &quot;sha256:abcdefg&quot;, &quot;RepoTags&quot;: [&quot;image:latest&quot;]},
        ]
    )
    get_client_mock = MagicMock(return_value=client)

    with patch.object(docker_mod, &quot;_get_client&quot;, get_client_mock):
        docker_mod._clear_context()
        result = docker_mod.images()
    assert result == {&quot;sha256:abcdefg&quot;: {&quot;RepoTags&quot;: [&quot;image:latest&quot;]}}


def test_compare_container_image_id_resolution():
    &quot;&quot;&quot;
    Test comparing two containers when one's inspect output is an ID and
    not formatted in image:tag notation.
    &quot;&quot;&quot;

    def _inspect_container_effect(id_):
        return {
            &quot;container1&quot;: {
                &quot;Config&quot;: {&quot;Image&quot;: &quot;realimage:latest&quot;},
                &quot;HostConfig&quot;: {},
            },
            &quot;container2&quot;: {&quot;Config&quot;: {&quot;Image&quot;: &quot;image_id&quot;}, &quot;HostConfig&quot;: {}},
        }[id_]

    def _inspect_image_effect(id_):
        return {
            &quot;realimage:latest&quot;: {&quot;Id&quot;: &quot;image_id&quot;},
            &quot;image_id&quot;: {&quot;Id&quot;: &quot;image_id&quot;},
        }[id_]

    inspect_container_mock = MagicMock(side_effect=_inspect_container_effect)
    inspect_image_mock = MagicMock(side_effect=_inspect_image_effect)

    with patch.object(docker_mod, &quot;inspect_container&quot;, inspect_container_mock):
        with patch.object(docker_mod, &quot;inspect_image&quot;, inspect_image_mock):
            ret = docker_mod.compare_containers(&quot;container1&quot;, &quot;container2&quot;)
            assert ret == {}


def test_compare_container_ulimits_order():
    &quot;&quot;&quot;
    Test comparing two containers when the order of the Ulimits HostConfig
    values are different, but the values are the same.
    &quot;&quot;&quot;

    def _inspect_container_effect(id_):
        return {
            &quot;container1&quot;: {
                &quot;Config&quot;: {},
                &quot;HostConfig&quot;: {
                    &quot;Ulimits&quot;: [
                        {&quot;Hard&quot;: -1, &quot;Soft&quot;: -1, &quot;Name&quot;: &quot;core&quot;},
                        {&quot;Hard&quot;: 65536, &quot;Soft&quot;: 65536, &quot;Name&quot;: &quot;nofile&quot;},
                    ]
                },
            },
            &quot;container2&quot;: {
                &quot;Config&quot;: {},
                &quot;HostConfig&quot;: {
                    &quot;Ulimits&quot;: [
                        {&quot;Hard&quot;: 65536, &quot;Soft&quot;: 65536, &quot;Name&quot;: &quot;nofile&quot;},
                        {&quot;Hard&quot;: -1, &quot;Soft&quot;: -1, &quot;Name&quot;: &quot;core&quot;},
                    ]
                },
            },
        }[id_]

    inspect_container_mock = MagicMock(side_effect=_inspect_container_effect)

    with patch.object(docker_mod, &quot;inspect_container&quot;, inspect_container_mock):
        # pylint: disable=not-callable
        ret = docker_mod.compare_container(&quot;container1&quot;, &quot;container2&quot;)
        # pylint: enable=not-callable
        assert ret == {}


def test_compare_container_env_order():
    &quot;&quot;&quot;
    Test comparing two containers when the order of the Env HostConfig
    values are different, but the values are the same.
    &quot;&quot;&quot;

    def _inspect_container_effect(id_):
        return {
            &quot;container1&quot;: {
                &quot;Config&quot;: {},
                &quot;HostConfig&quot;: {&quot;Env&quot;: [&quot;FOO=bar&quot;, &quot;HELLO=world&quot;]},
            },
            &quot;container2&quot;: {
                &quot;Config&quot;: {},
                &quot;HostConfig&quot;: {&quot;Env&quot;: [&quot;HELLO=world&quot;, &quot;FOO=bar&quot;]},
            },
        }[id_]

    inspect_container_mock = MagicMock(side_effect=_inspect_container_effect)

    with patch.object(docker_mod, &quot;inspect_container&quot;, inspect_container_mock):
        # pylint: disable=not-callable
        ret = docker_mod.compare_container(&quot;container1&quot;, &quot;container2&quot;)
        # pylint: enable=not-callable
        assert ret == {}


def test_resolve_tag():
    &quot;&quot;&quot;
    Test the resolve_tag function. It runs docker.insect_image on the image
    name passed and then looks for the RepoTags key in the result
    &quot;&quot;&quot;
    id_ = &quot;sha256:6ad733544a6317992a6fac4eb19fe1df577d4dec7529efec28a5bd0edad0fd30&quot;
    tags = [&quot;foo:latest&quot;, &quot;foo:bar&quot;]
    mock_tagged = MagicMock(return_value={&quot;Id&quot;: id_, &quot;RepoTags&quot;: tags})
    mock_untagged = MagicMock(return_value={&quot;Id&quot;: id_, &quot;RepoTags&quot;: []})
    mock_unexpected = MagicMock(return_value={&quot;Id&quot;: id_})
    mock_not_found = MagicMock(side_effect=CommandExecutionError())

    with patch.object(docker_mod, &quot;inspect_image&quot;, mock_tagged):
        assert docker_mod.resolve_tag(&quot;foo&quot;) == tags[0]
        assert docker_mod.resolve_tag(&quot;foo&quot;, all=True) == tags

    with patch.object(docker_mod, &quot;inspect_image&quot;, mock_untagged):
        assert docker_mod.resolve_tag(&quot;foo&quot;) == id_
        assert docker_mod.resolve_tag(&quot;foo&quot;, all=True) == [id_]

    with patch.object(docker_mod, &quot;inspect_image&quot;, mock_unexpected):
        assert docker_mod.resolve_tag(&quot;foo&quot;) == id_
        assert docker_mod.resolve_tag(&quot;foo&quot;, all=True) == [id_]

    with patch.object(docker_mod, &quot;inspect_image&quot;, mock_not_found):
        assert docker_mod.resolve_tag(&quot;foo&quot;) is False
        assert docker_mod.resolve_tag(&quot;foo&quot;, all=True) is False


def test_prune():
    &quot;&quot;&quot;
    Test the prune function
    &quot;&quot;&quot;

    def _run(**kwargs):
        side_effect = kwargs.pop(&quot;side_effect&quot;, None)
        # No arguments passed, we should be pruning everything but volumes
        client = Mock()
        if side_effect is not None:
            client.side_effect = side_effect
        with patch.object(docker_mod, &quot;_client_wrapper&quot;, client):
            docker_mod.prune(**kwargs)
        return client

    # Containers only, no filters
    client = _run(containers=True)
    client.assert_called_once_with(&quot;prune_containers&quot;, filters={})

    # Containers only, with filters
    client = _run(containers=True, until=&quot;24h&quot;, label=&quot;foo,bar=baz&quot;)
    client.assert_called_once_with(
        &quot;prune_containers&quot;, filters={&quot;until&quot;: [&quot;24h&quot;], &quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}
    )

    # Images only, no filters
    client = _run(images=True)
    client.assert_called_once_with(&quot;prune_images&quot;, filters={})

    # Images only, with filters
    client = _run(images=True, dangling=True, until=&quot;24h&quot;, label=&quot;foo,bar=baz&quot;)
    client.assert_called_once_with(
        &quot;prune_images&quot;,
        filters={&quot;dangling&quot;: True, &quot;until&quot;: [&quot;24h&quot;], &quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]},
    )

    # Networks only, no filters
    client = _run(networks=True)
    client.assert_called_once_with(&quot;prune_networks&quot;, filters={})

    # Networks only, with filters
    client = _run(networks=True, until=&quot;24h&quot;, label=&quot;foo,bar=baz&quot;)
    client.assert_called_once_with(
        &quot;prune_networks&quot;, filters={&quot;until&quot;: [&quot;24h&quot;], &quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}
    )

    # Volumes only, no filters
    client = _run(system=False, volumes=True)
    client.assert_called_once_with(&quot;prune_volumes&quot;, filters={})

    # Volumes only, with filters
    client = _run(system=False, volumes=True, label=&quot;foo,bar=baz&quot;)
    client.assert_called_once_with(
        &quot;prune_volumes&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}
    )

    # Containers and images, no filters
    client = _run(containers=True, images=True)
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={}),
        call(&quot;prune_images&quot;, filters={}),
    ]

    # Containers and images, with filters
    client = _run(containers=True, images=True, until=&quot;24h&quot;, label=&quot;foo,bar=baz&quot;)
    assert client.call_args_list == [
        call(
            &quot;prune_containers&quot;,
            filters={&quot;until&quot;: [&quot;24h&quot;], &quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]},
        ),
        call(
            &quot;prune_images&quot;,
            filters={&quot;until&quot;: [&quot;24h&quot;], &quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]},
        ),
    ]

    # System, no volumes, no filters, assuming prune_build in docker-py
    client = _run(system=True)
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={}),
        call(&quot;prune_images&quot;, filters={}),
        call(&quot;prune_networks&quot;, filters={}),
        call(&quot;prune_build&quot;, filters={}),
    ]

    # System, no volumes, no filters, assuming prune_build not in docker-py
    client = _run(
        system=True,
        side_effect=[None, None, None, SaltInvocationError(), None, None, None],
    )
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={}),
        call(&quot;prune_images&quot;, filters={}),
        call(&quot;prune_networks&quot;, filters={}),
        call(&quot;prune_build&quot;, filters={}),
        call(&quot;_url&quot;, &quot;/build/prune&quot;),
        call(&quot;_post&quot;, None),
        call(&quot;_result&quot;, None, True),
    ]

    # System, no volumes, with filters, assuming prune_build in docker-py
    client = _run(system=True, label=&quot;foo,bar=baz&quot;)
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_images&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_networks&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_build&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
    ]

    # System, no volumes, with filters, assuming prune_build not in docker-py
    client = _run(
        system=True,
        label=&quot;foo,bar=baz&quot;,
        side_effect=[None, None, None, SaltInvocationError(), None, None, None],
    )
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_images&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_networks&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_build&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;_url&quot;, &quot;/build/prune&quot;),
        call(&quot;_post&quot;, None),
        call(&quot;_result&quot;, None, True),
    ]

    # System and volumes, no filters, assuming prune_build in docker-py
    client = _run(system=True, volumes=True)
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={}),
        call(&quot;prune_images&quot;, filters={}),
        call(&quot;prune_networks&quot;, filters={}),
        call(&quot;prune_build&quot;, filters={}),
        call(&quot;prune_volumes&quot;, filters={}),
    ]

    # System and volumes, no filters, assuming prune_build not in docker-py
    client = _run(
        system=True,
        volumes=True,
        side_effect=[
            None,
            None,
            None,
            SaltInvocationError(),
            None,
            None,
            None,
            None,
        ],
    )
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={}),
        call(&quot;prune_images&quot;, filters={}),
        call(&quot;prune_networks&quot;, filters={}),
        call(&quot;prune_build&quot;, filters={}),
        call(&quot;_url&quot;, &quot;/build/prune&quot;),
        call(&quot;_post&quot;, None),
        call(&quot;_result&quot;, None, True),
        call(&quot;prune_volumes&quot;, filters={}),
    ]

    # System and volumes with filters, assuming prune_build in docker-py
    client = _run(system=True, volumes=True, label=&quot;foo,bar=baz&quot;)
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_images&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_networks&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_build&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_volumes&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
    ]

    # System and volumes, with filters, assuming prune_build not in docker-py
    client = _run(
        system=True,
        volumes=True,
        label=&quot;foo,bar=baz&quot;,
        side_effect=[
            None,
            None,
            None,
            SaltInvocationError(),
            None,
            None,
            None,
            None,
        ],
    )
    assert client.call_args_list == [
        call(&quot;prune_containers&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_images&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_networks&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;prune_build&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
        call(&quot;_url&quot;, &quot;/build/prune&quot;),
        call(&quot;_post&quot;, None),
        call(&quot;_result&quot;, None, True),
        call(&quot;prune_volumes&quot;, filters={&quot;label&quot;: [&quot;foo&quot;, &quot;bar=baz&quot;]}),
    ]


def test_port():
    &quot;&quot;&quot;
    Test docker.port function. Note that this test case does not test what
    happens when a specific container name is passed and that container
    does not exist. When that happens, the Docker API will just raise a 404
    error. Since we're using as side_effect to mock
    docker.inspect_container, it would be meaningless to code raising an
    exception into it and then test that we raised that exception.
    &quot;&quot;&quot;
    ports = {
        &quot;foo&quot;: {
            &quot;5555/tcp&quot;: [{&quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32768&quot;}],
            &quot;6666/tcp&quot;: [{&quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32769&quot;}],
        },
        &quot;bar&quot;: {
            &quot;4444/udp&quot;: [{&quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32767&quot;}],
            &quot;5555/tcp&quot;: [{&quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32768&quot;}],
            &quot;6666/tcp&quot;: [{&quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32769&quot;}],
        },
        &quot;baz&quot;: {
            &quot;5555/tcp&quot;: [{&quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32768&quot;}],
            &quot;6666/udp&quot;: [{&quot;HostIp&quot;: &quot;0.0.0.0&quot;, &quot;HostPort&quot;: &quot;32769&quot;}],
        },
    }
    list_mock = MagicMock(return_value=[&quot;bar&quot;, &quot;baz&quot;, &quot;foo&quot;])
    inspect_mock = MagicMock(
        side_effect=lambda x: {&quot;NetworkSettings&quot;: {&quot;Ports&quot;: ports.get(x)}}
    )
    with patch.object(docker_mod, &quot;list_containers&quot;, list_mock), patch.object(
        docker_mod, &quot;inspect_container&quot;, inspect_mock
    ):

        # Test with specific container name
        ret = docker_mod.port(&quot;foo&quot;)
        assert ret == ports[&quot;foo&quot;]

        # Test with specific container name and filtering on port
        ret = docker_mod.port(&quot;foo&quot;, private_port=&quot;5555/tcp&quot;)
        assert ret == {&quot;5555/tcp&quot;: ports[&quot;foo&quot;][&quot;5555/tcp&quot;]}

        # Test using pattern expression
        ret = docker_mod.port(&quot;ba*&quot;)
        assert ret == {&quot;bar&quot;: ports[&quot;bar&quot;], &quot;baz&quot;: ports[&quot;baz&quot;]}
        ret = docker_mod.port(&quot;ba?&quot;)
        assert ret == {&quot;bar&quot;: ports[&quot;bar&quot;], &quot;baz&quot;: ports[&quot;baz&quot;]}
        ret = docker_mod.port(&quot;ba[rz]&quot;)
        assert ret == {&quot;bar&quot;: ports[&quot;bar&quot;], &quot;baz&quot;: ports[&quot;baz&quot;]}

        # Test using pattern expression and port filtering
        ret = docker_mod.port(&quot;ba*&quot;, private_port=&quot;6666/tcp&quot;)
        assert ret == {&quot;bar&quot;: {&quot;6666/tcp&quot;: ports[&quot;bar&quot;][&quot;6666/tcp&quot;]}, &quot;baz&quot;: {}}
        ret = docker_mod.port(&quot;ba?&quot;, private_port=&quot;6666/tcp&quot;)
        assert ret == {&quot;bar&quot;: {&quot;6666/tcp&quot;: ports[&quot;bar&quot;][&quot;6666/tcp&quot;]}, &quot;baz&quot;: {}}
        ret = docker_mod.port(&quot;ba[rz]&quot;, private_port=&quot;6666/tcp&quot;)
        assert ret == {&quot;bar&quot;: {&quot;6666/tcp&quot;: ports[&quot;bar&quot;][&quot;6666/tcp&quot;]}, &quot;baz&quot;: {}}
        ret = docker_mod.port(&quot;*&quot;)
        assert ret == ports
        ret = docker_mod.port(&quot;*&quot;, private_port=&quot;5555/tcp&quot;)
        assert ret == {
            &quot;foo&quot;: {&quot;5555/tcp&quot;: ports[&quot;foo&quot;][&quot;5555/tcp&quot;]},
            &quot;bar&quot;: {&quot;5555/tcp&quot;: ports[&quot;bar&quot;][&quot;5555/tcp&quot;]},
            &quot;baz&quot;: {&quot;5555/tcp&quot;: ports[&quot;baz&quot;][&quot;5555/tcp&quot;]},
        }
        ret = docker_mod.port(&quot;*&quot;, private_port=6666)
        assert ret == {
            &quot;foo&quot;: {&quot;6666/tcp&quot;: ports[&quot;foo&quot;][&quot;6666/tcp&quot;]},
            &quot;bar&quot;: {&quot;6666/tcp&quot;: ports[&quot;bar&quot;][&quot;6666/tcp&quot;]},
            &quot;baz&quot;: {&quot;6666/udp&quot;: ports[&quot;baz&quot;][&quot;6666/udp&quot;]},
        }
        ret = docker_mod.port(&quot;*&quot;, private_port=&quot;6666/tcp&quot;)
        assert ret == {
            &quot;foo&quot;: {&quot;6666/tcp&quot;: ports[&quot;foo&quot;][&quot;6666/tcp&quot;]},
            &quot;bar&quot;: {&quot;6666/tcp&quot;: ports[&quot;bar&quot;][&quot;6666/tcp&quot;]},
            &quot;baz&quot;: {},
        }
</PRE>
</div>
  </div>
</body>
</html>
