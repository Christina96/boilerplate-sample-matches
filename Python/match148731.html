<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for cache_3.py &amp; tomcat_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cache_3.py &amp; tomcat_1.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cache_3.py (2.4390244%)<th>tomcat_1.py (2.3049645%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(8-20)<td><a href="#" name="0">(63-75)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cache_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>import functools
import logging
import os
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import re
import time
import salt.config
import salt.payload
import salt.utils.atomicfile
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.files
import salt.utils.msgpack
from salt.utils.zeromq import zmq
log = logging.getLogger(</b></font>__name__)
class CacheFactory:
    @classmethod
    def factory(cls, backend, ttl, *args, **kwargs):
        log.debug("Factory backend: %s", backend)
        if backend == "memory":
            return CacheDict(ttl, *args, **kwargs)
        elif backend == "disk":
            return CacheDisk(ttl, kwargs["minion_cache_path"], *args, **kwargs)
        else:
            log.error("CacheFactory received unrecognized cache type")
class CacheDict(dict):
    def __init__(self, ttl, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self._ttl = ttl
        self._key_cache_time = {}
    def _enforce_ttl_key(self, key):
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            dict.__delitem__(self, key)
    def __getitem__(self, key):
        self._enforce_ttl_key(key)
        return dict.__getitem__(self, key)
    def __setitem__(self, key, val):
        self._key_cache_time[key] = time.time()
        dict.__setitem__(self, key, val)
    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return dict.__contains__(self, key)
class CacheDisk(CacheDict):
    def __init__(self, ttl, path, *args, **kwargs):
        super().__init__(ttl, *args, **kwargs)
        self._path = path
        self._dict = {}
        self._read()
    def _enforce_ttl_key(self, key):
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            self._dict.__delitem__(key)
    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return self._dict.__contains__(key)
    def __getitem__(self, key):
        self._enforce_ttl_key(key)
        return self._dict.__getitem__(key)
    def __setitem__(self, key, val):
        self._key_cache_time[key] = time.time()
        self._dict.__setitem__(key, val)
        self._write()
    def __delitem__(self, key):
        del self._key_cache_time[key]
        self._dict.__delitem__(key)
        self._write()
    def clear(self):
        self._key_cache_time.clear()
        self._dict.clear()
        self._write()
    def _read(self):
        if not salt.utils.msgpack.HAS_MSGPACK or not os.path.exists(self._path):
            return
        with salt.utils.files.fopen(self._path, "rb") as fp_:
            cache = salt.utils.data.decode(
                salt.utils.msgpack.load(fp_, encoding=__salt_system_encoding__)
            )
        if "CacheDisk_cachetime" in cache:  # new format
            self._dict = cache["CacheDisk_data"]
            self._key_cache_time = cache["CacheDisk_cachetime"]
        else:  # old format
            self._dict = cache
            timestamp = os.path.getmtime(self._path)
            for key in self._dict:
                self._key_cache_time[key] = timestamp
        if log.isEnabledFor(logging.DEBUG):
            log.debug("Disk cache retrieved: %s", cache)
    def _write(self):
        if not salt.utils.msgpack.HAS_MSGPACK:
            return
        with salt.utils.atomicfile.atomic_open(self._path, "wb+") as fp_:
            cache = {
                "CacheDisk_data": self._dict,
                "CacheDisk_cachetime": self._key_cache_time,
            }
            salt.utils.msgpack.dump(cache, fp_, use_bin_type=True)
class CacheCli:
    def __init__(self, opts):
        self.opts = opts
        self.cache_sock = os.path.join(self.opts["sock_dir"], "con_cache.ipc")
        self.cache_upd_sock = os.path.join(self.opts["sock_dir"], "con_upd.ipc")
        context = zmq.Context()
        self.creq_out = context.socket(zmq.REQ)
        self.creq_out.setsockopt(zmq.LINGER, 100)
        self.creq_out.connect("ipc://" + self.cache_sock)
        self.cupd_out = context.socket(zmq.PUB)
        self.cupd_out.setsockopt(zmq.LINGER, 1)
        self.cupd_out.connect("ipc://" + self.cache_upd_sock)
    def put_cache(self, minions):
        self.cupd_out.send(salt.payload.dumps(minions))
    def get_cached(self):
        msg = salt.payload.dumps("minions")
        self.creq_out.send(msg)
        min_list = salt.payload.loads(self.creq_out.recv())
        return min_list
class CacheRegex:
    def __init__(
        self, prepend="", append="", size=1000, keep_fraction=0.8, max_age=3600
    ):
        self.prepend = prepend
        self.append = append
        self.size = size
        self.clear_size = int(size - size * (keep_fraction))
        if self.clear_size &gt;= size:
            self.clear_size = int(size / 2) + 1
            if self.clear_size &gt; size:
                self.clear_size = size
        self.max_age = max_age
        self.cache = {}
        self.timestamp = time.time()
    def clear(self):
        self.cache.clear()
    def sweep(self):
        if self.max_age &lt; time.time() - self.timestamp:
            self.clear()
            self.timestamp = time.time()
        else:
            paterns = list(self.cache.values())
            paterns.sort()
            for idx in range(self.clear_size):
                del self.cache[paterns[idx][2]]
    def get(self, pattern):
        try:
            self.cache[pattern][0] += 1
            return self.cache[pattern][1]
        except KeyError:
            pass
        if len(self.cache) &gt; self.size:
            self.sweep()
        regex = re.compile("{}{}{}".format(self.prepend, pattern, self.append))
        self.cache[pattern] = [1, regex, pattern, time.time()]
        return regex
class ContextCache:
    def __init__(self, opts, name):
        self.opts = opts
        self.cache_path = os.path.join(opts["cachedir"], "context", "{}.p".format(name))
    def cache_context(self, context):
        if not os.path.isdir(os.path.dirname(self.cache_path)):
            os.mkdir(os.path.dirname(self.cache_path))
        with salt.utils.files.fopen(self.cache_path, "w+b") as cache:
            salt.payload.dump(context, cache)
    def get_cache_context(self):
        with salt.utils.files.fopen(self.cache_path, "rb") as cache:
            return salt.utils.data.decode(salt.payload.load(cache))
def context_cache(func):
    @functools.wraps(func)
    def context_cache_wrap(*args, **kwargs):
        try:
            func_context = func.__globals__["__context__"].value()
        except AttributeError:
            func_context = func.__globals__["__context__"]
        try:
            func_opts = func.__globals__["__opts__"].value()
        except AttributeError:
            func_opts = func.__globals__["__opts__"]
        func_name = func.__globals__["__name__"]
        context_cache = ContextCache(func_opts, func_name)
        if not func_context and os.path.isfile(context_cache.cache_path):
            salt.utils.dictupdate.update(
                func_context, context_cache.get_cache_context()
            )
        else:
            context_cache.cache_context(func_context)
        return func(*args, **kwargs)
    return context_cache_wrap
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tomcat_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import glob
import hashlib
import logging
import os
import re
import tempfile
import urllib.parse
import urllib.request
import salt.utils.data
import salt.utils.stringutils
log = logging.getLogger(</b></font>__name__)
__func_alias__ = {"reload_": "reload"}
__valid_configs = {
    "user": ["tomcat-manager.user", "tomcat-manager:user"],
    "passwd": ["tomcat-manager.passwd", "tomcat-manager:passwd"],
}
def __virtual__():
    if __catalina_home() or _auth("dummy"):
        return "tomcat"
    return (
        False,
        "Tomcat execution module not loaded: neither Tomcat installed locally nor"
        " tomcat-manager credentials set in grains/pillar/config.",
    )
def __catalina_home():
    locations = ["/usr/share/tomcat*", "/opt/tomcat"]
    for location in locations:
        folders = glob.glob(location)
        if folders:
            for catalina_home in folders:
                if os.path.isdir(catalina_home + "/bin"):
                    return catalina_home
    return False
def _get_credentials():
    ret = {"user": False, "passwd": False}
    for item in ret:
        for struct in [__opts__, __grains__, __pillar__]:
            for config_key in __valid_configs[item]:
                value = salt.utils.data.traverse_dict_and_list(struct, config_key, None)
                if value:
                    ret[item] = value
                    break
    return ret["user"], ret["passwd"]
def _auth(uri):
    user, password = _get_credentials()
    if user is False or password is False:
        return False
    basic = urllib.request.HTTPBasicAuthHandler()
    basic.add_password(
        realm="Tomcat Manager Application", uri=uri, user=user, passwd=password
    )
    digest = urllib.request.HTTPDigestAuthHandler()
    digest.add_password(
        realm="Tomcat Manager Application", uri=uri, user=user, passwd=password
    )
    return urllib.request.build_opener(basic, digest)
def extract_war_version(war):
    basename = os.path.basename(war)
    war_package = os.path.splitext(basename)[0]  # remove '.war'
    version = re.findall("-([\\d.-]+)$", war_package)  # try semver
    return version[0] if version and len(version) == 1 else None  # default to none
def _wget(cmd, opts=None, url="http://localhost:8080/manager", timeout=180):
    ret = {"res": True, "msg": []}
    auth = _auth(url)
    if auth is False:
        ret["res"] = False
        ret["msg"] = "missing username and password settings (grain/pillar)"
        return ret
    if url[-1] != "/":
        url += "/"
    url6 = url
    url += "text/{}".format(cmd)
    url6 += "{}".format(cmd)
    if opts:
        url += "?{}".format(urllib.parse.urlencode(opts))
        url6 += "?{}".format(urllib.parse.urlencode(opts))
    urllib.request.install_opener(auth)
    try:
        ret["msg"] = urllib.request.urlopen(url, timeout=timeout).read().splitlines()
    except Exception:  # pylint: disable=broad-except
        try:
            ret["msg"] = (
                urllib.request.urlopen(url6, timeout=timeout).read().splitlines()
            )
        except Exception:  # pylint: disable=broad-except
            ret["msg"] = "Failed to create HTTP request"
    for key, value in enumerate(ret["msg"]):
        try:
            ret["msg"][key] = salt.utils.stringutils.to_unicode(value, "utf-8")
        except (UnicodeDecodeError, AttributeError):
            pass
    if not ret["msg"][0].startswith("OK"):
        ret["res"] = False
    return ret
def _simple_cmd(cmd, app, url="http://localhost:8080/manager", timeout=180):
    try:
        opts = {"path": app, "version": ls(url)[app]["version"]}
        return "\n".join(_wget(cmd, opts, url, timeout=timeout)["msg"])
    except Exception:  # pylint: disable=broad-except
        return "FAIL - No context exists for path {}".format(app)
def leaks(url="http://localhost:8080/manager", timeout=180):
    return _wget("findleaks", {"statusLine": "true"}, url, timeout=timeout)["msg"]
def status(url="http://localhost:8080/manager", timeout=180):
    return _wget("list", {}, url, timeout=timeout)["res"]
def ls(url="http://localhost:8080/manager", timeout=180):
    ret = {}
    data = _wget("list", "", url, timeout=timeout)
    if data["res"] is False:
        return {}
    data["msg"].pop(0)
    for line in data["msg"]:
        tmp = line.split(":")
        ret[tmp[0]] = {
            "mode": tmp[1],
            "sessions": tmp[2],
            "fullname": tmp[3],
            "version": "",
        }
        sliced = tmp[3].split("##")
        if len(sliced) &gt; 1:
            ret[tmp[0]]["version"] = sliced[1]
    return ret
def stop(app, url="http://localhost:8080/manager", timeout=180):
    return _simple_cmd("stop", app, url, timeout=timeout)
def start(app, url="http://localhost:8080/manager", timeout=180):
    return _simple_cmd("start", app, url, timeout=timeout)
def reload_(app, url="http://localhost:8080/manager", timeout=180):
    return _simple_cmd("reload", app, url, timeout=timeout)
def sessions(app, url="http://localhost:8080/manager", timeout=180):
    return _simple_cmd("sessions", app, url, timeout=timeout)
def status_webapp(app, url="http://localhost:8080/manager", timeout=180):
    webapps = ls(url, timeout=timeout)
    for i in webapps:
        if i == app:
            return webapps[i]["mode"]
    return "missing"
def serverinfo(url="http://localhost:8080/manager", timeout=180):
    data = _wget("serverinfo", {}, url, timeout=timeout)
    if data["res"] is False:
        return {"error": data["msg"]}
    ret = {}
    data["msg"].pop(0)
    for line in data["msg"]:
        tmp = line.split(":")
        ret[tmp[0].strip()] = tmp[1].strip()
    return ret
def undeploy(app, url="http://localhost:8080/manager", timeout=180):
    return _simple_cmd("undeploy", app, url, timeout=timeout)
def deploy_war(
    war,
    context,
    force="no",
    url="http://localhost:8080/manager",
    saltenv="base",
    timeout=180,
    temp_war_location=None,
    version=True,
):
    tfile = "salt.{}".format(os.path.basename(war))
    if temp_war_location is not None:
        if not os.path.isdir(temp_war_location):
            return 'Error - "{}" is not a directory'.format(temp_war_location)
        tfile = os.path.join(temp_war_location, tfile)
    else:
        tfile = os.path.join(tempfile.gettempdir(), tfile)
    cache = False
    if not os.path.isfile(war):
        cache = True
        cached = __salt__["cp.get_url"](war, tfile, saltenv)
        if not cached:
            return "FAIL - could not cache the WAR file"
        try:
            __salt__["file.set_mode"](cached, "0644")
        except KeyError:
            pass
    else:
        tfile = war
    opts = {
        "war": "file:{}".format(tfile),
        "path": context,
    }
    if version:
        version = extract_war_version(war) if version is True else version
        if isinstance(version, str):
            opts["version"] = version
    if force == "yes":
        opts["update"] = "true"
    deployed = _wget("deploy", opts, url, timeout=timeout)
    res = "\n".join(deployed["msg"])
    if cache:
        __salt__["file.remove"](tfile)
    return res
def passwd(passwd, user="", alg="sha1", realm=None):
    digest = hasattr(hashlib, alg) and getattr(hashlib, alg) or None
    if digest:
        if realm:
            digest.update(
                "{}:{}:{}".format(
                    user,
                    realm,
                    passwd,
                )
            )
        else:
            digest.update(passwd)
    return digest and digest.hexdigest() or False
def version():
    cmd = __catalina_home() + "/bin/catalina.sh version"
    out = __salt__["cmd.run"](cmd).splitlines()
    for line in out:
        if not line:
            continue
        if "Server version" in line:
            comps = line.split(": ")
            return comps[1]
def fullversion():
    cmd = __catalina_home() + "/bin/catalina.sh version"
    ret = {}
    out = __salt__["cmd.run"](cmd).splitlines()
    for line in out:
        if not line:
            continue
        if ": " in line:
            comps = line.split(": ")
            ret[comps[0]] = comps[1].lstrip()
    return ret
def signal(signal=None):
    valid_signals = {
        "forcestop": "stop -force",
        "securestart": "start -security",
        "start": "start",
        "stop": "stop",
    }
    if signal not in valid_signals:
        return
    cmd = "{}/bin/catalina.sh {}".format(__catalina_home(), valid_signals[signal])
    __salt__["cmd.run"](cmd)
if __name__ == "__main__":
    __opts__ = {}
    __grains__ = {}
    __pillar__ = {
        "tomcat-manager.user": "foobar",
        "tomcat-manager.passwd": "barfoo1!",
    }
    old_format_creds = _get_credentials()
    __pillar__ = {"tomcat-manager": {"user": "foobar", "passwd": "barfoo1!"}}
    new_format_creds = _get_credentials()
    if old_format_creds == new_format_creds:
        log.info("Config backwards compatible")
    else:
        log.ifno("Config not backwards compatible")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
