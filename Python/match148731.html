<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for cache_3.py & tomcat_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for cache_3.py & tomcat_1.py
      </h3>
      <h1 align="center">
        2.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>cache_3.py (2.4390244%)<TH>tomcat_1.py (2.3049645%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match148731-0.html#0',2,'match148731-1.html#0',3)" NAME="0">(8-20)<TD><A HREF="javascript:ZweiFrames('match148731-0.html#0',2,'match148731-1.html#0',3)" NAME="0">(63-75)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cache_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
In-memory caching used by Salt
&quot;&quot;&quot;

<A NAME="0"></A>import functools
import logging
import os
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match148731-1.html#0',3,'match148731-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import re
import time

import salt.config
import salt.payload
import salt.utils.atomicfile
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.files
import salt.utils.msgpack
from salt.utils.zeromq import zmq

log = logging.getLogger(</B></FONT>__name__)


class CacheFactory:
    &quot;&quot;&quot;
    Cache which can use a number of backends
    &quot;&quot;&quot;

    @classmethod
    def factory(cls, backend, ttl, *args, **kwargs):
        log.debug(&quot;Factory backend: %s&quot;, backend)
        if backend == &quot;memory&quot;:
            return CacheDict(ttl, *args, **kwargs)
        elif backend == &quot;disk&quot;:
            return CacheDisk(ttl, kwargs[&quot;minion_cache_path&quot;], *args, **kwargs)
        else:
            log.error(&quot;CacheFactory received unrecognized cache type&quot;)


class CacheDict(dict):
    &quot;&quot;&quot;
    Subclass of dict that will lazily delete items past ttl
    &quot;&quot;&quot;

    def __init__(self, ttl, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self._ttl = ttl
        self._key_cache_time = {}

    def _enforce_ttl_key(self, key):
        &quot;&quot;&quot;
        Enforce the TTL to a specific key, delete if its past TTL
        &quot;&quot;&quot;
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            dict.__delitem__(self, key)

    def __getitem__(self, key):
        &quot;&quot;&quot;
        Check if the key is ttld out, then do the get
        &quot;&quot;&quot;
        self._enforce_ttl_key(key)
        return dict.__getitem__(self, key)

    def __setitem__(self, key, val):
        &quot;&quot;&quot;
        Make sure to update the key cache time
        &quot;&quot;&quot;
        self._key_cache_time[key] = time.time()
        dict.__setitem__(self, key, val)

    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return dict.__contains__(self, key)


class CacheDisk(CacheDict):
    &quot;&quot;&quot;
    Class that represents itself as a dictionary to a consumer
    but uses a disk-based backend. Serialization and de-serialization
    is done with msgpack
    &quot;&quot;&quot;

    def __init__(self, ttl, path, *args, **kwargs):
        super().__init__(ttl, *args, **kwargs)
        self._path = path
        self._dict = {}
        self._read()

    def _enforce_ttl_key(self, key):
        &quot;&quot;&quot;
        Enforce the TTL to a specific key, delete if its past TTL
        &quot;&quot;&quot;
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            self._dict.__delitem__(key)

    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return self._dict.__contains__(key)

    def __getitem__(self, key):
        &quot;&quot;&quot;
        Check if the key is ttld out, then do the get
        &quot;&quot;&quot;
        self._enforce_ttl_key(key)
        return self._dict.__getitem__(key)

    def __setitem__(self, key, val):
        &quot;&quot;&quot;
        Make sure to update the key cache time
        &quot;&quot;&quot;
        self._key_cache_time[key] = time.time()
        self._dict.__setitem__(key, val)
        # Do the same as the parent but also persist
        self._write()

    def __delitem__(self, key):
        &quot;&quot;&quot;
        Make sure to remove the key cache time
        &quot;&quot;&quot;
        del self._key_cache_time[key]
        self._dict.__delitem__(key)
        # Do the same as the parent but also persist
        self._write()

    def clear(self):
        &quot;&quot;&quot;
        Clear the cache
        &quot;&quot;&quot;
        self._key_cache_time.clear()
        self._dict.clear()
        # Do the same as the parent but also persist
        self._write()

    def _read(self):
        &quot;&quot;&quot;
        Read in from disk
        &quot;&quot;&quot;
        if not salt.utils.msgpack.HAS_MSGPACK or not os.path.exists(self._path):
            return
        with salt.utils.files.fopen(self._path, &quot;rb&quot;) as fp_:
            cache = salt.utils.data.decode(
                salt.utils.msgpack.load(fp_, encoding=__salt_system_encoding__)
            )
        if &quot;CacheDisk_cachetime&quot; in cache:  # new format
            self._dict = cache[&quot;CacheDisk_data&quot;]
            self._key_cache_time = cache[&quot;CacheDisk_cachetime&quot;]
        else:  # old format
            self._dict = cache
            timestamp = os.path.getmtime(self._path)
            for key in self._dict:
                self._key_cache_time[key] = timestamp
        if log.isEnabledFor(logging.DEBUG):
            log.debug(&quot;Disk cache retrieved: %s&quot;, cache)

    def _write(self):
        &quot;&quot;&quot;
        Write out to disk
        &quot;&quot;&quot;
        if not salt.utils.msgpack.HAS_MSGPACK:
            return
        # TODO Add check into preflight to ensure dir exists
        # TODO Dir hashing?
        with salt.utils.atomicfile.atomic_open(self._path, &quot;wb+&quot;) as fp_:
            cache = {
                &quot;CacheDisk_data&quot;: self._dict,
                &quot;CacheDisk_cachetime&quot;: self._key_cache_time,
            }
            salt.utils.msgpack.dump(cache, fp_, use_bin_type=True)


class CacheCli:
    &quot;&quot;&quot;
    Connection client for the ConCache. Should be used by all
    components that need the list of currently connected minions
    &quot;&quot;&quot;

    def __init__(self, opts):
        &quot;&quot;&quot;
        Sets up the zmq-connection to the ConCache
        &quot;&quot;&quot;
        self.opts = opts
        self.cache_sock = os.path.join(self.opts[&quot;sock_dir&quot;], &quot;con_cache.ipc&quot;)
        self.cache_upd_sock = os.path.join(self.opts[&quot;sock_dir&quot;], &quot;con_upd.ipc&quot;)

        context = zmq.Context()

        # the socket for talking to the cache
        self.creq_out = context.socket(zmq.REQ)
        self.creq_out.setsockopt(zmq.LINGER, 100)
        self.creq_out.connect(&quot;ipc://&quot; + self.cache_sock)

        # the socket for sending updates to the cache
        self.cupd_out = context.socket(zmq.PUB)
        self.cupd_out.setsockopt(zmq.LINGER, 1)
        self.cupd_out.connect(&quot;ipc://&quot; + self.cache_upd_sock)

    def put_cache(self, minions):
        &quot;&quot;&quot;
        published the given minions to the ConCache
        &quot;&quot;&quot;
        self.cupd_out.send(salt.payload.dumps(minions))

    def get_cached(self):
        &quot;&quot;&quot;
        queries the ConCache for a list of currently connected minions
        &quot;&quot;&quot;
        msg = salt.payload.dumps(&quot;minions&quot;)
        self.creq_out.send(msg)
        min_list = salt.payload.loads(self.creq_out.recv())
        return min_list


class CacheRegex:
    &quot;&quot;&quot;
    Create a regular expression object cache for the most frequently
    used patterns to minimize compilation of the same patterns over
    and over again
    &quot;&quot;&quot;

    def __init__(
        self, prepend=&quot;&quot;, append=&quot;&quot;, size=1000, keep_fraction=0.8, max_age=3600
    ):
        self.prepend = prepend
        self.append = append
        self.size = size
        self.clear_size = int(size - size * (keep_fraction))
        if self.clear_size &gt;= size:
            self.clear_size = int(size / 2) + 1
            if self.clear_size &gt; size:
                self.clear_size = size
        self.max_age = max_age
        self.cache = {}
        self.timestamp = time.time()

    def clear(self):
        &quot;&quot;&quot;
        Clear the cache
        &quot;&quot;&quot;
        self.cache.clear()

    def sweep(self):
        &quot;&quot;&quot;
        Sweep the cache and remove the outdated or least frequently
        used entries
        &quot;&quot;&quot;
        if self.max_age &lt; time.time() - self.timestamp:
            self.clear()
            self.timestamp = time.time()
        else:
            paterns = list(self.cache.values())
            paterns.sort()
            for idx in range(self.clear_size):
                del self.cache[paterns[idx][2]]

    def get(self, pattern):
        &quot;&quot;&quot;
        Get a compiled regular expression object based on pattern and
        cache it when it is not in the cache already
        &quot;&quot;&quot;
        try:
            self.cache[pattern][0] += 1
            return self.cache[pattern][1]
        except KeyError:
            pass
        if len(self.cache) &gt; self.size:
            self.sweep()
        regex = re.compile(&quot;{}{}{}&quot;.format(self.prepend, pattern, self.append))
        self.cache[pattern] = [1, regex, pattern, time.time()]
        return regex


class ContextCache:
    def __init__(self, opts, name):
        &quot;&quot;&quot;
        Create a context cache
        &quot;&quot;&quot;
        self.opts = opts
        self.cache_path = os.path.join(opts[&quot;cachedir&quot;], &quot;context&quot;, &quot;{}.p&quot;.format(name))

    def cache_context(self, context):
        &quot;&quot;&quot;
        Cache the given context to disk
        &quot;&quot;&quot;
        if not os.path.isdir(os.path.dirname(self.cache_path)):
            os.mkdir(os.path.dirname(self.cache_path))
        with salt.utils.files.fopen(self.cache_path, &quot;w+b&quot;) as cache:
            salt.payload.dump(context, cache)

    def get_cache_context(self):
        &quot;&quot;&quot;
        Retrieve a context cache from disk
        &quot;&quot;&quot;
        with salt.utils.files.fopen(self.cache_path, &quot;rb&quot;) as cache:
            return salt.utils.data.decode(salt.payload.load(cache))


def context_cache(func):
    &quot;&quot;&quot;
    A decorator to be used module functions which need to cache their
    context.

    To evaluate a __context__ and re-hydrate it if a given key
    is empty or contains no items, pass a list of keys to evaulate.
    &quot;&quot;&quot;

    @functools.wraps(func)
    def context_cache_wrap(*args, **kwargs):
        try:
            func_context = func.__globals__[&quot;__context__&quot;].value()
        except AttributeError:
            func_context = func.__globals__[&quot;__context__&quot;]
        try:
            func_opts = func.__globals__[&quot;__opts__&quot;].value()
        except AttributeError:
            func_opts = func.__globals__[&quot;__opts__&quot;]
        func_name = func.__globals__[&quot;__name__&quot;]

        context_cache = ContextCache(func_opts, func_name)
        if not func_context and os.path.isfile(context_cache.cache_path):
            salt.utils.dictupdate.update(
                func_context, context_cache.get_cache_context()
            )
        else:
            context_cache.cache_context(func_context)
        return func(*args, **kwargs)

    return context_cache_wrap
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tomcat_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Support for Tomcat

This module uses the manager webapp to manage Apache tomcat webapps.
If the manager webapp is not configured some of the functions won't work.

:configuration:
    - Java bin path should be in default path
    - If ipv6 is enabled make sure you permit manager access to ipv6 interface
      &quot;0:0:0:0:0:0:0:1&quot;
    - If you are using tomcat.tar.gz it has to be installed or symlinked under
      ``/opt``, preferably using name tomcat
    - &quot;tomcat.signal start/stop&quot; works but it does not use the startup scripts

The following grains/pillar should be set:

.. code-block:: yaml

    tomcat-manager:
      user: &lt;username&gt;
      passwd: &lt;password&gt;

or the old format:

.. code-block:: yaml

    tomcat-manager.user: &lt;username&gt;
    tomcat-manager.passwd: &lt;password&gt;

Also configure a user in the conf/tomcat-users.xml file:

.. code-block:: xml

    &lt;?xml version='1.0' encoding='utf-8'?&gt;
    &lt;tomcat-users&gt;
        &lt;role rolename=&quot;manager-script&quot;/&gt;
        &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-script&quot;/&gt;
    &lt;/tomcat-users&gt;

.. note::

   - More information about tomcat manager:
     http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html
   - if you use only this module for deployments you've might want to strict
     access to the manager only from localhost for more info:
     http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html#Configuring_Manager_Application_Access
   - Tested on:

     JVM Vendor:
         Sun Microsystems Inc.
     JVM Version:
         1.6.0_43-b01
     OS Architecture:
         amd64
     OS Name:
         Linux
     OS Version:
         2.6.32-358.el6.x86_64
     Tomcat Version:
<A NAME="0"></A>         Apache Tomcat/7.0.37
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match148731-0.html#0',2,'match148731-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import glob
import hashlib
import logging
import os
import re
import tempfile
import urllib.parse
import urllib.request

import salt.utils.data
import salt.utils.stringutils

log = logging.getLogger(</B></FONT>__name__)

__func_alias__ = {&quot;reload_&quot;: &quot;reload&quot;}

# Support old-style grains/pillar
# config as well as new.
__valid_configs = {
    &quot;user&quot;: [&quot;tomcat-manager.user&quot;, &quot;tomcat-manager:user&quot;],
    &quot;passwd&quot;: [&quot;tomcat-manager.passwd&quot;, &quot;tomcat-manager:passwd&quot;],
}


def __virtual__():
    &quot;&quot;&quot;
    Only load tomcat if it is installed or if grains/pillar config exists
    &quot;&quot;&quot;
    if __catalina_home() or _auth(&quot;dummy&quot;):
        return &quot;tomcat&quot;
    return (
        False,
        &quot;Tomcat execution module not loaded: neither Tomcat installed locally nor&quot;
        &quot; tomcat-manager credentials set in grains/pillar/config.&quot;,
    )


def __catalina_home():
    &quot;&quot;&quot;
    Tomcat paths differ depending on packaging
    &quot;&quot;&quot;
    locations = [&quot;/usr/share/tomcat*&quot;, &quot;/opt/tomcat&quot;]
    for location in locations:
        folders = glob.glob(location)
        if folders:
            for catalina_home in folders:
                if os.path.isdir(catalina_home + &quot;/bin&quot;):
                    return catalina_home
    return False


def _get_credentials():
    &quot;&quot;&quot;
    Get the username and password from opts, grains, or pillar
    &quot;&quot;&quot;
    ret = {&quot;user&quot;: False, &quot;passwd&quot;: False}

    # Loop through opts, grains, and pillar
    # Return the first acceptable configuration found
    for item in ret:
        for struct in [__opts__, __grains__, __pillar__]:
            # Look for the config key
            # Support old-style config format and new
            for config_key in __valid_configs[item]:
                value = salt.utils.data.traverse_dict_and_list(struct, config_key, None)
                if value:
                    ret[item] = value
                    break
    return ret[&quot;user&quot;], ret[&quot;passwd&quot;]


def _auth(uri):
    &quot;&quot;&quot;
    returns a authentication handler.
    Get user &amp; password from grains, if are not set default to
    modules.config.option

    If user &amp; pass are missing return False
    &quot;&quot;&quot;

    user, password = _get_credentials()
    if user is False or password is False:
        return False

    basic = urllib.request.HTTPBasicAuthHandler()
    basic.add_password(
        realm=&quot;Tomcat Manager Application&quot;, uri=uri, user=user, passwd=password
    )
    digest = urllib.request.HTTPDigestAuthHandler()
    digest.add_password(
        realm=&quot;Tomcat Manager Application&quot;, uri=uri, user=user, passwd=password
    )
    return urllib.request.build_opener(basic, digest)


def extract_war_version(war):
    &quot;&quot;&quot;
    Extract the version from the war file name. There does not seem to be a
    standard for encoding the version into the `war file name`_

    .. _`war file name`: https://tomcat.apache.org/tomcat-6.0-doc/deployer-howto.html

    Examples:

    .. code-block:: bash

        /path/salt-2015.8.6.war -&gt; 2015.8.6
        /path/V6R2013xD5.war -&gt; None
    &quot;&quot;&quot;
    basename = os.path.basename(war)
    war_package = os.path.splitext(basename)[0]  # remove '.war'
    version = re.findall(&quot;-([\\d.-]+)$&quot;, war_package)  # try semver
    return version[0] if version and len(version) == 1 else None  # default to none


def _wget(cmd, opts=None, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    A private function used to issue the command to tomcat via the manager
    webapp

    cmd
        the command to execute

    url
        The URL of the server manager webapp (example:
        http://localhost:8080/manager)

    opts
        a dict of arguments

    timeout
        timeout for HTTP request

    Return value is a dict in the from of::

        {
            res: [True|False]
            msg: list of lines we got back from the manager
        }
    &quot;&quot;&quot;

    ret = {&quot;res&quot;: True, &quot;msg&quot;: []}

    # prepare authentication
    auth = _auth(url)
    if auth is False:
        ret[&quot;res&quot;] = False
        ret[&quot;msg&quot;] = &quot;missing username and password settings (grain/pillar)&quot;
        return ret

    # prepare URL
    if url[-1] != &quot;/&quot;:
        url += &quot;/&quot;
    url6 = url
    url += &quot;text/{}&quot;.format(cmd)
    url6 += &quot;{}&quot;.format(cmd)
    if opts:
        url += &quot;?{}&quot;.format(urllib.parse.urlencode(opts))
        url6 += &quot;?{}&quot;.format(urllib.parse.urlencode(opts))

    # Make the HTTP request
    urllib.request.install_opener(auth)

    try:
        # Trying tomcat &gt;= 7 url
        ret[&quot;msg&quot;] = urllib.request.urlopen(url, timeout=timeout).read().splitlines()
    except Exception:  # pylint: disable=broad-except
        try:
            # Trying tomcat6 url
            ret[&quot;msg&quot;] = (
                urllib.request.urlopen(url6, timeout=timeout).read().splitlines()
            )
        except Exception:  # pylint: disable=broad-except
            ret[&quot;msg&quot;] = &quot;Failed to create HTTP request&quot;

    # Force all byte strings to utf-8 strings, for python &gt;= 3.4
    for key, value in enumerate(ret[&quot;msg&quot;]):
        try:
            ret[&quot;msg&quot;][key] = salt.utils.stringutils.to_unicode(value, &quot;utf-8&quot;)
        except (UnicodeDecodeError, AttributeError):
            pass

    if not ret[&quot;msg&quot;][0].startswith(&quot;OK&quot;):
        ret[&quot;res&quot;] = False

    return ret


def _simple_cmd(cmd, app, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    Simple command wrapper to commands that need only a path option
    &quot;&quot;&quot;

    try:
        opts = {&quot;path&quot;: app, &quot;version&quot;: ls(url)[app][&quot;version&quot;]}
        return &quot;\n&quot;.join(_wget(cmd, opts, url, timeout=timeout)[&quot;msg&quot;])
    except Exception:  # pylint: disable=broad-except
        return &quot;FAIL - No context exists for path {}&quot;.format(app)


# Functions
def leaks(url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    Find memory leaks in tomcat

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.leaks
    &quot;&quot;&quot;

    return _wget(&quot;findleaks&quot;, {&quot;statusLine&quot;: &quot;true&quot;}, url, timeout=timeout)[&quot;msg&quot;]


def status(url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    Used to test if the tomcat manager is up

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.status
        salt '*' tomcat.status http://localhost:8080/manager
    &quot;&quot;&quot;

    return _wget(&quot;list&quot;, {}, url, timeout=timeout)[&quot;res&quot;]


def ls(url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    list all the deployed webapps

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.ls
        salt '*' tomcat.ls http://localhost:8080/manager
    &quot;&quot;&quot;

    ret = {}
    data = _wget(&quot;list&quot;, &quot;&quot;, url, timeout=timeout)
    if data[&quot;res&quot;] is False:
        return {}
    data[&quot;msg&quot;].pop(0)
    for line in data[&quot;msg&quot;]:
        tmp = line.split(&quot;:&quot;)
        ret[tmp[0]] = {
            &quot;mode&quot;: tmp[1],
            &quot;sessions&quot;: tmp[2],
            &quot;fullname&quot;: tmp[3],
            &quot;version&quot;: &quot;&quot;,
        }
        sliced = tmp[3].split(&quot;##&quot;)
        if len(sliced) &gt; 1:
            ret[tmp[0]][&quot;version&quot;] = sliced[1]

    return ret


def stop(app, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    Stop the webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.stop /jenkins
        salt '*' tomcat.stop /jenkins http://localhost:8080/manager
    &quot;&quot;&quot;

    return _simple_cmd(&quot;stop&quot;, app, url, timeout=timeout)


def start(app, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    Start the webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.start /jenkins
        salt '*' tomcat.start /jenkins http://localhost:8080/manager
    &quot;&quot;&quot;

    return _simple_cmd(&quot;start&quot;, app, url, timeout=timeout)


def reload_(app, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    Reload the webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.reload /jenkins
        salt '*' tomcat.reload /jenkins http://localhost:8080/manager
    &quot;&quot;&quot;

    return _simple_cmd(&quot;reload&quot;, app, url, timeout=timeout)


def sessions(app, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    return the status of the webapp sessions

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.sessions /jenkins
        salt '*' tomcat.sessions /jenkins http://localhost:8080/manager
    &quot;&quot;&quot;

    return _simple_cmd(&quot;sessions&quot;, app, url, timeout=timeout)


def status_webapp(app, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    return the status of the webapp (stopped | running | missing)

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.status_webapp /jenkins
        salt '*' tomcat.status_webapp /jenkins http://localhost:8080/manager
    &quot;&quot;&quot;

    webapps = ls(url, timeout=timeout)
    for i in webapps:
        if i == app:
            return webapps[i][&quot;mode&quot;]

    return &quot;missing&quot;


def serverinfo(url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    return details about the server

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.serverinfo
        salt '*' tomcat.serverinfo http://localhost:8080/manager
    &quot;&quot;&quot;

    data = _wget(&quot;serverinfo&quot;, {}, url, timeout=timeout)
    if data[&quot;res&quot;] is False:
        return {&quot;error&quot;: data[&quot;msg&quot;]}

    ret = {}
    data[&quot;msg&quot;].pop(0)
    for line in data[&quot;msg&quot;]:
        tmp = line.split(&quot;:&quot;)
        ret[tmp[0].strip()] = tmp[1].strip()

    return ret


def undeploy(app, url=&quot;http://localhost:8080/manager&quot;, timeout=180):
    &quot;&quot;&quot;
    Undeploy a webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.undeploy /jenkins
        salt '*' tomcat.undeploy /jenkins http://localhost:8080/manager
    &quot;&quot;&quot;

    return _simple_cmd(&quot;undeploy&quot;, app, url, timeout=timeout)


def deploy_war(
    war,
    context,
    force=&quot;no&quot;,
    url=&quot;http://localhost:8080/manager&quot;,
    saltenv=&quot;base&quot;,
    timeout=180,
    temp_war_location=None,
    version=True,
):
    &quot;&quot;&quot;
    Deploy a WAR file

    war
        absolute path to WAR file (should be accessible by the user running
        tomcat) or a path supported by the salt.modules.cp.get_file function
    context
        the context path to deploy
    force : False
        set True to deploy the webapp even one is deployed in the context
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    saltenv : base
        the environment for WAR file in used by salt.modules.cp.get_url
        function
    timeout : 180
        timeout for HTTP request
    temp_war_location : None
        use another location to temporarily copy to war file
        by default the system's temp directory is used
    version : ''
        Specify the war version.  If this argument is provided, it overrides
        the version encoded in the war file name, if one is present.

        Examples:

        .. code-block:: bash

            salt '*' tomcat.deploy_war salt://salt-2015.8.6.war version=2015.08.r6

        .. versionadded:: 2015.8.6

    CLI Examples:

    cp module

    .. code-block:: bash

        salt '*' tomcat.deploy_war salt://application.war /api
        salt '*' tomcat.deploy_war salt://application.war /api no
        salt '*' tomcat.deploy_war salt://application.war /api yes http://localhost:8080/manager

    minion local file system

    .. code-block:: bash

        salt '*' tomcat.deploy_war /tmp/application.war /api
        salt '*' tomcat.deploy_war /tmp/application.war /api no
        salt '*' tomcat.deploy_war /tmp/application.war /api yes http://localhost:8080/manager
    &quot;&quot;&quot;
    # Decide the location to copy the war for the deployment
    tfile = &quot;salt.{}&quot;.format(os.path.basename(war))
    if temp_war_location is not None:
        if not os.path.isdir(temp_war_location):
            return 'Error - &quot;{}&quot; is not a directory'.format(temp_war_location)
        tfile = os.path.join(temp_war_location, tfile)
    else:
        tfile = os.path.join(tempfile.gettempdir(), tfile)

    # Copy file name if needed
    cache = False
    if not os.path.isfile(war):
        cache = True
        cached = __salt__[&quot;cp.get_url&quot;](war, tfile, saltenv)
        if not cached:
            return &quot;FAIL - could not cache the WAR file&quot;
        try:
            __salt__[&quot;file.set_mode&quot;](cached, &quot;0644&quot;)
        except KeyError:
            pass
    else:
        tfile = war

    # Prepare options
    opts = {
        &quot;war&quot;: &quot;file:{}&quot;.format(tfile),
        &quot;path&quot;: context,
    }

    # If parallel versions are desired or not disabled
    if version:
        # Set it to defined version or attempt extract
        version = extract_war_version(war) if version is True else version

        if isinstance(version, str):
            # Only pass version to Tomcat if not undefined
            opts[&quot;version&quot;] = version

    if force == &quot;yes&quot;:
        opts[&quot;update&quot;] = &quot;true&quot;

    # Deploy
    deployed = _wget(&quot;deploy&quot;, opts, url, timeout=timeout)
    res = &quot;\n&quot;.join(deployed[&quot;msg&quot;])

    # Cleanup
    if cache:
        __salt__[&quot;file.remove&quot;](tfile)

    return res


def passwd(passwd, user=&quot;&quot;, alg=&quot;sha1&quot;, realm=None):
    &quot;&quot;&quot;
    This function replaces the $CATALINA_HOME/bin/digest.sh script
    convert a clear-text password to the $CATALINA_BASE/conf/tomcat-users.xml
    format

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.passwd secret
        salt '*' tomcat.passwd secret tomcat sha1
        salt '*' tomcat.passwd secret tomcat sha1 'Protected Realm'
    &quot;&quot;&quot;
    # Shouldn't it be SHA265 instead of SHA1?
    digest = hasattr(hashlib, alg) and getattr(hashlib, alg) or None
    if digest:
        if realm:
            digest.update(
                &quot;{}:{}:{}&quot;.format(
                    user,
                    realm,
                    passwd,
                )
            )
        else:
            digest.update(passwd)

    return digest and digest.hexdigest() or False


# Non-Manager functions
def version():
    &quot;&quot;&quot;
    Return server version from catalina.sh version

    CLI Example:

    .. code-block:: bash

        salt '*' tomcat.version
    &quot;&quot;&quot;
    cmd = __catalina_home() + &quot;/bin/catalina.sh version&quot;
    out = __salt__[&quot;cmd.run&quot;](cmd).splitlines()
    for line in out:
        if not line:
            continue
        if &quot;Server version&quot; in line:
            comps = line.split(&quot;: &quot;)
            return comps[1]


def fullversion():
    &quot;&quot;&quot;
    Return all server information from catalina.sh version

    CLI Example:

    .. code-block:: bash

        salt '*' tomcat.fullversion
    &quot;&quot;&quot;
    cmd = __catalina_home() + &quot;/bin/catalina.sh version&quot;
    ret = {}
    out = __salt__[&quot;cmd.run&quot;](cmd).splitlines()
    for line in out:
        if not line:
            continue
        if &quot;: &quot; in line:
            comps = line.split(&quot;: &quot;)
            ret[comps[0]] = comps[1].lstrip()
    return ret


def signal(signal=None):
    &quot;&quot;&quot;
    Signals catalina to start, stop, securestart, forcestop.

    CLI Example:

    .. code-block:: bash

        salt '*' tomcat.signal start
    &quot;&quot;&quot;
    valid_signals = {
        &quot;forcestop&quot;: &quot;stop -force&quot;,
        &quot;securestart&quot;: &quot;start -security&quot;,
        &quot;start&quot;: &quot;start&quot;,
        &quot;stop&quot;: &quot;stop&quot;,
    }

    if signal not in valid_signals:
        return

    cmd = &quot;{}/bin/catalina.sh {}&quot;.format(__catalina_home(), valid_signals[signal])
    __salt__[&quot;cmd.run&quot;](cmd)


if __name__ == &quot;__main__&quot;:
    # Allow testing from the CLI
    __opts__ = {}
    __grains__ = {}
    __pillar__ = {
        &quot;tomcat-manager.user&quot;: &quot;foobar&quot;,
        &quot;tomcat-manager.passwd&quot;: &quot;barfoo1!&quot;,
    }

    old_format_creds = _get_credentials()

    __pillar__ = {&quot;tomcat-manager&quot;: {&quot;user&quot;: &quot;foobar&quot;, &quot;passwd&quot;: &quot;barfoo1!&quot;}}

    new_format_creds = _get_credentials()

    if old_format_creds == new_format_creds:
        log.info(&quot;Config backwards compatible&quot;)
    else:
        log.ifno(&quot;Config not backwards compatible&quot;)
</PRE>
</div>
  </div>
</body>
</html>
