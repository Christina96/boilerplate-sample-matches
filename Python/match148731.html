<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for cache_3.py &amp; tomcat_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cache_3.py &amp; tomcat_1.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cache_3.py (2.4390244%)<th>tomcat_1.py (2.3049645%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(8-20)<td><a href="#" name="0">(63-75)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cache_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import re
4 import time
5 import salt.config
6 import salt.payload
7 import salt.utils.atomicfile
8 import salt.utils.data
9 import salt.utils.dictupdate
10 import salt.utils.files
11 import salt.utils.msgpack
12 from salt.utils.zeromq import zmq
13 log = logging.getLogger(</b></font>__name__)
14 class CacheFactory:
15     @classmethod
16     def factory(cls, backend, ttl, *args, **kwargs):
17         log.debug("Factory backend: %s", backend)
18         if backend == "memory":
19             return CacheDict(ttl, *args, **kwargs)
20         elif backend == "disk":
21             return CacheDisk(ttl, kwargs["minion_cache_path"], *args, **kwargs)
22         else:
23             log.error("CacheFactory received unrecognized cache type")
24 class CacheDict(dict):
25     def __init__(self, ttl, *args, **kwargs):
26         dict.__init__(self, *args, **kwargs)
27         self._ttl = ttl
28         self._key_cache_time = {}
29     def _enforce_ttl_key(self, key):
30         if key not in self._key_cache_time:
31             return
32         if time.time() - self._key_cache_time[key] &gt; self._ttl:
33             del self._key_cache_time[key]
34             dict.__delitem__(self, key)
35     def __getitem__(self, key):
36         self._enforce_ttl_key(key)
37         return dict.__getitem__(self, key)
38     def __setitem__(self, key, val):
39         self._key_cache_time[key] = time.time()
40         dict.__setitem__(self, key, val)
41     def __contains__(self, key):
42         self._enforce_ttl_key(key)
43         return dict.__contains__(self, key)
44 class CacheDisk(CacheDict):
45     def __init__(self, ttl, path, *args, **kwargs):
46         super().__init__(ttl, *args, **kwargs)
47         self._path = path
48         self._dict = {}
49         self._read()
50     def _enforce_ttl_key(self, key):
51         if key not in self._key_cache_time:
52             return
53         if time.time() - self._key_cache_time[key] &gt; self._ttl:
54             del self._key_cache_time[key]
55             self._dict.__delitem__(key)
56     def __contains__(self, key):
57         self._enforce_ttl_key(key)
58         return self._dict.__contains__(key)
59     def __getitem__(self, key):
60         self._enforce_ttl_key(key)
61         return self._dict.__getitem__(key)
62     def __setitem__(self, key, val):
63         self._key_cache_time[key] = time.time()
64         self._dict.__setitem__(key, val)
65         self._write()
66     def __delitem__(self, key):
67         del self._key_cache_time[key]
68         self._dict.__delitem__(key)
69         self._write()
70     def clear(self):
71         self._key_cache_time.clear()
72         self._dict.clear()
73         self._write()
74     def _read(self):
75         if not salt.utils.msgpack.HAS_MSGPACK or not os.path.exists(self._path):
76             return
77         with salt.utils.files.fopen(self._path, "rb") as fp_:
78             cache = salt.utils.data.decode(
79                 salt.utils.msgpack.load(fp_, encoding=__salt_system_encoding__)
80             )
81         if "CacheDisk_cachetime" in cache:  # new format
82             self._dict = cache["CacheDisk_data"]
83             self._key_cache_time = cache["CacheDisk_cachetime"]
84         else:  # old format
85             self._dict = cache
86             timestamp = os.path.getmtime(self._path)
87             for key in self._dict:
88                 self._key_cache_time[key] = timestamp
89         if log.isEnabledFor(logging.DEBUG):
90             log.debug("Disk cache retrieved: %s", cache)
91     def _write(self):
92         if not salt.utils.msgpack.HAS_MSGPACK:
93             return
94         with salt.utils.atomicfile.atomic_open(self._path, "wb+") as fp_:
95             cache = {
96                 "CacheDisk_data": self._dict,
97                 "CacheDisk_cachetime": self._key_cache_time,
98             }
99             salt.utils.msgpack.dump(cache, fp_, use_bin_type=True)
100 class CacheCli:
101     def __init__(self, opts):
102         self.opts = opts
103         self.cache_sock = os.path.join(self.opts["sock_dir"], "con_cache.ipc")
104         self.cache_upd_sock = os.path.join(self.opts["sock_dir"], "con_upd.ipc")
105         context = zmq.Context()
106         self.creq_out = context.socket(zmq.REQ)
107         self.creq_out.setsockopt(zmq.LINGER, 100)
108         self.creq_out.connect("ipc://" + self.cache_sock)
109         self.cupd_out = context.socket(zmq.PUB)
110         self.cupd_out.setsockopt(zmq.LINGER, 1)
111         self.cupd_out.connect("ipc://" + self.cache_upd_sock)
112     def put_cache(self, minions):
113         self.cupd_out.send(salt.payload.dumps(minions))
114     def get_cached(self):
115         msg = salt.payload.dumps("minions")
116         self.creq_out.send(msg)
117         min_list = salt.payload.loads(self.creq_out.recv())
118         return min_list
119 class CacheRegex:
120     def __init__(
121         self, prepend="", append="", size=1000, keep_fraction=0.8, max_age=3600
122     ):
123         self.prepend = prepend
124         self.append = append
125         self.size = size
126         self.clear_size = int(size - size * (keep_fraction))
127         if self.clear_size &gt;= size:
128             self.clear_size = int(size / 2) + 1
129             if self.clear_size &gt; size:
130                 self.clear_size = size
131         self.max_age = max_age
132         self.cache = {}
133         self.timestamp = time.time()
134     def clear(self):
135         self.cache.clear()
136     def sweep(self):
137         if self.max_age &lt; time.time() - self.timestamp:
138             self.clear()
139             self.timestamp = time.time()
140         else:
141             paterns = list(self.cache.values())
142             paterns.sort()
143             for idx in range(self.clear_size):
144                 del self.cache[paterns[idx][2]]
145     def get(self, pattern):
146         try:
147             self.cache[pattern][0] += 1
148             return self.cache[pattern][1]
149         except KeyError:
150             pass
151         if len(self.cache) &gt; self.size:
152             self.sweep()
153         regex = re.compile("{}{}{}".format(self.prepend, pattern, self.append))
154         self.cache[pattern] = [1, regex, pattern, time.time()]
155         return regex
156 class ContextCache:
157     def __init__(self, opts, name):
158         self.opts = opts
159         self.cache_path = os.path.join(opts["cachedir"], "context", "{}.p".format(name))
160     def cache_context(self, context):
161         if not os.path.isdir(os.path.dirname(self.cache_path)):
162             os.mkdir(os.path.dirname(self.cache_path))
163         with salt.utils.files.fopen(self.cache_path, "w+b") as cache:
164             salt.payload.dump(context, cache)
165     def get_cache_context(self):
166         with salt.utils.files.fopen(self.cache_path, "rb") as cache:
167             return salt.utils.data.decode(salt.payload.load(cache))
168 def context_cache(func):
169     @functools.wraps(func)
170     def context_cache_wrap(*args, **kwargs):
171         try:
172             func_context = func.__globals__["__context__"].value()
173         except AttributeError:
174             func_context = func.__globals__["__context__"]
175         try:
176             func_opts = func.__globals__["__opts__"].value()
177         except AttributeError:
178             func_opts = func.__globals__["__opts__"]
179         func_name = func.__globals__["__name__"]
180         context_cache = ContextCache(func_opts, func_name)
181         if not func_context and os.path.isfile(context_cache.cache_path):
182             salt.utils.dictupdate.update(
183                 func_context, context_cache.get_cache_context()
184             )
185         else:
186             context_cache.cache_context(func_context)
187         return func(*args, **kwargs)
188     return context_cache_wrap
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tomcat_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import glob
2 import hashlib
3 import logging
4 import os
5 import re
6 import tempfile
7 import urllib.parse
8 import urllib.request
9 import salt.utils.data
10 import salt.utils.stringutils
11 log = logging.getLogger(</b></font>__name__)
12 __func_alias__ = {"reload_": "reload"}
13 __valid_configs = {
14     "user": ["tomcat-manager.user", "tomcat-manager:user"],
15     "passwd": ["tomcat-manager.passwd", "tomcat-manager:passwd"],
16 }
17 def __virtual__():
18     if __catalina_home() or _auth("dummy"):
19         return "tomcat"
20     return (
21         False,
22         "Tomcat execution module not loaded: neither Tomcat installed locally nor"
23         " tomcat-manager credentials set in grains/pillar/config.",
24     )
25 def __catalina_home():
26     locations = ["/usr/share/tomcat*", "/opt/tomcat"]
27     for location in locations:
28         folders = glob.glob(location)
29         if folders:
30             for catalina_home in folders:
31                 if os.path.isdir(catalina_home + "/bin"):
32                     return catalina_home
33     return False
34 def _get_credentials():
35     ret = {"user": False, "passwd": False}
36     for item in ret:
37         for struct in [__opts__, __grains__, __pillar__]:
38             for config_key in __valid_configs[item]:
39                 value = salt.utils.data.traverse_dict_and_list(struct, config_key, None)
40                 if value:
41                     ret[item] = value
42                     break
43     return ret["user"], ret["passwd"]
44 def _auth(uri):
45     user, password = _get_credentials()
46     if user is False or password is False:
47         return False
48     basic = urllib.request.HTTPBasicAuthHandler()
49     basic.add_password(
50         realm="Tomcat Manager Application", uri=uri, user=user, passwd=password
51     )
52     digest = urllib.request.HTTPDigestAuthHandler()
53     digest.add_password(
54         realm="Tomcat Manager Application", uri=uri, user=user, passwd=password
55     )
56     return urllib.request.build_opener(basic, digest)
57 def extract_war_version(war):
58     basename = os.path.basename(war)
59     war_package = os.path.splitext(basename)[0]  # remove '.war'
60     version = re.findall("-([\\d.-]+)$", war_package)  # try semver
61     return version[0] if version and len(version) == 1 else None  # default to none
62 def _wget(cmd, opts=None, url="http://localhost:8080/manager", timeout=180):
63     ret = {"res": True, "msg": []}
64     auth = _auth(url)
65     if auth is False:
66         ret["res"] = False
67         ret["msg"] = "missing username and password settings (grain/pillar)"
68         return ret
69     if url[-1] != "/":
70         url += "/"
71     url6 = url
72     url += "text/{}".format(cmd)
73     url6 += "{}".format(cmd)
74     if opts:
75         url += "?{}".format(urllib.parse.urlencode(opts))
76         url6 += "?{}".format(urllib.parse.urlencode(opts))
77     urllib.request.install_opener(auth)
78     try:
79         ret["msg"] = urllib.request.urlopen(url, timeout=timeout).read().splitlines()
80     except Exception:  # pylint: disable=broad-except
81         try:
82             ret["msg"] = (
83                 urllib.request.urlopen(url6, timeout=timeout).read().splitlines()
84             )
85         except Exception:  # pylint: disable=broad-except
86             ret["msg"] = "Failed to create HTTP request"
87     for key, value in enumerate(ret["msg"]):
88         try:
89             ret["msg"][key] = salt.utils.stringutils.to_unicode(value, "utf-8")
90         except (UnicodeDecodeError, AttributeError):
91             pass
92     if not ret["msg"][0].startswith("OK"):
93         ret["res"] = False
94     return ret
95 def _simple_cmd(cmd, app, url="http://localhost:8080/manager", timeout=180):
96     try:
97         opts = {"path": app, "version": ls(url)[app]["version"]}
98         return "\n".join(_wget(cmd, opts, url, timeout=timeout)["msg"])
99     except Exception:  # pylint: disable=broad-except
100         return "FAIL - No context exists for path {}".format(app)
101 def leaks(url="http://localhost:8080/manager", timeout=180):
102     return _wget("findleaks", {"statusLine": "true"}, url, timeout=timeout)["msg"]
103 def status(url="http://localhost:8080/manager", timeout=180):
104     return _wget("list", {}, url, timeout=timeout)["res"]
105 def ls(url="http://localhost:8080/manager", timeout=180):
106     ret = {}
107     data = _wget("list", "", url, timeout=timeout)
108     if data["res"] is False:
109         return {}
110     data["msg"].pop(0)
111     for line in data["msg"]:
112         tmp = line.split(":")
113         ret[tmp[0]] = {
114             "mode": tmp[1],
115             "sessions": tmp[2],
116             "fullname": tmp[3],
117             "version": "",
118         }
119         sliced = tmp[3].split("##")
120         if len(sliced) &gt; 1:
121             ret[tmp[0]]["version"] = sliced[1]
122     return ret
123 def stop(app, url="http://localhost:8080/manager", timeout=180):
124     return _simple_cmd("stop", app, url, timeout=timeout)
125 def start(app, url="http://localhost:8080/manager", timeout=180):
126     return _simple_cmd("start", app, url, timeout=timeout)
127 def reload_(app, url="http://localhost:8080/manager", timeout=180):
128     return _simple_cmd("reload", app, url, timeout=timeout)
129 def sessions(app, url="http://localhost:8080/manager", timeout=180):
130     return _simple_cmd("sessions", app, url, timeout=timeout)
131 def status_webapp(app, url="http://localhost:8080/manager", timeout=180):
132     webapps = ls(url, timeout=timeout)
133     for i in webapps:
134         if i == app:
135             return webapps[i]["mode"]
136     return "missing"
137 def serverinfo(url="http://localhost:8080/manager", timeout=180):
138     data = _wget("serverinfo", {}, url, timeout=timeout)
139     if data["res"] is False:
140         return {"error": data["msg"]}
141     ret = {}
142     data["msg"].pop(0)
143     for line in data["msg"]:
144         tmp = line.split(":")
145         ret[tmp[0].strip()] = tmp[1].strip()
146     return ret
147 def undeploy(app, url="http://localhost:8080/manager", timeout=180):
148     return _simple_cmd("undeploy", app, url, timeout=timeout)
149 def deploy_war(
150     war,
151     context,
152     force="no",
153     url="http://localhost:8080/manager",
154     saltenv="base",
155     timeout=180,
156     temp_war_location=None,
157     version=True,
158 ):
159     tfile = "salt.{}".format(os.path.basename(war))
160     if temp_war_location is not None:
161         if not os.path.isdir(temp_war_location):
162             return 'Error - "{}" is not a directory'.format(temp_war_location)
163         tfile = os.path.join(temp_war_location, tfile)
164     else:
165         tfile = os.path.join(tempfile.gettempdir(), tfile)
166     cache = False
167     if not os.path.isfile(war):
168         cache = True
169         cached = __salt__["cp.get_url"](war, tfile, saltenv)
170         if not cached:
171             return "FAIL - could not cache the WAR file"
172         try:
173             __salt__["file.set_mode"](cached, "0644")
174         except KeyError:
175             pass
176     else:
177         tfile = war
178     opts = {
179         "war": "file:{}".format(tfile),
180         "path": context,
181     }
182     if version:
183         version = extract_war_version(war) if version is True else version
184         if isinstance(version, str):
185             opts["version"] = version
186     if force == "yes":
187         opts["update"] = "true"
188     deployed = _wget("deploy", opts, url, timeout=timeout)
189     res = "\n".join(deployed["msg"])
190     if cache:
191         __salt__["file.remove"](tfile)
192     return res
193 def passwd(passwd, user="", alg="sha1", realm=None):
194     digest = hasattr(hashlib, alg) and getattr(hashlib, alg) or None
195     if digest:
196         if realm:
197             digest.update(
198                 "{}:{}:{}".format(
199                     user,
200                     realm,
201                     passwd,
202                 )
203             )
204         else:
205             digest.update(passwd)
206     return digest and digest.hexdigest() or False
207 def version():
208     cmd = __catalina_home() + "/bin/catalina.sh version"
209     out = __salt__["cmd.run"](cmd).splitlines()
210     for line in out:
211         if not line:
212             continue
213         if "Server version" in line:
214             comps = line.split(": ")
215             return comps[1]
216 def fullversion():
217     cmd = __catalina_home() + "/bin/catalina.sh version"
218     ret = {}
219     out = __salt__["cmd.run"](cmd).splitlines()
220     for line in out:
221         if not line:
222             continue
223         if ": " in line:
224             comps = line.split(": ")
225             ret[comps[0]] = comps[1].lstrip()
226     return ret
227 def signal(signal=None):
228     valid_signals = {
229         "forcestop": "stop -force",
230         "securestart": "start -security",
231         "start": "start",
232         "stop": "stop",
233     }
234     if signal not in valid_signals:
235         return
236     cmd = "{}/bin/catalina.sh {}".format(__catalina_home(), valid_signals[signal])
237     __salt__["cmd.run"](cmd)
238 if __name__ == "__main__":
239     __opts__ = {}
240     __grains__ = {}
241     __pillar__ = {
242         "tomcat-manager.user": "foobar",
243         "tomcat-manager.passwd": "barfoo1!",
244     }
245     old_format_creds = _get_credentials()
246     __pillar__ = {"tomcat-manager": {"user": "foobar", "passwd": "barfoo1!"}}
247     new_format_creds = _get_credentials()
248     if old_format_creds == new_format_creds:
249         log.info("Config backwards compatible")
250     else:
251         log.ifno("Config not backwards compatible")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
