<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for cache_3.py &amp; tomcat_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for cache_3.py &amp; tomcat_1.py
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>cache_3.py (2.4390244%)<th>tomcat_1.py (2.3049645%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(8-20)<td><a href="#" name="0">(63-75)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>cache_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
In-memory caching used by Salt
"""

<a name="0"></a>import functools
import logging
import os
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import re
import time

import salt.config
import salt.payload
import salt.utils.atomicfile
import salt.utils.data
import salt.utils.dictupdate
import salt.utils.files
import salt.utils.msgpack
from salt.utils.zeromq import zmq

log = logging.getLogger(</b></font>__name__)


class CacheFactory:
    """
    Cache which can use a number of backends
    """

    @classmethod
    def factory(cls, backend, ttl, *args, **kwargs):
        log.debug("Factory backend: %s", backend)
        if backend == "memory":
            return CacheDict(ttl, *args, **kwargs)
        elif backend == "disk":
            return CacheDisk(ttl, kwargs["minion_cache_path"], *args, **kwargs)
        else:
            log.error("CacheFactory received unrecognized cache type")


class CacheDict(dict):
    """
    Subclass of dict that will lazily delete items past ttl
    """

    def __init__(self, ttl, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self._ttl = ttl
        self._key_cache_time = {}

    def _enforce_ttl_key(self, key):
        """
        Enforce the TTL to a specific key, delete if its past TTL
        """
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            dict.__delitem__(self, key)

    def __getitem__(self, key):
        """
        Check if the key is ttld out, then do the get
        """
        self._enforce_ttl_key(key)
        return dict.__getitem__(self, key)

    def __setitem__(self, key, val):
        """
        Make sure to update the key cache time
        """
        self._key_cache_time[key] = time.time()
        dict.__setitem__(self, key, val)

    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return dict.__contains__(self, key)


class CacheDisk(CacheDict):
    """
    Class that represents itself as a dictionary to a consumer
    but uses a disk-based backend. Serialization and de-serialization
    is done with msgpack
    """

    def __init__(self, ttl, path, *args, **kwargs):
        super().__init__(ttl, *args, **kwargs)
        self._path = path
        self._dict = {}
        self._read()

    def _enforce_ttl_key(self, key):
        """
        Enforce the TTL to a specific key, delete if its past TTL
        """
        if key not in self._key_cache_time:
            return
        if time.time() - self._key_cache_time[key] &gt; self._ttl:
            del self._key_cache_time[key]
            self._dict.__delitem__(key)

    def __contains__(self, key):
        self._enforce_ttl_key(key)
        return self._dict.__contains__(key)

    def __getitem__(self, key):
        """
        Check if the key is ttld out, then do the get
        """
        self._enforce_ttl_key(key)
        return self._dict.__getitem__(key)

    def __setitem__(self, key, val):
        """
        Make sure to update the key cache time
        """
        self._key_cache_time[key] = time.time()
        self._dict.__setitem__(key, val)
        # Do the same as the parent but also persist
        self._write()

    def __delitem__(self, key):
        """
        Make sure to remove the key cache time
        """
        del self._key_cache_time[key]
        self._dict.__delitem__(key)
        # Do the same as the parent but also persist
        self._write()

    def clear(self):
        """
        Clear the cache
        """
        self._key_cache_time.clear()
        self._dict.clear()
        # Do the same as the parent but also persist
        self._write()

    def _read(self):
        """
        Read in from disk
        """
        if not salt.utils.msgpack.HAS_MSGPACK or not os.path.exists(self._path):
            return
        with salt.utils.files.fopen(self._path, "rb") as fp_:
            cache = salt.utils.data.decode(
                salt.utils.msgpack.load(fp_, encoding=__salt_system_encoding__)
            )
        if "CacheDisk_cachetime" in cache:  # new format
            self._dict = cache["CacheDisk_data"]
            self._key_cache_time = cache["CacheDisk_cachetime"]
        else:  # old format
            self._dict = cache
            timestamp = os.path.getmtime(self._path)
            for key in self._dict:
                self._key_cache_time[key] = timestamp
        if log.isEnabledFor(logging.DEBUG):
            log.debug("Disk cache retrieved: %s", cache)

    def _write(self):
        """
        Write out to disk
        """
        if not salt.utils.msgpack.HAS_MSGPACK:
            return
        # TODO Add check into preflight to ensure dir exists
        # TODO Dir hashing?
        with salt.utils.atomicfile.atomic_open(self._path, "wb+") as fp_:
            cache = {
                "CacheDisk_data": self._dict,
                "CacheDisk_cachetime": self._key_cache_time,
            }
            salt.utils.msgpack.dump(cache, fp_, use_bin_type=True)


class CacheCli:
    """
    Connection client for the ConCache. Should be used by all
    components that need the list of currently connected minions
    """

    def __init__(self, opts):
        """
        Sets up the zmq-connection to the ConCache
        """
        self.opts = opts
        self.cache_sock = os.path.join(self.opts["sock_dir"], "con_cache.ipc")
        self.cache_upd_sock = os.path.join(self.opts["sock_dir"], "con_upd.ipc")

        context = zmq.Context()

        # the socket for talking to the cache
        self.creq_out = context.socket(zmq.REQ)
        self.creq_out.setsockopt(zmq.LINGER, 100)
        self.creq_out.connect("ipc://" + self.cache_sock)

        # the socket for sending updates to the cache
        self.cupd_out = context.socket(zmq.PUB)
        self.cupd_out.setsockopt(zmq.LINGER, 1)
        self.cupd_out.connect("ipc://" + self.cache_upd_sock)

    def put_cache(self, minions):
        """
        published the given minions to the ConCache
        """
        self.cupd_out.send(salt.payload.dumps(minions))

    def get_cached(self):
        """
        queries the ConCache for a list of currently connected minions
        """
        msg = salt.payload.dumps("minions")
        self.creq_out.send(msg)
        min_list = salt.payload.loads(self.creq_out.recv())
        return min_list


class CacheRegex:
    """
    Create a regular expression object cache for the most frequently
    used patterns to minimize compilation of the same patterns over
    and over again
    """

    def __init__(
        self, prepend="", append="", size=1000, keep_fraction=0.8, max_age=3600
    ):
        self.prepend = prepend
        self.append = append
        self.size = size
        self.clear_size = int(size - size * (keep_fraction))
        if self.clear_size &gt;= size:
            self.clear_size = int(size / 2) + 1
            if self.clear_size &gt; size:
                self.clear_size = size
        self.max_age = max_age
        self.cache = {}
        self.timestamp = time.time()

    def clear(self):
        """
        Clear the cache
        """
        self.cache.clear()

    def sweep(self):
        """
        Sweep the cache and remove the outdated or least frequently
        used entries
        """
        if self.max_age &lt; time.time() - self.timestamp:
            self.clear()
            self.timestamp = time.time()
        else:
            paterns = list(self.cache.values())
            paterns.sort()
            for idx in range(self.clear_size):
                del self.cache[paterns[idx][2]]

    def get(self, pattern):
        """
        Get a compiled regular expression object based on pattern and
        cache it when it is not in the cache already
        """
        try:
            self.cache[pattern][0] += 1
            return self.cache[pattern][1]
        except KeyError:
            pass
        if len(self.cache) &gt; self.size:
            self.sweep()
        regex = re.compile("{}{}{}".format(self.prepend, pattern, self.append))
        self.cache[pattern] = [1, regex, pattern, time.time()]
        return regex


class ContextCache:
    def __init__(self, opts, name):
        """
        Create a context cache
        """
        self.opts = opts
        self.cache_path = os.path.join(opts["cachedir"], "context", "{}.p".format(name))

    def cache_context(self, context):
        """
        Cache the given context to disk
        """
        if not os.path.isdir(os.path.dirname(self.cache_path)):
            os.mkdir(os.path.dirname(self.cache_path))
        with salt.utils.files.fopen(self.cache_path, "w+b") as cache:
            salt.payload.dump(context, cache)

    def get_cache_context(self):
        """
        Retrieve a context cache from disk
        """
        with salt.utils.files.fopen(self.cache_path, "rb") as cache:
            return salt.utils.data.decode(salt.payload.load(cache))


def context_cache(func):
    """
    A decorator to be used module functions which need to cache their
    context.

    To evaluate a __context__ and re-hydrate it if a given key
    is empty or contains no items, pass a list of keys to evaulate.
    """

    @functools.wraps(func)
    def context_cache_wrap(*args, **kwargs):
        try:
            func_context = func.__globals__["__context__"].value()
        except AttributeError:
            func_context = func.__globals__["__context__"]
        try:
            func_opts = func.__globals__["__opts__"].value()
        except AttributeError:
            func_opts = func.__globals__["__opts__"]
        func_name = func.__globals__["__name__"]

        context_cache = ContextCache(func_opts, func_name)
        if not func_context and os.path.isfile(context_cache.cache_path):
            salt.utils.dictupdate.update(
                func_context, context_cache.get_cache_context()
            )
        else:
            context_cache.cache_context(func_context)
        return func(*args, **kwargs)

    return context_cache_wrap
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tomcat_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Support for Tomcat

This module uses the manager webapp to manage Apache tomcat webapps.
If the manager webapp is not configured some of the functions won't work.

:configuration:
    - Java bin path should be in default path
    - If ipv6 is enabled make sure you permit manager access to ipv6 interface
      "0:0:0:0:0:0:0:1"
    - If you are using tomcat.tar.gz it has to be installed or symlinked under
      ``/opt``, preferably using name tomcat
    - "tomcat.signal start/stop" works but it does not use the startup scripts

The following grains/pillar should be set:

.. code-block:: yaml

    tomcat-manager:
      user: &lt;username&gt;
      passwd: &lt;password&gt;

or the old format:

.. code-block:: yaml

    tomcat-manager.user: &lt;username&gt;
    tomcat-manager.passwd: &lt;password&gt;

Also configure a user in the conf/tomcat-users.xml file:

.. code-block:: xml

    &lt;?xml version='1.0' encoding='utf-8'?&gt;
    &lt;tomcat-users&gt;
        &lt;role rolename="manager-script"/&gt;
        &lt;user username="tomcat" password="tomcat" roles="manager-script"/&gt;
    &lt;/tomcat-users&gt;

.. note::

   - More information about tomcat manager:
     http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html
   - if you use only this module for deployments you've might want to strict
     access to the manager only from localhost for more info:
     http://tomcat.apache.org/tomcat-7.0-doc/manager-howto.html#Configuring_Manager_Application_Access
   - Tested on:

     JVM Vendor:
         Sun Microsystems Inc.
     JVM Version:
         1.6.0_43-b01
     OS Architecture:
         amd64
     OS Name:
         Linux
     OS Version:
         2.6.32-358.el6.x86_64
     Tomcat Version:
<a name="0"></a>         Apache Tomcat/7.0.37
"""

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import glob
import hashlib
import logging
import os
import re
import tempfile
import urllib.parse
import urllib.request

import salt.utils.data
import salt.utils.stringutils

log = logging.getLogger(</b></font>__name__)

__func_alias__ = {"reload_": "reload"}

# Support old-style grains/pillar
# config as well as new.
__valid_configs = {
    "user": ["tomcat-manager.user", "tomcat-manager:user"],
    "passwd": ["tomcat-manager.passwd", "tomcat-manager:passwd"],
}


def __virtual__():
    """
    Only load tomcat if it is installed or if grains/pillar config exists
    """
    if __catalina_home() or _auth("dummy"):
        return "tomcat"
    return (
        False,
        "Tomcat execution module not loaded: neither Tomcat installed locally nor"
        " tomcat-manager credentials set in grains/pillar/config.",
    )


def __catalina_home():
    """
    Tomcat paths differ depending on packaging
    """
    locations = ["/usr/share/tomcat*", "/opt/tomcat"]
    for location in locations:
        folders = glob.glob(location)
        if folders:
            for catalina_home in folders:
                if os.path.isdir(catalina_home + "/bin"):
                    return catalina_home
    return False


def _get_credentials():
    """
    Get the username and password from opts, grains, or pillar
    """
    ret = {"user": False, "passwd": False}

    # Loop through opts, grains, and pillar
    # Return the first acceptable configuration found
    for item in ret:
        for struct in [__opts__, __grains__, __pillar__]:
            # Look for the config key
            # Support old-style config format and new
            for config_key in __valid_configs[item]:
                value = salt.utils.data.traverse_dict_and_list(struct, config_key, None)
                if value:
                    ret[item] = value
                    break
    return ret["user"], ret["passwd"]


def _auth(uri):
    """
    returns a authentication handler.
    Get user &amp; password from grains, if are not set default to
    modules.config.option

    If user &amp; pass are missing return False
    """

    user, password = _get_credentials()
    if user is False or password is False:
        return False

    basic = urllib.request.HTTPBasicAuthHandler()
    basic.add_password(
        realm="Tomcat Manager Application", uri=uri, user=user, passwd=password
    )
    digest = urllib.request.HTTPDigestAuthHandler()
    digest.add_password(
        realm="Tomcat Manager Application", uri=uri, user=user, passwd=password
    )
    return urllib.request.build_opener(basic, digest)


def extract_war_version(war):
    """
    Extract the version from the war file name. There does not seem to be a
    standard for encoding the version into the `war file name`_

    .. _`war file name`: https://tomcat.apache.org/tomcat-6.0-doc/deployer-howto.html

    Examples:

    .. code-block:: bash

        /path/salt-2015.8.6.war -&gt; 2015.8.6
        /path/V6R2013xD5.war -&gt; None
    """
    basename = os.path.basename(war)
    war_package = os.path.splitext(basename)[0]  # remove '.war'
    version = re.findall("-([\\d.-]+)$", war_package)  # try semver
    return version[0] if version and len(version) == 1 else None  # default to none


def _wget(cmd, opts=None, url="http://localhost:8080/manager", timeout=180):
    """
    A private function used to issue the command to tomcat via the manager
    webapp

    cmd
        the command to execute

    url
        The URL of the server manager webapp (example:
        http://localhost:8080/manager)

    opts
        a dict of arguments

    timeout
        timeout for HTTP request

    Return value is a dict in the from of::

        {
            res: [True|False]
            msg: list of lines we got back from the manager
        }
    """

    ret = {"res": True, "msg": []}

    # prepare authentication
    auth = _auth(url)
    if auth is False:
        ret["res"] = False
        ret["msg"] = "missing username and password settings (grain/pillar)"
        return ret

    # prepare URL
    if url[-1] != "/":
        url += "/"
    url6 = url
    url += "text/{}".format(cmd)
    url6 += "{}".format(cmd)
    if opts:
        url += "?{}".format(urllib.parse.urlencode(opts))
        url6 += "?{}".format(urllib.parse.urlencode(opts))

    # Make the HTTP request
    urllib.request.install_opener(auth)

    try:
        # Trying tomcat &gt;= 7 url
        ret["msg"] = urllib.request.urlopen(url, timeout=timeout).read().splitlines()
    except Exception:  # pylint: disable=broad-except
        try:
            # Trying tomcat6 url
            ret["msg"] = (
                urllib.request.urlopen(url6, timeout=timeout).read().splitlines()
            )
        except Exception:  # pylint: disable=broad-except
            ret["msg"] = "Failed to create HTTP request"

    # Force all byte strings to utf-8 strings, for python &gt;= 3.4
    for key, value in enumerate(ret["msg"]):
        try:
            ret["msg"][key] = salt.utils.stringutils.to_unicode(value, "utf-8")
        except (UnicodeDecodeError, AttributeError):
            pass

    if not ret["msg"][0].startswith("OK"):
        ret["res"] = False

    return ret


def _simple_cmd(cmd, app, url="http://localhost:8080/manager", timeout=180):
    """
    Simple command wrapper to commands that need only a path option
    """

    try:
        opts = {"path": app, "version": ls(url)[app]["version"]}
        return "\n".join(_wget(cmd, opts, url, timeout=timeout)["msg"])
    except Exception:  # pylint: disable=broad-except
        return "FAIL - No context exists for path {}".format(app)


# Functions
def leaks(url="http://localhost:8080/manager", timeout=180):
    """
    Find memory leaks in tomcat

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.leaks
    """

    return _wget("findleaks", {"statusLine": "true"}, url, timeout=timeout)["msg"]


def status(url="http://localhost:8080/manager", timeout=180):
    """
    Used to test if the tomcat manager is up

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.status
        salt '*' tomcat.status http://localhost:8080/manager
    """

    return _wget("list", {}, url, timeout=timeout)["res"]


def ls(url="http://localhost:8080/manager", timeout=180):
    """
    list all the deployed webapps

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.ls
        salt '*' tomcat.ls http://localhost:8080/manager
    """

    ret = {}
    data = _wget("list", "", url, timeout=timeout)
    if data["res"] is False:
        return {}
    data["msg"].pop(0)
    for line in data["msg"]:
        tmp = line.split(":")
        ret[tmp[0]] = {
            "mode": tmp[1],
            "sessions": tmp[2],
            "fullname": tmp[3],
            "version": "",
        }
        sliced = tmp[3].split("##")
        if len(sliced) &gt; 1:
            ret[tmp[0]]["version"] = sliced[1]

    return ret


def stop(app, url="http://localhost:8080/manager", timeout=180):
    """
    Stop the webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.stop /jenkins
        salt '*' tomcat.stop /jenkins http://localhost:8080/manager
    """

    return _simple_cmd("stop", app, url, timeout=timeout)


def start(app, url="http://localhost:8080/manager", timeout=180):
    """
    Start the webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.start /jenkins
        salt '*' tomcat.start /jenkins http://localhost:8080/manager
    """

    return _simple_cmd("start", app, url, timeout=timeout)


def reload_(app, url="http://localhost:8080/manager", timeout=180):
    """
    Reload the webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.reload /jenkins
        salt '*' tomcat.reload /jenkins http://localhost:8080/manager
    """

    return _simple_cmd("reload", app, url, timeout=timeout)


def sessions(app, url="http://localhost:8080/manager", timeout=180):
    """
    return the status of the webapp sessions

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.sessions /jenkins
        salt '*' tomcat.sessions /jenkins http://localhost:8080/manager
    """

    return _simple_cmd("sessions", app, url, timeout=timeout)


def status_webapp(app, url="http://localhost:8080/manager", timeout=180):
    """
    return the status of the webapp (stopped | running | missing)

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.status_webapp /jenkins
        salt '*' tomcat.status_webapp /jenkins http://localhost:8080/manager
    """

    webapps = ls(url, timeout=timeout)
    for i in webapps:
        if i == app:
            return webapps[i]["mode"]

    return "missing"


def serverinfo(url="http://localhost:8080/manager", timeout=180):
    """
    return details about the server

    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.serverinfo
        salt '*' tomcat.serverinfo http://localhost:8080/manager
    """

    data = _wget("serverinfo", {}, url, timeout=timeout)
    if data["res"] is False:
        return {"error": data["msg"]}

    ret = {}
    data["msg"].pop(0)
    for line in data["msg"]:
        tmp = line.split(":")
        ret[tmp[0].strip()] = tmp[1].strip()

    return ret


def undeploy(app, url="http://localhost:8080/manager", timeout=180):
    """
    Undeploy a webapp

    app
        the webapp context path
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    timeout : 180
        timeout for HTTP request

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.undeploy /jenkins
        salt '*' tomcat.undeploy /jenkins http://localhost:8080/manager
    """

    return _simple_cmd("undeploy", app, url, timeout=timeout)


def deploy_war(
    war,
    context,
    force="no",
    url="http://localhost:8080/manager",
    saltenv="base",
    timeout=180,
    temp_war_location=None,
    version=True,
):
    """
    Deploy a WAR file

    war
        absolute path to WAR file (should be accessible by the user running
        tomcat) or a path supported by the salt.modules.cp.get_file function
    context
        the context path to deploy
    force : False
        set True to deploy the webapp even one is deployed in the context
    url : http://localhost:8080/manager
        the URL of the server manager webapp
    saltenv : base
        the environment for WAR file in used by salt.modules.cp.get_url
        function
    timeout : 180
        timeout for HTTP request
    temp_war_location : None
        use another location to temporarily copy to war file
        by default the system's temp directory is used
    version : ''
        Specify the war version.  If this argument is provided, it overrides
        the version encoded in the war file name, if one is present.

        Examples:

        .. code-block:: bash

            salt '*' tomcat.deploy_war salt://salt-2015.8.6.war version=2015.08.r6

        .. versionadded:: 2015.8.6

    CLI Examples:

    cp module

    .. code-block:: bash

        salt '*' tomcat.deploy_war salt://application.war /api
        salt '*' tomcat.deploy_war salt://application.war /api no
        salt '*' tomcat.deploy_war salt://application.war /api yes http://localhost:8080/manager

    minion local file system

    .. code-block:: bash

        salt '*' tomcat.deploy_war /tmp/application.war /api
        salt '*' tomcat.deploy_war /tmp/application.war /api no
        salt '*' tomcat.deploy_war /tmp/application.war /api yes http://localhost:8080/manager
    """
    # Decide the location to copy the war for the deployment
    tfile = "salt.{}".format(os.path.basename(war))
    if temp_war_location is not None:
        if not os.path.isdir(temp_war_location):
            return 'Error - "{}" is not a directory'.format(temp_war_location)
        tfile = os.path.join(temp_war_location, tfile)
    else:
        tfile = os.path.join(tempfile.gettempdir(), tfile)

    # Copy file name if needed
    cache = False
    if not os.path.isfile(war):
        cache = True
        cached = __salt__["cp.get_url"](war, tfile, saltenv)
        if not cached:
            return "FAIL - could not cache the WAR file"
        try:
            __salt__["file.set_mode"](cached, "0644")
        except KeyError:
            pass
    else:
        tfile = war

    # Prepare options
    opts = {
        "war": "file:{}".format(tfile),
        "path": context,
    }

    # If parallel versions are desired or not disabled
    if version:
        # Set it to defined version or attempt extract
        version = extract_war_version(war) if version is True else version

        if isinstance(version, str):
            # Only pass version to Tomcat if not undefined
            opts["version"] = version

    if force == "yes":
        opts["update"] = "true"

    # Deploy
    deployed = _wget("deploy", opts, url, timeout=timeout)
    res = "\n".join(deployed["msg"])

    # Cleanup
    if cache:
        __salt__["file.remove"](tfile)

    return res


def passwd(passwd, user="", alg="sha1", realm=None):
    """
    This function replaces the $CATALINA_HOME/bin/digest.sh script
    convert a clear-text password to the $CATALINA_BASE/conf/tomcat-users.xml
    format

    CLI Examples:

    .. code-block:: bash

        salt '*' tomcat.passwd secret
        salt '*' tomcat.passwd secret tomcat sha1
        salt '*' tomcat.passwd secret tomcat sha1 'Protected Realm'
    """
    # Shouldn't it be SHA265 instead of SHA1?
    digest = hasattr(hashlib, alg) and getattr(hashlib, alg) or None
    if digest:
        if realm:
            digest.update(
                "{}:{}:{}".format(
                    user,
                    realm,
                    passwd,
                )
            )
        else:
            digest.update(passwd)

    return digest and digest.hexdigest() or False


# Non-Manager functions
def version():
    """
    Return server version from catalina.sh version

    CLI Example:

    .. code-block:: bash

        salt '*' tomcat.version
    """
    cmd = __catalina_home() + "/bin/catalina.sh version"
    out = __salt__["cmd.run"](cmd).splitlines()
    for line in out:
        if not line:
            continue
        if "Server version" in line:
            comps = line.split(": ")
            return comps[1]


def fullversion():
    """
    Return all server information from catalina.sh version

    CLI Example:

    .. code-block:: bash

        salt '*' tomcat.fullversion
    """
    cmd = __catalina_home() + "/bin/catalina.sh version"
    ret = {}
    out = __salt__["cmd.run"](cmd).splitlines()
    for line in out:
        if not line:
            continue
        if ": " in line:
            comps = line.split(": ")
            ret[comps[0]] = comps[1].lstrip()
    return ret


def signal(signal=None):
    """
    Signals catalina to start, stop, securestart, forcestop.

    CLI Example:

    .. code-block:: bash

        salt '*' tomcat.signal start
    """
    valid_signals = {
        "forcestop": "stop -force",
        "securestart": "start -security",
        "start": "start",
        "stop": "stop",
    }

    if signal not in valid_signals:
        return

    cmd = "{}/bin/catalina.sh {}".format(__catalina_home(), valid_signals[signal])
    __salt__["cmd.run"](cmd)


if __name__ == "__main__":
    # Allow testing from the CLI
    __opts__ = {}
    __grains__ = {}
    __pillar__ = {
        "tomcat-manager.user": "foobar",
        "tomcat-manager.passwd": "barfoo1!",
    }

    old_format_creds = _get_credentials()

    __pillar__ = {"tomcat-manager": {"user": "foobar", "passwd": "barfoo1!"}}

    new_format_creds = _get_credentials()

    if old_format_creds == new_format_creds:
        log.info("Config backwards compatible")
    else:
        log.ifno("Config not backwards compatible")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
