<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for theplatform.py &amp; ism.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for theplatform.py &amp; ism.py
      </h3>
<h1 align="center">
        7.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>theplatform.py (6.9148936%)<th>ism.py (7.6171875%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(284-292)<td><a href="#" name="0">(65-70)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(407-412)<td><a href="#" name="1">(46-50)</a><td align="center"><font color="#ec0000">13</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(293-297)<td><a href="#" name="2">(116-121)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>theplatform.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import re
3 import time
4 import hmac
5 import binascii
6 import hashlib
7 from .once import OnceIE
8 from .adobepass import AdobePassIE
9 from ..compat import (
10     compat_parse_qs,
11     compat_urllib_parse_urlparse,
12 )
13 from ..utils import (
14     determine_ext,
15     ExtractorError,
16     float_or_none,
17     int_or_none,
18     sanitized_Request,
19     unsmuggle_url,
20     update_url_query,
21     xpath_with_ns,
22     mimetype2ext,
23     find_xpath_attr,
24 )
25 default_ns = 'http://www.w3.org/2005/SMIL21/Language'
26 _x = lambda p: xpath_with_ns(p, {'smil': default_ns})
27 class ThePlatformBaseIE(OnceIE):
28     _TP_TLD = 'com'
29     def _extract_theplatform_smil(self, smil_url, video_id, note='Downloading SMIL data'):
30         meta = self._download_xml(
31             smil_url, video_id, note=note, query={'format': 'SMIL'},
32             headers=self.geo_verification_headers())
33         error_element = find_xpath_attr(meta, _x('.//smil:ref'), 'src')
34         if error_element is not None:
35             exception = find_xpath_attr(
36                 error_element, _x('.//smil:param'), 'name', 'exception')
37             if exception is not None:
38                 if exception.get('value') == 'GeoLocationBlocked':
39                     self.raise_geo_restricted(error_element.attrib['abstract'])
40                 elif error_element.attrib['src'].startswith(
41                         'http://link.theplatform.%s/s/errorFiles/Unavailable.'
42                         % self._TP_TLD):
43                     raise ExtractorError(
44                         error_element.attrib['abstract'], expected=True)
45         smil_formats = self._parse_smil_formats(
46             meta, smil_url, video_id, namespace=default_ns,
47             f4m_params={'g': 'UXWGVKRWHFSP', 'hdcore': '3.0.3'},
48             transform_rtmp_url=lambda streamer, src: (streamer, 'mp4:' + src))
49         formats = []
50         for _format in smil_formats:
51             if OnceIE.suitable(_format['url']):
52                 formats.extend(self._extract_once_formats(_format['url']))
53             else:
54                 media_url = _format['url']
55                 if determine_ext(media_url) == 'm3u8':
56                     hdnea2 = self._get_cookies(media_url).get('hdnea2')
57                     if hdnea2:
58                         _format['url'] = update_url_query(media_url, {'hdnea3': hdnea2.value})
59                 formats.append(_format)
60         subtitles = self._parse_smil_subtitles(meta, default_ns)
61         return formats, subtitles
62     def _download_theplatform_metadata(self, path, video_id):
63         info_url = 'http://link.theplatform.%s/s/%s?format=preview' % (self._TP_TLD, path)
64         return self._download_json(info_url, video_id)
65     def _parse_theplatform_metadata(self, info):
66         subtitles = {}
67         captions = info.get('captions')
68         if isinstance(captions, list):
69             for caption in captions:
70                 lang, src, mime = caption.get('lang', 'en'), caption.get('src'), caption.get('type')
71                 subtitles.setdefault(lang, []).append({
72                     'ext': mimetype2ext(mime),
73                     'url': src,
74                 })
75         duration = info.get('duration')
76         tp_chapters = info.get('chapters', [])
77         chapters = []
78         if tp_chapters:
79             def _add_chapter(start_time, end_time):
80                 start_time = float_or_none(start_time, 1000)
81                 end_time = float_or_none(end_time, 1000)
82                 if start_time is None or end_time is None:
83                     return
84                 chapters.append({
85                     'start_time': start_time,
86                     'end_time': end_time,
87                 })
88             for chapter in tp_chapters[:-1]:
89                 _add_chapter(chapter.get('startTime'), chapter.get('endTime'))
90             _add_chapter(tp_chapters[-1].get('startTime'), tp_chapters[-1].get('endTime') or duration)
91         return {
92             'title': info['title'],
93             'subtitles': subtitles,
94             'description': info['description'],
95             'thumbnail': info['defaultThumbnailUrl'],
96             'duration': float_or_none(duration, 1000),
97             'timestamp': int_or_none(info.get('pubDate'), 1000) or None,
98             'uploader': info.get('billingCode'),
99             'chapters': chapters,
100         }
101     def _extract_theplatform_metadata(self, path, video_id):
102         info = self._download_theplatform_metadata(path, video_id)
103         return self._parse_theplatform_metadata(info)
104 class ThePlatformIE(ThePlatformBaseIE, AdobePassIE):
105     _VALID_URL = r'''(?x)
106         (?:https?://(?:link|player)\.theplatform\.com/[sp]/(?P&lt;provider_id&gt;[^/]+)/
107            (?:(?:(?:[^/]+/)+select/)?(?P&lt;media&gt;media/(?:guid/\d+/)?)?|(?P&lt;config&gt;(?:[^/\?]+/(?:swf|config)|onsite)/select/))?
108          |theplatform:)(?P&lt;id&gt;[^/\?&amp;]+)'''
109     _TESTS = [{
110         'url': 'http://link.theplatform.com/s/dJ5BDC/e9I_cZgTgIPd/meta.smil?format=smil&amp;Tracking=true&amp;mbr=true',
111         'info_dict': {
112             'id': 'e9I_cZgTgIPd',
113             'ext': 'flv',
114             'title': 'Blackberry\'s big, bold Z30',
115             'description': 'The Z30 is Blackberry\'s biggest, baddest mobile messaging device yet.',
116             'duration': 247,
117             'timestamp': 1383239700,
118             'upload_date': '20131031',
119             'uploader': 'CBSI-NEW',
120         },
121         'params': {
122             'skip_download': True,
123         },
124         'skip': '404 Not Found',
125     }, {
126         'url': 'http://link.theplatform.com/s/kYEXFC/22d_qsQ6MIRT',
127         'info_dict': {
128             'id': '22d_qsQ6MIRT',
129             'ext': 'flv',
130             'description': 'md5:ac330c9258c04f9d7512cf26b9595409',
131             'title': 'Tesla Model S: A second step towards a cleaner motoring future',
132             'timestamp': 1426176191,
133             'upload_date': '20150312',
134             'uploader': 'CBSI-NEW',
135         },
136         'params': {
137             'skip_download': True,
138         }
139     }, {
140         'url': 'https://player.theplatform.com/p/D6x-PC/pulse_preview/embed/select/media/yMBg9E8KFxZD',
141         'info_dict': {
142             'id': 'yMBg9E8KFxZD',
143             'ext': 'mp4',
144             'description': 'md5:644ad9188d655b742f942bf2e06b002d',
145             'title': 'HIGHLIGHTS: USA bag first ever series Cup win',
146             'uploader': 'EGSM',
147         }
148     }, {
149         'url': 'http://player.theplatform.com/p/NnzsPC/widget/select/media/4Y0TlYUr_ZT7',
150         'only_matching': True,
151     }, {
152         'url': 'http://player.theplatform.com/p/2E2eJC/nbcNewsOffsite?guid=tdy_or_siri_150701',
153         'md5': 'fb96bb3d85118930a5b055783a3bd992',
154         'info_dict': {
155             'id': 'tdy_or_siri_150701',
156             'ext': 'mp4',
157             'title': 'iPhone Siriâ€™s sassy response to a math question has people talking',
158             'description': 'md5:a565d1deadd5086f3331d57298ec6333',
159             'duration': 83.0,
160             'thumbnail': r're:^https?://.*\.jpg$',
161             'timestamp': 1435752600,
162             'upload_date': '20150701',
163             'uploader': 'NBCU-NEWS',
164         },
165     }, {
166         'url': 'http://player.theplatform.com/p/NnzsPC/onsite_universal/select/media/guid/2410887629/2928790?fwsitesection=nbc_the_blacklist_video_library&amp;autoPlay=true&amp;carouselID=137781',
167         'only_matching': True,
168     }]
169     @classmethod
170     def _extract_urls(cls, webpage):
171         m = re.search(
172             r'''(?x)
173                     &lt;meta\s+
174                         property=(["'])(?:og:video(?::(?:secure_)?url)?|twitter:player)\1\s+
175                         content=(["'])(?P&lt;url&gt;https?://player\.theplatform\.com/p/.+?)\2
176             ''', webpage)
177         if m:
178             return [m.group('url')]
179         matches = re.findall(
180             r'(?s)&lt;(?:iframe|script)[^&gt;]+src=(["\'])((?:https?:)?//player\.theplatform\.com/p/.+?)\1', webpage)
181         if matches:
182             return [re.sub(r'\s', '', list(zip(*matches))[1][0])]
183     @staticmethod
184     def _sign_url(url, sig_key, sig_secret, life=600, include_qs=False):
185         flags = '10' if include_qs else '00'
186         expiration_date = '%x' % (int(time.time()) + life)
187         def str_to_hex(str):
188             return binascii.b2a_hex(str.encode('ascii')).decode('ascii')
189         def hex_to_bytes(hex):
190             return binascii.a2b_hex(hex.encode('ascii'))
191         relative_path = re.match(r'https?://link\.theplatform\.com/s/([^?]+)', url).group(1)
192         clear_text = hex_to_bytes(flags + expiration_date + str_to_hex(relative_path))
193         checksum = hmac.new(sig_key.encode('ascii'), clear_text, hashlib.sha1).hexdigest()
194         sig = flags + expiration_date + checksum + str_to_hex(sig_secret)
195         return '%s&amp;sig=%s' % (url, sig)
196     def _real_extract(self, url):
197         url, smuggled_data = unsmuggle_url(url, {})
198         self._initialize_geo_bypass({
199             'countries': smuggled_data.get('geo_countries'),
200         })
201         mobj = re.match(self._VALID_URL, url)
202         provider_id = mobj.group('provider_id')
203         video_id = mobj.group('id')
204         if not provider_id:
205             provider_id = 'dJ5BDC'
206         path = provider_id + '/'
207         if mobj.group('media'):
208             path += mobj.group('media')
209         path += video_id
210         qs_dict = compat_parse_qs(compat_urllib_parse_urlparse(url).query)
211         if 'guid' in qs_dict:
212             webpage = self._download_webpage(url, video_id)
213             scripts = re.findall(r'&lt;script[^&gt;]+src="([^"]+)"', webpage)
214             feed_id = None
215             for script in reversed(scripts):
216                 feed_script = self._download_webpage(
217                     self._proto_relative_url(script, 'http:'),
218                     video_id, 'Downloading feed script')
219                 feed_id = self._search_regex(
220                     r'defaultFeedId\s*:\s*"([^"]+)"', feed_script,
221                     'default feed id', default=None)
222                 if feed_id is not None:
223                     break
224             if feed_id is None:
225                 raise ExtractorError('Unable to find feed id')
226             return self.url_result('http://feed.theplatform.com/f/%s/%s?byGuid=%s' % (
227                 provider_id, feed_id, qs_dict['guid'][0]))
228         if smuggled_data.get('force_smil_url', False):
229             smil_url = url
230         elif '/guid/' in url:
231             headers = {}
232             source_url = smuggled_data.get('source_url')
233 <a name="0"></a>            if source_url:
234                 headers['Referer'] = source_url
235             request = sanitized_Request(url, headers=headers)
236             webpage <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self._download_webpage(request, video_id)
237             smil_url = self._search_regex(
238                 r'&lt;link[^&gt;]+href=(["\'])(?P&lt;url&gt;.+?)\1[^&gt;]+type=["\']application/smil\+xml',
239                 webpage, 'smil url', group='url')
240             path = self._search_regex(
241                 r'link\.theplatform\.com/s/((?:[^/?#&amp;]+/)+[^/?#&amp;]+)', smil_url, 'path')
242 <a name="2"></a>            smil_url += '?' if '?' not in smil_url else '&amp;' + 'formats=m3u,mpeg4'
243         elif mobj.group('config'):
244             config_url =</b></font> url + '&amp;form=json'
245             config_url <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= config_url.replace('swf/', 'config/')
246             config_url = config_url.replace('onsite/', 'onsite/config/')
247             config = self._download_json(config_url, video_id, 'Downloading config')
248             if 'releaseUrl' in config:
249                 release_url = config[</b></font>'releaseUrl']
250             else:
251                 release_url = 'http://link.theplatform.com/s/%s?mbr=true' % path
252             smil_url = release_url + '&amp;formats=MPEG4&amp;manifest=f4m'
253         else:
254             smil_url = 'http://link.theplatform.com/s/%s?mbr=true' % path
255         sig = smuggled_data.get('sig')
256         if sig:
257             smil_url = self._sign_url(smil_url, sig['key'], sig['secret'])
258         formats, subtitles = self._extract_theplatform_smil(smil_url, video_id)
259         self._sort_formats(formats)
260         ret = self._extract_theplatform_metadata(path, video_id)
261         combined_subtitles = self._merge_subtitles(ret.get('subtitles', {}), subtitles)
262         ret.update({
263             'id': video_id,
264             'formats': formats,
265             'subtitles': combined_subtitles,
266         })
267         return ret
268 class ThePlatformFeedIE(ThePlatformBaseIE):
269     _URL_TEMPLATE = '%s//feed.theplatform.com/f/%s/%s?form=json&amp;%s'
270     _VALID_URL = r'https?://feed\.theplatform\.com/f/(?P&lt;provider_id&gt;[^/]+)/(?P&lt;feed_id&gt;[^?/]+)\?(?:[^&amp;]+&amp;)*(?P&lt;filter&gt;by(?:Gui|I)d=(?P&lt;id&gt;[^&amp;]+))'
271     _TESTS = [{
272         'url': 'http://feed.theplatform.com/f/7wvmTC/msnbc_video-p-test?form=json&amp;pretty=true&amp;range=-40&amp;byGuid=n_hardball_5biden_140207',
273         'md5': '6e32495b5073ab414471b615c5ded394',
274         'info_dict': {
275             'id': 'n_hardball_5biden_140207',
276             'ext': 'mp4',
277             'title': 'The Biden factor: will Joe run in 2016?',
278             'description': 'Could Vice President Joe Biden be preparing a 2016 campaign? Mark Halperin and Sam Stein weigh in.',
279             'thumbnail': r're:^https?://.*\.jpg$',
280             'upload_date': '20140208',
281             'timestamp': 1391824260,
282             'duration': 467.0,
283             'categories': ['MSNBC/Issues/Democrats', 'MSNBC/Issues/Elections/Election 2016'],
284             'uploader': 'NBCU-NEWS',
285         },
286     }, {
287         'url': 'http://feed.theplatform.com/f/2E2eJC/nnd_NBCNews?byGuid=nn_netcast_180306.Copy.01',
288         'only_matching': True,
289     }]
290     def _extract_feed_info(self, provider_id, feed_id, filter_query, video_id, custom_fields=None, asset_types_query={}, account_id=None):
291         real_url = self._URL_TEMPLATE % (self.http_scheme(), provider_id, feed_id, filter_query)
292         entry = self._download_json(real_url, video_id)['entries'][0]
293         main_smil_url = 'http://link.theplatform.com/s/%s/media/guid/%d/%s' % (provider_id, account_id, entry['guid']) if account_id else entry.get('plmedia$publicUrl')
294         formats = []
295         subtitles = {}
296         first_video_id = None
297         duration = None
298         asset_types = []
299         for item in entry['media$content']:
300             smil_url = item['plfile$url']
301             cur_video_id = ThePlatformIE._match_id(smil_url)
302             if first_video_id is None:
303                 first_video_id = cur_video_id
304                 duration = float_or_none(item.get('plfile$duration'))
305             file_asset_types = item.get('plfile$assetTypes') or compat_parse_qs(compat_urllib_parse_urlparse(smil_url).query)['assetTypes']
306             for asset_type in file_asset_types:
307                 if asset_type in asset_types:
308                     continue
309                 asset_types.append(asset_type)
310                 query = {
311                     'mbr': 'true',
312                     'formats': item['plfile$format'],
313                     'assetTypes': asset_type,
314                 }
315                 if asset_type in asset_types_query:
316                     query.update(asset_types_query[asset_type])
317                 cur_formats, cur_subtitles = self._extract_theplatform_smil(update_url_query(
318                     main_smil_url or smil_url, query), video_id, 'Downloading SMIL data for %s' % asset_type)
319                 formats.extend(cur_formats)
320                 subtitles = self._merge_subtitles(subtitles, cur_subtitles)
321         self._sort_formats(formats)
322         thumbnails = [{
323             'url': thumbnail['plfile$url'],
324             'width': int_or_none(thumbnail.get('plfile$width')),
325             'height': int_or_none(thumbnail.get('plfile$height')),
326         } for thumbnail in entry.get('media$thumbnails', [])]
327         timestamp = int_or_none(entry.get('media$availableDate'), scale=1000)
328         categories = [item['media$name'] for item in entry.get('media$categories', [])]
329         ret = self._extract_theplatform_metadata('%s/%s' % (provider_id, first_video_id), video_id)
330         subtitles = self._merge_subtitles(subtitles, ret['subtitles'])
331         ret.update({
332             'id': video_id,
333             'formats': formats,
334             'subtitles': subtitles,
335             'thumbnails': thumbnails,
336             'duration': duration,
337             'timestamp': timestamp,
338             'categories': categories,
339         })
340         if custom_fields:
341             ret.update(custom_fields(entry))
342 <a name="1"></a>        return ret
343     def _real_extract(self, url):
344         mobj = re.match(self<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>._VALID_URL, url)
345         video_id = mobj.group('id')
346         provider_id = mobj.group('provider_id')
347         feed_id = mobj.group('feed_id')
348         filter_query = mobj.group(</b></font>'filter')
349         return self._extract_feed_info(provider_id, feed_id, filter_query, video_id)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ism.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 from __future__ import unicode_literals
2 import time
3 import binascii
4 import io
5 from .fragment import FragmentFD
6 from ..compat import (
7     compat_Struct,
8     compat_urllib_error,
9 )
10 u8 = compat_Struct('&gt;B')
11 u88 = compat_Struct('&gt;Bx')
12 u16 = compat_Struct('&gt;H')
13 u1616 = compat_Struct('&gt;Hxx')
14 u32 = compat_Struct('&gt;I')
15 u64 = compat_Struct('&gt;Q')
16 s88 = compat_Struct('&gt;bx')
17 s16 = compat_Struct('&gt;h')
18 s1616 = compat_Struct('&gt;hxx')
19 s32 = compat_Struct('&gt;i')
20 unity_matrix = (s32.pack(0x10000) + s32.pack(0) * 3) * 2 + s32.pack(0x40000000)
21 TRACK_ENABLED = 0x1
22 TRACK_IN_MOVIE = 0x2
23 TRACK_IN_PREVIEW = 0x4
24 SELF_CONTAINED = 0x1
25 def box(box_type, payload):
26     return u32.pack(8 + len(payload)) + box_type + payload
27 def full_box(box_type, version, flags, payload):
28     return box(box_type, u8.pack(version) + u32.pack(flags)[1:] + payload)
29 <a name="1"></a>def write_piff_header(stream, params):
30     track_id = params['track_id']
31     fourcc = params['fourcc']
32     duration = params<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>['duration']
33     timescale = params.get('timescale', 10000000)
34     language = params.get('language', 'und')
35     height = params.get('height', 0)
36     width = params.get(</b></font>'width', 0)
37     is_audio = width == 0 and height == 0
38     creation_time = modification_time = int(time.time())
39     ftyp_payload = b'isml'  # major brand
40     ftyp_payload += u32.pack(1)  # minor version
41     ftyp_payload += b'piff' + b'iso2'  # compatible brands
42     stream.write(box(b'ftyp', ftyp_payload))  # File Type Box
43     mvhd_payload = u64.pack(creation_time)
44     mvhd_payload += u64.pack(modification_time)
45     mvhd_payload += u32.pack(timescale)
46 <a name="0"></a>    mvhd_payload += u64.pack(duration)
47     mvhd_payload += s1616.pack(1)  # rate
48     mvhd_payload += s88.pack(1)  # volume
49     mvhd_payload <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>+= u16.pack(0)  # reserved
50     mvhd_payload += u32.pack(0) * 2  # reserved
51     mvhd_payload += unity_matrix
52     mvhd_payload += u32.pack(0) * 6  # pre defined
53     mvhd_payload += u32.pack(0xffffffff)  # next track id
54     moov_payload =</b></font> full_box(b'mvhd', 1, 0, mvhd_payload)  # Movie Header Box
55     tkhd_payload = u64.pack(creation_time)
56     tkhd_payload += u64.pack(modification_time)
57     tkhd_payload += u32.pack(track_id)  # track id
58     tkhd_payload += u32.pack(0)  # reserved
59     tkhd_payload += u64.pack(duration)
60     tkhd_payload += u32.pack(0) * 2  # reserved
61     tkhd_payload += s16.pack(0)  # layer
62     tkhd_payload += s16.pack(0)  # alternate group
63     tkhd_payload += s88.pack(1 if is_audio else 0)  # volume
64     tkhd_payload += u16.pack(0)  # reserved
65     tkhd_payload += unity_matrix
66     tkhd_payload += u1616.pack(width)
67     tkhd_payload += u1616.pack(height)
68     trak_payload = full_box(b'tkhd', 1, TRACK_ENABLED | TRACK_IN_MOVIE | TRACK_IN_PREVIEW, tkhd_payload)  # Track Header Box
69     mdhd_payload = u64.pack(creation_time)
70     mdhd_payload += u64.pack(modification_time)
71     mdhd_payload += u32.pack(timescale)
72     mdhd_payload += u64.pack(duration)
73     mdhd_payload += u16.pack(((ord(language[0]) - 0x60) &lt;&lt; 10) | ((ord(language[1]) - 0x60) &lt;&lt; 5) | (ord(language[2]) - 0x60))
74     mdhd_payload += u16.pack(0)  # pre defined
75     mdia_payload = full_box(b'mdhd', 1, 0, mdhd_payload)  # Media Header Box
76     hdlr_payload = u32.pack(0)  # pre defined
77     hdlr_payload += b'soun' if is_audio else b'vide'  # handler type
78     hdlr_payload += u32.pack(0) * 3  # reserved
79     hdlr_payload += (b'Sound' if is_audio else b'Video') + b'Handler\0'  # name
80     mdia_payload += full_box(b'hdlr', 0, 0, hdlr_payload)  # Handler Reference Box
81     if is_audio:
82         smhd_payload = s88.pack(0)  # balance
83         smhd_payload += u16.pack(0)  # reserved
84         media_header_box = full_box(b'smhd', 0, 0, smhd_payload)  # Sound Media Header
85     else:
86         vmhd_payload = u16.pack(0)  # graphics mode
87         vmhd_payload += u16.pack(0) * 3  # opcolor
88         media_header_box = full_box(b'vmhd', 0, 1, vmhd_payload)  # Video Media Header
89     minf_payload = media_header_box
90     dref_payload = u32.pack(1)  # entry count
91     dref_payload += full_box(b'url ', 0, SELF_CONTAINED, b'')  # Data Entry URL Box
92     minf_payload += box(b'dinf', dinf_payload)  # Data Information Box
93     stsd_payload <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= u32.pack(1)  # entry count
94     sample_entry_payload = u8.pack(0) * 6  # reserved
95     sample_entry_payload += u16.pack(1)  # data reference index
96     if is_audio:
97         sample_entry_payload += u32.</b></font>pack(0) * 2  # reserved
98         sample_entry_payload += u16.pack(params.get('channels', 2))
99         sample_entry_payload += u16.pack(params.get('bits_per_sample', 16))
100         sample_entry_payload += u16.pack(0)  # pre defined
101         sample_entry_payload += u16.pack(0)  # reserved
102         sample_entry_payload += u1616.pack(params['sampling_rate'])
103         if fourcc == 'AACL':
104             sample_entry_box = box(b'mp4a', sample_entry_payload)
105     else:
106         sample_entry_payload += u16.pack(0)  # pre defined
107         sample_entry_payload += u16.pack(0)  # reserved
108         sample_entry_payload += u32.pack(0) * 3  # pre defined
109         sample_entry_payload += u16.pack(width)
110         sample_entry_payload += u16.pack(height)
111         sample_entry_payload += u1616.pack(0x48)  # horiz resolution 72 dpi
112         sample_entry_payload += u1616.pack(0x48)  # vert resolution 72 dpi
113         sample_entry_payload += u32.pack(0)  # reserved
114         sample_entry_payload += u16.pack(1)  # frame count
115         sample_entry_payload += u8.pack(0) * 32  # compressor name
116         sample_entry_payload += u16.pack(0x18)  # depth
117         sample_entry_payload += s16.pack(-1)  # pre defined
118         codec_private_data = binascii.unhexlify(params['codec_private_data'].encode('utf-8'))
119         if fourcc in ('H264', 'AVC1'):
120             sps, pps = codec_private_data.split(u32.pack(1))[1:]
121             avcc_payload = u8.pack(1)  # configuration version
122             avcc_payload += sps[1:4]  # avc profile indication + profile compatibility + avc level indication
123             avcc_payload += u8.pack(0xfc | (params.get('nal_unit_length_field', 4) - 1))  # complete representation (1) + reserved (11111) + length size minus one
124             avcc_payload += u8.pack(1)  # reserved (0) + number of sps (0000001)
125             avcc_payload += u16.pack(len(sps))
126             avcc_payload += sps
127             avcc_payload += u8.pack(1)  # number of pps
128             avcc_payload += u16.pack(len(pps))
129             avcc_payload += pps
130             sample_entry_payload += box(b'avcC', avcc_payload)  # AVC Decoder Configuration Record
131             sample_entry_box = box(b'avc1', sample_entry_payload)  # AVC Simple Entry
132     stsd_payload += sample_entry_box
133     stbl_payload = full_box(b'stsd', 0, 0, stsd_payload)  # Sample Description Box
134     stts_payload = u32.pack(0)  # entry count
135     stbl_payload += full_box(b'stts', 0, 0, stts_payload)  # Decoding Time to Sample Box
136     stsc_payload = u32.pack(0)  # entry count
137     stbl_payload += full_box(b'stsc', 0, 0, stsc_payload)  # Sample To Chunk Box
138     stco_payload = u32.pack(0)  # entry count
139     stbl_payload += full_box(b'stco', 0, 0, stco_payload)  # Chunk Offset Box
140     minf_payload += box(b'stbl', stbl_payload)  # Sample Table Box
141     mdia_payload += box(b'minf', minf_payload)  # Media Information Box
142     trak_payload += box(b'mdia', mdia_payload)  # Media Box
143     moov_payload += box(b'trak', trak_payload)  # Track Box
144     mehd_payload = u64.pack(duration)
145     mvex_payload = full_box(b'mehd', 1, 0, mehd_payload)  # Movie Extends Header Box
146     trex_payload = u32.pack(track_id)  # track id
147     trex_payload += u32.pack(1)  # default sample description index
148     trex_payload += u32.pack(0)  # default sample duration
149     trex_payload += u32.pack(0)  # default sample size
150     trex_payload += u32.pack(0)  # default sample flags
151     mvex_payload += full_box(b'trex', 0, 0, trex_payload)  # Track Extends Box
152     moov_payload += box(b'mvex', mvex_payload)  # Movie Extends Box
153     stream.write(box(b'moov', moov_payload))  # Movie Box
154 def extract_box_data(data, box_sequence):
155     data_reader = io.BytesIO(data)
156     while True:
157         box_size = u32.unpack(data_reader.read(4))[0]
158         box_type = data_reader.read(4)
159         if box_type == box_sequence[0]:
160             box_data = data_reader.read(box_size - 8)
161             if len(box_sequence) == 1:
162                 return box_data
163             return extract_box_data(box_data, box_sequence[1:])
164         data_reader.seek(box_size - 8, 1)
165 class IsmFD(FragmentFD):
166     FD_NAME = 'ism'
167     def real_download(self, filename, info_dict):
168         segments = info_dict['fragments'][:1] if self.params.get(
169             'test', False) else info_dict['fragments']
170         ctx = {
171             'filename': filename,
172             'total_frags': len(segments),
173         }
174         self._prepare_and_start_frag_download(ctx)
175         fragment_retries = self.params.get('fragment_retries', 0)
176         skip_unavailable_fragments = self.params.get('skip_unavailable_fragments', True)
177         track_written = False
178         frag_index = 0
179         for i, segment in enumerate(segments):
180             frag_index += 1
181             if frag_index &lt;= ctx['fragment_index']:
182                 continue
183             count = 0
184             while count &lt;= fragment_retries:
185                 try:
186                     success, frag_content = self._download_fragment(ctx, segment['url'], info_dict)
187                     if not success:
188                         return False
189                     if not track_written:
190                         tfhd_data = extract_box_data(frag_content, [b'moof', b'traf', b'tfhd'])
191                         info_dict['_download_params']['track_id'] = u32.unpack(tfhd_data[4:8])[0]
192                         write_piff_header(ctx['dest_stream'], info_dict['_download_params'])
193                         track_written = True
194                     self._append_fragment(ctx, frag_content)
195                     break
196                 except compat_urllib_error.HTTPError as err:
197                     count += 1
198                     if count &lt;= fragment_retries:
199                         self.report_retry_fragment(err, frag_index, count, fragment_retries)
200             if count &gt; fragment_retries:
201                 if skip_unavailable_fragments:
202                     self.report_skip_fragment(frag_index)
203                     continue
204                 self.report_error('giving up after %s fragment retries' % fragment_retries)
205                 return False
206         self._finish_frag_download(ctx)
207         return True
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
