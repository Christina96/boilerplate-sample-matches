<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_salt_call.py &amp; verify.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_salt_call.py &amp; verify.py
      </h3>
<h1 align="center">
        1.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_salt_call.py (2.1416805%)<th>verify.py (1.1035653%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-14)<td><a href="#" name="0">(5-18)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_salt_call.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import copy
import logging
import os
import pprint
import re
import sys
import pytest
import salt.defaults.exitcodes
import salt.utils.files
import salt.utils.json
import salt.utils.platform
import salt.utils.yaml
from</b></font> tests.support.helpers import PRE_PYTEST_SKIP, PRE_PYTEST_SKIP_REASON, change_cwd
pytestmark = [
    pytest.mark.slow_test,
    pytest.mark.windows_whitelisted,
]
log = logging.getLogger(__name__)
def test_fib(salt_call_cli):
    ret = salt_call_cli.run("test.fib", "3")
    assert ret.exitcode == 0
    assert ret.json[0] == 2
def test_fib_txt_output(salt_call_cli):
    ret = salt_call_cli.run("--output=txt", "test.fib", "3")
    assert ret.exitcode == 0
    assert ret.json is None
    assert (
        re.match(r"local: \(2, [0-9]{1}\.(([0-9]+)(e-([0-9]+))?)\)\s", ret.stdout)
        is not None
    )
@pytest.mark.parametrize("indent", [-1, 0, 1])
def test_json_out_indent(salt_call_cli, indent):
    ret = salt_call_cli.run("--out=json", "--out-indent={}".format(indent), "test.ping")
    assert ret.exitcode == 0
    assert ret.json is True
    if indent == -1:
        expected_output = '{"local": true}\n'
    elif indent == 0:
        expected_output = '{\n"local": true\n}\n'
    else:
        expected_output = '{\n "local": true\n}\n'
    stdout = ret.stdout
    assert ret.stdout == expected_output
def test_local_sls_call(salt_master, salt_call_cli):
    sls_contents = """
    regular-module:
      module.run:
        - name: test.echo
        - text: hello
    This tests to make sure that salt-call does not execute the
    function twice, see https://github.com/saltstack/salt/pull/49552
    Test to see if passing additional arguments shows an error
    If there is no tops/master_tops or state file matches
    for this minion, salt-call should exit non-zero if invoked with
    option --retcode-passthrough
    Test to ensure we get expected output
    from pillar.items with salt-call
        salt_minion.id
    )
    basic_pillar_file = """
    monty: python
    knights:
      - Lancelot
      - Galahad
      - Bedevere
      - Robin
    test state.highstate in masterless mode
    testfile = tmp_path / "testfile"
    core_state = """
    {}:
      file:
        - managed
        - source: salt://testfile
        - makedirs: true
    test when log_file is set to a syslog file that does not exist
    Ensure correct exit status when an unknown argument is passed to salt CLI.
    Ensure correct exit status when salt CLI starts correctly.
    Test that a nonzero retcode set in the context dunder will cause the
    salt CLI to set a nonzero retcode.
    Test that we return the expected retcode when a minion function raises
    an exception.
    This tests ensures that when salt-call --local is called
    with a module but without a function the return code is 1
    and we receive the docs for all module functions.
    Also ensure we don't get an exception.
        a = state_run_dict["test.recho"]
        b = expected
        assert state_run_dict["test.recho"] == expected
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>verify.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import errno
import itertools
import logging
import os
import re
import socket
import stat
import sys
import salt.defaults.exitcodes
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import</b></font> salt.utils.user
from salt.exceptions import CommandExecutionError, SaltClientError, SaltSystemExit
from salt.log import is_console_configured
from salt.log.setup import LOG_LEVELS
try:
    import win32file
    import salt.utils.win_reg
except ImportError:
    import resource
log = logging.getLogger(__name__)
ROOT_DIR = "c:\\salt" if salt.utils.platform.is_windows() else "/"
DEFAULT_SCHEMES = ["tcp://", "udp://", "file://"]
def zmq_version():
    try:
        import zmq
    except Exception:  # pylint: disable=broad-except
        return True
    ver = zmq.__version__
    match = re.match(r"^(\d+)\.(\d+)(?:\.(\d+))?", ver)
    if not match:
        msg = "Using untested zmq python bindings version: '{}'".format(ver)
        if is_console_configured():
            log.warning(msg)
        else:
            sys.stderr.write("WARNING {}\n".format(msg))
        return True
    major, minor, point = match.groups()
    if major.isdigit():
        major = int(major)
    if minor.isdigit():
        minor = int(minor)
    if point and point.isdigit():
        point = int(point)
    if major == 2 and minor == 1:
        if "dev" in ver and not point:
            msg = "Using dev zmq module, please report unexpected results"
            if is_console_configured():
                log.warning(msg)
            else:
                sys.stderr.write("WARNING: {}\n".format(msg))
            return True
        elif point and point &gt;= 9:
            return True
    elif major &gt; 2 or (major == 2 and minor &gt; 1):
        return True
    log.critical("ZeroMQ python bindings &gt;= 2.1.9 are required")
    if "salt-master" in sys.argv[0]:
        msg = (
            "The Salt Master is unstable using a ZeroMQ version "
            "lower than 2.1.11 and requires this fix: http://lists.zeromq."
            "org/pipermail/zeromq-dev/2011-June/012094.html"
        )
        if is_console_configured():
            log.critical(msg)
        else:
            sys.stderr.write("CRITICAL {}\n".format(msg))
    return False
def lookup_family(hostname):
    fallback = socket.AF_INET
    try:
        hostnames = socket.getaddrinfo(
            hostname or None, None, socket.AF_UNSPEC, socket.SOCK_STREAM
        )
        if not hostnames:
            return fallback
        h = hostnames[0]
        return h[0]
    except socket.gaierror:
        return fallback
def verify_socket(interface, pub_port, ret_port):
    addr_family = lookup_family(interface)
    for port in pub_port, ret_port:
        sock = socket.socket(addr_family, socket.SOCK_STREAM)
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((interface, int(port)))
        except Exception as exc:  # pylint: disable=broad-except
            msg = "Unable to bind socket {}:{}".format(interface, port)
            if exc.args:
                msg = "{}, error: {}".format(msg, str(exc))
            else:
                msg = "{}, this might not be a problem.".format(msg)
            msg += "; Is there another salt-master running?"
            if is_console_configured():
                log.warning(msg)
            else:
                sys.stderr.write("WARNING: {}\n".format(msg))
            return False
        finally:
            sock.close()
    return True
def verify_logs_filter(files):
    to_verify = []
    for filename in files:
        verify_file = True
        for scheme in DEFAULT_SCHEMES:
            if filename.startswith(scheme):
                verify_file = False
                break
        if verify_file:
            to_verify.append(filename)
    return to_verify
def verify_log_files(files, user):
    return verify_files(verify_logs_filter(files), user)
def _get_pwnam(user):
    if salt.utils.platform.is_windows():
        return True
    import pwd  # after confirming not running Windows
    try:
        return pwd.getpwnam(user)
    except KeyError:
        msg = (
            "Failed to prepare the Salt environment for user {}. The user is not"
            " available.".format(user)
        )
        if is_console_configured():
            log.critical(msg)
        else:
            print(msg, file=sys.stderr, flush=True)
        sys.exit(salt.defaults.exitcodes.EX_NOUSER)
def verify_files(files, user):
    if salt.utils.platform.is_windows():
        return True
    pwnam = _get_pwnam(user)
    uid = pwnam[2]
    for fn_ in files:
        dirname = os.path.dirname(fn_)
        try:
            if dirname:
                try:
                    os.makedirs(dirname)
                except OSError as err:
                    if err.errno != errno.EEXIST:
                        raise
            if not os.path.isfile(fn_):
                with salt.utils.files.fopen(fn_, "w"):
                    pass
        except OSError as err:
            if os.path.isfile(dirname):
                msg = "Failed to create path {}, is {} a file?".format(fn_, dirname)
                raise SaltSystemExit(msg=msg)
            if err.errno != errno.EACCES:
                raise
            msg = 'No permissions to access "{}", are you running as the correct user?'.format(
                fn_
            )
            raise SaltSystemExit(msg=msg)
        except OSError as err:  # pylint: disable=duplicate-except
            msg = 'Failed to create path "{}" - {}'.format(fn_, err)
            raise SaltSystemExit(msg=msg)
        stats = os.stat(fn_)
        if uid != stats.st_uid:
            try:
                os.chown(fn_, uid, -1)
            except OSError:
                pass
    return True
def verify_env(
    dirs, user, permissive=False, pki_dir="", skip_extra=False, root_dir=ROOT_DIR
):
    if salt.utils.platform.is_windows():
        return win_verify_env(
            root_dir, dirs, permissive=permissive, skip_extra=skip_extra
        )
    pwnam = _get_pwnam(user)
    uid = pwnam[2]
    gid = pwnam[3]
    groups = salt.utils.user.get_gid_list(user, include_default=False)
    for dir_ in dirs:
        if not dir_:
            continue
        if not os.path.isdir(dir_):
            try:
                with salt.utils.files.set_umask(0o022):
                    os.makedirs(dir_)
                if os.getuid() == 0:
                    os.chown(dir_, uid, gid)
            except OSError as err:
                msg = 'Failed to create directory path "{0}" - {1}\n'
                sys.stderr.write(msg.format(dir_, err))
                sys.exit(err.errno)
        mode = os.stat(dir_)
        if os.getuid() == 0:
            fmode = os.stat(dir_)
            if fmode.st_uid != uid or fmode.st_gid != gid:
                if permissive and fmode.st_gid in groups:
                    pass
                else:
                    os.chown(dir_, uid, gid)
            for subdir in [a for a in os.listdir(dir_) if "jobs" not in a]:
                fsubdir = os.path.join(dir_, subdir)
                if "{}jobs".format(os.path.sep) in fsubdir:
                    continue
                for root, dirs, files in salt.utils.path.os_walk(fsubdir):
                    for name in itertools.chain(files, dirs):
                        if name.startswith("."):
                            continue
                        path = os.path.join(root, name)
                        try:
                            fmode = os.stat(path)
                            if fmode.st_uid != uid or fmode.st_gid != gid:
                                if permissive and fmode.st_gid in groups:
                                    pass
                                else:
                                    os.chown(path, uid, gid)
                        except OSError:
                            continue
        if dir_ == pki_dir:
            smode = stat.S_IMODE(mode.st_mode)
            if smode != 448 and smode != 488:
                if os.access(dir_, os.W_OK):
                    os.chmod(dir_, 448)
                else:
                    msg = 'Unable to securely set the permissions of "{0}".'
                    msg = msg.format(dir_)
                    if is_console_configured():
                        log.critical(msg)
                    else:
                        sys.stderr.write("CRITICAL: {}\n".format(msg))
    if skip_extra is False:
        zmq_version()
def check_user(user):
    if salt.utils.platform.is_windows():
        return True
    if user == salt.utils.user.get_user():
        return True
    pwuser = _get_pwnam(user)
    try:
        if hasattr(os, "initgroups"):
            os.initgroups(user, pwuser.pw_gid)  # pylint: disable=minimum-python-version
        else:
            os.setgroups(salt.utils.user.get_gid_list(user, include_default=False))
        os.setgid(pwuser.pw_gid)
        os.setuid(pwuser.pw_uid)
        if "HOME" in os.environ:
            os.environ["HOME"] = pwuser.pw_dir
        if "SHELL" in os.environ:
            os.environ["SHELL"] = pwuser.pw_shell
        for envvar in ("USER", "LOGNAME"):
            if envvar in os.environ:
                os.environ[envvar] = pwuser.pw_name
    except OSError:
        msg = 'Salt configured to run as user "{}" but unable to switch.'.format(user)
        if is_console_configured():
            log.critical(msg)
        else:
            sys.stderr.write("CRITICAL: {}\n".format(msg))
        return False
    return True
def list_path_traversal(path):
    out = [path]
    (head, tail) = os.path.split(path)
    if tail == "":
        out = [head]
        (head, tail) = os.path.split(head)
    while head != out[0]:
        out.insert(0, head)
        (head, tail) = os.path.split(head)
    return out
def check_path_traversal(path, user="root", skip_perm_errors=False):
    for tpath in list_path_traversal(path):
        if not os.access(tpath, os.R_OK):
            msg = "Could not access {}.".format(tpath)
            if not os.path.exists(tpath):
                msg += " Path does not exist."
            else:
                current_user = salt.utils.user.get_user()
                if user != current_user:
                    msg += " Try running as user {}.".format(user)
                else:
                    msg += " Please give {} read permissions.".format(user)
            if skip_perm_errors:
                return
            raise SaltClientError(msg)
def check_max_open_files(opts):
    mof_c = opts.get("max_open_files", 100000)
    if sys.platform.startswith("win"):
        mof_s = mof_h = win32file._getmaxstdio()
    else:
        mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)
    accepted_keys_dir = os.path.join(opts.get("pki_dir"), "minions")
    accepted_count = len(os.listdir(accepted_keys_dir))
    log.debug("This salt-master instance has accepted %s minion keys.", accepted_count)
    level = logging.INFO
    if (accepted_count * 4) &lt;= mof_s:
        return
    msg = (
        "The number of accepted minion keys({}) should be lower than 1/4 "
        "of the max open files soft setting({}). ".format(accepted_count, mof_s)
    )
    if accepted_count &gt;= mof_s:
        msg += "salt-master will crash pretty soon! "
        level = logging.CRITICAL
    elif (accepted_count * 2) &gt;= mof_s:
        level = logging.CRITICAL
    elif (accepted_count * 3) &gt;= mof_s:
        level = logging.WARNING
    elif (accepted_count * 4) &gt;= mof_s:
        level = logging.INFO
    if mof_c &lt; mof_h:
        msg += (
            "According to the system's hard limit, there's still a "
            "margin of {} to raise the salt's max_open_files "
            "setting. ".format(mof_h - mof_c)
        )
    msg += "Please consider raising this value."
    log.log(level=level, msg=msg)
def _realpath_darwin(path):
    base = ""
    for part in path.split(os.path.sep)[1:]:
        if base != "":
            if os.path.islink(os.path.sep.join([base, part])):
                base = os.readlink(os.path.sep.join([base, part]))
            else:
                base = os.path.abspath(os.path.sep.join([base, part]))
        else:
            base = os.path.abspath(os.path.sep.join([base, part]))
    return base
def _realpath_windows(path):
    base = ""
    for part in path.split(os.path.sep):
        if base != "":
            try:
                part = salt.utils.path.readlink(os.path.sep.join([base, part]))
                base = os.path.abspath(part)
            except OSError:
                base = os.path.abspath(os.path.sep.join([base, part]))
        else:
            base = part
    return base
def _realpath(path):
    if salt.utils.platform.is_darwin():
        return _realpath_darwin(path)
    elif salt.utils.platform.is_windows():
        return _realpath_windows(path)
    return os.path.realpath(path)
def clean_path(root, path, subdir=False):
    real_root = _realpath(root)
    if not os.path.isabs(real_root):
        return ""
    if not os.path.isabs(path):
        path = os.path.join(root, path)
    path = os.path.normpath(path)
    real_path = _realpath(path)
    if subdir:
        if real_path.startswith(real_root):
            return real_path
    else:
        if os.path.dirname(real_path) == os.path.normpath(real_root):
            return real_path
    return ""
def valid_id(opts, id_):
    try:
        if any(x in id_ for x in ("/", "\\", "\0")):
            return False
        return bool(clean_path(opts["pki_dir"], id_))
    except (AttributeError, KeyError, TypeError, UnicodeDecodeError):
        return False
def safe_py_code(code):
    bads = ("import", ";", "subprocess", "eval", "open", "file", "exec", "input")
    for bad in bads:
        if code.count(bad):
            return False
    return True
def verify_log(opts):
    level = LOG_LEVELS.get(str(opts.get("log_level")).lower(), logging.NOTSET)
    if level &lt; logging.INFO:
        log.warning(
            "Insecure logging configuration detected! Sensitive data may be logged."
        )
def win_verify_env(path, dirs, permissive=False, pki_dir="", skip_extra=False):
    import salt.utils.win_functions
    import salt.utils.win_dacl
    import salt.utils.path
    system_root = os.environ.get("SystemRoot", r"C:\Windows")
    allow_path = "\\".join([system_root, "TEMP"])
    if not salt.utils.path.safe_path(path=path, allow_path=allow_path):
        raise CommandExecutionError(
            "`file_roots` set to a possibly unsafe location: {}".format(path)
        )
    if not os.path.isdir(path):
        os.makedirs(path)
    current_user = salt.utils.win_functions.get_current_user()
    if salt.utils.win_functions.is_admin(current_user):
        reg_path = "HKLM\\SOFTWARE\\Salt Project\\salt"
        if not salt.utils.win_reg.key_exists(
            hive="HKLM", key="SOFTWARE\\Salt Project\\salt"
        ):
            salt.utils.win_reg.set_value(
                hive="HKLM", key="SOFTWARE\\Salt Project\\salt"
            )
        try:
            salt.utils.win_dacl.set_owner(
                obj_name=reg_path, principal="S-1-5-32-544", obj_type="registry"
            )
        except CommandExecutionError:
            msg = 'Unable to securely set the owner of "{}".'.format(reg_path)
            if is_console_configured():
                log.critical(msg)
            else:
                sys.stderr.write("CRITICAL: {}\n".format(msg))
        try:
            dacl = salt.utils.win_dacl.dacl(obj_type="registry")
            dacl.add_ace(
                principal="S-1-5-32-544",
                access_mode="grant",
                permissions="full_control",
                applies_to="this_key_subkeys",
            )
            dacl.add_ace(
                principal="S-1-5-18",
                access_mode="grant",
                permissions="full_control",
                applies_to="this_key_subkeys",
            )
            dacl.add_ace(
                principal="S-1-3-4",
                access_mode="grant",
                permissions="full_control",
                applies_to="this_key_subkeys",
            )
            dacl.save(obj_name=reg_path, protected=True)
        except CommandExecutionError:
            msg = 'Unable to securely set the permissions of "{}"'.format(reg_path)
            if is_console_configured():
                log.critical(msg)
            else:
                sys.stderr.write("CRITICAL: {}\n".format(msg))
    if salt.utils.win_functions.is_admin(current_user):
        try:
            salt.utils.win_dacl.set_owner(obj_name=path, principal="S-1-5-32-544")
        except CommandExecutionError:
            msg = "Unable to securely set the owner of {}".format(path)
            if is_console_configured():
                log.critical(msg)
            else:
                sys.stderr.write("CRITICAL: {}\n".format(msg))
        if not permissive:
            try:
                dacl = salt.utils.win_dacl.dacl()
                dacl.add_ace(
                    principal="S-1-5-32-544",
                    access_mode="grant",
                    permissions="full_control",
                    applies_to="this_folder_subfolders_files",
                )
                dacl.add_ace(
                    principal="S-1-5-18",
                    access_mode="grant",
                    permissions="full_control",
                    applies_to="this_folder_subfolders_files",
                )
                dacl.add_ace(
                    principal="S-1-3-4",
                    access_mode="grant",
                    permissions="full_control",
                    applies_to="this_folder_subfolders_files",
                )
                dacl.save(obj_name=path, protected=True)
            except CommandExecutionError:
                msg = 'Unable to securely set the permissions of "{}".'.format(path)
                if is_console_configured():
                    log.critical(msg)
                else:
                    sys.stderr.write("CRITICAL: {}\n".format(msg))
    for dir_ in dirs:
        if not dir_:
            continue
        if not os.path.isdir(dir_):
            try:
                os.makedirs(dir_)
            except OSError as err:
                msg = 'Failed to create directory path "{0}" - {1}\n'
                sys.stderr.write(msg.format(dir_, err))
                sys.exit(err.errno)
        if dir_ == pki_dir:
            try:
                salt.utils.win_dacl.set_owner(obj_name=path, principal="S-1-5-32-544")
                dacl = salt.utils.win_dacl.dacl()
                dacl.add_ace(
                    principal="S-1-5-32-544",
                    access_mode="grant",
                    permissions="full_control",
                    applies_to="this_folder_subfolders_files",
                )
                dacl.add_ace(
                    principal="S-1-5-18",
                    access_mode="grant",
                    permissions="full_control",
                    applies_to="this_folder_subfolders_files",
                )
                dacl.add_ace(
                    principal="S-1-3-4",
                    access_mode="grant",
                    permissions="full_control",
                    applies_to="this_folder_subfolders_files",
                )
                dacl.save(obj_name=dir_, protected=True)
            except CommandExecutionError:
                msg = 'Unable to securely set the permissions of "{0}".'
                msg = msg.format(dir_)
                if is_console_configured():
                    log.critical(msg)
                else:
                    sys.stderr.write("CRITICAL: {}\n".format(msg))
    if skip_extra is False:
        zmq_version()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
