<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_salt_call.py & verify.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_salt_call.py & verify.py
      </h3>
      <h1 align="center">
        1.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_salt_call.py (2.1416805%)<TH>verify.py (1.1035653%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match218022-0.html#0',2,'match218022-1.html#0',3)" NAME="0">(1-14)<TD><A HREF="javascript:ZweiFrames('match218022-0.html#0',2,'match218022-1.html#0',3)" NAME="0">(5-18)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_salt_call.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match218022-1.html#0',3,'match218022-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import copy
import logging
import os
import pprint
import re
import sys

import pytest
import salt.defaults.exitcodes
import salt.utils.files
import salt.utils.json
import salt.utils.platform
import salt.utils.yaml
from</B></FONT> tests.support.helpers import PRE_PYTEST_SKIP, PRE_PYTEST_SKIP_REASON, change_cwd

pytestmark = [
    pytest.mark.slow_test,
    pytest.mark.windows_whitelisted,
]

log = logging.getLogger(__name__)


def test_fib(salt_call_cli):
    ret = salt_call_cli.run(&quot;test.fib&quot;, &quot;3&quot;)
    assert ret.exitcode == 0
    assert ret.json[0] == 2


def test_fib_txt_output(salt_call_cli):
    ret = salt_call_cli.run(&quot;--output=txt&quot;, &quot;test.fib&quot;, &quot;3&quot;)
    assert ret.exitcode == 0
    assert ret.json is None
    assert (
        re.match(r&quot;local: \(2, [0-9]{1}\.(([0-9]+)(e-([0-9]+))?)\)\s&quot;, ret.stdout)
        is not None
    )


@pytest.mark.parametrize(&quot;indent&quot;, [-1, 0, 1])
def test_json_out_indent(salt_call_cli, indent):
    ret = salt_call_cli.run(&quot;--out=json&quot;, &quot;--out-indent={}&quot;.format(indent), &quot;test.ping&quot;)
    assert ret.exitcode == 0
    assert ret.json is True
    if indent == -1:
        expected_output = '{&quot;local&quot;: true}\n'
    elif indent == 0:
        expected_output = '{\n&quot;local&quot;: true\n}\n'
    else:
        expected_output = '{\n &quot;local&quot;: true\n}\n'
    stdout = ret.stdout
    assert ret.stdout == expected_output


def test_local_sls_call(salt_master, salt_call_cli):
    sls_contents = &quot;&quot;&quot;
    regular-module:
      module.run:
        - name: test.echo
        - text: hello
    &quot;&quot;&quot;
    with salt_master.state_tree.base.temp_file(&quot;saltcalllocal.sls&quot;, sls_contents):
        ret = salt_call_cli.run(
            &quot;--local&quot;,
            &quot;--file-root&quot;,
            str(salt_master.state_tree.base.paths[0]),
            &quot;state.sls&quot;,
            &quot;saltcalllocal&quot;,
        )
        assert ret.exitcode == 0
        state_run_dict = next(iter(ret.json.values()))
        assert state_run_dict[&quot;name&quot;] == &quot;test.echo&quot;
        assert state_run_dict[&quot;result&quot;] is True
        assert state_run_dict[&quot;changes&quot;][&quot;ret&quot;] == &quot;hello&quot;


def test_local_salt_call(salt_call_cli):
    &quot;&quot;&quot;
    This tests to make sure that salt-call does not execute the
    function twice, see https://github.com/saltstack/salt/pull/49552
    &quot;&quot;&quot;
    with pytest.helpers.temp_file() as filename:

        ret = salt_call_cli.run(
            &quot;--local&quot;, &quot;state.single&quot;, &quot;file.append&quot;, name=str(filename), text=&quot;foo&quot;
        )
        assert ret.exitcode == 0

        state_run_dict = next(iter(ret.json.values()))
        assert state_run_dict[&quot;changes&quot;]

        # 2nd sanity check: make sure that &quot;foo&quot; only exists once in the file
        contents = filename.read_text()
        assert contents.count(&quot;foo&quot;) == 1, contents


@pytest.mark.skip_on_windows(reason=PRE_PYTEST_SKIP_REASON)
def test_user_delete_kw_output(salt_call_cli):
    ret = salt_call_cli.run(&quot;-d&quot;, &quot;user.delete&quot;, _timeout=120)
    assert ret.exitcode == 0
    expected_output = &quot;salt '*' user.delete name&quot;
    if not salt.utils.platform.is_windows():
        expected_output += &quot; remove=True force=True&quot;
    assert expected_output in ret.stdout


def test_salt_documentation_too_many_arguments(salt_call_cli):
    &quot;&quot;&quot;
    Test to see if passing additional arguments shows an error
    &quot;&quot;&quot;
    ret = salt_call_cli.run(&quot;-d&quot;, &quot;virtualenv.create&quot;, &quot;/tmp/ve&quot;)
    assert ret.exitcode != 0
    assert &quot;You can only get documentation for one method at one time&quot; in ret.stderr


def test_issue_6973_state_highstate_exit_code(salt_call_cli):
    &quot;&quot;&quot;
    If there is no tops/master_tops or state file matches
    for this minion, salt-call should exit non-zero if invoked with
    option --retcode-passthrough
    &quot;&quot;&quot;
    expected_comment = &quot;No states found for this minion&quot;
    ret = salt_call_cli.run(&quot;--retcode-passthrough&quot;, &quot;state.highstate&quot;)
    assert ret.exitcode != 0
    assert expected_comment in ret.stdout


@PRE_PYTEST_SKIP
def test_issue_15074_output_file_append(salt_call_cli):

    with pytest.helpers.temp_file(name=&quot;issue-15074&quot;) as output_file_append:
        ret = salt_call_cli.run(
            &quot;--output-file&quot;, str(output_file_append), &quot;test.versions&quot;
        )
        assert ret.exitcode == 0

        first_run_output = output_file_append.read_text()

        assert first_run_output

        ret = salt_call_cli.run(
            &quot;--output-file&quot;,
            str(output_file_append),
            &quot;--output-file-append&quot;,
            &quot;test.versions&quot;,
        )
        assert ret.exitcode == 0

        second_run_output = output_file_append.read_text()

        assert second_run_output

        assert second_run_output == first_run_output + first_run_output


@PRE_PYTEST_SKIP
def test_issue_14979_output_file_permissions(salt_call_cli):
    with pytest.helpers.temp_file(name=&quot;issue-14979&quot;) as output_file:
        with salt.utils.files.set_umask(0o077):
            # Let's create an initial output file with some data
            ret = salt_call_cli.run(&quot;--output-file&quot;, str(output_file), &quot;--grains&quot;)
            assert ret.exitcode == 0
            try:
                stat1 = output_file.stat()
            except OSError:
                pytest.fail(&quot;Failed to generate output file {}&quot;.format(output_file))

            # Let's change umask
            os.umask(0o777)  # pylint: disable=blacklisted-function

            ret = salt_call_cli.run(
                &quot;--output-file&quot;, str(output_file), &quot;--output-file-append&quot;, &quot;--grains&quot;
            )
            assert ret.exitcode == 0
            stat2 = output_file.stat()
            assert stat1.st_mode == stat2.st_mode
            # Data was appeneded to file
            assert stat1.st_size &lt; stat2.st_size

            # Let's remove the output file
            output_file.unlink()

            # Not appending data
            ret = salt_call_cli.run(&quot;--output-file&quot;, str(output_file), &quot;--grains&quot;)
            assert ret.exitcode == 0
            try:
                stat3 = output_file.stat()
            except OSError:
                pytest.fail(&quot;Failed to generate output file {}&quot;.format(output_file))
            # Mode must have changed since we're creating a new log file
            assert stat1.st_mode != stat3.st_mode


@pytest.mark.skip_on_windows(reason=&quot;This test does not apply on Win&quot;)
def test_42116_cli_pillar_override(salt_call_cli):
    ret = salt_call_cli.run(
        &quot;state.apply&quot;,
        &quot;issue-42116-cli-pillar-override&quot;,
        pillar={&quot;myhost&quot;: &quot;localhost&quot;},
    )
    state_run_dict = next(iter(ret.json.values()))
    assert state_run_dict[&quot;changes&quot;]
    assert (
        state_run_dict[&quot;comment&quot;] == 'Command &quot;ping -c 2 localhost&quot; run'
    ), &quot;CLI pillar override not found in pillar data. State Run Dictionary:\n{}&quot;.format(
        pprint.pformat(state_run_dict)
    )


def test_pillar_items_masterless(salt_minion, salt_call_cli):
    &quot;&quot;&quot;
    Test to ensure we get expected output
    from pillar.items with salt-call
    &quot;&quot;&quot;
    top_file = &quot;&quot;&quot;
    base:
      '{}':
        - basic
    &quot;&quot;&quot;.format(
        salt_minion.id
    )
    basic_pillar_file = &quot;&quot;&quot;
    monty: python
    knights:
      - Lancelot
      - Galahad
      - Bedevere
      - Robin
    &quot;&quot;&quot;
    top_tempfile = salt_minion.pillar_tree.base.temp_file(&quot;top.sls&quot;, top_file)
    basic_tempfile = salt_minion.pillar_tree.base.temp_file(
        &quot;basic.sls&quot;, basic_pillar_file
    )

    with top_tempfile, basic_tempfile:
        ret = salt_call_cli.run(&quot;--local&quot;, &quot;pillar.items&quot;)
        assert ret.exitcode == 0
        assert &quot;knights&quot; in ret.json
        assert sorted(ret.json[&quot;knights&quot;]) == sorted(
            [&quot;Lancelot&quot;, &quot;Galahad&quot;, &quot;Bedevere&quot;, &quot;Robin&quot;]
        )
        assert &quot;monty&quot; in ret.json
        assert ret.json[&quot;monty&quot;] == &quot;python&quot;


def test_masterless_highstate(salt_minion, salt_call_cli, tmp_path):
    &quot;&quot;&quot;
    test state.highstate in masterless mode
    &quot;&quot;&quot;
    top_sls = &quot;&quot;&quot;
    base:
      '*':
        - core
        &quot;&quot;&quot;

    testfile = tmp_path / &quot;testfile&quot;
    core_state = &quot;&quot;&quot;
    {}:
      file:
        - managed
        - source: salt://testfile
        - makedirs: true
        &quot;&quot;&quot;.format(
        testfile
    )

    expected_id = str(testfile)

    with salt_minion.state_tree.base.temp_file(
        &quot;top.sls&quot;, top_sls
    ), salt_minion.state_tree.base.temp_file(&quot;core.sls&quot;, core_state):
        ret = salt_call_cli.run(&quot;--local&quot;, &quot;state.highstate&quot;)
        assert ret.exitcode == 0
        state_run_dict = next(iter(ret.json.values()))
        assert state_run_dict[&quot;result&quot;] is True
        assert state_run_dict[&quot;__id__&quot;] == expected_id


@pytest.mark.skip_on_windows
def test_syslog_file_not_found(salt_minion, salt_call_cli, tmp_path):
    &quot;&quot;&quot;
    test when log_file is set to a syslog file that does not exist
    &quot;&quot;&quot;
    config_dir = tmp_path / &quot;log_file_incorrect&quot;
    config_dir.mkdir()
    with change_cwd(str(config_dir)):
        minion_config = copy.deepcopy(salt_minion.config)
        minion_config[&quot;log_file&quot;] = &quot;file:///dev/doesnotexist&quot;
        with salt.utils.files.fopen(str(config_dir / &quot;minion&quot;), &quot;w&quot;) as fh_:
            fh_.write(salt.utils.yaml.dump(minion_config, default_flow_style=False))
        ret = salt_call_cli.run(
            &quot;--config-dir={}&quot;.format(config_dir),
            &quot;--log-level=debug&quot;,
            &quot;cmd.run&quot;,
            &quot;echo foo&quot;,
        )
        if sys.version_info &gt;= (3, 5, 4):
            assert ret.exitcode == 0
            assert (
                &quot;[WARNING ] The log_file does not exist. Logging not setup correctly or&quot;
                &quot; syslog service not started.&quot; in ret.stderr
            )
            assert ret.json == &quot;foo&quot;, ret
        else:
            assert ret.exitcode == 2
            assert &quot;Failed to setup the Syslog logging handler&quot; in ret.stderr


@PRE_PYTEST_SKIP
@pytest.mark.skip_on_windows
def test_return(salt_call_cli, salt_run_cli):
    command = &quot;echo returnTOmaster&quot;
    ret = salt_call_cli.run(&quot;cmd.run&quot;, command)
    assert ret.exitcode == 0
    assert ret.json == &quot;returnTOmaster&quot;

    ret = salt_run_cli.run(&quot;jobs.list_jobs&quot;)
    assert ret.exitcode == 0
    jid = target = None
    for jid, details in ret.json.items():
        if command in details[&quot;Arguments&quot;]:
            target = details[&quot;Target&quot;]
            break

    ret = salt_run_cli.run(&quot;jobs.lookup_jid&quot;, jid, _timeout=60)
    assert ret.exitcode == 0
    assert target in ret.json
    assert ret.json[target] == &quot;returnTOmaster&quot;


def test_exit_status_unknown_argument(salt_call_cli):
    &quot;&quot;&quot;
    Ensure correct exit status when an unknown argument is passed to salt CLI.
    &quot;&quot;&quot;
    ret = salt_call_cli.run(&quot;--unknown-argument&quot;)
    assert ret.exitcode == salt.defaults.exitcodes.EX_USAGE, ret
    assert &quot;Usage&quot; in ret.stderr
    assert &quot;no such option: --unknown-argument&quot; in ret.stderr


def test_exit_status_correct_usage(salt_call_cli):
    &quot;&quot;&quot;
    Ensure correct exit status when salt CLI starts correctly.

    &quot;&quot;&quot;
    ret = salt_call_cli.run(&quot;test.true&quot;)
    assert ret.exitcode == salt.defaults.exitcodes.EX_OK, ret


def test_context_retcode_salt_call(salt_call_cli):
    &quot;&quot;&quot;
    Test that a nonzero retcode set in the context dunder will cause the
    salt CLI to set a nonzero retcode.
    &quot;&quot;&quot;
    # Test salt-call, making sure to also confirm the behavior of
    # retcode_passthrough.
    ret = salt_call_cli.run(&quot;test.retcode&quot;, &quot;0&quot;)
    assert ret.exitcode == 0, ret
    ret = salt_call_cli.run(&quot;test.retcode&quot;, &quot;42&quot;)
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret
    ret = salt_call_cli.run(&quot;--retcode-passthrough&quot;, &quot;test.retcode&quot;, &quot;42&quot;)
    assert ret.exitcode == 42, ret

    # Test a state run that exits with one or more failures
    ret = salt_call_cli.run(&quot;state.single&quot;, &quot;test.fail_without_changes&quot;, &quot;foo&quot;)
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret
    ret = salt_call_cli.run(
        &quot;--retcode-passthrough&quot;, &quot;state.single&quot;, &quot;test.fail_without_changes&quot;, &quot;foo&quot;
    )
    assert ret.exitcode == salt.defaults.exitcodes.EX_STATE_FAILURE, ret

    # Test a state compiler error
    ret = salt_call_cli.run(&quot;state.apply&quot;, &quot;thisslsfiledoesnotexist&quot;)
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret
    ret = salt_call_cli.run(
        &quot;--retcode-passthrough&quot;, &quot;state.apply&quot;, &quot;thisslsfiledoesnotexist&quot;
    )
    assert ret.exitcode == salt.defaults.exitcodes.EX_STATE_COMPILER_ERROR, ret


def test_salt_call_error(salt_call_cli):
    &quot;&quot;&quot;
    Test that we return the expected retcode when a minion function raises
    an exception.
    &quot;&quot;&quot;
    ret = salt_call_cli.run(&quot;test.raise_exception&quot;, &quot;TypeError&quot;)
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret

    ret = salt_call_cli.run(
        &quot;test.raise_exception&quot;, &quot;salt.exceptions.CommandNotFoundError&quot;
    )
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret

    ret = salt_call_cli.run(
        &quot;test.raise_exception&quot;, &quot;salt.exceptions.CommandExecutionError&quot;
    )
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret

    ret = salt_call_cli.run(
        &quot;test.raise_exception&quot;, &quot;salt.exceptions.SaltInvocationError&quot;
    )
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret

    ret = salt_call_cli.run(
        &quot;test.raise_exception&quot;,
        &quot;OSError&quot;,
        &quot;2&quot;,
        &quot;No such file or directory&quot;,
        &quot;/tmp/foo.txt&quot;,
    )
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret

    ret = salt_call_cli.run(&quot;test.echo&quot;, &quot;{foo: bar, result: False}&quot;)
    assert ret.exitcode == salt.defaults.exitcodes.EX_GENERIC, ret


def test_local_salt_call_no_function_no_retcode(salt_call_cli):
    &quot;&quot;&quot;
    This tests ensures that when salt-call --local is called
    with a module but without a function the return code is 1
    and we receive the docs for all module functions.

    Also ensure we don't get an exception.
    &quot;&quot;&quot;
    with pytest.helpers.temp_file() as filename:

        ret = salt_call_cli.run(&quot;--local&quot;, &quot;test&quot;)
        assert ret.exitcode == 1

        state_run_dict = ret.json
        assert &quot;test&quot; in state_run_dict
        assert state_run_dict[&quot;test&quot;] == &quot;'test' is not available.&quot;

        assert &quot;test.recho&quot; in state_run_dict

        expected = &quot;&quot;&quot;
    Return a reversed string

    CLI Example:

        salt '*' test.recho 'foo bar baz quo qux'
    &quot;&quot;&quot;
        a = state_run_dict[&quot;test.recho&quot;]
        b = expected
        assert state_run_dict[&quot;test.recho&quot;] == expected
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>verify.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
<A NAME="0"></A>A few checks to make sure the environment is sane
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match218022-0.html#0',2,'match218022-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import errno
import itertools
import logging
import os
import re
import socket
import stat
import sys

import salt.defaults.exitcodes
import salt.utils.files
import salt.utils.path
import salt.utils.platform
import</B></FONT> salt.utils.user
from salt.exceptions import CommandExecutionError, SaltClientError, SaltSystemExit
from salt.log import is_console_configured
from salt.log.setup import LOG_LEVELS

# Original Author: Jeff Schroeder &lt;jeffschroeder@computer.org&gt;


try:
    import win32file
    import salt.utils.win_reg
except ImportError:
    import resource

log = logging.getLogger(__name__)

ROOT_DIR = &quot;c:\\salt&quot; if salt.utils.platform.is_windows() else &quot;/&quot;
DEFAULT_SCHEMES = [&quot;tcp://&quot;, &quot;udp://&quot;, &quot;file://&quot;]


def zmq_version():
    &quot;&quot;&quot;
    ZeroMQ python bindings &gt;= 2.1.9 are required
    &quot;&quot;&quot;
    try:
        import zmq
    except Exception:  # pylint: disable=broad-except
        # Return True for local mode
        return True
    ver = zmq.__version__
    # The last matched group can be None if the version
    # is something like 3.1 and that will work properly
    match = re.match(r&quot;^(\d+)\.(\d+)(?:\.(\d+))?&quot;, ver)

    # Fallthrough and hope for the best
    if not match:
        msg = &quot;Using untested zmq python bindings version: '{}'&quot;.format(ver)
        if is_console_configured():
            log.warning(msg)
        else:
            sys.stderr.write(&quot;WARNING {}\n&quot;.format(msg))
        return True

    major, minor, point = match.groups()

    if major.isdigit():
        major = int(major)
    if minor.isdigit():
        minor = int(minor)

    # point very well could be None
    if point and point.isdigit():
        point = int(point)

    if major == 2 and minor == 1:
        # zmq 2.1dev could be built against a newer libzmq
        if &quot;dev&quot; in ver and not point:
            msg = &quot;Using dev zmq module, please report unexpected results&quot;
            if is_console_configured():
                log.warning(msg)
            else:
                sys.stderr.write(&quot;WARNING: {}\n&quot;.format(msg))
            return True
        elif point and point &gt;= 9:
            return True
    elif major &gt; 2 or (major == 2 and minor &gt; 1):
        return True

    # If all else fails, gracefully croak and warn the user
    log.critical(&quot;ZeroMQ python bindings &gt;= 2.1.9 are required&quot;)
    if &quot;salt-master&quot; in sys.argv[0]:
        msg = (
            &quot;The Salt Master is unstable using a ZeroMQ version &quot;
            &quot;lower than 2.1.11 and requires this fix: http://lists.zeromq.&quot;
            &quot;org/pipermail/zeromq-dev/2011-June/012094.html&quot;
        )
        if is_console_configured():
            log.critical(msg)
        else:
            sys.stderr.write(&quot;CRITICAL {}\n&quot;.format(msg))
    return False


def lookup_family(hostname):
    &quot;&quot;&quot;
    Lookup a hostname and determine its address family. The first address returned
    will be AF_INET6 if the system is IPv6-enabled, and AF_INET otherwise.
    &quot;&quot;&quot;
    # If lookups fail, fall back to AF_INET sockets (and v4 addresses).
    fallback = socket.AF_INET
    try:
        hostnames = socket.getaddrinfo(
            hostname or None, None, socket.AF_UNSPEC, socket.SOCK_STREAM
        )
        if not hostnames:
            return fallback
        h = hostnames[0]
        return h[0]
    except socket.gaierror:
        return fallback


def verify_socket(interface, pub_port, ret_port):
    &quot;&quot;&quot;
    Attempt to bind to the sockets to verify that they are available
    &quot;&quot;&quot;

    addr_family = lookup_family(interface)
    for port in pub_port, ret_port:
        sock = socket.socket(addr_family, socket.SOCK_STREAM)
        try:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((interface, int(port)))
        except Exception as exc:  # pylint: disable=broad-except
            msg = &quot;Unable to bind socket {}:{}&quot;.format(interface, port)
            if exc.args:
                msg = &quot;{}, error: {}&quot;.format(msg, str(exc))
            else:
                msg = &quot;{}, this might not be a problem.&quot;.format(msg)
            msg += &quot;; Is there another salt-master running?&quot;
            if is_console_configured():
                log.warning(msg)
            else:
                sys.stderr.write(&quot;WARNING: {}\n&quot;.format(msg))
            return False
        finally:
            sock.close()

    return True


def verify_logs_filter(files):
    to_verify = []
    for filename in files:
        verify_file = True
        for scheme in DEFAULT_SCHEMES:
            if filename.startswith(scheme):
                verify_file = False
                break
        if verify_file:
            to_verify.append(filename)
    return to_verify


def verify_log_files(files, user):
    &quot;&quot;&quot;
    Verify the log files exist and are owned by the named user.  Filenames that
    begin with tcp:// and udp:// will be filtered out. Filenames that begin
    with file:// are handled correctly
    &quot;&quot;&quot;
    return verify_files(verify_logs_filter(files), user)


def _get_pwnam(user):
    &quot;&quot;&quot;
    Get the user from passwords database
    &quot;&quot;&quot;
    if salt.utils.platform.is_windows():
        return True
    import pwd  # after confirming not running Windows

    try:
        return pwd.getpwnam(user)
    except KeyError:
        msg = (
            &quot;Failed to prepare the Salt environment for user {}. The user is not&quot;
            &quot; available.&quot;.format(user)
        )
        if is_console_configured():
            log.critical(msg)
        else:
            print(msg, file=sys.stderr, flush=True)
        sys.exit(salt.defaults.exitcodes.EX_NOUSER)


def verify_files(files, user):
    &quot;&quot;&quot;
    Verify that the named files exist and are owned by the named user
    &quot;&quot;&quot;
    if salt.utils.platform.is_windows():
        return True

    # after confirming not running Windows
    pwnam = _get_pwnam(user)
    uid = pwnam[2]

    for fn_ in files:
        dirname = os.path.dirname(fn_)
        try:
            if dirname:
                try:
                    os.makedirs(dirname)
                except OSError as err:
                    if err.errno != errno.EEXIST:
                        raise
            if not os.path.isfile(fn_):
                with salt.utils.files.fopen(fn_, &quot;w&quot;):
                    pass

        except OSError as err:
            if os.path.isfile(dirname):
                msg = &quot;Failed to create path {}, is {} a file?&quot;.format(fn_, dirname)
                raise SaltSystemExit(msg=msg)
            if err.errno != errno.EACCES:
                raise
            msg = 'No permissions to access &quot;{}&quot;, are you running as the correct user?'.format(
                fn_
            )
            raise SaltSystemExit(msg=msg)

        except OSError as err:  # pylint: disable=duplicate-except
            msg = 'Failed to create path &quot;{}&quot; - {}'.format(fn_, err)
            raise SaltSystemExit(msg=msg)

        stats = os.stat(fn_)
        if uid != stats.st_uid:
            try:
                os.chown(fn_, uid, -1)
            except OSError:
                pass
    return True


def verify_env(
    dirs, user, permissive=False, pki_dir=&quot;&quot;, skip_extra=False, root_dir=ROOT_DIR
):
    &quot;&quot;&quot;
    Verify that the named directories are in place and that the environment
    can shake the salt
    &quot;&quot;&quot;
    if salt.utils.platform.is_windows():
        return win_verify_env(
            root_dir, dirs, permissive=permissive, skip_extra=skip_extra
        )

    # after confirming not running Windows
    pwnam = _get_pwnam(user)
    uid = pwnam[2]
    gid = pwnam[3]
    groups = salt.utils.user.get_gid_list(user, include_default=False)

    for dir_ in dirs:
        if not dir_:
            continue
        if not os.path.isdir(dir_):
            try:
                with salt.utils.files.set_umask(0o022):
                    os.makedirs(dir_)
                # If starting the process as root, chown the new dirs
                if os.getuid() == 0:
                    os.chown(dir_, uid, gid)
            except OSError as err:
                msg = 'Failed to create directory path &quot;{0}&quot; - {1}\n'
                sys.stderr.write(msg.format(dir_, err))
                sys.exit(err.errno)

        mode = os.stat(dir_)
        # If starting the process as root, chown the new dirs
        if os.getuid() == 0:
            fmode = os.stat(dir_)
            if fmode.st_uid != uid or fmode.st_gid != gid:
                if permissive and fmode.st_gid in groups:
                    # Allow the directory to be owned by any group root
                    # belongs to if we say it's ok to be permissive
                    pass
                else:
                    # chown the file for the new user
                    os.chown(dir_, uid, gid)
            for subdir in [a for a in os.listdir(dir_) if &quot;jobs&quot; not in a]:
                fsubdir = os.path.join(dir_, subdir)
                if &quot;{}jobs&quot;.format(os.path.sep) in fsubdir:
                    continue
                for root, dirs, files in salt.utils.path.os_walk(fsubdir):
                    for name in itertools.chain(files, dirs):
                        if name.startswith(&quot;.&quot;):
                            continue
                        path = os.path.join(root, name)
                        try:
                            fmode = os.stat(path)
                            if fmode.st_uid != uid or fmode.st_gid != gid:
                                if permissive and fmode.st_gid in groups:
                                    pass
                                else:
                                    # chown the file for the new user
                                    os.chown(path, uid, gid)
                        except OSError:
                            continue

        # Allow the pki dir to be 700 or 750, but nothing else.
        # This prevents other users from writing out keys, while
        # allowing the use-case of 3rd-party software (like django)
        # to read in what it needs to integrate.
        #
        # If the permissions aren't correct, default to the more secure 700.
        # If acls are enabled, the pki_dir needs to remain readable, this
        # is still secure because the private keys are still only readable
        # by the user running the master
        if dir_ == pki_dir:
            smode = stat.S_IMODE(mode.st_mode)
            if smode != 448 and smode != 488:
                if os.access(dir_, os.W_OK):
                    os.chmod(dir_, 448)
                else:
                    msg = 'Unable to securely set the permissions of &quot;{0}&quot;.'
                    msg = msg.format(dir_)
                    if is_console_configured():
                        log.critical(msg)
                    else:
                        sys.stderr.write(&quot;CRITICAL: {}\n&quot;.format(msg))

    if skip_extra is False:
        # Run the extra verification checks
        zmq_version()


def check_user(user):
    &quot;&quot;&quot;
    Check user and assign process uid/gid.
    &quot;&quot;&quot;
    if salt.utils.platform.is_windows():
        return True
    if user == salt.utils.user.get_user():
        return True

    # after confirming not running Windows
    pwuser = _get_pwnam(user)

    try:
        if hasattr(os, &quot;initgroups&quot;):
            os.initgroups(user, pwuser.pw_gid)  # pylint: disable=minimum-python-version
        else:
            os.setgroups(salt.utils.user.get_gid_list(user, include_default=False))
        os.setgid(pwuser.pw_gid)
        os.setuid(pwuser.pw_uid)

        # We could just reset the whole environment but let's just override
        # the variables we can get from pwuser
        if &quot;HOME&quot; in os.environ:
            os.environ[&quot;HOME&quot;] = pwuser.pw_dir

        if &quot;SHELL&quot; in os.environ:
            os.environ[&quot;SHELL&quot;] = pwuser.pw_shell

        for envvar in (&quot;USER&quot;, &quot;LOGNAME&quot;):
            if envvar in os.environ:
                os.environ[envvar] = pwuser.pw_name

    except OSError:
        msg = 'Salt configured to run as user &quot;{}&quot; but unable to switch.'.format(user)
        if is_console_configured():
            log.critical(msg)
        else:
            sys.stderr.write(&quot;CRITICAL: {}\n&quot;.format(msg))
        return False
    return True


def list_path_traversal(path):
    &quot;&quot;&quot;
    Returns a full list of directories leading up to, and including, a path.

    So list_path_traversal('/path/to/salt') would return:
        ['/', '/path', '/path/to', '/path/to/salt']
    in that order.

    This routine has been tested on Windows systems as well.
    list_path_traversal('c:\\path\\to\\salt') on Windows would return:
        ['c:\\', 'c:\\path', 'c:\\path\\to', 'c:\\path\\to\\salt']
    &quot;&quot;&quot;
    out = [path]
    (head, tail) = os.path.split(path)
    if tail == &quot;&quot;:
        # paths with trailing separators will return an empty string
        out = [head]
        (head, tail) = os.path.split(head)
    while head != out[0]:
        # loop until head is the same two consecutive times
        out.insert(0, head)
        (head, tail) = os.path.split(head)
    return out


def check_path_traversal(path, user=&quot;root&quot;, skip_perm_errors=False):
    &quot;&quot;&quot;
    Walk from the root up to a directory and verify that the current
    user has access to read each directory. This is used for  making
    sure a user can read all parent directories of the minion's  key
    before trying to go and generate a new key and raising an IOError
    &quot;&quot;&quot;
    for tpath in list_path_traversal(path):
        if not os.access(tpath, os.R_OK):
            msg = &quot;Could not access {}.&quot;.format(tpath)
            if not os.path.exists(tpath):
                msg += &quot; Path does not exist.&quot;
            else:
                current_user = salt.utils.user.get_user()
                # Make the error message more intelligent based on how
                # the user invokes salt-call or whatever other script.
                if user != current_user:
                    msg += &quot; Try running as user {}.&quot;.format(user)
                else:
                    msg += &quot; Please give {} read permissions.&quot;.format(user)

            # We don't need to bail on config file permission errors
            # if the CLI
            # process is run with the -a flag
            if skip_perm_errors:
                return
            # Propagate this exception up so there isn't a sys.exit()
            # in the middle of code that could be imported elsewhere.
            raise SaltClientError(msg)


def check_max_open_files(opts):
    &quot;&quot;&quot;
    Check the number of max allowed open files and adjust if needed
    &quot;&quot;&quot;
    mof_c = opts.get(&quot;max_open_files&quot;, 100000)
    if sys.platform.startswith(&quot;win&quot;):
        # Check the Windows API for more detail on this
        # http://msdn.microsoft.com/en-us/library/xt874334(v=vs.71).aspx
        # and the python binding http://timgolden.me.uk/pywin32-docs/win32file.html
        mof_s = mof_h = win32file._getmaxstdio()
    else:
        mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)

    accepted_keys_dir = os.path.join(opts.get(&quot;pki_dir&quot;), &quot;minions&quot;)
    accepted_count = len(os.listdir(accepted_keys_dir))

    log.debug(&quot;This salt-master instance has accepted %s minion keys.&quot;, accepted_count)

    level = logging.INFO

    if (accepted_count * 4) &lt;= mof_s:
        # We check for the soft value of max open files here because that's the
        # value the user chose to raise to.
        #
        # The number of accepted keys multiplied by four(4) is lower than the
        # soft value, everything should be OK
        return

    msg = (
        &quot;The number of accepted minion keys({}) should be lower than 1/4 &quot;
        &quot;of the max open files soft setting({}). &quot;.format(accepted_count, mof_s)
    )

    if accepted_count &gt;= mof_s:
        # This should never occur, it might have already crashed
        msg += &quot;salt-master will crash pretty soon! &quot;
        level = logging.CRITICAL
    elif (accepted_count * 2) &gt;= mof_s:
        # This is way too low, CRITICAL
        level = logging.CRITICAL
    elif (accepted_count * 3) &gt;= mof_s:
        level = logging.WARNING
        # The accepted count is more than 3 time, WARN
    elif (accepted_count * 4) &gt;= mof_s:
        level = logging.INFO

    if mof_c &lt; mof_h:
        msg += (
            &quot;According to the system's hard limit, there's still a &quot;
            &quot;margin of {} to raise the salt's max_open_files &quot;
            &quot;setting. &quot;.format(mof_h - mof_c)
        )

    msg += &quot;Please consider raising this value.&quot;
    log.log(level=level, msg=msg)


def _realpath_darwin(path):
    base = &quot;&quot;
    for part in path.split(os.path.sep)[1:]:
        if base != &quot;&quot;:
            if os.path.islink(os.path.sep.join([base, part])):
                base = os.readlink(os.path.sep.join([base, part]))
            else:
                base = os.path.abspath(os.path.sep.join([base, part]))
        else:
            base = os.path.abspath(os.path.sep.join([base, part]))
    return base


def _realpath_windows(path):
    base = &quot;&quot;
    for part in path.split(os.path.sep):
        if base != &quot;&quot;:
            try:
                # Need to use salt.utils.path.readlink as it handles junctions
                part = salt.utils.path.readlink(os.path.sep.join([base, part]))
                base = os.path.abspath(part)
            except OSError:
                base = os.path.abspath(os.path.sep.join([base, part]))
        else:
            base = part
    return base


def _realpath(path):
    &quot;&quot;&quot;
    Cross platform realpath method. On Windows when python 3, this method
    uses the os.readlink method to resolve any filesystem links.
    All other platforms and version use ``os.path.realpath``.
    &quot;&quot;&quot;
    if salt.utils.platform.is_darwin():
        return _realpath_darwin(path)
    elif salt.utils.platform.is_windows():
        return _realpath_windows(path)
    return os.path.realpath(path)


def clean_path(root, path, subdir=False):
    &quot;&quot;&quot;
    Accepts the root the path needs to be under and verifies that the path is
    under said root. Pass in subdir=True if the path can result in a
    subdirectory of the root instead of having to reside directly in the root
    &quot;&quot;&quot;
    real_root = _realpath(root)
    if not os.path.isabs(real_root):
        return &quot;&quot;
    if not os.path.isabs(path):
        path = os.path.join(root, path)
    path = os.path.normpath(path)
    real_path = _realpath(path)
    if subdir:
        if real_path.startswith(real_root):
            return real_path
    else:
        if os.path.dirname(real_path) == os.path.normpath(real_root):
            return real_path
    return &quot;&quot;


def valid_id(opts, id_):
    &quot;&quot;&quot;
    Returns if the passed id is valid
    &quot;&quot;&quot;
    try:
        if any(x in id_ for x in (&quot;/&quot;, &quot;\\&quot;, &quot;\0&quot;)):
            return False
        return bool(clean_path(opts[&quot;pki_dir&quot;], id_))
    except (AttributeError, KeyError, TypeError, UnicodeDecodeError):
        return False


def safe_py_code(code):
    &quot;&quot;&quot;
    Check a string to see if it has any potentially unsafe routines which
    could be executed via python, this routine is used to improve the
    safety of modules suct as virtualenv
    &quot;&quot;&quot;
    bads = (&quot;import&quot;, &quot;;&quot;, &quot;subprocess&quot;, &quot;eval&quot;, &quot;open&quot;, &quot;file&quot;, &quot;exec&quot;, &quot;input&quot;)
    for bad in bads:
        if code.count(bad):
            return False
    return True


def verify_log(opts):
    &quot;&quot;&quot;
    If an insecre logging configuration is found, show a warning
    &quot;&quot;&quot;
    level = LOG_LEVELS.get(str(opts.get(&quot;log_level&quot;)).lower(), logging.NOTSET)

    if level &lt; logging.INFO:
        log.warning(
            &quot;Insecure logging configuration detected! Sensitive data may be logged.&quot;
        )


def win_verify_env(path, dirs, permissive=False, pki_dir=&quot;&quot;, skip_extra=False):
    &quot;&quot;&quot;
    Verify that the named directories are in place and that the environment
    can shake the salt
    &quot;&quot;&quot;
    import salt.utils.win_functions
    import salt.utils.win_dacl
    import salt.utils.path

    # Make sure the file_roots is not set to something unsafe since permissions
    # on that directory are reset

    # `salt.utils.path.safe_path` will consider anything inside `C:\Windows` to
    # be unsafe. In some instances the test suite uses
    # `C:\Windows\Temp\salt-tests-tmpdir\rootdir` as the file_roots. So, we need
    # to consider anything in `C:\Windows\Temp` to be safe
    system_root = os.environ.get(&quot;SystemRoot&quot;, r&quot;C:\Windows&quot;)
    allow_path = &quot;\\&quot;.join([system_root, &quot;TEMP&quot;])
    if not salt.utils.path.safe_path(path=path, allow_path=allow_path):
        raise CommandExecutionError(
            &quot;`file_roots` set to a possibly unsafe location: {}&quot;.format(path)
        )

    # Create the root path directory if missing
    if not os.path.isdir(path):
        os.makedirs(path)

    current_user = salt.utils.win_functions.get_current_user()
    # Set permissions to the registry key
    if salt.utils.win_functions.is_admin(current_user):
        reg_path = &quot;HKLM\\SOFTWARE\\Salt Project\\salt&quot;
        if not salt.utils.win_reg.key_exists(
            hive=&quot;HKLM&quot;, key=&quot;SOFTWARE\\Salt Project\\salt&quot;
        ):
            salt.utils.win_reg.set_value(
                hive=&quot;HKLM&quot;, key=&quot;SOFTWARE\\Salt Project\\salt&quot;
            )
        try:
            # Make the Administrators group owner
            # Use the SID to be locale agnostic
            salt.utils.win_dacl.set_owner(
                obj_name=reg_path, principal=&quot;S-1-5-32-544&quot;, obj_type=&quot;registry&quot;
            )
        except CommandExecutionError:
            msg = 'Unable to securely set the owner of &quot;{}&quot;.'.format(reg_path)
            if is_console_configured():
                log.critical(msg)
            else:
                sys.stderr.write(&quot;CRITICAL: {}\n&quot;.format(msg))

        try:
            # Get a clean dacl by not passing an obj_name
            dacl = salt.utils.win_dacl.dacl(obj_type=&quot;registry&quot;)

            # Add aces to the dacl, use the GUID (locale non-specific)
            # Administrators Group
            dacl.add_ace(
                principal=&quot;S-1-5-32-544&quot;,
                access_mode=&quot;grant&quot;,
                permissions=&quot;full_control&quot;,
                applies_to=&quot;this_key_subkeys&quot;,
            )
            # System
            dacl.add_ace(
                principal=&quot;S-1-5-18&quot;,
                access_mode=&quot;grant&quot;,
                permissions=&quot;full_control&quot;,
                applies_to=&quot;this_key_subkeys&quot;,
            )
            # Owner
            dacl.add_ace(
                principal=&quot;S-1-3-4&quot;,
                access_mode=&quot;grant&quot;,
                permissions=&quot;full_control&quot;,
                applies_to=&quot;this_key_subkeys&quot;,
            )

            # Save the dacl to the object
            dacl.save(obj_name=reg_path, protected=True)

        except CommandExecutionError:
            msg = 'Unable to securely set the permissions of &quot;{}&quot;'.format(reg_path)
            if is_console_configured():
                log.critical(msg)
            else:
                sys.stderr.write(&quot;CRITICAL: {}\n&quot;.format(msg))

    # Set permissions to the root path directory
    if salt.utils.win_functions.is_admin(current_user):
        try:
            # Make the Administrators group owner
            # Use the SID to be locale agnostic
            salt.utils.win_dacl.set_owner(obj_name=path, principal=&quot;S-1-5-32-544&quot;)

        except CommandExecutionError:
            msg = &quot;Unable to securely set the owner of {}&quot;.format(path)
            if is_console_configured():
                log.critical(msg)
            else:
                sys.stderr.write(&quot;CRITICAL: {}\n&quot;.format(msg))

        if not permissive:
            try:
                # Get a clean dacl by not passing an obj_name
                dacl = salt.utils.win_dacl.dacl()

                # Add aces to the dacl, use the GUID (locale non-specific)
                # Administrators Group
                dacl.add_ace(
                    principal=&quot;S-1-5-32-544&quot;,
                    access_mode=&quot;grant&quot;,
                    permissions=&quot;full_control&quot;,
                    applies_to=&quot;this_folder_subfolders_files&quot;,
                )
                # System
                dacl.add_ace(
                    principal=&quot;S-1-5-18&quot;,
                    access_mode=&quot;grant&quot;,
                    permissions=&quot;full_control&quot;,
                    applies_to=&quot;this_folder_subfolders_files&quot;,
                )
                # Owner
                dacl.add_ace(
                    principal=&quot;S-1-3-4&quot;,
                    access_mode=&quot;grant&quot;,
                    permissions=&quot;full_control&quot;,
                    applies_to=&quot;this_folder_subfolders_files&quot;,
                )

                # Save the dacl to the object
                dacl.save(obj_name=path, protected=True)

            except CommandExecutionError:
                msg = 'Unable to securely set the permissions of &quot;{}&quot;.'.format(path)
                if is_console_configured():
                    log.critical(msg)
                else:
                    sys.stderr.write(&quot;CRITICAL: {}\n&quot;.format(msg))

    # Create the directories
    for dir_ in dirs:
        if not dir_:
            continue
        if not os.path.isdir(dir_):
            try:
                os.makedirs(dir_)
            except OSError as err:
                msg = 'Failed to create directory path &quot;{0}&quot; - {1}\n'
                sys.stderr.write(msg.format(dir_, err))
                sys.exit(err.errno)

        # The PKI dir gets its own permissions
        if dir_ == pki_dir:
            try:
                # Make Administrators group the owner
                salt.utils.win_dacl.set_owner(obj_name=path, principal=&quot;S-1-5-32-544&quot;)

                # Give Admins, System and Owner permissions
                # Get a clean dacl by not passing an obj_name
                dacl = salt.utils.win_dacl.dacl()

                # Add aces to the dacl, use the GUID (locale non-specific)
                # Administrators Group
                dacl.add_ace(
                    principal=&quot;S-1-5-32-544&quot;,
                    access_mode=&quot;grant&quot;,
                    permissions=&quot;full_control&quot;,
                    applies_to=&quot;this_folder_subfolders_files&quot;,
                )
                # System
                dacl.add_ace(
                    principal=&quot;S-1-5-18&quot;,
                    access_mode=&quot;grant&quot;,
                    permissions=&quot;full_control&quot;,
                    applies_to=&quot;this_folder_subfolders_files&quot;,
                )
                # Owner
                dacl.add_ace(
                    principal=&quot;S-1-3-4&quot;,
                    access_mode=&quot;grant&quot;,
                    permissions=&quot;full_control&quot;,
                    applies_to=&quot;this_folder_subfolders_files&quot;,
                )

                # Save the dacl to the object
                dacl.save(obj_name=dir_, protected=True)

            except CommandExecutionError:
                msg = 'Unable to securely set the permissions of &quot;{0}&quot;.'
                msg = msg.format(dir_)
                if is_console_configured():
                    log.critical(msg)
                else:
                    sys.stderr.write(&quot;CRITICAL: {}\n&quot;.format(msg))

    if skip_extra is False:
        # Run the extra verification checks
        zmq_version()
</PRE>
</div>
  </div>
</body>
</html>
