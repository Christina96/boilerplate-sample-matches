<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_salt_call.py &amp; verify.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_salt_call.py &amp; verify.py
      </h3>
<h1 align="center">
        1.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_salt_call.py (2.1416805%)<th>verify.py (1.1035653%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-14)<td><a href="#" name="0">(5-18)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_salt_call.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import os
3 import pprint
4 import re
5 import sys
6 import pytest
7 import salt.defaults.exitcodes
8 import salt.utils.files
9 import salt.utils.json
10 import salt.utils.platform
11 import salt.utils.yaml
12 from</b></font> tests.support.helpers import PRE_PYTEST_SKIP, PRE_PYTEST_SKIP_REASON, change_cwd
13 pytestmark = [
14     pytest.mark.slow_test,
15     pytest.mark.windows_whitelisted,
16 ]
17 log = logging.getLogger(__name__)
18 def test_fib(salt_call_cli):
19     ret = salt_call_cli.run("test.fib", "3")
20     assert ret.exitcode == 0
21     assert ret.json[0] == 2
22 def test_fib_txt_output(salt_call_cli):
23     ret = salt_call_cli.run("--output=txt", "test.fib", "3")
24     assert ret.exitcode == 0
25     assert ret.json is None
26     assert (
27         re.match(r"local: \(2, [0-9]{1}\.(([0-9]+)(e-([0-9]+))?)\)\s", ret.stdout)
28         is not None
29     )
30 @pytest.mark.parametrize("indent", [-1, 0, 1])
31 def test_json_out_indent(salt_call_cli, indent):
32     ret = salt_call_cli.run("--out=json", "--out-indent={}".format(indent), "test.ping")
33     assert ret.exitcode == 0
34     assert ret.json is True
35     if indent == -1:
36         expected_output = '{"local": true}\n'
37     elif indent == 0:
38         expected_output = '{\n"local": true\n}\n'
39     else:
40         expected_output = '{\n "local": true\n}\n'
41     stdout = ret.stdout
42     assert ret.stdout == expected_output
43 def test_local_sls_call(salt_master, salt_call_cli):
44     sls_contents = """
45     regular-module:
46       module.run:
47         - name: test.echo
48         - text: hello
49     This tests to make sure that salt-call does not execute the
50     function twice, see https://github.com/saltstack/salt/pull/49552
51     Test to see if passing additional arguments shows an error
52     If there is no tops/master_tops or state file matches
53     for this minion, salt-call should exit non-zero if invoked with
54     option --retcode-passthrough
55     Test to ensure we get expected output
56     from pillar.items with salt-call
57         salt_minion.id
58     )
59     basic_pillar_file = """
60     monty: python
61     knights:
62       - Lancelot
63       - Galahad
64       - Bedevere
65       - Robin
66     test state.highstate in masterless mode
67     testfile = tmp_path / "testfile"
68     core_state = """
69     {}:
70       file:
71         - managed
72         - source: salt://testfile
73         - makedirs: true
74     test when log_file is set to a syslog file that does not exist
75     Ensure correct exit status when an unknown argument is passed to salt CLI.
76     Ensure correct exit status when salt CLI starts correctly.
77     Test that a nonzero retcode set in the context dunder will cause the
78     salt CLI to set a nonzero retcode.
79     Test that we return the expected retcode when a minion function raises
80     an exception.
81     This tests ensures that when salt-call --local is called
82     with a module but without a function the return code is 1
83     and we receive the docs for all module functions.
84     Also ensure we don't get an exception.
85         a = state_run_dict["test.recho"]
86         b = expected
87         assert state_run_dict["test.recho"] == expected
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>verify.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import errno
2 import itertools
3 import logging
4 import os
5 import re
6 import socket
7 import stat
8 import sys
9 import salt.defaults.exitcodes
10 import salt.utils.files
11 import salt.utils.path
12 import salt.utils.platform
13 import</b></font> salt.utils.user
14 from salt.exceptions import CommandExecutionError, SaltClientError, SaltSystemExit
15 from salt.log import is_console_configured
16 from salt.log.setup import LOG_LEVELS
17 try:
18     import win32file
19     import salt.utils.win_reg
20 except ImportError:
21     import resource
22 log = logging.getLogger(__name__)
23 ROOT_DIR = "c:\\salt" if salt.utils.platform.is_windows() else "/"
24 DEFAULT_SCHEMES = ["tcp://", "udp://", "file://"]
25 def zmq_version():
26     try:
27         import zmq
28     except Exception:  # pylint: disable=broad-except
29         return True
30     ver = zmq.__version__
31     match = re.match(r"^(\d+)\.(\d+)(?:\.(\d+))?", ver)
32     if not match:
33         msg = "Using untested zmq python bindings version: '{}'".format(ver)
34         if is_console_configured():
35             log.warning(msg)
36         else:
37             sys.stderr.write("WARNING {}\n".format(msg))
38         return True
39     major, minor, point = match.groups()
40     if major.isdigit():
41         major = int(major)
42     if minor.isdigit():
43         minor = int(minor)
44     if point and point.isdigit():
45         point = int(point)
46     if major == 2 and minor == 1:
47         if "dev" in ver and not point:
48             msg = "Using dev zmq module, please report unexpected results"
49             if is_console_configured():
50                 log.warning(msg)
51             else:
52                 sys.stderr.write("WARNING: {}\n".format(msg))
53             return True
54         elif point and point &gt;= 9:
55             return True
56     elif major &gt; 2 or (major == 2 and minor &gt; 1):
57         return True
58     log.critical("ZeroMQ python bindings &gt;= 2.1.9 are required")
59     if "salt-master" in sys.argv[0]:
60         msg = (
61             "The Salt Master is unstable using a ZeroMQ version "
62             "lower than 2.1.11 and requires this fix: http://lists.zeromq."
63             "org/pipermail/zeromq-dev/2011-June/012094.html"
64         )
65         if is_console_configured():
66             log.critical(msg)
67         else:
68             sys.stderr.write("CRITICAL {}\n".format(msg))
69     return False
70 def lookup_family(hostname):
71     fallback = socket.AF_INET
72     try:
73         hostnames = socket.getaddrinfo(
74             hostname or None, None, socket.AF_UNSPEC, socket.SOCK_STREAM
75         )
76         if not hostnames:
77             return fallback
78         h = hostnames[0]
79         return h[0]
80     except socket.gaierror:
81         return fallback
82 def verify_socket(interface, pub_port, ret_port):
83     addr_family = lookup_family(interface)
84     for port in pub_port, ret_port:
85         sock = socket.socket(addr_family, socket.SOCK_STREAM)
86         try:
87             sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
88             sock.bind((interface, int(port)))
89         except Exception as exc:  # pylint: disable=broad-except
90             msg = "Unable to bind socket {}:{}".format(interface, port)
91             if exc.args:
92                 msg = "{}, error: {}".format(msg, str(exc))
93             else:
94                 msg = "{}, this might not be a problem.".format(msg)
95             msg += "; Is there another salt-master running?"
96             if is_console_configured():
97                 log.warning(msg)
98             else:
99                 sys.stderr.write("WARNING: {}\n".format(msg))
100             return False
101         finally:
102             sock.close()
103     return True
104 def verify_logs_filter(files):
105     to_verify = []
106     for filename in files:
107         verify_file = True
108         for scheme in DEFAULT_SCHEMES:
109             if filename.startswith(scheme):
110                 verify_file = False
111                 break
112         if verify_file:
113             to_verify.append(filename)
114     return to_verify
115 def verify_log_files(files, user):
116     return verify_files(verify_logs_filter(files), user)
117 def _get_pwnam(user):
118     if salt.utils.platform.is_windows():
119         return True
120     import pwd  # after confirming not running Windows
121     try:
122         return pwd.getpwnam(user)
123     except KeyError:
124         msg = (
125             "Failed to prepare the Salt environment for user {}. The user is not"
126             " available.".format(user)
127         )
128         if is_console_configured():
129             log.critical(msg)
130         else:
131             print(msg, file=sys.stderr, flush=True)
132         sys.exit(salt.defaults.exitcodes.EX_NOUSER)
133 def verify_files(files, user):
134     if salt.utils.platform.is_windows():
135         return True
136     pwnam = _get_pwnam(user)
137     uid = pwnam[2]
138     for fn_ in files:
139         dirname = os.path.dirname(fn_)
140         try:
141             if dirname:
142                 try:
143                     os.makedirs(dirname)
144                 except OSError as err:
145                     if err.errno != errno.EEXIST:
146                         raise
147             if not os.path.isfile(fn_):
148                 with salt.utils.files.fopen(fn_, "w"):
149                     pass
150         except OSError as err:
151             if os.path.isfile(dirname):
152                 msg = "Failed to create path {}, is {} a file?".format(fn_, dirname)
153                 raise SaltSystemExit(msg=msg)
154             if err.errno != errno.EACCES:
155                 raise
156             msg = 'No permissions to access "{}", are you running as the correct user?'.format(
157                 fn_
158             )
159             raise SaltSystemExit(msg=msg)
160         except OSError as err:  # pylint: disable=duplicate-except
161             msg = 'Failed to create path "{}" - {}'.format(fn_, err)
162             raise SaltSystemExit(msg=msg)
163         stats = os.stat(fn_)
164         if uid != stats.st_uid:
165             try:
166                 os.chown(fn_, uid, -1)
167             except OSError:
168                 pass
169     return True
170 def verify_env(
171     dirs, user, permissive=False, pki_dir="", skip_extra=False, root_dir=ROOT_DIR
172 ):
173     if salt.utils.platform.is_windows():
174         return win_verify_env(
175             root_dir, dirs, permissive=permissive, skip_extra=skip_extra
176         )
177     pwnam = _get_pwnam(user)
178     uid = pwnam[2]
179     gid = pwnam[3]
180     groups = salt.utils.user.get_gid_list(user, include_default=False)
181     for dir_ in dirs:
182         if not dir_:
183             continue
184         if not os.path.isdir(dir_):
185             try:
186                 with salt.utils.files.set_umask(0o022):
187                     os.makedirs(dir_)
188                 if os.getuid() == 0:
189                     os.chown(dir_, uid, gid)
190             except OSError as err:
191                 msg = 'Failed to create directory path "{0}" - {1}\n'
192                 sys.stderr.write(msg.format(dir_, err))
193                 sys.exit(err.errno)
194         mode = os.stat(dir_)
195         if os.getuid() == 0:
196             fmode = os.stat(dir_)
197             if fmode.st_uid != uid or fmode.st_gid != gid:
198                 if permissive and fmode.st_gid in groups:
199                     pass
200                 else:
201                     os.chown(dir_, uid, gid)
202             for subdir in [a for a in os.listdir(dir_) if "jobs" not in a]:
203                 fsubdir = os.path.join(dir_, subdir)
204                 if "{}jobs".format(os.path.sep) in fsubdir:
205                     continue
206                 for root, dirs, files in salt.utils.path.os_walk(fsubdir):
207                     for name in itertools.chain(files, dirs):
208                         if name.startswith("."):
209                             continue
210                         path = os.path.join(root, name)
211                         try:
212                             fmode = os.stat(path)
213                             if fmode.st_uid != uid or fmode.st_gid != gid:
214                                 if permissive and fmode.st_gid in groups:
215                                     pass
216                                 else:
217                                     os.chown(path, uid, gid)
218                         except OSError:
219                             continue
220         if dir_ == pki_dir:
221             smode = stat.S_IMODE(mode.st_mode)
222             if smode != 448 and smode != 488:
223                 if os.access(dir_, os.W_OK):
224                     os.chmod(dir_, 448)
225                 else:
226                     msg = 'Unable to securely set the permissions of "{0}".'
227                     msg = msg.format(dir_)
228                     if is_console_configured():
229                         log.critical(msg)
230                     else:
231                         sys.stderr.write("CRITICAL: {}\n".format(msg))
232     if skip_extra is False:
233         zmq_version()
234 def check_user(user):
235     if salt.utils.platform.is_windows():
236         return True
237     if user == salt.utils.user.get_user():
238         return True
239     pwuser = _get_pwnam(user)
240     try:
241         if hasattr(os, "initgroups"):
242             os.initgroups(user, pwuser.pw_gid)  # pylint: disable=minimum-python-version
243         else:
244             os.setgroups(salt.utils.user.get_gid_list(user, include_default=False))
245         os.setgid(pwuser.pw_gid)
246         os.setuid(pwuser.pw_uid)
247         if "HOME" in os.environ:
248             os.environ["HOME"] = pwuser.pw_dir
249         if "SHELL" in os.environ:
250             os.environ["SHELL"] = pwuser.pw_shell
251         for envvar in ("USER", "LOGNAME"):
252             if envvar in os.environ:
253                 os.environ[envvar] = pwuser.pw_name
254     except OSError:
255         msg = 'Salt configured to run as user "{}" but unable to switch.'.format(user)
256         if is_console_configured():
257             log.critical(msg)
258         else:
259             sys.stderr.write("CRITICAL: {}\n".format(msg))
260         return False
261     return True
262 def list_path_traversal(path):
263     out = [path]
264     (head, tail) = os.path.split(path)
265     if tail == "":
266         out = [head]
267         (head, tail) = os.path.split(head)
268     while head != out[0]:
269         out.insert(0, head)
270         (head, tail) = os.path.split(head)
271     return out
272 def check_path_traversal(path, user="root", skip_perm_errors=False):
273     for tpath in list_path_traversal(path):
274         if not os.access(tpath, os.R_OK):
275             msg = "Could not access {}.".format(tpath)
276             if not os.path.exists(tpath):
277                 msg += " Path does not exist."
278             else:
279                 current_user = salt.utils.user.get_user()
280                 if user != current_user:
281                     msg += " Try running as user {}.".format(user)
282                 else:
283                     msg += " Please give {} read permissions.".format(user)
284             if skip_perm_errors:
285                 return
286             raise SaltClientError(msg)
287 def check_max_open_files(opts):
288     mof_c = opts.get("max_open_files", 100000)
289     if sys.platform.startswith("win"):
290         mof_s = mof_h = win32file._getmaxstdio()
291     else:
292         mof_s, mof_h = resource.getrlimit(resource.RLIMIT_NOFILE)
293     accepted_keys_dir = os.path.join(opts.get("pki_dir"), "minions")
294     accepted_count = len(os.listdir(accepted_keys_dir))
295     log.debug("This salt-master instance has accepted %s minion keys.", accepted_count)
296     level = logging.INFO
297     if (accepted_count * 4) &lt;= mof_s:
298         return
299     msg = (
300         "The number of accepted minion keys({}) should be lower than 1/4 "
301         "of the max open files soft setting({}). ".format(accepted_count, mof_s)
302     )
303     if accepted_count &gt;= mof_s:
304         msg += "salt-master will crash pretty soon! "
305         level = logging.CRITICAL
306     elif (accepted_count * 2) &gt;= mof_s:
307         level = logging.CRITICAL
308     elif (accepted_count * 3) &gt;= mof_s:
309         level = logging.WARNING
310     elif (accepted_count * 4) &gt;= mof_s:
311         level = logging.INFO
312     if mof_c &lt; mof_h:
313         msg += (
314             "According to the system's hard limit, there's still a "
315             "margin of {} to raise the salt's max_open_files "
316             "setting. ".format(mof_h - mof_c)
317         )
318     msg += "Please consider raising this value."
319     log.log(level=level, msg=msg)
320 def _realpath_darwin(path):
321     base = ""
322     for part in path.split(os.path.sep)[1:]:
323         if base != "":
324             if os.path.islink(os.path.sep.join([base, part])):
325                 base = os.readlink(os.path.sep.join([base, part]))
326             else:
327                 base = os.path.abspath(os.path.sep.join([base, part]))
328         else:
329             base = os.path.abspath(os.path.sep.join([base, part]))
330     return base
331 def _realpath_windows(path):
332     base = ""
333     for part in path.split(os.path.sep):
334         if base != "":
335             try:
336                 part = salt.utils.path.readlink(os.path.sep.join([base, part]))
337                 base = os.path.abspath(part)
338             except OSError:
339                 base = os.path.abspath(os.path.sep.join([base, part]))
340         else:
341             base = part
342     return base
343 def _realpath(path):
344     if salt.utils.platform.is_darwin():
345         return _realpath_darwin(path)
346     elif salt.utils.platform.is_windows():
347         return _realpath_windows(path)
348     return os.path.realpath(path)
349 def clean_path(root, path, subdir=False):
350     real_root = _realpath(root)
351     if not os.path.isabs(real_root):
352         return ""
353     if not os.path.isabs(path):
354         path = os.path.join(root, path)
355     path = os.path.normpath(path)
356     real_path = _realpath(path)
357     if subdir:
358         if real_path.startswith(real_root):
359             return real_path
360     else:
361         if os.path.dirname(real_path) == os.path.normpath(real_root):
362             return real_path
363     return ""
364 def valid_id(opts, id_):
365     try:
366         if any(x in id_ for x in ("/", "\\", "\0")):
367             return False
368         return bool(clean_path(opts["pki_dir"], id_))
369     except (AttributeError, KeyError, TypeError, UnicodeDecodeError):
370         return False
371 def safe_py_code(code):
372     bads = ("import", ";", "subprocess", "eval", "open", "file", "exec", "input")
373     for bad in bads:
374         if code.count(bad):
375             return False
376     return True
377 def verify_log(opts):
378     level = LOG_LEVELS.get(str(opts.get("log_level")).lower(), logging.NOTSET)
379     if level &lt; logging.INFO:
380         log.warning(
381             "Insecure logging configuration detected! Sensitive data may be logged."
382         )
383 def win_verify_env(path, dirs, permissive=False, pki_dir="", skip_extra=False):
384     import salt.utils.win_functions
385     import salt.utils.win_dacl
386     import salt.utils.path
387     system_root = os.environ.get("SystemRoot", r"C:\Windows")
388     allow_path = "\\".join([system_root, "TEMP"])
389     if not salt.utils.path.safe_path(path=path, allow_path=allow_path):
390         raise CommandExecutionError(
391             "`file_roots` set to a possibly unsafe location: {}".format(path)
392         )
393     if not os.path.isdir(path):
394         os.makedirs(path)
395     current_user = salt.utils.win_functions.get_current_user()
396     if salt.utils.win_functions.is_admin(current_user):
397         reg_path = "HKLM\\SOFTWARE\\Salt Project\\salt"
398         if not salt.utils.win_reg.key_exists(
399             hive="HKLM", key="SOFTWARE\\Salt Project\\salt"
400         ):
401             salt.utils.win_reg.set_value(
402                 hive="HKLM", key="SOFTWARE\\Salt Project\\salt"
403             )
404         try:
405             salt.utils.win_dacl.set_owner(
406                 obj_name=reg_path, principal="S-1-5-32-544", obj_type="registry"
407             )
408         except CommandExecutionError:
409             msg = 'Unable to securely set the owner of "{}".'.format(reg_path)
410             if is_console_configured():
411                 log.critical(msg)
412             else:
413                 sys.stderr.write("CRITICAL: {}\n".format(msg))
414         try:
415             dacl = salt.utils.win_dacl.dacl(obj_type="registry")
416             dacl.add_ace(
417                 principal="S-1-5-32-544",
418                 access_mode="grant",
419                 permissions="full_control",
420                 applies_to="this_key_subkeys",
421             )
422             dacl.add_ace(
423                 principal="S-1-5-18",
424                 access_mode="grant",
425                 permissions="full_control",
426                 applies_to="this_key_subkeys",
427             )
428             dacl.add_ace(
429                 principal="S-1-3-4",
430                 access_mode="grant",
431                 permissions="full_control",
432                 applies_to="this_key_subkeys",
433             )
434             dacl.save(obj_name=reg_path, protected=True)
435         except CommandExecutionError:
436             msg = 'Unable to securely set the permissions of "{}"'.format(reg_path)
437             if is_console_configured():
438                 log.critical(msg)
439             else:
440                 sys.stderr.write("CRITICAL: {}\n".format(msg))
441     if salt.utils.win_functions.is_admin(current_user):
442         try:
443             salt.utils.win_dacl.set_owner(obj_name=path, principal="S-1-5-32-544")
444         except CommandExecutionError:
445             msg = "Unable to securely set the owner of {}".format(path)
446             if is_console_configured():
447                 log.critical(msg)
448             else:
449                 sys.stderr.write("CRITICAL: {}\n".format(msg))
450         if not permissive:
451             try:
452                 dacl = salt.utils.win_dacl.dacl()
453                 dacl.add_ace(
454                     principal="S-1-5-32-544",
455                     access_mode="grant",
456                     permissions="full_control",
457                     applies_to="this_folder_subfolders_files",
458                 )
459                 dacl.add_ace(
460                     principal="S-1-5-18",
461                     access_mode="grant",
462                     permissions="full_control",
463                     applies_to="this_folder_subfolders_files",
464                 )
465                 dacl.add_ace(
466                     principal="S-1-3-4",
467                     access_mode="grant",
468                     permissions="full_control",
469                     applies_to="this_folder_subfolders_files",
470                 )
471                 dacl.save(obj_name=path, protected=True)
472             except CommandExecutionError:
473                 msg = 'Unable to securely set the permissions of "{}".'.format(path)
474                 if is_console_configured():
475                     log.critical(msg)
476                 else:
477                     sys.stderr.write("CRITICAL: {}\n".format(msg))
478     for dir_ in dirs:
479         if not dir_:
480             continue
481         if not os.path.isdir(dir_):
482             try:
483                 os.makedirs(dir_)
484             except OSError as err:
485                 msg = 'Failed to create directory path "{0}" - {1}\n'
486                 sys.stderr.write(msg.format(dir_, err))
487                 sys.exit(err.errno)
488         if dir_ == pki_dir:
489             try:
490                 salt.utils.win_dacl.set_owner(obj_name=path, principal="S-1-5-32-544")
491                 dacl = salt.utils.win_dacl.dacl()
492                 dacl.add_ace(
493                     principal="S-1-5-32-544",
494                     access_mode="grant",
495                     permissions="full_control",
496                     applies_to="this_folder_subfolders_files",
497                 )
498                 dacl.add_ace(
499                     principal="S-1-5-18",
500                     access_mode="grant",
501                     permissions="full_control",
502                     applies_to="this_folder_subfolders_files",
503                 )
504                 dacl.add_ace(
505                     principal="S-1-3-4",
506                     access_mode="grant",
507                     permissions="full_control",
508                     applies_to="this_folder_subfolders_files",
509                 )
510                 dacl.save(obj_name=dir_, protected=True)
511             except CommandExecutionError:
512                 msg = 'Unable to securely set the permissions of "{0}".'
513                 msg = msg.format(dir_)
514                 if is_console_configured():
515                     log.critical(msg)
516                 else:
517                     sys.stderr.write("CRITICAL: {}\n".format(msg))
518     if skip_extra is False:
519         zmq_version()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
