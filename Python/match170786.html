<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_boto_elb_1.py & mixins_3.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_boto_elb_1.py & mixins_3.py
      </h3>
      <h1 align="center">
        2.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_boto_elb_1.py (3.1088083%)<TH>mixins_3.py (1.509434%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match170786-0.html#0',2,'match170786-1.html#0',3)" NAME="0">(1-13)<TD><A HREF="javascript:ZweiFrames('match170786-0.html#0',2,'match170786-1.html#0',3)" NAME="0">(5-17)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_elb_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match170786-1.html#0',3,'match170786-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import logging
import os.path
import sys
from copy import deepcopy

import salt.config
import salt.loader
import salt.modules.boto_elb as boto_elb
import salt.utils.versions
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from</B></FONT> tests.support.unit import TestCase, skipIf

# pylint: disable=import-error
try:
    import boto

    boto.ENDPOINTS_PATH = os.path.join(
        RUNTIME_VARS.TESTS_DIR, &quot;unit/files/endpoints.json&quot;
    )
    import boto.ec2.elb

    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False

try:
    import pkg_resources

    from moto import mock_ec2_deprecated  # pylint: disable=no-name-in-module
    from moto import mock_elb_deprecated  # pylint: disable=no-name-in-module

    HAS_MOTO = True
except ImportError:
    HAS_MOTO = False

    def mock_ec2_deprecated(self):
        &quot;&quot;&quot;
        if the mock_ec2_deprecated function is not available due to import failure
        this replaces the decorated function with stub_function.
        Allows boto_elb unit tests to use the @mock_ec2_deprecated decorator
        without a &quot;NameError: name 'mock_ec2_deprecated' is not defined&quot; error.
        &quot;&quot;&quot;

        def stub_function(self):
            pass

        return stub_function

    def mock_elb_deprecated(self):
        &quot;&quot;&quot;
        if the mock_elb_deprecated function is not available due to import failure
        this replaces the decorated function with stub_function.
        Allows boto_elb unit tests to use the @mock_elb_deprecated decorator
        without a &quot;NameError: name 'mock_elb_deprecated' is not defined&quot; error.
        &quot;&quot;&quot;

        def stub_function(self):
            pass

        return stub_function


# pylint: enable=import-error


log = logging.getLogger(__name__)

region = &quot;us-east-1&quot;
access_key = &quot;GKTADJGHEIQSXMKKRBJ08H&quot;
secret_key = &quot;askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs&quot;
conn_parameters = {
    &quot;region&quot;: region,
    &quot;key&quot;: access_key,
    &quot;keyid&quot;: secret_key,
    &quot;profile&quot;: {},
}
boto_conn_parameters = {
    &quot;aws_access_key_id&quot;: access_key,
    &quot;aws_secret_access_key&quot;: secret_key,
}
instance_parameters = {&quot;instance_type&quot;: &quot;t1.micro&quot;}
required_moto = &quot;0.3.7&quot;
required_moto_py3 = &quot;1.0.1&quot;


def _has_required_moto():
    &quot;&quot;&quot;
    Returns True or False depending on if ``moto`` is installed and at the correct version,
    depending on what version of Python is running these tests.
    &quot;&quot;&quot;
    if not HAS_MOTO:
        return False
    else:
        moto_version = salt.utils.versions.LooseVersion(
            pkg_resources.get_distribution(&quot;moto&quot;).version
        )
        if moto_version &lt; salt.utils.versions.LooseVersion(required_moto):
            return False
        elif moto_version &lt; salt.utils.versions.LooseVersion(required_moto_py3):
            return False

    return True


@skipIf(HAS_BOTO is False, &quot;The boto module must be installed.&quot;)
@skipIf(HAS_MOTO is False, &quot;The moto module must be installed.&quot;)
@skipIf(
    _has_required_moto() is False,
    &quot;The moto module must be &gt;= to {} for PY2 or {} for PY3.&quot;.format(
        required_moto, required_moto_py3
    ),
)
class BotoElbTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    TestCase for salt.modules.boto_elb module
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        opts = salt.config.DEFAULT_MASTER_OPTS.copy()
        utils = salt.loader.utils(
            opts, whitelist=[&quot;boto&quot;, &quot;args&quot;, &quot;systemd&quot;, &quot;path&quot;, &quot;platform&quot;]
        )
        funcs = salt.loader.minion_mods(opts, utils=utils)
        return {boto_elb: {&quot;__opts__&quot;: opts, &quot;__utils__&quot;: utils, &quot;__salt__&quot;: funcs}}

    def setUp(self):
        TestCase.setUp(self)
        # __virtual__ must be caller in order for _get_conn to be injected
        boto_elb.__virtual__()

    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_register_instances_valid_id_result_true(self):
        &quot;&quot;&quot;
        tests that given a valid instance id and valid ELB that
        register_instances returns True.
        &quot;&quot;&quot;
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = &quot;TestRegisterInstancesValidIdResult&quot;
        conn_elb.create_load_balancer(elb_name, zones, [(80, 80, &quot;http&quot;)])
        reservations = conn_ec2.run_instances(&quot;ami-08389d60&quot;)
        register_result = boto_elb.register_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        self.assertEqual(True, register_result)

    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_register_instances_valid_id_string(self):
        &quot;&quot;&quot;
        tests that given a string containing a instance id and valid ELB that
        register_instances adds the given instance to an ELB
        &quot;&quot;&quot;
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = &quot;TestRegisterInstancesValidIdResult&quot;
        conn_elb.create_load_balancer(elb_name, zones, [(80, 80, &quot;http&quot;)])
        reservations = conn_ec2.run_instances(&quot;ami-08389d60&quot;)
        boto_elb.register_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
        registered_instance_ids = [
            instance.id for instance in load_balancer_refreshed.instances
        ]

        log.debug(load_balancer_refreshed.instances)
        self.assertEqual([reservations.instances[0].id], registered_instance_ids)

    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_deregister_instances_valid_id_result_true(self):
        &quot;&quot;&quot;
        tests that given an valid id the boto_elb deregister_instances method
        removes exactly one of a number of ELB registered instances
        &quot;&quot;&quot;
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = &quot;TestDeregisterInstancesValidIdResult&quot;
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, &quot;http&quot;)]
        )
        reservations = conn_ec2.run_instances(&quot;ami-08389d60&quot;)
        load_balancer.register_instances(reservations.instances[0].id)
        deregister_result = boto_elb.deregister_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        self.assertEqual(True, deregister_result)

    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_deregister_instances_valid_id_string(self):
        &quot;&quot;&quot;
        tests that given an valid id the boto_elb deregister_instances method
        removes exactly one of a number of ELB registered instances
        &quot;&quot;&quot;
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = &quot;TestDeregisterInstancesValidIdString&quot;
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, &quot;http&quot;)]
        )
        reservations = conn_ec2.run_instances(&quot;ami-08389d60&quot;, min_count=2)
        all_instance_ids = [instance.id for instance in reservations.instances]
        load_balancer.register_instances(all_instance_ids)
        boto_elb.deregister_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
        expected_instances = deepcopy(all_instance_ids)
        expected_instances.remove(reservations.instances[0].id)
        actual_instances = [
            instance.id for instance in load_balancer_refreshed.instances
        ]
        self.assertEqual(actual_instances, expected_instances)

    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_deregister_instances_valid_id_list(self):
        &quot;&quot;&quot;
        tests that given an valid ids in the form of a list that the boto_elb
        deregister_instances all members of the given list
        &quot;&quot;&quot;
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = &quot;TestDeregisterInstancesValidIdList&quot;
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, &quot;http&quot;)]
        )
        reservations = conn_ec2.run_instances(&quot;ami-08389d60&quot;, min_count=3)
        all_instance_ids = [instance.id for instance in reservations.instances]
        load_balancer.register_instances(all_instance_ids)
        # reservations.instances[:-1] refers to all instances except list
        # instance
        deregister_instances = [instance.id for instance in reservations.instances[:-1]]
        expected_instances = [reservations.instances[-1].id]
        boto_elb.deregister_instances(elb_name, deregister_instances, **conn_parameters)
        load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
        actual_instances = [
            instance.id for instance in load_balancer_refreshed.instances
        ]
        self.assertEqual(actual_instances, expected_instances)

    @mock_ec2_deprecated
    @mock_elb_deprecated
    @skipIf(
        sys.version_info &gt; (3, 6),
        &quot;Disabled for 3.7+ pending https://github.com/spulec/moto/issues/1706.&quot;,
    )
    def test_get_elb_config(self):
        &quot;&quot;&quot;
        tests that given an valid ids in the form of a list that the boto_elb
        deregister_instances all members of the given list
        &quot;&quot;&quot;
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = &quot;TestGetELBConfig&quot;
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, &quot;http&quot;)]
        )
        reservations = conn_ec2.run_instances(&quot;ami-08389d60&quot;, min_count=3)
        all_instance_ids = [instance.id for instance in reservations.instances]
        load_balancer.register_instances(all_instance_ids)

        # DescribeTags does not appear to be included in moto
        # so mock the _get_all_tags function.  Ideally we wouldn't
        # need to mock this.
        with patch(&quot;salt.modules.boto_elb._get_all_tags&quot;, MagicMock(return_value=None)):
            ret = boto_elb.get_elb_config(elb_name, **conn_parameters)
            _expected_keys = [
                &quot;subnets&quot;,
                &quot;availability_zones&quot;,
                &quot;canonical_hosted_zone_name_id&quot;,
                &quot;tags&quot;,
                &quot;dns_name&quot;,
                &quot;listeners&quot;,
                &quot;backends&quot;,
                &quot;policies&quot;,
                &quot;vpc_id&quot;,
                &quot;scheme&quot;,
                &quot;canonical_hosted_zone_name&quot;,
                &quot;security_groups&quot;,
            ]
            for key in _expected_keys:
                self.assertIn(key, ret)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mixins_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
<A NAME="0"></A>A collection of mixins useful for the various *Client interfaces
&quot;&quot;&quot;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match170786-0.html#0',2,'match170786-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import copy
import fnmatch
import logging
import signal
import traceback
import weakref
from collections.abc import Mapping, MutableMapping

import salt.channel.client
import salt.exceptions
import salt.ext.tornado.stack_context
import salt.log.setup
import</B></FONT> salt.minion
import salt.output
import salt.utils.args
import salt.utils.doc
import salt.utils.error
import salt.utils.event
import salt.utils.jid
import salt.utils.job
import salt.utils.lazy
import salt.utils.platform
import salt.utils.process
import salt.utils.state
import salt.utils.user
import salt.utils.versions

log = logging.getLogger(__name__)

CLIENT_INTERNAL_KEYWORDS = frozenset(
    [
        &quot;client&quot;,
        &quot;cmd&quot;,
        &quot;eauth&quot;,
        &quot;fun&quot;,
        &quot;kwarg&quot;,
        &quot;match&quot;,
        &quot;token&quot;,
        &quot;__jid__&quot;,
        &quot;__tag__&quot;,
        &quot;__user__&quot;,
        &quot;username&quot;,
        &quot;password&quot;,
        &quot;full_return&quot;,
        &quot;print_event&quot;,
    ]
)


class ClientFuncsDict(MutableMapping):
    &quot;&quot;&quot;
    Class to make a read-only dict for accessing runner funcs &quot;directly&quot;
    &quot;&quot;&quot;

    def __init__(self, client):
        self.client = client

    def __getattr__(self, attr):
        &quot;&quot;&quot;
        Provide access eg. to 'pack'
        &quot;&quot;&quot;
        return getattr(self.client.functions, attr)

    def __setitem__(self, key, val):
        raise NotImplementedError()

    def __delitem__(self, key):
        raise NotImplementedError()

    def __getitem__(self, key):
        &quot;&quot;&quot;
        Return a function that you can call with regular func params, but
        will do all the _proc_function magic
        &quot;&quot;&quot;
        if key not in self.client.functions:
            raise KeyError

        def wrapper(*args, **kwargs):
            low = {
                &quot;fun&quot;: key,
                &quot;args&quot;: args,
                &quot;kwargs&quot;: kwargs,
            }
            pub_data = {}
            # Copy kwargs keys so we can iterate over and pop the pub data
            kwargs_keys = list(kwargs)

            # pull out pub_data if you have it
            for kwargs_key in kwargs_keys:
                if kwargs_key.startswith(&quot;__pub_&quot;):
                    pub_data[kwargs_key] = kwargs.pop(kwargs_key)

            async_pub = self.client._gen_async_pub(pub_data.get(&quot;__pub_jid&quot;))

            user = salt.utils.user.get_specific_user()
            return self.client._proc_function(
                fun=key,
                low=low,
                user=user,
                tag=async_pub[&quot;tag&quot;],
                jid=async_pub[&quot;jid&quot;],
                daemonize=False,
            )

        return wrapper

    def __len__(self):
        return len(self.client.functions)

    def __iter__(self):
        return iter(self.client.functions)


class ClientStateMixin:
    def __init__(self, opts, context=None):
        self.opts = opts
        if context is None:
            context = {}
        self.context = context

    # __setstate__ and __getstate__ are only used on spawning platforms.
    def __getstate__(self):
        return {
            &quot;opts&quot;: self.opts,
            &quot;context&quot;: self.context or None,
        }

    def __setstate__(self, state):
        # If __setstate__ is getting called it means this is running on a new process.
        self.__init__(state[&quot;opts&quot;], context=state[&quot;context&quot;])


class SyncClientMixin(ClientStateMixin):
    &quot;&quot;&quot;
    A mixin for *Client interfaces to abstract common function execution
    &quot;&quot;&quot;

    functions = ()

    def functions_dict(self):
        &quot;&quot;&quot;
        Return a dict that will mimic the &quot;functions&quot; dict used all over salt.
        It creates a wrapper around the function allowing **kwargs, and if pub_data
        is passed in as kwargs, will re-use the JID passed in
        &quot;&quot;&quot;
        return ClientFuncsDict(self)

    def master_call(self, **kwargs):
        &quot;&quot;&quot;
        Execute a function through the master network interface.
        &quot;&quot;&quot;
        load = kwargs
        load[&quot;cmd&quot;] = self.client

        with salt.channel.client.ReqChannel.factory(
            self.opts, crypt=&quot;clear&quot;, usage=&quot;master_call&quot;
        ) as channel:
            ret = channel.send(load)
            if isinstance(ret, Mapping):
                if &quot;error&quot; in ret:
                    salt.utils.error.raise_error(**ret[&quot;error&quot;])
            return ret

    def cmd_sync(self, low, timeout=None, full_return=False):
        &quot;&quot;&quot;
        Execute a runner function synchronously; eauth is respected

        This function requires that :conf_master:`external_auth` is configured
        and the user is authorized to execute runner functions: (``@runner``).

        .. code-block:: python

            runner.eauth_sync({
                'fun': 'jobs.list_jobs',
                'username': 'saltdev',
                'password': 'saltdev',
                'eauth': 'pam',
            })
        &quot;&quot;&quot;
        with salt.utils.event.get_master_event(
            self.opts, self.opts[&quot;sock_dir&quot;], listen=True
        ) as event:
            job = self.master_call(**low)
            ret_tag = salt.utils.event.tagify(&quot;ret&quot;, base=job[&quot;tag&quot;])

            if timeout is None:
                timeout = self.opts.get(&quot;rest_timeout&quot;, 300)
            ret = event.get_event(
                tag=ret_tag, full=True, wait=timeout, auto_reconnect=True
            )
            if ret is None:
                raise salt.exceptions.SaltClientTimeout(
                    &quot;RunnerClient job '{}' timed out&quot;.format(job[&quot;jid&quot;]),
                    jid=job[&quot;jid&quot;],
                )

            return ret if full_return else ret[&quot;data&quot;][&quot;return&quot;]

    def cmd(
        self,
        fun,
        arg=None,
        pub_data=None,
        kwarg=None,
        print_event=True,
        full_return=False,
    ):
        &quot;&quot;&quot;
        Execute a function
        &quot;&quot;&quot;
        if arg is None:
            arg = tuple()
        if not isinstance(arg, list) and not isinstance(arg, tuple):
            raise salt.exceptions.SaltInvocationError(
                &quot;arg must be formatted as a list/tuple&quot;
            )
        if pub_data is None:
            pub_data = {}
        if not isinstance(pub_data, dict):
            raise salt.exceptions.SaltInvocationError(
                &quot;pub_data must be formatted as a dictionary&quot;
            )
        if kwarg is None:
            kwarg = {}
        if not isinstance(kwarg, dict):
            raise salt.exceptions.SaltInvocationError(
                &quot;kwarg must be formatted as a dictionary&quot;
            )
        arglist = salt.utils.args.parse_input(
            arg, no_parse=self.opts.get(&quot;no_parse&quot;, [])
        )

        # if you were passed kwarg, add it to arglist
        if kwarg:
            kwarg[&quot;__kwarg__&quot;] = True
            arglist.append(kwarg)

        args, kwargs = salt.minion.load_args_and_kwargs(
            self.functions[fun], arglist, pub_data
        )
        low = {&quot;fun&quot;: fun, &quot;arg&quot;: args, &quot;kwarg&quot;: kwargs}
        return self.low(fun, low, print_event=print_event, full_return=full_return)

    @property
    def mminion(self):
        if not hasattr(self, &quot;_mminion&quot;):
            self._mminion = salt.minion.MasterMinion(
                self.opts, states=False, rend=False
            )
        return self._mminion

    @property
    def store_job(self):
        &quot;&quot;&quot;
        Helper that allows us to turn off storing jobs for different classes
        that may incorporate this mixin.
        &quot;&quot;&quot;
        try:
            class_name = self.__class__.__name__.lower()
        except AttributeError:
            log.warning(
                &quot;Unable to determine class name&quot;, exc_info_on_loglevel=logging.DEBUG
            )
            return True

        try:
            return self.opts[&quot;{}_returns&quot;.format(class_name)]
        except KeyError:
            # No such option, assume this isn't one we care about gating and
            # just return True.
            return True

    def low(self, fun, low, print_event=True, full_return=False):
        &quot;&quot;&quot;
        Execute a function from low data
        Low data includes:
            required:
                - fun: the name of the function to run
            optional:
                - arg: a list of args to pass to fun
                - kwarg: kwargs for fun
                - __user__: user who is running the command
                - __jid__: jid to run under
                - __tag__: tag to run under
        &quot;&quot;&quot;
        # fire the mminion loading (if not already done) here
        # this is not to clutter the output with the module loading
        # if we have a high debug level.
        self.mminion  # pylint: disable=W0104
        jid = low.get(&quot;__jid__&quot;, salt.utils.jid.gen_jid(self.opts))
        tag = low.get(&quot;__tag__&quot;, salt.utils.event.tagify(jid, prefix=self.tag_prefix))

        data = {
            &quot;fun&quot;: &quot;{}.{}&quot;.format(self.client, fun),
            &quot;jid&quot;: jid,
            &quot;user&quot;: low.get(&quot;__user__&quot;, &quot;UNKNOWN&quot;),
        }

        if print_event:
            print_func = (
                self.print_async_event if hasattr(self, &quot;print_async_event&quot;) else None
            )
        else:
            # Suppress printing of return event (this keeps us from printing
            # runner/wheel output during orchestration).
            print_func = None

        with salt.utils.event.NamespacedEvent(
            salt.utils.event.get_event(
                &quot;master&quot;,
                self.opts[&quot;sock_dir&quot;],
                opts=self.opts,
                listen=False,
            ),
            tag,
            print_func=print_func,
        ) as namespaced_event:

            # TODO: test that they exist
            # TODO: Other things to inject??
            func_globals = {
                &quot;__jid__&quot;: jid,
                &quot;__user__&quot;: data[&quot;user&quot;],
                &quot;__tag__&quot;: tag,
                # weak ref to avoid the Exception in interpreter
                # teardown of event
                &quot;__jid_event__&quot;: weakref.proxy(namespaced_event),
            }

            try:
                self_functions = copy.copy(self.functions)
                salt.utils.lazy.verify_fun(self_functions, fun)

                # Inject some useful globals to *all* the function's global
                # namespace only once per module-- not per func
                completed_funcs = []

                for mod_name in self_functions.keys():
                    if &quot;.&quot; not in mod_name:
                        continue
                    mod, _ = mod_name.split(&quot;.&quot;, 1)
                    if mod in completed_funcs:
                        continue
                    completed_funcs.append(mod)
                    for global_key, value in func_globals.items():
                        self.functions[mod_name].__globals__[global_key] = value

                # There are some discrepancies of what a &quot;low&quot; structure is in the
                # publisher world it is a dict including stuff such as jid, fun,
                # arg (a list of args, with kwargs packed in). Historically this
                # particular one has had no &quot;arg&quot; and just has had all the kwargs
                # packed into the top level object. The plan is to move away from
                # that since the caller knows what is an arg vs a kwarg, but while
                # we make the transition we will load &quot;kwargs&quot; using format_call if
                # there are no kwargs in the low object passed in.

                if &quot;arg&quot; in low and &quot;kwarg&quot; in low:
                    args = low[&quot;arg&quot;]
                    kwargs = low[&quot;kwarg&quot;]
                else:
                    f_call = salt.utils.args.format_call(
                        self.functions[fun],
                        low,
                        expected_extra_kws=CLIENT_INTERNAL_KEYWORDS,
                    )
                    args = f_call.get(&quot;args&quot;, ())
                    kwargs = f_call.get(&quot;kwargs&quot;, {})

                # Update the event data with loaded args and kwargs
                data[&quot;fun_args&quot;] = list(args) + ([kwargs] if kwargs else [])
                func_globals[&quot;__jid_event__&quot;].fire_event(data, &quot;new&quot;)

                # Initialize a context for executing the method.
                with salt.ext.tornado.stack_context.StackContext(
                    self.functions.context_dict.clone
                ):
                    func = self.functions[fun]
                    try:
                        data[&quot;return&quot;] = func(*args, **kwargs)
                    except TypeError as exc:
                        data[
                            &quot;return&quot;
                        ] = &quot;\nPassed invalid arguments: {}\n\nUsage:\n{}&quot;.format(
                            exc, func.__doc__
                        )
                    try:
                        data[&quot;success&quot;] = self.context.get(&quot;retcode&quot;, 0) == 0
                    except AttributeError:
                        # Assume a True result if no context attribute
                        data[&quot;success&quot;] = True
                    if isinstance(data[&quot;return&quot;], dict) and &quot;data&quot; in data[&quot;return&quot;]:
                        # some functions can return boolean values
                        data[&quot;success&quot;] = salt.utils.state.check_result(
                            data[&quot;return&quot;][&quot;data&quot;]
                        )
            except (Exception, SystemExit) as ex:  # pylint: disable=broad-except
                if isinstance(ex, salt.exceptions.NotImplemented):
                    data[&quot;return&quot;] = str(ex)
                else:
                    data[&quot;return&quot;] = &quot;Exception occurred in {} {}: {}&quot;.format(
                        self.client,
                        fun,
                        traceback.format_exc(),
                    )
                data[&quot;success&quot;] = False

            if self.store_job:
                try:
                    salt.utils.job.store_job(
                        self.opts,
                        {
                            &quot;id&quot;: self.opts[&quot;id&quot;],
                            &quot;tgt&quot;: self.opts[&quot;id&quot;],
                            &quot;jid&quot;: data[&quot;jid&quot;],
                            &quot;return&quot;: data,
                        },
                        event=None,
                        mminion=self.mminion,
                    )
                except salt.exceptions.SaltCacheError:
                    log.error(
                        &quot;Could not store job cache info. &quot;
                        &quot;Job details for this run may be unavailable.&quot;
                    )

            # Outputters _can_ mutate data so write to the job cache first!
            namespaced_event.fire_event(data, &quot;ret&quot;)

            # if we fired an event, make sure to delete the event object.
            # This will ensure that we call destroy, which will do the 0MQ linger
            log.info(&quot;Runner completed: %s&quot;, data[&quot;jid&quot;])
            return data if full_return else data[&quot;return&quot;]

    def get_docs(self, arg=None):
        &quot;&quot;&quot;
        Return a dictionary of functions and the inline documentation for each
        &quot;&quot;&quot;
        if arg:
            if &quot;*&quot; in arg:
                target_mod = arg
                _use_fnmatch = True
            else:
                target_mod = arg + &quot;.&quot; if not arg.endswith(&quot;.&quot;) else arg
                _use_fnmatch = False
            if _use_fnmatch:
                docs = [
                    (fun, self.functions[fun].__doc__)
                    for fun in fnmatch.filter(self.functions, target_mod)
                ]
            else:
                docs = [
                    (fun, self.functions[fun].__doc__)
                    for fun in sorted(self.functions)
                    if fun == arg or fun.startswith(target_mod)
                ]
        else:
            docs = [
                (fun, self.functions[fun].__doc__) for fun in sorted(self.functions)
            ]
        docs = dict(docs)
        return salt.utils.doc.strip_rst(docs)


class AsyncClientMixin(ClientStateMixin):
    &quot;&quot;&quot;
    A mixin for *Client interfaces to enable easy asynchronous function execution
    &quot;&quot;&quot;

    client = None
    tag_prefix = None

    def _proc_function_remote(self, *, fun, low, user, tag, jid, daemonize=True):
        &quot;&quot;&quot;
        Run this method in a multiprocess target to execute the function on the
        master and fire the return data on the event bus
        &quot;&quot;&quot;
        if daemonize and not salt.utils.platform.is_windows():
            # Shutdown the multiprocessing before daemonizing
            salt.log.setup.shutdown_multiprocessing_logging()

            salt.utils.process.daemonize()

            # Reconfigure multiprocessing logging after daemonizing
            salt.log.setup.setup_multiprocessing_logging()

        # pack a few things into low
        low[&quot;__jid__&quot;] = jid
        low[&quot;__user__&quot;] = user
        low[&quot;__tag__&quot;] = tag

        try:
            return self.cmd_sync(low)
        except salt.exceptions.EauthAuthenticationError as exc:
            log.error(exc)

    def _proc_function(self, *, fun, low, user, tag, jid, daemonize=True):
        &quot;&quot;&quot;
        Run this method in a multiprocess target to execute the function
        locally and fire the return data on the event bus
        &quot;&quot;&quot;
        if daemonize and not salt.utils.platform.is_windows():
            # Shutdown the multiprocessing before daemonizing
            salt.log.setup.shutdown_multiprocessing_logging()

            salt.utils.process.daemonize()

            # Reconfigure multiprocessing logging after daemonizing
            salt.log.setup.setup_multiprocessing_logging()

        # pack a few things into low
        low[&quot;__jid__&quot;] = jid
        low[&quot;__user__&quot;] = user
        low[&quot;__tag__&quot;] = tag

        return self.low(fun, low)

    def cmd_async(self, low):
        &quot;&quot;&quot;
        Execute a function asynchronously; eauth is respected

        This function requires that :conf_master:`external_auth` is configured
        and the user is authorized

        .. code-block:: python

            &gt;&gt;&gt; wheel.cmd_async({
                'fun': 'key.finger',
                'match': 'jerry',
                'eauth': 'auto',
                'username': 'saltdev',
                'password': 'saltdev',
            })
            {'jid': '20131219224744416681', 'tag': 'salt/wheel/20131219224744416681'}
        &quot;&quot;&quot;
        return self.master_call(**low)

    def _gen_async_pub(self, jid=None):
        if jid is None:
            jid = salt.utils.jid.gen_jid(self.opts)
        tag = salt.utils.event.tagify(jid, prefix=self.tag_prefix)
        return {&quot;tag&quot;: tag, &quot;jid&quot;: jid}

    def asynchronous(self, fun, low, user=&quot;UNKNOWN&quot;, pub=None, local=True):
        &quot;&quot;&quot;
        Execute the function in a multiprocess and return the event tag to use
        to watch for the return
        &quot;&quot;&quot;
        if local:
            proc_func = self._proc_function
        else:
            proc_func = self._proc_function_remote
        async_pub = pub if pub is not None else self._gen_async_pub()
        with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):
            # Reset current signals before starting the process in
            # order not to inherit the current signal handlers
            proc = salt.utils.process.SignalHandlingProcess(
                target=proc_func,
                name=&quot;ProcessFunc({}, fun={} jid={})&quot;.format(
                    proc_func.__qualname__, fun, async_pub[&quot;jid&quot;]
                ),
                kwargs=dict(
                    fun=fun,
                    low=low,
                    user=user,
                    tag=async_pub[&quot;tag&quot;],
                    jid=async_pub[&quot;jid&quot;],
                ),
            )
            proc.start()
        proc.join()  # MUST join, otherwise we leave zombies all over
        return async_pub

    def print_async_event(self, suffix, event):
        &quot;&quot;&quot;
        Print all of the events with the prefix 'tag'
        &quot;&quot;&quot;
        if not isinstance(event, dict):
            return

        # if we are &quot;quiet&quot;, don't print
        if self.opts.get(&quot;quiet&quot;, False):
            return

        # some suffixes we don't want to print
        if suffix in (&quot;new&quot;,):
            return

        try:
            outputter = self.opts.get(
                &quot;output&quot;,
                event.get(&quot;outputter&quot;, None) or event.get(&quot;return&quot;).get(&quot;outputter&quot;),
            )
        except AttributeError:
            outputter = None

        # if this is a ret, we have our own set of rules
        if suffix == &quot;ret&quot;:
            # Check if outputter was passed in the return data. If this is the case,
            # then the return data will be a dict two keys: 'data' and 'outputter'
            if isinstance(event.get(&quot;return&quot;), dict) and set(event[&quot;return&quot;]) == {
                &quot;data&quot;,
                &quot;outputter&quot;,
            }:
                event_data = event[&quot;return&quot;][&quot;data&quot;]
                outputter = event[&quot;return&quot;][&quot;outputter&quot;]
            else:
                event_data = event[&quot;return&quot;]
        else:
            event_data = {&quot;suffix&quot;: suffix, &quot;event&quot;: event}

        salt.output.display_output(event_data, outputter, self.opts)
</PRE>
</div>
  </div>
</body>
</html>
