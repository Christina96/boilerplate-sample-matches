<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_elb_1.py &amp; mixins_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_elb_1.py &amp; mixins_3.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_elb_1.py (3.1088083%)<th>mixins_3.py (1.509434%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-13)<td><a href="#" name="0">(5-17)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_elb_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
import os.path
import sys
from copy import deepcopy
import salt.config
import salt.loader
import salt.modules.boto_elb as boto_elb
import salt.utils.versions
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.runtests import RUNTIME_VARS
from</b></font> tests.support.unit import TestCase, skipIf
try:
    import boto
    boto.ENDPOINTS_PATH = os.path.join(
        RUNTIME_VARS.TESTS_DIR, "unit/files/endpoints.json"
    )
    import boto.ec2.elb
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
try:
    import pkg_resources
    from moto import mock_ec2_deprecated  # pylint: disable=no-name-in-module
    from moto import mock_elb_deprecated  # pylint: disable=no-name-in-module
    HAS_MOTO = True
except ImportError:
    HAS_MOTO = False
    def mock_ec2_deprecated(self):
        def stub_function(self):
            pass
        return stub_function
    def mock_elb_deprecated(self):
        def stub_function(self):
            pass
        return stub_function
log = logging.getLogger(__name__)
region = "us-east-1"
access_key = "GKTADJGHEIQSXMKKRBJ08H"
secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
conn_parameters = {
    "region": region,
    "key": access_key,
    "keyid": secret_key,
    "profile": {},
}
boto_conn_parameters = {
    "aws_access_key_id": access_key,
    "aws_secret_access_key": secret_key,
}
instance_parameters = {"instance_type": "t1.micro"}
required_moto = "0.3.7"
required_moto_py3 = "1.0.1"
def _has_required_moto():
    if not HAS_MOTO:
        return False
    else:
        moto_version = salt.utils.versions.LooseVersion(
            pkg_resources.get_distribution("moto").version
        )
        if moto_version &lt; salt.utils.versions.LooseVersion(required_moto):
            return False
        elif moto_version &lt; salt.utils.versions.LooseVersion(required_moto_py3):
            return False
    return True
@skipIf(HAS_BOTO is False, "The boto module must be installed.")
@skipIf(HAS_MOTO is False, "The moto module must be installed.")
@skipIf(
    _has_required_moto() is False,
    "The moto module must be &gt;= to {} for PY2 or {} for PY3.".format(
        required_moto, required_moto_py3
    ),
)
class BotoElbTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        opts = salt.config.DEFAULT_MASTER_OPTS.copy()
        utils = salt.loader.utils(
            opts, whitelist=["boto", "args", "systemd", "path", "platform"]
        )
        funcs = salt.loader.minion_mods(opts, utils=utils)
        return {boto_elb: {"__opts__": opts, "__utils__": utils, "__salt__": funcs}}
    def setUp(self):
        TestCase.setUp(self)
        boto_elb.__virtual__()
    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_register_instances_valid_id_result_true(self):
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = "TestRegisterInstancesValidIdResult"
        conn_elb.create_load_balancer(elb_name, zones, [(80, 80, "http")])
        reservations = conn_ec2.run_instances("ami-08389d60")
        register_result = boto_elb.register_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        self.assertEqual(True, register_result)
    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_register_instances_valid_id_string(self):
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = "TestRegisterInstancesValidIdResult"
        conn_elb.create_load_balancer(elb_name, zones, [(80, 80, "http")])
        reservations = conn_ec2.run_instances("ami-08389d60")
        boto_elb.register_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
        registered_instance_ids = [
            instance.id for instance in load_balancer_refreshed.instances
        ]
        log.debug(load_balancer_refreshed.instances)
        self.assertEqual([reservations.instances[0].id], registered_instance_ids)
    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_deregister_instances_valid_id_result_true(self):
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = "TestDeregisterInstancesValidIdResult"
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, "http")]
        )
        reservations = conn_ec2.run_instances("ami-08389d60")
        load_balancer.register_instances(reservations.instances[0].id)
        deregister_result = boto_elb.deregister_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        self.assertEqual(True, deregister_result)
    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_deregister_instances_valid_id_string(self):
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = "TestDeregisterInstancesValidIdString"
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, "http")]
        )
        reservations = conn_ec2.run_instances("ami-08389d60", min_count=2)
        all_instance_ids = [instance.id for instance in reservations.instances]
        load_balancer.register_instances(all_instance_ids)
        boto_elb.deregister_instances(
            elb_name, reservations.instances[0].id, **conn_parameters
        )
        load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
        expected_instances = deepcopy(all_instance_ids)
        expected_instances.remove(reservations.instances[0].id)
        actual_instances = [
            instance.id for instance in load_balancer_refreshed.instances
        ]
        self.assertEqual(actual_instances, expected_instances)
    @mock_ec2_deprecated
    @mock_elb_deprecated
    def test_deregister_instances_valid_id_list(self):
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = "TestDeregisterInstancesValidIdList"
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, "http")]
        )
        reservations = conn_ec2.run_instances("ami-08389d60", min_count=3)
        all_instance_ids = [instance.id for instance in reservations.instances]
        load_balancer.register_instances(all_instance_ids)
        deregister_instances = [instance.id for instance in reservations.instances[:-1]]
        expected_instances = [reservations.instances[-1].id]
        boto_elb.deregister_instances(elb_name, deregister_instances, **conn_parameters)
        load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
        actual_instances = [
            instance.id for instance in load_balancer_refreshed.instances
        ]
        self.assertEqual(actual_instances, expected_instances)
    @mock_ec2_deprecated
    @mock_elb_deprecated
    @skipIf(
        sys.version_info &gt; (3, 6),
        "Disabled for 3.7+ pending https://github.com/spulec/moto/issues/1706.",
    )
    def test_get_elb_config(self):
        conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
        conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
        zones = [zone.name for zone in conn_ec2.get_all_zones()]
        elb_name = "TestGetELBConfig"
        load_balancer = conn_elb.create_load_balancer(
            elb_name, zones, [(80, 80, "http")]
        )
        reservations = conn_ec2.run_instances("ami-08389d60", min_count=3)
        all_instance_ids = [instance.id for instance in reservations.instances]
        load_balancer.register_instances(all_instance_ids)
        with patch("salt.modules.boto_elb._get_all_tags", MagicMock(return_value=None)):
            ret = boto_elb.get_elb_config(elb_name, **conn_parameters)
            _expected_keys = [
                "subnets",
                "availability_zones",
                "canonical_hosted_zone_name_id",
                "tags",
                "dns_name",
                "listeners",
                "backends",
                "policies",
                "vpc_id",
                "scheme",
                "canonical_hosted_zone_name",
                "security_groups",
            ]
            for key in _expected_keys:
                self.assertIn(key, ret)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mixins_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
import fnmatch
import logging
import signal
import traceback
import weakref
from collections.abc import Mapping, MutableMapping
import salt.channel.client
import salt.exceptions
import salt.ext.tornado.stack_context
import salt.log.setup
import</b></font> salt.minion
import salt.output
import salt.utils.args
import salt.utils.doc
import salt.utils.error
import salt.utils.event
import salt.utils.jid
import salt.utils.job
import salt.utils.lazy
import salt.utils.platform
import salt.utils.process
import salt.utils.state
import salt.utils.user
import salt.utils.versions
log = logging.getLogger(__name__)
CLIENT_INTERNAL_KEYWORDS = frozenset(
    [
        "client",
        "cmd",
        "eauth",
        "fun",
        "kwarg",
        "match",
        "token",
        "__jid__",
        "__tag__",
        "__user__",
        "username",
        "password",
        "full_return",
        "print_event",
    ]
)
class ClientFuncsDict(MutableMapping):
    def __init__(self, client):
        self.client = client
    def __getattr__(self, attr):
        return getattr(self.client.functions, attr)
    def __setitem__(self, key, val):
        raise NotImplementedError()
    def __delitem__(self, key):
        raise NotImplementedError()
    def __getitem__(self, key):
        if key not in self.client.functions:
            raise KeyError
        def wrapper(*args, **kwargs):
            low = {
                "fun": key,
                "args": args,
                "kwargs": kwargs,
            }
            pub_data = {}
            kwargs_keys = list(kwargs)
            for kwargs_key in kwargs_keys:
                if kwargs_key.startswith("__pub_"):
                    pub_data[kwargs_key] = kwargs.pop(kwargs_key)
            async_pub = self.client._gen_async_pub(pub_data.get("__pub_jid"))
            user = salt.utils.user.get_specific_user()
            return self.client._proc_function(
                fun=key,
                low=low,
                user=user,
                tag=async_pub["tag"],
                jid=async_pub["jid"],
                daemonize=False,
            )
        return wrapper
    def __len__(self):
        return len(self.client.functions)
    def __iter__(self):
        return iter(self.client.functions)
class ClientStateMixin:
    def __init__(self, opts, context=None):
        self.opts = opts
        if context is None:
            context = {}
        self.context = context
    def __getstate__(self):
        return {
            "opts": self.opts,
            "context": self.context or None,
        }
    def __setstate__(self, state):
        self.__init__(state["opts"], context=state["context"])
class SyncClientMixin(ClientStateMixin):
    functions = ()
    def functions_dict(self):
        return ClientFuncsDict(self)
    def master_call(self, **kwargs):
        load = kwargs
        load["cmd"] = self.client
        with salt.channel.client.ReqChannel.factory(
            self.opts, crypt="clear", usage="master_call"
        ) as channel:
            ret = channel.send(load)
            if isinstance(ret, Mapping):
                if "error" in ret:
                    salt.utils.error.raise_error(**ret["error"])
            return ret
    def cmd_sync(self, low, timeout=None, full_return=False):
        with salt.utils.event.get_master_event(
            self.opts, self.opts["sock_dir"], listen=True
        ) as event:
            job = self.master_call(**low)
            ret_tag = salt.utils.event.tagify("ret", base=job["tag"])
            if timeout is None:
                timeout = self.opts.get("rest_timeout", 300)
            ret = event.get_event(
                tag=ret_tag, full=True, wait=timeout, auto_reconnect=True
            )
            if ret is None:
                raise salt.exceptions.SaltClientTimeout(
                    "RunnerClient job '{}' timed out".format(job["jid"]),
                    jid=job["jid"],
                )
            return ret if full_return else ret["data"]["return"]
    def cmd(
        self,
        fun,
        arg=None,
        pub_data=None,
        kwarg=None,
        print_event=True,
        full_return=False,
    ):
        if arg is None:
            arg = tuple()
        if not isinstance(arg, list) and not isinstance(arg, tuple):
            raise salt.exceptions.SaltInvocationError(
                "arg must be formatted as a list/tuple"
            )
        if pub_data is None:
            pub_data = {}
        if not isinstance(pub_data, dict):
            raise salt.exceptions.SaltInvocationError(
                "pub_data must be formatted as a dictionary"
            )
        if kwarg is None:
            kwarg = {}
        if not isinstance(kwarg, dict):
            raise salt.exceptions.SaltInvocationError(
                "kwarg must be formatted as a dictionary"
            )
        arglist = salt.utils.args.parse_input(
            arg, no_parse=self.opts.get("no_parse", [])
        )
        if kwarg:
            kwarg["__kwarg__"] = True
            arglist.append(kwarg)
        args, kwargs = salt.minion.load_args_and_kwargs(
            self.functions[fun], arglist, pub_data
        )
        low = {"fun": fun, "arg": args, "kwarg": kwargs}
        return self.low(fun, low, print_event=print_event, full_return=full_return)
    @property
    def mminion(self):
        if not hasattr(self, "_mminion"):
            self._mminion = salt.minion.MasterMinion(
                self.opts, states=False, rend=False
            )
        return self._mminion
    @property
    def store_job(self):
        try:
            class_name = self.__class__.__name__.lower()
        except AttributeError:
            log.warning(
                "Unable to determine class name", exc_info_on_loglevel=logging.DEBUG
            )
            return True
        try:
            return self.opts["{}_returns".format(class_name)]
        except KeyError:
            return True
    def low(self, fun, low, print_event=True, full_return=False):
        self.mminion  # pylint: disable=W0104
        jid = low.get("__jid__", salt.utils.jid.gen_jid(self.opts))
        tag = low.get("__tag__", salt.utils.event.tagify(jid, prefix=self.tag_prefix))
        data = {
            "fun": "{}.{}".format(self.client, fun),
            "jid": jid,
            "user": low.get("__user__", "UNKNOWN"),
        }
        if print_event:
            print_func = (
                self.print_async_event if hasattr(self, "print_async_event") else None
            )
        else:
            print_func = None
        with salt.utils.event.NamespacedEvent(
            salt.utils.event.get_event(
                "master",
                self.opts["sock_dir"],
                opts=self.opts,
                listen=False,
            ),
            tag,
            print_func=print_func,
        ) as namespaced_event:
            func_globals = {
                "__jid__": jid,
                "__user__": data["user"],
                "__tag__": tag,
                "__jid_event__": weakref.proxy(namespaced_event),
            }
            try:
                self_functions = copy.copy(self.functions)
                salt.utils.lazy.verify_fun(self_functions, fun)
                completed_funcs = []
                for mod_name in self_functions.keys():
                    if "." not in mod_name:
                        continue
                    mod, _ = mod_name.split(".", 1)
                    if mod in completed_funcs:
                        continue
                    completed_funcs.append(mod)
                    for global_key, value in func_globals.items():
                        self.functions[mod_name].__globals__[global_key] = value
                if "arg" in low and "kwarg" in low:
                    args = low["arg"]
                    kwargs = low["kwarg"]
                else:
                    f_call = salt.utils.args.format_call(
                        self.functions[fun],
                        low,
                        expected_extra_kws=CLIENT_INTERNAL_KEYWORDS,
                    )
                    args = f_call.get("args", ())
                    kwargs = f_call.get("kwargs", {})
                data["fun_args"] = list(args) + ([kwargs] if kwargs else [])
                func_globals["__jid_event__"].fire_event(data, "new")
                with salt.ext.tornado.stack_context.StackContext(
                    self.functions.context_dict.clone
                ):
                    func = self.functions[fun]
                    try:
                        data["return"] = func(*args, **kwargs)
                    except TypeError as exc:
                        data[
                            "return"
                        ] = "\nPassed invalid arguments: {}\n\nUsage:\n{}".format(
                            exc, func.__doc__
                        )
                    try:
                        data["success"] = self.context.get("retcode", 0) == 0
                    except AttributeError:
                        data["success"] = True
                    if isinstance(data["return"], dict) and "data" in data["return"]:
                        data["success"] = salt.utils.state.check_result(
                            data["return"]["data"]
                        )
            except (Exception, SystemExit) as ex:  # pylint: disable=broad-except
                if isinstance(ex, salt.exceptions.NotImplemented):
                    data["return"] = str(ex)
                else:
                    data["return"] = "Exception occurred in {} {}: {}".format(
                        self.client,
                        fun,
                        traceback.format_exc(),
                    )
                data["success"] = False
            if self.store_job:
                try:
                    salt.utils.job.store_job(
                        self.opts,
                        {
                            "id": self.opts["id"],
                            "tgt": self.opts["id"],
                            "jid": data["jid"],
                            "return": data,
                        },
                        event=None,
                        mminion=self.mminion,
                    )
                except salt.exceptions.SaltCacheError:
                    log.error(
                        "Could not store job cache info. "
                        "Job details for this run may be unavailable."
                    )
            namespaced_event.fire_event(data, "ret")
            log.info("Runner completed: %s", data["jid"])
            return data if full_return else data["return"]
    def get_docs(self, arg=None):
        if arg:
            if "*" in arg:
                target_mod = arg
                _use_fnmatch = True
            else:
                target_mod = arg + "." if not arg.endswith(".") else arg
                _use_fnmatch = False
            if _use_fnmatch:
                docs = [
                    (fun, self.functions[fun].__doc__)
                    for fun in fnmatch.filter(self.functions, target_mod)
                ]
            else:
                docs = [
                    (fun, self.functions[fun].__doc__)
                    for fun in sorted(self.functions)
                    if fun == arg or fun.startswith(target_mod)
                ]
        else:
            docs = [
                (fun, self.functions[fun].__doc__) for fun in sorted(self.functions)
            ]
        docs = dict(docs)
        return salt.utils.doc.strip_rst(docs)
class AsyncClientMixin(ClientStateMixin):
    client = None
    tag_prefix = None
    def _proc_function_remote(self, *, fun, low, user, tag, jid, daemonize=True):
        if daemonize and not salt.utils.platform.is_windows():
            salt.log.setup.shutdown_multiprocessing_logging()
            salt.utils.process.daemonize()
            salt.log.setup.setup_multiprocessing_logging()
        low["__jid__"] = jid
        low["__user__"] = user
        low["__tag__"] = tag
        try:
            return self.cmd_sync(low)
        except salt.exceptions.EauthAuthenticationError as exc:
            log.error(exc)
    def _proc_function(self, *, fun, low, user, tag, jid, daemonize=True):
        if daemonize and not salt.utils.platform.is_windows():
            salt.log.setup.shutdown_multiprocessing_logging()
            salt.utils.process.daemonize()
            salt.log.setup.setup_multiprocessing_logging()
        low["__jid__"] = jid
        low["__user__"] = user
        low["__tag__"] = tag
        return self.low(fun, low)
    def cmd_async(self, low):
        return self.master_call(**low)
    def _gen_async_pub(self, jid=None):
        if jid is None:
            jid = salt.utils.jid.gen_jid(self.opts)
        tag = salt.utils.event.tagify(jid, prefix=self.tag_prefix)
        return {"tag": tag, "jid": jid}
    def asynchronous(self, fun, low, user="UNKNOWN", pub=None, local=True):
        if local:
            proc_func = self._proc_function
        else:
            proc_func = self._proc_function_remote
        async_pub = pub if pub is not None else self._gen_async_pub()
        with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):
            proc = salt.utils.process.SignalHandlingProcess(
                target=proc_func,
                name="ProcessFunc({}, fun={} jid={})".format(
                    proc_func.__qualname__, fun, async_pub["jid"]
                ),
                kwargs=dict(
                    fun=fun,
                    low=low,
                    user=user,
                    tag=async_pub["tag"],
                    jid=async_pub["jid"],
                ),
            )
            proc.start()
        proc.join()  # MUST join, otherwise we leave zombies all over
        return async_pub
    def print_async_event(self, suffix, event):
        if not isinstance(event, dict):
            return
        if self.opts.get("quiet", False):
            return
        if suffix in ("new",):
            return
        try:
            outputter = self.opts.get(
                "output",
                event.get("outputter", None) or event.get("return").get("outputter"),
            )
        except AttributeError:
            outputter = None
        if suffix == "ret":
            if isinstance(event.get("return"), dict) and set(event["return"]) == {
                "data",
                "outputter",
            }:
                event_data = event["return"]["data"]
                outputter = event["return"]["outputter"]
            else:
                event_data = event["return"]
        else:
            event_data = {"suffix": suffix, "event": event}
        salt.output.display_output(event_data, outputter, self.opts)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
