<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_elb_1.py &amp; mixins_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_elb_1.py &amp; mixins_3.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_elb_1.py (3.1088083%)<th>mixins_3.py (1.509434%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-13)<td><a href="#" name="0">(5-17)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_elb_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os.path
2 import sys
3 from copy import deepcopy
4 import salt.config
5 import salt.loader
6 import salt.modules.boto_elb as boto_elb
7 import salt.utils.versions
8 from tests.support.mixins import LoaderModuleMockMixin
9 from tests.support.mock import MagicMock, patch
10 from tests.support.runtests import RUNTIME_VARS
11 from</b></font> tests.support.unit import TestCase, skipIf
12 try:
13     import boto
14     boto.ENDPOINTS_PATH = os.path.join(
15         RUNTIME_VARS.TESTS_DIR, "unit/files/endpoints.json"
16     )
17     import boto.ec2.elb
18     HAS_BOTO = True
19 except ImportError:
20     HAS_BOTO = False
21 try:
22     import pkg_resources
23     from moto import mock_ec2_deprecated  # pylint: disable=no-name-in-module
24     from moto import mock_elb_deprecated  # pylint: disable=no-name-in-module
25     HAS_MOTO = True
26 except ImportError:
27     HAS_MOTO = False
28     def mock_ec2_deprecated(self):
29         def stub_function(self):
30             pass
31         return stub_function
32     def mock_elb_deprecated(self):
33         def stub_function(self):
34             pass
35         return stub_function
36 log = logging.getLogger(__name__)
37 region = "us-east-1"
38 access_key = "GKTADJGHEIQSXMKKRBJ08H"
39 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
40 conn_parameters = {
41     "region": region,
42     "key": access_key,
43     "keyid": secret_key,
44     "profile": {},
45 }
46 boto_conn_parameters = {
47     "aws_access_key_id": access_key,
48     "aws_secret_access_key": secret_key,
49 }
50 instance_parameters = {"instance_type": "t1.micro"}
51 required_moto = "0.3.7"
52 required_moto_py3 = "1.0.1"
53 def _has_required_moto():
54     if not HAS_MOTO:
55         return False
56     else:
57         moto_version = salt.utils.versions.LooseVersion(
58             pkg_resources.get_distribution("moto").version
59         )
60         if moto_version &lt; salt.utils.versions.LooseVersion(required_moto):
61             return False
62         elif moto_version &lt; salt.utils.versions.LooseVersion(required_moto_py3):
63             return False
64     return True
65 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
66 @skipIf(HAS_MOTO is False, "The moto module must be installed.")
67 @skipIf(
68     _has_required_moto() is False,
69     "The moto module must be &gt;= to {} for PY2 or {} for PY3.".format(
70         required_moto, required_moto_py3
71     ),
72 )
73 class BotoElbTestCase(TestCase, LoaderModuleMockMixin):
74     def setup_loader_modules(self):
75         opts = salt.config.DEFAULT_MASTER_OPTS.copy()
76         utils = salt.loader.utils(
77             opts, whitelist=["boto", "args", "systemd", "path", "platform"]
78         )
79         funcs = salt.loader.minion_mods(opts, utils=utils)
80         return {boto_elb: {"__opts__": opts, "__utils__": utils, "__salt__": funcs}}
81     def setUp(self):
82         TestCase.setUp(self)
83         boto_elb.__virtual__()
84     @mock_ec2_deprecated
85     @mock_elb_deprecated
86     def test_register_instances_valid_id_result_true(self):
87         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
88         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
89         zones = [zone.name for zone in conn_ec2.get_all_zones()]
90         elb_name = "TestRegisterInstancesValidIdResult"
91         conn_elb.create_load_balancer(elb_name, zones, [(80, 80, "http")])
92         reservations = conn_ec2.run_instances("ami-08389d60")
93         register_result = boto_elb.register_instances(
94             elb_name, reservations.instances[0].id, **conn_parameters
95         )
96         self.assertEqual(True, register_result)
97     @mock_ec2_deprecated
98     @mock_elb_deprecated
99     def test_register_instances_valid_id_string(self):
100         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
101         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
102         zones = [zone.name for zone in conn_ec2.get_all_zones()]
103         elb_name = "TestRegisterInstancesValidIdResult"
104         conn_elb.create_load_balancer(elb_name, zones, [(80, 80, "http")])
105         reservations = conn_ec2.run_instances("ami-08389d60")
106         boto_elb.register_instances(
107             elb_name, reservations.instances[0].id, **conn_parameters
108         )
109         load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
110         registered_instance_ids = [
111             instance.id for instance in load_balancer_refreshed.instances
112         ]
113         log.debug(load_balancer_refreshed.instances)
114         self.assertEqual([reservations.instances[0].id], registered_instance_ids)
115     @mock_ec2_deprecated
116     @mock_elb_deprecated
117     def test_deregister_instances_valid_id_result_true(self):
118         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
119         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
120         zones = [zone.name for zone in conn_ec2.get_all_zones()]
121         elb_name = "TestDeregisterInstancesValidIdResult"
122         load_balancer = conn_elb.create_load_balancer(
123             elb_name, zones, [(80, 80, "http")]
124         )
125         reservations = conn_ec2.run_instances("ami-08389d60")
126         load_balancer.register_instances(reservations.instances[0].id)
127         deregister_result = boto_elb.deregister_instances(
128             elb_name, reservations.instances[0].id, **conn_parameters
129         )
130         self.assertEqual(True, deregister_result)
131     @mock_ec2_deprecated
132     @mock_elb_deprecated
133     def test_deregister_instances_valid_id_string(self):
134         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
135         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
136         zones = [zone.name for zone in conn_ec2.get_all_zones()]
137         elb_name = "TestDeregisterInstancesValidIdString"
138         load_balancer = conn_elb.create_load_balancer(
139             elb_name, zones, [(80, 80, "http")]
140         )
141         reservations = conn_ec2.run_instances("ami-08389d60", min_count=2)
142         all_instance_ids = [instance.id for instance in reservations.instances]
143         load_balancer.register_instances(all_instance_ids)
144         boto_elb.deregister_instances(
145             elb_name, reservations.instances[0].id, **conn_parameters
146         )
147         load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
148         expected_instances = deepcopy(all_instance_ids)
149         expected_instances.remove(reservations.instances[0].id)
150         actual_instances = [
151             instance.id for instance in load_balancer_refreshed.instances
152         ]
153         self.assertEqual(actual_instances, expected_instances)
154     @mock_ec2_deprecated
155     @mock_elb_deprecated
156     def test_deregister_instances_valid_id_list(self):
157         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
158         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
159         zones = [zone.name for zone in conn_ec2.get_all_zones()]
160         elb_name = "TestDeregisterInstancesValidIdList"
161         load_balancer = conn_elb.create_load_balancer(
162             elb_name, zones, [(80, 80, "http")]
163         )
164         reservations = conn_ec2.run_instances("ami-08389d60", min_count=3)
165         all_instance_ids = [instance.id for instance in reservations.instances]
166         load_balancer.register_instances(all_instance_ids)
167         deregister_instances = [instance.id for instance in reservations.instances[:-1]]
168         expected_instances = [reservations.instances[-1].id]
169         boto_elb.deregister_instances(elb_name, deregister_instances, **conn_parameters)
170         load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
171         actual_instances = [
172             instance.id for instance in load_balancer_refreshed.instances
173         ]
174         self.assertEqual(actual_instances, expected_instances)
175     @mock_ec2_deprecated
176     @mock_elb_deprecated
177     @skipIf(
178         sys.version_info &gt; (3, 6),
179         "Disabled for 3.7+ pending https://github.com/spulec/moto/issues/1706.",
180     )
181     def test_get_elb_config(self):
182         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
183         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
184         zones = [zone.name for zone in conn_ec2.get_all_zones()]
185         elb_name = "TestGetELBConfig"
186         load_balancer = conn_elb.create_load_balancer(
187             elb_name, zones, [(80, 80, "http")]
188         )
189         reservations = conn_ec2.run_instances("ami-08389d60", min_count=3)
190         all_instance_ids = [instance.id for instance in reservations.instances]
191         load_balancer.register_instances(all_instance_ids)
192         with patch("salt.modules.boto_elb._get_all_tags", MagicMock(return_value=None)):
193             ret = boto_elb.get_elb_config(elb_name, **conn_parameters)
194             _expected_keys = [
195                 "subnets",
196                 "availability_zones",
197                 "canonical_hosted_zone_name_id",
198                 "tags",
199                 "dns_name",
200                 "listeners",
201                 "backends",
202                 "policies",
203                 "vpc_id",
204                 "scheme",
205                 "canonical_hosted_zone_name",
206                 "security_groups",
207             ]
208             for key in _expected_keys:
209                 self.assertIn(key, ret)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mixins_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
2 import fnmatch
3 import logging
4 import signal
5 import traceback
6 import weakref
7 from collections.abc import Mapping, MutableMapping
8 import salt.channel.client
9 import salt.exceptions
10 import salt.ext.tornado.stack_context
11 import salt.log.setup
12 import</b></font> salt.minion
13 import salt.output
14 import salt.utils.args
15 import salt.utils.doc
16 import salt.utils.error
17 import salt.utils.event
18 import salt.utils.jid
19 import salt.utils.job
20 import salt.utils.lazy
21 import salt.utils.platform
22 import salt.utils.process
23 import salt.utils.state
24 import salt.utils.user
25 import salt.utils.versions
26 log = logging.getLogger(__name__)
27 CLIENT_INTERNAL_KEYWORDS = frozenset(
28     [
29         "client",
30         "cmd",
31         "eauth",
32         "fun",
33         "kwarg",
34         "match",
35         "token",
36         "__jid__",
37         "__tag__",
38         "__user__",
39         "username",
40         "password",
41         "full_return",
42         "print_event",
43     ]
44 )
45 class ClientFuncsDict(MutableMapping):
46     def __init__(self, client):
47         self.client = client
48     def __getattr__(self, attr):
49         return getattr(self.client.functions, attr)
50     def __setitem__(self, key, val):
51         raise NotImplementedError()
52     def __delitem__(self, key):
53         raise NotImplementedError()
54     def __getitem__(self, key):
55         if key not in self.client.functions:
56             raise KeyError
57         def wrapper(*args, **kwargs):
58             low = {
59                 "fun": key,
60                 "args": args,
61                 "kwargs": kwargs,
62             }
63             pub_data = {}
64             kwargs_keys = list(kwargs)
65             for kwargs_key in kwargs_keys:
66                 if kwargs_key.startswith("__pub_"):
67                     pub_data[kwargs_key] = kwargs.pop(kwargs_key)
68             async_pub = self.client._gen_async_pub(pub_data.get("__pub_jid"))
69             user = salt.utils.user.get_specific_user()
70             return self.client._proc_function(
71                 fun=key,
72                 low=low,
73                 user=user,
74                 tag=async_pub["tag"],
75                 jid=async_pub["jid"],
76                 daemonize=False,
77             )
78         return wrapper
79     def __len__(self):
80         return len(self.client.functions)
81     def __iter__(self):
82         return iter(self.client.functions)
83 class ClientStateMixin:
84     def __init__(self, opts, context=None):
85         self.opts = opts
86         if context is None:
87             context = {}
88         self.context = context
89     def __getstate__(self):
90         return {
91             "opts": self.opts,
92             "context": self.context or None,
93         }
94     def __setstate__(self, state):
95         self.__init__(state["opts"], context=state["context"])
96 class SyncClientMixin(ClientStateMixin):
97     functions = ()
98     def functions_dict(self):
99         return ClientFuncsDict(self)
100     def master_call(self, **kwargs):
101         load = kwargs
102         load["cmd"] = self.client
103         with salt.channel.client.ReqChannel.factory(
104             self.opts, crypt="clear", usage="master_call"
105         ) as channel:
106             ret = channel.send(load)
107             if isinstance(ret, Mapping):
108                 if "error" in ret:
109                     salt.utils.error.raise_error(**ret["error"])
110             return ret
111     def cmd_sync(self, low, timeout=None, full_return=False):
112         with salt.utils.event.get_master_event(
113             self.opts, self.opts["sock_dir"], listen=True
114         ) as event:
115             job = self.master_call(**low)
116             ret_tag = salt.utils.event.tagify("ret", base=job["tag"])
117             if timeout is None:
118                 timeout = self.opts.get("rest_timeout", 300)
119             ret = event.get_event(
120                 tag=ret_tag, full=True, wait=timeout, auto_reconnect=True
121             )
122             if ret is None:
123                 raise salt.exceptions.SaltClientTimeout(
124                     "RunnerClient job '{}' timed out".format(job["jid"]),
125                     jid=job["jid"],
126                 )
127             return ret if full_return else ret["data"]["return"]
128     def cmd(
129         self,
130         fun,
131         arg=None,
132         pub_data=None,
133         kwarg=None,
134         print_event=True,
135         full_return=False,
136     ):
137         if arg is None:
138             arg = tuple()
139         if not isinstance(arg, list) and not isinstance(arg, tuple):
140             raise salt.exceptions.SaltInvocationError(
141                 "arg must be formatted as a list/tuple"
142             )
143         if pub_data is None:
144             pub_data = {}
145         if not isinstance(pub_data, dict):
146             raise salt.exceptions.SaltInvocationError(
147                 "pub_data must be formatted as a dictionary"
148             )
149         if kwarg is None:
150             kwarg = {}
151         if not isinstance(kwarg, dict):
152             raise salt.exceptions.SaltInvocationError(
153                 "kwarg must be formatted as a dictionary"
154             )
155         arglist = salt.utils.args.parse_input(
156             arg, no_parse=self.opts.get("no_parse", [])
157         )
158         if kwarg:
159             kwarg["__kwarg__"] = True
160             arglist.append(kwarg)
161         args, kwargs = salt.minion.load_args_and_kwargs(
162             self.functions[fun], arglist, pub_data
163         )
164         low = {"fun": fun, "arg": args, "kwarg": kwargs}
165         return self.low(fun, low, print_event=print_event, full_return=full_return)
166     @property
167     def mminion(self):
168         if not hasattr(self, "_mminion"):
169             self._mminion = salt.minion.MasterMinion(
170                 self.opts, states=False, rend=False
171             )
172         return self._mminion
173     @property
174     def store_job(self):
175         try:
176             class_name = self.__class__.__name__.lower()
177         except AttributeError:
178             log.warning(
179                 "Unable to determine class name", exc_info_on_loglevel=logging.DEBUG
180             )
181             return True
182         try:
183             return self.opts["{}_returns".format(class_name)]
184         except KeyError:
185             return True
186     def low(self, fun, low, print_event=True, full_return=False):
187         self.mminion  # pylint: disable=W0104
188         jid = low.get("__jid__", salt.utils.jid.gen_jid(self.opts))
189         tag = low.get("__tag__", salt.utils.event.tagify(jid, prefix=self.tag_prefix))
190         data = {
191             "fun": "{}.{}".format(self.client, fun),
192             "jid": jid,
193             "user": low.get("__user__", "UNKNOWN"),
194         }
195         if print_event:
196             print_func = (
197                 self.print_async_event if hasattr(self, "print_async_event") else None
198             )
199         else:
200             print_func = None
201         with salt.utils.event.NamespacedEvent(
202             salt.utils.event.get_event(
203                 "master",
204                 self.opts["sock_dir"],
205                 opts=self.opts,
206                 listen=False,
207             ),
208             tag,
209             print_func=print_func,
210         ) as namespaced_event:
211             func_globals = {
212                 "__jid__": jid,
213                 "__user__": data["user"],
214                 "__tag__": tag,
215                 "__jid_event__": weakref.proxy(namespaced_event),
216             }
217             try:
218                 self_functions = copy.copy(self.functions)
219                 salt.utils.lazy.verify_fun(self_functions, fun)
220                 completed_funcs = []
221                 for mod_name in self_functions.keys():
222                     if "." not in mod_name:
223                         continue
224                     mod, _ = mod_name.split(".", 1)
225                     if mod in completed_funcs:
226                         continue
227                     completed_funcs.append(mod)
228                     for global_key, value in func_globals.items():
229                         self.functions[mod_name].__globals__[global_key] = value
230                 if "arg" in low and "kwarg" in low:
231                     args = low["arg"]
232                     kwargs = low["kwarg"]
233                 else:
234                     f_call = salt.utils.args.format_call(
235                         self.functions[fun],
236                         low,
237                         expected_extra_kws=CLIENT_INTERNAL_KEYWORDS,
238                     )
239                     args = f_call.get("args", ())
240                     kwargs = f_call.get("kwargs", {})
241                 data["fun_args"] = list(args) + ([kwargs] if kwargs else [])
242                 func_globals["__jid_event__"].fire_event(data, "new")
243                 with salt.ext.tornado.stack_context.StackContext(
244                     self.functions.context_dict.clone
245                 ):
246                     func = self.functions[fun]
247                     try:
248                         data["return"] = func(*args, **kwargs)
249                     except TypeError as exc:
250                         data[
251                             "return"
252                         ] = "\nPassed invalid arguments: {}\n\nUsage:\n{}".format(
253                             exc, func.__doc__
254                         )
255                     try:
256                         data["success"] = self.context.get("retcode", 0) == 0
257                     except AttributeError:
258                         data["success"] = True
259                     if isinstance(data["return"], dict) and "data" in data["return"]:
260                         data["success"] = salt.utils.state.check_result(
261                             data["return"]["data"]
262                         )
263             except (Exception, SystemExit) as ex:  # pylint: disable=broad-except
264                 if isinstance(ex, salt.exceptions.NotImplemented):
265                     data["return"] = str(ex)
266                 else:
267                     data["return"] = "Exception occurred in {} {}: {}".format(
268                         self.client,
269                         fun,
270                         traceback.format_exc(),
271                     )
272                 data["success"] = False
273             if self.store_job:
274                 try:
275                     salt.utils.job.store_job(
276                         self.opts,
277                         {
278                             "id": self.opts["id"],
279                             "tgt": self.opts["id"],
280                             "jid": data["jid"],
281                             "return": data,
282                         },
283                         event=None,
284                         mminion=self.mminion,
285                     )
286                 except salt.exceptions.SaltCacheError:
287                     log.error(
288                         "Could not store job cache info. "
289                         "Job details for this run may be unavailable."
290                     )
291             namespaced_event.fire_event(data, "ret")
292             log.info("Runner completed: %s", data["jid"])
293             return data if full_return else data["return"]
294     def get_docs(self, arg=None):
295         if arg:
296             if "*" in arg:
297                 target_mod = arg
298                 _use_fnmatch = True
299             else:
300                 target_mod = arg + "." if not arg.endswith(".") else arg
301                 _use_fnmatch = False
302             if _use_fnmatch:
303                 docs = [
304                     (fun, self.functions[fun].__doc__)
305                     for fun in fnmatch.filter(self.functions, target_mod)
306                 ]
307             else:
308                 docs = [
309                     (fun, self.functions[fun].__doc__)
310                     for fun in sorted(self.functions)
311                     if fun == arg or fun.startswith(target_mod)
312                 ]
313         else:
314             docs = [
315                 (fun, self.functions[fun].__doc__) for fun in sorted(self.functions)
316             ]
317         docs = dict(docs)
318         return salt.utils.doc.strip_rst(docs)
319 class AsyncClientMixin(ClientStateMixin):
320     client = None
321     tag_prefix = None
322     def _proc_function_remote(self, *, fun, low, user, tag, jid, daemonize=True):
323         if daemonize and not salt.utils.platform.is_windows():
324             salt.log.setup.shutdown_multiprocessing_logging()
325             salt.utils.process.daemonize()
326             salt.log.setup.setup_multiprocessing_logging()
327         low["__jid__"] = jid
328         low["__user__"] = user
329         low["__tag__"] = tag
330         try:
331             return self.cmd_sync(low)
332         except salt.exceptions.EauthAuthenticationError as exc:
333             log.error(exc)
334     def _proc_function(self, *, fun, low, user, tag, jid, daemonize=True):
335         if daemonize and not salt.utils.platform.is_windows():
336             salt.log.setup.shutdown_multiprocessing_logging()
337             salt.utils.process.daemonize()
338             salt.log.setup.setup_multiprocessing_logging()
339         low["__jid__"] = jid
340         low["__user__"] = user
341         low["__tag__"] = tag
342         return self.low(fun, low)
343     def cmd_async(self, low):
344         return self.master_call(**low)
345     def _gen_async_pub(self, jid=None):
346         if jid is None:
347             jid = salt.utils.jid.gen_jid(self.opts)
348         tag = salt.utils.event.tagify(jid, prefix=self.tag_prefix)
349         return {"tag": tag, "jid": jid}
350     def asynchronous(self, fun, low, user="UNKNOWN", pub=None, local=True):
351         if local:
352             proc_func = self._proc_function
353         else:
354             proc_func = self._proc_function_remote
355         async_pub = pub if pub is not None else self._gen_async_pub()
356         with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):
357             proc = salt.utils.process.SignalHandlingProcess(
358                 target=proc_func,
359                 name="ProcessFunc({}, fun={} jid={})".format(
360                     proc_func.__qualname__, fun, async_pub["jid"]
361                 ),
362                 kwargs=dict(
363                     fun=fun,
364                     low=low,
365                     user=user,
366                     tag=async_pub["tag"],
367                     jid=async_pub["jid"],
368                 ),
369             )
370             proc.start()
371         proc.join()  # MUST join, otherwise we leave zombies all over
372         return async_pub
373     def print_async_event(self, suffix, event):
374         if not isinstance(event, dict):
375             return
376         if self.opts.get("quiet", False):
377             return
378         if suffix in ("new",):
379             return
380         try:
381             outputter = self.opts.get(
382                 "output",
383                 event.get("outputter", None) or event.get("return").get("outputter"),
384             )
385         except AttributeError:
386             outputter = None
387         if suffix == "ret":
388             if isinstance(event.get("return"), dict) and set(event["return"]) == {
389                 "data",
390                 "outputter",
391             }:
392                 event_data = event["return"]["data"]
393                 outputter = event["return"]["outputter"]
394             else:
395                 event_data = event["return"]
396         else:
397             event_data = {"suffix": suffix, "event": event}
398         salt.output.display_output(event_data, outputter, self.opts)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
