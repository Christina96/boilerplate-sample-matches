<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_boto_elb_1.py &amp; mixins_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_boto_elb_1.py &amp; mixins_3.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_boto_elb_1.py (3.1088083%)<th>mixins_3.py (1.509434%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1-13)<td><a href="#" name="0">(5-17)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_boto_elb_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="0"></a><font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import os.path
3 import sys
4 from copy import deepcopy
5 import salt.config
6 import salt.loader
7 import salt.modules.boto_elb as boto_elb
8 import salt.utils.versions
9 from tests.support.mixins import LoaderModuleMockMixin
10 from tests.support.mock import MagicMock, patch
11 from tests.support.runtests import RUNTIME_VARS
12 from</b></font> tests.support.unit import TestCase, skipIf
13 try:
14     import boto
15     boto.ENDPOINTS_PATH = os.path.join(
16         RUNTIME_VARS.TESTS_DIR, "unit/files/endpoints.json"
17     )
18     import boto.ec2.elb
19     HAS_BOTO = True
20 except ImportError:
21     HAS_BOTO = False
22 try:
23     import pkg_resources
24     from moto import mock_ec2_deprecated  # pylint: disable=no-name-in-module
25     from moto import mock_elb_deprecated  # pylint: disable=no-name-in-module
26     HAS_MOTO = True
27 except ImportError:
28     HAS_MOTO = False
29     def mock_ec2_deprecated(self):
30         def stub_function(self):
31             pass
32         return stub_function
33     def mock_elb_deprecated(self):
34         def stub_function(self):
35             pass
36         return stub_function
37 log = logging.getLogger(__name__)
38 region = "us-east-1"
39 access_key = "GKTADJGHEIQSXMKKRBJ08H"
40 secret_key = "askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs"
41 conn_parameters = {
42     "region": region,
43     "key": access_key,
44     "keyid": secret_key,
45     "profile": {},
46 }
47 boto_conn_parameters = {
48     "aws_access_key_id": access_key,
49     "aws_secret_access_key": secret_key,
50 }
51 instance_parameters = {"instance_type": "t1.micro"}
52 required_moto = "0.3.7"
53 required_moto_py3 = "1.0.1"
54 def _has_required_moto():
55     if not HAS_MOTO:
56         return False
57     else:
58         moto_version = salt.utils.versions.LooseVersion(
59             pkg_resources.get_distribution("moto").version
60         )
61         if moto_version &lt; salt.utils.versions.LooseVersion(required_moto):
62             return False
63         elif moto_version &lt; salt.utils.versions.LooseVersion(required_moto_py3):
64             return False
65     return True
66 @skipIf(HAS_BOTO is False, "The boto module must be installed.")
67 @skipIf(HAS_MOTO is False, "The moto module must be installed.")
68 @skipIf(
69     _has_required_moto() is False,
70     "The moto module must be &gt;= to {} for PY2 or {} for PY3.".format(
71         required_moto, required_moto_py3
72     ),
73 )
74 class BotoElbTestCase(TestCase, LoaderModuleMockMixin):
75     def setup_loader_modules(self):
76         opts = salt.config.DEFAULT_MASTER_OPTS.copy()
77         utils = salt.loader.utils(
78             opts, whitelist=["boto", "args", "systemd", "path", "platform"]
79         )
80         funcs = salt.loader.minion_mods(opts, utils=utils)
81         return {boto_elb: {"__opts__": opts, "__utils__": utils, "__salt__": funcs}}
82     def setUp(self):
83         TestCase.setUp(self)
84         boto_elb.__virtual__()
85     @mock_ec2_deprecated
86     @mock_elb_deprecated
87     def test_register_instances_valid_id_result_true(self):
88         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
89         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
90         zones = [zone.name for zone in conn_ec2.get_all_zones()]
91         elb_name = "TestRegisterInstancesValidIdResult"
92         conn_elb.create_load_balancer(elb_name, zones, [(80, 80, "http")])
93         reservations = conn_ec2.run_instances("ami-08389d60")
94         register_result = boto_elb.register_instances(
95             elb_name, reservations.instances[0].id, **conn_parameters
96         )
97         self.assertEqual(True, register_result)
98     @mock_ec2_deprecated
99     @mock_elb_deprecated
100     def test_register_instances_valid_id_string(self):
101         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
102         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
103         zones = [zone.name for zone in conn_ec2.get_all_zones()]
104         elb_name = "TestRegisterInstancesValidIdResult"
105         conn_elb.create_load_balancer(elb_name, zones, [(80, 80, "http")])
106         reservations = conn_ec2.run_instances("ami-08389d60")
107         boto_elb.register_instances(
108             elb_name, reservations.instances[0].id, **conn_parameters
109         )
110         load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
111         registered_instance_ids = [
112             instance.id for instance in load_balancer_refreshed.instances
113         ]
114         log.debug(load_balancer_refreshed.instances)
115         self.assertEqual([reservations.instances[0].id], registered_instance_ids)
116     @mock_ec2_deprecated
117     @mock_elb_deprecated
118     def test_deregister_instances_valid_id_result_true(self):
119         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
120         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
121         zones = [zone.name for zone in conn_ec2.get_all_zones()]
122         elb_name = "TestDeregisterInstancesValidIdResult"
123         load_balancer = conn_elb.create_load_balancer(
124             elb_name, zones, [(80, 80, "http")]
125         )
126         reservations = conn_ec2.run_instances("ami-08389d60")
127         load_balancer.register_instances(reservations.instances[0].id)
128         deregister_result = boto_elb.deregister_instances(
129             elb_name, reservations.instances[0].id, **conn_parameters
130         )
131         self.assertEqual(True, deregister_result)
132     @mock_ec2_deprecated
133     @mock_elb_deprecated
134     def test_deregister_instances_valid_id_string(self):
135         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
136         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
137         zones = [zone.name for zone in conn_ec2.get_all_zones()]
138         elb_name = "TestDeregisterInstancesValidIdString"
139         load_balancer = conn_elb.create_load_balancer(
140             elb_name, zones, [(80, 80, "http")]
141         )
142         reservations = conn_ec2.run_instances("ami-08389d60", min_count=2)
143         all_instance_ids = [instance.id for instance in reservations.instances]
144         load_balancer.register_instances(all_instance_ids)
145         boto_elb.deregister_instances(
146             elb_name, reservations.instances[0].id, **conn_parameters
147         )
148         load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
149         expected_instances = deepcopy(all_instance_ids)
150         expected_instances.remove(reservations.instances[0].id)
151         actual_instances = [
152             instance.id for instance in load_balancer_refreshed.instances
153         ]
154         self.assertEqual(actual_instances, expected_instances)
155     @mock_ec2_deprecated
156     @mock_elb_deprecated
157     def test_deregister_instances_valid_id_list(self):
158         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
159         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
160         zones = [zone.name for zone in conn_ec2.get_all_zones()]
161         elb_name = "TestDeregisterInstancesValidIdList"
162         load_balancer = conn_elb.create_load_balancer(
163             elb_name, zones, [(80, 80, "http")]
164         )
165         reservations = conn_ec2.run_instances("ami-08389d60", min_count=3)
166         all_instance_ids = [instance.id for instance in reservations.instances]
167         load_balancer.register_instances(all_instance_ids)
168         deregister_instances = [instance.id for instance in reservations.instances[:-1]]
169         expected_instances = [reservations.instances[-1].id]
170         boto_elb.deregister_instances(elb_name, deregister_instances, **conn_parameters)
171         load_balancer_refreshed = conn_elb.get_all_load_balancers(elb_name)[0]
172         actual_instances = [
173             instance.id for instance in load_balancer_refreshed.instances
174         ]
175         self.assertEqual(actual_instances, expected_instances)
176     @mock_ec2_deprecated
177     @mock_elb_deprecated
178     @skipIf(
179         sys.version_info &gt; (3, 6),
180         "Disabled for 3.7+ pending https://github.com/spulec/moto/issues/1706.",
181     )
182     def test_get_elb_config(self):
183         conn_ec2 = boto.ec2.connect_to_region(region, **boto_conn_parameters)
184         conn_elb = boto.ec2.elb.connect_to_region(region, **boto_conn_parameters)
185         zones = [zone.name for zone in conn_ec2.get_all_zones()]
186         elb_name = "TestGetELBConfig"
187         load_balancer = conn_elb.create_load_balancer(
188             elb_name, zones, [(80, 80, "http")]
189         )
190         reservations = conn_ec2.run_instances("ami-08389d60", min_count=3)
191         all_instance_ids = [instance.id for instance in reservations.instances]
192         load_balancer.register_instances(all_instance_ids)
193         with patch("salt.modules.boto_elb._get_all_tags", MagicMock(return_value=None)):
194             ret = boto_elb.get_elb_config(elb_name, **conn_parameters)
195             _expected_keys = [
196                 "subnets",
197                 "availability_zones",
198                 "canonical_hosted_zone_name_id",
199                 "tags",
200                 "dns_name",
201                 "listeners",
202                 "backends",
203                 "policies",
204                 "vpc_id",
205                 "scheme",
206                 "canonical_hosted_zone_name",
207                 "security_groups",
208             ]
209             for key in _expected_keys:
210                 self.assertIn(key, ret)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mixins_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import copy
2 import fnmatch
3 import logging
4 import signal
5 import traceback
6 import weakref
7 from collections.abc import Mapping, MutableMapping
8 import salt.channel.client
9 import salt.exceptions
10 import salt.ext.tornado.stack_context
11 import salt.log.setup
12 import</b></font> salt.minion
13 import salt.output
14 import salt.utils.args
15 import salt.utils.doc
16 import salt.utils.error
17 import salt.utils.event
18 import salt.utils.jid
19 import salt.utils.job
20 import salt.utils.lazy
21 import salt.utils.platform
22 import salt.utils.process
23 import salt.utils.state
24 import salt.utils.user
25 import salt.utils.versions
26 log = logging.getLogger(__name__)
27 CLIENT_INTERNAL_KEYWORDS = frozenset(
28     [
29         "client",
30         "cmd",
31         "eauth",
32         "fun",
33         "kwarg",
34         "match",
35         "token",
36         "__jid__",
37         "__tag__",
38         "__user__",
39         "username",
40         "password",
41         "full_return",
42         "print_event",
43     ]
44 )
45 class ClientFuncsDict(MutableMapping):
46     def __init__(self, client):
47         self.client = client
48     def __getattr__(self, attr):
49         return getattr(self.client.functions, attr)
50     def __setitem__(self, key, val):
51         raise NotImplementedError()
52     def __delitem__(self, key):
53         raise NotImplementedError()
54     def __getitem__(self, key):
55         if key not in self.client.functions:
56             raise KeyError
57         def wrapper(*args, **kwargs):
58             low = {
59                 "fun": key,
60                 "args": args,
61                 "kwargs": kwargs,
62             }
63             pub_data = {}
64             kwargs_keys = list(kwargs)
65             for kwargs_key in kwargs_keys:
66                 if kwargs_key.startswith("__pub_"):
67                     pub_data[kwargs_key] = kwargs.pop(kwargs_key)
68             async_pub = self.client._gen_async_pub(pub_data.get("__pub_jid"))
69             user = salt.utils.user.get_specific_user()
70             return self.client._proc_function(
71                 fun=key,
72                 low=low,
73                 user=user,
74                 tag=async_pub["tag"],
75                 jid=async_pub["jid"],
76                 daemonize=False,
77             )
78         return wrapper
79     def __len__(self):
80         return len(self.client.functions)
81     def __iter__(self):
82         return iter(self.client.functions)
83 class ClientStateMixin:
84     def __init__(self, opts, context=None):
85         self.opts = opts
86         if context is None:
87             context = {}
88         self.context = context
89     def __getstate__(self):
90         return {
91             "opts": self.opts,
92             "context": self.context or None,
93         }
94     def __setstate__(self, state):
95         self.__init__(state["opts"], context=state["context"])
96 class SyncClientMixin(ClientStateMixin):
97     functions = ()
98     def functions_dict(self):
99         return ClientFuncsDict(self)
100     def master_call(self, **kwargs):
101         load = kwargs
102         load["cmd"] = self.client
103         with salt.channel.client.ReqChannel.factory(
104             self.opts, crypt="clear", usage="master_call"
105         ) as channel:
106             ret = channel.send(load)
107             if isinstance(ret, Mapping):
108                 if "error" in ret:
109                     salt.utils.error.raise_error(**ret["error"])
110             return ret
111     def cmd_sync(self, low, timeout=None, full_return=False):
112         with salt.utils.event.get_master_event(
113             self.opts, self.opts["sock_dir"], listen=True
114         ) as event:
115             job = self.master_call(**low)
116             ret_tag = salt.utils.event.tagify("ret", base=job["tag"])
117             if timeout is None:
118                 timeout = self.opts.get("rest_timeout", 300)
119             ret = event.get_event(
120                 tag=ret_tag, full=True, wait=timeout, auto_reconnect=True
121             )
122             if ret is None:
123                 raise salt.exceptions.SaltClientTimeout(
124                     "RunnerClient job '{}' timed out".format(job["jid"]),
125                     jid=job["jid"],
126                 )
127             return ret if full_return else ret["data"]["return"]
128     def cmd(
129         self,
130         fun,
131         arg=None,
132         pub_data=None,
133         kwarg=None,
134         print_event=True,
135         full_return=False,
136     ):
137         if arg is None:
138             arg = tuple()
139         if not isinstance(arg, list) and not isinstance(arg, tuple):
140             raise salt.exceptions.SaltInvocationError(
141                 "arg must be formatted as a list/tuple"
142             )
143         if pub_data is None:
144             pub_data = {}
145         if not isinstance(pub_data, dict):
146             raise salt.exceptions.SaltInvocationError(
147                 "pub_data must be formatted as a dictionary"
148             )
149         if kwarg is None:
150             kwarg = {}
151         if not isinstance(kwarg, dict):
152             raise salt.exceptions.SaltInvocationError(
153                 "kwarg must be formatted as a dictionary"
154             )
155         arglist = salt.utils.args.parse_input(
156             arg, no_parse=self.opts.get("no_parse", [])
157         )
158         if kwarg:
159             kwarg["__kwarg__"] = True
160             arglist.append(kwarg)
161         args, kwargs = salt.minion.load_args_and_kwargs(
162             self.functions[fun], arglist, pub_data
163         )
164         low = {"fun": fun, "arg": args, "kwarg": kwargs}
165         return self.low(fun, low, print_event=print_event, full_return=full_return)
166     @property
167     def mminion(self):
168         if not hasattr(self, "_mminion"):
169             self._mminion = salt.minion.MasterMinion(
170                 self.opts, states=False, rend=False
171             )
172         return self._mminion
173     @property
174     def store_job(self):
175         try:
176             class_name = self.__class__.__name__.lower()
177         except AttributeError:
178             log.warning(
179                 "Unable to determine class name", exc_info_on_loglevel=logging.DEBUG
180             )
181             return True
182         try:
183             return self.opts["{}_returns".format(class_name)]
184         except KeyError:
185             return True
186     def low(self, fun, low, print_event=True, full_return=False):
187         self.mminion  # pylint: disable=W0104
188         jid = low.get("__jid__", salt.utils.jid.gen_jid(self.opts))
189         tag = low.get("__tag__", salt.utils.event.tagify(jid, prefix=self.tag_prefix))
190         data = {
191             "fun": "{}.{}".format(self.client, fun),
192             "jid": jid,
193             "user": low.get("__user__", "UNKNOWN"),
194         }
195         if print_event:
196             print_func = (
197                 self.print_async_event if hasattr(self, "print_async_event") else None
198             )
199         else:
200             print_func = None
201         with salt.utils.event.NamespacedEvent(
202             salt.utils.event.get_event(
203                 "master",
204                 self.opts["sock_dir"],
205                 opts=self.opts,
206                 listen=False,
207             ),
208             tag,
209             print_func=print_func,
210         ) as namespaced_event:
211             func_globals = {
212                 "__jid__": jid,
213                 "__user__": data["user"],
214                 "__tag__": tag,
215                 "__jid_event__": weakref.proxy(namespaced_event),
216             }
217             try:
218                 self_functions = copy.copy(self.functions)
219                 salt.utils.lazy.verify_fun(self_functions, fun)
220                 completed_funcs = []
221                 for mod_name in self_functions.keys():
222                     if "." not in mod_name:
223                         continue
224                     mod, _ = mod_name.split(".", 1)
225                     if mod in completed_funcs:
226                         continue
227                     completed_funcs.append(mod)
228                     for global_key, value in func_globals.items():
229                         self.functions[mod_name].__globals__[global_key] = value
230                 if "arg" in low and "kwarg" in low:
231                     args = low["arg"]
232                     kwargs = low["kwarg"]
233                 else:
234                     f_call = salt.utils.args.format_call(
235                         self.functions[fun],
236                         low,
237                         expected_extra_kws=CLIENT_INTERNAL_KEYWORDS,
238                     )
239                     args = f_call.get("args", ())
240                     kwargs = f_call.get("kwargs", {})
241                 data["fun_args"] = list(args) + ([kwargs] if kwargs else [])
242                 func_globals["__jid_event__"].fire_event(data, "new")
243                 with salt.ext.tornado.stack_context.StackContext(
244                     self.functions.context_dict.clone
245                 ):
246                     func = self.functions[fun]
247                     try:
248                         data["return"] = func(*args, **kwargs)
249                     except TypeError as exc:
250                         data[
251                             "return"
252                         ] = "\nPassed invalid arguments: {}\n\nUsage:\n{}".format(
253                             exc, func.__doc__
254                         )
255                     try:
256                         data["success"] = self.context.get("retcode", 0) == 0
257                     except AttributeError:
258                         data["success"] = True
259                     if isinstance(data["return"], dict) and "data" in data["return"]:
260                         data["success"] = salt.utils.state.check_result(
261                             data["return"]["data"]
262                         )
263             except (Exception, SystemExit) as ex:  # pylint: disable=broad-except
264                 if isinstance(ex, salt.exceptions.NotImplemented):
265                     data["return"] = str(ex)
266                 else:
267                     data["return"] = "Exception occurred in {} {}: {}".format(
268                         self.client,
269                         fun,
270                         traceback.format_exc(),
271                     )
272                 data["success"] = False
273             if self.store_job:
274                 try:
275                     salt.utils.job.store_job(
276                         self.opts,
277                         {
278                             "id": self.opts["id"],
279                             "tgt": self.opts["id"],
280                             "jid": data["jid"],
281                             "return": data,
282                         },
283                         event=None,
284                         mminion=self.mminion,
285                     )
286                 except salt.exceptions.SaltCacheError:
287                     log.error(
288                         "Could not store job cache info. "
289                         "Job details for this run may be unavailable."
290                     )
291             namespaced_event.fire_event(data, "ret")
292             log.info("Runner completed: %s", data["jid"])
293             return data if full_return else data["return"]
294     def get_docs(self, arg=None):
295         if arg:
296             if "*" in arg:
297                 target_mod = arg
298                 _use_fnmatch = True
299             else:
300                 target_mod = arg + "." if not arg.endswith(".") else arg
301                 _use_fnmatch = False
302             if _use_fnmatch:
303                 docs = [
304                     (fun, self.functions[fun].__doc__)
305                     for fun in fnmatch.filter(self.functions, target_mod)
306                 ]
307             else:
308                 docs = [
309                     (fun, self.functions[fun].__doc__)
310                     for fun in sorted(self.functions)
311                     if fun == arg or fun.startswith(target_mod)
312                 ]
313         else:
314             docs = [
315                 (fun, self.functions[fun].__doc__) for fun in sorted(self.functions)
316             ]
317         docs = dict(docs)
318         return salt.utils.doc.strip_rst(docs)
319 class AsyncClientMixin(ClientStateMixin):
320     client = None
321     tag_prefix = None
322     def _proc_function_remote(self, *, fun, low, user, tag, jid, daemonize=True):
323         if daemonize and not salt.utils.platform.is_windows():
324             salt.log.setup.shutdown_multiprocessing_logging()
325             salt.utils.process.daemonize()
326             salt.log.setup.setup_multiprocessing_logging()
327         low["__jid__"] = jid
328         low["__user__"] = user
329         low["__tag__"] = tag
330         try:
331             return self.cmd_sync(low)
332         except salt.exceptions.EauthAuthenticationError as exc:
333             log.error(exc)
334     def _proc_function(self, *, fun, low, user, tag, jid, daemonize=True):
335         if daemonize and not salt.utils.platform.is_windows():
336             salt.log.setup.shutdown_multiprocessing_logging()
337             salt.utils.process.daemonize()
338             salt.log.setup.setup_multiprocessing_logging()
339         low["__jid__"] = jid
340         low["__user__"] = user
341         low["__tag__"] = tag
342         return self.low(fun, low)
343     def cmd_async(self, low):
344         return self.master_call(**low)
345     def _gen_async_pub(self, jid=None):
346         if jid is None:
347             jid = salt.utils.jid.gen_jid(self.opts)
348         tag = salt.utils.event.tagify(jid, prefix=self.tag_prefix)
349         return {"tag": tag, "jid": jid}
350     def asynchronous(self, fun, low, user="UNKNOWN", pub=None, local=True):
351         if local:
352             proc_func = self._proc_function
353         else:
354             proc_func = self._proc_function_remote
355         async_pub = pub if pub is not None else self._gen_async_pub()
356         with salt.utils.process.default_signals(signal.SIGINT, signal.SIGTERM):
357             proc = salt.utils.process.SignalHandlingProcess(
358                 target=proc_func,
359                 name="ProcessFunc({}, fun={} jid={})".format(
360                     proc_func.__qualname__, fun, async_pub["jid"]
361                 ),
362                 kwargs=dict(
363                     fun=fun,
364                     low=low,
365                     user=user,
366                     tag=async_pub["tag"],
367                     jid=async_pub["jid"],
368                 ),
369             )
370             proc.start()
371         proc.join()  # MUST join, otherwise we leave zombies all over
372         return async_pub
373     def print_async_event(self, suffix, event):
374         if not isinstance(event, dict):
375             return
376         if self.opts.get("quiet", False):
377             return
378         if suffix in ("new",):
379             return
380         try:
381             outputter = self.opts.get(
382                 "output",
383                 event.get("outputter", None) or event.get("return").get("outputter"),
384             )
385         except AttributeError:
386             outputter = None
387         if suffix == "ret":
388             if isinstance(event.get("return"), dict) and set(event["return"]) == {
389                 "data",
390                 "outputter",
391             }:
392                 event_data = event["return"]["data"]
393                 outputter = event["return"]["outputter"]
394             else:
395                 event_data = event["return"]
396         else:
397             event_data = {"suffix": suffix, "event": event}
398         salt.output.display_output(event_data, outputter, self.opts)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
