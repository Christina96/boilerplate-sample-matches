<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nacl.py &amp; cloud_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nacl.py &amp; cloud_4.py
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nacl.py (17.247097%)<th>cloud_4.py (2.4018476%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(183-186)<td><a href="#" name="0">(259-261)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(269-271)<td><a href="#" name="1">(2999-3001)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(340-341)<td><a href="#" name="2">(262-263)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(196-198)<td><a href="#" name="3">(2771-2773)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(157-159)<td><a href="#" name="4">(2735-2737)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(275-276)<td><a href="#" name="5">(3069-3070)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(188-190)<td><a href="#" name="6">(279-281)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(153-156)<td><a href="#" name="7">(2836-2839)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nacl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import logging
3 import os
4 import salt.syspaths
5 import salt.utils.files
6 import salt.utils.platform
7 import salt.utils.stringutils
8 import salt.utils.versions
9 import salt.utils.win_dacl
10 import salt.utils.win_functions
11 log = logging.getLogger(__name__)
12 REQ_ERROR = None
13 try:
14     import libnacl.secret
15     import libnacl.sealed
16 except (ImportError, OSError) as e:
17     REQ_ERROR = (
18         "libnacl import error, perhaps missing python libnacl package or should update."
19     )
20 __virtualname__ = "nacl"
21 def __virtual__():
22     if __opts__["fips_mode"] is True:
23         return False, "nacl utils not available in FIPS mode"
24     return check_requirements()
25 def check_requirements():
26     return (REQ_ERROR is None, REQ_ERROR)
27 def _get_config(**kwargs):
28     sk_file = kwargs.get("sk_file")
29     if not sk_file:
30         sk_file = os.path.join(kwargs["opts"].get("pki_dir"), "master/nacl")
31     pk_file = kwargs.get("pk_file")
32     if not pk_file:
33         pk_file = os.path.join(kwargs["opts"].get("pki_dir"), "master/nacl.pub")
34     config = {
35         "box_type": kwargs.get("box_type", "sealedbox"),
36         "sk": None,
37         "sk_file": sk_file,
38         "pk": None,
39         "pk_file": pk_file,
40     }
41     config_key = "{}.config".format(__virtualname__)
42     try:
43         config.update(__salt__["config.get"](config_key, {}))
44     except (NameError, KeyError) as e:
45         config.update(kwargs["opts"].get(config_key, {}))
46     for k in set(config.keys()) &amp; set(kwargs.keys()):
47         config[k] = kwargs[k]
48     return config
49 def _get_sk(**kwargs):
50     config = _get_config(**kwargs)
51     key = None
52     if config["sk"]:
53         key = salt.utils.stringutils.to_str(config["sk"])
54     sk_file = config["sk_file"]
55     if not key and sk_file:
56         try:
57             with salt.utils.files.fopen(sk_file, "rb") as keyf:
58                 key = salt.utils.stringutils.to_unicode(keyf.read()).rstrip("\n")
59         except OSError:
60             raise Exception("no key or sk_file found")
61     return base64.b64decode(key)
62 def _get_pk(**kwargs):
63     config = _get_config(**kwargs)
64     pubkey = None
65     if config["pk"]:
66         pubkey = salt.utils.stringutils.to_str(config["pk"])
67     pk_file = config["pk_file"]
68     if not pubkey and pk_file:
69         try:
70             with salt.utils.files.fopen(pk_file, "rb") as keyf:
71                 pubkey = salt.utils.stringutils.to_unicode(keyf.read()).rstrip("\n")
72         except OSError:
73             raise Exception("no pubkey or pk_file found")
74     pubkey = str(pubkey)
75     return base64.b64decode(pubkey)
76 def keygen(sk_file=None, pk_file=None, **kwargs):
77     if "keyfile" in kwargs:
78         sk_file = kwargs["keyfile"]
79     if sk_file is None:
80         kp = libnacl.public.SecretKey()
81         return {"sk": base64.b64encode(kp.sk), "pk": base64.b64encode(kp.pk)}
82     if pk_file is None:
83 <a name="7"></a>        pk_file = "{}.pub".format(sk_file)
84     if sk_file and pk_file is None:
85         if not os.path<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.isfile(sk_file):
86 <a name="4"></a>            kp = libnacl.public.SecretKey()
87             with salt.utils.files.fopen(sk_file, "wb") as keyf:
88                 keyf.</b></font>write(base64.b64encode(kp.sk))
89             if salt<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.platform.is_windows():
90                 cur_user = salt.utils.win_functions.get_current_user()
91                 salt.utils.win_dacl.set_owner(</b></font>sk_file, cur_user)
92                 salt.utils.win_dacl.set_permissions(
93                     sk_file,
94                     cur_user,
95                     "full_control",
96                     "grant",
97                     reset_perms=True,
98                     protected=True,
99                 )
100             else:
101                 os.chmod(sk_file, 1536)
102             return "saved sk_file: {}".format(sk_file)
103         else:
104             raise Exception("sk_file:{} already exist.".format(sk_file))
105     if sk_file is None and pk_file:
106         raise Exception("sk_file: Must be set inorder to generate a public key.")
107     if os.path.isfile(sk_file) and os.path.isfile(pk_file):
108         raise Exception(
109 <a name="0"></a>            "sk_file:{} and pk_file:{} already exist.".format(sk_file, pk_file)
110         )
111     if os.path.isfile(sk_file) and not os<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.isfile(pk_file):
112 <a name="6"></a>        with salt.utils.files.fopen(sk_file, "rb") as keyf:
113             sk = salt.utils.stringutils.to_unicode(keyf.read(</b></font>)).rstrip("\n")
114             sk = base64.b64decode(sk)
115         kp <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= libnacl.public.SecretKey(sk)
116         with salt.utils.files.fopen(pk_file, "wb") as keyf:
117             keyf.write(base64.</b></font>b64encode(kp.pk))
118         return "saved pk_file: {}".format(pk_file)
119 <a name="3"></a>    kp = libnacl.public.SecretKey()
120     with salt.utils.files.fopen(sk_file, "wb") as keyf:
121         keyf.write(base64.b64encode(kp.sk))
122     if salt<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.platform.is_windows():
123         cur_user = salt.utils.win_functions.get_current_user()
124         salt.utils.win_dacl.set_owner(</b></font>sk_file, cur_user)
125         salt.utils.win_dacl.set_permissions(
126             sk_file, cur_user, "full_control", "grant", reset_perms=True, protected=True
127         )
128     else:
129         os.chmod(sk_file, 1536)
130     with salt.utils.files.fopen(pk_file, "wb") as keyf:
131         keyf.write(base64.b64encode(kp.pk))
132     return "saved sk_file:{}  pk_file: {}".format(sk_file, pk_file)
133 def enc(data, **kwargs):
134     if "keyfile" in kwargs:
135         kwargs["sk_file"] = kwargs["keyfile"]
136         kwargs["box_type"] = "secretbox"
137     if "key" in kwargs:
138         kwargs["sk"] = kwargs["key"]
139         kwargs["box_type"] = "secretbox"
140     box_type = _get_config(**kwargs)["box_type"]
141     if box_type == "secretbox":
142         return secretbox_encrypt(data, **kwargs)
143     return sealedbox_encrypt(data, **kwargs)
144 def enc_file(name, out=None, **kwargs):
145     try:
146 <a name="1"></a>        data = __salt__["cp.get_file_str"](name)
147     except Exception as e:  # pylint: disable=broad-except
148         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(name, "rb") as f:
149             data = salt.utils.stringutils.to_unicode(f.read())
150     d =</b></font> enc(data, **kwargs)
151 <a name="5"></a>    if out:
152         if os.path.isfile(out):
153             raise Exception("file:{} already exist.".format(out))
154         <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(out, "wb") as f:
155             f.write(salt.utils.stringutils.to_bytes(</b></font>d))
156         return "Wrote: {}".format(out)
157     return d
158 def dec(data, **kwargs):
159     if "keyfile" in kwargs:
160         kwargs["sk_file"] = kwargs["keyfile"]
161         kwargs["box_type"] = "secretbox"
162     if "key" in kwargs:
163         kwargs["sk"] = kwargs["key"]
164         kwargs["box_type"] = "secretbox"
165     box_type = _get_config(**kwargs)["box_type"]
166     if box_type == "secretbox":
167         return secretbox_decrypt(data, **kwargs)
168     return sealedbox_decrypt(data, **kwargs)
169 def dec_file(name, out=None, **kwargs):
170     try:
171 <a name="2"></a>        data = __salt__["cp.get_file_str"](name)
172     except Exception as e:  # pylint: disable=broad-except
173         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(name, "rb") as f:
174             data = salt.utils.stringutils.to_unicode(f.read(</b></font>))
175     d = dec(data, **kwargs)
176     if out:
177         if os.path.isfile(out):
178             raise Exception("file:{} already exist.".format(out))
179         with salt.utils.files.fopen(out, "wb") as f:
180             f.write(salt.utils.stringutils.to_bytes(d))
181         return "Wrote: {}".format(out)
182     return d
183 def sealedbox_encrypt(data, **kwargs):
184     data = salt.utils.stringutils.to_bytes(data)
185     pk = _get_pk(**kwargs)
186     b = libnacl.sealed.SealedBox(pk)
187     return base64.b64encode(b.encrypt(data))
188 def sealedbox_decrypt(data, **kwargs):
189     if data is None:
190         return None
191     data = salt.utils.stringutils.to_bytes(data)
192     sk = _get_sk(**kwargs)
193     keypair = libnacl.public.SecretKey(sk)
194     b = libnacl.sealed.SealedBox(keypair)
195     return b.decrypt(base64.b64decode(data))
196 def secretbox_encrypt(data, **kwargs):
197     data = salt.utils.stringutils.to_bytes(data)
198     sk = _get_sk(**kwargs)
199     b = libnacl.secret.SecretBox(sk)
200     return base64.b64encode(b.encrypt(data))
201 def secretbox_decrypt(data, **kwargs):
202     if data is None:
203         return None
204     data = salt.utils.stringutils.to_bytes(data)
205     key = _get_sk(**kwargs)
206     b = libnacl.secret.SecretBox(key=key)
207     return b.decrypt(base64.b64decode(data))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>cloud_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import codecs
2 import copy
3 import errno
4 import hashlib
5 import logging
6 import multiprocessing
7 import os
8 import pipes
9 import re
10 import shutil
11 import socket
12 import stat
13 import subprocess
14 import tempfile
15 import time
16 import traceback
17 import uuid
18 import salt.client
19 import salt.cloud
20 import salt.config
21 import salt.crypt
22 import salt.loader
23 import salt.template
24 import salt.utils.compat
25 import salt.utils.crypt
26 import salt.utils.data
27 import salt.utils.event
28 import salt.utils.files
29 import salt.utils.msgpack
30 import salt.utils.path
31 import salt.utils.platform
32 import salt.utils.stringutils
33 import salt.utils.versions
34 import salt.utils.vt
35 import salt.utils.yaml
36 from jinja2 import Template
37 from salt.exceptions import (
38     SaltCloudConfigError,
39     SaltCloudException,
40     SaltCloudExecutionFailure,
41     SaltCloudExecutionTimeout,
42     SaltCloudPasswordError,
43     SaltCloudSystemExit,
44 )
45 from salt.utils.nb_popen import NonBlockingPopen
46 from salt.utils.validate.path import is_writeable
47 try:
48     import salt.utils.smb
49     HAS_SMB = True
50 except ImportError:
51     HAS_SMB = False
52 try:
53     from pypsexec.client import Client as PsExecClient
54     from pypsexec.scmr import Service as ScmrService
55     from pypsexec.exceptions import SCMRException
56     from smbprotocol.tree import TreeConnect
57     from smbprotocol.exceptions import SMBResponseException
58     logging.getLogger("smbprotocol").setLevel(logging.WARNING)
59     logging.getLogger("pypsexec").setLevel(logging.WARNING)
60     HAS_PSEXEC = True
61 except ImportError:
62     HAS_PSEXEC = False
63 WINRM_MIN_VER = "0.3.0"
64 try:
65     import winrm
66     from winrm.exceptions import WinRMTransportError
67     import pkg_resources  # pylint: disable=3rd-party-module-not-gated
68     winrm_pkg = pkg_resources.get_distribution("pywinrm")
69     if not salt.utils.versions.compare(winrm_pkg.version, "&gt;=", WINRM_MIN_VER):
70         HAS_WINRM = False
71     else:
72         HAS_WINRM = True
73 except ImportError:
74     HAS_WINRM = False
75 try:
76     import pwd
77 except ImportError:
78     if not salt.utils.platform.is_windows():
79         raise
80 try:
81     import getpass
82     HAS_GETPASS = True
83 except ImportError:
84     HAS_GETPASS = False
85 MSGPACK_ENCODING = "utf-8"
86 NSTATES = {
87     0: "running",
88     1: "rebooting",
89     2: "terminated",
90     3: "pending",
91 }
92 SSH_PASSWORD_PROMP_RE = re.compile(r"(?:.*)[Pp]assword(?: for .*)?:\ *$", re.M)
93 SSH_PASSWORD_PROMP_SUDO_RE = re.compile(
94     r"(?:.*sudo)(?:.*)[Pp]assword(?: for .*)?:", re.M
95 )
96 SERVER_ALIVE_INTERVAL = 60
97 SERVER_ALIVE_COUNT_MAX = 3
98 log = logging.getLogger(__name__)
99 def __render_script(path, vm_=None, opts=None, minion=""):
100     log.info("Rendering deploy script: %s", path)
101     try:
102         with salt.utils.files.fopen(path, "r") as fp_:
103             template = Template(salt.utils.stringutils.to_unicode(fp_.read()))
104             return str(template.render(opts=opts, vm=vm_, minion=minion))
105     except AttributeError:
106         with salt.utils.files.fopen(path, "r") as fp_:
107             return str(fp_.read())
108 def __ssh_gateway_config_dict(gateway):
109     extended_kwargs = {}
110     if gateway:
111         extended_kwargs["ssh_gateway"] = gateway["ssh_gateway"]
112         extended_kwargs["ssh_gateway_key"] = gateway["ssh_gateway_key"]
113         extended_kwargs["ssh_gateway_user"] = gateway["ssh_gateway_user"]
114         extended_kwargs["ssh_gateway_command"] = gateway["ssh_gateway_command"]
115     return extended_kwargs
116 def __ssh_gateway_arguments(kwargs):
117     extended_arguments = ""
118     ssh_gateway = kwargs.get("ssh_gateway", "")
119     ssh_gateway_port = 22
120     if ":" in ssh_gateway:
121         ssh_gateway, ssh_gateway_port = ssh_gateway.split(":")
122     ssh_gateway_command = kwargs.get("ssh_gateway_command", "nc -q0 %h %p")
123     if ssh_gateway:
124         ssh_gateway_port = kwargs.get("ssh_gateway_port", ssh_gateway_port)
125         ssh_gateway_key = (
126             "-i {}".format(kwargs["ssh_gateway_key"])
127             if "ssh_gateway_key" in kwargs
128             else ""
129         )
130         ssh_gateway_user = kwargs.get("ssh_gateway_user", "root")
131         extended_arguments = " ".join(
132             (
133                 "ssh",
134                 "-oStrictHostKeyChecking=no",
135                 "-oServerAliveInterval={}".format(
136                     kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
137                 ),
138                 "-oServerAliveCountMax={}".format(
139                     kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
140                 ),
141                 "-oUserKnownHostsFile=/dev/null",
142                 "-oControlPath=none",
143                 str(ssh_gateway_key),
144                 "{}@{}".format(ssh_gateway_user, ssh_gateway),
145                 "-p",
146                 str(ssh_gateway_port),
147                 str(ssh_gateway_command),
148             )
149         )
150         log.info(
151             "Using SSH gateway %s@%s:%s %s",
152             ssh_gateway_user,
153             ssh_gateway,
154             ssh_gateway_port,
155             ssh_gateway_command,
156         )
157     return extended_arguments
158 def os_script(os_, vm_=None, opts=None, minion=""):
159     if minion:
160         minion = salt_config_to_yaml(minion)
161     if os.path.isabs(os_):
162         return __render_script(os_, vm_, opts, minion)
163     if os.path.isabs("{}.sh".format(os_)):
164         return __render_script("{}.sh".format(os_), vm_, opts, minion)
165     for search_path in opts["deploy_scripts_search_path"]:
166         if os.path.isfile(os.path.join(search_path, os_)):
167             return __render_script(os.path.join(search_path, os_), vm_, opts, minion)
168         if os.path.isfile(os.path.join(search_path, "{}.sh".format(os_))):
169             return __render_script(
170                 os.path.join(search_path, "{}.sh".format(os_)), vm_, opts, minion
171             )
172     return ""
173 def gen_keys(keysize=2048):
174     if keysize &lt; 2048:
175         keysize = 2048
176     tdir = tempfile.mkdtemp()
177 <a name="0"></a>
178     salt.crypt.gen_keys(tdir, "minion", keysize)
179     priv_path = os.path.join(tdir, "minion.pem")
180 <a name="2"></a>    pub_path = os<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.path.join(tdir, "minion.pub")
181     with salt.utils.files.fopen(priv_path) as fp_:
182         priv = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
183     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(pub_path) as fp_:
184         pub = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
185     shutil.rmtree(tdir)
186     return priv, pub
187 def accept_key(pki_dir, pub, id_):
188     for key_dir in "minions", "minions_pre", "minions_rejected":
189         key_path = os.path.join(pki_dir, key_dir)
190 <a name="6"></a>        if not os.path.exists(key_path):
191             os.makedirs(key_path)
192     key <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.path.join(pki_dir, "minions", id_)
193     with salt.utils.files.fopen(key, "w+") as fp_:
194         fp_.write(salt.</b></font>utils.stringutils.to_str(pub))
195     oldkey = os.path.join(pki_dir, "minions_pre", id_)
196     if os.path.isfile(oldkey):
197         with salt.utils.files.fopen(oldkey) as fp_:
198             if fp_.read() == pub:
199                 os.remove(oldkey)
200 def remove_key(pki_dir, id_):
201     key = os.path.join(pki_dir, "minions", id_)
202     if os.path.isfile(key):
203         os.remove(key)
204         log.debug("Deleted '%s'", key)
205 def rename_key(pki_dir, id_, new_id):
206     oldkey = os.path.join(pki_dir, "minions", id_)
207     newkey = os.path.join(pki_dir, "minions", new_id)
208     if os.path.isfile(oldkey):
209         os.rename(oldkey, newkey)
210 def minion_config(opts, vm_):
211     minion = {
212         "master": "salt",
213         "log_level": "info",
214         "hash_type": "sha256",
215     }
216     minion["id"] = vm_["name"]
217     master_finger = salt.config.get_cloud_config_value("master_finger", vm_, opts)
218     if master_finger is not None:
219         minion["master_finger"] = master_finger
220     minion.update(
221         salt.config.get_cloud_config_value(
222             "minion", vm_, opts, default={}, search_global=True
223         )
224     )
225     make_master = salt.config.get_cloud_config_value("make_master", vm_, opts)
226     if "master" not in minion and make_master is not True:
227         raise SaltCloudConfigError(
228             "A master setting was not defined in the minion's configuration."
229         )
230     minion.setdefault("grains", {}).update(
231         salt.config.get_cloud_config_value(
232             "grains", vm_, opts, default={}, search_global=True
233         )
234     )
235     return minion
236 def master_config(opts, vm_):
237     master = copy.deepcopy(salt.config.DEFAULT_MASTER_OPTS)
238     master.update(log_level="info", log_level_logfile="info", hash_type="sha256")
239     master.update(
240         salt.config.get_cloud_config_value(
241             "master", vm_, opts, default={}, search_global=True
242         )
243     )
244     return master
245 def salt_config_to_yaml(configuration, line_break="\n"):
246     return salt.utils.yaml.safe_dump(
247         configuration, line_break=line_break, default_flow_style=False
248     )
249 def bootstrap(vm_, opts=None):
250     if opts is None:
251         opts = __opts__
252     deploy_config = salt.config.get_cloud_config_value(
253         "deploy", vm_, opts, default=False
254     )
255     inline_script_config = salt.config.get_cloud_config_value(
256         "inline_script", vm_, opts, default=None
257     )
258     if deploy_config is False and inline_script_config is None:
259         return {"Error": {"No Deploy": "'deploy' is not enabled. Not deploying."}}
260     if vm_.get("driver") == "saltify":
261         saltify_driver = True
262     else:
263         saltify_driver = False
264     key_filename = salt.config.get_cloud_config_value(
265         "key_filename",
266         vm_,
267         opts,
268         search_global=False,
269         default=salt.config.get_cloud_config_value(
270             "ssh_keyfile", vm_, opts, search_global=False, default=None
271         ),
272     )
273     if key_filename is not None and not os.path.isfile(key_filename):
274         raise SaltCloudConfigError(
275             "The defined ssh_keyfile '{}' does not exist".format(key_filename)
276         )
277     has_ssh_agent = False
278     if (
279         opts.get("ssh_agent", False)
280         and "SSH_AUTH_SOCK" in os.environ
281         and stat.S_ISSOCK(os.stat(os.environ["SSH_AUTH_SOCK"]).st_mode)
282     ):
283         has_ssh_agent = True
284     if (
285         key_filename is None
286         and salt.config.get_cloud_config_value("password", vm_, opts, default=None)
287         is None
288         and salt.config.get_cloud_config_value("win_password", vm_, opts, default=None)
289         is None
290         and has_ssh_agent is False
291     ):
292         raise SaltCloudSystemExit(
293             "Cannot deploy Salt in a VM if the 'key_filename' setting "
294             "is not set and there is no password set for the VM. "
295             "Check the provider docs for 'change_password' option if it "
296             "is supported by your provider."
297         )
298     ret = {}
299     minion_conf = minion_config(opts, vm_)
300     deploy_script_code = os_script(
301         salt.config.get_cloud_config_value("os", vm_, opts, default="bootstrap-salt"),
302         vm_,
303         opts,
304         minion_conf,
305     )
306     ssh_username = salt.config.get_cloud_config_value(
307         "ssh_username", vm_, opts, default="root"
308     )
309     if "file_transport" not in opts:
310         opts["file_transport"] = vm_.get("file_transport", "sftp")
311     if "pub_key" not in vm_ and "priv_key" not in vm_:
312         log.debug("Generating keys for '%s'", vm_["name"])
313         vm_["priv_key"], vm_["pub_key"] = gen_keys(
314             salt.config.get_cloud_config_value("keysize", vm_, opts)
315         )
316         key_id = vm_.get("name")
317         if "append_domain" in vm_:
318             key_id = ".".join([key_id, vm_["append_domain"]])
319         accept_key(opts["pki_dir"], vm_["pub_key"], key_id)
320     if "os" not in vm_:
321         vm_["os"] = salt.config.get_cloud_config_value("script", vm_, opts)
322     host = salt.config.get_cloud_config_value("ssh_host", vm_, opts)
323     deploy_kwargs = {
324         "opts": opts,
325         "host": host,
326         "port": salt.config.get_cloud_config_value("ssh_port", vm_, opts, default=22),
327         "salt_host": vm_.get("salt_host", host),
328         "username": ssh_username,
329         "script": deploy_script_code,
330         "inline_script": inline_script_config,
331         "name": vm_["name"],
332         "has_ssh_agent": has_ssh_agent,
333         "tmp_dir": salt.config.get_cloud_config_value(
334             "tmp_dir", vm_, opts, default="/tmp/.saltcloud"
335         ),
336         "vm_": vm_,
337         "start_action": opts["start_action"],
338         "parallel": opts["parallel"],
339         "sock_dir": opts["sock_dir"],
340         "conf_file": opts["conf_file"],
341         "minion_pem": vm_["priv_key"],
342         "minion_pub": vm_["pub_key"],
343         "master_sign_pub_file": salt.config.get_cloud_config_value(
344             "master_sign_pub_file", vm_, opts, default=None
345         ),
346         "keep_tmp": opts["keep_tmp"],
347         "sudo": salt.config.get_cloud_config_value(
348             "sudo", vm_, opts, default=(ssh_username != "root")
349         ),
350         "sudo_password": salt.config.get_cloud_config_value(
351             "sudo_password", vm_, opts, default=None
352         ),
353         "tty": salt.config.get_cloud_config_value("tty", vm_, opts, default=True),
354         "password": salt.config.get_cloud_config_value(
355             "password", vm_, opts, search_global=False
356         ),
357         "key_filename": key_filename,
358         "script_args": salt.config.get_cloud_config_value("script_args", vm_, opts),
359         "script_env": salt.config.get_cloud_config_value("script_env", vm_, opts),
360         "minion_conf": minion_conf,
361         "force_minion_config": salt.config.get_cloud_config_value(
362             "force_minion_config", vm_, opts, default=False
363         ),
364         "preseed_minion_keys": vm_.get("preseed_minion_keys", None),
365         "display_ssh_output": salt.config.get_cloud_config_value(
366             "display_ssh_output", vm_, opts, default=True
367         ),
368         "known_hosts_file": salt.config.get_cloud_config_value(
369             "known_hosts_file", vm_, opts, default="/dev/null"
370         ),
371         "file_map": salt.config.get_cloud_config_value(
372             "file_map", vm_, opts, default=None
373         ),
374         "maxtries": salt.config.get_cloud_config_value(
375             "wait_for_passwd_maxtries", vm_, opts, default=15
376         ),
377         "preflight_cmds": salt.config.get_cloud_config_value(
378             "preflight_cmds", vm_, opts, default=[]
379         ),
380         "cloud_grains": {
381             "driver": vm_["driver"],
382             "provider": vm_["provider"],
383             "profile": vm_["profile"],
384         },
385     }
386     inline_script_kwargs = deploy_kwargs.copy()  # make a copy at this point
387     if "gateway" in vm_:
388         deploy_kwargs.update({"gateway": vm_["gateway"]})
389     if salt.config.get_cloud_config_value("make_master", vm_, opts) is True:
390         deploy_kwargs["make_master"] = True
391         deploy_kwargs["master_pub"] = vm_["master_pub"]
392         deploy_kwargs["master_pem"] = vm_["master_pem"]
393         master_conf = master_config(opts, vm_)
394         deploy_kwargs["master_conf"] = master_conf
395         if master_conf.get("syndic_master", None):
396             deploy_kwargs["make_syndic"] = True
397     deploy_kwargs["make_minion"] = salt.config.get_cloud_config_value(
398         "make_minion", vm_, opts, default=True
399     )
400     if saltify_driver:
401         deploy_kwargs[
402             "wait_for_passwd_maxtries"
403         ] = 0  # No need to wait/retry with Saltify
404     win_installer = salt.config.get_cloud_config_value("win_installer", vm_, opts)
405     if win_installer:
406         deploy_kwargs["port"] = salt.config.get_cloud_config_value(
407             "smb_port", vm_, opts, default=445
408         )
409         deploy_kwargs["win_installer"] = win_installer
410         minion = minion_config(opts, vm_)
411         deploy_kwargs["master"] = minion["master"]
412         deploy_kwargs["username"] = salt.config.get_cloud_config_value(
413             "win_username", vm_, opts, default="Administrator"
414         )
415         win_pass = salt.config.get_cloud_config_value(
416             "win_password", vm_, opts, default=""
417         )
418         if win_pass:
419             deploy_kwargs["password"] = win_pass
420         deploy_kwargs["use_winrm"] = salt.config.get_cloud_config_value(
421             "use_winrm", vm_, opts, default=False
422         )
423         deploy_kwargs["winrm_port"] = salt.config.get_cloud_config_value(
424             "winrm_port", vm_, opts, default=5986
425         )
426         deploy_kwargs["winrm_use_ssl"] = salt.config.get_cloud_config_value(
427             "winrm_use_ssl", vm_, opts, default=True
428         )
429         deploy_kwargs["winrm_verify_ssl"] = salt.config.get_cloud_config_value(
430             "winrm_verify_ssl", vm_, opts, default=True
431         )
432         if saltify_driver:
433             deploy_kwargs["port_timeout"] = 1  # No need to wait/retry with Saltify
434     event_kwargs = copy.deepcopy(deploy_kwargs)
435     del event_kwargs["opts"]
436     del event_kwargs["minion_pem"]
437     del event_kwargs["minion_pub"]
438     del event_kwargs["sudo_password"]
439     if "password" in event_kwargs:
440         del event_kwargs["password"]
441     ret["deploy_kwargs"] = event_kwargs
442     fire_event(
443         "event",
444         "executing deploy script",
445         "salt/cloud/{}/deploying".format(vm_["name"]),
446         args={"kwargs": salt.utils.data.simple_types_filter(event_kwargs)},
447         sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
448         transport=opts.get("transport", "zeromq"),
449     )
450     if inline_script_config and deploy_config is False:
451         inline_script_deployed = run_inline_script(**inline_script_kwargs)
452         if inline_script_deployed is not False:
453             log.info("Inline script(s) ha(s|ve) run on %s", vm_["name"])
454         ret["deployed"] = False
455         return ret
456     else:
457         if win_installer:
458             deployed = deploy_windows(**deploy_kwargs)
459         else:
460             deployed = deploy_script(**deploy_kwargs)
461         if inline_script_config:
462             inline_script_deployed = run_inline_script(**inline_script_kwargs)
463             if inline_script_deployed is not False:
464                 log.info("Inline script(s) ha(s|ve) run on %s", vm_["name"])
465         if deployed is not False:
466             ret["deployed"] = True
467             if deployed is not True:
468                 ret.update(deployed)
469             log.info("Salt installed on %s", vm_["name"])
470             return ret
471     log.error("Failed to start Salt on host %s", vm_["name"])
472     return {
473         "Error": {"Not Deployed": "Failed to start Salt on host {}".format(vm_["name"])}
474     }
475 def ssh_usernames(vm_, opts, default_users=None):
476     if default_users is None:
477         default_users = ["root"]
478     usernames = salt.config.get_cloud_config_value("ssh_username", vm_, opts)
479     if not isinstance(usernames, list):
480         usernames = [usernames]
481     usernames = [x for x in usernames if x]
482     initial = usernames[:]
483     for name in default_users:
484         if name not in usernames:
485             usernames.append(name)
486     usernames.extend(initial)
487     return usernames
488 def wait_for_fun(fun, timeout=900, **kwargs):
489     start = time.time()
490     log.debug("Attempting function %s", fun)
491     trycount = 0
492     while True:
493         trycount += 1
494         try:
495             response = fun(**kwargs)
496             if not isinstance(response, bool):
497                 return response
498         except Exception as exc:  # pylint: disable=broad-except
499             log.debug("Caught exception in wait_for_fun: %s", exc)
500             time.sleep(1)
501             log.debug("Retrying function %s on  (try %s)", fun, trycount)
502         if time.time() - start &gt; timeout:
503             log.error("Function timed out: %s", timeout)
504             return False
505 def wait_for_port(
506     host,
507     port=22,
508     timeout=900,
509     gateway=None,
510     server_alive_interval=SERVER_ALIVE_INTERVAL,
511     server_alive_count_max=SERVER_ALIVE_COUNT_MAX,
512 ):
513     start = time.time()
514     test_ssh_host = host
515     test_ssh_port = port
516     if gateway:
517         ssh_gateway = gateway["ssh_gateway"]
518         ssh_gateway_port = 22
519         if ":" in ssh_gateway:
520             ssh_gateway, ssh_gateway_port = ssh_gateway.split(":")
521         if "ssh_gateway_port" in gateway:
522             ssh_gateway_port = gateway["ssh_gateway_port"]
523         test_ssh_host = ssh_gateway
524         test_ssh_port = ssh_gateway_port
525         log.debug(
526             "Attempting connection to host %s on port %s via gateway %s on port %s",
527             host,
528             port,
529             ssh_gateway,
530             ssh_gateway_port,
531         )
532     else:
533         log.debug("Attempting connection to host %s on port %s", host, port)
534     trycount = 0
535     while True:
536         trycount += 1
537         try:
538             if socket.inet_pton(socket.AF_INET6, host):
539                 sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
540             else:
541                 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
542         except OSError:
543             sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
544         try:
545             sock.settimeout(5)
546             sock.connect((test_ssh_host, int(test_ssh_port)))
547             sock.shutdown(socket.SHUT_RDWR)
548             sock.close()
549             break
550         except OSError as exc:
551             log.debug("Caught exception in wait_for_port: %s", exc)
552             time.sleep(1)
553             if time.time() - start &gt; timeout:
554                 log.error("Port connection timed out: %s", timeout)
555                 return False
556             log.debug(
557                 "Retrying connection to %s %s on port %s (try %s)",
558                 "gateway" if gateway else "host",
559                 test_ssh_host,
560                 test_ssh_port,
561                 trycount,
562             )
563     if not gateway:
564         return True
565     log.debug("Gateway %s on port %s is reachable.", test_ssh_host, test_ssh_port)
566     ssh_args = []
567     ssh_args.extend(
568         [
569             "-oStrictHostKeyChecking=no",
570             "-oServerAliveInterval={}".format(server_alive_interval),
571             "-oServerAliveCountMax={}".format(server_alive_count_max),
572             "-oUserKnownHostsFile=/dev/null",
573             "-oControlPath=none",
574         ]
575     )
576     if "ssh_gateway_key" in gateway:
577         ssh_args.extend(
578             [
579                 "-oPasswordAuthentication=no",
580                 "-oChallengeResponseAuthentication=no",
581                 "-oPubkeyAuthentication=yes",
582                 "-oIdentitiesOnly=yes",
583                 "-oKbdInteractiveAuthentication=no",
584                 "-i {}".format(gateway["ssh_gateway_key"]),
585             ]
586         )
587     command = "nc -z -w5 -q0 {} {}".format(host, port)
588     pcmd = "ssh {} {}@{} -p {} {}".format(
589         " ".join(ssh_args),
590         gateway["ssh_gateway_user"],
591         ssh_gateway,
592         ssh_gateway_port,
593         pipes.quote("date"),
594     )
595     cmd = "ssh {} {}@{} -p {} {}".format(
596         " ".join(ssh_args),
597         gateway["ssh_gateway_user"],
598         ssh_gateway,
599         ssh_gateway_port,
600         pipes.quote(command),
601     )
602     log.debug("SSH command: '%s'", cmd)
603     kwargs = {
604         "display_ssh_output": False,
605         "password": gateway.get("ssh_gateway_password", None),
606     }
607     trycount = 0
608     usable_gateway = False
609     gateway_retries = 5
610     while True:
611         trycount += 1
612         if not usable_gateway:
613             pstatus = _exec_ssh_cmd(pcmd, allow_failure=True, **kwargs)
614             if pstatus == 0:
615                 usable_gateway = True
616             else:
617                 gateway_retries -= 1
618                 log.error(
619                     "Gateway usage seems to be broken, password error ? Tries left: %s",
620                     gateway_retries,
621                 )
622             if not gateway_retries:
623                 raise SaltCloudExecutionFailure(
624                     "SSH gateway is reachable but we can not login"
625                 )
626         if usable_gateway:
627             status = _exec_ssh_cmd(cmd, allow_failure=True, **kwargs)
628             if status == 0:
629                 return True
630         time.sleep(1)
631         if time.time() - start &gt; timeout:
632             log.error("Port connection timed out: %s", timeout)
633             return False
634         log.debug(
635             "Retrying connection to host %s on port %s "
636             "via gateway %s on port %s. (try %s)",
637             host,
638             port,
639             ssh_gateway,
640             ssh_gateway_port,
641             trycount,
642         )
643 class Client:
644     def __init__(
645         self,
646         server,
647         username=None,
648         password=None,
649         port=445,
650         encrypt=True,
651         service_name=None,
652     ):
653         self.service_name = service_name
654         self._exe_file = "{}.exe".format(self.service_name)
655         self._client = PsExecClient(server, username, password, port, encrypt)
656         self._client._service = ScmrService(self.service_name, self._client.session)
657     def connect(self):
658         return self._client.connect()
659     def disconnect(self):
660         return self._client.disconnect()
661     def create_service(self):
662         return self._client.create_service()
663     def run_executable(self, *args, **kwargs):
664         return self._client.run_executable(*args, **kwargs)
665     def remove_service(self, wait_timeout=10, sleep_wait=1):
666         log.debug("Deleting PAExec service at the end of the process")
667         wait_start = time.time()
668         while True:
669             try:
670                 self._client._service.delete()
671             except SCMRException as exc:
672                 log.debug("Exception encountered while deleting service %s", repr(exc))
673                 if time.time() - wait_start &gt; wait_timeout:
674                     raise exc
675                 time.sleep(sleep_wait)
676                 continue
677             break
678         smb_tree = TreeConnect(
679             self._client.session,
680             r"\\{}\ADMIN$".format(self._client.connection.server_name),
681         )
682         log.info("Connecting to SMB Tree %s", smb_tree.share_name)
683         smb_tree.connect()
684         wait_start = time.time()
685         while True:
686             try:
687                 log.info("Creating open to PAExec file with delete on close flags")
688                 self._client._delete_file(smb_tree, self._exe_file)
689             except SMBResponseException as exc:
690                 log.debug("Exception deleting file %s %s", self._exe_file, repr(exc))
691                 if time.time() - wait_start &gt; wait_timeout:
692                     raise exc
693                 time.sleep(sleep_wait)
694                 continue
695             break
696         log.info("Disconnecting from SMB Tree %s", smb_tree.share_name)
697         smb_tree.disconnect()
698 def run_winexe_command(cmd, args, host, username, password, port=445):
699     creds = "-U '{}%{}' //{}".format(username, password, host)
700     logging_creds = "-U '{}%XXX-REDACTED-XXX' //{}".format(username, host)
701     cmd = "winexe {} {} {}".format(creds, cmd, args)
702     logging_cmd = "winexe {} {} {}".format(logging_creds, cmd, args)
703     return win_cmd(cmd, logging_command=logging_cmd)
704 def run_psexec_command(cmd, args, host, username, password, port=445):
705     service_name = "PS-Exec-{}".format(uuid.uuid4())
706     stdout, stderr, ret_code = "", "", None
707     client = Client(
708         host, username, password, port=port, encrypt=False, service_name=service_name
709     )
710     client.connect()
711     try:
712         client.create_service()
713         stdout, stderr, ret_code = client.run_executable(cmd, args)
714     finally:
715         client.remove_service()
716         client.disconnect()
717     return stdout, stderr, ret_code
718 def wait_for_winexe(host, port, username, password, timeout=900):
719     start = time.time()
720     log.debug("Attempting winexe connection to host %s on port %s", host, port)
721     try_count = 0
722     while True:
723         try_count += 1
724         try:
725             ret_code = run_winexe_command(
726                 "sc", "query winexesvc", host, username, password, port
727             )
728             if ret_code == 0:
729                 log.debug("winexe connected...")
730                 return True
731             log.debug("Return code was %s", ret_code)
732         except OSError as exc:
733             log.debug("Caught exception in wait_for_winexesvc: %s", exc)
734         if time.time() - start &gt; timeout:
735             return False
736         time.sleep(1)
737 def wait_for_psexecsvc(host, port, username, password, timeout=900):
738     start = time.time()
739     try_count = 0
740     while True:
741         try_count += 1
742         ret_code = 1
743         try:
744             stdout, stderr, ret_code = run_psexec_command(
745                 "cmd.exe", "/c hostname", host, username, password, port=port
746             )
747         except Exception as exc:  # pylint: disable=broad-except
748             log.exception("Unable to execute command")
749         if ret_code == 0:
750             log.debug("psexec connected...")
751             return True
752         if time.time() - start &gt; timeout:
753             return False
754         log.debug(
755             "Retrying psexec connection to host %s on port %s (try %s)",
756             host,
757             port,
758             try_count,
759         )
760         time.sleep(1)
761 def wait_for_winrm(
762     host, port, username, password, timeout=900, use_ssl=True, verify=True
763 ):
764     wait_for_port(host=host, port=port, timeout=timeout)
765     start = time.time()
766     log.debug("Attempting WinRM connection to host %s on port %s", host, port)
767     transport = "ssl"
768     if not use_ssl:
769         transport = "ntlm"
770     trycount = 0
771     while True:
772         trycount += 1
773         try:
774             winrm_kwargs = {
775                 "target": host,
776                 "auth": (username, password),
777                 "transport": transport,
778             }
779             if not verify:
780                 log.debug("SSL validation for WinRM disabled.")
781                 winrm_kwargs["server_cert_validation"] = "ignore"
782             s = winrm.Session(**winrm_kwargs)
783             if hasattr(s.protocol, "set_timeout"):
784                 s.protocol.set_timeout(15)
785             log.trace("WinRM endpoint url: %s", s.url)
786             r = s.run_cmd("sc query winrm")
787             if r.status_code == 0:
788                 log.debug("WinRM session connected...")
789                 return s
790             log.debug("Return code was %s", r.status_code)
791         except WinRMTransportError as exc:
792             log.debug("Caught exception in wait_for_winrm: %s", exc)
793         if time.time() - start &gt; timeout:
794             log.error("WinRM connection timed out: %s", timeout)
795             return None
796         log.debug(
797             "Retrying WinRM connection to host %s on port %s (try %s)",
798             host,
799             port,
800             trycount,
801         )
802         time.sleep(1)
803 def validate_windows_cred_winexe(
804     host, username="Administrator", password=None, retries=10, retry_delay=1
805 ):
806     cmd = "winexe -U '{}%{}' //{} \"hostname\"".format(username, password, host)
807     logging_cmd = "winexe -U '{}%XXX-REDACTED-XXX' //{} \"hostname\"".format(
808         username, host
809     )
810     for i in range(retries):
811         ret_code = win_cmd(cmd, logging_command=logging_cmd)
812     return ret_code == 0
813 def validate_windows_cred(
814     host, username="Administrator", password=None, retries=10, retry_delay=1
815 ):
816     for i in range(retries):
817         ret_code = 1
818         try:
819             stdout, stderr, ret_code = run_psexec_command(
820                 "cmd.exe", "/c hostname", host, username, password, port=445
821             )
822         except Exception as exc:  # pylint: disable=broad-except
823             log.exception("Exceoption while executing psexec")
824         if ret_code == 0:
825             break
826         time.sleep(retry_delay)
827     return ret_code == 0
828 def wait_for_passwd(
829     host,
830     port=22,
831     ssh_timeout=15,
832     username="root",
833     password=None,
834     key_filename=None,
835     maxtries=15,
836     trysleep=1,
837     display_ssh_output=True,
838     gateway=None,
839     known_hosts_file="/dev/null",
840     hard_timeout=None,
841 ):
842     trycount = 0
843     while trycount &lt; maxtries:
844         connectfail = False
845         try:
846             kwargs = {
847                 "hostname": host,
848                 "port": port,
849                 "username": username,
850                 "password_retries": maxtries,
851                 "timeout": ssh_timeout,
852                 "display_ssh_output": display_ssh_output,
853                 "known_hosts_file": known_hosts_file,
854                 "ssh_timeout": ssh_timeout,
855                 "hard_timeout": hard_timeout,
856             }
857             kwargs.update(__ssh_gateway_config_dict(gateway))
858             if key_filename:
859                 if not os.path.isfile(key_filename):
860                     raise SaltCloudConfigError(
861                         "The defined key_filename '{}' does not exist".format(
862                             key_filename
863                         )
864                     )
865                 kwargs["key_filename"] = key_filename
866                 log.debug("Using %s as the key_filename", key_filename)
867             elif password:
868                 kwargs["password"] = password
869                 log.debug("Using password authentication")
870             trycount += 1
871             log.debug(
872                 "Attempting to authenticate as %s (try %s of %s)",
873                 username,
874                 trycount,
875                 maxtries,
876             )
877             status = root_cmd("date", tty=False, sudo=False, **kwargs)
878             if status != 0:
879                 connectfail = True
880                 if trycount &lt; maxtries:
881                     time.sleep(trysleep)
882                     continue
883                 log.error("Authentication failed: status code %s", status)
884                 return False
885             if connectfail is False:
886                 return True
887             return False
888         except SaltCloudPasswordError:
889             raise
890         except Exception:  # pylint: disable=broad-except
891             if trycount &gt;= maxtries:
892                 return False
893             time.sleep(trysleep)
894 def deploy_windows(
895     host,
896     port=445,
897     timeout=900,
898     username="Administrator",
899     password=None,
900     name=None,
901     sock_dir=None,
902     conf_file=None,
903     start_action=None,
904     parallel=False,
905     minion_pub=None,
906     minion_pem=None,
907     minion_conf=None,
908     keep_tmp=False,
909     script_args=None,
910     script_env=None,
911     port_timeout=15,
912     preseed_minion_keys=None,
913     win_installer=None,
914     master=None,
915     tmp_dir="C:\\salttmp",
916     opts=None,
917     master_sign_pub_file=None,
918     use_winrm=False,
919     winrm_port=5986,
920     winrm_use_ssl=True,
921     winrm_verify_ssl=True,
922     **kwargs
923 ):
924     if not isinstance(opts, dict):
925         opts = {}
926     if use_winrm and not HAS_WINRM:
927         log.error(
928             "WinRM requested but module winrm could not be imported. "
929             "Ensure you are using version %s or higher.",
930             WINRM_MIN_VER,
931         )
932         return False
933     starttime = time.mktime(time.localtime())
934     log.debug("Deploying %s at %s (Windows)", host, starttime)
935     log.trace("HAS_WINRM: %s, use_winrm: %s", HAS_WINRM, use_winrm)
936     port_available = wait_for_port(host=host, port=port, timeout=port_timeout * 60)
937     if not port_available:
938         return False
939     service_available = False
940     winrm_session = None
941     if HAS_WINRM and use_winrm:
942         winrm_session = wait_for_winrm(
943             host=host,
944             port=winrm_port,
945             username=username,
946             password=password,
947             timeout=port_timeout * 60,
948             use_ssl=winrm_use_ssl,
949             verify=winrm_verify_ssl,
950         )
951         if winrm_session is not None:
952             service_available = True
953     else:
954         service_available = wait_for_psexecsvc(
955             host=host,
956             port=port,
957             username=username,
958             password=password,
959             timeout=port_timeout * 60,
960         )
961     if port_available and service_available:
962         log.debug("SMB port %s on %s is available", port, host)
963         log.debug("Logging into %s:%s as %s", host, port, username)
964         smb_conn = salt.utils.smb.get_conn(host, username, password, port)
965         if smb_conn is False:
966             log.error("Please install smbprotocol to enable SMB functionality")
967             return False
968         salt.utils.smb.mkdirs("salttemp", conn=smb_conn)
969         salt.utils.smb.mkdirs("salt/conf/pki/minion", conn=smb_conn)
970         if minion_pub:
971             salt.utils.smb.put_str(
972                 minion_pub, "salt\\conf\\pki\\minion\\minion.pub", conn=smb_conn
973             )
974         if minion_pem:
975             salt.utils.smb.put_str(
976                 minion_pem, "salt\\conf\\pki\\minion\\minion.pem", conn=smb_conn
977             )
978         if master_sign_pub_file:
979             log.debug(
980                 "Copying master_sign.pub file from %s to minion", master_sign_pub_file
981             )
982             try:
983                 salt.utils.smb.put_file(
984                     master_sign_pub_file,
985                     "salt\\conf\\pki\\minion\\master_sign.pub",
986                     "C$",
987                     conn=smb_conn,
988                 )
989             except Exception as e:  # pylint: disable=broad-except
990                 log.debug(
991                     "Exception copying master_sign.pub file %s to minion",
992                     master_sign_pub_file,
993                 )
994         comps = win_installer.split("/")
995         local_path = "/".join(comps[:-1])
996         installer = comps[-1]
997         salt.utils.smb.put_file(
998             win_installer,
999             "salttemp\\{}".format(installer),
1000             "C$",
1001             conn=smb_conn,
1002         )
1003         if use_winrm:
1004             winrm_cmd(
1005                 winrm_session,
1006                 "c:\\salttemp\\{}".format(installer),
1007                 ["/S", "/master={}".format(master), "/minion-name={}".format(name)],
1008             )
1009         else:
1010             cmd = "c:\\salttemp\\{}".format(installer)
1011             args = "/S /master={} /minion-name={}".format(master, name)
1012             stdout, stderr, ret_code = run_psexec_command(
1013                 cmd, args, host, username, password
1014             )
1015             if ret_code != 0:
1016                 raise Exception("Fail installer {}".format(ret_code))
1017         if minion_conf:
1018             if not isinstance(minion_conf, dict):
1019                 raise DeprecationWarning(
1020                     "`salt.utils.cloud.deploy_windows` now only accepts "
1021                     "dictionaries for its `minion_conf` parameter. "
1022                     "Loading YAML..."
1023                 )
1024             minion_grains = minion_conf.pop("grains", {})
1025             if minion_grains:
1026                 salt.utils.smb.put_str(
1027                     salt_config_to_yaml(minion_grains, line_break="\r\n"),
1028                     "salt\\conf\\grains",
1029                     conn=smb_conn,
1030                 )
1031             windows_minion_conf = {
1032                 "ipc_mode": "tcp",
1033                 "root_dir": "c:\\salt",
1034                 "pki_dir": "/conf/pki/minion",
1035                 "multiprocessing": False,
1036             }
1037             minion_conf = dict(minion_conf, **windows_minion_conf)
1038             salt.utils.smb.put_str(
1039                 salt_config_to_yaml(minion_conf, line_break="\r\n"),
1040                 "salt\\conf\\minion",
1041                 conn=smb_conn,
1042             )
1043         if not keep_tmp:
1044             if use_winrm:
1045                 winrm_cmd(winrm_session, "rmdir", ["/Q", "/S", "C:\\salttemp\\"])
1046             else:
1047                 salt.utils.smb.delete_file(
1048                     "salttemp\\{}".format(installer), "C$", conn=smb_conn
1049                 )
1050                 salt.utils.smb.delete_directory("salttemp", "C$", conn=smb_conn)
1051         if use_winrm:
1052             winrm_cmd(winrm_session, "net", ["stop", "salt-minion"])
1053             winrm_cmd(winrm_session, "net", ["start", "salt-minion"])
1054         else:
1055             stdout, stderr, ret_code = run_psexec_command(
1056                 "cmd.exe", "/c net stop salt-minion", host, username, password
1057             )
1058             if ret_code != 0:
1059                 return False
1060             log.debug("Run psexec: sc start salt-minion")
1061             stdout, stderr, ret_code = run_psexec_command(
1062                 "cmd.exe", "/c net start salt-minion", host, username, password
1063             )
1064             if ret_code != 0:
1065                 return False
1066         fire_event(
1067             "event",
1068             "{} has been deployed at {}".format(name, host),
1069             "salt/cloud/{}/deploy_windows".format(name),
1070             args={"name": name},
1071             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
1072             transport=opts.get("transport", "zeromq"),
1073         )
1074         return True
1075     return False
1076 def deploy_script(
1077     host,
1078     port=22,
1079     timeout=900,
1080     username="root",
1081     password=None,
1082     key_filename=None,
1083     script=None,
1084     name=None,
1085     sock_dir=None,
1086     provider=None,
1087     conf_file=None,
1088     start_action=None,
1089     make_master=False,
1090     master_pub=None,
1091     master_pem=None,
1092     master_conf=None,
1093     minion_pub=None,
1094     minion_pem=None,
1095     minion_conf=None,
1096     keep_tmp=False,
1097     script_args=None,
1098     script_env=None,
1099     ssh_timeout=15,
1100     maxtries=15,
1101     make_syndic=False,
1102     make_minion=True,
1103     display_ssh_output=True,
1104     preseed_minion_keys=None,
1105     parallel=False,
1106     sudo_password=None,
1107     sudo=False,
1108     tty=None,
1109     vm_=None,
1110     opts=None,
1111     tmp_dir="/tmp/.saltcloud",
1112     file_map=None,
1113     master_sign_pub_file=None,
1114     cloud_grains=None,
1115     force_minion_config=False,
1116     **kwargs
1117 ):
1118     if not isinstance(opts, dict):
1119         opts = {}
1120     vm_ = vm_ or {}  # if None, default to empty dict
1121     cloud_grains = cloud_grains or {}
1122     tmp_dir = "{}-{}".format(tmp_dir.rstrip("/"), uuid.uuid4())
1123     deploy_command = salt.config.get_cloud_config_value(
1124         "deploy_command", vm_, opts, default=os.path.join(tmp_dir, "deploy.sh")
1125     )
1126     if key_filename is not None and not os.path.isfile(key_filename):
1127         raise SaltCloudConfigError(
1128             "The defined key_filename '{}' does not exist".format(key_filename)
1129         )
1130     gateway = None
1131     if "gateway" in kwargs:
1132         gateway = kwargs["gateway"]
1133     starttime = time.localtime()
1134     log.debug("Deploying %s at %s", host, time.strftime("%Y-%m-%d %H:%M:%S", starttime))
1135     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1136     hard_timeout = opts.get("hard_timeout", None)
1137     if wait_for_port(host=host, port=port, gateway=gateway):
1138         log.debug("SSH port %s on %s is available", port, host)
1139         if wait_for_passwd(
1140             host,
1141             port=port,
1142             username=username,
1143             password=password,
1144             key_filename=key_filename,
1145             ssh_timeout=ssh_timeout,
1146             display_ssh_output=display_ssh_output,
1147             gateway=gateway,
1148             known_hosts_file=known_hosts_file,
1149             maxtries=maxtries,
1150             hard_timeout=hard_timeout,
1151         ):
1152             log.debug("Logging into %s:%s as %s", host, port, username)
1153             ssh_kwargs = {
1154                 "hostname": host,
1155                 "port": port,
1156                 "username": username,
1157                 "timeout": ssh_timeout,
1158                 "ssh_timeout": ssh_timeout,
1159                 "display_ssh_output": display_ssh_output,
1160                 "sudo_password": sudo_password,
1161                 "sftp": opts.get("use_sftp", False),
1162             }
1163             ssh_kwargs.update(__ssh_gateway_config_dict(gateway))
1164             if key_filename:
1165                 log.debug("Using %s as the key_filename", key_filename)
1166                 ssh_kwargs["key_filename"] = key_filename
1167             elif password and kwargs.get("has_ssh_agent", False) is False:
1168                 ssh_kwargs["password"] = password
1169             if root_cmd(
1170                 "test -e '{}'".format(tmp_dir),
1171                 tty,
1172                 sudo,
1173                 allow_failure=True,
1174                 **ssh_kwargs
1175             ):
1176                 ret = root_cmd(
1177                     "sh -c \"( mkdir -p -m 700 '{}' )\"".format(tmp_dir),
1178                     tty,
1179                     sudo,
1180                     **ssh_kwargs
1181                 )
1182                 if ret:
1183                     raise SaltCloudSystemExit(
1184                         "Can't create temporary directory in {} !".format(tmp_dir)
1185                     )
1186             if sudo:
1187                 comps = tmp_dir.lstrip("/").rstrip("/").split("/")
1188                 if comps:
1189                     if len(comps) &gt; 1 or comps[0] != "tmp":
1190                         ret = root_cmd(
1191                             'chown {} "{}"'.format(username, tmp_dir),
1192                             tty,
1193                             sudo,
1194                             **ssh_kwargs
1195                         )
1196                         if ret:
1197                             raise SaltCloudSystemExit(
1198                                 "Cant set {} ownership on {}".format(username, tmp_dir)
1199                             )
1200             if not isinstance(file_map, dict):
1201                 file_map = {}
1202             remote_dirs = []
1203             file_map_success = []
1204             file_map_fail = []
1205             for map_item in file_map:
1206                 local_file = map_item
1207                 remote_file = file_map[map_item]
1208                 if not os.path.exists(map_item):
1209                     log.error(
1210                         'The local file "%s" does not exist, and will not be '
1211                         'copied to "%s" on the target system',
1212                         local_file,
1213                         remote_file,
1214                     )
1215                     file_map_fail.append({local_file: remote_file})
1216                     continue
1217                 if os.path.isdir(local_file):
1218                     dir_name = os.path.basename(local_file)
1219                     remote_dir = os.path.join(os.path.dirname(remote_file), dir_name)
1220                 else:
1221                     remote_dir = os.path.dirname(remote_file)
1222                 if remote_dir not in remote_dirs:
1223                     root_cmd(
1224                         "mkdir -p '{}'".format(remote_dir), tty, sudo, **ssh_kwargs
1225                     )
1226                     if ssh_kwargs["username"] != "root":
1227                         root_cmd(
1228                             "chown {} '{}'".format(ssh_kwargs["username"], remote_dir),
1229                             tty,
1230                             sudo,
1231                             **ssh_kwargs
1232                         )
1233                     remote_dirs.append(remote_dir)
1234                 ssh_file(opts, remote_file, kwargs=ssh_kwargs, local_file=local_file)
1235                 file_map_success.append({local_file: remote_file})
1236             if minion_pem:
1237                 ssh_file(opts, "{}/minion.pem".format(tmp_dir), minion_pem, ssh_kwargs)
1238                 ret = root_cmd(
1239                     "chmod 600 '{}/minion.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1240                 )
1241                 if ret:
1242                     raise SaltCloudSystemExit(
1243                         "Can't set perms on {}/minion.pem".format(tmp_dir)
1244                     )
1245             if minion_pub:
1246                 ssh_file(opts, "{}/minion.pub".format(tmp_dir), minion_pub, ssh_kwargs)
1247             if master_sign_pub_file:
1248                 ssh_file(
1249                     opts,
1250                     "{}/master_sign.pub".format(tmp_dir),
1251                     kwargs=ssh_kwargs,
1252                     local_file=master_sign_pub_file,
1253                 )
1254             if minion_conf:
1255                 if not isinstance(minion_conf, dict):
1256                     raise DeprecationWarning(
1257                         "`salt.utils.cloud.deploy_script now only accepts "
1258                         "dictionaries for it's `minion_conf` parameter. "
1259                         "Loading YAML..."
1260                     )
1261                 minion_grains = minion_conf.pop("grains", {})
1262                 if minion_grains:
1263                     ssh_file(
1264                         opts,
1265                         "{}/grains".format(tmp_dir),
1266                         salt_config_to_yaml(minion_grains),
1267                         ssh_kwargs,
1268                     )
1269                 if cloud_grains and opts.get("enable_cloud_grains", True):
1270                     minion_conf["grains"] = {"salt-cloud": cloud_grains}
1271                 ssh_file(
1272                     opts,
1273                     "{}/minion".format(tmp_dir),
1274                     salt_config_to_yaml(minion_conf),
1275                     ssh_kwargs,
1276                 )
1277             if master_pem:
1278                 ssh_file(opts, "{}/master.pem".format(tmp_dir), master_pem, ssh_kwargs)
1279                 ret = root_cmd(
1280                     "chmod 600 '{}/master.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1281                 )
1282                 if ret:
1283                     raise SaltCloudSystemExit(
1284                         "Cant set perms on {}/master.pem".format(tmp_dir)
1285                     )
1286             if master_pub:
1287                 ssh_file(opts, "{}/master.pub".format(tmp_dir), master_pub, ssh_kwargs)
1288             if master_conf:
1289                 if not isinstance(master_conf, dict):
1290                     raise DeprecationWarning(
1291                         "`salt.utils.cloud.deploy_script now only accepts "
1292                         "dictionaries for it's `master_conf` parameter. "
1293                         "Loading from YAML ..."
1294                     )
1295                 ssh_file(
1296                     opts,
1297                     "{}/master".format(tmp_dir),
1298                     salt_config_to_yaml(master_conf),
1299                     ssh_kwargs,
1300                 )
1301             preseed_minion_keys_tempdir = "{}/preseed-minion-keys".format(tmp_dir)
1302             if preseed_minion_keys is not None:
1303                 ret = root_cmd(
1304                     "mkdir '{}'".format(preseed_minion_keys_tempdir),
1305                     tty,
1306                     sudo,
1307                     **ssh_kwargs
1308                 )
1309                 if ret:
1310                     raise SaltCloudSystemExit(
1311                         "Cant create {}".format(preseed_minion_keys_tempdir)
1312                     )
1313                 ret = root_cmd(
1314                     "chmod 700 '{}'".format(preseed_minion_keys_tempdir),
1315                     tty,
1316                     sudo,
1317                     **ssh_kwargs
1318                 )
1319                 if ret:
1320                     raise SaltCloudSystemExit(
1321                         "Can't set perms on {}".format(preseed_minion_keys_tempdir)
1322                     )
1323                 if ssh_kwargs["username"] != "root":
1324                     root_cmd(
1325                         "chown {} '{}'".format(
1326                             ssh_kwargs["username"], preseed_minion_keys_tempdir
1327                         ),
1328                         tty,
1329                         sudo,
1330                         **ssh_kwargs
1331                     )
1332                 for minion_id, minion_key in preseed_minion_keys.items():
1333                     rpath = os.path.join(preseed_minion_keys_tempdir, minion_id)
1334                     ssh_file(opts, rpath, minion_key, ssh_kwargs)
1335                 if ssh_kwargs["username"] != "root":
1336                     root_cmd(
1337                         "chown -R root '{}'".format(preseed_minion_keys_tempdir),
1338                         tty,
1339                         sudo,
1340                         **ssh_kwargs
1341                     )
1342                     if ret:
1343                         raise SaltCloudSystemExit(
1344                             "Can't set ownership for {}".format(
1345                                 preseed_minion_keys_tempdir
1346                             )
1347                         )
1348             preflight_cmds = kwargs.get("preflight_cmds", [])
1349             for command in preflight_cmds:
1350                 cmd_ret = root_cmd(command, tty, sudo, **ssh_kwargs)
1351                 if cmd_ret:
1352                     raise SaltCloudSystemExit(
1353                         "Pre-flight command failed: '{}'".format(command)
1354                     )
1355             if script:
1356                 ssh_file(opts, "{}/deploy.sh".format(tmp_dir), script, ssh_kwargs)
1357                 ret = root_cmd(
1358                     "sh -c \"( chmod +x '{}/deploy.sh' )\";exit $?".format(tmp_dir),
1359                     tty,
1360                     sudo,
1361                     **ssh_kwargs
1362                 )
1363                 if ret:
1364                     raise SaltCloudSystemExit(
1365                         "Can't set perms on {}/deploy.sh".format(tmp_dir)
1366                     )
1367             time_used = time.mktime(time.localtime()) - time.mktime(starttime)
1368             newtimeout = timeout - time_used
1369             queue = None
1370             process = None
1371             if start_action and not parallel:
1372                 queue = multiprocessing.Queue()
1373                 process = multiprocessing.Process(
1374                     target=check_auth,
1375                     kwargs=dict(
1376                         name=name, sock_dir=sock_dir, timeout=newtimeout, queue=queue
1377                     ),
1378                     name="DeployScriptCheckAuth({})".format(name),
1379                 )
1380                 log.debug("Starting new process to wait for salt-minion")
1381                 process.start()
1382             if script:
1383                 if "bootstrap-salt" in script:
1384                     deploy_command += " -c '{}'".format(tmp_dir)
1385                     if force_minion_config:
1386                         deploy_command += " -F"
1387                     if make_syndic is True:
1388                         deploy_command += " -S"
1389                     if make_master is True:
1390                         deploy_command += " -M"
1391                     if make_minion is False:
1392                         deploy_command += " -N"
1393                     if keep_tmp is True:
1394                         deploy_command += " -K"
1395                     if preseed_minion_keys is not None:
1396                         deploy_command += " -k '{}'".format(preseed_minion_keys_tempdir)
1397                 if script_args:
1398                     deploy_command += " {}".format(script_args)
1399                 if script_env:
1400                     if not isinstance(script_env, dict):
1401                         raise SaltCloudSystemExit(
1402                             "The 'script_env' configuration setting NEEDS "
1403                             "to be a dictionary not a {}".format(type(script_env))
1404                         )
1405                     environ_script_contents = ["#!/bin/sh"]
1406                     for key, value in script_env.items():
1407                         environ_script_contents.append(
1408                             "setenv {0} '{1}' &gt;/dev/null 2&gt;&amp;1 || "
1409                             "export {0}='{1}'".format(key, value)
1410                         )
1411                     environ_script_contents.append(deploy_command)
1412                     ssh_file(
1413                         opts,
1414                         "{}/environ-deploy-wrapper.sh".format(tmp_dir),
1415                         "\n".join(environ_script_contents),
1416                         ssh_kwargs,
1417                     )
1418                     root_cmd(
1419                         "chmod +x '{}/environ-deploy-wrapper.sh'".format(tmp_dir),
1420                         tty,
1421                         sudo,
1422                         **ssh_kwargs
1423                     )
1424                     deploy_command = "'{}/environ-deploy-wrapper.sh'".format(
1425                         tmp_dir,
1426                     )
1427                 if root_cmd(deploy_command, tty, sudo, **ssh_kwargs) != 0:
1428                     raise SaltCloudSystemExit(
1429                         "Executing the command '{}' failed".format(deploy_command)
1430                     )
1431                 log.debug("Executed command '%s'", deploy_command)
1432                 if not keep_tmp:
1433                     root_cmd(
1434                         "rm -f '{}/deploy.sh'".format(tmp_dir), tty, sudo, **ssh_kwargs
1435                     )
1436                     log.debug("Removed %s/deploy.sh", tmp_dir)
1437                     if script_env:
1438                         root_cmd(
1439                             "rm -f '{}/environ-deploy-wrapper.sh'".format(tmp_dir),
1440                             tty,
1441                             sudo,
1442                             **ssh_kwargs
1443                         )
1444                         log.debug("Removed %s/environ-deploy-wrapper.sh", tmp_dir)
1445             if keep_tmp:
1446                 log.debug("Not removing deployment files from %s/", tmp_dir)
1447             else:
1448                 if minion_pub:
1449                     root_cmd(
1450                         "rm -f '{}/minion.pub'".format(tmp_dir), tty, sudo, **ssh_kwargs
1451                     )
1452                     log.debug("Removed %s/minion.pub", tmp_dir)
1453                 if minion_pem:
1454                     root_cmd(
1455                         "rm -f '{}/minion.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1456                     )
1457                     log.debug("Removed %s/minion.pem", tmp_dir)
1458                 if minion_conf:
1459                     root_cmd(
1460                         "rm -f '{}/grains'".format(tmp_dir), tty, sudo, **ssh_kwargs
1461                     )
1462                     log.debug("Removed %s/grains", tmp_dir)
1463                     root_cmd(
1464                         "rm -f '{}/minion'".format(tmp_dir), tty, sudo, **ssh_kwargs
1465                     )
1466                     log.debug("Removed %s/minion", tmp_dir)
1467                 if master_sign_pub_file:
1468                     root_cmd(
1469                         "rm -f {}/master_sign.pub".format(tmp_dir),
1470                         tty,
1471                         sudo,
1472                         **ssh_kwargs
1473                     )
1474                     log.debug("Removed %s/master_sign.pub", tmp_dir)
1475                 if master_pub:
1476                     root_cmd(
1477                         "rm -f '{}/master.pub'".format(tmp_dir), tty, sudo, **ssh_kwargs
1478                     )
1479                     log.debug("Removed %s/master.pub", tmp_dir)
1480                 if master_pem:
1481                     root_cmd(
1482                         "rm -f '{}/master.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1483                     )
1484                     log.debug("Removed %s/master.pem", tmp_dir)
1485                 if master_conf:
1486                     root_cmd(
1487                         "rm -f '{}/master'".format(tmp_dir), tty, sudo, **ssh_kwargs
1488                     )
1489                     log.debug("Removed %s/master", tmp_dir)
1490                 if preseed_minion_keys is not None:
1491                     root_cmd(
1492                         "rm -rf '{}'".format(preseed_minion_keys_tempdir),
1493                         tty,
1494                         sudo,
1495                         **ssh_kwargs
1496                     )
1497                     log.debug("Removed %s", preseed_minion_keys_tempdir)
1498             if start_action and not parallel:
1499                 queuereturn = queue.get()
1500                 process.join()
1501                 if queuereturn and start_action:
1502                     log.info("Executing %s on the salt-minion", start_action)
1503                     root_cmd(
1504                         "salt-call {}".format(start_action), tty, sudo, **ssh_kwargs
1505                     )
1506                     log.info("Finished executing %s on the salt-minion", start_action)
1507             fire_event(
1508                 "event",
1509                 "{} has been deployed at {}".format(name, host),
1510                 "salt/cloud/{}/deploy_script".format(name),
1511                 args={"name": name, "host": host},
1512                 sock_dir=opts.get(
1513                     "sock_dir", os.path.join(__opts__["sock_dir"], "master")
1514                 ),
1515                 transport=opts.get("transport", "zeromq"),
1516             )
1517             if file_map_fail or file_map_success:
1518                 return {
1519                     "File Upload Success": file_map_success,
1520                     "File Upload Failure": file_map_fail,
1521                 }
1522             return True
1523     return False
1524 def run_inline_script(
1525     host,
1526     name=None,
1527     port=22,
1528     timeout=900,
1529     username="root",
1530     key_filename=None,
1531     inline_script=None,
1532     ssh_timeout=15,
1533     display_ssh_output=True,
1534     parallel=False,
1535     sudo_password=None,
1536     sudo=False,
1537     password=None,
1538     tty=None,
1539     opts=None,
1540     tmp_dir="/tmp/.saltcloud-inline_script",
1541     **kwargs
1542 ):
1543     gateway = None
1544     if "gateway" in kwargs:
1545         gateway = kwargs["gateway"]
1546     starttime = time.mktime(time.localtime())
1547     log.debug("Deploying %s at %s", host, starttime)
1548     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1549     if wait_for_port(host=host, port=port, gateway=gateway):
1550         log.debug("SSH port %s on %s is available", port, host)
1551         newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1552         if wait_for_passwd(
1553             host,
1554             port=port,
1555             username=username,
1556             password=password,
1557             key_filename=key_filename,
1558             ssh_timeout=ssh_timeout,
1559             display_ssh_output=display_ssh_output,
1560             gateway=gateway,
1561             known_hosts_file=known_hosts_file,
1562         ):
1563             log.debug("Logging into %s:%s as %s", host, port, username)
1564             newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1565             ssh_kwargs = {
1566                 "hostname": host,
1567                 "port": port,
1568                 "username": username,
1569                 "timeout": ssh_timeout,
1570                 "display_ssh_output": display_ssh_output,
1571                 "sudo_password": sudo_password,
1572                 "sftp": opts.get("use_sftp", False),
1573             }
1574             ssh_kwargs.update(__ssh_gateway_config_dict(gateway))
1575             if key_filename:
1576                 log.debug("Using %s as the key_filename", key_filename)
1577                 ssh_kwargs["key_filename"] = key_filename
1578             elif (
1579                 password
1580                 and "has_ssh_agent" in kwargs
1581                 and kwargs["has_ssh_agent"] is False
1582             ):
1583                 ssh_kwargs["password"] = password
1584             if (
1585                 root_cmd(
1586                     'test -e \\"{}\\"'.format(tmp_dir),
1587                     tty,
1588                     sudo,
1589                     allow_failure=True,
1590                     **ssh_kwargs
1591                 )
1592                 and inline_script
1593             ):
1594                 log.debug("Found inline script to execute.")
1595                 for cmd_line in inline_script:
1596                     log.info("Executing inline command: %s", cmd_line)
1597                     ret = root_cmd(
1598                         'sh -c "( {} )"'.format(cmd_line),
1599                         tty,
1600                         sudo,
1601                         allow_failure=True,
1602                         **ssh_kwargs
1603                     )
1604                     if ret:
1605                         log.info("[%s] Output: %s", cmd_line, ret)
1606     return True
1607 def filter_event(tag, data, defaults):
1608     ret = {}
1609     keys = []
1610     use_defaults = True
1611     for ktag in __opts__.get("filter_events", {}):
1612         if tag != ktag:
1613             continue
1614         keys = __opts__["filter_events"][ktag]["keys"]
1615         use_defaults = __opts__["filter_events"][ktag].get("use_defaults", True)
1616     if use_defaults is False:
1617         defaults = []
1618     if not isinstance(defaults, list):
1619         defaults = list(defaults)
1620     defaults = list(set(defaults + keys))
1621     for key in defaults:
1622         if key in data:
1623             ret[key] = data[key]
1624     return ret
1625 def fire_event(key, msg, tag, sock_dir, args=None, transport="zeromq"):
1626     with salt.utils.event.get_event("master", sock_dir, listen=False) as event:
1627         try:
1628             event.fire_event(msg, tag)
1629         except ValueError:
1630             if isinstance(args, dict):
1631                 args[key] = msg
1632             else:
1633                 args = {key: msg}
1634             event.fire_event(args, tag)
1635         time.sleep(0.025)
1636 def _exec_ssh_cmd(cmd, error_msg=None, allow_failure=False, **kwargs):
1637     if error_msg is None:
1638         error_msg = "A wrong password has been issued while establishing ssh session."
1639     password_retries = kwargs.get("password_retries", 3)
1640     try:
1641         stdout, stderr = None, None
1642         proc = salt.utils.vt.Terminal(
1643             cmd,
1644             shell=True,
1645             log_stdout=True,
1646             log_stderr=True,
1647             stream_stdout=kwargs.get("display_ssh_output", True),
1648             stream_stderr=kwargs.get("display_ssh_output", True),
1649         )
1650         sent_password = 0
1651         while proc.has_unread_data:
1652             stdout, stderr = proc.recv()
1653             if stdout and SSH_PASSWORD_PROMP_RE.search(stdout):
1654                 if (
1655                     "key_filename" in kwargs
1656                     and kwargs["key_filename"]
1657                     and SSH_PASSWORD_PROMP_SUDO_RE.search(stdout)
1658                 ):
1659                     proc.sendline(kwargs["sudo_password"])
1660                 elif kwargs.get("password", None) and (
1661                     sent_password &lt; password_retries
1662                 ):
1663                     sent_password += 1
1664                     proc.sendline(kwargs["password"])
1665                 else:
1666                     raise SaltCloudPasswordError(error_msg)
1667             time.sleep(0.5)
1668         if proc.exitstatus != 0 and allow_failure is False:
1669             raise SaltCloudSystemExit(
1670                 "Command '{}' failed. Exit code: {}".format(cmd, proc.exitstatus)
1671             )
1672         return proc.exitstatus
1673     except salt.utils.vt.TerminalException as err:
1674         trace = traceback.format_exc()
1675         log.error(
1676             error_msg.format(cmd, err, trace)
1677         )  # pylint: disable=str-format-in-logging
1678     finally:
1679         proc.close(terminate=True, kill=True)
1680     return 1
1681 def scp_file(dest_path, contents=None, kwargs=None, local_file=None):
1682     file_to_upload = None
1683     try:
1684         if contents is not None:
1685             try:
1686                 tmpfd, file_to_upload = tempfile.mkstemp()
1687                 os.write(tmpfd, contents)
1688             finally:
1689                 try:
1690                     os.close(tmpfd)
1691                 except OSError as exc:
1692                     if exc.errno != errno.EBADF:
1693                         raise
1694         log.debug("Uploading %s to %s", dest_path, kwargs["hostname"])
1695         ssh_args = [
1696             "-oStrictHostKeyChecking=no",
1697             "-oServerAliveInterval={}".format(
1698                 kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
1699             ),
1700             "-oServerAliveCountMax={}".format(
1701                 kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
1702             ),
1703             "-oUserKnownHostsFile=/dev/null",
1704             "-oControlPath=none",
1705         ]
1706         if local_file is not None:
1707             file_to_upload = local_file
1708             if os.path.isdir(local_file):
1709                 ssh_args.append("-r")
1710         if "key_filename" in kwargs:
1711             ssh_args.extend(
1712                 [
1713                     "-oPasswordAuthentication=no",
1714                     "-oChallengeResponseAuthentication=no",
1715                     "-oPubkeyAuthentication=yes",
1716                     "-oIdentitiesOnly=yes",
1717                     "-oKbdInteractiveAuthentication=no",
1718                     "-i {}".format(kwargs["key_filename"]),
1719                 ]
1720             )
1721         if "port" in kwargs:
1722             ssh_args.append("-oPort={}".format(kwargs["port"]))
1723         ssh_args.append(__ssh_gateway_arguments(kwargs))
1724         try:
1725             if socket.inet_pton(socket.AF_INET6, kwargs["hostname"]):
1726                 ipaddr = "[{}]".format(kwargs["hostname"])
1727             else:
1728                 ipaddr = kwargs["hostname"]
1729         except OSError:
1730             ipaddr = kwargs["hostname"]
1731         if file_to_upload is None:
1732             log.warning(
1733                 "No source file to upload. Please make sure that either file "
1734                 "contents or the path to a local file are provided."
1735             )
1736         cmd = (
1737             "scp {0} {1} {2[username]}@{4}:{3} || "
1738             'echo "put {1} {3}" | sftp {0} {2[username]}@{4} || '
1739             'rsync -avz -e "ssh {0}" {1} {2[username]}@{2[hostname]}:{3}'.format(
1740                 " ".join(ssh_args), file_to_upload, kwargs, dest_path, ipaddr
1741             )
1742         )
1743         log.debug("SCP command: '%s'", cmd)
1744         retcode = _exec_ssh_cmd(
1745             cmd,
1746             error_msg="Failed to upload file '{0}': {1}\n{2}",
1747             password_retries=3,
1748             **kwargs
1749         )
1750     finally:
1751         if contents is not None:
1752             try:
1753                 os.remove(file_to_upload)
1754             except OSError as exc:
1755                 if exc.errno != errno.ENOENT:
1756                     raise
1757     return retcode
1758 def ssh_file(opts, dest_path, contents=None, kwargs=None, local_file=None):
1759     if opts.get("file_transport", "sftp") == "sftp":
1760         return sftp_file(dest_path, contents, kwargs, local_file)
1761     return scp_file(dest_path, contents, kwargs, local_file)
1762 def sftp_file(dest_path, contents=None, kwargs=None, local_file=None):
1763     put_args = []
1764     if kwargs is None:
1765         kwargs = {}
1766     file_to_upload = None
1767     try:
1768         if contents is not None:
1769             try:
1770                 tmpfd, file_to_upload = tempfile.mkstemp()
1771                 if isinstance(contents, str):
1772                     os.write(tmpfd, contents.encode(__salt_system_encoding__))
1773                 else:
1774                     os.write(tmpfd, contents)
1775             finally:
1776                 try:
1777                     os.close(tmpfd)
1778                 except OSError as exc:
1779                     if exc.errno != errno.EBADF:
1780                         raise
1781         if local_file is not None:
1782             file_to_upload = local_file
1783             if os.path.isdir(local_file):
1784                 put_args = ["-r"]
1785         log.debug("Uploading %s to %s (sftp)", dest_path, kwargs.get("hostname"))
1786         ssh_args = [
1787             "-oStrictHostKeyChecking=no",
1788             "-oServerAliveInterval={}".format(
1789                 kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
1790             ),
1791             "-oServerAliveCountMax={}".format(
1792                 kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
1793             ),
1794             "-oUserKnownHostsFile=/dev/null",
1795             "-oControlPath=none",
1796         ]
1797         if "key_filename" in kwargs:
1798             ssh_args.extend(
1799                 [
1800                     "-oPasswordAuthentication=no",
1801                     "-oChallengeResponseAuthentication=no",
1802                     "-oPubkeyAuthentication=yes",
1803                     "-oIdentitiesOnly=yes",
1804                     "-oKbdInteractiveAuthentication=no",
1805                     "-oIdentityFile={}".format(kwargs["key_filename"]),
1806                 ]
1807             )
1808         if "port" in kwargs:
1809             ssh_args.append("-oPort={}".format(kwargs["port"]))
1810         ssh_args.append(__ssh_gateway_arguments(kwargs))
1811         try:
1812             if socket.inet_pton(socket.AF_INET6, kwargs["hostname"]):
1813                 ipaddr = "[{}]".format(kwargs["hostname"])
1814             else:
1815                 ipaddr = kwargs["hostname"]
1816         except OSError:
1817             ipaddr = kwargs["hostname"]
1818         if file_to_upload is None:
1819             log.warning(
1820                 "No source file to upload. Please make sure that either file "
1821                 "contents or the path to a local file are provided."
1822             )
1823         cmd = 'echo "put {0} {1} {2}" | sftp {3} {4[username]}@{5}'.format(
1824             " ".join(put_args),
1825             file_to_upload,
1826             dest_path,
1827             " ".join(ssh_args),
1828             kwargs,
1829             ipaddr,
1830         )
1831         log.debug("SFTP command: '%s'", cmd)
1832         retcode = _exec_ssh_cmd(
1833             cmd,
1834             error_msg="Failed to upload file '{0}': {1}\n{2}",
1835             password_retries=3,
1836             **kwargs
1837         )
1838     finally:
1839         if contents is not None:
1840             try:
1841                 os.remove(file_to_upload)
1842             except OSError as exc:
1843                 if exc.errno != errno.ENOENT:
1844                     raise
1845     return retcode
1846 def win_cmd(command, **kwargs):
1847     logging_command = kwargs.get("logging_command", None)
1848     try:
1849         proc = NonBlockingPopen(
1850             command,
1851             shell=True,
1852             stderr=subprocess.PIPE,
1853             stdout=subprocess.PIPE,
1854             stream_stds=kwargs.get("display_ssh_output", True),
1855             logging_command=logging_command,
1856         )
1857         if logging_command is None:
1858             log.debug("Executing command(PID %s): '%s'", proc.pid, command)
1859         else:
1860             log.debug("Executing command(PID %s): '%s'", proc.pid, logging_command)
1861         proc.poll_and_read_until_finish()
1862         proc.communicate()
1863         return proc.returncode
1864     except Exception as err:  # pylint: disable=broad-except
1865         log.exception("Failed to execute command '%s'", logging_command)
1866     return 1
1867 def winrm_cmd(session, command, flags, **kwargs):
1868     log.debug("Executing WinRM command: %s %s", command, flags)
1869     r = session.run_cmd(command, flags)
1870     return r.status_code
1871 def root_cmd(command, tty, sudo, allow_failure=False, **kwargs):
1872     logging_command = command
1873     sudo_password = kwargs.get("sudo_password", None)
1874     if sudo:
1875         if sudo_password is None:
1876             command = "sudo {}".format(command)
1877             logging_command = command
1878         else:
1879             logging_command = 'sudo -S "XXX-REDACTED-XXX" {}'.format(command)
1880             command = "sudo -S {}".format(command)
1881         log.debug("Using sudo to run command %s", logging_command)
1882     ssh_args = []
1883     if tty:
1884         ssh_args.extend(["-t", "-t"])
1885     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1886     host_key_checking = "no"
1887     if known_hosts_file != "/dev/null":
1888         host_key_checking = "yes"
1889     ssh_args.extend(
1890         [
1891             "-oStrictHostKeyChecking={}".format(host_key_checking),
1892             "-oUserKnownHostsFile={}".format(known_hosts_file),
1893             "-oControlPath=none",
1894         ]
1895     )
1896     if "key_filename" in kwargs:
1897         ssh_args.extend(
1898             [
1899                 "-oPasswordAuthentication=no",
1900                 "-oChallengeResponseAuthentication=no",
1901                 "-oPubkeyAuthentication=yes",
1902                 "-oIdentitiesOnly=yes",
1903                 "-oKbdInteractiveAuthentication=no",
1904                 "-i {}".format(kwargs["key_filename"]),
1905             ]
1906         )
1907     if "ssh_timeout" in kwargs:
1908         ssh_args.extend(["-oConnectTimeout={}".format(kwargs["ssh_timeout"])])
1909     ssh_args.extend([__ssh_gateway_arguments(kwargs)])
1910     if "port" in kwargs:
1911         ssh_args.extend(["-p {}".format(kwargs["port"])])
1912     cmd = "ssh {0} {1[username]}@{1[hostname]} ".format(" ".join(ssh_args), kwargs)
1913     logging_command = cmd + logging_command
1914     cmd = cmd + pipes.quote(command)
1915     hard_timeout = kwargs.get("hard_timeout")
1916     if hard_timeout is not None:
1917         logging_command = "timeout {} {}".format(hard_timeout, logging_command)
1918         cmd = "timeout {} {}".format(hard_timeout, cmd)
1919     log.debug("SSH command: '%s'", logging_command)
1920     retcode = _exec_ssh_cmd(cmd, allow_failure=allow_failure, **kwargs)
1921     return retcode
1922 def check_auth(name, sock_dir=None, queue=None, timeout=300):
1923     with salt.utils.event.SaltEvent("master", sock_dir, listen=True) as event:
1924         starttime = time.mktime(time.localtime())
1925         newtimeout = timeout
1926         log.debug("In check_auth, waiting for %s to become available", name)
1927         while newtimeout &gt; 0:
1928             newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1929             ret = event.get_event(full=True)
1930             if ret is None:
1931                 continue
1932             if ret["tag"] == "salt/minion/{}/start".format(name):
1933                 queue.put(name)
1934                 newtimeout = 0
1935                 log.debug("Minion %s is ready to receive commands", name)
1936 def ip_to_int(ip):
1937     ret = 0
1938     for octet in ip.split("."):
1939         ret = ret * 256 + int(octet)
1940     return ret
1941 def is_public_ip(ip):
1942     if ":" in ip:
1943         if ip.startswith("fe80:"):
1944             return False
1945         return True
1946     addr = ip_to_int(ip)
1947     if 167772160 &lt; addr &lt; 184549375:
1948         return False
1949     elif 3232235520 &lt; addr &lt; 3232301055:
1950         return False
1951     elif 2886729728 &lt; addr &lt; 2887778303:
1952         return False
1953     elif 2130706432 &lt; addr &lt; 2147483647:
1954         return False
1955     return True
1956 def check_name(name, safe_chars):
1957     regexp = re.compile("[^{}]".format(safe_chars))
1958     if regexp.search(name):
1959         raise SaltCloudException(
1960             "{} contains characters not supported by this cloud provider. "
1961             "Valid characters are: {}".format(name, safe_chars)
1962         )
1963 def remove_sshkey(host, known_hosts=None):
1964     if known_hosts is None:
1965         if "HOME" in os.environ:
1966             known_hosts = "{}/.ssh/known_hosts".format(os.environ["HOME"])
1967         else:
1968             try:
1969                 known_hosts = "{}/.ssh/known_hosts".format(
1970                     pwd.getpwuid(os.getuid()).pwd_dir
1971                 )
1972             except Exception:  # pylint: disable=broad-except
1973                 pass
1974     if known_hosts is not None:
1975         log.debug("Removing ssh key for %s from known hosts file %s", host, known_hosts)
1976     else:
1977         log.debug("Removing ssh key for %s from known hosts file", host)
1978     subprocess.call(["ssh-keygen", "-R", host])
1979 def wait_for_ip(
1980     update_callback,
1981     update_args=None,
1982     update_kwargs=None,
1983     timeout=5 * 60,
1984     interval=5,
1985     interval_multiplier=1,
1986     max_failures=10,
1987 ):
1988     if update_args is None:
1989         update_args = ()
1990     if update_kwargs is None:
1991         update_kwargs = {}
1992     duration = timeout
1993     while True:
1994         log.debug(
1995             "Waiting for VM IP. Giving up in 00:%02d:%02d.",
1996             int(timeout // 60),
1997             int(timeout % 60),
1998         )
1999         data = update_callback(*update_args, **update_kwargs)
2000         if data is False:
2001             log.debug(
2002                 "'update_callback' has returned 'False', which is "
2003                 "considered a failure. Remaining Failures: %s.",
2004                 max_failures,
2005             )
2006             max_failures -= 1
2007             if max_failures &lt;= 0:
2008                 raise SaltCloudExecutionFailure(
2009                     "Too many failures occurred while waiting for the IP address."
2010                 )
2011         elif data is not None:
2012             return data
2013         if timeout &lt; 0:
2014             raise SaltCloudExecutionTimeout(
2015                 "Unable to get IP for 00:{:02d}:{:02d}.".format(
2016                     int(duration // 60), int(duration % 60)
2017                 )
2018             )
2019         time.sleep(interval)
2020         timeout -= interval
2021         if interval_multiplier &gt; 1:
2022             interval *= interval_multiplier
2023             if interval &gt; timeout:
2024                 interval = timeout + 1
2025             log.info("Interval multiplier in effect; interval is now %ss.", interval)
2026 def list_nodes_select(nodes, selection, call=None):
2027     if call == "action":
2028         raise SaltCloudSystemExit(
2029             "The list_nodes_select function must be called with -f or --function."
2030         )
2031     if "error" in nodes:
2032         raise SaltCloudSystemExit(
2033             "An error occurred while listing nodes: {}".format(
2034                 nodes["error"]["Errors"]["Error"]["Message"]
2035             )
2036         )
2037     ret = {}
2038     for node in nodes:
2039         pairs = {}
2040         data = nodes[node]
2041         for key in data:
2042             if str(key) in selection:
2043                 value = data[key]
2044                 pairs[key] = value
2045         ret[node] = pairs
2046     return ret
2047 def lock_file(filename, interval=0.5, timeout=15):
2048     log.trace("Attempting to obtain lock for %s", filename)
2049     lock = filename + ".lock"
2050     start = time.time()
2051     while True:
2052         if os.path.exists(lock):
2053             if time.time() - start &gt;= timeout:
2054                 log.warning("Unable to obtain lock for %s", filename)
2055                 return False
2056             time.sleep(interval)
2057         else:
2058             break
2059     with salt.utils.files.fopen(lock, "a"):
2060         pass
2061 def unlock_file(filename):
2062     log.trace("Removing lock for %s", filename)
2063     lock = filename + ".lock"
2064     try:
2065         os.remove(lock)
2066     except OSError as exc:
2067         log.trace("Unable to remove lock for %s: %s", filename, exc)
2068 def cachedir_index_add(minion_id, profile, driver, provider, base=None):
2069     base = init_cachedir(base)
2070     index_file = os.path.join(base, "index.p")
2071 <a name="4"></a>    lock_file(index_file)
2072     if os.path.exists(index_file):
2073         with salt<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(index_file, "rb") as fh_:
2074             index = salt.utils.data.decode(
2075                 salt.utils.msgpack.load(</b></font>fh_, encoding=MSGPACK_ENCODING)
2076             )
2077     else:
2078         index = {}
2079     prov_comps = provider.split(":")
2080     index.update(
2081         {
2082             minion_id: {
2083                 "id": minion_id,
2084                 "profile": profile,
2085                 "driver": driver,
2086                 "provider": prov_comps[0],
2087             }
2088         }
2089     )
2090     with salt.utils.files.fopen(index_file, "wb") as fh_:
2091         salt.utils.msgpack.dump(index, fh_, encoding=MSGPACK_ENCODING)
2092     unlock_file(index_file)
2093 def cachedir_index_del(minion_id, base=None):
2094     base = init_cachedir(base)
2095     index_file = os.path.join(base, "index.p")
2096 <a name="3"></a>    lock_file(index_file)
2097     if os.path.exists(index_file):
2098         with salt<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(index_file, "rb") as fh_:
2099             index = salt.utils.data.decode(
2100                 salt.utils.msgpack.load(</b></font>fh_, encoding=MSGPACK_ENCODING)
2101             )
2102     else:
2103         return
2104     if minion_id in index:
2105         del index[minion_id]
2106     with salt.utils.files.fopen(index_file, "wb") as fh_:
2107         salt.utils.msgpack.dump(index, fh_, encoding=MSGPACK_ENCODING)
2108     unlock_file(index_file)
2109 def init_cachedir(base=None):
2110     if base is None:
2111         base = __opts__["cachedir"]
2112     needed_dirs = (base, os.path.join(base, "requested"), os.path.join(base, "active"))
2113     for dir_ in needed_dirs:
2114         if not os.path.exists(dir_):
2115             os.makedirs(dir_)
2116         os.chmod(base, 0o755)
2117     return base
2118 def request_minion_cachedir(
2119     minion_id,
2120     opts=None,
2121     fingerprint="",
2122     pubkey=None,
2123     provider=None,
2124     base=None,
2125 ):
2126     if base is None:
2127         base = __opts__["cachedir"]
2128     if not fingerprint and pubkey is not None:
2129         fingerprint = salt.utils.crypt.pem_finger(
2130             key=pubkey, sum_type=(opts and opts.get("hash_type") or "sha256")
2131         )
2132     init_cachedir(base)
2133     data = {
2134         "minion_id": minion_id,
2135         "fingerprint": fingerprint,
2136 <a name="7"></a>        "provider": provider,
2137     }
2138     fname = "{}.p"<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.format(minion_id)
2139     path = os.path.join(base, "requested", fname)
2140     with salt.utils.files.fopen(path, "wb") as fh_:
2141         salt.</b></font>utils.msgpack.dump(data, fh_, encoding=MSGPACK_ENCODING)
2142 def change_minion_cachedir(
2143     minion_id,
2144     cachedir,
2145     data=None,
2146     base=None,
2147 ):
2148     if not isinstance(data, dict):
2149         return False
2150     if base is None:
2151         base = __opts__["cachedir"]
2152     fname = "{}.p".format(minion_id)
2153     path = os.path.join(base, cachedir, fname)
2154     with salt.utils.files.fopen(path, "r") as fh_:
2155         cache_data = salt.utils.data.decode(
2156             salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2157         )
2158     cache_data.update(data)
2159     with salt.utils.files.fopen(path, "w") as fh_:
2160         salt.utils.msgpack.dump(cache_data, fh_, encoding=MSGPACK_ENCODING)
2161 def activate_minion_cachedir(minion_id, base=None):
2162     if base is None:
2163         base = __opts__["cachedir"]
2164     fname = "{}.p".format(minion_id)
2165     src = os.path.join(base, "requested", fname)
2166     dst = os.path.join(base, "active")
2167     shutil.move(src, dst)
2168 def delete_minion_cachedir(minion_id, provider, opts, base=None):
2169     if isinstance(opts, dict):
2170         __opts__.update(opts)
2171     if __opts__.get("update_cachedir", False) is False:
2172         return
2173     if base is None:
2174         base = __opts__["cachedir"]
2175     driver = next(iter(__opts__["providers"][provider].keys()))
2176     fname = "{}.p".format(minion_id)
2177     for cachedir in "requested", "active":
2178         path = os.path.join(base, cachedir, driver, provider, fname)
2179         log.debug("path: %s", path)
2180         if os.path.exists(path):
2181             os.remove(path)
2182 def list_cache_nodes_full(opts=None, provider=None, base=None):
2183     if opts is None:
2184         opts = __opts__
2185     if opts.get("update_cachedir", False) is False:
2186         return
2187     if base is None:
2188         base = os.path.join(opts["cachedir"], "active")
2189     minions = {}
2190     for driver in os.listdir(base):
2191         minions[driver] = {}
2192         prov_dir = os.path.join(base, driver)
2193         for prov in os.listdir(prov_dir):
2194             if provider and provider != prov:
2195                 continue
2196             minions[driver][prov] = {}
2197             min_dir = os.path.join(prov_dir, prov)
2198             for fname in os.listdir(min_dir):
2199                 fpath = os.path.join(min_dir, fname)
2200                 minion_id = fname[:-2]  # strip '.p' from end of msgpack filename
2201                 with salt.utils.files.fopen(fpath, "rb") as fh_:
2202                     minions[driver][prov][minion_id] = salt.utils.data.decode(
2203                         salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2204                     )
2205     return minions
2206 def update_bootstrap(config, url=None):
2207     default_url = config.get("bootstrap_script_url", "https://bootstrap.saltstack.com")
2208     if not url:
2209         url = default_url
2210     if not url:
2211         raise ValueError("Cant get any source to update")
2212     if url.startswith("http") or "://" in url:
2213         log.debug("Updating the bootstrap-salt.sh script to latest stable")
2214         try:
2215             import requests
2216         except ImportError:
2217             return {
2218                 "error": (
2219                     "Updating the bootstrap-salt.sh script requires the "
2220                     "Python requests library to be installed"
2221                 )
2222             }
2223         req = requests.get(url)
2224         if req.status_code != 200:
2225             return {
2226                 "error": (
2227                     "Failed to download the latest stable version of the "
2228                     "bootstrap-salt.sh script from {}. HTTP error: "
2229                     "{}".format(url, req.status_code)
2230                 )
2231             }
2232         script_content = req.text
2233         if url == default_url:
2234             script_name = "bootstrap-salt.sh"
2235 <a name="1"></a>        else:
2236             script_name = os.path.basename(url)
2237     elif os.path.exists(url):
2238         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(url) as fic:
2239             script_content = salt.utils.stringutils.to_unicode(fic.read())
2240         script_name =</b></font> os.path.basename(url)
2241     else:
2242         script_content = url
2243         script_name = "{}.sh".format(hashlib.sha1(script_content).hexdigest())
2244     if not script_content:
2245         raise ValueError("No content in bootstrap script !")
2246     builtin_deploy_dir = os.path.join(os.path.dirname(__file__), "deploy")
2247     deploy_d_from_conf_file = os.path.join(
2248         os.path.dirname(config["conf_file"]), "cloud.deploy.d"
2249     )
2250     deploy_d_from_syspaths = os.path.join(config["config_dir"], "cloud.deploy.d")
2251     deploy_scripts_search_paths = []
2252     for entry in config.get("deploy_scripts_search_path", []):
2253         if entry.startswith(builtin_deploy_dir):
2254             continue
2255         if entry in (deploy_d_from_conf_file, deploy_d_from_syspaths):
2256             deploy_scripts_search_paths.append((entry, True))
2257         else:
2258             deploy_scripts_search_paths.append((entry, False))
2259     if deploy_d_from_conf_file not in deploy_scripts_search_paths:
2260         deploy_scripts_search_paths.append((deploy_d_from_conf_file, True))
2261     if deploy_d_from_syspaths not in deploy_scripts_search_paths:
2262         deploy_scripts_search_paths.append((deploy_d_from_syspaths, True))
2263     finished = []
2264     finished_full = []
2265     for entry, makedirs in deploy_scripts_search_paths:
2266         if entry in finished:
2267             continue
2268         else:
2269             finished.append(entry)
2270         if makedirs and not os.path.isdir(entry):
2271             try:
2272                 os.makedirs(entry)
2273             except OSError as err:
2274                 log.info("Failed to create directory '%s'", entry)
2275                 continue
2276         if not is_writeable(entry):
2277             log.debug("The '%s' is not writeable. Continuing...", entry)
2278             continue
2279 <a name="5"></a>        deploy_path = os.path.join(entry, script_name)
2280         try:
2281             finished_full.append(deploy_path)
2282             <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(deploy_path, "w") as fp_:
2283                 fp_.write(salt.utils.stringutils.to_str(</b></font>script_content))
2284         except OSError as err:
2285             log.debug("Failed to write the updated script: %s", err)
2286             continue
2287     return {"Success": {"Files updated": finished_full}}
2288 def cache_node_list(nodes, provider, opts):
2289     if "update_cachedir" not in opts or not opts["update_cachedir"]:
2290         return
2291     base = os.path.join(init_cachedir(), "active")
2292     driver = next(iter(opts["providers"][provider].keys()))
2293     prov_dir = os.path.join(base, driver, provider)
2294     if not os.path.exists(prov_dir):
2295         os.makedirs(prov_dir)
2296     missing_node_cache(prov_dir, nodes, provider, opts)
2297     for node in nodes:
2298         diff_node_cache(prov_dir, node, nodes[node], opts)
2299         path = os.path.join(prov_dir, "{}.p".format(node))
2300         with salt.utils.files.fopen(path, "wb") as fh_:
2301             salt.utils.msgpack.dump(nodes[node], fh_, encoding=MSGPACK_ENCODING)
2302 def cache_node(node, provider, opts):
2303     if isinstance(opts, dict):
2304         __opts__.update(opts)
2305     if "update_cachedir" not in __opts__ or not __opts__["update_cachedir"]:
2306         return
2307     if not os.path.exists(os.path.join(__opts__["cachedir"], "active")):
2308         init_cachedir()
2309     base = os.path.join(__opts__["cachedir"], "active")
2310     provider, driver = provider.split(":")
2311     prov_dir = os.path.join(base, driver, provider)
2312     if not os.path.exists(prov_dir):
2313         os.makedirs(prov_dir)
2314     path = os.path.join(prov_dir, "{}.p".format(node["name"]))
2315     with salt.utils.files.fopen(path, "wb") as fh_:
2316         salt.utils.msgpack.dump(node, fh_, encoding=MSGPACK_ENCODING)
2317 def missing_node_cache(prov_dir, node_list, provider, opts):
2318     cached_nodes = []
2319     for node in os.listdir(prov_dir):
2320         cached_nodes.append(os.path.splitext(node)[0])
2321     for node in cached_nodes:
2322         if node not in node_list:
2323             delete_minion_cachedir(node, provider, opts)
2324             if "diff_cache_events" in opts and opts["diff_cache_events"]:
2325                 fire_event(
2326                     "event",
2327                     "cached node missing from provider",
2328                     "salt/cloud/{}/cache_node_missing".format(node),
2329                     args={"missing node": node},
2330                     sock_dir=opts.get(
2331                         "sock_dir", os.path.join(__opts__["sock_dir"], "master")
2332                     ),
2333                     transport=opts.get("transport", "zeromq"),
2334                 )
2335 def diff_node_cache(prov_dir, node, new_data, opts):
2336     if "diff_cache_events" not in opts or not opts["diff_cache_events"]:
2337         return
2338     if node is None:
2339         return
2340     path = "{}.p".format(os.path.join(prov_dir, node))
2341     if not os.path.exists(path):
2342         event_data = _strip_cache_events(new_data, opts)
2343         fire_event(
2344             "event",
2345             "new node found",
2346             "salt/cloud/{}/cache_node_new".format(node),
2347             args={"new_data": event_data},
2348             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
2349             transport=opts.get("transport", "zeromq"),
2350         )
2351         return
2352     with salt.utils.files.fopen(path, "r") as fh_:
2353         try:
2354             cache_data = salt.utils.data.decode(
2355                 salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2356             )
2357         except ValueError:
2358             log.warning("Cache for %s was corrupt: Deleting", node)
2359             cache_data = {}
2360     diff = salt.utils.compat.cmp(new_data, cache_data)
2361     if diff != 0:
2362         fire_event(
2363             "event",
2364             "node data differs",
2365             "salt/cloud/{}/cache_node_diff".format(node),
2366             args={
2367                 "new_data": _strip_cache_events(new_data, opts),
2368                 "cache_data": _strip_cache_events(cache_data, opts),
2369             },
2370             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
2371             transport=opts.get("transport", "zeromq"),
2372         )
2373 def _strip_cache_events(data, opts):
2374     event_data = copy.deepcopy(data)
2375     strip_fields = opts.get("cache_event_strip_fields", [])
2376     for field in strip_fields:
2377         if field in event_data:
2378             del event_data[field]
2379     return event_data
2380 def _salt_cloud_force_ascii(exc):
2381     if not isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError)):
2382         raise TypeError("Can't handle {}".format(exc))
2383     unicode_trans = {
2384         "\xa0": " ",
2385         "\u2013": "-",
2386     }
2387     if exc.object[exc.start : exc.end] in unicode_trans:
2388         return unicode_trans[exc.object[exc.start : exc.end]], exc.end
2389     raise exc
2390 codecs.register_error("salt-cloud-force-ascii", _salt_cloud_force_ascii)
2391 def retrieve_password_from_keyring(credential_id, username):
2392     try:
2393         import keyring  # pylint: disable=import-error
2394         return keyring.get_password(credential_id, username)
2395     except ImportError:
2396         log.error(
2397             "USE_KEYRING configured as a password, but no keyring module is installed"
2398         )
2399         return False
2400 def _save_password_in_keyring(credential_id, username, password):
2401     try:
2402         import keyring  # pylint: disable=import-error
2403         return keyring.set_password(credential_id, username, password)
2404     except ImportError:
2405         log.error(
2406             "Tried to store password in keyring, but no keyring module is installed"
2407         )
2408         return False
2409 def store_password_in_keyring(credential_id, username, password=None):
2410     try:
2411         import keyring
2412         import keyring.errors
2413         if password is None:
2414             prompt = "Please enter password for {}: ".format(credential_id)
2415             try:
2416                 password = getpass.getpass(prompt)
2417             except EOFError:
2418                 password = None
2419             if not password:
2420                 raise RuntimeError("Invalid password provided.")
2421         try:
2422             _save_password_in_keyring(credential_id, username, password)
2423         except keyring.errors.PasswordSetError as exc:
2424             log.debug("Problem saving password in the keyring: %s", exc)
2425     except ImportError:
2426         log.error(
2427             "Tried to store password in keyring, but no keyring module is installed"
2428         )
2429         return False
2430 def _unwrap_dict(dictionary, index_string):
2431     index = index_string.split(",")
2432     for k in index:
2433         dictionary = dictionary[k]
2434     return dictionary
2435 def run_func_until_ret_arg(
2436     fun,
2437     kwargs,
2438     fun_call=None,
2439     argument_being_watched=None,
2440     required_argument_response=None,
2441 ):
2442     status = None
2443     while status != required_argument_response:
2444         f_result = fun(kwargs, call=fun_call)
2445         r_set = {}
2446         for d in f_result:
2447             if isinstance(d, list):
2448                 d0 = d[0]
2449                 if isinstance(d0, dict):
2450                     for k, v in d0.items():
2451                         r_set[k] = v
2452         status = _unwrap_dict(r_set, argument_being_watched)
2453         log.debug(
2454             "Function: %s, Watched arg: %s, Response: %s",
2455             str(fun).split(" ")[1],
2456             argument_being_watched,
2457             status,
2458         )
2459         time.sleep(5)
2460     return True
2461 def get_salt_interface(vm_, opts):
2462     salt_host = salt.config.get_cloud_config_value(
2463         "salt_interface", vm_, opts, default=False, search_global=False
2464     )
2465     if salt_host is False:
2466         salt_host = salt.config.get_cloud_config_value(
2467             "ssh_interface", vm_, opts, default="public_ips", search_global=False
2468         )
2469     return salt_host
2470 def check_key_path_and_mode(provider, key_path):
2471     if not os.path.exists(key_path):
2472         log.error(
2473             "The key file '%s' used in the '%s' provider configuration "
2474             "does not exist.\n",
2475             key_path,
2476             provider,
2477         )
2478         return False
2479     key_mode = stat.S_IMODE(os.stat(key_path).st_mode)
2480     if key_mode not in (0o400, 0o600):
2481         log.error(
2482             "The key file '%s' used in the '%s' provider configuration "
2483             "needs to be set to mode 0400 or 0600.\n",
2484             key_path,
2485             provider,
2486         )
2487         return False
2488     return True
2489 def userdata_template(opts, vm_, userdata):
2490     if userdata is None:
2491         return userdata
2492     userdata_template = salt.config.get_cloud_config_value(
2493         "userdata_template", vm_, opts, search_global=False, default=None
2494     )
2495     if userdata_template is False:
2496         return userdata
2497     renderer = (
2498         opts.get("userdata_template")
2499         if userdata_template is None
2500         else userdata_template
2501     )
2502     if renderer is None:
2503         return userdata
2504     else:
2505         render_opts = opts.copy()
2506         render_opts.update(vm_)
2507         rend = salt.loader.render(render_opts, {})
2508         blacklist = opts["renderer_blacklist"]
2509         whitelist = opts["renderer_whitelist"]
2510         templated = salt.template.compile_template(
2511             ":string:",
2512             rend,
2513             renderer,
2514             blacklist,
2515             whitelist,
2516             input_data=userdata,
2517         )
2518         if not isinstance(templated, str):
2519             try:
2520                 templated = "".join(templated.readlines())
2521             except AttributeError:
2522                 log.warning(
2523                     "Templated userdata resulted in non-string result (%s), "
2524                     "converting to string",
2525                     templated,
2526                 )
2527                 templated = str(templated)
2528         return templated
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
