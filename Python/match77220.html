<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nacl.py &amp; cloud_4.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nacl.py &amp; cloud_4.py
      </h3>
<h1 align="center">
        4.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nacl.py (17.247097%)<th>cloud_4.py (2.4018476%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(183-186)<td><a href="#" name="0">(259-261)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(269-271)<td><a href="#" name="1">(2999-3001)</a><td align="center"><font color="#ee0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(340-341)<td><a href="#" name="2">(262-263)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(196-198)<td><a href="#" name="3">(2771-2773)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(157-159)<td><a href="#" name="4">(2735-2737)</a><td align="center"><font color="#dd0000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(275-276)<td><a href="#" name="5">(3069-3070)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(188-190)<td><a href="#" name="6">(279-281)</a><td align="center"><font color="#cc0000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(153-156)<td><a href="#" name="7">(2836-2839)</a><td align="center"><font color="#cc0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nacl.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import base64
2 import logging
3 import os
4 import salt.syspaths
5 import salt.utils.files
6 import salt.utils.platform
7 import salt.utils.stringutils
8 import salt.utils.versions
9 import salt.utils.win_dacl
10 import salt.utils.win_functions
11 log = logging.getLogger(__name__)
12 REQ_ERROR = None
13 try:
14     import libnacl.secret
15     import libnacl.sealed
16 except (ImportError, OSError) as e:
17     REQ_ERROR = (
18         "libnacl import error, perhaps missing python libnacl package or should update."
19     )
20 __virtualname__ = "nacl"
21 def __virtual__():
22     if __opts__["fips_mode"] is True:
23         return False, "nacl utils not available in FIPS mode"
24     return check_requirements()
25 def check_requirements():
26     return (REQ_ERROR is None, REQ_ERROR)
27 def _get_config(**kwargs):
28     sk_file = kwargs.get("sk_file")
29     if not sk_file:
30         sk_file = os.path.join(kwargs["opts"].get("pki_dir"), "master/nacl")
31     pk_file = kwargs.get("pk_file")
32     if not pk_file:
33         pk_file = os.path.join(kwargs["opts"].get("pki_dir"), "master/nacl.pub")
34     config = {
35         "box_type": kwargs.get("box_type", "sealedbox"),
36         "sk": None,
37         "sk_file": sk_file,
38         "pk": None,
39         "pk_file": pk_file,
40     }
41     config_key = "{}.config".format(__virtualname__)
42     try:
43         config.update(__salt__["config.get"](config_key, {}))
44     except (NameError, KeyError) as e:
45         config.update(kwargs["opts"].get(config_key, {}))
46     for k in set(config.keys()) &amp; set(kwargs.keys()):
47         config[k] = kwargs[k]
48     return config
49 def _get_sk(**kwargs):
50     config = _get_config(**kwargs)
51     key = None
52     if config["sk"]:
53         key = salt.utils.stringutils.to_str(config["sk"])
54     sk_file = config["sk_file"]
55     if not key and sk_file:
56         try:
57             with salt.utils.files.fopen(sk_file, "rb") as keyf:
58                 key = salt.utils.stringutils.to_unicode(keyf.read()).rstrip("\n")
59         except OSError:
60             raise Exception("no key or sk_file found")
61     return base64.b64decode(key)
62 def _get_pk(**kwargs):
63     config = _get_config(**kwargs)
64     pubkey = None
65     if config["pk"]:
66         pubkey = salt.utils.stringutils.to_str(config["pk"])
67     pk_file = config["pk_file"]
68     if not pubkey and pk_file:
69         try:
70             with salt.utils.files.fopen(pk_file, "rb") as keyf:
71                 pubkey = salt.utils.stringutils.to_unicode(keyf.read()).rstrip("\n")
72         except OSError:
73             raise Exception("no pubkey or pk_file found")
74     pubkey = str(pubkey)
75     return base64.b64decode(pubkey)
76 def keygen(sk_file=None, pk_file=None, **kwargs):
77     if "keyfile" in kwargs:
78         sk_file = kwargs["keyfile"]
79     if sk_file is None:
80         kp = libnacl.public.SecretKey()
81         return {"sk": base64.b64encode(kp.sk), "pk": base64.b64encode(kp.pk)}
82     if pk_file is None:
83     if sk_file and pk_file is None:
84         if not os.path<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.isfile(sk_file):
85             with salt.utils.files.fopen(sk_file, "wb") as keyf:
86                 keyf.</b></font>write(base64.b64encode(kp.sk))
87             if salt<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.platform.is_windows():
88                 cur_user = salt.utils.win_functions.get_current_user()
89                 salt.utils.win_dacl.set_owner(</b></font>sk_file, cur_user)
90                 salt.utils.win_dacl.set_permissions(
91                     sk_file,
92                     cur_user,
93                     "full_control",
94                     "grant",
95                     reset_perms=True,
96                     protected=True,
97                 )
98             else:
99                 os.chmod(sk_file, 1536)
100             return "saved sk_file: {}".format(sk_file)
101         else:
102             raise Exception("sk_file:{} already exist.".format(sk_file))
103     if sk_file is None and pk_file:
104         raise Exception("sk_file: Must be set inorder to generate a public key.")
105     if os.path.isfile(sk_file) and os.path.isfile(pk_file):
106         raise Exception(
107         )
108     if os.path.isfile(sk_file) and not os<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.path.isfile(pk_file):
109             sk = salt.utils.stringutils.to_unicode(keyf.read(</b></font>)).rstrip("\n")
110             sk = base64.b64decode(sk)
111         kp <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= libnacl.public.SecretKey(sk)
112         with salt.utils.files.fopen(pk_file, "wb") as keyf:
113             keyf.write(base64.</b></font>b64encode(kp.pk))
114         return "saved pk_file: {}".format(pk_file)
115     with salt.utils.files.fopen(sk_file, "wb") as keyf:
116         keyf.write(base64.b64encode(kp.sk))
117     if salt<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.utils.platform.is_windows():
118         cur_user = salt.utils.win_functions.get_current_user()
119         salt.utils.win_dacl.set_owner(</b></font>sk_file, cur_user)
120         salt.utils.win_dacl.set_permissions(
121             sk_file, cur_user, "full_control", "grant", reset_perms=True, protected=True
122         )
123     else:
124         os.chmod(sk_file, 1536)
125     with salt.utils.files.fopen(pk_file, "wb") as keyf:
126         keyf.write(base64.b64encode(kp.pk))
127     return "saved sk_file:{}  pk_file: {}".format(sk_file, pk_file)
128 def enc(data, **kwargs):
129     if "keyfile" in kwargs:
130         kwargs["sk_file"] = kwargs["keyfile"]
131         kwargs["box_type"] = "secretbox"
132     if "key" in kwargs:
133         kwargs["sk"] = kwargs["key"]
134         kwargs["box_type"] = "secretbox"
135     box_type = _get_config(**kwargs)["box_type"]
136     if box_type == "secretbox":
137         return secretbox_encrypt(data, **kwargs)
138     return sealedbox_encrypt(data, **kwargs)
139 def enc_file(name, out=None, **kwargs):
140     try:
141     except Exception as e:  # pylint: disable=broad-except
142         <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(name, "rb") as f:
143             data = salt.utils.stringutils.to_unicode(f.read())
144     d =</b></font> enc(data, **kwargs)
145         if os.path.isfile(out):
146             raise Exception("file:{} already exist.".format(out))
147         <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(out, "wb") as f:
148             f.write(salt.utils.stringutils.to_bytes(</b></font>d))
149         return "Wrote: {}".format(out)
150     return d
151 def dec(data, **kwargs):
152     if "keyfile" in kwargs:
153         kwargs["sk_file"] = kwargs["keyfile"]
154         kwargs["box_type"] = "secretbox"
155     if "key" in kwargs:
156         kwargs["sk"] = kwargs["key"]
157         kwargs["box_type"] = "secretbox"
158     box_type = _get_config(**kwargs)["box_type"]
159     if box_type == "secretbox":
160         return secretbox_decrypt(data, **kwargs)
161     return sealedbox_decrypt(data, **kwargs)
162 def dec_file(name, out=None, **kwargs):
163     try:
164     except Exception as e:  # pylint: disable=broad-except
165         <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>with salt.utils.files.fopen(name, "rb") as f:
166             data = salt.utils.stringutils.to_unicode(f.read(</b></font>))
167     d = dec(data, **kwargs)
168     if out:
169         if os.path.isfile(out):
170             raise Exception("file:{} already exist.".format(out))
171         with salt.utils.files.fopen(out, "wb") as f:
172             f.write(salt.utils.stringutils.to_bytes(d))
173         return "Wrote: {}".format(out)
174     return d
175 def sealedbox_encrypt(data, **kwargs):
176     data = salt.utils.stringutils.to_bytes(data)
177     pk = _get_pk(**kwargs)
178     b = libnacl.sealed.SealedBox(pk)
179     return base64.b64encode(b.encrypt(data))
180 def sealedbox_decrypt(data, **kwargs):
181     if data is None:
182         return None
183     data = salt.utils.stringutils.to_bytes(data)
184     sk = _get_sk(**kwargs)
185     keypair = libnacl.public.SecretKey(sk)
186     b = libnacl.sealed.SealedBox(keypair)
187     return b.decrypt(base64.b64decode(data))
188 def secretbox_encrypt(data, **kwargs):
189     data = salt.utils.stringutils.to_bytes(data)
190     sk = _get_sk(**kwargs)
191     b = libnacl.secret.SecretBox(sk)
192     return base64.b64encode(b.encrypt(data))
193 def secretbox_decrypt(data, **kwargs):
194     if data is None:
195         return None
196     data = salt.utils.stringutils.to_bytes(data)
197     key = _get_sk(**kwargs)
198     b = libnacl.secret.SecretBox(key=key)
199     return b.decrypt(base64.b64decode(data))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>cloud_4.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import codecs
2 import copy
3 import errno
4 import hashlib
5 import logging
6 import multiprocessing
7 import os
8 import pipes
9 import re
10 import shutil
11 import socket
12 import stat
13 import subprocess
14 import tempfile
15 import time
16 import traceback
17 import uuid
18 import salt.client
19 import salt.cloud
20 import salt.config
21 import salt.crypt
22 import salt.loader
23 import salt.template
24 import salt.utils.compat
25 import salt.utils.crypt
26 import salt.utils.data
27 import salt.utils.event
28 import salt.utils.files
29 import salt.utils.msgpack
30 import salt.utils.path
31 import salt.utils.platform
32 import salt.utils.stringutils
33 import salt.utils.versions
34 import salt.utils.vt
35 import salt.utils.yaml
36 from jinja2 import Template
37 from salt.exceptions import (
38     SaltCloudConfigError,
39     SaltCloudException,
40     SaltCloudExecutionFailure,
41     SaltCloudExecutionTimeout,
42     SaltCloudPasswordError,
43     SaltCloudSystemExit,
44 )
45 from salt.utils.nb_popen import NonBlockingPopen
46 from salt.utils.validate.path import is_writeable
47 try:
48     import salt.utils.smb
49     HAS_SMB = True
50 except ImportError:
51     HAS_SMB = False
52 try:
53     from pypsexec.client import Client as PsExecClient
54     from pypsexec.scmr import Service as ScmrService
55     from pypsexec.exceptions import SCMRException
56     from smbprotocol.tree import TreeConnect
57     from smbprotocol.exceptions import SMBResponseException
58     logging.getLogger("smbprotocol").setLevel(logging.WARNING)
59     logging.getLogger("pypsexec").setLevel(logging.WARNING)
60     HAS_PSEXEC = True
61 except ImportError:
62     HAS_PSEXEC = False
63 WINRM_MIN_VER = "0.3.0"
64 try:
65     import winrm
66     from winrm.exceptions import WinRMTransportError
67     import pkg_resources  # pylint: disable=3rd-party-module-not-gated
68     winrm_pkg = pkg_resources.get_distribution("pywinrm")
69     if not salt.utils.versions.compare(winrm_pkg.version, "&gt;=", WINRM_MIN_VER):
70         HAS_WINRM = False
71     else:
72         HAS_WINRM = True
73 except ImportError:
74     HAS_WINRM = False
75 try:
76     import pwd
77 except ImportError:
78     if not salt.utils.platform.is_windows():
79         raise
80 try:
81     import getpass
82     HAS_GETPASS = True
83 except ImportError:
84     HAS_GETPASS = False
85 MSGPACK_ENCODING = "utf-8"
86 NSTATES = {
87     0: "running",
88     1: "rebooting",
89     2: "terminated",
90     3: "pending",
91 }
92 SSH_PASSWORD_PROMP_RE = re.compile(r"(?:.*)[Pp]assword(?: for .*)?:\ *$", re.M)
93 SSH_PASSWORD_PROMP_SUDO_RE = re.compile(
94     r"(?:.*sudo)(?:.*)[Pp]assword(?: for .*)?:", re.M
95 )
96 SERVER_ALIVE_INTERVAL = 60
97 SERVER_ALIVE_COUNT_MAX = 3
98 log = logging.getLogger(__name__)
99 def __render_script(path, vm_=None, opts=None, minion=""):
100     log.info("Rendering deploy script: %s", path)
101     try:
102         with salt.utils.files.fopen(path, "r") as fp_:
103             template = Template(salt.utils.stringutils.to_unicode(fp_.read()))
104             return str(template.render(opts=opts, vm=vm_, minion=minion))
105     except AttributeError:
106         with salt.utils.files.fopen(path, "r") as fp_:
107             return str(fp_.read())
108 def __ssh_gateway_config_dict(gateway):
109     extended_kwargs = {}
110     if gateway:
111         extended_kwargs["ssh_gateway"] = gateway["ssh_gateway"]
112         extended_kwargs["ssh_gateway_key"] = gateway["ssh_gateway_key"]
113         extended_kwargs["ssh_gateway_user"] = gateway["ssh_gateway_user"]
114         extended_kwargs["ssh_gateway_command"] = gateway["ssh_gateway_command"]
115     return extended_kwargs
116 def __ssh_gateway_arguments(kwargs):
117     extended_arguments = ""
118     ssh_gateway = kwargs.get("ssh_gateway", "")
119     ssh_gateway_port = 22
120     if ":" in ssh_gateway:
121         ssh_gateway, ssh_gateway_port = ssh_gateway.split(":")
122     ssh_gateway_command = kwargs.get("ssh_gateway_command", "nc -q0 %h %p")
123     if ssh_gateway:
124         ssh_gateway_port = kwargs.get("ssh_gateway_port", ssh_gateway_port)
125         ssh_gateway_key = (
126             "-i {}".format(kwargs["ssh_gateway_key"])
127             if "ssh_gateway_key" in kwargs
128             else ""
129         )
130         ssh_gateway_user = kwargs.get("ssh_gateway_user", "root")
131         extended_arguments = " ".join(
132             (
133                 "ssh",
134                 "-oStrictHostKeyChecking=no",
135                 "-oServerAliveInterval={}".format(
136                     kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
137                 ),
138                 "-oServerAliveCountMax={}".format(
139                     kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
140                 ),
141                 "-oUserKnownHostsFile=/dev/null",
142                 "-oControlPath=none",
143                 str(ssh_gateway_key),
144                 "{}@{}".format(ssh_gateway_user, ssh_gateway),
145                 "-p",
146                 str(ssh_gateway_port),
147                 str(ssh_gateway_command),
148             )
149         )
150         log.info(
151             "Using SSH gateway %s@%s:%s %s",
152             ssh_gateway_user,
153             ssh_gateway,
154             ssh_gateway_port,
155             ssh_gateway_command,
156         )
157     return extended_arguments
158 def os_script(os_, vm_=None, opts=None, minion=""):
159     if minion:
160         minion = salt_config_to_yaml(minion)
161     if os.path.isabs(os_):
162         return __render_script(os_, vm_, opts, minion)
163     if os.path.isabs("{}.sh".format(os_)):
164         return __render_script("{}.sh".format(os_), vm_, opts, minion)
165     for search_path in opts["deploy_scripts_search_path"]:
166         if os.path.isfile(os.path.join(search_path, os_)):
167             return __render_script(os.path.join(search_path, os_), vm_, opts, minion)
168         if os.path.isfile(os.path.join(search_path, "{}.sh".format(os_))):
169             return __render_script(
170                 os.path.join(search_path, "{}.sh".format(os_)), vm_, opts, minion
171             )
172     return ""
173 def gen_keys(keysize=2048):
174     if keysize &lt; 2048:
175         keysize = 2048
176     tdir = tempfile.mkdtemp()
177     salt.crypt.gen_keys(tdir, "minion", keysize)
178     priv_path = os.path.join(tdir, "minion.pem")
179     with salt.utils.files.fopen(priv_path) as fp_:
180         priv = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
181     <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(pub_path) as fp_:
182         pub = salt.utils.stringutils.to_unicode(fp_.read(</b></font>))
183     shutil.rmtree(tdir)
184     return priv, pub
185 def accept_key(pki_dir, pub, id_):
186     for key_dir in "minions", "minions_pre", "minions_rejected":
187         key_path = os.path.join(pki_dir, key_dir)
188             os.makedirs(key_path)
189     key <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= os.path.join(pki_dir, "minions", id_)
190     with salt.utils.files.fopen(key, "w+") as fp_:
191         fp_.write(salt.</b></font>utils.stringutils.to_str(pub))
192     oldkey = os.path.join(pki_dir, "minions_pre", id_)
193     if os.path.isfile(oldkey):
194         with salt.utils.files.fopen(oldkey) as fp_:
195             if fp_.read() == pub:
196                 os.remove(oldkey)
197 def remove_key(pki_dir, id_):
198     key = os.path.join(pki_dir, "minions", id_)
199     if os.path.isfile(key):
200         os.remove(key)
201         log.debug("Deleted '%s'", key)
202 def rename_key(pki_dir, id_, new_id):
203     oldkey = os.path.join(pki_dir, "minions", id_)
204     newkey = os.path.join(pki_dir, "minions", new_id)
205     if os.path.isfile(oldkey):
206         os.rename(oldkey, newkey)
207 def minion_config(opts, vm_):
208     minion = {
209         "master": "salt",
210         "log_level": "info",
211         "hash_type": "sha256",
212     }
213     minion["id"] = vm_["name"]
214     master_finger = salt.config.get_cloud_config_value("master_finger", vm_, opts)
215     if master_finger is not None:
216         minion["master_finger"] = master_finger
217     minion.update(
218         salt.config.get_cloud_config_value(
219             "minion", vm_, opts, default={}, search_global=True
220         )
221     )
222     make_master = salt.config.get_cloud_config_value("make_master", vm_, opts)
223     if "master" not in minion and make_master is not True:
224         raise SaltCloudConfigError(
225             "A master setting was not defined in the minion's configuration."
226         )
227     minion.setdefault("grains", {}).update(
228         salt.config.get_cloud_config_value(
229             "grains", vm_, opts, default={}, search_global=True
230         )
231     )
232     return minion
233 def master_config(opts, vm_):
234     master = copy.deepcopy(salt.config.DEFAULT_MASTER_OPTS)
235     master.update(log_level="info", log_level_logfile="info", hash_type="sha256")
236     master.update(
237         salt.config.get_cloud_config_value(
238             "master", vm_, opts, default={}, search_global=True
239         )
240     )
241     return master
242 def salt_config_to_yaml(configuration, line_break="\n"):
243     return salt.utils.yaml.safe_dump(
244         configuration, line_break=line_break, default_flow_style=False
245     )
246 def bootstrap(vm_, opts=None):
247     if opts is None:
248         opts = __opts__
249     deploy_config = salt.config.get_cloud_config_value(
250         "deploy", vm_, opts, default=False
251     )
252     inline_script_config = salt.config.get_cloud_config_value(
253         "inline_script", vm_, opts, default=None
254     )
255     if deploy_config is False and inline_script_config is None:
256         return {"Error": {"No Deploy": "'deploy' is not enabled. Not deploying."}}
257     if vm_.get("driver") == "saltify":
258         saltify_driver = True
259     else:
260         saltify_driver = False
261     key_filename = salt.config.get_cloud_config_value(
262         "key_filename",
263         vm_,
264         opts,
265         search_global=False,
266         default=salt.config.get_cloud_config_value(
267             "ssh_keyfile", vm_, opts, search_global=False, default=None
268         ),
269     )
270     if key_filename is not None and not os.path.isfile(key_filename):
271         raise SaltCloudConfigError(
272             "The defined ssh_keyfile '{}' does not exist".format(key_filename)
273         )
274     has_ssh_agent = False
275     if (
276         opts.get("ssh_agent", False)
277         and "SSH_AUTH_SOCK" in os.environ
278         and stat.S_ISSOCK(os.stat(os.environ["SSH_AUTH_SOCK"]).st_mode)
279     ):
280         has_ssh_agent = True
281     if (
282         key_filename is None
283         and salt.config.get_cloud_config_value("password", vm_, opts, default=None)
284         is None
285         and salt.config.get_cloud_config_value("win_password", vm_, opts, default=None)
286         is None
287         and has_ssh_agent is False
288     ):
289         raise SaltCloudSystemExit(
290             "Cannot deploy Salt in a VM if the 'key_filename' setting "
291             "is not set and there is no password set for the VM. "
292             "Check the provider docs for 'change_password' option if it "
293             "is supported by your provider."
294         )
295     ret = {}
296     minion_conf = minion_config(opts, vm_)
297     deploy_script_code = os_script(
298         salt.config.get_cloud_config_value("os", vm_, opts, default="bootstrap-salt"),
299         vm_,
300         opts,
301         minion_conf,
302     )
303     ssh_username = salt.config.get_cloud_config_value(
304         "ssh_username", vm_, opts, default="root"
305     )
306     if "file_transport" not in opts:
307         opts["file_transport"] = vm_.get("file_transport", "sftp")
308     if "pub_key" not in vm_ and "priv_key" not in vm_:
309         log.debug("Generating keys for '%s'", vm_["name"])
310         vm_["priv_key"], vm_["pub_key"] = gen_keys(
311             salt.config.get_cloud_config_value("keysize", vm_, opts)
312         )
313         key_id = vm_.get("name")
314         if "append_domain" in vm_:
315             key_id = ".".join([key_id, vm_["append_domain"]])
316         accept_key(opts["pki_dir"], vm_["pub_key"], key_id)
317     if "os" not in vm_:
318         vm_["os"] = salt.config.get_cloud_config_value("script", vm_, opts)
319     host = salt.config.get_cloud_config_value("ssh_host", vm_, opts)
320     deploy_kwargs = {
321         "opts": opts,
322         "host": host,
323         "port": salt.config.get_cloud_config_value("ssh_port", vm_, opts, default=22),
324         "salt_host": vm_.get("salt_host", host),
325         "username": ssh_username,
326         "script": deploy_script_code,
327         "inline_script": inline_script_config,
328         "name": vm_["name"],
329         "has_ssh_agent": has_ssh_agent,
330         "tmp_dir": salt.config.get_cloud_config_value(
331             "tmp_dir", vm_, opts, default="/tmp/.saltcloud"
332         ),
333         "vm_": vm_,
334         "start_action": opts["start_action"],
335         "parallel": opts["parallel"],
336         "sock_dir": opts["sock_dir"],
337         "conf_file": opts["conf_file"],
338         "minion_pem": vm_["priv_key"],
339         "minion_pub": vm_["pub_key"],
340         "master_sign_pub_file": salt.config.get_cloud_config_value(
341             "master_sign_pub_file", vm_, opts, default=None
342         ),
343         "keep_tmp": opts["keep_tmp"],
344         "sudo": salt.config.get_cloud_config_value(
345             "sudo", vm_, opts, default=(ssh_username != "root")
346         ),
347         "sudo_password": salt.config.get_cloud_config_value(
348             "sudo_password", vm_, opts, default=None
349         ),
350         "tty": salt.config.get_cloud_config_value("tty", vm_, opts, default=True),
351         "password": salt.config.get_cloud_config_value(
352             "password", vm_, opts, search_global=False
353         ),
354         "key_filename": key_filename,
355         "script_args": salt.config.get_cloud_config_value("script_args", vm_, opts),
356         "script_env": salt.config.get_cloud_config_value("script_env", vm_, opts),
357         "minion_conf": minion_conf,
358         "force_minion_config": salt.config.get_cloud_config_value(
359             "force_minion_config", vm_, opts, default=False
360         ),
361         "preseed_minion_keys": vm_.get("preseed_minion_keys", None),
362         "display_ssh_output": salt.config.get_cloud_config_value(
363             "display_ssh_output", vm_, opts, default=True
364         ),
365         "known_hosts_file": salt.config.get_cloud_config_value(
366             "known_hosts_file", vm_, opts, default="/dev/null"
367         ),
368         "file_map": salt.config.get_cloud_config_value(
369             "file_map", vm_, opts, default=None
370         ),
371         "maxtries": salt.config.get_cloud_config_value(
372             "wait_for_passwd_maxtries", vm_, opts, default=15
373         ),
374         "preflight_cmds": salt.config.get_cloud_config_value(
375             "preflight_cmds", vm_, opts, default=[]
376         ),
377         "cloud_grains": {
378             "driver": vm_["driver"],
379             "provider": vm_["provider"],
380             "profile": vm_["profile"],
381         },
382     }
383     inline_script_kwargs = deploy_kwargs.copy()  # make a copy at this point
384     if "gateway" in vm_:
385         deploy_kwargs.update({"gateway": vm_["gateway"]})
386     if salt.config.get_cloud_config_value("make_master", vm_, opts) is True:
387         deploy_kwargs["make_master"] = True
388         deploy_kwargs["master_pub"] = vm_["master_pub"]
389         deploy_kwargs["master_pem"] = vm_["master_pem"]
390         master_conf = master_config(opts, vm_)
391         deploy_kwargs["master_conf"] = master_conf
392         if master_conf.get("syndic_master", None):
393             deploy_kwargs["make_syndic"] = True
394     deploy_kwargs["make_minion"] = salt.config.get_cloud_config_value(
395         "make_minion", vm_, opts, default=True
396     )
397     if saltify_driver:
398         deploy_kwargs[
399             "wait_for_passwd_maxtries"
400         ] = 0  # No need to wait/retry with Saltify
401     win_installer = salt.config.get_cloud_config_value("win_installer", vm_, opts)
402     if win_installer:
403         deploy_kwargs["port"] = salt.config.get_cloud_config_value(
404             "smb_port", vm_, opts, default=445
405         )
406         deploy_kwargs["win_installer"] = win_installer
407         minion = minion_config(opts, vm_)
408         deploy_kwargs["master"] = minion["master"]
409         deploy_kwargs["username"] = salt.config.get_cloud_config_value(
410             "win_username", vm_, opts, default="Administrator"
411         )
412         win_pass = salt.config.get_cloud_config_value(
413             "win_password", vm_, opts, default=""
414         )
415         if win_pass:
416             deploy_kwargs["password"] = win_pass
417         deploy_kwargs["use_winrm"] = salt.config.get_cloud_config_value(
418             "use_winrm", vm_, opts, default=False
419         )
420         deploy_kwargs["winrm_port"] = salt.config.get_cloud_config_value(
421             "winrm_port", vm_, opts, default=5986
422         )
423         deploy_kwargs["winrm_use_ssl"] = salt.config.get_cloud_config_value(
424             "winrm_use_ssl", vm_, opts, default=True
425         )
426         deploy_kwargs["winrm_verify_ssl"] = salt.config.get_cloud_config_value(
427             "winrm_verify_ssl", vm_, opts, default=True
428         )
429         if saltify_driver:
430             deploy_kwargs["port_timeout"] = 1  # No need to wait/retry with Saltify
431     event_kwargs = copy.deepcopy(deploy_kwargs)
432     del event_kwargs["opts"]
433     del event_kwargs["minion_pem"]
434     del event_kwargs["minion_pub"]
435     del event_kwargs["sudo_password"]
436     if "password" in event_kwargs:
437         del event_kwargs["password"]
438     ret["deploy_kwargs"] = event_kwargs
439     fire_event(
440         "event",
441         "executing deploy script",
442         "salt/cloud/{}/deploying".format(vm_["name"]),
443         args={"kwargs": salt.utils.data.simple_types_filter(event_kwargs)},
444         sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
445         transport=opts.get("transport", "zeromq"),
446     )
447     if inline_script_config and deploy_config is False:
448         inline_script_deployed = run_inline_script(**inline_script_kwargs)
449         if inline_script_deployed is not False:
450             log.info("Inline script(s) ha(s|ve) run on %s", vm_["name"])
451         ret["deployed"] = False
452         return ret
453     else:
454         if win_installer:
455             deployed = deploy_windows(**deploy_kwargs)
456         else:
457             deployed = deploy_script(**deploy_kwargs)
458         if inline_script_config:
459             inline_script_deployed = run_inline_script(**inline_script_kwargs)
460             if inline_script_deployed is not False:
461                 log.info("Inline script(s) ha(s|ve) run on %s", vm_["name"])
462         if deployed is not False:
463             ret["deployed"] = True
464             if deployed is not True:
465                 ret.update(deployed)
466             log.info("Salt installed on %s", vm_["name"])
467             return ret
468     log.error("Failed to start Salt on host %s", vm_["name"])
469     return {
470         "Error": {"Not Deployed": "Failed to start Salt on host {}".format(vm_["name"])}
471     }
472 def ssh_usernames(vm_, opts, default_users=None):
473     if default_users is None:
474         default_users = ["root"]
475     usernames = salt.config.get_cloud_config_value("ssh_username", vm_, opts)
476     if not isinstance(usernames, list):
477         usernames = [usernames]
478     usernames = [x for x in usernames if x]
479     initial = usernames[:]
480     for name in default_users:
481         if name not in usernames:
482             usernames.append(name)
483     usernames.extend(initial)
484     return usernames
485 def wait_for_fun(fun, timeout=900, **kwargs):
486     start = time.time()
487     log.debug("Attempting function %s", fun)
488     trycount = 0
489     while True:
490         trycount += 1
491         try:
492             response = fun(**kwargs)
493             if not isinstance(response, bool):
494                 return response
495         except Exception as exc:  # pylint: disable=broad-except
496             log.debug("Caught exception in wait_for_fun: %s", exc)
497             time.sleep(1)
498             log.debug("Retrying function %s on  (try %s)", fun, trycount)
499         if time.time() - start &gt; timeout:
500             log.error("Function timed out: %s", timeout)
501             return False
502 def wait_for_port(
503     host,
504     port=22,
505     timeout=900,
506     gateway=None,
507     server_alive_interval=SERVER_ALIVE_INTERVAL,
508     server_alive_count_max=SERVER_ALIVE_COUNT_MAX,
509 ):
510     start = time.time()
511     test_ssh_host = host
512     test_ssh_port = port
513     if gateway:
514         ssh_gateway = gateway["ssh_gateway"]
515         ssh_gateway_port = 22
516         if ":" in ssh_gateway:
517             ssh_gateway, ssh_gateway_port = ssh_gateway.split(":")
518         if "ssh_gateway_port" in gateway:
519             ssh_gateway_port = gateway["ssh_gateway_port"]
520         test_ssh_host = ssh_gateway
521         test_ssh_port = ssh_gateway_port
522         log.debug(
523             "Attempting connection to host %s on port %s via gateway %s on port %s",
524             host,
525             port,
526             ssh_gateway,
527             ssh_gateway_port,
528         )
529     else:
530         log.debug("Attempting connection to host %s on port %s", host, port)
531     trycount = 0
532     while True:
533         trycount += 1
534         try:
535             if socket.inet_pton(socket.AF_INET6, host):
536                 sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
537             else:
538                 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
539         except OSError:
540             sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
541         try:
542             sock.settimeout(5)
543             sock.connect((test_ssh_host, int(test_ssh_port)))
544             sock.shutdown(socket.SHUT_RDWR)
545             sock.close()
546             break
547         except OSError as exc:
548             log.debug("Caught exception in wait_for_port: %s", exc)
549             time.sleep(1)
550             if time.time() - start &gt; timeout:
551                 log.error("Port connection timed out: %s", timeout)
552                 return False
553             log.debug(
554                 "Retrying connection to %s %s on port %s (try %s)",
555                 "gateway" if gateway else "host",
556                 test_ssh_host,
557                 test_ssh_port,
558                 trycount,
559             )
560     if not gateway:
561         return True
562     log.debug("Gateway %s on port %s is reachable.", test_ssh_host, test_ssh_port)
563     ssh_args = []
564     ssh_args.extend(
565         [
566             "-oStrictHostKeyChecking=no",
567             "-oServerAliveInterval={}".format(server_alive_interval),
568             "-oServerAliveCountMax={}".format(server_alive_count_max),
569             "-oUserKnownHostsFile=/dev/null",
570             "-oControlPath=none",
571         ]
572     )
573     if "ssh_gateway_key" in gateway:
574         ssh_args.extend(
575             [
576                 "-oPasswordAuthentication=no",
577                 "-oChallengeResponseAuthentication=no",
578                 "-oPubkeyAuthentication=yes",
579                 "-oIdentitiesOnly=yes",
580                 "-oKbdInteractiveAuthentication=no",
581                 "-i {}".format(gateway["ssh_gateway_key"]),
582             ]
583         )
584     command = "nc -z -w5 -q0 {} {}".format(host, port)
585     pcmd = "ssh {} {}@{} -p {} {}".format(
586         " ".join(ssh_args),
587         gateway["ssh_gateway_user"],
588         ssh_gateway,
589         ssh_gateway_port,
590         pipes.quote("date"),
591     )
592     cmd = "ssh {} {}@{} -p {} {}".format(
593         " ".join(ssh_args),
594         gateway["ssh_gateway_user"],
595         ssh_gateway,
596         ssh_gateway_port,
597         pipes.quote(command),
598     )
599     log.debug("SSH command: '%s'", cmd)
600     kwargs = {
601         "display_ssh_output": False,
602         "password": gateway.get("ssh_gateway_password", None),
603     }
604     trycount = 0
605     usable_gateway = False
606     gateway_retries = 5
607     while True:
608         trycount += 1
609         if not usable_gateway:
610             pstatus = _exec_ssh_cmd(pcmd, allow_failure=True, **kwargs)
611             if pstatus == 0:
612                 usable_gateway = True
613             else:
614                 gateway_retries -= 1
615                 log.error(
616                     "Gateway usage seems to be broken, password error ? Tries left: %s",
617                     gateway_retries,
618                 )
619             if not gateway_retries:
620                 raise SaltCloudExecutionFailure(
621                     "SSH gateway is reachable but we can not login"
622                 )
623         if usable_gateway:
624             status = _exec_ssh_cmd(cmd, allow_failure=True, **kwargs)
625             if status == 0:
626                 return True
627         time.sleep(1)
628         if time.time() - start &gt; timeout:
629             log.error("Port connection timed out: %s", timeout)
630             return False
631         log.debug(
632             "Retrying connection to host %s on port %s "
633             "via gateway %s on port %s. (try %s)",
634             host,
635             port,
636             ssh_gateway,
637             ssh_gateway_port,
638             trycount,
639         )
640 class Client:
641     def __init__(
642         self,
643         server,
644         username=None,
645         password=None,
646         port=445,
647         encrypt=True,
648         service_name=None,
649     ):
650         self.service_name = service_name
651         self._exe_file = "{}.exe".format(self.service_name)
652         self._client = PsExecClient(server, username, password, port, encrypt)
653         self._client._service = ScmrService(self.service_name, self._client.session)
654     def connect(self):
655         return self._client.connect()
656     def disconnect(self):
657         return self._client.disconnect()
658     def create_service(self):
659         return self._client.create_service()
660     def run_executable(self, *args, **kwargs):
661         return self._client.run_executable(*args, **kwargs)
662     def remove_service(self, wait_timeout=10, sleep_wait=1):
663         log.debug("Deleting PAExec service at the end of the process")
664         wait_start = time.time()
665         while True:
666             try:
667                 self._client._service.delete()
668             except SCMRException as exc:
669                 log.debug("Exception encountered while deleting service %s", repr(exc))
670                 if time.time() - wait_start &gt; wait_timeout:
671                     raise exc
672                 time.sleep(sleep_wait)
673                 continue
674             break
675         smb_tree = TreeConnect(
676             self._client.session,
677             r"\\{}\ADMIN$".format(self._client.connection.server_name),
678         )
679         log.info("Connecting to SMB Tree %s", smb_tree.share_name)
680         smb_tree.connect()
681         wait_start = time.time()
682         while True:
683             try:
684                 log.info("Creating open to PAExec file with delete on close flags")
685                 self._client._delete_file(smb_tree, self._exe_file)
686             except SMBResponseException as exc:
687                 log.debug("Exception deleting file %s %s", self._exe_file, repr(exc))
688                 if time.time() - wait_start &gt; wait_timeout:
689                     raise exc
690                 time.sleep(sleep_wait)
691                 continue
692             break
693         log.info("Disconnecting from SMB Tree %s", smb_tree.share_name)
694         smb_tree.disconnect()
695 def run_winexe_command(cmd, args, host, username, password, port=445):
696     creds = "-U '{}%{}' //{}".format(username, password, host)
697     logging_creds = "-U '{}%XXX-REDACTED-XXX' //{}".format(username, host)
698     cmd = "winexe {} {} {}".format(creds, cmd, args)
699     logging_cmd = "winexe {} {} {}".format(logging_creds, cmd, args)
700     return win_cmd(cmd, logging_command=logging_cmd)
701 def run_psexec_command(cmd, args, host, username, password, port=445):
702     service_name = "PS-Exec-{}".format(uuid.uuid4())
703     stdout, stderr, ret_code = "", "", None
704     client = Client(
705         host, username, password, port=port, encrypt=False, service_name=service_name
706     )
707     client.connect()
708     try:
709         client.create_service()
710         stdout, stderr, ret_code = client.run_executable(cmd, args)
711     finally:
712         client.remove_service()
713         client.disconnect()
714     return stdout, stderr, ret_code
715 def wait_for_winexe(host, port, username, password, timeout=900):
716     start = time.time()
717     log.debug("Attempting winexe connection to host %s on port %s", host, port)
718     try_count = 0
719     while True:
720         try_count += 1
721         try:
722             ret_code = run_winexe_command(
723                 "sc", "query winexesvc", host, username, password, port
724             )
725             if ret_code == 0:
726                 log.debug("winexe connected...")
727                 return True
728             log.debug("Return code was %s", ret_code)
729         except OSError as exc:
730             log.debug("Caught exception in wait_for_winexesvc: %s", exc)
731         if time.time() - start &gt; timeout:
732             return False
733         time.sleep(1)
734 def wait_for_psexecsvc(host, port, username, password, timeout=900):
735     start = time.time()
736     try_count = 0
737     while True:
738         try_count += 1
739         ret_code = 1
740         try:
741             stdout, stderr, ret_code = run_psexec_command(
742                 "cmd.exe", "/c hostname", host, username, password, port=port
743             )
744         except Exception as exc:  # pylint: disable=broad-except
745             log.exception("Unable to execute command")
746         if ret_code == 0:
747             log.debug("psexec connected...")
748             return True
749         if time.time() - start &gt; timeout:
750             return False
751         log.debug(
752             "Retrying psexec connection to host %s on port %s (try %s)",
753             host,
754             port,
755             try_count,
756         )
757         time.sleep(1)
758 def wait_for_winrm(
759     host, port, username, password, timeout=900, use_ssl=True, verify=True
760 ):
761     wait_for_port(host=host, port=port, timeout=timeout)
762     start = time.time()
763     log.debug("Attempting WinRM connection to host %s on port %s", host, port)
764     transport = "ssl"
765     if not use_ssl:
766         transport = "ntlm"
767     trycount = 0
768     while True:
769         trycount += 1
770         try:
771             winrm_kwargs = {
772                 "target": host,
773                 "auth": (username, password),
774                 "transport": transport,
775             }
776             if not verify:
777                 log.debug("SSL validation for WinRM disabled.")
778                 winrm_kwargs["server_cert_validation"] = "ignore"
779             s = winrm.Session(**winrm_kwargs)
780             if hasattr(s.protocol, "set_timeout"):
781                 s.protocol.set_timeout(15)
782             log.trace("WinRM endpoint url: %s", s.url)
783             r = s.run_cmd("sc query winrm")
784             if r.status_code == 0:
785                 log.debug("WinRM session connected...")
786                 return s
787             log.debug("Return code was %s", r.status_code)
788         except WinRMTransportError as exc:
789             log.debug("Caught exception in wait_for_winrm: %s", exc)
790         if time.time() - start &gt; timeout:
791             log.error("WinRM connection timed out: %s", timeout)
792             return None
793         log.debug(
794             "Retrying WinRM connection to host %s on port %s (try %s)",
795             host,
796             port,
797             trycount,
798         )
799         time.sleep(1)
800 def validate_windows_cred_winexe(
801     host, username="Administrator", password=None, retries=10, retry_delay=1
802 ):
803     cmd = "winexe -U '{}%{}' //{} \"hostname\"".format(username, password, host)
804     logging_cmd = "winexe -U '{}%XXX-REDACTED-XXX' //{} \"hostname\"".format(
805         username, host
806     )
807     for i in range(retries):
808         ret_code = win_cmd(cmd, logging_command=logging_cmd)
809     return ret_code == 0
810 def validate_windows_cred(
811     host, username="Administrator", password=None, retries=10, retry_delay=1
812 ):
813     for i in range(retries):
814         ret_code = 1
815         try:
816             stdout, stderr, ret_code = run_psexec_command(
817                 "cmd.exe", "/c hostname", host, username, password, port=445
818             )
819         except Exception as exc:  # pylint: disable=broad-except
820             log.exception("Exceoption while executing psexec")
821         if ret_code == 0:
822             break
823         time.sleep(retry_delay)
824     return ret_code == 0
825 def wait_for_passwd(
826     host,
827     port=22,
828     ssh_timeout=15,
829     username="root",
830     password=None,
831     key_filename=None,
832     maxtries=15,
833     trysleep=1,
834     display_ssh_output=True,
835     gateway=None,
836     known_hosts_file="/dev/null",
837     hard_timeout=None,
838 ):
839     trycount = 0
840     while trycount &lt; maxtries:
841         connectfail = False
842         try:
843             kwargs = {
844                 "hostname": host,
845                 "port": port,
846                 "username": username,
847                 "password_retries": maxtries,
848                 "timeout": ssh_timeout,
849                 "display_ssh_output": display_ssh_output,
850                 "known_hosts_file": known_hosts_file,
851                 "ssh_timeout": ssh_timeout,
852                 "hard_timeout": hard_timeout,
853             }
854             kwargs.update(__ssh_gateway_config_dict(gateway))
855             if key_filename:
856                 if not os.path.isfile(key_filename):
857                     raise SaltCloudConfigError(
858                         "The defined key_filename '{}' does not exist".format(
859                             key_filename
860                         )
861                     )
862                 kwargs["key_filename"] = key_filename
863                 log.debug("Using %s as the key_filename", key_filename)
864             elif password:
865                 kwargs["password"] = password
866                 log.debug("Using password authentication")
867             trycount += 1
868             log.debug(
869                 "Attempting to authenticate as %s (try %s of %s)",
870                 username,
871                 trycount,
872                 maxtries,
873             )
874             status = root_cmd("date", tty=False, sudo=False, **kwargs)
875             if status != 0:
876                 connectfail = True
877                 if trycount &lt; maxtries:
878                     time.sleep(trysleep)
879                     continue
880                 log.error("Authentication failed: status code %s", status)
881                 return False
882             if connectfail is False:
883                 return True
884             return False
885         except SaltCloudPasswordError:
886             raise
887         except Exception:  # pylint: disable=broad-except
888             if trycount &gt;= maxtries:
889                 return False
890             time.sleep(trysleep)
891 def deploy_windows(
892     host,
893     port=445,
894     timeout=900,
895     username="Administrator",
896     password=None,
897     name=None,
898     sock_dir=None,
899     conf_file=None,
900     start_action=None,
901     parallel=False,
902     minion_pub=None,
903     minion_pem=None,
904     minion_conf=None,
905     keep_tmp=False,
906     script_args=None,
907     script_env=None,
908     port_timeout=15,
909     preseed_minion_keys=None,
910     win_installer=None,
911     master=None,
912     tmp_dir="C:\\salttmp",
913     opts=None,
914     master_sign_pub_file=None,
915     use_winrm=False,
916     winrm_port=5986,
917     winrm_use_ssl=True,
918     winrm_verify_ssl=True,
919     **kwargs
920 ):
921     if not isinstance(opts, dict):
922         opts = {}
923     if use_winrm and not HAS_WINRM:
924         log.error(
925             "WinRM requested but module winrm could not be imported. "
926             "Ensure you are using version %s or higher.",
927             WINRM_MIN_VER,
928         )
929         return False
930     starttime = time.mktime(time.localtime())
931     log.debug("Deploying %s at %s (Windows)", host, starttime)
932     log.trace("HAS_WINRM: %s, use_winrm: %s", HAS_WINRM, use_winrm)
933     port_available = wait_for_port(host=host, port=port, timeout=port_timeout * 60)
934     if not port_available:
935         return False
936     service_available = False
937     winrm_session = None
938     if HAS_WINRM and use_winrm:
939         winrm_session = wait_for_winrm(
940             host=host,
941             port=winrm_port,
942             username=username,
943             password=password,
944             timeout=port_timeout * 60,
945             use_ssl=winrm_use_ssl,
946             verify=winrm_verify_ssl,
947         )
948         if winrm_session is not None:
949             service_available = True
950     else:
951         service_available = wait_for_psexecsvc(
952             host=host,
953             port=port,
954             username=username,
955             password=password,
956             timeout=port_timeout * 60,
957         )
958     if port_available and service_available:
959         log.debug("SMB port %s on %s is available", port, host)
960         log.debug("Logging into %s:%s as %s", host, port, username)
961         smb_conn = salt.utils.smb.get_conn(host, username, password, port)
962         if smb_conn is False:
963             log.error("Please install smbprotocol to enable SMB functionality")
964             return False
965         salt.utils.smb.mkdirs("salttemp", conn=smb_conn)
966         salt.utils.smb.mkdirs("salt/conf/pki/minion", conn=smb_conn)
967         if minion_pub:
968             salt.utils.smb.put_str(
969                 minion_pub, "salt\\conf\\pki\\minion\\minion.pub", conn=smb_conn
970             )
971         if minion_pem:
972             salt.utils.smb.put_str(
973                 minion_pem, "salt\\conf\\pki\\minion\\minion.pem", conn=smb_conn
974             )
975         if master_sign_pub_file:
976             log.debug(
977                 "Copying master_sign.pub file from %s to minion", master_sign_pub_file
978             )
979             try:
980                 salt.utils.smb.put_file(
981                     master_sign_pub_file,
982                     "salt\\conf\\pki\\minion\\master_sign.pub",
983                     "C$",
984                     conn=smb_conn,
985                 )
986             except Exception as e:  # pylint: disable=broad-except
987                 log.debug(
988                     "Exception copying master_sign.pub file %s to minion",
989                     master_sign_pub_file,
990                 )
991         comps = win_installer.split("/")
992         local_path = "/".join(comps[:-1])
993         installer = comps[-1]
994         salt.utils.smb.put_file(
995             win_installer,
996             "salttemp\\{}".format(installer),
997             "C$",
998             conn=smb_conn,
999         )
1000         if use_winrm:
1001             winrm_cmd(
1002                 winrm_session,
1003                 "c:\\salttemp\\{}".format(installer),
1004                 ["/S", "/master={}".format(master), "/minion-name={}".format(name)],
1005             )
1006         else:
1007             cmd = "c:\\salttemp\\{}".format(installer)
1008             args = "/S /master={} /minion-name={}".format(master, name)
1009             stdout, stderr, ret_code = run_psexec_command(
1010                 cmd, args, host, username, password
1011             )
1012             if ret_code != 0:
1013                 raise Exception("Fail installer {}".format(ret_code))
1014         if minion_conf:
1015             if not isinstance(minion_conf, dict):
1016                 raise DeprecationWarning(
1017                     "`salt.utils.cloud.deploy_windows` now only accepts "
1018                     "dictionaries for its `minion_conf` parameter. "
1019                     "Loading YAML..."
1020                 )
1021             minion_grains = minion_conf.pop("grains", {})
1022             if minion_grains:
1023                 salt.utils.smb.put_str(
1024                     salt_config_to_yaml(minion_grains, line_break="\r\n"),
1025                     "salt\\conf\\grains",
1026                     conn=smb_conn,
1027                 )
1028             windows_minion_conf = {
1029                 "ipc_mode": "tcp",
1030                 "root_dir": "c:\\salt",
1031                 "pki_dir": "/conf/pki/minion",
1032                 "multiprocessing": False,
1033             }
1034             minion_conf = dict(minion_conf, **windows_minion_conf)
1035             salt.utils.smb.put_str(
1036                 salt_config_to_yaml(minion_conf, line_break="\r\n"),
1037                 "salt\\conf\\minion",
1038                 conn=smb_conn,
1039             )
1040         if not keep_tmp:
1041             if use_winrm:
1042                 winrm_cmd(winrm_session, "rmdir", ["/Q", "/S", "C:\\salttemp\\"])
1043             else:
1044                 salt.utils.smb.delete_file(
1045                     "salttemp\\{}".format(installer), "C$", conn=smb_conn
1046                 )
1047                 salt.utils.smb.delete_directory("salttemp", "C$", conn=smb_conn)
1048         if use_winrm:
1049             winrm_cmd(winrm_session, "net", ["stop", "salt-minion"])
1050             winrm_cmd(winrm_session, "net", ["start", "salt-minion"])
1051         else:
1052             stdout, stderr, ret_code = run_psexec_command(
1053                 "cmd.exe", "/c net stop salt-minion", host, username, password
1054             )
1055             if ret_code != 0:
1056                 return False
1057             log.debug("Run psexec: sc start salt-minion")
1058             stdout, stderr, ret_code = run_psexec_command(
1059                 "cmd.exe", "/c net start salt-minion", host, username, password
1060             )
1061             if ret_code != 0:
1062                 return False
1063         fire_event(
1064             "event",
1065             "{} has been deployed at {}".format(name, host),
1066             "salt/cloud/{}/deploy_windows".format(name),
1067             args={"name": name},
1068             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
1069             transport=opts.get("transport", "zeromq"),
1070         )
1071         return True
1072     return False
1073 def deploy_script(
1074     host,
1075     port=22,
1076     timeout=900,
1077     username="root",
1078     password=None,
1079     key_filename=None,
1080     script=None,
1081     name=None,
1082     sock_dir=None,
1083     provider=None,
1084     conf_file=None,
1085     start_action=None,
1086     make_master=False,
1087     master_pub=None,
1088     master_pem=None,
1089     master_conf=None,
1090     minion_pub=None,
1091     minion_pem=None,
1092     minion_conf=None,
1093     keep_tmp=False,
1094     script_args=None,
1095     script_env=None,
1096     ssh_timeout=15,
1097     maxtries=15,
1098     make_syndic=False,
1099     make_minion=True,
1100     display_ssh_output=True,
1101     preseed_minion_keys=None,
1102     parallel=False,
1103     sudo_password=None,
1104     sudo=False,
1105     tty=None,
1106     vm_=None,
1107     opts=None,
1108     tmp_dir="/tmp/.saltcloud",
1109     file_map=None,
1110     master_sign_pub_file=None,
1111     cloud_grains=None,
1112     force_minion_config=False,
1113     **kwargs
1114 ):
1115     if not isinstance(opts, dict):
1116         opts = {}
1117     vm_ = vm_ or {}  # if None, default to empty dict
1118     cloud_grains = cloud_grains or {}
1119     tmp_dir = "{}-{}".format(tmp_dir.rstrip("/"), uuid.uuid4())
1120     deploy_command = salt.config.get_cloud_config_value(
1121         "deploy_command", vm_, opts, default=os.path.join(tmp_dir, "deploy.sh")
1122     )
1123     if key_filename is not None and not os.path.isfile(key_filename):
1124         raise SaltCloudConfigError(
1125             "The defined key_filename '{}' does not exist".format(key_filename)
1126         )
1127     gateway = None
1128     if "gateway" in kwargs:
1129         gateway = kwargs["gateway"]
1130     starttime = time.localtime()
1131     log.debug("Deploying %s at %s", host, time.strftime("%Y-%m-%d %H:%M:%S", starttime))
1132     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1133     hard_timeout = opts.get("hard_timeout", None)
1134     if wait_for_port(host=host, port=port, gateway=gateway):
1135         log.debug("SSH port %s on %s is available", port, host)
1136         if wait_for_passwd(
1137             host,
1138             port=port,
1139             username=username,
1140             password=password,
1141             key_filename=key_filename,
1142             ssh_timeout=ssh_timeout,
1143             display_ssh_output=display_ssh_output,
1144             gateway=gateway,
1145             known_hosts_file=known_hosts_file,
1146             maxtries=maxtries,
1147             hard_timeout=hard_timeout,
1148         ):
1149             log.debug("Logging into %s:%s as %s", host, port, username)
1150             ssh_kwargs = {
1151                 "hostname": host,
1152                 "port": port,
1153                 "username": username,
1154                 "timeout": ssh_timeout,
1155                 "ssh_timeout": ssh_timeout,
1156                 "display_ssh_output": display_ssh_output,
1157                 "sudo_password": sudo_password,
1158                 "sftp": opts.get("use_sftp", False),
1159             }
1160             ssh_kwargs.update(__ssh_gateway_config_dict(gateway))
1161             if key_filename:
1162                 log.debug("Using %s as the key_filename", key_filename)
1163                 ssh_kwargs["key_filename"] = key_filename
1164             elif password and kwargs.get("has_ssh_agent", False) is False:
1165                 ssh_kwargs["password"] = password
1166             if root_cmd(
1167                 "test -e '{}'".format(tmp_dir),
1168                 tty,
1169                 sudo,
1170                 allow_failure=True,
1171                 **ssh_kwargs
1172             ):
1173                 ret = root_cmd(
1174                     "sh -c \"( mkdir -p -m 700 '{}' )\"".format(tmp_dir),
1175                     tty,
1176                     sudo,
1177                     **ssh_kwargs
1178                 )
1179                 if ret:
1180                     raise SaltCloudSystemExit(
1181                         "Can't create temporary directory in {} !".format(tmp_dir)
1182                     )
1183             if sudo:
1184                 comps = tmp_dir.lstrip("/").rstrip("/").split("/")
1185                 if comps:
1186                     if len(comps) &gt; 1 or comps[0] != "tmp":
1187                         ret = root_cmd(
1188                             'chown {} "{}"'.format(username, tmp_dir),
1189                             tty,
1190                             sudo,
1191                             **ssh_kwargs
1192                         )
1193                         if ret:
1194                             raise SaltCloudSystemExit(
1195                                 "Cant set {} ownership on {}".format(username, tmp_dir)
1196                             )
1197             if not isinstance(file_map, dict):
1198                 file_map = {}
1199             remote_dirs = []
1200             file_map_success = []
1201             file_map_fail = []
1202             for map_item in file_map:
1203                 local_file = map_item
1204                 remote_file = file_map[map_item]
1205                 if not os.path.exists(map_item):
1206                     log.error(
1207                         'The local file "%s" does not exist, and will not be '
1208                         'copied to "%s" on the target system',
1209                         local_file,
1210                         remote_file,
1211                     )
1212                     file_map_fail.append({local_file: remote_file})
1213                     continue
1214                 if os.path.isdir(local_file):
1215                     dir_name = os.path.basename(local_file)
1216                     remote_dir = os.path.join(os.path.dirname(remote_file), dir_name)
1217                 else:
1218                     remote_dir = os.path.dirname(remote_file)
1219                 if remote_dir not in remote_dirs:
1220                     root_cmd(
1221                         "mkdir -p '{}'".format(remote_dir), tty, sudo, **ssh_kwargs
1222                     )
1223                     if ssh_kwargs["username"] != "root":
1224                         root_cmd(
1225                             "chown {} '{}'".format(ssh_kwargs["username"], remote_dir),
1226                             tty,
1227                             sudo,
1228                             **ssh_kwargs
1229                         )
1230                     remote_dirs.append(remote_dir)
1231                 ssh_file(opts, remote_file, kwargs=ssh_kwargs, local_file=local_file)
1232                 file_map_success.append({local_file: remote_file})
1233             if minion_pem:
1234                 ssh_file(opts, "{}/minion.pem".format(tmp_dir), minion_pem, ssh_kwargs)
1235                 ret = root_cmd(
1236                     "chmod 600 '{}/minion.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1237                 )
1238                 if ret:
1239                     raise SaltCloudSystemExit(
1240                         "Can't set perms on {}/minion.pem".format(tmp_dir)
1241                     )
1242             if minion_pub:
1243                 ssh_file(opts, "{}/minion.pub".format(tmp_dir), minion_pub, ssh_kwargs)
1244             if master_sign_pub_file:
1245                 ssh_file(
1246                     opts,
1247                     "{}/master_sign.pub".format(tmp_dir),
1248                     kwargs=ssh_kwargs,
1249                     local_file=master_sign_pub_file,
1250                 )
1251             if minion_conf:
1252                 if not isinstance(minion_conf, dict):
1253                     raise DeprecationWarning(
1254                         "`salt.utils.cloud.deploy_script now only accepts "
1255                         "dictionaries for it's `minion_conf` parameter. "
1256                         "Loading YAML..."
1257                     )
1258                 minion_grains = minion_conf.pop("grains", {})
1259                 if minion_grains:
1260                     ssh_file(
1261                         opts,
1262                         "{}/grains".format(tmp_dir),
1263                         salt_config_to_yaml(minion_grains),
1264                         ssh_kwargs,
1265                     )
1266                 if cloud_grains and opts.get("enable_cloud_grains", True):
1267                     minion_conf["grains"] = {"salt-cloud": cloud_grains}
1268                 ssh_file(
1269                     opts,
1270                     "{}/minion".format(tmp_dir),
1271                     salt_config_to_yaml(minion_conf),
1272                     ssh_kwargs,
1273                 )
1274             if master_pem:
1275                 ssh_file(opts, "{}/master.pem".format(tmp_dir), master_pem, ssh_kwargs)
1276                 ret = root_cmd(
1277                     "chmod 600 '{}/master.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1278                 )
1279                 if ret:
1280                     raise SaltCloudSystemExit(
1281                         "Cant set perms on {}/master.pem".format(tmp_dir)
1282                     )
1283             if master_pub:
1284                 ssh_file(opts, "{}/master.pub".format(tmp_dir), master_pub, ssh_kwargs)
1285             if master_conf:
1286                 if not isinstance(master_conf, dict):
1287                     raise DeprecationWarning(
1288                         "`salt.utils.cloud.deploy_script now only accepts "
1289                         "dictionaries for it's `master_conf` parameter. "
1290                         "Loading from YAML ..."
1291                     )
1292                 ssh_file(
1293                     opts,
1294                     "{}/master".format(tmp_dir),
1295                     salt_config_to_yaml(master_conf),
1296                     ssh_kwargs,
1297                 )
1298             preseed_minion_keys_tempdir = "{}/preseed-minion-keys".format(tmp_dir)
1299             if preseed_minion_keys is not None:
1300                 ret = root_cmd(
1301                     "mkdir '{}'".format(preseed_minion_keys_tempdir),
1302                     tty,
1303                     sudo,
1304                     **ssh_kwargs
1305                 )
1306                 if ret:
1307                     raise SaltCloudSystemExit(
1308                         "Cant create {}".format(preseed_minion_keys_tempdir)
1309                     )
1310                 ret = root_cmd(
1311                     "chmod 700 '{}'".format(preseed_minion_keys_tempdir),
1312                     tty,
1313                     sudo,
1314                     **ssh_kwargs
1315                 )
1316                 if ret:
1317                     raise SaltCloudSystemExit(
1318                         "Can't set perms on {}".format(preseed_minion_keys_tempdir)
1319                     )
1320                 if ssh_kwargs["username"] != "root":
1321                     root_cmd(
1322                         "chown {} '{}'".format(
1323                             ssh_kwargs["username"], preseed_minion_keys_tempdir
1324                         ),
1325                         tty,
1326                         sudo,
1327                         **ssh_kwargs
1328                     )
1329                 for minion_id, minion_key in preseed_minion_keys.items():
1330                     rpath = os.path.join(preseed_minion_keys_tempdir, minion_id)
1331                     ssh_file(opts, rpath, minion_key, ssh_kwargs)
1332                 if ssh_kwargs["username"] != "root":
1333                     root_cmd(
1334                         "chown -R root '{}'".format(preseed_minion_keys_tempdir),
1335                         tty,
1336                         sudo,
1337                         **ssh_kwargs
1338                     )
1339                     if ret:
1340                         raise SaltCloudSystemExit(
1341                             "Can't set ownership for {}".format(
1342                                 preseed_minion_keys_tempdir
1343                             )
1344                         )
1345             preflight_cmds = kwargs.get("preflight_cmds", [])
1346             for command in preflight_cmds:
1347                 cmd_ret = root_cmd(command, tty, sudo, **ssh_kwargs)
1348                 if cmd_ret:
1349                     raise SaltCloudSystemExit(
1350                         "Pre-flight command failed: '{}'".format(command)
1351                     )
1352             if script:
1353                 ssh_file(opts, "{}/deploy.sh".format(tmp_dir), script, ssh_kwargs)
1354                 ret = root_cmd(
1355                     "sh -c \"( chmod +x '{}/deploy.sh' )\";exit $?".format(tmp_dir),
1356                     tty,
1357                     sudo,
1358                     **ssh_kwargs
1359                 )
1360                 if ret:
1361                     raise SaltCloudSystemExit(
1362                         "Can't set perms on {}/deploy.sh".format(tmp_dir)
1363                     )
1364             time_used = time.mktime(time.localtime()) - time.mktime(starttime)
1365             newtimeout = timeout - time_used
1366             queue = None
1367             process = None
1368             if start_action and not parallel:
1369                 queue = multiprocessing.Queue()
1370                 process = multiprocessing.Process(
1371                     target=check_auth,
1372                     kwargs=dict(
1373                         name=name, sock_dir=sock_dir, timeout=newtimeout, queue=queue
1374                     ),
1375                     name="DeployScriptCheckAuth({})".format(name),
1376                 )
1377                 log.debug("Starting new process to wait for salt-minion")
1378                 process.start()
1379             if script:
1380                 if "bootstrap-salt" in script:
1381                     deploy_command += " -c '{}'".format(tmp_dir)
1382                     if force_minion_config:
1383                         deploy_command += " -F"
1384                     if make_syndic is True:
1385                         deploy_command += " -S"
1386                     if make_master is True:
1387                         deploy_command += " -M"
1388                     if make_minion is False:
1389                         deploy_command += " -N"
1390                     if keep_tmp is True:
1391                         deploy_command += " -K"
1392                     if preseed_minion_keys is not None:
1393                         deploy_command += " -k '{}'".format(preseed_minion_keys_tempdir)
1394                 if script_args:
1395                     deploy_command += " {}".format(script_args)
1396                 if script_env:
1397                     if not isinstance(script_env, dict):
1398                         raise SaltCloudSystemExit(
1399                             "The 'script_env' configuration setting NEEDS "
1400                             "to be a dictionary not a {}".format(type(script_env))
1401                         )
1402                     environ_script_contents = ["#!/bin/sh"]
1403                     for key, value in script_env.items():
1404                         environ_script_contents.append(
1405                             "setenv {0} '{1}' &gt;/dev/null 2&gt;&amp;1 || "
1406                             "export {0}='{1}'".format(key, value)
1407                         )
1408                     environ_script_contents.append(deploy_command)
1409                     ssh_file(
1410                         opts,
1411                         "{}/environ-deploy-wrapper.sh".format(tmp_dir),
1412                         "\n".join(environ_script_contents),
1413                         ssh_kwargs,
1414                     )
1415                     root_cmd(
1416                         "chmod +x '{}/environ-deploy-wrapper.sh'".format(tmp_dir),
1417                         tty,
1418                         sudo,
1419                         **ssh_kwargs
1420                     )
1421                     deploy_command = "'{}/environ-deploy-wrapper.sh'".format(
1422                         tmp_dir,
1423                     )
1424                 if root_cmd(deploy_command, tty, sudo, **ssh_kwargs) != 0:
1425                     raise SaltCloudSystemExit(
1426                         "Executing the command '{}' failed".format(deploy_command)
1427                     )
1428                 log.debug("Executed command '%s'", deploy_command)
1429                 if not keep_tmp:
1430                     root_cmd(
1431                         "rm -f '{}/deploy.sh'".format(tmp_dir), tty, sudo, **ssh_kwargs
1432                     )
1433                     log.debug("Removed %s/deploy.sh", tmp_dir)
1434                     if script_env:
1435                         root_cmd(
1436                             "rm -f '{}/environ-deploy-wrapper.sh'".format(tmp_dir),
1437                             tty,
1438                             sudo,
1439                             **ssh_kwargs
1440                         )
1441                         log.debug("Removed %s/environ-deploy-wrapper.sh", tmp_dir)
1442             if keep_tmp:
1443                 log.debug("Not removing deployment files from %s/", tmp_dir)
1444             else:
1445                 if minion_pub:
1446                     root_cmd(
1447                         "rm -f '{}/minion.pub'".format(tmp_dir), tty, sudo, **ssh_kwargs
1448                     )
1449                     log.debug("Removed %s/minion.pub", tmp_dir)
1450                 if minion_pem:
1451                     root_cmd(
1452                         "rm -f '{}/minion.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1453                     )
1454                     log.debug("Removed %s/minion.pem", tmp_dir)
1455                 if minion_conf:
1456                     root_cmd(
1457                         "rm -f '{}/grains'".format(tmp_dir), tty, sudo, **ssh_kwargs
1458                     )
1459                     log.debug("Removed %s/grains", tmp_dir)
1460                     root_cmd(
1461                         "rm -f '{}/minion'".format(tmp_dir), tty, sudo, **ssh_kwargs
1462                     )
1463                     log.debug("Removed %s/minion", tmp_dir)
1464                 if master_sign_pub_file:
1465                     root_cmd(
1466                         "rm -f {}/master_sign.pub".format(tmp_dir),
1467                         tty,
1468                         sudo,
1469                         **ssh_kwargs
1470                     )
1471                     log.debug("Removed %s/master_sign.pub", tmp_dir)
1472                 if master_pub:
1473                     root_cmd(
1474                         "rm -f '{}/master.pub'".format(tmp_dir), tty, sudo, **ssh_kwargs
1475                     )
1476                     log.debug("Removed %s/master.pub", tmp_dir)
1477                 if master_pem:
1478                     root_cmd(
1479                         "rm -f '{}/master.pem'".format(tmp_dir), tty, sudo, **ssh_kwargs
1480                     )
1481                     log.debug("Removed %s/master.pem", tmp_dir)
1482                 if master_conf:
1483                     root_cmd(
1484                         "rm -f '{}/master'".format(tmp_dir), tty, sudo, **ssh_kwargs
1485                     )
1486                     log.debug("Removed %s/master", tmp_dir)
1487                 if preseed_minion_keys is not None:
1488                     root_cmd(
1489                         "rm -rf '{}'".format(preseed_minion_keys_tempdir),
1490                         tty,
1491                         sudo,
1492                         **ssh_kwargs
1493                     )
1494                     log.debug("Removed %s", preseed_minion_keys_tempdir)
1495             if start_action and not parallel:
1496                 queuereturn = queue.get()
1497                 process.join()
1498                 if queuereturn and start_action:
1499                     log.info("Executing %s on the salt-minion", start_action)
1500                     root_cmd(
1501                         "salt-call {}".format(start_action), tty, sudo, **ssh_kwargs
1502                     )
1503                     log.info("Finished executing %s on the salt-minion", start_action)
1504             fire_event(
1505                 "event",
1506                 "{} has been deployed at {}".format(name, host),
1507                 "salt/cloud/{}/deploy_script".format(name),
1508                 args={"name": name, "host": host},
1509                 sock_dir=opts.get(
1510                     "sock_dir", os.path.join(__opts__["sock_dir"], "master")
1511                 ),
1512                 transport=opts.get("transport", "zeromq"),
1513             )
1514             if file_map_fail or file_map_success:
1515                 return {
1516                     "File Upload Success": file_map_success,
1517                     "File Upload Failure": file_map_fail,
1518                 }
1519             return True
1520     return False
1521 def run_inline_script(
1522     host,
1523     name=None,
1524     port=22,
1525     timeout=900,
1526     username="root",
1527     key_filename=None,
1528     inline_script=None,
1529     ssh_timeout=15,
1530     display_ssh_output=True,
1531     parallel=False,
1532     sudo_password=None,
1533     sudo=False,
1534     password=None,
1535     tty=None,
1536     opts=None,
1537     tmp_dir="/tmp/.saltcloud-inline_script",
1538     **kwargs
1539 ):
1540     gateway = None
1541     if "gateway" in kwargs:
1542         gateway = kwargs["gateway"]
1543     starttime = time.mktime(time.localtime())
1544     log.debug("Deploying %s at %s", host, starttime)
1545     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1546     if wait_for_port(host=host, port=port, gateway=gateway):
1547         log.debug("SSH port %s on %s is available", port, host)
1548         newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1549         if wait_for_passwd(
1550             host,
1551             port=port,
1552             username=username,
1553             password=password,
1554             key_filename=key_filename,
1555             ssh_timeout=ssh_timeout,
1556             display_ssh_output=display_ssh_output,
1557             gateway=gateway,
1558             known_hosts_file=known_hosts_file,
1559         ):
1560             log.debug("Logging into %s:%s as %s", host, port, username)
1561             newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1562             ssh_kwargs = {
1563                 "hostname": host,
1564                 "port": port,
1565                 "username": username,
1566                 "timeout": ssh_timeout,
1567                 "display_ssh_output": display_ssh_output,
1568                 "sudo_password": sudo_password,
1569                 "sftp": opts.get("use_sftp", False),
1570             }
1571             ssh_kwargs.update(__ssh_gateway_config_dict(gateway))
1572             if key_filename:
1573                 log.debug("Using %s as the key_filename", key_filename)
1574                 ssh_kwargs["key_filename"] = key_filename
1575             elif (
1576                 password
1577                 and "has_ssh_agent" in kwargs
1578                 and kwargs["has_ssh_agent"] is False
1579             ):
1580                 ssh_kwargs["password"] = password
1581             if (
1582                 root_cmd(
1583                     'test -e \\"{}\\"'.format(tmp_dir),
1584                     tty,
1585                     sudo,
1586                     allow_failure=True,
1587                     **ssh_kwargs
1588                 )
1589                 and inline_script
1590             ):
1591                 log.debug("Found inline script to execute.")
1592                 for cmd_line in inline_script:
1593                     log.info("Executing inline command: %s", cmd_line)
1594                     ret = root_cmd(
1595                         'sh -c "( {} )"'.format(cmd_line),
1596                         tty,
1597                         sudo,
1598                         allow_failure=True,
1599                         **ssh_kwargs
1600                     )
1601                     if ret:
1602                         log.info("[%s] Output: %s", cmd_line, ret)
1603     return True
1604 def filter_event(tag, data, defaults):
1605     ret = {}
1606     keys = []
1607     use_defaults = True
1608     for ktag in __opts__.get("filter_events", {}):
1609         if tag != ktag:
1610             continue
1611         keys = __opts__["filter_events"][ktag]["keys"]
1612         use_defaults = __opts__["filter_events"][ktag].get("use_defaults", True)
1613     if use_defaults is False:
1614         defaults = []
1615     if not isinstance(defaults, list):
1616         defaults = list(defaults)
1617     defaults = list(set(defaults + keys))
1618     for key in defaults:
1619         if key in data:
1620             ret[key] = data[key]
1621     return ret
1622 def fire_event(key, msg, tag, sock_dir, args=None, transport="zeromq"):
1623     with salt.utils.event.get_event("master", sock_dir, listen=False) as event:
1624         try:
1625             event.fire_event(msg, tag)
1626         except ValueError:
1627             if isinstance(args, dict):
1628                 args[key] = msg
1629             else:
1630                 args = {key: msg}
1631             event.fire_event(args, tag)
1632         time.sleep(0.025)
1633 def _exec_ssh_cmd(cmd, error_msg=None, allow_failure=False, **kwargs):
1634     if error_msg is None:
1635         error_msg = "A wrong password has been issued while establishing ssh session."
1636     password_retries = kwargs.get("password_retries", 3)
1637     try:
1638         stdout, stderr = None, None
1639         proc = salt.utils.vt.Terminal(
1640             cmd,
1641             shell=True,
1642             log_stdout=True,
1643             log_stderr=True,
1644             stream_stdout=kwargs.get("display_ssh_output", True),
1645             stream_stderr=kwargs.get("display_ssh_output", True),
1646         )
1647         sent_password = 0
1648         while proc.has_unread_data:
1649             stdout, stderr = proc.recv()
1650             if stdout and SSH_PASSWORD_PROMP_RE.search(stdout):
1651                 if (
1652                     "key_filename" in kwargs
1653                     and kwargs["key_filename"]
1654                     and SSH_PASSWORD_PROMP_SUDO_RE.search(stdout)
1655                 ):
1656                     proc.sendline(kwargs["sudo_password"])
1657                 elif kwargs.get("password", None) and (
1658                     sent_password &lt; password_retries
1659                 ):
1660                     sent_password += 1
1661                     proc.sendline(kwargs["password"])
1662                 else:
1663                     raise SaltCloudPasswordError(error_msg)
1664             time.sleep(0.5)
1665         if proc.exitstatus != 0 and allow_failure is False:
1666             raise SaltCloudSystemExit(
1667                 "Command '{}' failed. Exit code: {}".format(cmd, proc.exitstatus)
1668             )
1669         return proc.exitstatus
1670     except salt.utils.vt.TerminalException as err:
1671         trace = traceback.format_exc()
1672         log.error(
1673             error_msg.format(cmd, err, trace)
1674         )  # pylint: disable=str-format-in-logging
1675     finally:
1676         proc.close(terminate=True, kill=True)
1677     return 1
1678 def scp_file(dest_path, contents=None, kwargs=None, local_file=None):
1679     file_to_upload = None
1680     try:
1681         if contents is not None:
1682             try:
1683                 tmpfd, file_to_upload = tempfile.mkstemp()
1684                 os.write(tmpfd, contents)
1685             finally:
1686                 try:
1687                     os.close(tmpfd)
1688                 except OSError as exc:
1689                     if exc.errno != errno.EBADF:
1690                         raise
1691         log.debug("Uploading %s to %s", dest_path, kwargs["hostname"])
1692         ssh_args = [
1693             "-oStrictHostKeyChecking=no",
1694             "-oServerAliveInterval={}".format(
1695                 kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
1696             ),
1697             "-oServerAliveCountMax={}".format(
1698                 kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
1699             ),
1700             "-oUserKnownHostsFile=/dev/null",
1701             "-oControlPath=none",
1702         ]
1703         if local_file is not None:
1704             file_to_upload = local_file
1705             if os.path.isdir(local_file):
1706                 ssh_args.append("-r")
1707         if "key_filename" in kwargs:
1708             ssh_args.extend(
1709                 [
1710                     "-oPasswordAuthentication=no",
1711                     "-oChallengeResponseAuthentication=no",
1712                     "-oPubkeyAuthentication=yes",
1713                     "-oIdentitiesOnly=yes",
1714                     "-oKbdInteractiveAuthentication=no",
1715                     "-i {}".format(kwargs["key_filename"]),
1716                 ]
1717             )
1718         if "port" in kwargs:
1719             ssh_args.append("-oPort={}".format(kwargs["port"]))
1720         ssh_args.append(__ssh_gateway_arguments(kwargs))
1721         try:
1722             if socket.inet_pton(socket.AF_INET6, kwargs["hostname"]):
1723                 ipaddr = "[{}]".format(kwargs["hostname"])
1724             else:
1725                 ipaddr = kwargs["hostname"]
1726         except OSError:
1727             ipaddr = kwargs["hostname"]
1728         if file_to_upload is None:
1729             log.warning(
1730                 "No source file to upload. Please make sure that either file "
1731                 "contents or the path to a local file are provided."
1732             )
1733         cmd = (
1734             "scp {0} {1} {2[username]}@{4}:{3} || "
1735             'echo "put {1} {3}" | sftp {0} {2[username]}@{4} || '
1736             'rsync -avz -e "ssh {0}" {1} {2[username]}@{2[hostname]}:{3}'.format(
1737                 " ".join(ssh_args), file_to_upload, kwargs, dest_path, ipaddr
1738             )
1739         )
1740         log.debug("SCP command: '%s'", cmd)
1741         retcode = _exec_ssh_cmd(
1742             cmd,
1743             error_msg="Failed to upload file '{0}': {1}\n{2}",
1744             password_retries=3,
1745             **kwargs
1746         )
1747     finally:
1748         if contents is not None:
1749             try:
1750                 os.remove(file_to_upload)
1751             except OSError as exc:
1752                 if exc.errno != errno.ENOENT:
1753                     raise
1754     return retcode
1755 def ssh_file(opts, dest_path, contents=None, kwargs=None, local_file=None):
1756     if opts.get("file_transport", "sftp") == "sftp":
1757         return sftp_file(dest_path, contents, kwargs, local_file)
1758     return scp_file(dest_path, contents, kwargs, local_file)
1759 def sftp_file(dest_path, contents=None, kwargs=None, local_file=None):
1760     put_args = []
1761     if kwargs is None:
1762         kwargs = {}
1763     file_to_upload = None
1764     try:
1765         if contents is not None:
1766             try:
1767                 tmpfd, file_to_upload = tempfile.mkstemp()
1768                 if isinstance(contents, str):
1769                     os.write(tmpfd, contents.encode(__salt_system_encoding__))
1770                 else:
1771                     os.write(tmpfd, contents)
1772             finally:
1773                 try:
1774                     os.close(tmpfd)
1775                 except OSError as exc:
1776                     if exc.errno != errno.EBADF:
1777                         raise
1778         if local_file is not None:
1779             file_to_upload = local_file
1780             if os.path.isdir(local_file):
1781                 put_args = ["-r"]
1782         log.debug("Uploading %s to %s (sftp)", dest_path, kwargs.get("hostname"))
1783         ssh_args = [
1784             "-oStrictHostKeyChecking=no",
1785             "-oServerAliveInterval={}".format(
1786                 kwargs.get("server_alive_interval", SERVER_ALIVE_INTERVAL)
1787             ),
1788             "-oServerAliveCountMax={}".format(
1789                 kwargs.get("server_alive_count_max", SERVER_ALIVE_COUNT_MAX)
1790             ),
1791             "-oUserKnownHostsFile=/dev/null",
1792             "-oControlPath=none",
1793         ]
1794         if "key_filename" in kwargs:
1795             ssh_args.extend(
1796                 [
1797                     "-oPasswordAuthentication=no",
1798                     "-oChallengeResponseAuthentication=no",
1799                     "-oPubkeyAuthentication=yes",
1800                     "-oIdentitiesOnly=yes",
1801                     "-oKbdInteractiveAuthentication=no",
1802                     "-oIdentityFile={}".format(kwargs["key_filename"]),
1803                 ]
1804             )
1805         if "port" in kwargs:
1806             ssh_args.append("-oPort={}".format(kwargs["port"]))
1807         ssh_args.append(__ssh_gateway_arguments(kwargs))
1808         try:
1809             if socket.inet_pton(socket.AF_INET6, kwargs["hostname"]):
1810                 ipaddr = "[{}]".format(kwargs["hostname"])
1811             else:
1812                 ipaddr = kwargs["hostname"]
1813         except OSError:
1814             ipaddr = kwargs["hostname"]
1815         if file_to_upload is None:
1816             log.warning(
1817                 "No source file to upload. Please make sure that either file "
1818                 "contents or the path to a local file are provided."
1819             )
1820         cmd = 'echo "put {0} {1} {2}" | sftp {3} {4[username]}@{5}'.format(
1821             " ".join(put_args),
1822             file_to_upload,
1823             dest_path,
1824             " ".join(ssh_args),
1825             kwargs,
1826             ipaddr,
1827         )
1828         log.debug("SFTP command: '%s'", cmd)
1829         retcode = _exec_ssh_cmd(
1830             cmd,
1831             error_msg="Failed to upload file '{0}': {1}\n{2}",
1832             password_retries=3,
1833             **kwargs
1834         )
1835     finally:
1836         if contents is not None:
1837             try:
1838                 os.remove(file_to_upload)
1839             except OSError as exc:
1840                 if exc.errno != errno.ENOENT:
1841                     raise
1842     return retcode
1843 def win_cmd(command, **kwargs):
1844     logging_command = kwargs.get("logging_command", None)
1845     try:
1846         proc = NonBlockingPopen(
1847             command,
1848             shell=True,
1849             stderr=subprocess.PIPE,
1850             stdout=subprocess.PIPE,
1851             stream_stds=kwargs.get("display_ssh_output", True),
1852             logging_command=logging_command,
1853         )
1854         if logging_command is None:
1855             log.debug("Executing command(PID %s): '%s'", proc.pid, command)
1856         else:
1857             log.debug("Executing command(PID %s): '%s'", proc.pid, logging_command)
1858         proc.poll_and_read_until_finish()
1859         proc.communicate()
1860         return proc.returncode
1861     except Exception as err:  # pylint: disable=broad-except
1862         log.exception("Failed to execute command '%s'", logging_command)
1863     return 1
1864 def winrm_cmd(session, command, flags, **kwargs):
1865     log.debug("Executing WinRM command: %s %s", command, flags)
1866     r = session.run_cmd(command, flags)
1867     return r.status_code
1868 def root_cmd(command, tty, sudo, allow_failure=False, **kwargs):
1869     logging_command = command
1870     sudo_password = kwargs.get("sudo_password", None)
1871     if sudo:
1872         if sudo_password is None:
1873             command = "sudo {}".format(command)
1874             logging_command = command
1875         else:
1876             logging_command = 'sudo -S "XXX-REDACTED-XXX" {}'.format(command)
1877             command = "sudo -S {}".format(command)
1878         log.debug("Using sudo to run command %s", logging_command)
1879     ssh_args = []
1880     if tty:
1881         ssh_args.extend(["-t", "-t"])
1882     known_hosts_file = kwargs.get("known_hosts_file", "/dev/null")
1883     host_key_checking = "no"
1884     if known_hosts_file != "/dev/null":
1885         host_key_checking = "yes"
1886     ssh_args.extend(
1887         [
1888             "-oStrictHostKeyChecking={}".format(host_key_checking),
1889             "-oUserKnownHostsFile={}".format(known_hosts_file),
1890             "-oControlPath=none",
1891         ]
1892     )
1893     if "key_filename" in kwargs:
1894         ssh_args.extend(
1895             [
1896                 "-oPasswordAuthentication=no",
1897                 "-oChallengeResponseAuthentication=no",
1898                 "-oPubkeyAuthentication=yes",
1899                 "-oIdentitiesOnly=yes",
1900                 "-oKbdInteractiveAuthentication=no",
1901                 "-i {}".format(kwargs["key_filename"]),
1902             ]
1903         )
1904     if "ssh_timeout" in kwargs:
1905         ssh_args.extend(["-oConnectTimeout={}".format(kwargs["ssh_timeout"])])
1906     ssh_args.extend([__ssh_gateway_arguments(kwargs)])
1907     if "port" in kwargs:
1908         ssh_args.extend(["-p {}".format(kwargs["port"])])
1909     cmd = "ssh {0} {1[username]}@{1[hostname]} ".format(" ".join(ssh_args), kwargs)
1910     logging_command = cmd + logging_command
1911     cmd = cmd + pipes.quote(command)
1912     hard_timeout = kwargs.get("hard_timeout")
1913     if hard_timeout is not None:
1914         logging_command = "timeout {} {}".format(hard_timeout, logging_command)
1915         cmd = "timeout {} {}".format(hard_timeout, cmd)
1916     log.debug("SSH command: '%s'", logging_command)
1917     retcode = _exec_ssh_cmd(cmd, allow_failure=allow_failure, **kwargs)
1918     return retcode
1919 def check_auth(name, sock_dir=None, queue=None, timeout=300):
1920     with salt.utils.event.SaltEvent("master", sock_dir, listen=True) as event:
1921         starttime = time.mktime(time.localtime())
1922         newtimeout = timeout
1923         log.debug("In check_auth, waiting for %s to become available", name)
1924         while newtimeout &gt; 0:
1925             newtimeout = timeout - (time.mktime(time.localtime()) - starttime)
1926             ret = event.get_event(full=True)
1927             if ret is None:
1928                 continue
1929             if ret["tag"] == "salt/minion/{}/start".format(name):
1930                 queue.put(name)
1931                 newtimeout = 0
1932                 log.debug("Minion %s is ready to receive commands", name)
1933 def ip_to_int(ip):
1934     ret = 0
1935     for octet in ip.split("."):
1936         ret = ret * 256 + int(octet)
1937     return ret
1938 def is_public_ip(ip):
1939     if ":" in ip:
1940         if ip.startswith("fe80:"):
1941             return False
1942         return True
1943     addr = ip_to_int(ip)
1944     if 167772160 &lt; addr &lt; 184549375:
1945         return False
1946     elif 3232235520 &lt; addr &lt; 3232301055:
1947         return False
1948     elif 2886729728 &lt; addr &lt; 2887778303:
1949         return False
1950     elif 2130706432 &lt; addr &lt; 2147483647:
1951         return False
1952     return True
1953 def check_name(name, safe_chars):
1954     regexp = re.compile("[^{}]".format(safe_chars))
1955     if regexp.search(name):
1956         raise SaltCloudException(
1957             "{} contains characters not supported by this cloud provider. "
1958             "Valid characters are: {}".format(name, safe_chars)
1959         )
1960 def remove_sshkey(host, known_hosts=None):
1961     if known_hosts is None:
1962         if "HOME" in os.environ:
1963             known_hosts = "{}/.ssh/known_hosts".format(os.environ["HOME"])
1964         else:
1965             try:
1966                 known_hosts = "{}/.ssh/known_hosts".format(
1967                     pwd.getpwuid(os.getuid()).pwd_dir
1968                 )
1969             except Exception:  # pylint: disable=broad-except
1970                 pass
1971     if known_hosts is not None:
1972         log.debug("Removing ssh key for %s from known hosts file %s", host, known_hosts)
1973     else:
1974         log.debug("Removing ssh key for %s from known hosts file", host)
1975     subprocess.call(["ssh-keygen", "-R", host])
1976 def wait_for_ip(
1977     update_callback,
1978     update_args=None,
1979     update_kwargs=None,
1980     timeout=5 * 60,
1981     interval=5,
1982     interval_multiplier=1,
1983     max_failures=10,
1984 ):
1985     if update_args is None:
1986         update_args = ()
1987     if update_kwargs is None:
1988         update_kwargs = {}
1989     duration = timeout
1990     while True:
1991         log.debug(
1992             "Waiting for VM IP. Giving up in 00:%02d:%02d.",
1993             int(timeout // 60),
1994             int(timeout % 60),
1995         )
1996         data = update_callback(*update_args, **update_kwargs)
1997         if data is False:
1998             log.debug(
1999                 "'update_callback' has returned 'False', which is "
2000                 "considered a failure. Remaining Failures: %s.",
2001                 max_failures,
2002             )
2003             max_failures -= 1
2004             if max_failures &lt;= 0:
2005                 raise SaltCloudExecutionFailure(
2006                     "Too many failures occurred while waiting for the IP address."
2007                 )
2008         elif data is not None:
2009             return data
2010         if timeout &lt; 0:
2011             raise SaltCloudExecutionTimeout(
2012                 "Unable to get IP for 00:{:02d}:{:02d}.".format(
2013                     int(duration // 60), int(duration % 60)
2014                 )
2015             )
2016         time.sleep(interval)
2017         timeout -= interval
2018         if interval_multiplier &gt; 1:
2019             interval *= interval_multiplier
2020             if interval &gt; timeout:
2021                 interval = timeout + 1
2022             log.info("Interval multiplier in effect; interval is now %ss.", interval)
2023 def list_nodes_select(nodes, selection, call=None):
2024     if call == "action":
2025         raise SaltCloudSystemExit(
2026             "The list_nodes_select function must be called with -f or --function."
2027         )
2028     if "error" in nodes:
2029         raise SaltCloudSystemExit(
2030             "An error occurred while listing nodes: {}".format(
2031                 nodes["error"]["Errors"]["Error"]["Message"]
2032             )
2033         )
2034     ret = {}
2035     for node in nodes:
2036         pairs = {}
2037         data = nodes[node]
2038         for key in data:
2039             if str(key) in selection:
2040                 value = data[key]
2041                 pairs[key] = value
2042         ret[node] = pairs
2043     return ret
2044 def lock_file(filename, interval=0.5, timeout=15):
2045     log.trace("Attempting to obtain lock for %s", filename)
2046     lock = filename + ".lock"
2047     start = time.time()
2048     while True:
2049         if os.path.exists(lock):
2050             if time.time() - start &gt;= timeout:
2051                 log.warning("Unable to obtain lock for %s", filename)
2052                 return False
2053             time.sleep(interval)
2054         else:
2055             break
2056     with salt.utils.files.fopen(lock, "a"):
2057         pass
2058 def unlock_file(filename):
2059     log.trace("Removing lock for %s", filename)
2060     lock = filename + ".lock"
2061     try:
2062         os.remove(lock)
2063     except OSError as exc:
2064         log.trace("Unable to remove lock for %s: %s", filename, exc)
2065 def cachedir_index_add(minion_id, profile, driver, provider, base=None):
2066     base = init_cachedir(base)
2067     index_file = os.path.join(base, "index.p")
2068     if os.path.exists(index_file):
2069         with salt<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(index_file, "rb") as fh_:
2070             index = salt.utils.data.decode(
2071                 salt.utils.msgpack.load(</b></font>fh_, encoding=MSGPACK_ENCODING)
2072             )
2073     else:
2074         index = {}
2075     prov_comps = provider.split(":")
2076     index.update(
2077         {
2078             minion_id: {
2079                 "id": minion_id,
2080                 "profile": profile,
2081                 "driver": driver,
2082                 "provider": prov_comps[0],
2083             }
2084         }
2085     )
2086     with salt.utils.files.fopen(index_file, "wb") as fh_:
2087         salt.utils.msgpack.dump(index, fh_, encoding=MSGPACK_ENCODING)
2088     unlock_file(index_file)
2089 def cachedir_index_del(minion_id, base=None):
2090     base = init_cachedir(base)
2091     index_file = os.path.join(base, "index.p")
2092     if os.path.exists(index_file):
2093         with salt<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.utils.files.fopen(index_file, "rb") as fh_:
2094             index = salt.utils.data.decode(
2095                 salt.utils.msgpack.load(</b></font>fh_, encoding=MSGPACK_ENCODING)
2096             )
2097     else:
2098         return
2099     if minion_id in index:
2100         del index[minion_id]
2101     with salt.utils.files.fopen(index_file, "wb") as fh_:
2102         salt.utils.msgpack.dump(index, fh_, encoding=MSGPACK_ENCODING)
2103     unlock_file(index_file)
2104 def init_cachedir(base=None):
2105     if base is None:
2106         base = __opts__["cachedir"]
2107     needed_dirs = (base, os.path.join(base, "requested"), os.path.join(base, "active"))
2108     for dir_ in needed_dirs:
2109         if not os.path.exists(dir_):
2110             os.makedirs(dir_)
2111         os.chmod(base, 0o755)
2112     return base
2113 def request_minion_cachedir(
2114     minion_id,
2115     opts=None,
2116     fingerprint="",
2117     pubkey=None,
2118     provider=None,
2119     base=None,
2120 ):
2121     if base is None:
2122         base = __opts__["cachedir"]
2123     if not fingerprint and pubkey is not None:
2124         fingerprint = salt.utils.crypt.pem_finger(
2125             key=pubkey, sum_type=(opts and opts.get("hash_type") or "sha256")
2126         )
2127     init_cachedir(base)
2128     data = {
2129         "minion_id": minion_id,
2130         "fingerprint": fingerprint,
2131     }
2132     fname = "{}.p"<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.format(minion_id)
2133     path = os.path.join(base, "requested", fname)
2134     with salt.utils.files.fopen(path, "wb") as fh_:
2135         salt.</b></font>utils.msgpack.dump(data, fh_, encoding=MSGPACK_ENCODING)
2136 def change_minion_cachedir(
2137     minion_id,
2138     cachedir,
2139     data=None,
2140     base=None,
2141 ):
2142     if not isinstance(data, dict):
2143         return False
2144     if base is None:
2145         base = __opts__["cachedir"]
2146     fname = "{}.p".format(minion_id)
2147     path = os.path.join(base, cachedir, fname)
2148     with salt.utils.files.fopen(path, "r") as fh_:
2149         cache_data = salt.utils.data.decode(
2150             salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2151         )
2152     cache_data.update(data)
2153     with salt.utils.files.fopen(path, "w") as fh_:
2154         salt.utils.msgpack.dump(cache_data, fh_, encoding=MSGPACK_ENCODING)
2155 def activate_minion_cachedir(minion_id, base=None):
2156     if base is None:
2157         base = __opts__["cachedir"]
2158     fname = "{}.p".format(minion_id)
2159     src = os.path.join(base, "requested", fname)
2160     dst = os.path.join(base, "active")
2161     shutil.move(src, dst)
2162 def delete_minion_cachedir(minion_id, provider, opts, base=None):
2163     if isinstance(opts, dict):
2164         __opts__.update(opts)
2165     if __opts__.get("update_cachedir", False) is False:
2166         return
2167     if base is None:
2168         base = __opts__["cachedir"]
2169     driver = next(iter(__opts__["providers"][provider].keys()))
2170     fname = "{}.p".format(minion_id)
2171     for cachedir in "requested", "active":
2172         path = os.path.join(base, cachedir, driver, provider, fname)
2173         log.debug("path: %s", path)
2174         if os.path.exists(path):
2175             os.remove(path)
2176 def list_cache_nodes_full(opts=None, provider=None, base=None):
2177     if opts is None:
2178         opts = __opts__
2179     if opts.get("update_cachedir", False) is False:
2180         return
2181     if base is None:
2182         base = os.path.join(opts["cachedir"], "active")
2183     minions = {}
2184     for driver in os.listdir(base):
2185         minions[driver] = {}
2186         prov_dir = os.path.join(base, driver)
2187         for prov in os.listdir(prov_dir):
2188             if provider and provider != prov:
2189                 continue
2190             minions[driver][prov] = {}
2191             min_dir = os.path.join(prov_dir, prov)
2192             for fname in os.listdir(min_dir):
2193                 fpath = os.path.join(min_dir, fname)
2194                 minion_id = fname[:-2]  # strip '.p' from end of msgpack filename
2195                 with salt.utils.files.fopen(fpath, "rb") as fh_:
2196                     minions[driver][prov][minion_id] = salt.utils.data.decode(
2197                         salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2198                     )
2199     return minions
2200 def update_bootstrap(config, url=None):
2201     default_url = config.get("bootstrap_script_url", "https://bootstrap.saltstack.com")
2202     if not url:
2203         url = default_url
2204     if not url:
2205         raise ValueError("Cant get any source to update")
2206     if url.startswith("http") or "://" in url:
2207         log.debug("Updating the bootstrap-salt.sh script to latest stable")
2208         try:
2209             import requests
2210         except ImportError:
2211             return {
2212                 "error": (
2213                     "Updating the bootstrap-salt.sh script requires the "
2214                     "Python requests library to be installed"
2215                 )
2216             }
2217         req = requests.get(url)
2218         if req.status_code != 200:
2219             return {
2220                 "error": (
2221                     "Failed to download the latest stable version of the "
2222                     "bootstrap-salt.sh script from {}. HTTP error: "
2223                     "{}".format(url, req.status_code)
2224                 )
2225             }
2226         script_content = req.text
2227         if url == default_url:
2228             script_name = "bootstrap-salt.sh"
2229             script_name = os.path.basename(url)
2230     elif os.path.exists(url):
2231         <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(url) as fic:
2232             script_content = salt.utils.stringutils.to_unicode(fic.read())
2233         script_name =</b></font> os.path.basename(url)
2234     else:
2235         script_content = url
2236         script_name = "{}.sh".format(hashlib.sha1(script_content).hexdigest())
2237     if not script_content:
2238         raise ValueError("No content in bootstrap script !")
2239     builtin_deploy_dir = os.path.join(os.path.dirname(__file__), "deploy")
2240     deploy_d_from_conf_file = os.path.join(
2241         os.path.dirname(config["conf_file"]), "cloud.deploy.d"
2242     )
2243     deploy_d_from_syspaths = os.path.join(config["config_dir"], "cloud.deploy.d")
2244     deploy_scripts_search_paths = []
2245     for entry in config.get("deploy_scripts_search_path", []):
2246         if entry.startswith(builtin_deploy_dir):
2247             continue
2248         if entry in (deploy_d_from_conf_file, deploy_d_from_syspaths):
2249             deploy_scripts_search_paths.append((entry, True))
2250         else:
2251             deploy_scripts_search_paths.append((entry, False))
2252     if deploy_d_from_conf_file not in deploy_scripts_search_paths:
2253         deploy_scripts_search_paths.append((deploy_d_from_conf_file, True))
2254     if deploy_d_from_syspaths not in deploy_scripts_search_paths:
2255         deploy_scripts_search_paths.append((deploy_d_from_syspaths, True))
2256     finished = []
2257     finished_full = []
2258     for entry, makedirs in deploy_scripts_search_paths:
2259         if entry in finished:
2260             continue
2261         else:
2262             finished.append(entry)
2263         if makedirs and not os.path.isdir(entry):
2264             try:
2265                 os.makedirs(entry)
2266             except OSError as err:
2267                 log.info("Failed to create directory '%s'", entry)
2268                 continue
2269         if not is_writeable(entry):
2270             log.debug("The '%s' is not writeable. Continuing...", entry)
2271             continue
2272         try:
2273             finished_full.append(deploy_path)
2274             <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>with salt.utils.files.fopen(deploy_path, "w") as fp_:
2275                 fp_.write(salt.utils.stringutils.to_str(</b></font>script_content))
2276         except OSError as err:
2277             log.debug("Failed to write the updated script: %s", err)
2278             continue
2279     return {"Success": {"Files updated": finished_full}}
2280 def cache_node_list(nodes, provider, opts):
2281     if "update_cachedir" not in opts or not opts["update_cachedir"]:
2282         return
2283     base = os.path.join(init_cachedir(), "active")
2284     driver = next(iter(opts["providers"][provider].keys()))
2285     prov_dir = os.path.join(base, driver, provider)
2286     if not os.path.exists(prov_dir):
2287         os.makedirs(prov_dir)
2288     missing_node_cache(prov_dir, nodes, provider, opts)
2289     for node in nodes:
2290         diff_node_cache(prov_dir, node, nodes[node], opts)
2291         path = os.path.join(prov_dir, "{}.p".format(node))
2292         with salt.utils.files.fopen(path, "wb") as fh_:
2293             salt.utils.msgpack.dump(nodes[node], fh_, encoding=MSGPACK_ENCODING)
2294 def cache_node(node, provider, opts):
2295     if isinstance(opts, dict):
2296         __opts__.update(opts)
2297     if "update_cachedir" not in __opts__ or not __opts__["update_cachedir"]:
2298         return
2299     if not os.path.exists(os.path.join(__opts__["cachedir"], "active")):
2300         init_cachedir()
2301     base = os.path.join(__opts__["cachedir"], "active")
2302     provider, driver = provider.split(":")
2303     prov_dir = os.path.join(base, driver, provider)
2304     if not os.path.exists(prov_dir):
2305         os.makedirs(prov_dir)
2306     path = os.path.join(prov_dir, "{}.p".format(node["name"]))
2307     with salt.utils.files.fopen(path, "wb") as fh_:
2308         salt.utils.msgpack.dump(node, fh_, encoding=MSGPACK_ENCODING)
2309 def missing_node_cache(prov_dir, node_list, provider, opts):
2310     cached_nodes = []
2311     for node in os.listdir(prov_dir):
2312         cached_nodes.append(os.path.splitext(node)[0])
2313     for node in cached_nodes:
2314         if node not in node_list:
2315             delete_minion_cachedir(node, provider, opts)
2316             if "diff_cache_events" in opts and opts["diff_cache_events"]:
2317                 fire_event(
2318                     "event",
2319                     "cached node missing from provider",
2320                     "salt/cloud/{}/cache_node_missing".format(node),
2321                     args={"missing node": node},
2322                     sock_dir=opts.get(
2323                         "sock_dir", os.path.join(__opts__["sock_dir"], "master")
2324                     ),
2325                     transport=opts.get("transport", "zeromq"),
2326                 )
2327 def diff_node_cache(prov_dir, node, new_data, opts):
2328     if "diff_cache_events" not in opts or not opts["diff_cache_events"]:
2329         return
2330     if node is None:
2331         return
2332     path = "{}.p".format(os.path.join(prov_dir, node))
2333     if not os.path.exists(path):
2334         event_data = _strip_cache_events(new_data, opts)
2335         fire_event(
2336             "event",
2337             "new node found",
2338             "salt/cloud/{}/cache_node_new".format(node),
2339             args={"new_data": event_data},
2340             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
2341             transport=opts.get("transport", "zeromq"),
2342         )
2343         return
2344     with salt.utils.files.fopen(path, "r") as fh_:
2345         try:
2346             cache_data = salt.utils.data.decode(
2347                 salt.utils.msgpack.load(fh_, encoding=MSGPACK_ENCODING)
2348             )
2349         except ValueError:
2350             log.warning("Cache for %s was corrupt: Deleting", node)
2351             cache_data = {}
2352     diff = salt.utils.compat.cmp(new_data, cache_data)
2353     if diff != 0:
2354         fire_event(
2355             "event",
2356             "node data differs",
2357             "salt/cloud/{}/cache_node_diff".format(node),
2358             args={
2359                 "new_data": _strip_cache_events(new_data, opts),
2360                 "cache_data": _strip_cache_events(cache_data, opts),
2361             },
2362             sock_dir=opts.get("sock_dir", os.path.join(__opts__["sock_dir"], "master")),
2363             transport=opts.get("transport", "zeromq"),
2364         )
2365 def _strip_cache_events(data, opts):
2366     event_data = copy.deepcopy(data)
2367     strip_fields = opts.get("cache_event_strip_fields", [])
2368     for field in strip_fields:
2369         if field in event_data:
2370             del event_data[field]
2371     return event_data
2372 def _salt_cloud_force_ascii(exc):
2373     if not isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError)):
2374         raise TypeError("Can't handle {}".format(exc))
2375     unicode_trans = {
2376         "\xa0": " ",
2377         "\u2013": "-",
2378     }
2379     if exc.object[exc.start : exc.end] in unicode_trans:
2380         return unicode_trans[exc.object[exc.start : exc.end]], exc.end
2381     raise exc
2382 codecs.register_error("salt-cloud-force-ascii", _salt_cloud_force_ascii)
2383 def retrieve_password_from_keyring(credential_id, username):
2384     try:
2385         import keyring  # pylint: disable=import-error
2386         return keyring.get_password(credential_id, username)
2387     except ImportError:
2388         log.error(
2389             "USE_KEYRING configured as a password, but no keyring module is installed"
2390         )
2391         return False
2392 def _save_password_in_keyring(credential_id, username, password):
2393     try:
2394         import keyring  # pylint: disable=import-error
2395         return keyring.set_password(credential_id, username, password)
2396     except ImportError:
2397         log.error(
2398             "Tried to store password in keyring, but no keyring module is installed"
2399         )
2400         return False
2401 def store_password_in_keyring(credential_id, username, password=None):
2402     try:
2403         import keyring
2404         import keyring.errors
2405         if password is None:
2406             prompt = "Please enter password for {}: ".format(credential_id)
2407             try:
2408                 password = getpass.getpass(prompt)
2409             except EOFError:
2410                 password = None
2411             if not password:
2412                 raise RuntimeError("Invalid password provided.")
2413         try:
2414             _save_password_in_keyring(credential_id, username, password)
2415         except keyring.errors.PasswordSetError as exc:
2416             log.debug("Problem saving password in the keyring: %s", exc)
2417     except ImportError:
2418         log.error(
2419             "Tried to store password in keyring, but no keyring module is installed"
2420         )
2421         return False
2422 def _unwrap_dict(dictionary, index_string):
2423     index = index_string.split(",")
2424     for k in index:
2425         dictionary = dictionary[k]
2426     return dictionary
2427 def run_func_until_ret_arg(
2428     fun,
2429     kwargs,
2430     fun_call=None,
2431     argument_being_watched=None,
2432     required_argument_response=None,
2433 ):
2434     status = None
2435     while status != required_argument_response:
2436         f_result = fun(kwargs, call=fun_call)
2437         r_set = {}
2438         for d in f_result:
2439             if isinstance(d, list):
2440                 d0 = d[0]
2441                 if isinstance(d0, dict):
2442                     for k, v in d0.items():
2443                         r_set[k] = v
2444         status = _unwrap_dict(r_set, argument_being_watched)
2445         log.debug(
2446             "Function: %s, Watched arg: %s, Response: %s",
2447             str(fun).split(" ")[1],
2448             argument_being_watched,
2449             status,
2450         )
2451         time.sleep(5)
2452     return True
2453 def get_salt_interface(vm_, opts):
2454     salt_host = salt.config.get_cloud_config_value(
2455         "salt_interface", vm_, opts, default=False, search_global=False
2456     )
2457     if salt_host is False:
2458         salt_host = salt.config.get_cloud_config_value(
2459             "ssh_interface", vm_, opts, default="public_ips", search_global=False
2460         )
2461     return salt_host
2462 def check_key_path_and_mode(provider, key_path):
2463     if not os.path.exists(key_path):
2464         log.error(
2465             "The key file '%s' used in the '%s' provider configuration "
2466             "does not exist.\n",
2467             key_path,
2468             provider,
2469         )
2470         return False
2471     key_mode = stat.S_IMODE(os.stat(key_path).st_mode)
2472     if key_mode not in (0o400, 0o600):
2473         log.error(
2474             "The key file '%s' used in the '%s' provider configuration "
2475             "needs to be set to mode 0400 or 0600.\n",
2476             key_path,
2477             provider,
2478         )
2479         return False
2480     return True
2481 def userdata_template(opts, vm_, userdata):
2482     if userdata is None:
2483         return userdata
2484     userdata_template = salt.config.get_cloud_config_value(
2485         "userdata_template", vm_, opts, search_global=False, default=None
2486     )
2487     if userdata_template is False:
2488         return userdata
2489     renderer = (
2490         opts.get("userdata_template")
2491         if userdata_template is None
2492         else userdata_template
2493     )
2494     if renderer is None:
2495         return userdata
2496     else:
2497         render_opts = opts.copy()
2498         render_opts.update(vm_)
2499         rend = salt.loader.render(render_opts, {})
2500         blacklist = opts["renderer_blacklist"]
2501         whitelist = opts["renderer_whitelist"]
2502         templated = salt.template.compile_template(
2503             ":string:",
2504             rend,
2505             renderer,
2506             blacklist,
2507             whitelist,
2508             input_data=userdata,
2509         )
2510         if not isinstance(templated, str):
2511             try:
2512                 templated = "".join(templated.readlines())
2513             except AttributeError:
2514                 log.warning(
2515                     "Templated userdata resulted in non-string result (%s), "
2516                     "converting to string",
2517                     templated,
2518                 )
2519                 templated = str(templated)
2520         return templated
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
