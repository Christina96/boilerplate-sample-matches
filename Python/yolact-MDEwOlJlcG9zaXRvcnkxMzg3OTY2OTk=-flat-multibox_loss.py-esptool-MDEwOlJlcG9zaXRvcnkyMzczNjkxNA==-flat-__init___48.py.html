
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.330573793890949%, Tokens: 9</h2>
        <div class="column">
            <h3>yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-multibox_loss.py</h3>
            <pre><code>1  import torch
2  import torch.nn as nn
3  import torch.nn.functional as F
4  from torch.autograd import Variable
5  from ..box_utils import match, log_sum_exp, decode, center_size, crop, elemwise_mask_iou, elemwise_box_iou
6  from data import cfg, mask_type, activation_func
7  class MultiBoxLoss(nn.Module):
8      def __init__(self, num_classes, pos_threshold, neg_threshold, negpos_ratio):
9          super(MultiBoxLoss, self).__init__()
10          self.num_classes = num_classes
11          self.pos_threshold = pos_threshold
12          self.neg_threshold = neg_threshold
13          self.negpos_ratio = negpos_ratio
14          self.l1_expected_area = 20*20/70/70
15          self.l1_alpha = 0.1
16          if cfg.use_class_balanced_conf:
17              self.class_instances = None
18              self.total_instances = 0
19      def forward(self, net, predictions, targets, masks, num_crowds):
20          loc_data  = predictions['loc']
21          conf_data = predictions['conf']
22          mask_data = predictions['mask']
23          priors    = predictions['priors']
24          if cfg.mask_type == mask_type.lincomb:
25              proto_data = predictions['proto']
26          score_data = predictions['score'] if cfg.use_mask_scoring   else None   
27          inst_data  = predictions['inst']  if cfg.use_instance_coeff else None
28          labels = [None] * len(targets) # Used in sem segm loss
29          batch_size = loc_data.size(0)
30          num_priors = priors.size(0)
31          num_classes = self.num_classes
32          loc_t = loc_data.new(batch_size, num_priors, 4)
33          gt_box_t = loc_data.new(batch_size, num_priors, 4)
34          conf_t = loc_data.new(batch_size, num_priors).long()
35          idx_t = loc_data.new(batch_size, num_priors).long()
36          if cfg.use_class_existence_loss:
37              class_existence_t = loc_data.new(batch_size, num_classes-1)
38          for idx in range(batch_size):
39              truths      = targets[idx][:, :-1].data
40              labels[idx] = targets[idx][:, -1].data.long()
41              if cfg.use_class_existence_loss:
42                  class_existence_t[idx, :] = torch.eye(num_classes-1, device=conf_t.get_device())[labels[idx]].max(dim=0)[0]
43              cur_crowds = num_crowds[idx]
44              if cur_crowds > 0:
45                  split = lambda x: (x[-cur_crowds:], x[:-cur_crowds])
46                  crowd_boxes, truths = split(truths)
47                  _, labels[idx] = split(labels[idx])
48                  _, masks[idx]  = split(masks[idx])
49              else:
50                  crowd_boxes = None
51              match(self.pos_threshold, self.neg_threshold,
52                    truths, priors.data, labels[idx], crowd_boxes,
53                    loc_t, conf_t, idx_t, idx, loc_data[idx])
54              gt_box_t[idx, :, :] = truths[idx_t[idx]]
55          loc_t = Variable(loc_t, requires_grad=False)
56          conf_t = Variable(conf_t, requires_grad=False)
57          idx_t = Variable(idx_t, requires_grad=False)
58          pos = conf_t > 0
59          num_pos = pos.sum(dim=1, keepdim=True)
60          pos_idx = pos.unsqueeze(pos.dim()).expand_as(loc_data)
61          losses = {}
62          if cfg.train_boxes:
63              loc_p = loc_data[pos_idx].view(-1, 4)
64              loc_t = loc_t[pos_idx].view(-1, 4)
65              losses['B'] = F.smooth_l1_loss(loc_p, loc_t, reduction='sum') * cfg.bbox_alpha
66          if cfg.train_masks:
67              if cfg.mask_type == mask_type.direct:
68                  if cfg.use_gt_bboxes:
69                      pos_masks = []
70                      for idx in range(batch_size):
71                          pos_masks.append(masks[idx][idx_t[idx, pos[idx]]])
72                      masks_t = torch.cat(pos_masks, 0)
73                      masks_p = mask_data[pos, :].view(-1, cfg.mask_dim)
74                      losses['M'] = F.binary_cross_entropy(torch.clamp(masks_p, 0, 1), masks_t, reduction='sum') * cfg.mask_alpha
75                  else:
76                      losses['M'] = self.direct_mask_loss(pos_idx, idx_t, loc_data, mask_data, priors, masks)
77              elif cfg.mask_type == mask_type.lincomb:
78                  ret = self.lincomb_mask_loss(pos, idx_t, loc_data, mask_data, priors, proto_data, masks, gt_box_t, score_data, inst_data, labels)
79                  if cfg.use_maskiou:
80                      loss, maskiou_targets = ret
81                  else:
82                      loss = ret
83                  losses.update(loss)
84                  if cfg.mask_proto_loss is not None:
85                      if cfg.mask_proto_loss == 'l1':
86                          losses['P'] = torch.mean(torch.abs(proto_data)) / self.l1_expected_area * self.l1_alpha
87                      elif cfg.mask_proto_loss == 'disj':
88                          losses['P'] = -torch.mean(torch.max(F.log_softmax(proto_data, dim=-1), dim=-1)[0])
89          if cfg.use_focal_loss:
90              if cfg.use_sigmoid_focal_loss:
91                  losses['C'] = self.focal_conf_sigmoid_loss(conf_data, conf_t)
92              elif cfg.use_objectness_score:
93                  losses['C'] = self.focal_conf_objectness_loss(conf_data, conf_t)
94              else:
95                  losses['C'] = self.focal_conf_loss(conf_data, conf_t)
96          else:
97              if cfg.use_objectness_score:
98                  losses['C'] = self.conf_objectness_loss(conf_data, conf_t, batch_size, loc_p, loc_t, priors)
99              else:
100                  losses['C'] = self.ohem_conf_loss(conf_data, conf_t, pos, batch_size)
101          if cfg.use_maskiou and maskiou_targets is not None:
102              losses['I'] = self.mask_iou_loss(net, maskiou_targets)
103          if cfg.use_class_existence_loss:
104              losses['E'] = self.class_existence_loss(predictions['classes'], class_existence_t)
105          if cfg.use_semantic_segmentation_loss:
106              losses['S'] = self.semantic_segmentation_loss(predictions['segm'], masks, labels)
107          total_num_pos = num_pos.data.sum().float()
108          for k in losses:
109              if k not in ('P', 'E', 'S'):
110                  losses[k] /= total_num_pos
111              else:
112                  losses[k] /= batch_size
113          return losses
114      def class_existence_loss(self, class_data, class_existence_t):
115          return cfg.class_existence_alpha * F.binary_cross_entropy_with_logits(class_data, class_existence_t, reduction='sum')
116      def semantic_segmentation_loss(self, segment_data, mask_t, class_t, interpolation_mode='bilinear'):
117          batch_size, num_classes, mask_h, mask_w = segment_data.size()
118          loss_s = 0
119          for idx in range(batch_size):
120              cur_segment = segment_data[idx]
121              cur_class_t = class_t[idx]
122              with torch.no_grad():
123                  downsampled_masks = F.interpolate(mask_t[idx].unsqueeze(0), (mask_h, mask_w),
124                                                    mode=interpolation_mode, align_corners=False).squeeze(0)
125                  downsampled_masks = downsampled_masks.gt(0.5).float()
126                  segment_t = torch.zeros_like(cur_segment, requires_grad=False)
127                  for obj_idx in range(downsampled_masks.size(0)):
128                      segment_t[cur_class_t[obj_idx]] = torch.max(segment_t[cur_class_t[obj_idx]], downsampled_masks[obj_idx])
129              loss_s += F.binary_cross_entropy_with_logits(cur_segment, segment_t, reduction='sum')
130          return loss_s / mask_h / mask_w * cfg.semantic_segmentation_alpha
131      def ohem_conf_loss(self, conf_data, conf_t, pos, num):
132          batch_conf = conf_data.view(-1, self.num_classes)
133          if cfg.ohem_use_most_confident:
134              batch_conf = F.softmax(batch_conf, dim=1)
135              loss_c, _ = batch_conf[:, 1:].max(dim=1)
136          else:
137              loss_c = log_sum_exp(batch_conf) - batch_conf[:, 0]
138          loss_c = loss_c.view(num, -1)
139          loss_c[pos]        = 0 # filter out pos boxes
140          loss_c[conf_t < 0] = 0 # filter out neutrals (conf_t = -1)
141          _, loss_idx = loss_c.sort(1, descending=True)
142          _, idx_rank = loss_idx.sort(1)
143          num_pos = pos.long().sum(1, keepdim=True)
144          num_neg = torch.clamp(self.negpos_ratio*num_pos, max=pos.size(1)-1)
145          neg = idx_rank < num_neg.expand_as(idx_rank)
146          neg[pos]        = 0
147          neg[conf_t < 0] = 0 # Filter out neutrals
148          pos_idx = pos.unsqueeze(2).expand_as(conf_data)
149          neg_idx = neg.unsqueeze(2).expand_as(conf_data)
150          conf_p = conf_data[(pos_idx+neg_idx).gt(0)].view(-1, self.num_classes)
151          targets_weighted = conf_t[(pos+neg).gt(0)]
152          loss_c = F.cross_entropy(conf_p, targets_weighted, reduction='none')
153          if cfg.use_class_balanced_conf:
154              if self.class_instances is None:
155                  self.class_instances = torch.zeros(self.num_classes, device=targets_weighted.device)
156              classes, counts = targets_weighted.unique(return_counts=True)
157              for _cls, _cnt in zip(classes.cpu().numpy(), counts.cpu().numpy()):
158                  self.class_instances[_cls] += _cnt
159              self.total_instances += targets_weighted.size(0)
160              weighting = 1 - (self.class_instances[targets_weighted] / self.total_instances)
161              weighting = torch.clamp(weighting, min=1/self.num_classes)
162              avg_weight = (self.num_classes - 1) / self.num_classes
163              loss_c = (loss_c * weighting).sum() / avg_weight
164          else:
165              loss_c = loss_c.sum()
166          return cfg.conf_alpha * loss_c
167      def focal_conf_loss(self, conf_data, conf_t):
168          conf_t = conf_t.view(-1) # [batch_size*num_priors]
169          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
170          keep = (conf_t >= 0).float()
171          conf_t[conf_t < 0] = 0 # so that gather doesn't drum up a fuss
172          logpt = F.log_softmax(conf_data, dim=-1)
173          logpt = logpt.gather(1, conf_t.unsqueeze(-1))
174          logpt = logpt.view(-1)
175          pt    = logpt.exp()
176          background = (conf_t == 0).float()
177          at = (1 - cfg.focal_loss_alpha) * background + cfg.focal_loss_alpha * (1 - background)
178          loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
179          return cfg.conf_alpha * (loss * keep).sum()
180      def focal_conf_sigmoid_loss(self, conf_data, conf_t):
181          num_classes = conf_data.size(-1)
182          conf_t = conf_t.view(-1) # [batch_size*num_priors]
183          conf_data = conf_data.view(-1, num_classes) # [batch_size*num_priors, num_classes]
184          keep = (conf_t >= 0).float()
185          conf_t[conf_t < 0] = 0 # can't mask with -1, so filter that out
186          conf_one_t = torch.eye(num_classes, device=conf_t.get_device())[conf_t]
187          conf_pm_t  = conf_one_t * 2 - 1 # -1 if background, +1 if forground for specific class
188          logpt = F.logsigmoid(conf_data * conf_pm_t) # note: 1 - sigmoid(x) = sigmoid(-x)
189          pt    = logpt.exp()
190          at = cfg.focal_loss_alpha * conf_one_t + (1 - cfg.focal_loss_alpha) * (1 - conf_one_t)
191          at[..., 0] = 0 # Set alpha for the background class to 0 because sigmoid focal loss doesn't use it
192          loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
193          loss = keep * loss.sum(dim=-1)
194          return cfg.conf_alpha * loss.sum()
195      def focal_conf_objectness_loss(self, conf_data, conf_t):
<span onclick='openModal()' class='match'>196          conf_t = conf_t.view(-1) # [batch_size*num_priors]
197          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
198          keep = (conf_t >= 0).float()
</span>199          conf_t[conf_t < 0] = 0 # so that gather doesn't drum up a fuss
200          background = (conf_t == 0).float()
201          at = (1 - cfg.focal_loss_alpha) * background + cfg.focal_loss_alpha * (1 - background)
202          logpt = F.logsigmoid(conf_data[:, 0]) * (1 - background) + F.logsigmoid(-conf_data[:, 0]) * background
203          pt    = logpt.exp()
204          obj_loss = -at * (1 - pt) ** cfg.focal_loss_gamma * logpt
205          pos_mask = conf_t > 0
206          conf_data_pos = (conf_data[:, 1:])[pos_mask] # Now this has just 80 classes
207          conf_t_pos    = conf_t[pos_mask] - 1         # So subtract 1 here
208          class_loss = F.cross_entropy(conf_data_pos, conf_t_pos, reduction='sum')
209          return cfg.conf_alpha * (class_loss + (obj_loss * keep).sum())
210      def conf_objectness_loss(self, conf_data, conf_t, batch_size, loc_p, loc_t, priors):
211          conf_t = conf_t.view(-1) # [batch_size*num_priors]
212          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
213          pos_mask = (conf_t > 0)
214          neg_mask = (conf_t == 0)
215          obj_data = conf_data[:, 0]
216          obj_data_pos = obj_data[pos_mask]
217          obj_data_neg = obj_data[neg_mask]
218          obj_neg_loss = - F.logsigmoid(-obj_data_neg).sum()
219          with torch.no_grad():
220              pos_priors = priors.unsqueeze(0).expand(batch_size, -1, -1).reshape(-1, 4)[pos_mask, :]
221              boxes_pred = decode(loc_p, pos_priors, cfg.use_yolo_regressors)
222              boxes_targ = decode(loc_t, pos_priors, cfg.use_yolo_regressors)
223              iou_targets = elemwise_box_iou(boxes_pred, boxes_targ)
224          obj_pos_loss = - iou_targets * F.logsigmoid(obj_data_pos) - (1 - iou_targets) * F.logsigmoid(-obj_data_pos)
225          obj_pos_loss = obj_pos_loss.sum()
226          conf_data_pos = (conf_data[:, 1:])[pos_mask] # Now this has just 80 classes
227          conf_t_pos    = conf_t[pos_mask] - 1         # So subtract 1 here
228          class_loss = F.cross_entropy(conf_data_pos, conf_t_pos, reduction='sum')
229          return cfg.conf_alpha * (class_loss + obj_pos_loss + obj_neg_loss)
230      def direct_mask_loss(self, pos_idx, idx_t, loc_data, mask_data, priors, masks):
231          loss_m = 0
232          for idx in range(mask_data.size(0)):
233              with torch.no_grad():
234                  cur_pos_idx = pos_idx[idx, :, :]
235                  cur_pos_idx_squeezed = cur_pos_idx[:, 1]
236                  pos_bboxes = decode(loc_data[idx, :, :], priors.data, cfg.use_yolo_regressors)
237                  pos_bboxes = pos_bboxes[cur_pos_idx].view(-1, 4).clamp(0, 1)
238                  pos_lookup = idx_t[idx, cur_pos_idx_squeezed]
239                  cur_masks = masks[idx]
240                  pos_masks = cur_masks[pos_lookup, :, :]
241                  num_pos, img_height, img_width = pos_masks.size()
242                  x1, x2 = sanitize_coordinates(pos_bboxes[:, 0], pos_bboxes[:, 2], img_width)
243                  y1, y2 = sanitize_coordinates(pos_bboxes[:, 1], pos_bboxes[:, 3], img_height)
244                  scaled_masks = []
245                  for jdx in range(num_pos):
246                      tmp_mask = pos_masks[jdx, y1[jdx]:y2[jdx], x1[jdx]:x2[jdx]]
247                      while tmp_mask.dim() < 2:
248                          tmp_mask = tmp_mask.unsqueeze(0)
249                      new_mask = F.adaptive_avg_pool2d(tmp_mask.unsqueeze(0), cfg.mask_size)
250                      scaled_masks.append(new_mask.view(1, -1))
251                  mask_t = torch.cat(scaled_masks, 0).gt(0.5).float() # Threshold downsampled mask
252              pos_mask_data = mask_data[idx, cur_pos_idx_squeezed, :]
253              loss_m += F.binary_cross_entropy(torch.clamp(pos_mask_data, 0, 1), mask_t, reduction='sum') * cfg.mask_alpha
254          return loss_m
255      def coeff_diversity_loss(self, coeffs, instance_t):
256          num_pos = coeffs.size(0)
257          instance_t = instance_t.view(-1) # juuuust to make sure
258          coeffs_norm = F.normalize(coeffs, dim=1)
259          cos_sim = coeffs_norm @ coeffs_norm.t()
260          inst_eq = (instance_t[:, None].expand_as(cos_sim) == instance_t[None, :].expand_as(cos_sim)).float()
261          cos_sim = (cos_sim + 1) / 2
262          loss = (1 - cos_sim) * inst_eq + cos_sim * (1 - inst_eq)
263          return cfg.mask_proto_coeff_diversity_alpha * loss.sum() / num_pos
264      def lincomb_mask_loss(self, pos, idx_t, loc_data, mask_data, priors, proto_data, masks, gt_box_t, score_data, inst_data, labels, interpolation_mode='bilinear'):
265          mask_h = proto_data.size(1)
266          mask_w = proto_data.size(2)
267          process_gt_bboxes = cfg.mask_proto_normalize_emulate_roi_pooling or cfg.mask_proto_crop
268          if cfg.mask_proto_remove_empty_masks:
269              pos = pos.clone()
270          loss_m = 0
271          loss_d = 0 # Coefficient diversity loss
272          maskiou_t_list = []
273          maskiou_net_input_list = []
274          label_t_list = []
275          for idx in range(mask_data.size(0)):
276              with torch.no_grad():
277                  downsampled_masks = F.interpolate(masks[idx].unsqueeze(0), (mask_h, mask_w),
278                                                    mode=interpolation_mode, align_corners=False).squeeze(0)
279                  downsampled_masks = downsampled_masks.permute(1, 2, 0).contiguous()
280                  if cfg.mask_proto_binarize_downsampled_gt:
281                      downsampled_masks = downsampled_masks.gt(0.5).float()
282                  if cfg.mask_proto_remove_empty_masks:
283                      very_small_masks = (downsampled_masks.sum(dim=(0,1)) <= 0.0001)
284                      for i in range(very_small_masks.size(0)):
285                          if very_small_masks[i]:
286                              pos[idx, idx_t[idx] == i] = 0
287                  if cfg.mask_proto_reweight_mask_loss:
288                      if not cfg.mask_proto_binarize_downsampled_gt:
289                          bin_gt = downsampled_masks.gt(0.5).float()
290                      else:
291                          bin_gt = downsampled_masks
292                      gt_foreground_norm = bin_gt     / (torch.sum(bin_gt,   dim=(0,1), keepdim=True) + 0.0001)
293                      gt_background_norm = (1-bin_gt) / (torch.sum(1-bin_gt, dim=(0,1), keepdim=True) + 0.0001)
294                      mask_reweighting   = gt_foreground_norm * cfg.mask_proto_reweight_coeff + gt_background_norm
295                      mask_reweighting  *= mask_h * mask_w
296              cur_pos = pos[idx]
297              pos_idx_t = idx_t[idx, cur_pos]
298              if process_gt_bboxes:
299                  if cfg.mask_proto_crop_with_pred_box:
300                      pos_gt_box_t = decode(loc_data[idx, :, :], priors.data, cfg.use_yolo_regressors)[cur_pos]
301                  else:
302                      pos_gt_box_t = gt_box_t[idx, cur_pos]
303              if pos_idx_t.size(0) == 0:
304                  continue
305              proto_masks = proto_data[idx]
306              proto_coef  = mask_data[idx, cur_pos, :]
307              if cfg.use_mask_scoring:
308                  mask_scores = score_data[idx, cur_pos, :]
309              if cfg.mask_proto_coeff_diversity_loss:
310                  if inst_data is not None:
311                      div_coeffs = inst_data[idx, cur_pos, :]
312                  else:
313                      div_coeffs = proto_coef
314                  loss_d += self.coeff_diversity_loss(div_coeffs, pos_idx_t)
315              old_num_pos = proto_coef.size(0)
316              if old_num_pos > cfg.masks_to_train:
317                  perm = torch.randperm(proto_coef.size(0))
318                  select = perm[:cfg.masks_to_train]
319                  proto_coef = proto_coef[select, :]
320                  pos_idx_t  = pos_idx_t[select]
321                  if process_gt_bboxes:
322                      pos_gt_box_t = pos_gt_box_t[select, :]
323                  if cfg.use_mask_scoring:
324                      mask_scores = mask_scores[select, :]
325              num_pos = proto_coef.size(0)
326              mask_t = downsampled_masks[:, :, pos_idx_t]     
327              label_t = labels[idx][pos_idx_t]     
328              pred_masks = proto_masks @ proto_coef.t()
329              pred_masks = cfg.mask_proto_mask_activation(pred_masks)
330              if cfg.mask_proto_double_loss:
331                  if cfg.mask_proto_mask_activation == activation_func.sigmoid:
332                      pre_loss = F.binary_cross_entropy(torch.clamp(pred_masks, 0, 1), mask_t, reduction='sum')
333                  else:
334                      pre_loss = F.smooth_l1_loss(pred_masks, mask_t, reduction='sum')
335                  loss_m += cfg.mask_proto_double_loss_alpha * pre_loss
336              if cfg.mask_proto_crop:
337                  pred_masks = crop(pred_masks, pos_gt_box_t)
338              if cfg.mask_proto_mask_activation == activation_func.sigmoid:
339                  pre_loss = F.binary_cross_entropy(torch.clamp(pred_masks, 0, 1), mask_t, reduction='none')
340              else:
341                  pre_loss = F.smooth_l1_loss(pred_masks, mask_t, reduction='none')
342              if cfg.mask_proto_normalize_mask_loss_by_sqrt_area:
343                  gt_area  = torch.sum(mask_t, dim=(0, 1), keepdim=True)
344                  pre_loss = pre_loss / (torch.sqrt(gt_area) + 0.0001)
345              if cfg.mask_proto_reweight_mask_loss:
346                  pre_loss = pre_loss * mask_reweighting[:, :, pos_idx_t]
347              if cfg.mask_proto_normalize_emulate_roi_pooling:
348                  weight = mask_h * mask_w if cfg.mask_proto_crop else 1
349                  pos_gt_csize = center_size(pos_gt_box_t)
350                  gt_box_width  = pos_gt_csize[:, 2] * mask_w
351                  gt_box_height = pos_gt_csize[:, 3] * mask_h
352                  pre_loss = pre_loss.sum(dim=(0, 1)) / gt_box_width / gt_box_height * weight
353              if old_num_pos > num_pos:
354                  pre_loss *= old_num_pos / num_pos
355              loss_m += torch.sum(pre_loss)
356              if cfg.use_maskiou:
357                  if cfg.discard_mask_area > 0:
358                      gt_mask_area = torch.sum(mask_t, dim=(0, 1))
359                      select = gt_mask_area > cfg.discard_mask_area
360                      if torch.sum(select) < 1:
361                          continue
362                      pos_gt_box_t = pos_gt_box_t[select, :]
363                      pred_masks = pred_masks[:, :, select]
364                      mask_t = mask_t[:, :, select]
365                      label_t = label_t[select]
366                  maskiou_net_input = pred_masks.permute(2, 0, 1).contiguous().unsqueeze(1)
367                  pred_masks = pred_masks.gt(0.5).float()                
368                  maskiou_t = self._mask_iou(pred_masks, mask_t)
369                  maskiou_net_input_list.append(maskiou_net_input)
370                  maskiou_t_list.append(maskiou_t)
371                  label_t_list.append(label_t)
372          losses = {'M': loss_m * cfg.mask_alpha / mask_h / mask_w}
373          if cfg.mask_proto_coeff_diversity_loss:
374              losses['D'] = loss_d
375          if cfg.use_maskiou:
376              if len(maskiou_t_list) == 0:
377                  return losses, None
378              maskiou_t = torch.cat(maskiou_t_list)
379              label_t = torch.cat(label_t_list)
380              maskiou_net_input = torch.cat(maskiou_net_input_list)
381              num_samples = maskiou_t.size(0)
382              if cfg.maskious_to_train > 0 and num_samples > cfg.maskious_to_train:
383                  perm = torch.randperm(num_samples)
384                  select = perm[:cfg.masks_to_train]
385                  maskiou_t = maskiou_t[select]
386                  label_t = label_t[select]
387                  maskiou_net_input = maskiou_net_input[select]
388              return losses, [maskiou_net_input, maskiou_t, label_t]
389          return losses
390      def _mask_iou(self, mask1, mask2):
391          intersection = torch.sum(mask1*mask2, dim=(0, 1))
392          area1 = torch.sum(mask1, dim=(0, 1))
393          area2 = torch.sum(mask2, dim=(0, 1))
394          union = (area1 + area2) - intersection
395          ret = intersection / union
396          return ret
397      def mask_iou_loss(self, net, maskiou_targets):
398          maskiou_net_input, maskiou_t, label_t = maskiou_targets
399          maskiou_p = net.maskiou_net(maskiou_net_input)
400          label_t = label_t[:, None]
401          maskiou_p = torch.gather(maskiou_p, dim=1, index=label_t).view(-1)
402          loss_i = F.smooth_l1_loss(maskiou_p, maskiou_t, reduction='sum')
403          return loss_i * cfg.maskiou_alpha
</code></pre>
        </div>
        <div class="column">
            <h3>esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___48.py</h3>
            <pre><code>1  import argparse
2  import hashlib
3  import operator
4  import os
5  import struct
6  import sys
7  import tempfile
8  import zlib
9  from collections import namedtuple
10  from cryptography import exceptions
11  from cryptography.hazmat.backends import default_backend
12  from cryptography.hazmat.primitives import hashes
13  from cryptography.hazmat.primitives import serialization
14  from cryptography.hazmat.primitives.asymmetric import ec, padding, rsa, utils
15  from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
16  from cryptography.utils import int_to_bytes
17  import ecdsa
18  import esptool
19  SIG_BLOCK_MAGIC = 0xE7
20  SIG_BLOCK_VERSION_RSA = 0x02
21  SIG_BLOCK_VERSION_ECDSA = 0x03
22  CURVE_ID_P192 = 1
23  CURVE_ID_P256 = 2
24  SECTOR_SIZE = 4096
25  SIG_BLOCK_SIZE = (
26      1216  # Refer to secure boot v2 signature block format for more details.
27  )
28  def get_chunks(source, chunk_len):
29      return (source[i : i + chunk_len] for i in range(0, len(source), chunk_len))
30  def endian_swap_words(source):
31      assert len(source) % 4 == 0
32      words = "I" * (len(source) // 4)
33      return struct.pack("<" + words, *struct.unpack(">" + words, source))
34  def swap_word_order(source):
35      assert len(source) % 4 == 0
36      words = "I" * (len(source) // 4)
37      return struct.pack(words, *reversed(struct.unpack(words, source)))
38  def _load_hardware_key(keyfile):
39      key = keyfile.read()
40      if len(key) not in [16, 24, 32, 64]:
41          raise esptool.FatalError(
42              "Key file contains wrong length (%d bytes), 16, 24, 32 or 64 expected."
43              % len(key)
44          )
45      if len(key) == 16:
46          key = _sha256_digest(key)
47          print("Using 128-bit key (extended)")
48      elif len(key) == 24:
49          key = key + key[8:16]
50          assert len(key) == 32
51          print("Using 192-bit key (extended)")
52      elif len(key) == 32:
53          print("Using 256-bit key")
54      else:
55          print("Using 512-bit key")
56      return key
57  def digest_secure_bootloader(args):
58      _check_output_is_not_input(args.keyfile, args.output)
59      _check_output_is_not_input(args.image, args.output)
60      _check_output_is_not_input(args.iv, args.output)
61      if args.iv is not None:
62          print("WARNING: --iv argument is for TESTING PURPOSES ONLY")
63          iv = args.iv.read(128)
64      else:
65          iv = os.urandom(128)
66      plaintext_image = args.image.read()
67      args.image.seek(0)
68      fw_image = esptool.bin_image.ESP32FirmwareImage(args.image)
69      if fw_image.append_digest:
70          if len(plaintext_image) % 128 <= 32:
71              new_len = len(plaintext_image) - (len(plaintext_image) % 128)
72              plaintext_image = plaintext_image[:new_len]
73      if len(plaintext_image) % 128 != 0:
74          plaintext_image += b"\xFF" * (128 - (len(plaintext_image) % 128))
75      plaintext = iv + plaintext_image
76      key = _load_hardware_key(args.keyfile)
77      backend = default_backend()
78      cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=backend)
79      encryptor = cipher.encryptor()
80      digest = hashlib.sha512()
81      for block in get_chunks(plaintext, 16):
82          block = block[::-1]  # reverse each input block
83          cipher_block = encryptor.update(block)
84          cipher_block = cipher_block[::-1]
85          for block in get_chunks(cipher_block, 4):
86              digest.update(block[::-1])
87      if args.output is None:
88          args.output = os.path.splitext(args.image.name)[0] + "-digest-0x0000.bin"
89      with open(args.output, "wb") as f:
90          f.write(iv)
91          digest = digest.digest()
92          for word in get_chunks(digest, 4):
93              f.write(word[::-1])  # swap word order in the result
94          f.write(b"\xFF" * (0x1000 - f.tell()))  # pad to 0x1000
95          f.write(plaintext_image)
96      print("digest+image written to %s" % args.output)
97  def _generate_ecdsa_signing_key(curve_id, keyfile):
98      sk = ecdsa.SigningKey.generate(curve=curve_id)
99      with open(keyfile, "wb") as f:
100          f.write(sk.to_pem())
101  def generate_signing_key(args):
102      if os.path.exists(args.keyfile):
103          raise esptool.FatalError("ERROR: Key file %s already exists" % args.keyfile)
104      if args.version == "1":
105          if hasattr(args, "scheme"):
106              if args.scheme != "ecdsa256" and args.scheme is not None:
107                  raise esptool.FatalError("ERROR: V1 only supports ECDSA256")
108          _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
109          print("ECDSA NIST256p private key in PEM format written to %s" % args.keyfile)
110      elif args.version == "2":
111          if args.scheme == "rsa3072" or args.scheme is None:
112              private_key = rsa.generate_private_key(
113                  public_exponent=65537, key_size=3072, backend=default_backend()
114              ).private_bytes(
115                  encoding=serialization.Encoding.PEM,
116                  format=serialization.PrivateFormat.TraditionalOpenSSL,
117                  encryption_algorithm=serialization.NoEncryption(),
118              )
119              with open(args.keyfile, "wb") as f:
120                  f.write(private_key)
121              print("RSA 3072 private key in PEM format written to %s" % args.keyfile)
122          elif args.scheme == "ecdsa192":
123              _generate_ecdsa_signing_key(ecdsa.NIST192p, args.keyfile)
124              print(
125                  "ECDSA NIST192p private key in PEM format written to %s" % args.keyfile
126              )
127          elif args.scheme == "ecdsa256":
128              _generate_ecdsa_signing_key(ecdsa.NIST256p, args.keyfile)
129              print(
130                  "ECDSA NIST256p private key in PEM format written to %s" % args.keyfile
131              )
132          else:
133              raise esptool.FatalError(
134                  "ERROR: Unsupported signing scheme (%s)" % args.scheme
135              )
136  def load_ecdsa_signing_key(keyfile):
137      try:
138          sk = ecdsa.SigningKey.from_pem(keyfile.read())
139      except ValueError:
140          raise esptool.FatalError(
141              "Incorrect ECDSA private key specified. "
142              "Please check algorithm and/or format."
143          )
144      if sk.curve not in [ecdsa.NIST192p, ecdsa.NIST256p]:
145          raise esptool.FatalError("Supports NIST192p and NIST256p keys only")
146      return sk
147  def _load_ecdsa_signing_key(keyfile):
148      sk = load_ecdsa_signing_key(keyfile)
149      if sk.curve != ecdsa.NIST256p:
150          raise esptool.FatalError(
151              "Signing key uses incorrect curve. ESP32 Secure Boot only supports "
152              "NIST256p (openssl calls this curve 'prime256v1')"
153          )
154      return sk
155  def _load_ecdsa_verifying_key(keyfile):
156      try:
157          vk = ecdsa.VerifyingKey.from_pem(keyfile.read())
158      except ValueError:
159          raise esptool.FatalError(
160              "Incorrect ECDSA public key specified. "
161              "Please check algorithm and/or format."
162          )
163      if vk.curve != ecdsa.NIST256p:
164          raise esptool.FatalError(
165              "Signing key uses incorrect curve. ESP32 Secure Boot only supports "
166              "NIST256p (openssl calls this curve 'prime256v1')"
167          )
168      return vk
169  def _load_sbv2_signing_key(keydata):
170      sk = serialization.load_pem_private_key(
171          keydata, password=None, backend=default_backend()
172      )
173      if isinstance(sk, rsa.RSAPrivateKey):
174          if sk.key_size != 3072:
175              raise esptool.FatalError(
176                  "Key file has length %d bits. Secure boot v2 only supports RSA-3072."
177                  % sk.key_size
178              )
179          return sk
180      if isinstance(sk, ec.EllipticCurvePrivateKey):
181          if not (
182              isinstance(sk.curve, ec.SECP192R1) or isinstance(sk.curve, ec.SECP256R1)
183          ):
184              raise esptool.FatalError(
185                  "Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports "
186                  "NIST192p, NIST256p (aka prime192v1, prime256v1)"
187              )
188          return sk
189      raise esptool.FatalError("Unsupported signing key for Secure Boot V2")
190  def _load_sbv2_pub_key(keydata):
191      vk = serialization.load_pem_public_key(keydata, backend=default_backend())
192      if isinstance(vk, rsa.RSAPublicKey):
193          if vk.key_size != 3072:
194              raise esptool.FatalError(
195                  "Key file has length %d bits. Secure boot v2 only supports RSA-3072."
196                  % vk.key_size
197              )
198          return vk
199      if isinstance(vk, ec.EllipticCurvePublicKey):
200          if not (
201              isinstance(vk.curve, ec.SECP192R1) or isinstance(vk.curve, ec.SECP256R1)
202          ):
203              raise esptool.FatalError(
204                  "Key file uses incorrect curve. Secure Boot V2 + ECDSA only supports "
205                  "NIST192p, NIST256p (aka prime192v1, prime256v1)"
206              )
207          return vk
208      raise esptool.FatalError("Unsupported public key for Secure Boot V2")
209  def _get_sbv2_pub_key(keyfile):
210      key_data = keyfile.read()
211      if (
212          b"-BEGIN RSA PRIVATE KEY" in key_data
213          or b"-BEGIN EC PRIVATE KEY" in key_data
214          or b"-BEGIN PRIVATE KEY" in key_data
215      ):
216          return _load_sbv2_signing_key(key_data).public_key()
217      elif b"-BEGIN PUBLIC KEY" in key_data:
218          vk = _load_sbv2_pub_key(key_data)
219      else:
220          raise esptool.FatalError(
221              "Verification key does not appear to be an RSA Private or "
222              "Public key in PEM format. Unsupported"
223          )
224      return vk
225  def _get_sbv2_rsa_primitives(public_key):
226      primitives = namedtuple("primitives", ["n", "e", "m", "rinv"])
227      numbers = public_key.public_numbers()
228      primitives.n = numbers.n  #
229      primitives.e = numbers.e  # two public key components
230      primitives.m = -rsa._modinv(primitives.n, 1 << 32)
231      rr = 1 << (public_key.key_size * 2)
232      primitives.rinv = rr % primitives.n
233      return primitives
234  def _microecc_format(a, b, curve_len):
235      byte_len = int(curve_len / 8)
236      ab = int_to_bytes(a, byte_len)[::-1] + int_to_bytes(b, byte_len)[::-1]
237      assert len(ab) == 48 or len(ab) == 64
238      return ab
239  def sign_data(args):
240      if args.keyfile:
241          _check_output_is_not_input(args.keyfile, args.output)
242      _check_output_is_not_input(args.datafile, args.output)
243      if args.version == "1":
244          return sign_secure_boot_v1(args)
245      elif args.version == "2":
246          return sign_secure_boot_v2(args)
247  def sign_secure_boot_v1(args):
248      binary_content = args.datafile.read()
249      if args.hsm:
250          raise esptool.FatalError(
251              "Secure Boot V1 does not support signing using an "
252              "external Hardware Security Module (HSM)"
253          )
254      if args.signature:
255          print("Pre-calculated signatures found")
256          if len(args.pub_key) > 1:
257              raise esptool.FatalError("Secure Boot V1 only supports one signing key")
258          signature = args.signature[0].read()
259          vk = _load_ecdsa_verifying_key(args.pub_key[0])
260      else:
261          if len(args.keyfile) > 1:
262              raise esptool.FatalError("Secure Boot V1 only supports one signing key")
263          sk = _load_ecdsa_signing_key(args.keyfile[0])
264          signature = sk.sign_deterministic(binary_content, hashlib.sha256)
265          vk = sk.get_verifying_key()
266      vk.verify(signature, binary_content, hashlib.sha256)  # throws exception on failure
267      if args.output is None or os.path.abspath(args.output) == os.path.abspath(
268          args.datafile.name
269      ):  # append signature to input file
270          args.datafile.close()
271          outfile = open(args.datafile.name, "ab")
272      else:  # write file & signature to new file
273          outfile = open(args.output, "wb")
274          outfile.write(binary_content)
275      outfile.write(
276          struct.pack("I", 0)
277      )  # Version indicator, allow for different curves/formats later
278      outfile.write(signature)
279      outfile.close()
280      print("Signed %d bytes of data from %s" % (len(binary_content), args.datafile.name))
281  def sign_secure_boot_v2(args):
282      SIG_BLOCK_MAX_COUNT = 3
283      contents = args.datafile.read()
284      sig_block_num = 0
285      signature_sector = b""
286      signature = args.signature
287      pub_key = args.pub_key
288      if len(contents) % SECTOR_SIZE != 0:
289          if args.signature:
290              raise esptool.FatalError(
291                  "Secure Boot V2 requires the signature block to start "
292                  "from a 4KB aligned sector "
293                  "but the datafile supplied is not sector aligned."
294              )
295          else:
296              pad_by = SECTOR_SIZE - (len(contents) % SECTOR_SIZE)
297              print(
298                  f"Padding data contents by {pad_by} bytes "
299                  "so signature sector aligns at sector boundary"
300              )
301              contents += b"\xff" * pad_by
302      elif args.append_signatures:
303          while sig_block_num < SIG_BLOCK_MAX_COUNT:
304              sig_block = validate_signature_block(contents, sig_block_num)
305              if sig_block is None:
306                  break
307              signature_sector += (
308                  sig_block  # Signature sector is populated with already valid blocks
309              )
310              sig_block_num += 1
311          if len(signature_sector) % SIG_BLOCK_SIZE != 0:
312              raise esptool.FatalError("Incorrect signature sector size")
313          if sig_block_num == 0:
314              print(
315                  "No valid signature blocks found. "
316                  "Discarding --append-signature and proceeding to sign the image afresh."
317              )
318          else:
319              print(
320                  f"{sig_block_num} valid signature block(s) already present "
321                  "in the signature sector."
322              )
323              if sig_block_num == SIG_BLOCK_MAX_COUNT:
324                  raise esptool.FatalError(
325                      f"Upto {SIG_BLOCK_MAX_COUNT} signature blocks are supported. "
326                      "(For ESP32-ECO3 only 1 signature block is supported)"
327                  )
328              contents = contents[: len(contents) - SECTOR_SIZE]
329      if args.hsm:
330          if args.hsm_config is None:
331              raise esptool.FatalError(
332                  "Config file is required to generate signature using an external HSM."
333              )
334          import espsecure.esp_hsm_sign as hsm
335          try:
336              config = hsm.read_hsm_config(args.hsm_config)
337          except Exception as e:
338              raise esptool.FatalError(f"Incorrect HSM config file format ({e})")
339          if pub_key is None:
340              pub_key = extract_pubkey_from_hsm(config)
341          signature = generate_signature_using_hsm(config, contents)
342      if signature:
343          print("Pre-calculated signatures found")
344          key_count = len(pub_key)
345          if len(signature) != key_count:
346              raise esptool.FatalError(
347                  f"Number of public keys ({key_count}) not equal to "
348                  f"the number of signatures {len(signature)}."
349              )
350      else:
351          key_count = len(args.keyfile)
352      empty_signature_blocks = SIG_BLOCK_MAX_COUNT - sig_block_num
353      if key_count > empty_signature_blocks:
354          raise esptool.FatalError(
355              f"Number of keys({key_count}) more than the empty signature blocks."
356              f"({empty_signature_blocks})"
357          )
<span onclick='openModal()' class='match'>358      print(f"{key_count} signing key(s) found.")
359      digest = hashlib.sha256()
360      digest.update(contents)
361      digest = digest.digest()
</span>362      if signature:
363          signature_block = generate_signature_block_using_pre_calculated_signature(
364              signature, pub_key, digest
365          )
366      else:
367          signature_block = generate_signature_block_using_private_key(
368              args.keyfile, digest
369          )
370      if signature_block is None or len(signature_block) == 0:
371          raise esptool.FatalError("Signature Block generation failed")
372      signature_sector += signature_block
373      if (
374          len(signature_sector) < 0
375          and len(signature_sector) > SIG_BLOCK_SIZE * 3
376          and len(signature_sector) % SIG_BLOCK_SIZE != 0
377      ):
378          raise esptool.FatalError("Incorrect signature sector generation")
379      total_sig_blocks = len(signature_sector) // SIG_BLOCK_SIZE
380      signature_sector = signature_sector + (
381          b"\xff" * (SECTOR_SIZE - len(signature_sector))
382      )
383      if len(signature_sector) != SECTOR_SIZE:
384          raise esptool.FatalError("Incorrect signature sector size")
385      if args.output is None:
386          args.datafile.close()
387          args.output = args.datafile.name
388      with open(args.output, "wb") as f:
389          f.write(contents + signature_sector)
390      print(
391          f"Signed {len(contents)} bytes of data from {args.datafile.name}. "
392          f"Signature sector now has {total_sig_blocks} signature blocks."
393      )
394  def generate_signature_using_hsm(config, contents):
395      import espsecure.esp_hsm_sign as hsm
396      session = hsm.establish_session(config)
397      private_key = hsm.get_privkey_info(session, config)
398      signature = hsm.sign_payload(private_key, contents)
399      hsm.close_connection(session)
400      temp_signature_file = tempfile.TemporaryFile()
401      temp_signature_file.write(signature)
402      temp_signature_file.seek(0)
403      return [temp_signature_file]
404  def generate_signature_block_using_pre_calculated_signature(signature, pub_key, digest):
405      signature_blocks = b""
406      for sig, pk in zip(signature, pub_key):
407          try:
408              public_key = _get_sbv2_pub_key(pk)
409              signature = sig.read()
410              if isinstance(public_key, rsa.RSAPublicKey):
411                  rsa_primitives = _get_sbv2_rsa_primitives(public_key)
412                  public_key.verify(
413                      signature,
414                      digest,
415                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
416                      utils.Prehashed(hashes.SHA256()),
417                  )
418                  signature_block = generate_rsa_signature_block(
419                      digest, rsa_primitives, signature
420                  )
421              else:
422                  numbers = public_key.public_numbers()
423                  if isinstance(numbers.curve, ec.SECP192R1):
424                      curve_len = 192
425                      curve_id = CURVE_ID_P192
426                  elif isinstance(numbers.curve, ec.SECP256R1):
427                      curve_len = 256
428                      curve_id = CURVE_ID_P256
429                  else:
430                      raise esptool.FatalError("Invalid ECDSA curve instance.")
431                  public_key.verify(
432                      signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
433                  )
434                  pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
435                  r, s = utils.decode_dss_signature(signature)
436                  signature_rs = _microecc_format(r, s, curve_len)
437                  signature_block = generate_ecdsa_signature_block(
438                      digest, curve_id, pubkey_point, signature_rs
439                  )
440          except exceptions.InvalidSignature:
441              raise esptool.FatalError(
442                  "Signature verification failed: Invalid Signature\n"
443                  "The pre-calculated signature has not been signed "
444                  "using the given public key"
445              )
446          signature_block += struct.pack("<I", zlib.crc32(signature_block) & 0xFFFFFFFF)
447          signature_block += b"\x00" * 16  # padding
448          if len(signature_block) != SIG_BLOCK_SIZE:
449              raise esptool.FatalError("Incorrect signature block size")
450          signature_blocks += signature_block
451      return signature_blocks
452  def generate_signature_block_using_private_key(keyfiles, digest):
453      signature_blocks = b""
454      for keyfile in keyfiles:
455          private_key = _load_sbv2_signing_key(keyfile.read())
456          if isinstance(private_key, rsa.RSAPrivateKey):
457              signature = private_key.sign(
458                  digest,
459                  padding.PSS(
460                      mgf=padding.MGF1(hashes.SHA256()),
461                      salt_length=32,
462                  ),
463                  utils.Prehashed(hashes.SHA256()),
464              )
465              rsa_primitives = _get_sbv2_rsa_primitives(private_key.public_key())
466              signature_block = generate_rsa_signature_block(
467                  digest, rsa_primitives, signature
468              )
469          else:
470              signature = private_key.sign(
471                  digest, ec.ECDSA(utils.Prehashed(hashes.SHA256()))
472              )
473              numbers = private_key.public_key().public_numbers()
474              if isinstance(private_key.curve, ec.SECP192R1):
475                  curve_len = 192
476                  curve_id = CURVE_ID_P192
477              elif isinstance(numbers.curve, ec.SECP256R1):
478                  curve_len = 256
479                  curve_id = CURVE_ID_P256
480              else:
481                  raise esptool.FatalError("Invalid ECDSA curve instance.")
482              pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
483              r, s = utils.decode_dss_signature(signature)
484              signature_rs = _microecc_format(r, s, curve_len)
485              signature_block = generate_ecdsa_signature_block(
486                  digest, curve_id, pubkey_point, signature_rs
487              )
488          signature_block += struct.pack("<I", zlib.crc32(signature_block) & 0xFFFFFFFF)
489          signature_block += b"\x00" * 16  # padding
490          if len(signature_block) != SIG_BLOCK_SIZE:
491              raise esptool.FatalError("Incorrect signature block size")
492          signature_blocks += signature_block
493      return signature_blocks
494  def generate_rsa_signature_block(digest, rsa_primitives, signature):
495      signature_block = struct.pack(
496          "<BBxx32s384sI384sI384s",
497          SIG_BLOCK_MAGIC,
498          SIG_BLOCK_VERSION_RSA,
499          digest,
500          int_to_bytes(rsa_primitives.n)[::-1],
501          rsa_primitives.e,
502          int_to_bytes(rsa_primitives.rinv)[::-1],
503          rsa_primitives.m & 0xFFFFFFFF,
504          signature[::-1],
505      )
506      return signature_block
507  def generate_ecdsa_signature_block(digest, curve_id, pubkey_point, signature_rs):
508      signature_block = struct.pack(
509          "<BBxx32sB64s64s1031x",
510          SIG_BLOCK_MAGIC,
511          SIG_BLOCK_VERSION_ECDSA,
512          digest,
513          curve_id,
514          pubkey_point,
515          signature_rs,
516      )
517      return signature_block
518  def verify_signature(args):
519      if args.version == "1":
520          return verify_signature_v1(args)
521      elif args.version == "2":
522          return verify_signature_v2(args)
523  def verify_signature_v1(args):
524      key_data = args.keyfile.read()
525      if b"-BEGIN EC PRIVATE KEY" in key_data:
526          sk = ecdsa.SigningKey.from_pem(key_data)
527          vk = sk.get_verifying_key()
528      elif b"-BEGIN PUBLIC KEY" in key_data:
529          vk = ecdsa.VerifyingKey.from_pem(key_data)
530      elif len(key_data) == 64:
531          vk = ecdsa.VerifyingKey.from_string(key_data, curve=ecdsa.NIST256p)
532      else:
533          raise esptool.FatalError(
534              "Verification key does not appear to be an EC key in PEM format "
535              "or binary EC public key data. Unsupported"
536          )
537      if vk.curve != ecdsa.NIST256p:
538          raise esptool.FatalError(
539              "Public key uses incorrect curve. ESP32 Secure Boot only supports "
540              "NIST256p (openssl calls this curve 'prime256v1"
541          )
542      binary_content = args.datafile.read()
543      data = binary_content[0:-68]
544      sig_version, signature = struct.unpack("I64s", binary_content[-68:])
545      if sig_version != 0:
546          raise esptool.FatalError(
547              "Signature block has version %d. This version of espsecure "
548              "only supports version 0." % sig_version
549          )
550      print("Verifying %d bytes of data" % len(data))
551      try:
552          if vk.verify(signature, data, hashlib.sha256):
553              print("Signature is valid")
554          else:
555              raise esptool.FatalError("Signature is not valid")
556      except ecdsa.keys.BadSignatureError:
557          raise esptool.FatalError("Signature is not valid")
558  def validate_signature_block(image_content, sig_blk_num):
559      offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
560      sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
561      assert len(sig_blk) == SIG_BLOCK_SIZE
562      magic, version, _, _, _, _, _, _, blk_crc = struct.unpack(
563          "<BBxx32s384sI384sI384sI16x", sig_blk
564      )
565      calc_crc = zlib.crc32(sig_blk[:1196])
566      is_invalid_block = magic != SIG_BLOCK_MAGIC
567      is_invalid_block |= version not in [SIG_BLOCK_VERSION_RSA, SIG_BLOCK_VERSION_ECDSA]
568      if is_invalid_block or blk_crc != calc_crc & 0xFFFFFFFF:  # Signature block invalid
569          return None
570      key_type = "RSA" if version == SIG_BLOCK_VERSION_RSA else "ECDSA"
571      print(f"Signature block {sig_blk_num} is valid ({key_type}).")
572      return sig_blk
573  def verify_signature_v2(args):
574      keyfile = args.keyfile
575      if args.hsm:
576          if args.hsm_config is None:
577              raise esptool.FatalError(
578                  "Config file is required to extract public key from an external HSM."
579              )
580          import espsecure.esp_hsm_sign as hsm
581          try:
582              config = hsm.read_hsm_config(args.hsm_config)
583          except Exception as e:
584              raise esptool.FatalError(f"Incorrect HSM config file format ({e})")
585          keyfile = extract_pubkey_from_hsm(config)[0]
586      vk = _get_sbv2_pub_key(keyfile)
587      if isinstance(vk, rsa.RSAPublicKey):
588          SIG_BLOCK_MAX_COUNT = 3
589      elif isinstance(vk, ec.EllipticCurvePublicKey):
590          SIG_BLOCK_MAX_COUNT = 1
591      image_content = args.datafile.read()
592      if len(image_content) < SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
593          raise esptool.FatalError(
594              "Invalid datafile. Data size should be non-zero & a multiple of 4096."
595          )
596      digest = digest = hashlib.sha256()
597      digest.update(image_content[:-SECTOR_SIZE])
598      digest = digest.digest()
599      valid = False
600      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
601          sig_blk = validate_signature_block(image_content, sig_blk_num)
602          if sig_blk is None:
603              print(f"Signature block {sig_blk_num} invalid. Skipping.")
604              continue
605          _, version, blk_digest = struct.unpack("<BBxx32s", sig_blk[:36])
606          if blk_digest != digest:
607              raise esptool.FatalError(
608                  "Signature block image digest does not match "
609                  f"the actual image digest {digest}. Expected {blk_digest}."
610              )
611          try:
612              if isinstance(vk, rsa.RSAPublicKey):
613                  _, _, _, _, signature, _ = struct.unpack(
614                      "<384sI384sI384sI16x", sig_blk[36:]
615                  )
616                  vk.verify(
617                      signature[::-1],
618                      digest,
619                      padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32),
620                      utils.Prehashed(hashes.SHA256()),
621                  )
622              else:
623                  curve_id, _pubkey, encoded_rs = struct.unpack(
624                      "B64s64s1031x4x16x", sig_blk[36:]
625                  )
626                  assert curve_id in (CURVE_ID_P192, CURVE_ID_P256)
627                  keylen = (
628                      24 if curve_id == CURVE_ID_P192 else 32
629                  )  # length of each number in the keypair
630                  r = int.from_bytes(encoded_rs[:keylen], "little")
631                  s = int.from_bytes(encoded_rs[keylen : keylen * 2], "little")
632                  signature = utils.encode_dss_signature(r, s)
633                  vk.verify(signature, digest, ec.ECDSA(utils.Prehashed(hashes.SHA256())))
634              key_type = "RSA" if isinstance(vk, rsa.RSAPublicKey) else "ECDSA"
635              print(
636                  f"Signature block {sig_blk_num} verification successful using "
637                  f"the supplied key ({key_type})."
638              )
639              valid = True
640          except exceptions.InvalidSignature:
641              print(
642                  f"Signature block {sig_blk_num} is not signed by the supplied key. "
643                  "Checking the next block"
644              )
645              continue
646      if not valid:
647          raise esptool.FatalError(
648              "Checked all blocks. Signature could not be verified with the provided key."
649          )
650  def extract_public_key(args):
651      _check_output_is_not_input(args.keyfile, args.public_keyfile)
652      if args.version == "1":
653          sk = _load_ecdsa_signing_key(args.keyfile)
654          vk = sk.get_verifying_key()
655          args.public_keyfile.write(vk.to_string())
656      elif args.version == "2":
657          sk = _load_sbv2_signing_key(args.keyfile.read())
658          vk = sk.public_key().public_bytes(
659              encoding=serialization.Encoding.PEM,
660              format=serialization.PublicFormat.SubjectPublicKeyInfo,
661          )
662          args.public_keyfile.write(vk)
663      print(
664          "%s public key extracted to %s" % (args.keyfile.name, args.public_keyfile.name)
665      )
666  def extract_pubkey_from_hsm(config):
667      import espsecure.esp_hsm_sign as hsm
668      session = hsm.establish_session(config)
669      public_key = hsm.get_pubkey(session, config)
670      hsm.close_connection(session)
671      pem = public_key.public_bytes(
672          encoding=serialization.Encoding.PEM,
673          format=serialization.PublicFormat.SubjectPublicKeyInfo,
674      )
675      temp_pub_key_file = tempfile.TemporaryFile()
676      temp_pub_key_file.write(pem)
677      temp_pub_key_file.seek(0)
678      return [temp_pub_key_file]
679  def _sha256_digest(data):
680      digest = hashlib.sha256()
681      digest.update(data)
682      return digest.digest()
683  def signature_info_v2(args):
684      SIG_BLOCK_MAX_COUNT = 3
685      image_content = args.datafile.read()
686      if len(image_content) < SECTOR_SIZE or len(image_content) % SECTOR_SIZE != 0:
687          raise esptool.FatalError(
688              "Invalid datafile. Data size should be non-zero & a multiple of 4096."
689          )
690      digest = _sha256_digest(image_content[:-SECTOR_SIZE])
691      for sig_blk_num in range(SIG_BLOCK_MAX_COUNT):
692          sig_blk = validate_signature_block(image_content, sig_blk_num)
693          if sig_blk is None:
694              print(
695                  "Signature block %d absent/invalid. Skipping checking next blocks."
696                  % sig_blk_num
697              )
698              return
699          sig_data = struct.unpack("<BBxx32s384sI384sI384sI16x", sig_blk)
700          if sig_data[2] != digest:
701              raise esptool.FatalError(
702                  "Digest in signature block %d doesn't match the image digest."
703                  % (sig_blk_num)
704              )
705          offset = -SECTOR_SIZE + sig_blk_num * SIG_BLOCK_SIZE
706          sig_blk = image_content[offset : offset + SIG_BLOCK_SIZE]
707          if sig_data[1] == SIG_BLOCK_VERSION_RSA:
708              key_digest = _sha256_digest(sig_blk[36:812])
709          elif sig_data[1] == SIG_BLOCK_VERSION_ECDSA:
710              key_digest = _sha256_digest(sig_blk[36:101])
711          else:
712              raise esptool.FatalError(
713                  "Unsupported scheme in signature block %d" % (sig_blk_num)
714              )
715          print(
716              "Public key digest for block %d: %s"
717              % (sig_blk_num, " ".join("{:02x}".format(c) for c in bytearray(key_digest)))
718          )
719  def _digest_sbv2_public_key(keyfile):
720      public_key = _get_sbv2_pub_key(keyfile)
721      if isinstance(public_key, rsa.RSAPublicKey):
722          rsa_primitives = _get_sbv2_rsa_primitives(public_key)
723          binary_format = struct.pack(
724              "<384sI384sI",
725              int_to_bytes(rsa_primitives.n)[::-1],
726              rsa_primitives.e,
727              int_to_bytes(rsa_primitives.rinv)[::-1],
728              rsa_primitives.m & 0xFFFFFFFF,
729          )
730      else:  # ECC public key
731          numbers = public_key.public_numbers()
732          if isinstance(public_key.curve, ec.SECP192R1):
733              curve_len = 192
734              curve_id = CURVE_ID_P192
735          else:
736              curve_len = 256
737              curve_id = CURVE_ID_P256
738          pubkey_point = _microecc_format(numbers.x, numbers.y, curve_len)
739          binary_format = struct.pack(
740              "<B64s",
741              curve_id,
742              pubkey_point,
743          )
744      return hashlib.sha256(binary_format).digest()
745  def digest_sbv2_public_key(args):
746      _check_output_is_not_input(args.keyfile, args.output)
747      public_key_digest = _digest_sbv2_public_key(args.keyfile)
748      with open(args.output, "wb") as f:
749          print(
750              "Writing the public key digest of %s to %s."
751              % (args.keyfile.name, args.output)
752          )
753          f.write(public_key_digest)
754  def digest_rsa_public_key(args):
755      digest_sbv2_public_key(args)
756  def digest_private_key(args):
757      _check_output_is_not_input(args.keyfile, args.digest_file)
758      sk = _load_ecdsa_signing_key(args.keyfile)
759      repr(sk.to_string())
760      digest = hashlib.sha256()
761      digest.update(sk.to_string())
762      result = digest.digest()
763      if args.keylen == 192:
764          result = result[0:24]
765      args.digest_file.write(result)
766      print(
767          "SHA-256 digest of private key %s%s written to %s"
768          % (
769              args.keyfile.name,
770              "" if args.keylen == 256 else " (truncated to 192 bits)",
771              args.digest_file.name,
772          )
773      )
774  _FLASH_ENCRYPTION_TWEAK_PATTERN = [
775      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
776      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
777      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
778      14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
779      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
780      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
781      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
782      12, 11, 10, 9, 8, 7, 6, 5,
783      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
784      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
785      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
786      10, 9, 8, 7, 6, 5,
787      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
788      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
789      23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
790      8, 7, 6, 5
791  ]
792  assert len(_FLASH_ENCRYPTION_TWEAK_PATTERN) == 256
793  def _flash_encryption_tweak_range(flash_crypt_config=0xF):
794      tweak_range = []
795      if (flash_crypt_config & 1) != 0:
796          tweak_range += range(67)
797      if (flash_crypt_config & 2) != 0:
798          tweak_range += range(67, 132)
799      if (flash_crypt_config & 4) != 0:
800          tweak_range += range(132, 195)
801      if (flash_crypt_config & 8) != 0:
802          tweak_range += range(195, 256)
803      return tweak_range
804  def _flash_encryption_tweak_range_bits(flash_crypt_config=0xF):
805      tweak_range = 0
806      if (flash_crypt_config & 1) != 0:
807          tweak_range |= (
808              0xFFFFFFFFFFFFFFFFE00000000000000000000000000000000000000000000000
809          )
810      if (flash_crypt_config & 2) != 0:
811          tweak_range |= (
812              0x00000000000000001FFFFFFFFFFFFFFFF0000000000000000000000000000000
813          )
814      if (flash_crypt_config & 4) != 0:
815          tweak_range |= (
816              0x000000000000000000000000000000000FFFFFFFFFFFFFFFE000000000000000
817          )
818      if (flash_crypt_config & 8) != 0:
819          tweak_range |= (
820              0x0000000000000000000000000000000000000000000000001FFFFFFFFFFFFFFF
821          )
822      return tweak_range
823  mul1 = 0x0000200004000080000004000080001000000200004000080000040000800010
824  mul2 = 0x0000000000000000200000000000000010000000000000002000000000000001
825  mul1_mask = 0xFFFFFFFFFFFFFF801FFFFFFFFFFFFFF00FFFFFFFFFFFFFF81FFFFFFFFFFFFFF0
826  mul2_mask = 0x000000000000007FE00000000000000FF000000000000007E00000000000000F
827  def _flash_encryption_tweak_key(key, offset, tweak_range):
828      addr = offset >> 5
829      key ^= ((mul1 * addr) | ((mul2 * addr) & mul2_mask)) & tweak_range
830      return int.to_bytes(key, length=32, byteorder="big", signed=False)
831  def generate_flash_encryption_key(args):
832      print("Writing %d random bits to key file %s" % (args.keylen, args.key_file.name))
833      args.key_file.write(os.urandom(args.keylen // 8))
834  def _flash_encryption_operation_esp32(
835      output_file, input_file, flash_address, keyfile, flash_crypt_conf, do_decrypt
836  ):
837      key = _load_hardware_key(keyfile)
838      if flash_address % 16 != 0:
839          raise esptool.FatalError(
840              "Starting flash address 0x%x must be a multiple of 16" % flash_address
841          )
842      if flash_crypt_conf == 0:
843          print("WARNING: Setting FLASH_CRYPT_CONF to zero is not recommended")
844      tweak_range = _flash_encryption_tweak_range_bits(flash_crypt_conf)
845      key = int.from_bytes(key, byteorder="big", signed=False)
846      backend = default_backend()
847      cipher = None
848      block_offs = flash_address
849      while True:
850          block = input_file.read(16)
851          if len(block) == 0:
852              break
853          elif len(block) < 16:
854              if do_decrypt:
855                  raise esptool.FatalError("Data length is not a multiple of 16 bytes")
856              pad = 16 - len(block)
857              block = block + os.urandom(pad)
858              print(
859                  "Note: Padding with %d bytes of random data "
860                  "(encrypted data must be multiple of 16 bytes long)" % pad
861              )
862          if block_offs % 32 == 0 or cipher is None:
863              block_key = _flash_encryption_tweak_key(key, block_offs, tweak_range)
864              if cipher is None:  # first pass
865                  cipher = Cipher(algorithms.AES(block_key), modes.ECB(), backend=backend)
866                  actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
867              else:
868                  try:
869                      backend = actor._ctx._backend
870                      res = backend._lib.EVP_CipherInit_ex(
871                          actor._ctx._ctx,
872                          backend._ffi.NULL,
873                          backend._ffi.NULL,
874                          backend._ffi.from_buffer(block_key),
875                          backend._ffi.NULL,
876                          actor._ctx._operation,
877                      )
878                      backend.openssl_assert(res != 0)
879                  except AttributeError:
880                      cipher.algorithm.key = block_key
881                      actor = cipher.encryptor() if do_decrypt else cipher.decryptor()
882          block = block[::-1]  # reverse input block byte order
883          block = actor.update(block)
884          output_file.write(block[::-1])  # reverse output block byte order
885          block_offs += 16
886  def _flash_encryption_operation_aes_xts(
887      output_file, input_file, flash_address, keyfile, do_decrypt
888  ):
889      backend = default_backend()
890      key = _load_hardware_key(keyfile)
891      indata = input_file.read()
892      if flash_address % 16 != 0:
893          raise esptool.FatalError(
894              "Starting flash address 0x%x must be a multiple of 16" % flash_address
895          )
896      if len(indata) % 16 != 0:
897          raise esptool.FatalError(
898              "Input data length (%d) must be a multiple of 16" % len(indata)
899          )
900      if len(indata) == 0:
901          raise esptool.FatalError("Input data must be longer than 0")
902      pad_left = flash_address % 0x80
903      indata = (b"\x00" * pad_left) + indata
904      pad_right = len(indata) % 0x80
905      if pad_right > 0:
906          pad_right = 0x80 - pad_right
907      indata = indata + (b"\x00" * pad_right)
908      inblocks = _split_blocks(indata, 0x80)  # split into 1024 bit blocks
909      output = []
910      for inblock in inblocks:  # for each block
911          tweak = struct.pack("<I", (flash_address & ~0x7F)) + (b"\x00" * 12)
912          flash_address += 0x80  # for next block
913          if len(tweak) != 16:
914              raise esptool.FatalError(
915                  "Length of tweak must be 16, was {}".format(len(tweak))
916              )
917          cipher = Cipher(algorithms.AES(key), modes.XTS(tweak), backend=backend)
918          encryptor = cipher.decryptor() if do_decrypt else cipher.encryptor()
919          inblock = inblock[::-1]  # reverse input
920          outblock = encryptor.update(inblock)  # standard algo
921          output.append(outblock[::-1])  # reverse output
922      output = b"".join(output)
923      if pad_right != 0:
924          output = output[:-pad_right]
925      if pad_left != 0:
926          output = output[pad_left:]
927      if len(output) != len(indata) - pad_left - pad_right:
928          raise esptool.FatalError(
929              "Length of input data ({}) should match the output data ({})".format(
930                  len(indata) - pad_left - pad_right, len(output)
931              )
932          )
933      output_file.write(output)
934  def _split_blocks(text, block_len=16):
935      assert len(text) % block_len == 0
936      pos = 0
937      while pos < len(text):
938          yield text[pos : pos + block_len]
939          pos = pos + block_len
940  def decrypt_flash_data(args):
941      _check_output_is_not_input(args.keyfile, args.output)
942      _check_output_is_not_input(args.encrypted_file, args.output)
943      if args.aes_xts:
944          return _flash_encryption_operation_aes_xts(
945              args.output, args.encrypted_file, args.address, args.keyfile, True
946          )
947      else:
948          return _flash_encryption_operation_esp32(
949              args.output,
950              args.encrypted_file,
951              args.address,
952              args.keyfile,
953              args.flash_crypt_conf,
954              True,
955          )
956  def encrypt_flash_data(args):
957      _check_output_is_not_input(args.keyfile, args.output)
958      _check_output_is_not_input(args.plaintext_file, args.output)
959      if args.aes_xts:
960          return _flash_encryption_operation_aes_xts(
961              args.output, args.plaintext_file, args.address, args.keyfile, False
962          )
963      else:
964          return _flash_encryption_operation_esp32(
965              args.output,
966              args.plaintext_file,
967              args.address,
968              args.keyfile,
969              args.flash_crypt_conf,
970              False,
971          )
972  def _samefile(p1, p2):
973      return os.path.normcase(os.path.normpath(p1)) == os.path.normcase(
974          os.path.normpath(p2)
975      )
976  def _check_output_is_not_input(input_file, output_file):
977      i = getattr(input_file, "name", input_file)
978      o = getattr(output_file, "name", output_file)
979      check_f = _samefile if isinstance(i, str) and isinstance(o, str) else operator.eq
980      if check_f(i, o):
981          raise esptool.FatalError(
982              'The input "{}" and output "{}" should not be the same!'.format(i, o)
983          )
984  class OutFileType(object):
985      def __init__(self):
986          self.path = None
987          self.file_obj = None
988      def __call__(self, path):
989          self.path = path
990          return self
991      def __repr__(self):
992          return "{}({})".format(type(self).__name__, self.path)
993      def write(self, payload):
994          if len(payload) > 0:
995              if not self.file_obj:
996                  self.file_obj = open(self.path, "wb")
997              self.file_obj.write(payload)
998      def close(self):
999          if self.file_obj:
1000              self.file_obj.close()
1001              self.file_obj = None
1002      @property
1003      def name(self):
1004          return self.path
1005  def main(custom_commandline=None):
1006      parser = argparse.ArgumentParser(
1007          description="espsecure.py v%s - ESP32 Secure Boot & Flash Encryption tool"
1008          % esptool.__version__,
1009          prog="espsecure",
1010      )
1011      subparsers = parser.add_subparsers(
1012          dest="operation", help="Run espsecure.py {command} -h for additional help"
1013      )
1014      p = subparsers.add_parser(
1015          "digest_secure_bootloader",
1016          help="Take a bootloader binary image and a secure boot key, "
1017          "and output a combined digest+binary suitable for flashing along "
1018          "with the precalculated secure boot key.",
1019      )
1020      p.add_argument(
1021          "--keyfile",
1022          "-k",
1023          help="256 bit key for secure boot digest.",
1024          type=argparse.FileType("rb"),
1025          required=True,
1026      )
1027      p.add_argument("--output", "-o", help="Output file for signed digest image.")
1028      p.add_argument(
1029          "--iv",
1030          help="128 byte IV file. Supply a file for testing purposes only, "
1031          "if not supplied an IV will be randomly generated.",
1032          type=argparse.FileType("rb"),
1033      )
1034      p.add_argument(
1035          "image",
1036          help="Bootloader image file to calculate digest from",
1037          type=argparse.FileType("rb"),
1038      )
1039      p = subparsers.add_parser(
1040          "generate_signing_key",
1041          help="Generate a private key for signing secure boot images "
1042          "as per the secure boot version. "
1043          "Key file is generated in PEM format, "
1044          "Secure Boot V1 - ECDSA NIST256p private key. "
1045          "Secure Boot V2 - RSA 3072, ECDSA NIST256p, ECDSA NIST192p private key.",
1046      )
1047      p.add_argument(
1048          "--version",
1049          "-v",
1050          help="Version of the secure boot signing scheme to use.",
1051          choices=["1", "2"],
1052          default="1",
1053      )
1054      p.add_argument(
1055          "--scheme",
1056          "-s",
1057          help="Scheme of secure boot signing.",
1058          choices=["rsa3072", "ecdsa192", "ecdsa256"],
1059          required=False,
1060      )
1061      p.add_argument(
1062          "keyfile", help="Filename for private key file (embedded public key)"
1063      )
1064      p = subparsers.add_parser(
1065          "sign_data",
1066          help="Sign a data file for use with secure boot. "
1067          "Signing algorithm is deterministic ECDSA w/ SHA-512 (V1) "
1068          "or either RSA-PSS or ECDSA w/ SHA-256 (V2).",
1069      )
1070      p.add_argument(
1071          "--version",
1072          "-v",
1073          help="Version of the secure boot signing scheme to use.",
1074          choices=["1", "2"],
1075          required=True,
1076      )
1077      p.add_argument(
1078          "--keyfile",
1079          "-k",
1080          help="Private key file for signing. Key is in PEM format.",
1081          type=argparse.FileType("rb"),
1082          nargs="+",
1083      )
1084      p.add_argument(
1085          "--append_signatures",
1086          "-a",
1087          help="Append signature block(s) to already signed image. "
1088          "Valid only for ESP32-S2.",
1089          action="store_true",
1090      )
1091      p.add_argument(
1092          "--hsm",
1093          help="Use an external Hardware Security Module "
1094          "to generate signature using PKCS#11 interface.",
1095          action="store_true",
1096      )
1097      p.add_argument(
1098          "--hsm-config",
1099          help="Config file for the external Hardware Security Module "
1100          "to be used to generate signature.",
1101          default=None,
1102      )
1103      p.add_argument(
1104          "--pub-key",
1105          help="Public key files corresponding to the private key used to generate "
1106          "the pre-calculated signatures. Keys should be in PEM format.",
1107          type=argparse.FileType("rb"),
1108          nargs="+",
1109      )
1110      p.add_argument(
1111          "--signature",
1112          help="Pre-calculated signatures. "
1113          "Signatures generated using external private keys e.g. keys stored in HSM.",
1114          type=argparse.FileType("rb"),
1115          nargs="+",
1116          default=None,
1117      )
1118      p.add_argument(
1119          "--output",
1120          "-o",
1121          help="Output file for signed digest image. Default is to sign the input file.",
1122      )
1123      p.add_argument(
1124          "datafile",
1125          help="File to sign. For version 1, this can be any file. "
1126          "For version 2, this must be a valid app image.",
1127          type=argparse.FileType("rb"),
1128      )
1129      p = subparsers.add_parser(
1130          "verify_signature",
1131          help='Verify a data file previously signed by "sign_data", '
1132          "using the public key.",
1133      )
1134      p.add_argument(
1135          "--version",
1136          "-v",
1137          help="Version of the secure boot scheme to use.",
1138          choices=["1", "2"],
1139          required=True,
1140      )
1141      p.add_argument(
1142          "--hsm",
1143          help="Use an external Hardware Security Module "
1144          "to verify signature using PKCS#11 interface.",
1145          action="store_true",
1146      )
1147      p.add_argument(
1148          "--hsm-config",
1149          help="Config file for the external Hardware Security Module "
1150          "to be used to verify signature.",
1151          default=None,
1152      )
1153      p.add_argument(
1154          "--keyfile",
1155          "-k",
1156          help="Public key file for verification. "
1157          "Can be private or public key in PEM format.",
1158          type=argparse.FileType("rb"),
1159      )
1160      p.add_argument(
1161          "datafile",
1162          help="Signed data file to verify signature.",
1163          type=argparse.FileType("rb"),
1164      )
1165      p = subparsers.add_parser(
1166          "extract_public_key",
1167          help="Extract the public verification key for signatures, "
1168          "save it as a raw binary file.",
1169      )
1170      p.add_argument(
1171          "--version",
1172          "-v",
1173          help="Version of the secure boot signing scheme to use.",
1174          choices=["1", "2"],
1175          default="1",
1176      )
1177      p.add_argument(
1178          "--keyfile",
1179          "-k",
1180          help="Private key file (PEM format) to extract the "
1181          "public verification key from.",
1182          type=argparse.FileType("rb"),
1183          required=True,
1184      )
1185      p.add_argument(
1186          "public_keyfile", help="File to save new public key into", type=OutFileType()
1187      )
1188      p = subparsers.add_parser(
1189          "digest_rsa_public_key",
1190          help="Generate an SHA-256 digest of the RSA public key. "
1191          "This digest is burned into the eFuse and asserts the legitimacy "
1192          "of the public key for Secure boot v2.",
1193      )
1194      p.add_argument(
1195          "--keyfile",
1196          "-k",
1197          help="Public key file for verification. "
1198          "Can be private or public key in PEM format.",
1199          type=argparse.FileType("rb"),
1200          required=True,
1201      )
1202      p.add_argument("--output", "-o", help="Output file for the digest.", required=True)
1203      p = subparsers.add_parser(
1204          "digest_sbv2_public_key",
1205          help="Generate an SHA-256 digest of the public key. "
1206          "This digest is burned into the eFuse and asserts the legitimacy "
1207          "of the public key for Secure boot v2.",
1208      )
1209      p.add_argument(
1210          "--keyfile",
1211          "-k",
1212          help="Public key file for verification. "
1213          "Can be private or public key in PEM format.",
1214          type=argparse.FileType("rb"),
1215          required=True,
1216      )
1217      p.add_argument("--output", "-o", help="Output file for the digest.", required=True)
1218      p = subparsers.add_parser(
1219          "signature_info_v2",
1220          help="Reads the signature block and provides the signature block information.",
1221      )
1222      p.add_argument(
1223          "datafile",
1224          help="Secure boot v2 signed data file.",
1225          type=argparse.FileType("rb"),
1226      )
1227      p = subparsers.add_parser(
1228          "digest_private_key",
1229          help="Generate an SHA-256 digest of the private signing key. "
1230          "This can be used as a reproducible secure bootloader (only secure boot v1) "
1231          "or flash encryption key.",
1232      )
1233      p.add_argument(
1234          "--keyfile",
1235          "-k",
1236          help="Private key file (PEM format) to generate a digest from.",
1237          type=argparse.FileType("rb"),
1238          required=True,
1239      )
1240      p.add_argument(
1241          "--keylen",
1242          "-l",
1243          help="Length of private key digest file to generate (in bits). "
1244          "3/4 Coding Scheme requires 192 bit key.",
1245          choices=[192, 256],
1246          default=256,
1247          type=int,
1248      )
1249      p.add_argument(
1250          "digest_file", help="File to write 32 byte digest into", type=OutFileType()
1251      )
1252      p = subparsers.add_parser(
1253          "generate_flash_encryption_key",
1254          help="Generate a development-use flash encryption key with random data.",
1255      )
1256      p.add_argument(
1257          "--keylen",
1258          "-l",
1259          help="Length of private key digest file to generate (in bits). "
1260          "3/4 Coding Scheme requires 192 bit key.",
1261          choices=[128, 192, 256, 512],
1262          default=256,
1263          type=int,
1264      )
1265      p.add_argument(
1266          "key_file",
1267          help="File to write 16, 24, 32 or 64 byte key into",
1268          type=OutFileType(),
1269      )
1270      p = subparsers.add_parser(
1271          "decrypt_flash_data",
1272          help="Decrypt some data read from encrypted flash (using known key)",
1273      )
1274      p.add_argument(
1275          "encrypted_file",
1276          help="File with encrypted flash contents",
1277          type=argparse.FileType("rb"),
1278      )
1279      p.add_argument(
1280          "--aes_xts",
1281          "-x",
1282          help="Decrypt data using AES-XTS as used on "
1283          "ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6",
1284          action="store_true",
1285      )
1286      p.add_argument(
1287          "--keyfile",
1288          "-k",
1289          help="File with flash encryption key",
1290          type=argparse.FileType("rb"),
1291          required=True,
1292      )
1293      p.add_argument(
1294          "--output",
1295          "-o",
1296          help="Output file for plaintext data.",
1297          type=OutFileType(),
1298          required=True,
1299      )
1300      p.add_argument(
1301          "--address",
1302          "-a",
1303          help="Address offset in flash that file was read from.",
1304          required=True,
1305          type=esptool.arg_auto_int,
1306      )
1307      p.add_argument(
1308          "--flash_crypt_conf",
1309          help="Override FLASH_CRYPT_CONF efuse value (default is 0XF).",
1310          required=False,
1311          default=0xF,
1312          type=esptool.arg_auto_int,
1313      )
1314      p = subparsers.add_parser(
1315          "encrypt_flash_data",
1316          help="Encrypt some data suitable for encrypted flash (using known key)",
1317      )
1318      p.add_argument(
1319          "--aes_xts",
1320          "-x",
1321          help="Encrypt data using AES-XTS as used on "
1322          "ESP32-S2, ESP32-C2, ESP32-C3 and ESP32-C6",
1323          action="store_true",
1324      )
1325      p.add_argument(
1326          "--keyfile",
1327          "-k",
1328          help="File with flash encryption key",
1329          type=argparse.FileType("rb"),
1330          required=True,
1331      )
1332      p.add_argument(
1333          "--output",
1334          "-o",
1335          help="Output file for encrypted data.",
1336          type=OutFileType(),
1337          required=True,
1338      )
1339      p.add_argument(
1340          "--address",
1341          "-a",
1342          help="Address offset in flash where file will be flashed.",
1343          required=True,
1344          type=esptool.arg_auto_int,
1345      )
1346      p.add_argument(
1347          "--flash_crypt_conf",
1348          help="Override FLASH_CRYPT_CONF efuse value (default is 0XF).",
1349          required=False,
1350          default=0xF,
1351          type=esptool.arg_auto_int,
1352      )
1353      p.add_argument(
1354          "plaintext_file",
1355          help="File with plaintext content for encrypting",
1356          type=argparse.FileType("rb"),
1357      )
1358      args = parser.parse_args(custom_commandline)
1359      print("espsecure.py v%s" % esptool.__version__)
1360      if args.operation is None:
1361          parser.print_help()
1362          parser.exit(1)
1363      try:
1364          operation_func = globals()[args.operation]
1365          operation_func(args)
1366      finally:
1367          for arg_name in vars(args):
1368              obj = getattr(args, arg_name)
1369              if isinstance(obj, OutFileType):
1370                  obj.close()
1371  def _main():
1372      try:
1373          main()
1374      except esptool.FatalError as e:
1375          print("\nA fatal error occurred: %s" % e)
1376          sys.exit(2)
1377      except ValueError as e:
1378          try:
1379              if [arg for arg in e.args if "Could not deserialize key data." in arg]:
1380                  print(
1381                      "Note: This error originates from the cryptography module. "
1382                      "It is likely not a problem with espsecure, "
1383                      "please make sure you are using a compatible OpenSSL backend."
1384                  )
1385          finally:
1386              raise
1387  if __name__ == "__main__":
1388      _main()
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from yolact-MDEwOlJlcG9zaXRvcnkxMzg3OTY2OTk=-flat-multibox_loss.py</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from esptool-MDEwOlJlcG9zaXRvcnkyMzczNjkxNA==-flat-__init___48.py</div>
                <div class="column column_space"><pre><code>196          conf_t = conf_t.view(-1) # [batch_size*num_priors]
197          conf_data = conf_data.view(-1, conf_data.size(-1)) # [batch_size*num_priors, num_classes]
198          keep = (conf_t >= 0).float()
</pre></code></div>
                <div class="column column_space"><pre><code>358      print(f"{key_count} signing key(s) found.")
359      digest = hashlib.sha256()
360      digest.update(contents)
361      digest = digest.digest()
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    