<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for simple_httpclient.py &amp; nspawn.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for simple_httpclient.py &amp; nspawn.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>simple_httpclient.py (1.3592232%)<th>nspawn.py (1.088647%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(3-18)<td><a href="#" name="0">(24-38)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>simple_httpclient.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
2 from salt.ext.tornado.escape import utf8, _unicode
3 from salt.ext.tornado import gen
4 from salt.ext.tornado.httpclient import HTTPResponse, HTTPError, AsyncHTTPClient, main, _RequestProxy
5 from salt.ext.tornado import httputil
6 from salt.ext.tornado.http1connection import HTTP1Connection, HTTP1ConnectionParameters
7 from salt.ext.tornado.iostream import StreamClosedError
8 from salt.ext.tornado.netutil import Resolver, OverrideResolver, _client_ssl_defaults
9 from salt.ext.tornado.log import gen_log
10 from salt.ext.tornado import stack_context
11 from salt.ext.tornado.tcpclient import TCPClient
12 from salt.ext.tornado.util import PY3
13 import base64
14 import</b></font> collections
15 import copy
16 import functools
17 import re
18 import socket
19 import sys
20 from io import BytesIO
21 if PY3:
22     import urllib.parse as urlparse
23 else:
24     import urlparse
25 try:
26     import ssl
27 except ImportError:
28     ssl = None
29 try:
30     import certifi
31 except ImportError:
32     certifi = None
33 def _default_ca_certs():
34     if certifi is None:
35         raise Exception("The 'certifi' package is required to use https "
36                         "in simple_httpclient")
37     return certifi.where()
38 class SimpleAsyncHTTPClient(AsyncHTTPClient):
39     def initialize(self, io_loop, max_clients=10,
40                    hostname_mapping=None, max_buffer_size=104857600,
41                    resolver=None, defaults=None, max_header_size=None,
42                    max_body_size=None):
43         super(SimpleAsyncHTTPClient, self).initialize(io_loop,
44                                                       defaults=defaults)
45         self.max_clients = max_clients
46         self.queue = collections.deque()
47         self.active = {}
48         self.waiting = {}
49         self.max_buffer_size = max_buffer_size
50         self.max_header_size = max_header_size
51         self.max_body_size = max_body_size
52         if resolver:
53             self.resolver = resolver
54             self.own_resolver = False
55         else:
56             self.resolver = Resolver(io_loop=io_loop)
57             self.own_resolver = True
58         if hostname_mapping is not None:
59             self.resolver = OverrideResolver(resolver=self.resolver,
60                                              mapping=hostname_mapping)
61         self.tcp_client = TCPClient(resolver=self.resolver, io_loop=io_loop)
62     def close(self):
63         super(SimpleAsyncHTTPClient, self).close()
64         if self.own_resolver:
65             self.resolver.close()
66         self.tcp_client.close()
67     def fetch_impl(self, request, callback):
68         key = object()
69         self.queue.append((key, request, callback))
70         if not len(self.active) &lt; self.max_clients:
71             timeout_handle = self.io_loop.add_timeout(
72                 self.io_loop.time() + min(request.connect_timeout,
73                                           request.request_timeout),
74                 functools.partial(self._on_timeout, key, "in request queue"))
75         else:
76             timeout_handle = None
77         self.waiting[key] = (request, callback, timeout_handle)
78         self._process_queue()
79         if self.queue:
80             gen_log.debug("max_clients limit reached, request queued. "
81                           "%d active, %d queued requests." % (
82                               len(self.active), len(self.queue)))
83     def _process_queue(self):
84         with stack_context.NullContext():
85             while self.queue and len(self.active) &lt; self.max_clients:
86                 key, request, callback = self.queue.popleft()
87                 if key not in self.waiting:
88                     continue
89                 self._remove_timeout(key)
90                 self.active[key] = (request, callback)
91                 release_callback = functools.partial(self._release_fetch, key)
92                 self._handle_request(request, release_callback, callback)
93     def _connection_class(self):
94         return _HTTPConnection
95     def _handle_request(self, request, release_callback, final_callback):
96         self._connection_class()(
97             self.io_loop, self, request, release_callback,
98             final_callback, self.max_buffer_size, self.tcp_client,
99             self.max_header_size, self.max_body_size)
100     def _release_fetch(self, key):
101         del self.active[key]
102         self._process_queue()
103     def _remove_timeout(self, key):
104         if key in self.waiting:
105             request, callback, timeout_handle = self.waiting[key]
106             if timeout_handle is not None:
107                 self.io_loop.remove_timeout(timeout_handle)
108             del self.waiting[key]
109     def _on_timeout(self, key, info=None):
110         request, callback, timeout_handle = self.waiting[key]
111         self.queue.remove((key, request, callback))
112         error_message = "Timeout {0}".format(info) if info else "Timeout"
113         timeout_response = HTTPResponse(
114             request, 599, error=HTTPError(599, error_message),
115             request_time=self.io_loop.time() - request.start_time)
116         self.io_loop.add_callback(callback, timeout_response)
117         del self.waiting[key]
118 class _HTTPConnection(httputil.HTTPMessageDelegate):
119     _SUPPORTED_METHODS = set(["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"])
120     def __init__(self, io_loop, client, request, release_callback,
121                  final_callback, max_buffer_size, tcp_client,
122                  max_header_size, max_body_size):
123         self.start_time = io_loop.time()
124         self.io_loop = io_loop
125         self.client = client
126         self.request = request
127         self.release_callback = release_callback
128         self.final_callback = final_callback
129         self.max_buffer_size = max_buffer_size
130         self.tcp_client = tcp_client
131         self.max_header_size = max_header_size
132         self.max_body_size = max_body_size
133         self.code = None
134         self.headers = None
135         self.chunks = []
136         self._decompressor = None
137         self._timeout = None
138         self._sockaddr = None
139         with stack_context.ExceptionStackContext(self._handle_exception):
140             self.parsed = urlparse.urlsplit(_unicode(self.request.url))
141             if self.parsed.scheme not in ("http", "https"):
142                 raise ValueError("Unsupported url scheme: %s" %
143                                  self.request.url)
144             netloc = self.parsed.netloc
145             if "@" in netloc:
146                 userpass, _, netloc = netloc.rpartition("@")
147             host, port = httputil.split_host_and_port(netloc)
148             if port is None:
149                 port = 443 if self.parsed.scheme == "https" else 80
150             if re.match(r'^\[.*\]$', host):
151                 host = host[1:-1]
152             self.parsed_hostname = host  # save final host for _on_connect
153             if request.allow_ipv6 is False:
154                 af = socket.AF_INET
155             else:
156                 af = socket.AF_UNSPEC
157             ssl_options = self._get_ssl_options(self.parsed.scheme)
158             timeout = min(self.request.connect_timeout, self.request.request_timeout)
159             if timeout:
160                 self._timeout = self.io_loop.add_timeout(
161                     self.start_time + timeout,
162                     stack_context.wrap(functools.partial(self._on_timeout, "while connecting")))
163             self.tcp_client.connect(host, port, af=af,
164                                     ssl_options=ssl_options,
165                                     max_buffer_size=self.max_buffer_size,
166                                     callback=self._on_connect)
167     def _get_ssl_options(self, scheme):
168         if scheme == "https":
169             if self.request.ssl_options is not None:
170                 return self.request.ssl_options
171             if (self.request.validate_cert and
172                     self.request.ca_certs is None and
173                     self.request.client_cert is None and
174                     self.request.client_key is None):
175                 return _client_ssl_defaults
176             ssl_options = {}
177             if self.request.validate_cert:
178                 ssl_options["cert_reqs"] = ssl.CERT_REQUIRED
179             if self.request.ca_certs is not None:
180                 ssl_options["ca_certs"] = self.request.ca_certs
181             elif not hasattr(ssl, 'create_default_context'):
182                 ssl_options["ca_certs"] = _default_ca_certs()
183             if self.request.client_key is not None:
184                 ssl_options["keyfile"] = self.request.client_key
185             if self.request.client_cert is not None:
186                 ssl_options["certfile"] = self.request.client_cert
187             if sys.version_info &gt;= (2, 7):
188                 ssl_options["ciphers"] = "DEFAULT:!SSLv2:!EXPORT:!DES"
189             else:
190                 ssl_options["ssl_version"] = ssl.PROTOCOL_TLSv1
191             return ssl_options
192         return None
193     def _on_timeout(self, info=None):
194         self._timeout = None
195         error_message = "Timeout {0}".format(info) if info else "Timeout"
196         if self.final_callback is not None:
197             raise HTTPError(599, error_message)
198     def _remove_timeout(self):
199         if self._timeout is not None:
200             self.io_loop.remove_timeout(self._timeout)
201             self._timeout = None
202     def _on_connect(self, stream):
203         if self.final_callback is None:
204             stream.close()
205             return
206         self.stream = stream
207         self.stream.set_close_callback(self.on_connection_close)
208         self._remove_timeout()
209         if self.final_callback is None:
210             return
211         if self.request.request_timeout:
212             self._timeout = self.io_loop.add_timeout(
213                 self.start_time + self.request.request_timeout,
214                 stack_context.wrap(functools.partial(self._on_timeout, "during request")))
215         if (self.request.method not in self._SUPPORTED_METHODS and
216                 not self.request.allow_nonstandard_methods):
217             raise KeyError("unknown method %s" % self.request.method)
218         for key in ('network_interface',
219                     'proxy_host', 'proxy_port',
220                     'proxy_username', 'proxy_password',
221                     'proxy_auth_mode'):
222             if getattr(self.request, key, None):
223                 raise NotImplementedError('%s not supported' % key)
224         if "Connection" not in self.request.headers:
225             self.request.headers["Connection"] = "close"
226         if "Host" not in self.request.headers:
227             if '@' in self.parsed.netloc:
228                 self.request.headers["Host"] = self.parsed.netloc.rpartition('@')[-1]
229             else:
230                 self.request.headers["Host"] = self.parsed.netloc
231         username, password = None, None
232         if self.parsed.username is not None:
233             username, password = self.parsed.username, self.parsed.password
234         elif self.request.auth_username is not None:
235             username = self.request.auth_username
236             password = self.request.auth_password or ''
237         if username is not None:
238             if self.request.auth_mode not in (None, "basic"):
239                 raise ValueError("unsupported auth_mode %s",
240                                  self.request.auth_mode)
241             auth = utf8(username) + b":" + utf8(password)
242             self.request.headers["Authorization"] = (b"Basic " +
243                                                      base64.b64encode(auth))
244         if self.request.user_agent:
245             self.request.headers["User-Agent"] = self.request.user_agent
246         if not self.request.allow_nonstandard_methods:
247             body_expected = self.request.method in ("POST", "PATCH", "PUT")
248             body_present = (self.request.body is not None or
249                             self.request.body_producer is not None)
250             if ((body_expected and not body_present) or
251                     (body_present and not body_expected)):
252                 raise ValueError(
253                     'Body must %sbe None for method %s (unless '
254                     'allow_nonstandard_methods is true)' %
255                     ('not ' if body_expected else '', self.request.method))
256         if self.request.expect_100_continue:
257             self.request.headers["Expect"] = "100-continue"
258         if self.request.body is not None:
259             self.request.headers["Content-Length"] = str(len(
260                 self.request.body))
261         if (self.request.method == "POST" and
262                 "Content-Type" not in self.request.headers):
263             self.request.headers["Content-Type"] = "application/x-www-form-urlencoded"
264         if self.request.decompress_response:
265             self.request.headers["Accept-Encoding"] = "gzip"
266         req_path = ((self.parsed.path or '/') +
267                     (('?' + self.parsed.query) if self.parsed.query else ''))
268         self.connection = self._create_connection(stream)
269         start_line = httputil.RequestStartLine(self.request.method,
270                                                req_path, '')
271         self.connection.write_headers(start_line, self.request.headers)
272         if self.request.expect_100_continue:
273             self._read_response()
274         else:
275             self._write_body(True)
276     def _create_connection(self, stream):
277         stream.set_nodelay(True)
278         connection = HTTP1Connection(
279             stream, True,
280             HTTP1ConnectionParameters(
281                 no_keep_alive=True,
282                 max_header_size=self.max_header_size,
283                 max_body_size=self.max_body_size,
284                 decompress=self.request.decompress_response),
285             self._sockaddr)
286         return connection
287     def _write_body(self, start_read):
288         if self.request.body is not None:
289             self.connection.write(self.request.body)
290         elif self.request.body_producer is not None:
291             fut = self.request.body_producer(self.connection.write)
292             if fut is not None:
293                 fut = gen.convert_yielded(fut)
294                 def on_body_written(fut):
295                     fut.result()
296                     self.connection.finish()
297                     if start_read:
298                         self._read_response()
299                 self.io_loop.add_future(fut, on_body_written)
300                 return
301         self.connection.finish()
302         if start_read:
303             self._read_response()
304     def _read_response(self):
305         self.io_loop.add_future(
306             self.connection.read_response(self),
307             lambda f: f.result())
308     def _release(self):
309         if self.release_callback is not None:
310             release_callback = self.release_callback
311             self.release_callback = None
312             release_callback()
313     def _run_callback(self, response):
314         self._release()
315         if self.final_callback is not None:
316             final_callback = self.final_callback
317             self.final_callback = None
318             self.io_loop.add_callback(final_callback, response)
319     def _handle_exception(self, typ, value, tb):
320         if self.final_callback:
321             self._remove_timeout()
322             if isinstance(value, StreamClosedError):
323                 if value.real_error is None:
324                     value = HTTPError(599, "Stream closed")
325                 else:
326                     value = value.real_error
327             self._run_callback(HTTPResponse(self.request, 599, error=value,
328                                             request_time=self.io_loop.time() - self.start_time,
329                                             ))
330             if hasattr(self, "stream"):
331                 self.stream.close()
332             return True
333         else:
334             return isinstance(value, StreamClosedError)
335     def on_connection_close(self):
336         if self.final_callback is not None:
337             message = "Connection closed"
338             if self.stream.error:
339                 raise self.stream.error
340             try:
341                 raise HTTPError(599, message)
342             except HTTPError:
343                 self._handle_exception(*sys.exc_info())
344     def headers_received(self, first_line, headers):
345         if self.request.expect_100_continue and first_line.code == 100:
346             self._write_body(False)
347             return
348         self.code = first_line.code
349         self.reason = first_line.reason
350         self.headers = headers
351         if self._should_follow_redirect():
352             return
353         if self.request.header_callback is not None:
354             self.request.header_callback('%s %s %s\r\n' % first_line)
355             for k, v in self.headers.get_all():
356                 self.request.header_callback("%s: %s\r\n" % (k, v))
357             self.request.header_callback('\r\n')
358     def _should_follow_redirect(self):
359         return (self.request.follow_redirects and
360                 self.request.max_redirects &gt; 0 and
361                 self.code in (301, 302, 303, 307, 308))
362     def finish(self):
363         data = b''.join(self.chunks)
364         self._remove_timeout()
365         original_request = getattr(self.request, "original_request",
366                                    self.request)
367         if self._should_follow_redirect():
368             assert isinstance(self.request, _RequestProxy)
369             new_request = copy.copy(self.request.request)
370             new_request.url = urlparse.urljoin(self.request.url,
371                                                self.headers["Location"])
372             new_request.max_redirects = self.request.max_redirects - 1
373             del new_request.headers["Host"]
374             if self.code in (302, 303):
375                 new_request.method = "GET"
376                 new_request.body = None
377                 for h in ["Content-Length", "Content-Type",
378                           "Content-Encoding", "Transfer-Encoding"]:
379                     try:
380                         del self.request.headers[h]
381                     except KeyError:
382                         pass
383             new_request.original_request = original_request
384             final_callback = self.final_callback
385             self.final_callback = None
386             self._release()
387             self.client.fetch(new_request, final_callback)
388             self._on_end_request()
389             return
390         if self.request.streaming_callback:
391             buffer = BytesIO()
392         else:
393             buffer = BytesIO(data)  # TODO: don't require one big string?
394         response = HTTPResponse(original_request,
395                                 self.code, reason=getattr(self, 'reason', None),
396                                 headers=self.headers,
397                                 request_time=self.io_loop.time() - self.start_time,
398                                 buffer=buffer,
399                                 effective_url=self.request.url)
400         self._run_callback(response)
401         self._on_end_request()
402     def _on_end_request(self):
403         self.stream.close()
404     def data_received(self, chunk):
405         if self._should_follow_redirect():
406             return
407         if self.request.streaming_callback is not None:
408             self.request.streaming_callback(chunk)
409         else:
410             self.chunks.append(chunk)
411 if __name__ == "__main__":
412     AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
413     main()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>nspawn.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import errno
2 import functools
3 import logging
4 import os
5 import re
6 import shutil
7 import tempfile
8 import time
9 import salt.defaults.exitcodes
10 import salt.utils.args
11 import salt.utils.functools
12 import salt.utils.path
13 import salt.utils.systemd
14 from</b></font> salt.exceptions import CommandExecutionError, SaltInvocationError
15 log = logging.getLogger(__name__)
16 __func_alias__ = {
17     "list_": "list",
18 }
19 __virtualname__ = "nspawn"
20 SEED_MARKER = "/nspawn.initial_seed"
21 WANT = "/etc/systemd/system/multi-user.target.wants/systemd-nspawn@{0}.service"
22 EXEC_DRIVER = "nsenter"
23 def __virtual__():
24     if __grains__["kernel"] == "Linux" and salt.utils.systemd.booted(__context__):
25         if salt.utils.systemd.version() is None:
26             log.error("nspawn: Unable to determine systemd version")
27         else:
28             return __virtualname__
29     return (
30         False,
31         "The nspawn execution module failed to load: "
32         "only work on systems that have been booted with systemd.",
33     )
34 def _sd_version():
35     return salt.utils.systemd.version(__context__)
36 def _ensure_exists(wrapped):
37     @functools.wraps(wrapped)
38     def check_exists(name, *args, **kwargs):
39         if not exists(name):
40             raise CommandExecutionError("Container '{}' does not exist".format(name))
41         return wrapped(name, *args, **salt.utils.args.clean_kwargs(**kwargs))
42     return check_exists
43 def _root(name="", all_roots=False):
44     if _sd_version() &gt;= 219:
45         if all_roots:
46             return [
47                 os.path.join(x, name)
48                 for x in ("/var/lib/machines", "/var/lib/container")
49             ]
50         else:
51             return os.path.join("/var/lib/machines", name)
52     else:
53         ret = os.path.join("/var/lib/container", name)
54         if all_roots:
55             return [ret]
56         else:
57             return ret
58 def _make_container_root(name):
59     path = _root(name)
60     if os.path.exists(path):
61         __context__["retcode"] = salt.defaults.exitcodes.SALT_BUILD_FAIL
62         raise CommandExecutionError("Container {} already exists".format(name))
63     else:
64         try:
65             os.makedirs(path)
66             return path
67         except OSError as exc:
68             raise CommandExecutionError(
69                 "Unable to make container root directory {}: {}".format(name, exc)
70             )
71 def _build_failed(dst, name):
72     try:
73         __context__["retcode"] = salt.defaults.exitcodes.SALT_BUILD_FAIL
74         shutil.rmtree(dst)
75     except OSError as exc:
76         if exc.errno != errno.ENOENT:
77             raise CommandExecutionError(
78                 "Unable to cleanup container root dir {}".format(dst)
79             )
80     raise CommandExecutionError("Container {} failed to build".format(name))
81 def _bootstrap_arch(name, **kwargs):
82     if not salt.utils.path.which("pacstrap"):
83         raise CommandExecutionError(
84             "pacstrap not found, is the arch-install-scripts package installed?"
85         )
86     dst = _make_container_root(name)
87     cmd = "pacstrap -c -d {} base".format(dst)
88     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
89     if ret["retcode"] != 0:
90         _build_failed(dst, name)
91     return ret
92 def _bootstrap_debian(name, **kwargs):
93     version = kwargs.get("version", False)
94     if not version:
95         if __grains__["os"].lower() == "debian":
96             version = __grains__["osrelease"]
97         else:
98             version = "stable"
99     release_blacklist = [
100         "hamm",
101         "slink",
102         "potato",
103         "woody",
104         "sarge",
105         "etch",
106         "lenny",
107         "squeeze",
108         "wheezy",
109     ]
110     if version in release_blacklist:
111         raise CommandExecutionError(
112             'Unsupported Debian version "{}". '
113             'Only "stable" or "jessie" and newer are supported'.format(version)
114         )
115     dst = _make_container_root(name)
116     cmd = "debootstrap --arch=amd64 {} {}".format(version, dst)
117     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
118     if ret["retcode"] != 0:
119         _build_failed(dst, name)
120     return ret
121 def _bootstrap_fedora(name, **kwargs):
122     dst = _make_container_root(name)
123     if not kwargs.get("version", False):
124         if __grains__["os"].lower() == "fedora":
125             version = __grains__["osrelease"]
126         else:
127             version = "21"
128     else:
129         version = "21"
130     cmd = (
131         "yum -y --releasever={} --nogpg --installroot={} "
132         '--disablerepo="*" --enablerepo=fedora install systemd passwd yum '
133         "fedora-release vim-minimal".format(version, dst)
134     )
135     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
136     if ret["retcode"] != 0:
137         _build_failed(dst, name)
138     return ret
139 def _bootstrap_ubuntu(name, **kwargs):
140     version = kwargs.get("version", False)
141     if not version:
142         if __grains__["os"].lower() == "ubuntu":
143             version = __grains__["oscodename"]
144         else:
145             version = "xenial"
146     dst = _make_container_root(name)
147     cmd = "debootstrap --arch=amd64 {} {}".format(version, dst)
148     ret = __salt__["cmd.run_all"](cmd, python_shell=False)
149     if ret["retcode"] != 0:
150         _build_failed(dst, name)
151     return ret
152 def _clear_context():
153     for var in [x for x in __context__ if x.startswith("nspawn.")]:
154         log.trace("Clearing __context__['%s']", var)
155         __context__.pop(var, None)
156 def _ensure_running(name):
157     if state(name) != "running":
158         return True
159     else:
160         return start(name)
161 def _ensure_systemd(version):
162     try:
163         version = int(version)
164     except ValueError:
165         raise CommandExecutionError("Invalid version '{}'".format(version))
166     try:
167         installed = _sd_version()
168         log.debug("nspawn: detected systemd %s", installed)
169     except (IndexError, ValueError):
170         raise CommandExecutionError("nspawn: Unable to get systemd version")
171     if installed &lt; version:
172         raise CommandExecutionError(
173             "This function requires systemd &gt;= {} (Detected version: {}).".format(
174                 version, installed
175             )
176         )
177 def _machinectl(cmd, output_loglevel="debug", ignore_retcode=False, use_vt=False):
178     prefix = "machinectl --no-legend --no-pager"
179     return __salt__["cmd.run_all"](
180         "{} {}".format(prefix, cmd),
181         output_loglevel=output_loglevel,
182         ignore_retcode=ignore_retcode,
183         use_vt=use_vt,
184     )
185 @_ensure_exists
186 def _run(
187     name,
188     cmd,
189     output=None,
190     no_start=False,
191     stdin=None,
192     python_shell=True,
193     preserve_state=False,
194     output_loglevel="debug",
195     ignore_retcode=False,
196     use_vt=False,
197     keep_env=None,
198 ):
199     orig_state = state(name)
200     exc = None
201     try:
202         ret = __salt__["container_resource.run"](
203             name,
204             cmd,
205             container_type=__virtualname__,
206             exec_driver=EXEC_DRIVER,
207             output=output,
208             no_start=no_start,
209             stdin=stdin,
210             python_shell=python_shell,
211             output_loglevel=output_loglevel,
212             ignore_retcode=ignore_retcode,
213             use_vt=use_vt,
214             keep_env=keep_env,
215         )
216     finally:
217         if preserve_state and orig_state == "stopped" and state(name) != "stopped":
218             stop(name)
219     if output in (None, "all"):
220         return ret
221     else:
222         return ret[output]
223 @_ensure_exists
224 def pid(name):
225     try:
226         return int(info(name).get("PID"))
227     except (TypeError, ValueError) as exc:
228         raise CommandExecutionError(
229             "Unable to get PID for container '{}': {}".format(name, exc)
230         )
231 def run(
232     name,
233     cmd,
234     no_start=False,
235     preserve_state=True,
236     stdin=None,
237     python_shell=True,
238     output_loglevel="debug",
239     use_vt=False,
240     ignore_retcode=False,
241     keep_env=None,
242 ):
243     return _run(
244         name,
245         cmd,
246         output=None,
247         no_start=no_start,
248         preserve_state=preserve_state,
249         stdin=stdin,
250         python_shell=python_shell,
251         output_loglevel=output_loglevel,
252         use_vt=use_vt,
253         ignore_retcode=ignore_retcode,
254         keep_env=keep_env,
255     )
256 def run_stdout(
257     name,
258     cmd,
259     no_start=False,
260     preserve_state=True,
261     stdin=None,
262     python_shell=True,
263     output_loglevel="debug",
264     use_vt=False,
265     ignore_retcode=False,
266     keep_env=None,
267 ):
268     return _run(
269         name,
270         cmd,
271         output="stdout",
272         no_start=no_start,
273         preserve_state=preserve_state,
274         stdin=stdin,
275         python_shell=python_shell,
276         output_loglevel=output_loglevel,
277         use_vt=use_vt,
278         ignore_retcode=ignore_retcode,
279         keep_env=keep_env,
280     )
281 def run_stderr(
282     name,
283     cmd,
284     no_start=False,
285     preserve_state=True,
286     stdin=None,
287     python_shell=True,
288     output_loglevel="debug",
289     use_vt=False,
290     ignore_retcode=False,
291     keep_env=None,
292 ):
293     return _run(
294         name,
295         cmd,
296         output="stderr",
297         no_start=no_start,
298         preserve_state=preserve_state,
299         stdin=stdin,
300         python_shell=python_shell,
301         output_loglevel=output_loglevel,
302         use_vt=use_vt,
303         ignore_retcode=ignore_retcode,
304         keep_env=keep_env,
305     )
306 def retcode(
307     name,
308     cmd,
309     no_start=False,
310     preserve_state=True,
311     stdin=None,
312     python_shell=True,
313     output_loglevel="debug",
314     use_vt=False,
315     ignore_retcode=False,
316     keep_env=None,
317 ):
318     return _run(
319         name,
320         cmd,
321         output="retcode",
322         no_start=no_start,
323         preserve_state=preserve_state,
324         stdin=stdin,
325         python_shell=python_shell,
326         output_loglevel=output_loglevel,
327         use_vt=use_vt,
328         ignore_retcode=ignore_retcode,
329         keep_env=keep_env,
330     )
331 def run_all(
332     name,
333     cmd,
334     no_start=False,
335     preserve_state=True,
336     stdin=None,
337     python_shell=True,
338     output_loglevel="debug",
339     use_vt=False,
340     ignore_retcode=False,
341     keep_env=None,
342 ):
343     return _run(
344         name,
345         cmd,
346         output="all",
347         no_start=no_start,
348         preserve_state=preserve_state,
349         stdin=stdin,
350         python_shell=python_shell,
351         output_loglevel=output_loglevel,
352         use_vt=use_vt,
353         ignore_retcode=ignore_retcode,
354         keep_env=keep_env,
355     )
356 def bootstrap_container(name, dist=None, version=None):
357     if not dist:
358         dist = __grains__["os"].lower()
359         log.debug("nspawn.bootstrap: no dist provided, defaulting to '%s'", dist)
360     try:
361         return globals()["_bootstrap_{}".format(dist)](name, version=version)
362     except KeyError:
363         raise CommandExecutionError('Unsupported distribution "{}"'.format(dist))
364 def _needs_install(name):
365     ret = 0
366     has_minion = retcode(name, "command -v salt-minion")
367     if has_minion:
368         processes = run_stdout(name, "ps aux")
369         if "salt-minion" not in processes:
370             ret = 1
371         else:
372             retcode(name, "salt-call --local service.stop salt-minion")
373     else:
374         ret = 1
375     return ret
376 def bootstrap_salt(
377     name,
378     config=None,
379     approve_key=True,
380     install=True,
381     pub_key=None,
382     priv_key=None,
383     bootstrap_url=None,
384     force_install=False,
385     unconditional_install=False,
386     bootstrap_delay=None,
387     bootstrap_args=None,
388     bootstrap_shell=None,
389 ):
390     if bootstrap_delay is not None:
391         try:
392             time.sleep(bootstrap_delay)
393         except TypeError:
394             time.sleep(5)
395     c_info = info(name)
396     if not c_info:
397         return None
398     if bootstrap_args:
399         if "{0}" not in bootstrap_args:
400             bootstrap_args += " -c {0}"
401     else:
402         bootstrap_args = "-c {0}"
403     if not bootstrap_shell:
404         bootstrap_shell = "sh"
405     orig_state = _ensure_running(name)
406     if not orig_state:
407         return orig_state
408     if not force_install:
409         needs_install = _needs_install(name)
410     else:
411         needs_install = True
412     seeded = retcode(name, "test -e '{}'".format(SEED_MARKER)) == 0
413     tmp = tempfile.mkdtemp()
414     if seeded and not unconditional_install:
415         ret = True
416     else:
417         ret = False
418         cfg_files = __salt__["seed.mkconfig"](
419             config,
420             tmp=tmp,
421             id_=name,
422             approve_key=approve_key,
423             pub_key=pub_key,
424             priv_key=priv_key,
425         )
426         if needs_install or force_install or unconditional_install:
427             if install:
428                 rstr = __salt__["test.random_hash"]()
429                 configdir = "/tmp/.c_{}".format(rstr)
430                 run(name, "install -m 0700 -d {}".format(configdir), python_shell=False)
431                 bs_ = __salt__["config.gather_bootstrap_script"](
432                     bootstrap=bootstrap_url
433                 )
434                 dest_dir = os.path.join("/tmp", rstr)
435                 for cmd in [
436                     "mkdir -p {}".format(dest_dir),
437                     "chmod 700 {}".format(dest_dir),
438                 ]:
439                     if run_stdout(name, cmd):
440                         log.error("tmpdir %s creation failed (%s)", dest_dir, cmd)
441                         return False
442                 copy_to(name, bs_, "{}/bootstrap.sh".format(dest_dir), makedirs=True)
443                 copy_to(name, cfg_files["config"], os.path.join(configdir, "minion"))
444                 copy_to(
445                     name, cfg_files["privkey"], os.path.join(configdir, "minion.pem")
446                 )
447                 copy_to(
448                     name, cfg_files["pubkey"], os.path.join(configdir, "minion.pub")
449                 )
450                 bootstrap_args = bootstrap_args.format(configdir)
451                 cmd = "{0} {2}/bootstrap.sh {1}".format(
452                     bootstrap_shell, bootstrap_args.replace("'", "''"), dest_dir
453                 )
454                 log.info("Running %s in LXC container '%s'", cmd, name)
455                 ret = retcode(name, cmd, output_loglevel="info", use_vt=True) == 0
456             else:
457                 ret = False
458         else:
459             minion_config = salt.config.minion_config(cfg_files["config"])
460             pki_dir = minion_config["pki_dir"]
461             copy_to(name, cfg_files["config"], "/etc/salt/minion")
462             copy_to(name, cfg_files["privkey"], os.path.join(pki_dir, "minion.pem"))
463             copy_to(name, cfg_files["pubkey"], os.path.join(pki_dir, "minion.pub"))
464             run(
465                 name, "salt-call --local service.enable salt-minion", python_shell=False
466             )
467             ret = True
468         shutil.rmtree(tmp)
469         if orig_state == "stopped":
470             stop(name)
471         if ret:
472             run(name, "touch '{}'".format(SEED_MARKER), python_shell=False)
473     return ret
474 def list_all():
475     ret = []
476     if _sd_version() &gt;= 219:
477         for line in _machinectl("list-images")["stdout"].splitlines():
478             try:
479                 ret.append(line.split()[0])
480             except IndexError:
481                 continue
482     else:
483         rootdir = _root()
484         try:
485             for dirname in os.listdir(rootdir):
486                 if os.path.isdir(os.path.join(rootdir, dirname)):
487                     ret.append(dirname)
488         except OSError:
489             pass
490     return ret
491 def list_running():
492     ret = []
493     for line in _machinectl("list")["stdout"].splitlines():
494         try:
495             ret.append(line.split()[0])
496         except IndexError:
497             pass
498     return sorted(ret)
499 list_ = salt.utils.functools.alias_function(list_running, "list_")
500 def list_stopped():
501     return sorted(set(list_all()) - set(list_running()))
502 def exists(name):
503     contextkey = "nspawn.exists.{}".format(name)
504     if contextkey in __context__:
505         return __context__[contextkey]
506     __context__[contextkey] = name in list_all()
507     return __context__[contextkey]
508 @_ensure_exists
509 def state(name):
510     try:
511         cmd = "show {} --property=State".format(name)
512         return _machinectl(cmd, ignore_retcode=True)["stdout"].split("=")[-1]
513     except IndexError:
514         return "stopped"
515 def info(name, **kwargs):
516     kwargs = salt.utils.args.clean_kwargs(**kwargs)
517     start_ = kwargs.pop("start", False)
518     if kwargs:
519         salt.utils.args.invalid_kwargs(kwargs)
520     if not start_:
521         _ensure_running(name)
522     elif name not in list_running():
523         start(name)
524     c_info = _machinectl("status {}".format(name))
525     if c_info["retcode"] != 0:
526         raise CommandExecutionError(
527             "Unable to get info for container '{}'".format(name)
528         )
529     key_name_map = {
530         "Iface": "Network Interface",
531         "Leader": "PID",
532         "Service": False,
533         "Since": "Running Since",
534     }
535     ret = {}
536     kv_pair = re.compile(r"^\s+([A-Za-z]+): (.+)$")
537     tree = re.compile(r"[|`]")
538     lines = c_info["stdout"].splitlines()
539     multiline = False
540     cur_key = None
541     for idx, line in enumerate(lines):
542         match = kv_pair.match(line)
543         if match:
544             key, val = match.groups()
545             key = key_name_map.get(key, key)
546             if key is False:
547                 continue
548             elif key == "PID":
549                 try:
550                     val = val.split()[0]
551                 except IndexError:
552                     pass
553             cur_key = key
554             if multiline:
555                 multiline = False
556             ret[key] = val
557         else:
558             if cur_key is None:
559                 continue
560             if tree.search(lines[idx]):
561                 break
562             if multiline:
563                 ret[cur_key].append(lines[idx].strip())
564             else:
565                 ret[cur_key] = [ret[key], lines[idx].strip()]
566                 multiline = True
567     return ret
568 @_ensure_exists
569 def enable(name):
570     cmd = "systemctl enable systemd-nspawn@{}".format(name)
571     if __salt__["cmd.retcode"](cmd, python_shell=False) != 0:
572         __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
573         return False
574     return True
575 @_ensure_exists
576 def disable(name):
577     cmd = "systemctl disable systemd-nspawn@{}".format(name)
578     if __salt__["cmd.retcode"](cmd, python_shell=False) != 0:
579         __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
580         return False
581     return True
582 @_ensure_exists
583 def start(name):
584     if _sd_version() &gt;= 219:
585         ret = _machinectl("start {}".format(name))
586     else:
587         cmd = "systemctl start systemd-nspawn@{}".format(name)
588         ret = __salt__["cmd.run_all"](cmd, python_shell=False)
589     if ret["retcode"] != 0:
590         __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
591         return False
592     return True
593 @_ensure_exists
594 def stop(name, kill=False):
595     if _sd_version() &gt;= 219:
596         if kill:
597             action = "terminate"
598         else:
599             action = "poweroff"
600         ret = _machinectl("{} {}".format(action, name))
601     else:
602         cmd = "systemctl stop systemd-nspawn@{}".format(name)
603         ret = __salt__["cmd.run_all"](cmd, python_shell=False)
604     if ret["retcode"] != 0:
605         __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
606         return False
607     return True
608 def poweroff(name):
609     return stop(name, kill=False)
610 def terminate(name):
611     return stop(name, kill=True)
612 def restart(name):
613     return reboot(name)
614 @_ensure_exists
615 def reboot(name, kill=False):
616     if _sd_version() &gt;= 219:
617         if state(name) == "running":
618             ret = _machinectl("reboot {}".format(name))
619         else:
620             return start(name)
621     else:
622         cmd = "systemctl stop systemd-nspawn@{}".format(name)
623         ret = __salt__["cmd.run_all"](cmd, python_shell=False)
624         if ret["retcode"] != 0:
625             __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
626             return False
627         cmd = "systemctl start systemd-nspawn@{}".format(name)
628         ret = __salt__["cmd.run_all"](cmd, python_shell=False)
629     if ret["retcode"] != 0:
630         __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
631         return False
632     return True
633 @_ensure_exists
634 def remove(name, stop=False):
635     if not stop and state(name) != "stopped":
636         raise CommandExecutionError("Container '{}' is not stopped".format(name))
637     def _failed_remove(name, exc):
638         raise CommandExecutionError(
639             "Unable to remove container '{}': {}".format(name, exc)
640         )
641     if _sd_version() &gt;= 219:
642         ret = _machinectl("remove {}".format(name))
643         if ret["retcode"] != 0:
644             __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
645             _failed_remove(name, ret["stderr"])
646     else:
647         try:
648             shutil.rmtree(os.path.join(_root(), name))
649         except OSError as exc:
650             _failed_remove(name, exc)
651     return True
652 destroy = salt.utils.functools.alias_function(remove, "destroy")
653 @_ensure_exists
654 def copy_to(name, source, dest, overwrite=False, makedirs=False):
655     path = source
656     try:
657         if source.startswith("salt://"):
658             cached_source = __salt__["cp.cache_file"](source)
659             if not cached_source:
660                 raise CommandExecutionError("Unable to cache {}".format(source))
661             path = cached_source
662     except AttributeError:
663         raise SaltInvocationError("Invalid source file {}".format(source))
664     if _sd_version() &gt;= 219:
665         pass
666     return __salt__["container_resource.copy_to"](
667         name,
668         path,
669         dest,
670         container_type=__virtualname__,
671         exec_driver=EXEC_DRIVER,
672         overwrite=overwrite,
673         makedirs=makedirs,
674     )
675 cp = salt.utils.functools.alias_function(copy_to, "cp")
676 def _pull_image(pull_type, image, name, **kwargs):
677     _ensure_systemd(219)
678     if exists(name):
679         raise SaltInvocationError("Container '{}' already exists".format(name))
680     if pull_type in ("raw", "tar"):
681         valid_kwargs = ("verify",)
682     elif pull_type == "dkr":
683         valid_kwargs = ("index",)
684     else:
685         raise SaltInvocationError("Unsupported image type '{}'".format(pull_type))
686     kwargs = salt.utils.args.clean_kwargs(**kwargs)
687     bad_kwargs = {
688         x: y
689         for x, y in salt.utils.args.clean_kwargs(**kwargs).items()
690         if x not in valid_kwargs
691     }
692     if bad_kwargs:
693         salt.utils.args.invalid_kwargs(bad_kwargs)
694     pull_opts = []
695     if pull_type in ("raw", "tar"):
696         verify = kwargs.get("verify", False)
697         if not verify:
698             pull_opts.append("--verify=no")
699         else:
700             def _bad_verify():
701                 raise SaltInvocationError(
702                     "'verify' must be one of the following: signature, checksum"
703                 )
704             try:
705                 verify = verify.lower()
706             except AttributeError:
707                 _bad_verify()
708             else:
709                 if verify not in ("signature", "checksum"):
710                     _bad_verify()
711                 pull_opts.append("--verify={}".format(verify))
712     elif pull_type == "dkr":
713         if "index" in kwargs:
714             pull_opts.append("--dkr-index-url={}".format(kwargs["index"]))
715     cmd = "pull-{} {} {} {}".format(pull_type, " ".join(pull_opts), image, name)
716     result = _machinectl(cmd, use_vt=True)
717     if result["retcode"] != 0:
718         msg = (
719             "Error occurred pulling image. Stderr from the pull command "
720             "(if any) follows: "
721         )
722         if result["stderr"]:
723             msg += "\n\n{}".format(result["stderr"])
724         raise CommandExecutionError(msg)
725     return True
726 def pull_raw(url, name, verify=False):
727     return _pull_image("raw", url, name, verify=verify)
728 def pull_tar(url, name, verify=False):
729     return _pull_image("tar", url, name, verify=verify)
730 def pull_dkr(url, name, index):
731     return _pull_image("dkr", url, name, index=index)
732 pull_docker = salt.utils.functools.alias_function(pull_dkr, "pull_docker")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
