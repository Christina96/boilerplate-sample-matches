<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for simple_httpclient.py & nspawn.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for simple_httpclient.py & nspawn.py
      </h3>
      <h1 align="center">
        1.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>simple_httpclient.py (1.3592232%)<TH>nspawn.py (1.088647%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match240300-0.html#0',2,'match240300-1.html#0',3)" NAME="0">(3-18)<TD><A HREF="javascript:ZweiFrames('match240300-0.html#0',2,'match240300-1.html#0',3)" NAME="0">(24-38)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>simple_httpclient.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
<A NAME="0"></A>#!/usr/bin/env python
# pylint: skip-file
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match240300-1.html#0',3,'match240300-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>from __future__ import absolute_import, division, print_function

from salt.ext.tornado.escape import utf8, _unicode
from salt.ext.tornado import gen
from salt.ext.tornado.httpclient import HTTPResponse, HTTPError, AsyncHTTPClient, main, _RequestProxy
from salt.ext.tornado import httputil
from salt.ext.tornado.http1connection import HTTP1Connection, HTTP1ConnectionParameters
from salt.ext.tornado.iostream import StreamClosedError
from salt.ext.tornado.netutil import Resolver, OverrideResolver, _client_ssl_defaults
from salt.ext.tornado.log import gen_log
from salt.ext.tornado import stack_context
from salt.ext.tornado.tcpclient import TCPClient
from salt.ext.tornado.util import PY3

import base64
import</B></FONT> collections
import copy
import functools
import re
import socket
import sys
from io import BytesIO


if PY3:
    import urllib.parse as urlparse
else:
    import urlparse

try:
    import ssl
except ImportError:
    # ssl is not available on Google App Engine.
    ssl = None

try:
    import certifi
except ImportError:
    certifi = None


def _default_ca_certs():
    if certifi is None:
        raise Exception(&quot;The 'certifi' package is required to use https &quot;
                        &quot;in simple_httpclient&quot;)
    return certifi.where()


class SimpleAsyncHTTPClient(AsyncHTTPClient):
    &quot;&quot;&quot;Non-blocking HTTP client with no external dependencies.

    This class implements an HTTP 1.1 client on top of Tornado's IOStreams.
    Some features found in the curl-based AsyncHTTPClient are not yet
    supported.  In particular, proxies are not supported, connections
    are not reused, and callers cannot select the network interface to be
    used.
    &quot;&quot;&quot;
    def initialize(self, io_loop, max_clients=10,
                   hostname_mapping=None, max_buffer_size=104857600,
                   resolver=None, defaults=None, max_header_size=None,
                   max_body_size=None):
        &quot;&quot;&quot;Creates a AsyncHTTPClient.

        Only a single AsyncHTTPClient instance exists per IOLoop
        in order to provide limitations on the number of pending connections.
        ``force_instance=True`` may be used to suppress this behavior.

        Note that because of this implicit reuse, unless ``force_instance``
        is used, only the first call to the constructor actually uses
        its arguments. It is recommended to use the ``configure`` method
        instead of the constructor to ensure that arguments take effect.

        ``max_clients`` is the number of concurrent requests that can be
        in progress; when this limit is reached additional requests will be
        queued. Note that time spent waiting in this queue still counts
        against the ``request_timeout``.

        ``hostname_mapping`` is a dictionary mapping hostnames to IP addresses.
        It can be used to make local DNS changes when modifying system-wide
        settings like ``/etc/hosts`` is not possible or desirable (e.g. in
        unittests).

        ``max_buffer_size`` (default 100MB) is the number of bytes
        that can be read into memory at once. ``max_body_size``
        (defaults to ``max_buffer_size``) is the largest response body
        that the client will accept.  Without a
        ``streaming_callback``, the smaller of these two limits
        applies; with a ``streaming_callback`` only ``max_body_size``
        does.

        .. versionchanged:: 4.2
           Added the ``max_body_size`` argument.
        &quot;&quot;&quot;
        super(SimpleAsyncHTTPClient, self).initialize(io_loop,
                                                      defaults=defaults)
        self.max_clients = max_clients
        self.queue = collections.deque()
        self.active = {}
        self.waiting = {}
        self.max_buffer_size = max_buffer_size
        self.max_header_size = max_header_size
        self.max_body_size = max_body_size
        # TCPClient could create a Resolver for us, but we have to do it
        # ourselves to support hostname_mapping.
        if resolver:
            self.resolver = resolver
            self.own_resolver = False
        else:
            self.resolver = Resolver(io_loop=io_loop)
            self.own_resolver = True
        if hostname_mapping is not None:
            self.resolver = OverrideResolver(resolver=self.resolver,
                                             mapping=hostname_mapping)
        self.tcp_client = TCPClient(resolver=self.resolver, io_loop=io_loop)

    def close(self):
        super(SimpleAsyncHTTPClient, self).close()
        if self.own_resolver:
            self.resolver.close()
        self.tcp_client.close()

    def fetch_impl(self, request, callback):
        key = object()
        self.queue.append((key, request, callback))
        if not len(self.active) &lt; self.max_clients:
            timeout_handle = self.io_loop.add_timeout(
                self.io_loop.time() + min(request.connect_timeout,
                                          request.request_timeout),
                functools.partial(self._on_timeout, key, &quot;in request queue&quot;))
        else:
            timeout_handle = None
        self.waiting[key] = (request, callback, timeout_handle)
        self._process_queue()
        if self.queue:
            gen_log.debug(&quot;max_clients limit reached, request queued. &quot;
                          &quot;%d active, %d queued requests.&quot; % (
                              len(self.active), len(self.queue)))

    def _process_queue(self):
        with stack_context.NullContext():
            while self.queue and len(self.active) &lt; self.max_clients:
                key, request, callback = self.queue.popleft()
                if key not in self.waiting:
                    continue
                self._remove_timeout(key)
                self.active[key] = (request, callback)
                release_callback = functools.partial(self._release_fetch, key)
                self._handle_request(request, release_callback, callback)

    def _connection_class(self):
        return _HTTPConnection

    def _handle_request(self, request, release_callback, final_callback):
        self._connection_class()(
            self.io_loop, self, request, release_callback,
            final_callback, self.max_buffer_size, self.tcp_client,
            self.max_header_size, self.max_body_size)

    def _release_fetch(self, key):
        del self.active[key]
        self._process_queue()

    def _remove_timeout(self, key):
        if key in self.waiting:
            request, callback, timeout_handle = self.waiting[key]
            if timeout_handle is not None:
                self.io_loop.remove_timeout(timeout_handle)
            del self.waiting[key]

    def _on_timeout(self, key, info=None):
        &quot;&quot;&quot;Timeout callback of request.

        Construct a timeout HTTPResponse when a timeout occurs.

        :arg object key: A simple object to mark the request.
        :info string key: More detailed timeout information.
        &quot;&quot;&quot;
        request, callback, timeout_handle = self.waiting[key]
        self.queue.remove((key, request, callback))

        error_message = &quot;Timeout {0}&quot;.format(info) if info else &quot;Timeout&quot;
        timeout_response = HTTPResponse(
            request, 599, error=HTTPError(599, error_message),
            request_time=self.io_loop.time() - request.start_time)
        self.io_loop.add_callback(callback, timeout_response)
        del self.waiting[key]


class _HTTPConnection(httputil.HTTPMessageDelegate):
    _SUPPORTED_METHODS = set([&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;, &quot;OPTIONS&quot;])

    def __init__(self, io_loop, client, request, release_callback,
                 final_callback, max_buffer_size, tcp_client,
                 max_header_size, max_body_size):
        self.start_time = io_loop.time()
        self.io_loop = io_loop
        self.client = client
        self.request = request
        self.release_callback = release_callback
        self.final_callback = final_callback
        self.max_buffer_size = max_buffer_size
        self.tcp_client = tcp_client
        self.max_header_size = max_header_size
        self.max_body_size = max_body_size
        self.code = None
        self.headers = None
        self.chunks = []
        self._decompressor = None
        # Timeout handle returned by IOLoop.add_timeout
        self._timeout = None
        self._sockaddr = None
        with stack_context.ExceptionStackContext(self._handle_exception):
            self.parsed = urlparse.urlsplit(_unicode(self.request.url))
            if self.parsed.scheme not in (&quot;http&quot;, &quot;https&quot;):
                raise ValueError(&quot;Unsupported url scheme: %s&quot; %
                                 self.request.url)
            # urlsplit results have hostname and port results, but they
            # didn't support ipv6 literals until python 2.7.
            netloc = self.parsed.netloc
            if &quot;@&quot; in netloc:
                userpass, _, netloc = netloc.rpartition(&quot;@&quot;)
            host, port = httputil.split_host_and_port(netloc)
            if port is None:
                port = 443 if self.parsed.scheme == &quot;https&quot; else 80
            if re.match(r'^\[.*\]$', host):
                # raw ipv6 addresses in urls are enclosed in brackets
                host = host[1:-1]
            self.parsed_hostname = host  # save final host for _on_connect

            if request.allow_ipv6 is False:
                af = socket.AF_INET
            else:
                af = socket.AF_UNSPEC

            ssl_options = self._get_ssl_options(self.parsed.scheme)

            timeout = min(self.request.connect_timeout, self.request.request_timeout)
            if timeout:
                self._timeout = self.io_loop.add_timeout(
                    self.start_time + timeout,
                    stack_context.wrap(functools.partial(self._on_timeout, &quot;while connecting&quot;)))
            self.tcp_client.connect(host, port, af=af,
                                    ssl_options=ssl_options,
                                    max_buffer_size=self.max_buffer_size,
                                    callback=self._on_connect)

    def _get_ssl_options(self, scheme):
        if scheme == &quot;https&quot;:
            if self.request.ssl_options is not None:
                return self.request.ssl_options
            # If we are using the defaults, don't construct a
            # new SSLContext.
            if (self.request.validate_cert and
                    self.request.ca_certs is None and
                    self.request.client_cert is None and
                    self.request.client_key is None):
                return _client_ssl_defaults
            ssl_options = {}
            if self.request.validate_cert:
                ssl_options[&quot;cert_reqs&quot;] = ssl.CERT_REQUIRED
            if self.request.ca_certs is not None:
                ssl_options[&quot;ca_certs&quot;] = self.request.ca_certs
            elif not hasattr(ssl, 'create_default_context'):
                # When create_default_context is present,
                # we can omit the &quot;ca_certs&quot; parameter entirely,
                # which avoids the dependency on &quot;certifi&quot; for py34.
                ssl_options[&quot;ca_certs&quot;] = _default_ca_certs()
            if self.request.client_key is not None:
                ssl_options[&quot;keyfile&quot;] = self.request.client_key
            if self.request.client_cert is not None:
                ssl_options[&quot;certfile&quot;] = self.request.client_cert

            # SSL interoperability is tricky.  We want to disable
            # SSLv2 for security reasons; it wasn't disabled by default
            # until openssl 1.0.  The best way to do this is to use
            # the SSL_OP_NO_SSLv2, but that wasn't exposed to python
            # until 3.2.  Python 2.7 adds the ciphers argument, which
            # can also be used to disable SSLv2.  As a last resort
            # on python 2.6, we set ssl_version to TLSv1.  This is
            # more narrow than we'd like since it also breaks
            # compatibility with servers configured for SSLv3 only,
            # but nearly all servers support both SSLv3 and TLSv1:
            # http://blog.ivanristic.com/2011/09/ssl-survey-protocol-support.html
            if sys.version_info &gt;= (2, 7):
                # In addition to disabling SSLv2, we also exclude certain
                # classes of insecure ciphers.
                ssl_options[&quot;ciphers&quot;] = &quot;DEFAULT:!SSLv2:!EXPORT:!DES&quot;
            else:
                # This is really only necessary for pre-1.0 versions
                # of openssl, but python 2.6 doesn't expose version
                # information.
                ssl_options[&quot;ssl_version&quot;] = ssl.PROTOCOL_TLSv1
            return ssl_options
        return None

    def _on_timeout(self, info=None):
        &quot;&quot;&quot;Timeout callback of _HTTPConnection instance.

        Raise a timeout HTTPError when a timeout occurs.

        :info string key: More detailed timeout information.
        &quot;&quot;&quot;
        self._timeout = None
        error_message = &quot;Timeout {0}&quot;.format(info) if info else &quot;Timeout&quot;
        if self.final_callback is not None:
            raise HTTPError(599, error_message)

    def _remove_timeout(self):
        if self._timeout is not None:
            self.io_loop.remove_timeout(self._timeout)
            self._timeout = None

    def _on_connect(self, stream):
        if self.final_callback is None:
            # final_callback is cleared if we've hit our timeout.
            stream.close()
            return
        self.stream = stream
        self.stream.set_close_callback(self.on_connection_close)
        self._remove_timeout()
        if self.final_callback is None:
            return
        if self.request.request_timeout:
            self._timeout = self.io_loop.add_timeout(
                self.start_time + self.request.request_timeout,
                stack_context.wrap(functools.partial(self._on_timeout, &quot;during request&quot;)))
        if (self.request.method not in self._SUPPORTED_METHODS and
                not self.request.allow_nonstandard_methods):
            raise KeyError(&quot;unknown method %s&quot; % self.request.method)
        for key in ('network_interface',
                    'proxy_host', 'proxy_port',
                    'proxy_username', 'proxy_password',
                    'proxy_auth_mode'):
            if getattr(self.request, key, None):
                raise NotImplementedError('%s not supported' % key)
        if &quot;Connection&quot; not in self.request.headers:
            self.request.headers[&quot;Connection&quot;] = &quot;close&quot;
        if &quot;Host&quot; not in self.request.headers:
            if '@' in self.parsed.netloc:
                self.request.headers[&quot;Host&quot;] = self.parsed.netloc.rpartition('@')[-1]
            else:
                self.request.headers[&quot;Host&quot;] = self.parsed.netloc
        username, password = None, None
        if self.parsed.username is not None:
            username, password = self.parsed.username, self.parsed.password
        elif self.request.auth_username is not None:
            username = self.request.auth_username
            password = self.request.auth_password or ''
        if username is not None:
            if self.request.auth_mode not in (None, &quot;basic&quot;):
                raise ValueError(&quot;unsupported auth_mode %s&quot;,
                                 self.request.auth_mode)
            auth = utf8(username) + b&quot;:&quot; + utf8(password)
            self.request.headers[&quot;Authorization&quot;] = (b&quot;Basic &quot; +
                                                     base64.b64encode(auth))
        if self.request.user_agent:
            self.request.headers[&quot;User-Agent&quot;] = self.request.user_agent
        if not self.request.allow_nonstandard_methods:
            # Some HTTP methods nearly always have bodies while others
            # almost never do. Fail in this case unless the user has
            # opted out of sanity checks with allow_nonstandard_methods.
            body_expected = self.request.method in (&quot;POST&quot;, &quot;PATCH&quot;, &quot;PUT&quot;)
            body_present = (self.request.body is not None or
                            self.request.body_producer is not None)
            if ((body_expected and not body_present) or
                    (body_present and not body_expected)):
                raise ValueError(
                    'Body must %sbe None for method %s (unless '
                    'allow_nonstandard_methods is true)' %
                    ('not ' if body_expected else '', self.request.method))
        if self.request.expect_100_continue:
            self.request.headers[&quot;Expect&quot;] = &quot;100-continue&quot;
        if self.request.body is not None:
            # When body_producer is used the caller is responsible for
            # setting Content-Length (or else chunked encoding will be used).
            self.request.headers[&quot;Content-Length&quot;] = str(len(
                self.request.body))
        if (self.request.method == &quot;POST&quot; and
                &quot;Content-Type&quot; not in self.request.headers):
            self.request.headers[&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;
        if self.request.decompress_response:
            self.request.headers[&quot;Accept-Encoding&quot;] = &quot;gzip&quot;
        req_path = ((self.parsed.path or '/') +
                    (('?' + self.parsed.query) if self.parsed.query else ''))
        self.connection = self._create_connection(stream)
        start_line = httputil.RequestStartLine(self.request.method,
                                               req_path, '')
        self.connection.write_headers(start_line, self.request.headers)
        if self.request.expect_100_continue:
            self._read_response()
        else:
            self._write_body(True)

    def _create_connection(self, stream):
        stream.set_nodelay(True)
        connection = HTTP1Connection(
            stream, True,
            HTTP1ConnectionParameters(
                no_keep_alive=True,
                max_header_size=self.max_header_size,
                max_body_size=self.max_body_size,
                decompress=self.request.decompress_response),
            self._sockaddr)
        return connection

    def _write_body(self, start_read):
        if self.request.body is not None:
            self.connection.write(self.request.body)
        elif self.request.body_producer is not None:
            fut = self.request.body_producer(self.connection.write)
            if fut is not None:
                fut = gen.convert_yielded(fut)

                def on_body_written(fut):
                    fut.result()
                    self.connection.finish()
                    if start_read:
                        self._read_response()
                self.io_loop.add_future(fut, on_body_written)
                return
        self.connection.finish()
        if start_read:
            self._read_response()

    def _read_response(self):
        # Ensure that any exception raised in read_response ends up in our
        # stack context.
        self.io_loop.add_future(
            self.connection.read_response(self),
            lambda f: f.result())

    def _release(self):
        if self.release_callback is not None:
            release_callback = self.release_callback
            self.release_callback = None
            release_callback()

    def _run_callback(self, response):
        self._release()
        if self.final_callback is not None:
            final_callback = self.final_callback
            self.final_callback = None
            self.io_loop.add_callback(final_callback, response)

    def _handle_exception(self, typ, value, tb):
        if self.final_callback:
            self._remove_timeout()
            if isinstance(value, StreamClosedError):
                if value.real_error is None:
                    value = HTTPError(599, &quot;Stream closed&quot;)
                else:
                    value = value.real_error
            self._run_callback(HTTPResponse(self.request, 599, error=value,
                                            request_time=self.io_loop.time() - self.start_time,
                                            ))

            if hasattr(self, &quot;stream&quot;):
                # TODO: this may cause a StreamClosedError to be raised
                # by the connection's Future.  Should we cancel the
                # connection more gracefully?
                self.stream.close()
            return True
        else:
            # If our callback has already been called, we are probably
            # catching an exception that is not caused by us but rather
            # some child of our callback. Rather than drop it on the floor,
            # pass it along, unless it's just the stream being closed.
            return isinstance(value, StreamClosedError)

    def on_connection_close(self):
        if self.final_callback is not None:
            message = &quot;Connection closed&quot;
            if self.stream.error:
                raise self.stream.error
            try:
                raise HTTPError(599, message)
            except HTTPError:
                self._handle_exception(*sys.exc_info())

    def headers_received(self, first_line, headers):
        if self.request.expect_100_continue and first_line.code == 100:
            self._write_body(False)
            return
        self.code = first_line.code
        self.reason = first_line.reason
        self.headers = headers

        if self._should_follow_redirect():
            return

        if self.request.header_callback is not None:
            # Reassemble the start line.
            self.request.header_callback('%s %s %s\r\n' % first_line)
            for k, v in self.headers.get_all():
                self.request.header_callback(&quot;%s: %s\r\n&quot; % (k, v))
            self.request.header_callback('\r\n')

    def _should_follow_redirect(self):
        return (self.request.follow_redirects and
                self.request.max_redirects &gt; 0 and
                self.code in (301, 302, 303, 307, 308))

    def finish(self):
        data = b''.join(self.chunks)
        self._remove_timeout()
        original_request = getattr(self.request, &quot;original_request&quot;,
                                   self.request)
        if self._should_follow_redirect():
            assert isinstance(self.request, _RequestProxy)
            new_request = copy.copy(self.request.request)
            new_request.url = urlparse.urljoin(self.request.url,
                                               self.headers[&quot;Location&quot;])
            new_request.max_redirects = self.request.max_redirects - 1
            del new_request.headers[&quot;Host&quot;]
            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4
            # Client SHOULD make a GET request after a 303.
            # According to the spec, 302 should be followed by the same
            # method as the original request, but in practice browsers
            # treat 302 the same as 303, and many servers use 302 for
            # compatibility with pre-HTTP/1.1 user agents which don't
            # understand the 303 status.
            if self.code in (302, 303):
                new_request.method = &quot;GET&quot;
                new_request.body = None
                for h in [&quot;Content-Length&quot;, &quot;Content-Type&quot;,
                          &quot;Content-Encoding&quot;, &quot;Transfer-Encoding&quot;]:
                    try:
                        del self.request.headers[h]
                    except KeyError:
                        pass
            new_request.original_request = original_request
            final_callback = self.final_callback
            self.final_callback = None
            self._release()
            self.client.fetch(new_request, final_callback)
            self._on_end_request()
            return
        if self.request.streaming_callback:
            buffer = BytesIO()
        else:
            buffer = BytesIO(data)  # TODO: don't require one big string?
        response = HTTPResponse(original_request,
                                self.code, reason=getattr(self, 'reason', None),
                                headers=self.headers,
                                request_time=self.io_loop.time() - self.start_time,
                                buffer=buffer,
                                effective_url=self.request.url)
        self._run_callback(response)
        self._on_end_request()

    def _on_end_request(self):
        self.stream.close()

    def data_received(self, chunk):
        if self._should_follow_redirect():
            # We're going to follow a redirect so just discard the body.
            return
        if self.request.streaming_callback is not None:
            self.request.streaming_callback(chunk)
        else:
            self.chunks.append(chunk)


if __name__ == &quot;__main__&quot;:
    AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
    main()
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>nspawn.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Manage nspawn containers

.. versionadded:: 2015.8.0

`systemd-nspawn(1)`__ is a tool used to manage lightweight namespace
containers. This execution module provides several functions to help manage
these containers.

.. __: http://www.freedesktop.org/software/systemd/man/systemd-nspawn.html

Minions running systemd &gt;= 219 will place new containers in
``/var/lib/machines``, while those running systemd &lt; 219 will place them in
``/var/lib/container``.

.. note:

    ``nsenter(1)`` is required to run commands within containers. It should
    already be present on any systemd host, as part of the **util-linux**
    package.
<A NAME="0"></A>&quot;&quot;&quot;


<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match240300-0.html#0',2,'match240300-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import errno
import functools
import logging
import os
import re
import shutil
import tempfile
import time

import salt.defaults.exitcodes
import salt.utils.args
import salt.utils.functools
import salt.utils.path
import salt.utils.systemd
from</B></FONT> salt.exceptions import CommandExecutionError, SaltInvocationError

log = logging.getLogger(__name__)

__func_alias__ = {
    &quot;list_&quot;: &quot;list&quot;,
}
__virtualname__ = &quot;nspawn&quot;
SEED_MARKER = &quot;/nspawn.initial_seed&quot;
WANT = &quot;/etc/systemd/system/multi-user.target.wants/systemd-nspawn@{0}.service&quot;
EXEC_DRIVER = &quot;nsenter&quot;


def __virtual__():
    &quot;&quot;&quot;
    Only work on systems that have been booted with systemd
    &quot;&quot;&quot;
    if __grains__[&quot;kernel&quot;] == &quot;Linux&quot; and salt.utils.systemd.booted(__context__):
        if salt.utils.systemd.version() is None:
            log.error(&quot;nspawn: Unable to determine systemd version&quot;)
        else:
            return __virtualname__
    return (
        False,
        &quot;The nspawn execution module failed to load: &quot;
        &quot;only work on systems that have been booted with systemd.&quot;,
    )


def _sd_version():
    &quot;&quot;&quot;
    Returns __context__.get('systemd.version', 0), avoiding duplication of the
    call to dict.get and making it easier to change how we handle this context
    var in the future
    &quot;&quot;&quot;
    return salt.utils.systemd.version(__context__)


def _ensure_exists(wrapped):
    &quot;&quot;&quot;
    Decorator to ensure that the named container exists.
    &quot;&quot;&quot;

    @functools.wraps(wrapped)
    def check_exists(name, *args, **kwargs):
        if not exists(name):
            raise CommandExecutionError(&quot;Container '{}' does not exist&quot;.format(name))
        return wrapped(name, *args, **salt.utils.args.clean_kwargs(**kwargs))

    return check_exists


def _root(name=&quot;&quot;, all_roots=False):
    &quot;&quot;&quot;
    Return the container root directory. Starting with systemd 219, new
    images go into /var/lib/machines.
    &quot;&quot;&quot;
    if _sd_version() &gt;= 219:
        if all_roots:
            return [
                os.path.join(x, name)
                for x in (&quot;/var/lib/machines&quot;, &quot;/var/lib/container&quot;)
            ]
        else:
            return os.path.join(&quot;/var/lib/machines&quot;, name)
    else:
        ret = os.path.join(&quot;/var/lib/container&quot;, name)
        if all_roots:
            return [ret]
        else:
            return ret


def _make_container_root(name):
    &quot;&quot;&quot;
    Make the container root directory
    &quot;&quot;&quot;
    path = _root(name)
    if os.path.exists(path):
        __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.SALT_BUILD_FAIL
        raise CommandExecutionError(&quot;Container {} already exists&quot;.format(name))
    else:
        try:
            os.makedirs(path)
            return path
        except OSError as exc:
            raise CommandExecutionError(
                &quot;Unable to make container root directory {}: {}&quot;.format(name, exc)
            )


def _build_failed(dst, name):
    try:
        __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.SALT_BUILD_FAIL
        shutil.rmtree(dst)
    except OSError as exc:
        if exc.errno != errno.ENOENT:
            raise CommandExecutionError(
                &quot;Unable to cleanup container root dir {}&quot;.format(dst)
            )
    raise CommandExecutionError(&quot;Container {} failed to build&quot;.format(name))


def _bootstrap_arch(name, **kwargs):
    &quot;&quot;&quot;
    Bootstrap an Arch Linux container
    &quot;&quot;&quot;
    if not salt.utils.path.which(&quot;pacstrap&quot;):
        raise CommandExecutionError(
            &quot;pacstrap not found, is the arch-install-scripts package installed?&quot;
        )
    dst = _make_container_root(name)
    cmd = &quot;pacstrap -c -d {} base&quot;.format(dst)
    ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)
    if ret[&quot;retcode&quot;] != 0:
        _build_failed(dst, name)
    return ret


def _bootstrap_debian(name, **kwargs):
    &quot;&quot;&quot;
    Bootstrap a Debian Linux container
    &quot;&quot;&quot;
    version = kwargs.get(&quot;version&quot;, False)
    if not version:
        if __grains__[&quot;os&quot;].lower() == &quot;debian&quot;:
            version = __grains__[&quot;osrelease&quot;]
        else:
            version = &quot;stable&quot;

    release_blacklist = [
        &quot;hamm&quot;,
        &quot;slink&quot;,
        &quot;potato&quot;,
        &quot;woody&quot;,
        &quot;sarge&quot;,
        &quot;etch&quot;,
        &quot;lenny&quot;,
        &quot;squeeze&quot;,
        &quot;wheezy&quot;,
    ]
    if version in release_blacklist:
        raise CommandExecutionError(
            'Unsupported Debian version &quot;{}&quot;. '
            'Only &quot;stable&quot; or &quot;jessie&quot; and newer are supported'.format(version)
        )

    dst = _make_container_root(name)
    cmd = &quot;debootstrap --arch=amd64 {} {}&quot;.format(version, dst)
    ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)
    if ret[&quot;retcode&quot;] != 0:
        _build_failed(dst, name)
    return ret


def _bootstrap_fedora(name, **kwargs):
    &quot;&quot;&quot;
    Bootstrap a Fedora container
    &quot;&quot;&quot;
    dst = _make_container_root(name)
    if not kwargs.get(&quot;version&quot;, False):
        if __grains__[&quot;os&quot;].lower() == &quot;fedora&quot;:
            version = __grains__[&quot;osrelease&quot;]
        else:
            version = &quot;21&quot;
    else:
        version = &quot;21&quot;
    cmd = (
        &quot;yum -y --releasever={} --nogpg --installroot={} &quot;
        '--disablerepo=&quot;*&quot; --enablerepo=fedora install systemd passwd yum '
        &quot;fedora-release vim-minimal&quot;.format(version, dst)
    )
    ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)
    if ret[&quot;retcode&quot;] != 0:
        _build_failed(dst, name)
    return ret


def _bootstrap_ubuntu(name, **kwargs):
    &quot;&quot;&quot;
    Bootstrap a Ubuntu Linux container
    &quot;&quot;&quot;
    version = kwargs.get(&quot;version&quot;, False)
    if not version:
        if __grains__[&quot;os&quot;].lower() == &quot;ubuntu&quot;:
            version = __grains__[&quot;oscodename&quot;]
        else:
            version = &quot;xenial&quot;
    dst = _make_container_root(name)
    cmd = &quot;debootstrap --arch=amd64 {} {}&quot;.format(version, dst)
    ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)
    if ret[&quot;retcode&quot;] != 0:
        _build_failed(dst, name)
    return ret


def _clear_context():
    &quot;&quot;&quot;
    Clear any lxc variables set in __context__
    &quot;&quot;&quot;
    for var in [x for x in __context__ if x.startswith(&quot;nspawn.&quot;)]:
        log.trace(&quot;Clearing __context__['%s']&quot;, var)
        __context__.pop(var, None)


def _ensure_running(name):
    &quot;&quot;&quot;
    Raise an exception if the container does not exist
    &quot;&quot;&quot;
    if state(name) != &quot;running&quot;:
        return True
    else:
        return start(name)


def _ensure_systemd(version):
    &quot;&quot;&quot;
    Raises an exception if the systemd version is not greater than the
    passed version.
    &quot;&quot;&quot;
    try:
        version = int(version)
    except ValueError:
        raise CommandExecutionError(&quot;Invalid version '{}'&quot;.format(version))

    try:
        installed = _sd_version()
        log.debug(&quot;nspawn: detected systemd %s&quot;, installed)
    except (IndexError, ValueError):
        raise CommandExecutionError(&quot;nspawn: Unable to get systemd version&quot;)

    if installed &lt; version:
        raise CommandExecutionError(
            &quot;This function requires systemd &gt;= {} (Detected version: {}).&quot;.format(
                version, installed
            )
        )


def _machinectl(cmd, output_loglevel=&quot;debug&quot;, ignore_retcode=False, use_vt=False):
    &quot;&quot;&quot;
    Helper function to run machinectl
    &quot;&quot;&quot;
    prefix = &quot;machinectl --no-legend --no-pager&quot;
    return __salt__[&quot;cmd.run_all&quot;](
        &quot;{} {}&quot;.format(prefix, cmd),
        output_loglevel=output_loglevel,
        ignore_retcode=ignore_retcode,
        use_vt=use_vt,
    )


@_ensure_exists
def _run(
    name,
    cmd,
    output=None,
    no_start=False,
    stdin=None,
    python_shell=True,
    preserve_state=False,
    output_loglevel=&quot;debug&quot;,
    ignore_retcode=False,
    use_vt=False,
    keep_env=None,
):
    &quot;&quot;&quot;
    Common logic for nspawn.run functions
    &quot;&quot;&quot;
    orig_state = state(name)
    exc = None
    try:
        ret = __salt__[&quot;container_resource.run&quot;](
            name,
            cmd,
            container_type=__virtualname__,
            exec_driver=EXEC_DRIVER,
            output=output,
            no_start=no_start,
            stdin=stdin,
            python_shell=python_shell,
            output_loglevel=output_loglevel,
            ignore_retcode=ignore_retcode,
            use_vt=use_vt,
            keep_env=keep_env,
        )
    finally:
        # Make sure we stop the container if necessary, even if an exception
        # was raised.
        if preserve_state and orig_state == &quot;stopped&quot; and state(name) != &quot;stopped&quot;:
            stop(name)

    if output in (None, &quot;all&quot;):
        return ret
    else:
        return ret[output]


@_ensure_exists
def pid(name):
    &quot;&quot;&quot;
    Returns the PID of a container

    name
        Container name

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.pid arch1
    &quot;&quot;&quot;
    try:
        return int(info(name).get(&quot;PID&quot;))
    except (TypeError, ValueError) as exc:
        raise CommandExecutionError(
            &quot;Unable to get PID for container '{}': {}&quot;.format(name, exc)
        )


def run(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel=&quot;debug&quot;,
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    &quot;&quot;&quot;
    Run :mod:`cmd.run &lt;salt.modules.cmdmod.run&gt;` within a container

    name
        Name of the container in which to run the command

    cmd
        Command to run

    no_start : False
        If the container is not running, don't start it

    preserve_state : True
        After running the command, return the container to its previous state

    stdin : None
        Standard input to be used for the command

    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.

    use_vt : False
        Use SaltStack's utils.vt to stream output to console.

    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.run mycontainer 'ifconfig -a'
    &quot;&quot;&quot;
    return _run(
        name,
        cmd,
        output=None,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )


def run_stdout(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel=&quot;debug&quot;,
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    &quot;&quot;&quot;
    Run :mod:`cmd.run_stdout &lt;salt.modules.cmdmod.run_stdout&gt;` within a container

    name
        Name of the container in which to run the command

    cmd
        Command to run

    no_start : False
        If the container is not running, don't start it

    preserve_state : True
        After running the command, return the container to its previous state

    stdin : None
        Standard input to be used for the command

    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.

    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.

    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.run_stdout mycontainer 'ifconfig -a'
    &quot;&quot;&quot;
    return _run(
        name,
        cmd,
        output=&quot;stdout&quot;,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )


def run_stderr(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel=&quot;debug&quot;,
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    &quot;&quot;&quot;
    Run :mod:`cmd.run_stderr &lt;salt.modules.cmdmod.run_stderr&gt;` within a container

    name
        Name of the container in which to run the command

    cmd
        Command to run

    no_start : False
        If the container is not running, don't start it

    preserve_state : True
        After running the command, return the container to its previous state

    stdin : None
        Standard input to be used for the command

    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.

    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.

    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.run_stderr mycontainer 'ip addr show'
    &quot;&quot;&quot;
    return _run(
        name,
        cmd,
        output=&quot;stderr&quot;,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )


def retcode(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel=&quot;debug&quot;,
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    &quot;&quot;&quot;
    Run :mod:`cmd.retcode &lt;salt.modules.cmdmod.retcode&gt;` within a container

    name
        Name of the container in which to run the command

    cmd
        Command to run

    no_start : False
        If the container is not running, don't start it

    preserve_state : True
        After running the command, return the container to its previous state

    stdin : None
        Standard input to be used for the command

    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.

    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.

    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.retcode mycontainer 'ip addr show'
    &quot;&quot;&quot;
    return _run(
        name,
        cmd,
        output=&quot;retcode&quot;,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )


def run_all(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel=&quot;debug&quot;,
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    &quot;&quot;&quot;
    Run :mod:`cmd.run_all &lt;salt.modules.cmdmod.run_all&gt;` within a container

    .. note::

        While the command is run within the container, it is initiated from the
        host. Therefore, the PID in the return dict is from the host, not from
        the container.

    name
        Name of the container in which to run the command

    cmd
        Command to run

    no_start : False
        If the container is not running, don't start it

    preserve_state : True
        After running the command, return the container to its previous state

    stdin : None
        Standard input to be used for the command

    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.

    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.

    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.run_all mycontainer 'ip addr show'
    &quot;&quot;&quot;
    return _run(
        name,
        cmd,
        output=&quot;all&quot;,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )


def bootstrap_container(name, dist=None, version=None):
    &quot;&quot;&quot;
    Bootstrap a container from package servers, if dist is None the os the
    minion is running as will be created, otherwise the needed bootstrapping
    tools will need to be available on the host.

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.bootstrap_container &lt;name&gt;
    &quot;&quot;&quot;
    if not dist:
        dist = __grains__[&quot;os&quot;].lower()
        log.debug(&quot;nspawn.bootstrap: no dist provided, defaulting to '%s'&quot;, dist)
    try:
        return globals()[&quot;_bootstrap_{}&quot;.format(dist)](name, version=version)
    except KeyError:
        raise CommandExecutionError('Unsupported distribution &quot;{}&quot;'.format(dist))


def _needs_install(name):
    ret = 0
    has_minion = retcode(name, &quot;command -v salt-minion&quot;)
    # we assume that installing is when no minion is running
    # but testing the executable presence is not enougth for custom
    # installs where the bootstrap can do much more than installing
    # the bare salt binaries.
    if has_minion:
        processes = run_stdout(name, &quot;ps aux&quot;)
        if &quot;salt-minion&quot; not in processes:
            ret = 1
        else:
            retcode(name, &quot;salt-call --local service.stop salt-minion&quot;)
    else:
        ret = 1
    return ret


def bootstrap_salt(
    name,
    config=None,
    approve_key=True,
    install=True,
    pub_key=None,
    priv_key=None,
    bootstrap_url=None,
    force_install=False,
    unconditional_install=False,
    bootstrap_delay=None,
    bootstrap_args=None,
    bootstrap_shell=None,
):
    &quot;&quot;&quot;
    Bootstrap a container from package servers, if dist is None the os the
    minion is running as will be created, otherwise the needed bootstrapping
    tools will need to be available on the host.

    CLI Example:

    .. code-block:: bash

        salt '*' nspawn.bootstrap_salt arch1
    &quot;&quot;&quot;
    if bootstrap_delay is not None:
        try:
            time.sleep(bootstrap_delay)
        except TypeError:
            # Bad input, but assume since a value was passed that
            # a delay was desired, and sleep for 5 seconds
            time.sleep(5)

    c_info = info(name)
    if not c_info:
        return None

    # default set here as we cannot set them
    # in def as it can come from a chain of procedures.
    if bootstrap_args:
        # custom bootstrap args can be totally customized, and user could
        # have inserted the placeholder for the config directory.
        # For example, some salt bootstrap script do not use at all -c
        if &quot;{0}&quot; not in bootstrap_args:
            bootstrap_args += &quot; -c {0}&quot;
    else:
        bootstrap_args = &quot;-c {0}&quot;
    if not bootstrap_shell:
        bootstrap_shell = &quot;sh&quot;

    orig_state = _ensure_running(name)
    if not orig_state:
        return orig_state
    if not force_install:
        needs_install = _needs_install(name)
    else:
        needs_install = True
    seeded = retcode(name, &quot;test -e '{}'&quot;.format(SEED_MARKER)) == 0
    tmp = tempfile.mkdtemp()
    if seeded and not unconditional_install:
        ret = True
    else:
        ret = False
        cfg_files = __salt__[&quot;seed.mkconfig&quot;](
            config,
            tmp=tmp,
            id_=name,
            approve_key=approve_key,
            pub_key=pub_key,
            priv_key=priv_key,
        )
        if needs_install or force_install or unconditional_install:
            if install:
                rstr = __salt__[&quot;test.random_hash&quot;]()
                configdir = &quot;/tmp/.c_{}&quot;.format(rstr)
                run(name, &quot;install -m 0700 -d {}&quot;.format(configdir), python_shell=False)
                bs_ = __salt__[&quot;config.gather_bootstrap_script&quot;](
                    bootstrap=bootstrap_url
                )
                dest_dir = os.path.join(&quot;/tmp&quot;, rstr)
                for cmd in [
                    &quot;mkdir -p {}&quot;.format(dest_dir),
                    &quot;chmod 700 {}&quot;.format(dest_dir),
                ]:
                    if run_stdout(name, cmd):
                        log.error(&quot;tmpdir %s creation failed (%s)&quot;, dest_dir, cmd)
                        return False
                copy_to(name, bs_, &quot;{}/bootstrap.sh&quot;.format(dest_dir), makedirs=True)
                copy_to(name, cfg_files[&quot;config&quot;], os.path.join(configdir, &quot;minion&quot;))
                copy_to(
                    name, cfg_files[&quot;privkey&quot;], os.path.join(configdir, &quot;minion.pem&quot;)
                )
                copy_to(
                    name, cfg_files[&quot;pubkey&quot;], os.path.join(configdir, &quot;minion.pub&quot;)
                )
                bootstrap_args = bootstrap_args.format(configdir)
                cmd = &quot;{0} {2}/bootstrap.sh {1}&quot;.format(
                    bootstrap_shell, bootstrap_args.replace(&quot;'&quot;, &quot;''&quot;), dest_dir
                )
                # log ASAP the forged bootstrap command which can be wrapped
                # out of the output in case of unexpected problem
                log.info(&quot;Running %s in LXC container '%s'&quot;, cmd, name)
                ret = retcode(name, cmd, output_loglevel=&quot;info&quot;, use_vt=True) == 0
            else:
                ret = False
        else:
            minion_config = salt.config.minion_config(cfg_files[&quot;config&quot;])
            pki_dir = minion_config[&quot;pki_dir&quot;]
            copy_to(name, cfg_files[&quot;config&quot;], &quot;/etc/salt/minion&quot;)
            copy_to(name, cfg_files[&quot;privkey&quot;], os.path.join(pki_dir, &quot;minion.pem&quot;))
            copy_to(name, cfg_files[&quot;pubkey&quot;], os.path.join(pki_dir, &quot;minion.pub&quot;))
            run(
                name, &quot;salt-call --local service.enable salt-minion&quot;, python_shell=False
            )
            ret = True
        shutil.rmtree(tmp)
        if orig_state == &quot;stopped&quot;:
            stop(name)
        # mark seeded upon successful install
        if ret:
            run(name, &quot;touch '{}'&quot;.format(SEED_MARKER), python_shell=False)
    return ret


def list_all():
    &quot;&quot;&quot;
    Lists all nspawn containers

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.list_all
    &quot;&quot;&quot;
    ret = []
    if _sd_version() &gt;= 219:
        for line in _machinectl(&quot;list-images&quot;)[&quot;stdout&quot;].splitlines():
            try:
                ret.append(line.split()[0])
            except IndexError:
                continue
    else:
        rootdir = _root()
        try:
            for dirname in os.listdir(rootdir):
                if os.path.isdir(os.path.join(rootdir, dirname)):
                    ret.append(dirname)
        except OSError:
            pass
    return ret


def list_running():
    &quot;&quot;&quot;
    Lists running nspawn containers

    .. note::

        ``nspawn.list`` also works to list running containers

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.list_running
        salt myminion nspawn.list
    &quot;&quot;&quot;
    ret = []
    for line in _machinectl(&quot;list&quot;)[&quot;stdout&quot;].splitlines():
        try:
            ret.append(line.split()[0])
        except IndexError:
            pass
    return sorted(ret)


# 'machinectl list' shows only running containers, so allow this to work as an
# alias to nspawn.list_running
list_ = salt.utils.functools.alias_function(list_running, &quot;list_&quot;)


def list_stopped():
    &quot;&quot;&quot;
    Lists stopped nspawn containers

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.list_stopped
    &quot;&quot;&quot;
    return sorted(set(list_all()) - set(list_running()))


def exists(name):
    &quot;&quot;&quot;
    Returns true if the named container exists

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.exists &lt;name&gt;
    &quot;&quot;&quot;
    contextkey = &quot;nspawn.exists.{}&quot;.format(name)
    if contextkey in __context__:
        return __context__[contextkey]
    __context__[contextkey] = name in list_all()
    return __context__[contextkey]


@_ensure_exists
def state(name):
    &quot;&quot;&quot;
    Return state of container (running or stopped)

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.state &lt;name&gt;
    &quot;&quot;&quot;
    try:
        cmd = &quot;show {} --property=State&quot;.format(name)
        return _machinectl(cmd, ignore_retcode=True)[&quot;stdout&quot;].split(&quot;=&quot;)[-1]
    except IndexError:
        return &quot;stopped&quot;


def info(name, **kwargs):
    &quot;&quot;&quot;
    Return info about a container

    .. note::

        The container must be running for ``machinectl`` to gather information
        about it. If the container is stopped, then this function will start
        it.

    start : False
        If ``True``, then the container will be started to retrieve the info. A
        ``Started`` key will be in the return data if the container was
        started.

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.info arch1
        salt myminion nspawn.info arch1 force_start=False
    &quot;&quot;&quot;
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    start_ = kwargs.pop(&quot;start&quot;, False)
    if kwargs:
        salt.utils.args.invalid_kwargs(kwargs)

    if not start_:
        _ensure_running(name)
    elif name not in list_running():
        start(name)

    # Have to parse 'machinectl status' here since 'machinectl show' doesn't
    # contain IP address info or OS info. *shakes fist angrily*
    c_info = _machinectl(&quot;status {}&quot;.format(name))
    if c_info[&quot;retcode&quot;] != 0:
        raise CommandExecutionError(
            &quot;Unable to get info for container '{}'&quot;.format(name)
        )
    # Better human-readable names. False means key should be ignored.
    key_name_map = {
        &quot;Iface&quot;: &quot;Network Interface&quot;,
        &quot;Leader&quot;: &quot;PID&quot;,
        &quot;Service&quot;: False,
        &quot;Since&quot;: &quot;Running Since&quot;,
    }
    ret = {}
    kv_pair = re.compile(r&quot;^\s+([A-Za-z]+): (.+)$&quot;)
    tree = re.compile(r&quot;[|`]&quot;)
    lines = c_info[&quot;stdout&quot;].splitlines()
    multiline = False
    cur_key = None
    for idx, line in enumerate(lines):
        match = kv_pair.match(line)
        if match:
            key, val = match.groups()
            # Get a better key name if one exists
            key = key_name_map.get(key, key)
            if key is False:
                continue
            elif key == &quot;PID&quot;:
                try:
                    val = val.split()[0]
                except IndexError:
                    pass
            cur_key = key
            if multiline:
                multiline = False
            ret[key] = val
        else:
            if cur_key is None:
                continue
            if tree.search(lines[idx]):
                # We've reached the process tree, bail out
                break
            if multiline:
                ret[cur_key].append(lines[idx].strip())
            else:
                ret[cur_key] = [ret[key], lines[idx].strip()]
                multiline = True
    return ret


@_ensure_exists
def enable(name):
    &quot;&quot;&quot;
    Set the named container to be launched at boot

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.enable &lt;name&gt;
    &quot;&quot;&quot;
    cmd = &quot;systemctl enable systemd-nspawn@{}&quot;.format(name)
    if __salt__[&quot;cmd.retcode&quot;](cmd, python_shell=False) != 0:
        __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True


@_ensure_exists
def disable(name):
    &quot;&quot;&quot;
    Set the named container to *not* be launched at boot

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.enable &lt;name&gt;
    &quot;&quot;&quot;
    cmd = &quot;systemctl disable systemd-nspawn@{}&quot;.format(name)
    if __salt__[&quot;cmd.retcode&quot;](cmd, python_shell=False) != 0:
        __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True


@_ensure_exists
def start(name):
    &quot;&quot;&quot;
    Start the named container

    CLI Example:

    .. code-block:: bash

        salt myminion nspawn.start &lt;name&gt;
    &quot;&quot;&quot;
    if _sd_version() &gt;= 219:
        ret = _machinectl(&quot;start {}&quot;.format(name))
    else:
        cmd = &quot;systemctl start systemd-nspawn@{}&quot;.format(name)
        ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)

    if ret[&quot;retcode&quot;] != 0:
        __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True


# This function is hidden from sphinx docs
@_ensure_exists
def stop(name, kill=False):
    &quot;&quot;&quot;
    This is a compatibility function which provides the logic for
    nspawn.poweroff and nspawn.terminate.
    &quot;&quot;&quot;
    if _sd_version() &gt;= 219:
        if kill:
            action = &quot;terminate&quot;
        else:
            action = &quot;poweroff&quot;
        ret = _machinectl(&quot;{} {}&quot;.format(action, name))
    else:
        cmd = &quot;systemctl stop systemd-nspawn@{}&quot;.format(name)
        ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)

    if ret[&quot;retcode&quot;] != 0:
        __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True


def poweroff(name):
    &quot;&quot;&quot;
    Issue a clean shutdown to the container.  Equivalent to running
    ``machinectl poweroff`` on the named container.

    For convenience, running ``nspawn.stop``(as shown in the CLI examples
    below) is equivalent to running ``nspawn.poweroff``.

    .. note::

        ``machinectl poweroff`` is only supported in systemd &gt;= 219. On earlier
        systemd versions, running this function will simply issue a clean
        shutdown via ``systemctl``.

    CLI Examples:

    .. code-block:: bash

        salt myminion nspawn.poweroff arch1
        salt myminion nspawn.stop arch1
    &quot;&quot;&quot;
    return stop(name, kill=False)


def terminate(name):
    &quot;&quot;&quot;
    Kill all processes in the container without issuing a clean shutdown.
    Equivalent to running ``machinectl terminate`` on the named container.

    For convenience, running ``nspawn.stop`` and passing ``kill=True`` (as
    shown in the CLI examples below) is equivalent to running
    ``nspawn.terminate``.

    .. note::

        ``machinectl terminate`` is only supported in systemd &gt;= 219. On
        earlier systemd versions, running this function will simply issue a
        clean shutdown via ``systemctl``.

    CLI Examples:

    .. code-block:: bash

        salt myminion nspawn.terminate arch1
        salt myminion nspawn.stop arch1 kill=True
    &quot;&quot;&quot;
    return stop(name, kill=True)


# This function is hidden from sphinx docs
def restart(name):
    &quot;&quot;&quot;
    This is a compatibility function which simply calls nspawn.reboot.
    &quot;&quot;&quot;
    return reboot(name)


@_ensure_exists
def reboot(name, kill=False):
    &quot;&quot;&quot;
    Reboot the container by sending a SIGINT to its init process. Equivalent
    to running ``machinectl reboot`` on the named container.

    For convenience, running ``nspawn.restart`` (as shown in the CLI examples
    below) is equivalent to running ``nspawn.reboot``.

    .. note::

        ``machinectl reboot`` is only supported in systemd &gt;= 219. On earlier
        systemd versions, running this function will instead restart the
        container via ``systemctl``.

    CLI Examples:

    .. code-block:: bash

        salt myminion nspawn.reboot arch1
        salt myminion nspawn.restart arch1
    &quot;&quot;&quot;
    if _sd_version() &gt;= 219:
        if state(name) == &quot;running&quot;:
            ret = _machinectl(&quot;reboot {}&quot;.format(name))
        else:
            # 'machinectl reboot' will fail on a stopped container
            return start(name)
    else:
        # 'systemctl restart' did not work, at least in my testing. Running
        # 'uptime' in the container afterwards showed it had not rebooted. So,
        # we need stop and start the container in separate actions.

        # First stop the container
        cmd = &quot;systemctl stop systemd-nspawn@{}&quot;.format(name)
        ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)
        # Now check if successful
        if ret[&quot;retcode&quot;] != 0:
            __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.EX_UNAVAILABLE
            return False
        # Finally, start the container back up. No need to check the retcode a
        # second time, it'll be checked below once we exit the if/else block.
        cmd = &quot;systemctl start systemd-nspawn@{}&quot;.format(name)
        ret = __salt__[&quot;cmd.run_all&quot;](cmd, python_shell=False)

    if ret[&quot;retcode&quot;] != 0:
        __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True


@_ensure_exists
def remove(name, stop=False):
    &quot;&quot;&quot;
    Remove the named container

    .. warning::

        This function will remove all data associated with the container. It
        will not, however, remove the btrfs subvolumes created by pulling
        container images (:mod:`nspawn.pull_raw
        &lt;salt.modules.nspawn.pull_raw&gt;`, :mod:`nspawn.pull_tar
        &lt;salt.modules.nspawn.pull_tar&gt;`, :mod:`nspawn.pull_dkr
        &lt;salt.modules.nspawn.pull_dkr&gt;`).

    stop : False
        If ``True``, the container will be destroyed even if it is
        running/frozen.

    CLI Examples:

    .. code-block:: bash

        salt '*' nspawn.remove foo
        salt '*' nspawn.remove foo stop=True
    &quot;&quot;&quot;
    if not stop and state(name) != &quot;stopped&quot;:
        raise CommandExecutionError(&quot;Container '{}' is not stopped&quot;.format(name))

    def _failed_remove(name, exc):
        raise CommandExecutionError(
            &quot;Unable to remove container '{}': {}&quot;.format(name, exc)
        )

    if _sd_version() &gt;= 219:
        ret = _machinectl(&quot;remove {}&quot;.format(name))
        if ret[&quot;retcode&quot;] != 0:
            __context__[&quot;retcode&quot;] = salt.defaults.exitcodes.EX_UNAVAILABLE
            _failed_remove(name, ret[&quot;stderr&quot;])
    else:
        try:
            shutil.rmtree(os.path.join(_root(), name))
        except OSError as exc:
            _failed_remove(name, exc)
    return True


# Compatibility between LXC and nspawn
destroy = salt.utils.functools.alias_function(remove, &quot;destroy&quot;)


@_ensure_exists
def copy_to(name, source, dest, overwrite=False, makedirs=False):
    &quot;&quot;&quot;
    Copy a file from the host into a container

    name
        Container name

    source
        File to be copied to the container

    dest
        Destination on the container. Must be an absolute path.

    overwrite : False
        Unless this option is set to ``True``, then if a file exists at the
        location specified by the ``dest`` argument, an error will be raised.

    makedirs : False

        Create the parent directory on the container if it does not already
        exist.

    CLI Example:

    .. code-block:: bash

        salt 'minion' nspawn.copy_to /tmp/foo /root/foo
    &quot;&quot;&quot;
    path = source
    try:
        if source.startswith(&quot;salt://&quot;):
            cached_source = __salt__[&quot;cp.cache_file&quot;](source)
            if not cached_source:
                raise CommandExecutionError(&quot;Unable to cache {}&quot;.format(source))
            path = cached_source
    except AttributeError:
        raise SaltInvocationError(&quot;Invalid source file {}&quot;.format(source))

    if _sd_version() &gt;= 219:
        # TODO: Use machinectl copy-to
        pass
    return __salt__[&quot;container_resource.copy_to&quot;](
        name,
        path,
        dest,
        container_type=__virtualname__,
        exec_driver=EXEC_DRIVER,
        overwrite=overwrite,
        makedirs=makedirs,
    )


cp = salt.utils.functools.alias_function(copy_to, &quot;cp&quot;)


# Everything below requres systemd &gt;= 219
# TODO: Write a decorator to keep these functions from being available to older
#       systemd versions.
def _pull_image(pull_type, image, name, **kwargs):
    &quot;&quot;&quot;
    Common logic for machinectl pull-* commands
    &quot;&quot;&quot;
    _ensure_systemd(219)
    if exists(name):
        raise SaltInvocationError(&quot;Container '{}' already exists&quot;.format(name))
    if pull_type in (&quot;raw&quot;, &quot;tar&quot;):
        valid_kwargs = (&quot;verify&quot;,)
    elif pull_type == &quot;dkr&quot;:
        valid_kwargs = (&quot;index&quot;,)
    else:
        raise SaltInvocationError(&quot;Unsupported image type '{}'&quot;.format(pull_type))

    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    bad_kwargs = {
        x: y
        for x, y in salt.utils.args.clean_kwargs(**kwargs).items()
        if x not in valid_kwargs
    }

    if bad_kwargs:
        salt.utils.args.invalid_kwargs(bad_kwargs)

    pull_opts = []

    if pull_type in (&quot;raw&quot;, &quot;tar&quot;):
        verify = kwargs.get(&quot;verify&quot;, False)
        if not verify:
            pull_opts.append(&quot;--verify=no&quot;)
        else:

            def _bad_verify():
                raise SaltInvocationError(
                    &quot;'verify' must be one of the following: signature, checksum&quot;
                )

            try:
                verify = verify.lower()
            except AttributeError:
                _bad_verify()
            else:
                if verify not in (&quot;signature&quot;, &quot;checksum&quot;):
                    _bad_verify()
                pull_opts.append(&quot;--verify={}&quot;.format(verify))

    elif pull_type == &quot;dkr&quot;:
        # No need to validate the index URL, machinectl will take care of this
        # for us.
        if &quot;index&quot; in kwargs:
            pull_opts.append(&quot;--dkr-index-url={}&quot;.format(kwargs[&quot;index&quot;]))

    cmd = &quot;pull-{} {} {} {}&quot;.format(pull_type, &quot; &quot;.join(pull_opts), image, name)
    result = _machinectl(cmd, use_vt=True)
    if result[&quot;retcode&quot;] != 0:
        msg = (
            &quot;Error occurred pulling image. Stderr from the pull command &quot;
            &quot;(if any) follows: &quot;
        )
        if result[&quot;stderr&quot;]:
            msg += &quot;\n\n{}&quot;.format(result[&quot;stderr&quot;])
        raise CommandExecutionError(msg)
    return True


def pull_raw(url, name, verify=False):
    &quot;&quot;&quot;
    Execute a ``machinectl pull-raw`` to download a .qcow2 or raw disk image,
    and add it to /var/lib/machines as a new container.

    .. note::

        **Requires systemd &gt;= 219**

    url
        URL from which to download the container

    name
        Name for the new container

    verify : False
        Perform signature or checksum verification on the container. See the
        ``machinectl(1)`` man page (section titled &quot;Image Transfer Commands&quot;)
        for more information on requirements for image verification. To perform
        signature verification, use ``verify=signature``. For checksum
        verification, use ``verify=checksum``. By default, no verification will
        be performed.

    CLI Examples:

    .. code-block:: bash

        salt myminion nspawn.pull_raw http://ftp.halifax.rwth-aachen.de/fedora/linux/releases/21/Cloud/Images/x86_64/Fedora-Cloud-Base-20141203-21.x86_64.raw.xz fedora21
    &quot;&quot;&quot;
    return _pull_image(&quot;raw&quot;, url, name, verify=verify)


def pull_tar(url, name, verify=False):
    &quot;&quot;&quot;
    Execute a ``machinectl pull-raw`` to download a .tar container image,
    and add it to /var/lib/machines as a new container.

    .. note::

        **Requires systemd &gt;= 219**

    url
        URL from which to download the container

    name
        Name for the new container

    verify : False
        Perform signature or checksum verification on the container. See the
        ``machinectl(1)`` man page (section titled &quot;Image Transfer Commands&quot;)
        for more information on requirements for image verification. To perform
        signature verification, use ``verify=signature``. For checksum
        verification, use ``verify=checksum``. By default, no verification will
        be performed.

    CLI Examples:

    .. code-block:: bash

        salt myminion nspawn.pull_tar http://foo.domain.tld/containers/archlinux-2015.02.01.tar.gz arch2
    &quot;&quot;&quot;
    return _pull_image(&quot;tar&quot;, url, name, verify=verify)


def pull_dkr(url, name, index):
    &quot;&quot;&quot;
    Execute a ``machinectl pull-dkr`` to download a docker image and add it to
    /var/lib/machines as a new container.

    .. note::

        **Requires systemd &gt;= 219**

    url
        URL from which to download the container

    name
        Name for the new container

    index
        URL of the Docker index server from which to pull (must be an
        ``http://`` or ``https://`` URL).

    CLI Examples:

    .. code-block:: bash

        salt myminion nspawn.pull_dkr centos/centos6 cent6 index=https://get.docker.com
        salt myminion nspawn.pull_docker centos/centos6 cent6 index=https://get.docker.com
    &quot;&quot;&quot;
    return _pull_image(&quot;dkr&quot;, url, name, index=index)


pull_docker = salt.utils.functools.alias_function(pull_dkr, &quot;pull_docker&quot;)
</PRE>
</div>
  </div>
</body>
</html>
