<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for simple_httpclient.py &amp; nspawn.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for simple_httpclient.py &amp; nspawn.py
      </h3>
<h1 align="center">
        1.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>simple_httpclient.py (1.3592232%)<th>nspawn.py (1.088647%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(3-18)<td><a href="#" name="0">(24-38)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>simple_httpclient.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>from __future__ import absolute_import, division, print_function
from salt.ext.tornado.escape import utf8, _unicode
from salt.ext.tornado import gen
from salt.ext.tornado.httpclient import HTTPResponse, HTTPError, AsyncHTTPClient, main, _RequestProxy
from salt.ext.tornado import httputil
from salt.ext.tornado.http1connection import HTTP1Connection, HTTP1ConnectionParameters
from salt.ext.tornado.iostream import StreamClosedError
from salt.ext.tornado.netutil import Resolver, OverrideResolver, _client_ssl_defaults
from salt.ext.tornado.log import gen_log
from salt.ext.tornado import stack_context
from salt.ext.tornado.tcpclient import TCPClient
from salt.ext.tornado.util import PY3
import base64
import</b></font> collections
import copy
import functools
import re
import socket
import sys
from io import BytesIO
if PY3:
    import urllib.parse as urlparse
else:
    import urlparse
try:
    import ssl
except ImportError:
    ssl = None
try:
    import certifi
except ImportError:
    certifi = None
def _default_ca_certs():
    if certifi is None:
        raise Exception("The 'certifi' package is required to use https "
                        "in simple_httpclient")
    return certifi.where()
class SimpleAsyncHTTPClient(AsyncHTTPClient):
    """Non-blocking HTTP client with no external dependencies.
    This class implements an HTTP 1.1 client on top of Tornado's IOStreams.
    Some features found in the curl-based AsyncHTTPClient are not yet
    supported.  In particular, proxies are not supported, connections
    are not reused, and callers cannot select the network interface to be
    used.
    """
    def initialize(self, io_loop, max_clients=10,
                   hostname_mapping=None, max_buffer_size=104857600,
                   resolver=None, defaults=None, max_header_size=None,
                   max_body_size=None):
        """Creates a AsyncHTTPClient.
        Only a single AsyncHTTPClient instance exists per IOLoop
        in order to provide limitations on the number of pending connections.
        ``force_instance=True`` may be used to suppress this behavior.
        Note that because of this implicit reuse, unless ``force_instance``
        is used, only the first call to the constructor actually uses
        its arguments. It is recommended to use the ``configure`` method
        instead of the constructor to ensure that arguments take effect.
        ``max_clients`` is the number of concurrent requests that can be
        in progress; when this limit is reached additional requests will be
        queued. Note that time spent waiting in this queue still counts
        against the ``request_timeout``.
        ``hostname_mapping`` is a dictionary mapping hostnames to IP addresses.
        It can be used to make local DNS changes when modifying system-wide
        settings like ``/etc/hosts`` is not possible or desirable (e.g. in
        unittests).
        ``max_buffer_size`` (default 100MB) is the number of bytes
        that can be read into memory at once. ``max_body_size``
        (defaults to ``max_buffer_size``) is the largest response body
        that the client will accept.  Without a
        ``streaming_callback``, the smaller of these two limits
        applies; with a ``streaming_callback`` only ``max_body_size``
        does.
        .. versionchanged:: 4.2
           Added the ``max_body_size`` argument.
        """
        super(SimpleAsyncHTTPClient, self).initialize(io_loop,
                                                      defaults=defaults)
        self.max_clients = max_clients
        self.queue = collections.deque()
        self.active = {}
        self.waiting = {}
        self.max_buffer_size = max_buffer_size
        self.max_header_size = max_header_size
        self.max_body_size = max_body_size
        if resolver:
            self.resolver = resolver
            self.own_resolver = False
        else:
            self.resolver = Resolver(io_loop=io_loop)
            self.own_resolver = True
        if hostname_mapping is not None:
            self.resolver = OverrideResolver(resolver=self.resolver,
                                             mapping=hostname_mapping)
        self.tcp_client = TCPClient(resolver=self.resolver, io_loop=io_loop)
    def close(self):
        super(SimpleAsyncHTTPClient, self).close()
        if self.own_resolver:
            self.resolver.close()
        self.tcp_client.close()
    def fetch_impl(self, request, callback):
        key = object()
        self.queue.append((key, request, callback))
        if not len(self.active) &lt; self.max_clients:
            timeout_handle = self.io_loop.add_timeout(
                self.io_loop.time() + min(request.connect_timeout,
                                          request.request_timeout),
                functools.partial(self._on_timeout, key, "in request queue"))
        else:
            timeout_handle = None
        self.waiting[key] = (request, callback, timeout_handle)
        self._process_queue()
        if self.queue:
            gen_log.debug("max_clients limit reached, request queued. "
                          "%d active, %d queued requests." % (
                              len(self.active), len(self.queue)))
    def _process_queue(self):
        with stack_context.NullContext():
            while self.queue and len(self.active) &lt; self.max_clients:
                key, request, callback = self.queue.popleft()
                if key not in self.waiting:
                    continue
                self._remove_timeout(key)
                self.active[key] = (request, callback)
                release_callback = functools.partial(self._release_fetch, key)
                self._handle_request(request, release_callback, callback)
    def _connection_class(self):
        return _HTTPConnection
    def _handle_request(self, request, release_callback, final_callback):
        self._connection_class()(
            self.io_loop, self, request, release_callback,
            final_callback, self.max_buffer_size, self.tcp_client,
            self.max_header_size, self.max_body_size)
    def _release_fetch(self, key):
        del self.active[key]
        self._process_queue()
    def _remove_timeout(self, key):
        if key in self.waiting:
            request, callback, timeout_handle = self.waiting[key]
            if timeout_handle is not None:
                self.io_loop.remove_timeout(timeout_handle)
            del self.waiting[key]
    def _on_timeout(self, key, info=None):
        """Timeout callback of request.
        Construct a timeout HTTPResponse when a timeout occurs.
        :arg object key: A simple object to mark the request.
        :info string key: More detailed timeout information.
        """
        request, callback, timeout_handle = self.waiting[key]
        self.queue.remove((key, request, callback))
        error_message = "Timeout {0}".format(info) if info else "Timeout"
        timeout_response = HTTPResponse(
            request, 599, error=HTTPError(599, error_message),
            request_time=self.io_loop.time() - request.start_time)
        self.io_loop.add_callback(callback, timeout_response)
        del self.waiting[key]
class _HTTPConnection(httputil.HTTPMessageDelegate):
    _SUPPORTED_METHODS = set(["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"])
    def __init__(self, io_loop, client, request, release_callback,
                 final_callback, max_buffer_size, tcp_client,
                 max_header_size, max_body_size):
        self.start_time = io_loop.time()
        self.io_loop = io_loop
        self.client = client
        self.request = request
        self.release_callback = release_callback
        self.final_callback = final_callback
        self.max_buffer_size = max_buffer_size
        self.tcp_client = tcp_client
        self.max_header_size = max_header_size
        self.max_body_size = max_body_size
        self.code = None
        self.headers = None
        self.chunks = []
        self._decompressor = None
        self._timeout = None
        self._sockaddr = None
        with stack_context.ExceptionStackContext(self._handle_exception):
            self.parsed = urlparse.urlsplit(_unicode(self.request.url))
            if self.parsed.scheme not in ("http", "https"):
                raise ValueError("Unsupported url scheme: %s" %
                                 self.request.url)
            netloc = self.parsed.netloc
            if "@" in netloc:
                userpass, _, netloc = netloc.rpartition("@")
            host, port = httputil.split_host_and_port(netloc)
            if port is None:
                port = 443 if self.parsed.scheme == "https" else 80
            if re.match(r'^\[.*\]$', host):
                host = host[1:-1]
            self.parsed_hostname = host  # save final host for _on_connect
            if request.allow_ipv6 is False:
                af = socket.AF_INET
            else:
                af = socket.AF_UNSPEC
            ssl_options = self._get_ssl_options(self.parsed.scheme)
            timeout = min(self.request.connect_timeout, self.request.request_timeout)
            if timeout:
                self._timeout = self.io_loop.add_timeout(
                    self.start_time + timeout,
                    stack_context.wrap(functools.partial(self._on_timeout, "while connecting")))
            self.tcp_client.connect(host, port, af=af,
                                    ssl_options=ssl_options,
                                    max_buffer_size=self.max_buffer_size,
                                    callback=self._on_connect)
    def _get_ssl_options(self, scheme):
        if scheme == "https":
            if self.request.ssl_options is not None:
                return self.request.ssl_options
            if (self.request.validate_cert and
                    self.request.ca_certs is None and
                    self.request.client_cert is None and
                    self.request.client_key is None):
                return _client_ssl_defaults
            ssl_options = {}
            if self.request.validate_cert:
                ssl_options["cert_reqs"] = ssl.CERT_REQUIRED
            if self.request.ca_certs is not None:
                ssl_options["ca_certs"] = self.request.ca_certs
            elif not hasattr(ssl, 'create_default_context'):
                ssl_options["ca_certs"] = _default_ca_certs()
            if self.request.client_key is not None:
                ssl_options["keyfile"] = self.request.client_key
            if self.request.client_cert is not None:
                ssl_options["certfile"] = self.request.client_cert
            if sys.version_info &gt;= (2, 7):
                ssl_options["ciphers"] = "DEFAULT:!SSLv2:!EXPORT:!DES"
            else:
                ssl_options["ssl_version"] = ssl.PROTOCOL_TLSv1
            return ssl_options
        return None
    def _on_timeout(self, info=None):
        """Timeout callback of _HTTPConnection instance.
        Raise a timeout HTTPError when a timeout occurs.
        :info string key: More detailed timeout information.
        """
        self._timeout = None
        error_message = "Timeout {0}".format(info) if info else "Timeout"
        if self.final_callback is not None:
            raise HTTPError(599, error_message)
    def _remove_timeout(self):
        if self._timeout is not None:
            self.io_loop.remove_timeout(self._timeout)
            self._timeout = None
    def _on_connect(self, stream):
        if self.final_callback is None:
            stream.close()
            return
        self.stream = stream
        self.stream.set_close_callback(self.on_connection_close)
        self._remove_timeout()
        if self.final_callback is None:
            return
        if self.request.request_timeout:
            self._timeout = self.io_loop.add_timeout(
                self.start_time + self.request.request_timeout,
                stack_context.wrap(functools.partial(self._on_timeout, "during request")))
        if (self.request.method not in self._SUPPORTED_METHODS and
                not self.request.allow_nonstandard_methods):
            raise KeyError("unknown method %s" % self.request.method)
        for key in ('network_interface',
                    'proxy_host', 'proxy_port',
                    'proxy_username', 'proxy_password',
                    'proxy_auth_mode'):
            if getattr(self.request, key, None):
                raise NotImplementedError('%s not supported' % key)
        if "Connection" not in self.request.headers:
            self.request.headers["Connection"] = "close"
        if "Host" not in self.request.headers:
            if '@' in self.parsed.netloc:
                self.request.headers["Host"] = self.parsed.netloc.rpartition('@')[-1]
            else:
                self.request.headers["Host"] = self.parsed.netloc
        username, password = None, None
        if self.parsed.username is not None:
            username, password = self.parsed.username, self.parsed.password
        elif self.request.auth_username is not None:
            username = self.request.auth_username
            password = self.request.auth_password or ''
        if username is not None:
            if self.request.auth_mode not in (None, "basic"):
                raise ValueError("unsupported auth_mode %s",
                                 self.request.auth_mode)
            auth = utf8(username) + b":" + utf8(password)
            self.request.headers["Authorization"] = (b"Basic " +
                                                     base64.b64encode(auth))
        if self.request.user_agent:
            self.request.headers["User-Agent"] = self.request.user_agent
        if not self.request.allow_nonstandard_methods:
            body_expected = self.request.method in ("POST", "PATCH", "PUT")
            body_present = (self.request.body is not None or
                            self.request.body_producer is not None)
            if ((body_expected and not body_present) or
                    (body_present and not body_expected)):
                raise ValueError(
                    'Body must %sbe None for method %s (unless '
                    'allow_nonstandard_methods is true)' %
                    ('not ' if body_expected else '', self.request.method))
        if self.request.expect_100_continue:
            self.request.headers["Expect"] = "100-continue"
        if self.request.body is not None:
            self.request.headers["Content-Length"] = str(len(
                self.request.body))
        if (self.request.method == "POST" and
                "Content-Type" not in self.request.headers):
            self.request.headers["Content-Type"] = "application/x-www-form-urlencoded"
        if self.request.decompress_response:
            self.request.headers["Accept-Encoding"] = "gzip"
        req_path = ((self.parsed.path or '/') +
                    (('?' + self.parsed.query) if self.parsed.query else ''))
        self.connection = self._create_connection(stream)
        start_line = httputil.RequestStartLine(self.request.method,
                                               req_path, '')
        self.connection.write_headers(start_line, self.request.headers)
        if self.request.expect_100_continue:
            self._read_response()
        else:
            self._write_body(True)
    def _create_connection(self, stream):
        stream.set_nodelay(True)
        connection = HTTP1Connection(
            stream, True,
            HTTP1ConnectionParameters(
                no_keep_alive=True,
                max_header_size=self.max_header_size,
                max_body_size=self.max_body_size,
                decompress=self.request.decompress_response),
            self._sockaddr)
        return connection
    def _write_body(self, start_read):
        if self.request.body is not None:
            self.connection.write(self.request.body)
        elif self.request.body_producer is not None:
            fut = self.request.body_producer(self.connection.write)
            if fut is not None:
                fut = gen.convert_yielded(fut)
                def on_body_written(fut):
                    fut.result()
                    self.connection.finish()
                    if start_read:
                        self._read_response()
                self.io_loop.add_future(fut, on_body_written)
                return
        self.connection.finish()
        if start_read:
            self._read_response()
    def _read_response(self):
        self.io_loop.add_future(
            self.connection.read_response(self),
            lambda f: f.result())
    def _release(self):
        if self.release_callback is not None:
            release_callback = self.release_callback
            self.release_callback = None
            release_callback()
    def _run_callback(self, response):
        self._release()
        if self.final_callback is not None:
            final_callback = self.final_callback
            self.final_callback = None
            self.io_loop.add_callback(final_callback, response)
    def _handle_exception(self, typ, value, tb):
        if self.final_callback:
            self._remove_timeout()
            if isinstance(value, StreamClosedError):
                if value.real_error is None:
                    value = HTTPError(599, "Stream closed")
                else:
                    value = value.real_error
            self._run_callback(HTTPResponse(self.request, 599, error=value,
                                            request_time=self.io_loop.time() - self.start_time,
                                            ))
            if hasattr(self, "stream"):
                self.stream.close()
            return True
        else:
            return isinstance(value, StreamClosedError)
    def on_connection_close(self):
        if self.final_callback is not None:
            message = "Connection closed"
            if self.stream.error:
                raise self.stream.error
            try:
                raise HTTPError(599, message)
            except HTTPError:
                self._handle_exception(*sys.exc_info())
    def headers_received(self, first_line, headers):
        if self.request.expect_100_continue and first_line.code == 100:
            self._write_body(False)
            return
        self.code = first_line.code
        self.reason = first_line.reason
        self.headers = headers
        if self._should_follow_redirect():
            return
        if self.request.header_callback is not None:
            self.request.header_callback('%s %s %s\r\n' % first_line)
            for k, v in self.headers.get_all():
                self.request.header_callback("%s: %s\r\n" % (k, v))
            self.request.header_callback('\r\n')
    def _should_follow_redirect(self):
        return (self.request.follow_redirects and
                self.request.max_redirects &gt; 0 and
                self.code in (301, 302, 303, 307, 308))
    def finish(self):
        data = b''.join(self.chunks)
        self._remove_timeout()
        original_request = getattr(self.request, "original_request",
                                   self.request)
        if self._should_follow_redirect():
            assert isinstance(self.request, _RequestProxy)
            new_request = copy.copy(self.request.request)
            new_request.url = urlparse.urljoin(self.request.url,
                                               self.headers["Location"])
            new_request.max_redirects = self.request.max_redirects - 1
            del new_request.headers["Host"]
            if self.code in (302, 303):
                new_request.method = "GET"
                new_request.body = None
                for h in ["Content-Length", "Content-Type",
                          "Content-Encoding", "Transfer-Encoding"]:
                    try:
                        del self.request.headers[h]
                    except KeyError:
                        pass
            new_request.original_request = original_request
            final_callback = self.final_callback
            self.final_callback = None
            self._release()
            self.client.fetch(new_request, final_callback)
            self._on_end_request()
            return
        if self.request.streaming_callback:
            buffer = BytesIO()
        else:
            buffer = BytesIO(data)  # TODO: don't require one big string?
        response = HTTPResponse(original_request,
                                self.code, reason=getattr(self, 'reason', None),
                                headers=self.headers,
                                request_time=self.io_loop.time() - self.start_time,
                                buffer=buffer,
                                effective_url=self.request.url)
        self._run_callback(response)
        self._on_end_request()
    def _on_end_request(self):
        self.stream.close()
    def data_received(self, chunk):
        if self._should_follow_redirect():
            return
        if self.request.streaming_callback is not None:
            self.request.streaming_callback(chunk)
        else:
            self.chunks.append(chunk)
if __name__ == "__main__":
    AsyncHTTPClient.configure(SimpleAsyncHTTPClient)
    main()
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>nspawn.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Manage nspawn containers
.. versionadded:: 2015.8.0
`systemd-nspawn(1)`__ is a tool used to manage lightweight namespace
containers. This execution module provides several functions to help manage
these containers.
.. __: http://www.freedesktop.org/software/systemd/man/systemd-nspawn.html
Minions running systemd &gt;= 219 will place new containers in
``/var/lib/machines``, while those running systemd &lt; 219 will place them in
``/var/lib/container``.
.. note:
    ``nsenter(1)`` is required to run commands within containers. It should
    already be present on any systemd host, as part of the **util-linux**
    package.
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import errno
import functools
import logging
import os
import re
import shutil
import tempfile
import time
import salt.defaults.exitcodes
import salt.utils.args
import salt.utils.functools
import salt.utils.path
import salt.utils.systemd
from</b></font> salt.exceptions import CommandExecutionError, SaltInvocationError
log = logging.getLogger(__name__)
__func_alias__ = {
    "list_": "list",
}
__virtualname__ = "nspawn"
SEED_MARKER = "/nspawn.initial_seed"
WANT = "/etc/systemd/system/multi-user.target.wants/systemd-nspawn@{0}.service"
EXEC_DRIVER = "nsenter"
def __virtual__():
    """
    Only work on systems that have been booted with systemd
    """
    if __grains__["kernel"] == "Linux" and salt.utils.systemd.booted(__context__):
        if salt.utils.systemd.version() is None:
            log.error("nspawn: Unable to determine systemd version")
        else:
            return __virtualname__
    return (
        False,
        "The nspawn execution module failed to load: "
        "only work on systems that have been booted with systemd.",
    )
def _sd_version():
    """
    Returns __context__.get('systemd.version', 0), avoiding duplication of the
    call to dict.get and making it easier to change how we handle this context
    var in the future
    """
    return salt.utils.systemd.version(__context__)
def _ensure_exists(wrapped):
    """
    Decorator to ensure that the named container exists.
    """
    @functools.wraps(wrapped)
    def check_exists(name, *args, **kwargs):
        if not exists(name):
            raise CommandExecutionError("Container '{}' does not exist".format(name))
        return wrapped(name, *args, **salt.utils.args.clean_kwargs(**kwargs))
    return check_exists
def _root(name="", all_roots=False):
    """
    Return the container root directory. Starting with systemd 219, new
    images go into /var/lib/machines.
    """
    if _sd_version() &gt;= 219:
        if all_roots:
            return [
                os.path.join(x, name)
                for x in ("/var/lib/machines", "/var/lib/container")
            ]
        else:
            return os.path.join("/var/lib/machines", name)
    else:
        ret = os.path.join("/var/lib/container", name)
        if all_roots:
            return [ret]
        else:
            return ret
def _make_container_root(name):
    """
    Make the container root directory
    """
    path = _root(name)
    if os.path.exists(path):
        __context__["retcode"] = salt.defaults.exitcodes.SALT_BUILD_FAIL
        raise CommandExecutionError("Container {} already exists".format(name))
    else:
        try:
            os.makedirs(path)
            return path
        except OSError as exc:
            raise CommandExecutionError(
                "Unable to make container root directory {}: {}".format(name, exc)
            )
def _build_failed(dst, name):
    try:
        __context__["retcode"] = salt.defaults.exitcodes.SALT_BUILD_FAIL
        shutil.rmtree(dst)
    except OSError as exc:
        if exc.errno != errno.ENOENT:
            raise CommandExecutionError(
                "Unable to cleanup container root dir {}".format(dst)
            )
    raise CommandExecutionError("Container {} failed to build".format(name))
def _bootstrap_arch(name, **kwargs):
    """
    Bootstrap an Arch Linux container
    """
    if not salt.utils.path.which("pacstrap"):
        raise CommandExecutionError(
            "pacstrap not found, is the arch-install-scripts package installed?"
        )
    dst = _make_container_root(name)
    cmd = "pacstrap -c -d {} base".format(dst)
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        _build_failed(dst, name)
    return ret
def _bootstrap_debian(name, **kwargs):
    """
    Bootstrap a Debian Linux container
    """
    version = kwargs.get("version", False)
    if not version:
        if __grains__["os"].lower() == "debian":
            version = __grains__["osrelease"]
        else:
            version = "stable"
    release_blacklist = [
        "hamm",
        "slink",
        "potato",
        "woody",
        "sarge",
        "etch",
        "lenny",
        "squeeze",
        "wheezy",
    ]
    if version in release_blacklist:
        raise CommandExecutionError(
            'Unsupported Debian version "{}". '
            'Only "stable" or "jessie" and newer are supported'.format(version)
        )
    dst = _make_container_root(name)
    cmd = "debootstrap --arch=amd64 {} {}".format(version, dst)
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        _build_failed(dst, name)
    return ret
def _bootstrap_fedora(name, **kwargs):
    """
    Bootstrap a Fedora container
    """
    dst = _make_container_root(name)
    if not kwargs.get("version", False):
        if __grains__["os"].lower() == "fedora":
            version = __grains__["osrelease"]
        else:
            version = "21"
    else:
        version = "21"
    cmd = (
        "yum -y --releasever={} --nogpg --installroot={} "
        '--disablerepo="*" --enablerepo=fedora install systemd passwd yum '
        "fedora-release vim-minimal".format(version, dst)
    )
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        _build_failed(dst, name)
    return ret
def _bootstrap_ubuntu(name, **kwargs):
    """
    Bootstrap a Ubuntu Linux container
    """
    version = kwargs.get("version", False)
    if not version:
        if __grains__["os"].lower() == "ubuntu":
            version = __grains__["oscodename"]
        else:
            version = "xenial"
    dst = _make_container_root(name)
    cmd = "debootstrap --arch=amd64 {} {}".format(version, dst)
    ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        _build_failed(dst, name)
    return ret
def _clear_context():
    """
    Clear any lxc variables set in __context__
    """
    for var in [x for x in __context__ if x.startswith("nspawn.")]:
        log.trace("Clearing __context__['%s']", var)
        __context__.pop(var, None)
def _ensure_running(name):
    """
    Raise an exception if the container does not exist
    """
    if state(name) != "running":
        return True
    else:
        return start(name)
def _ensure_systemd(version):
    """
    Raises an exception if the systemd version is not greater than the
    passed version.
    """
    try:
        version = int(version)
    except ValueError:
        raise CommandExecutionError("Invalid version '{}'".format(version))
    try:
        installed = _sd_version()
        log.debug("nspawn: detected systemd %s", installed)
    except (IndexError, ValueError):
        raise CommandExecutionError("nspawn: Unable to get systemd version")
    if installed &lt; version:
        raise CommandExecutionError(
            "This function requires systemd &gt;= {} (Detected version: {}).".format(
                version, installed
            )
        )
def _machinectl(cmd, output_loglevel="debug", ignore_retcode=False, use_vt=False):
    """
    Helper function to run machinectl
    """
    prefix = "machinectl --no-legend --no-pager"
    return __salt__["cmd.run_all"](
        "{} {}".format(prefix, cmd),
        output_loglevel=output_loglevel,
        ignore_retcode=ignore_retcode,
        use_vt=use_vt,
    )
@_ensure_exists
def _run(
    name,
    cmd,
    output=None,
    no_start=False,
    stdin=None,
    python_shell=True,
    preserve_state=False,
    output_loglevel="debug",
    ignore_retcode=False,
    use_vt=False,
    keep_env=None,
):
    """
    Common logic for nspawn.run functions
    """
    orig_state = state(name)
    exc = None
    try:
        ret = __salt__["container_resource.run"](
            name,
            cmd,
            container_type=__virtualname__,
            exec_driver=EXEC_DRIVER,
            output=output,
            no_start=no_start,
            stdin=stdin,
            python_shell=python_shell,
            output_loglevel=output_loglevel,
            ignore_retcode=ignore_retcode,
            use_vt=use_vt,
            keep_env=keep_env,
        )
    finally:
        if preserve_state and orig_state == "stopped" and state(name) != "stopped":
            stop(name)
    if output in (None, "all"):
        return ret
    else:
        return ret[output]
@_ensure_exists
def pid(name):
    """
    Returns the PID of a container
    name
        Container name
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.pid arch1
    """
    try:
        return int(info(name).get("PID"))
    except (TypeError, ValueError) as exc:
        raise CommandExecutionError(
            "Unable to get PID for container '{}': {}".format(name, exc)
        )
def run(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    """
    Run :mod:`cmd.run &lt;salt.modules.cmdmod.run&gt;` within a container
    name
        Name of the container in which to run the command
    cmd
        Command to run
    no_start : False
        If the container is not running, don't start it
    preserve_state : True
        After running the command, return the container to its previous state
    stdin : None
        Standard input to be used for the command
    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.
    use_vt : False
        Use SaltStack's utils.vt to stream output to console.
    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.run mycontainer 'ifconfig -a'
    """
    return _run(
        name,
        cmd,
        output=None,
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )
def run_stdout(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    """
    Run :mod:`cmd.run_stdout &lt;salt.modules.cmdmod.run_stdout&gt;` within a container
    name
        Name of the container in which to run the command
    cmd
        Command to run
    no_start : False
        If the container is not running, don't start it
    preserve_state : True
        After running the command, return the container to its previous state
    stdin : None
        Standard input to be used for the command
    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.
    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.
    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.run_stdout mycontainer 'ifconfig -a'
    """
    return _run(
        name,
        cmd,
        output="stdout",
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )
def run_stderr(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    """
    Run :mod:`cmd.run_stderr &lt;salt.modules.cmdmod.run_stderr&gt;` within a container
    name
        Name of the container in which to run the command
    cmd
        Command to run
    no_start : False
        If the container is not running, don't start it
    preserve_state : True
        After running the command, return the container to its previous state
    stdin : None
        Standard input to be used for the command
    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.
    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.
    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.run_stderr mycontainer 'ip addr show'
    """
    return _run(
        name,
        cmd,
        output="stderr",
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )
def retcode(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    """
    Run :mod:`cmd.retcode &lt;salt.modules.cmdmod.retcode&gt;` within a container
    name
        Name of the container in which to run the command
    cmd
        Command to run
    no_start : False
        If the container is not running, don't start it
    preserve_state : True
        After running the command, return the container to its previous state
    stdin : None
        Standard input to be used for the command
    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.
    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.
    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.retcode mycontainer 'ip addr show'
    """
    return _run(
        name,
        cmd,
        output="retcode",
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )
def run_all(
    name,
    cmd,
    no_start=False,
    preserve_state=True,
    stdin=None,
    python_shell=True,
    output_loglevel="debug",
    use_vt=False,
    ignore_retcode=False,
    keep_env=None,
):
    """
    Run :mod:`cmd.run_all &lt;salt.modules.cmdmod.run_all&gt;` within a container
    .. note::
        While the command is run within the container, it is initiated from the
        host. Therefore, the PID in the return dict is from the host, not from
        the container.
    name
        Name of the container in which to run the command
    cmd
        Command to run
    no_start : False
        If the container is not running, don't start it
    preserve_state : True
        After running the command, return the container to its previous state
    stdin : None
        Standard input to be used for the command
    output_loglevel : debug
        Level at which to log the output from the command. Set to ``quiet`` to
        suppress logging.
    use_vt : False
        Use SaltStack's utils.vt to stream output to console. Assumes
        ``output=all``.
    keep_env : None
        If not passed, only a sane default PATH environment variable will be
        set. If ``True``, all environment variables from the container's host
        will be kept. Otherwise, a comma-separated list (or Python list) of
        environment variable names can be passed, and those environment
        variables will be kept.
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.run_all mycontainer 'ip addr show'
    """
    return _run(
        name,
        cmd,
        output="all",
        no_start=no_start,
        preserve_state=preserve_state,
        stdin=stdin,
        python_shell=python_shell,
        output_loglevel=output_loglevel,
        use_vt=use_vt,
        ignore_retcode=ignore_retcode,
        keep_env=keep_env,
    )
def bootstrap_container(name, dist=None, version=None):
    """
    Bootstrap a container from package servers, if dist is None the os the
    minion is running as will be created, otherwise the needed bootstrapping
    tools will need to be available on the host.
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.bootstrap_container &lt;name&gt;
    """
    if not dist:
        dist = __grains__["os"].lower()
        log.debug("nspawn.bootstrap: no dist provided, defaulting to '%s'", dist)
    try:
        return globals()["_bootstrap_{}".format(dist)](name, version=version)
    except KeyError:
        raise CommandExecutionError('Unsupported distribution "{}"'.format(dist))
def _needs_install(name):
    ret = 0
    has_minion = retcode(name, "command -v salt-minion")
    if has_minion:
        processes = run_stdout(name, "ps aux")
        if "salt-minion" not in processes:
            ret = 1
        else:
            retcode(name, "salt-call --local service.stop salt-minion")
    else:
        ret = 1
    return ret
def bootstrap_salt(
    name,
    config=None,
    approve_key=True,
    install=True,
    pub_key=None,
    priv_key=None,
    bootstrap_url=None,
    force_install=False,
    unconditional_install=False,
    bootstrap_delay=None,
    bootstrap_args=None,
    bootstrap_shell=None,
):
    """
    Bootstrap a container from package servers, if dist is None the os the
    minion is running as will be created, otherwise the needed bootstrapping
    tools will need to be available on the host.
    CLI Example:
    .. code-block:: bash
        salt '*' nspawn.bootstrap_salt arch1
    """
    if bootstrap_delay is not None:
        try:
            time.sleep(bootstrap_delay)
        except TypeError:
            time.sleep(5)
    c_info = info(name)
    if not c_info:
        return None
    if bootstrap_args:
        if "{0}" not in bootstrap_args:
            bootstrap_args += " -c {0}"
    else:
        bootstrap_args = "-c {0}"
    if not bootstrap_shell:
        bootstrap_shell = "sh"
    orig_state = _ensure_running(name)
    if not orig_state:
        return orig_state
    if not force_install:
        needs_install = _needs_install(name)
    else:
        needs_install = True
    seeded = retcode(name, "test -e '{}'".format(SEED_MARKER)) == 0
    tmp = tempfile.mkdtemp()
    if seeded and not unconditional_install:
        ret = True
    else:
        ret = False
        cfg_files = __salt__["seed.mkconfig"](
            config,
            tmp=tmp,
            id_=name,
            approve_key=approve_key,
            pub_key=pub_key,
            priv_key=priv_key,
        )
        if needs_install or force_install or unconditional_install:
            if install:
                rstr = __salt__["test.random_hash"]()
                configdir = "/tmp/.c_{}".format(rstr)
                run(name, "install -m 0700 -d {}".format(configdir), python_shell=False)
                bs_ = __salt__["config.gather_bootstrap_script"](
                    bootstrap=bootstrap_url
                )
                dest_dir = os.path.join("/tmp", rstr)
                for cmd in [
                    "mkdir -p {}".format(dest_dir),
                    "chmod 700 {}".format(dest_dir),
                ]:
                    if run_stdout(name, cmd):
                        log.error("tmpdir %s creation failed (%s)", dest_dir, cmd)
                        return False
                copy_to(name, bs_, "{}/bootstrap.sh".format(dest_dir), makedirs=True)
                copy_to(name, cfg_files["config"], os.path.join(configdir, "minion"))
                copy_to(
                    name, cfg_files["privkey"], os.path.join(configdir, "minion.pem")
                )
                copy_to(
                    name, cfg_files["pubkey"], os.path.join(configdir, "minion.pub")
                )
                bootstrap_args = bootstrap_args.format(configdir)
                cmd = "{0} {2}/bootstrap.sh {1}".format(
                    bootstrap_shell, bootstrap_args.replace("'", "''"), dest_dir
                )
                log.info("Running %s in LXC container '%s'", cmd, name)
                ret = retcode(name, cmd, output_loglevel="info", use_vt=True) == 0
            else:
                ret = False
        else:
            minion_config = salt.config.minion_config(cfg_files["config"])
            pki_dir = minion_config["pki_dir"]
            copy_to(name, cfg_files["config"], "/etc/salt/minion")
            copy_to(name, cfg_files["privkey"], os.path.join(pki_dir, "minion.pem"))
            copy_to(name, cfg_files["pubkey"], os.path.join(pki_dir, "minion.pub"))
            run(
                name, "salt-call --local service.enable salt-minion", python_shell=False
            )
            ret = True
        shutil.rmtree(tmp)
        if orig_state == "stopped":
            stop(name)
        if ret:
            run(name, "touch '{}'".format(SEED_MARKER), python_shell=False)
    return ret
def list_all():
    """
    Lists all nspawn containers
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.list_all
    """
    ret = []
    if _sd_version() &gt;= 219:
        for line in _machinectl("list-images")["stdout"].splitlines():
            try:
                ret.append(line.split()[0])
            except IndexError:
                continue
    else:
        rootdir = _root()
        try:
            for dirname in os.listdir(rootdir):
                if os.path.isdir(os.path.join(rootdir, dirname)):
                    ret.append(dirname)
        except OSError:
            pass
    return ret
def list_running():
    """
    Lists running nspawn containers
    .. note::
        ``nspawn.list`` also works to list running containers
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.list_running
        salt myminion nspawn.list
    """
    ret = []
    for line in _machinectl("list")["stdout"].splitlines():
        try:
            ret.append(line.split()[0])
        except IndexError:
            pass
    return sorted(ret)
list_ = salt.utils.functools.alias_function(list_running, "list_")
def list_stopped():
    """
    Lists stopped nspawn containers
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.list_stopped
    """
    return sorted(set(list_all()) - set(list_running()))
def exists(name):
    """
    Returns true if the named container exists
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.exists &lt;name&gt;
    """
    contextkey = "nspawn.exists.{}".format(name)
    if contextkey in __context__:
        return __context__[contextkey]
    __context__[contextkey] = name in list_all()
    return __context__[contextkey]
@_ensure_exists
def state(name):
    """
    Return state of container (running or stopped)
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.state &lt;name&gt;
    """
    try:
        cmd = "show {} --property=State".format(name)
        return _machinectl(cmd, ignore_retcode=True)["stdout"].split("=")[-1]
    except IndexError:
        return "stopped"
def info(name, **kwargs):
    """
    Return info about a container
    .. note::
        The container must be running for ``machinectl`` to gather information
        about it. If the container is stopped, then this function will start
        it.
    start : False
        If ``True``, then the container will be started to retrieve the info. A
        ``Started`` key will be in the return data if the container was
        started.
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.info arch1
        salt myminion nspawn.info arch1 force_start=False
    """
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    start_ = kwargs.pop("start", False)
    if kwargs:
        salt.utils.args.invalid_kwargs(kwargs)
    if not start_:
        _ensure_running(name)
    elif name not in list_running():
        start(name)
    c_info = _machinectl("status {}".format(name))
    if c_info["retcode"] != 0:
        raise CommandExecutionError(
            "Unable to get info for container '{}'".format(name)
        )
    key_name_map = {
        "Iface": "Network Interface",
        "Leader": "PID",
        "Service": False,
        "Since": "Running Since",
    }
    ret = {}
    kv_pair = re.compile(r"^\s+([A-Za-z]+): (.+)$")
    tree = re.compile(r"[|`]")
    lines = c_info["stdout"].splitlines()
    multiline = False
    cur_key = None
    for idx, line in enumerate(lines):
        match = kv_pair.match(line)
        if match:
            key, val = match.groups()
            key = key_name_map.get(key, key)
            if key is False:
                continue
            elif key == "PID":
                try:
                    val = val.split()[0]
                except IndexError:
                    pass
            cur_key = key
            if multiline:
                multiline = False
            ret[key] = val
        else:
            if cur_key is None:
                continue
            if tree.search(lines[idx]):
                break
            if multiline:
                ret[cur_key].append(lines[idx].strip())
            else:
                ret[cur_key] = [ret[key], lines[idx].strip()]
                multiline = True
    return ret
@_ensure_exists
def enable(name):
    """
    Set the named container to be launched at boot
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.enable &lt;name&gt;
    """
    cmd = "systemctl enable systemd-nspawn@{}".format(name)
    if __salt__["cmd.retcode"](cmd, python_shell=False) != 0:
        __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True
@_ensure_exists
def disable(name):
    """
    Set the named container to *not* be launched at boot
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.enable &lt;name&gt;
    """
    cmd = "systemctl disable systemd-nspawn@{}".format(name)
    if __salt__["cmd.retcode"](cmd, python_shell=False) != 0:
        __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True
@_ensure_exists
def start(name):
    """
    Start the named container
    CLI Example:
    .. code-block:: bash
        salt myminion nspawn.start &lt;name&gt;
    """
    if _sd_version() &gt;= 219:
        ret = _machinectl("start {}".format(name))
    else:
        cmd = "systemctl start systemd-nspawn@{}".format(name)
        ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True
@_ensure_exists
def stop(name, kill=False):
    """
    This is a compatibility function which provides the logic for
    nspawn.poweroff and nspawn.terminate.
    """
    if _sd_version() &gt;= 219:
        if kill:
            action = "terminate"
        else:
            action = "poweroff"
        ret = _machinectl("{} {}".format(action, name))
    else:
        cmd = "systemctl stop systemd-nspawn@{}".format(name)
        ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True
def poweroff(name):
    """
    Issue a clean shutdown to the container.  Equivalent to running
    ``machinectl poweroff`` on the named container.
    For convenience, running ``nspawn.stop``(as shown in the CLI examples
    below) is equivalent to running ``nspawn.poweroff``.
    .. note::
        ``machinectl poweroff`` is only supported in systemd &gt;= 219. On earlier
        systemd versions, running this function will simply issue a clean
        shutdown via ``systemctl``.
    CLI Examples:
    .. code-block:: bash
        salt myminion nspawn.poweroff arch1
        salt myminion nspawn.stop arch1
    """
    return stop(name, kill=False)
def terminate(name):
    """
    Kill all processes in the container without issuing a clean shutdown.
    Equivalent to running ``machinectl terminate`` on the named container.
    For convenience, running ``nspawn.stop`` and passing ``kill=True`` (as
    shown in the CLI examples below) is equivalent to running
    ``nspawn.terminate``.
    .. note::
        ``machinectl terminate`` is only supported in systemd &gt;= 219. On
        earlier systemd versions, running this function will simply issue a
        clean shutdown via ``systemctl``.
    CLI Examples:
    .. code-block:: bash
        salt myminion nspawn.terminate arch1
        salt myminion nspawn.stop arch1 kill=True
    """
    return stop(name, kill=True)
def restart(name):
    """
    This is a compatibility function which simply calls nspawn.reboot.
    """
    return reboot(name)
@_ensure_exists
def reboot(name, kill=False):
    """
    Reboot the container by sending a SIGINT to its init process. Equivalent
    to running ``machinectl reboot`` on the named container.
    For convenience, running ``nspawn.restart`` (as shown in the CLI examples
    below) is equivalent to running ``nspawn.reboot``.
    .. note::
        ``machinectl reboot`` is only supported in systemd &gt;= 219. On earlier
        systemd versions, running this function will instead restart the
        container via ``systemctl``.
    CLI Examples:
    .. code-block:: bash
        salt myminion nspawn.reboot arch1
        salt myminion nspawn.restart arch1
    """
    if _sd_version() &gt;= 219:
        if state(name) == "running":
            ret = _machinectl("reboot {}".format(name))
        else:
            return start(name)
    else:
        cmd = "systemctl stop systemd-nspawn@{}".format(name)
        ret = __salt__["cmd.run_all"](cmd, python_shell=False)
        if ret["retcode"] != 0:
            __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
            return False
        cmd = "systemctl start systemd-nspawn@{}".format(name)
        ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    if ret["retcode"] != 0:
        __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
        return False
    return True
@_ensure_exists
def remove(name, stop=False):
    """
    Remove the named container
    .. warning::
        This function will remove all data associated with the container. It
        will not, however, remove the btrfs subvolumes created by pulling
        container images (:mod:`nspawn.pull_raw
        &lt;salt.modules.nspawn.pull_raw&gt;`, :mod:`nspawn.pull_tar
        &lt;salt.modules.nspawn.pull_tar&gt;`, :mod:`nspawn.pull_dkr
        &lt;salt.modules.nspawn.pull_dkr&gt;`).
    stop : False
        If ``True``, the container will be destroyed even if it is
        running/frozen.
    CLI Examples:
    .. code-block:: bash
        salt '*' nspawn.remove foo
        salt '*' nspawn.remove foo stop=True
    """
    if not stop and state(name) != "stopped":
        raise CommandExecutionError("Container '{}' is not stopped".format(name))
    def _failed_remove(name, exc):
        raise CommandExecutionError(
            "Unable to remove container '{}': {}".format(name, exc)
        )
    if _sd_version() &gt;= 219:
        ret = _machinectl("remove {}".format(name))
        if ret["retcode"] != 0:
            __context__["retcode"] = salt.defaults.exitcodes.EX_UNAVAILABLE
            _failed_remove(name, ret["stderr"])
    else:
        try:
            shutil.rmtree(os.path.join(_root(), name))
        except OSError as exc:
            _failed_remove(name, exc)
    return True
destroy = salt.utils.functools.alias_function(remove, "destroy")
@_ensure_exists
def copy_to(name, source, dest, overwrite=False, makedirs=False):
    """
    Copy a file from the host into a container
    name
        Container name
    source
        File to be copied to the container
    dest
        Destination on the container. Must be an absolute path.
    overwrite : False
        Unless this option is set to ``True``, then if a file exists at the
        location specified by the ``dest`` argument, an error will be raised.
    makedirs : False
        Create the parent directory on the container if it does not already
        exist.
    CLI Example:
    .. code-block:: bash
        salt 'minion' nspawn.copy_to /tmp/foo /root/foo
    """
    path = source
    try:
        if source.startswith("salt://"):
            cached_source = __salt__["cp.cache_file"](source)
            if not cached_source:
                raise CommandExecutionError("Unable to cache {}".format(source))
            path = cached_source
    except AttributeError:
        raise SaltInvocationError("Invalid source file {}".format(source))
    if _sd_version() &gt;= 219:
        pass
    return __salt__["container_resource.copy_to"](
        name,
        path,
        dest,
        container_type=__virtualname__,
        exec_driver=EXEC_DRIVER,
        overwrite=overwrite,
        makedirs=makedirs,
    )
cp = salt.utils.functools.alias_function(copy_to, "cp")
def _pull_image(pull_type, image, name, **kwargs):
    """
    Common logic for machinectl pull-* commands
    """
    _ensure_systemd(219)
    if exists(name):
        raise SaltInvocationError("Container '{}' already exists".format(name))
    if pull_type in ("raw", "tar"):
        valid_kwargs = ("verify",)
    elif pull_type == "dkr":
        valid_kwargs = ("index",)
    else:
        raise SaltInvocationError("Unsupported image type '{}'".format(pull_type))
    kwargs = salt.utils.args.clean_kwargs(**kwargs)
    bad_kwargs = {
        x: y
        for x, y in salt.utils.args.clean_kwargs(**kwargs).items()
        if x not in valid_kwargs
    }
    if bad_kwargs:
        salt.utils.args.invalid_kwargs(bad_kwargs)
    pull_opts = []
    if pull_type in ("raw", "tar"):
        verify = kwargs.get("verify", False)
        if not verify:
            pull_opts.append("--verify=no")
        else:
            def _bad_verify():
                raise SaltInvocationError(
                    "'verify' must be one of the following: signature, checksum"
                )
            try:
                verify = verify.lower()
            except AttributeError:
                _bad_verify()
            else:
                if verify not in ("signature", "checksum"):
                    _bad_verify()
                pull_opts.append("--verify={}".format(verify))
    elif pull_type == "dkr":
        if "index" in kwargs:
            pull_opts.append("--dkr-index-url={}".format(kwargs["index"]))
    cmd = "pull-{} {} {} {}".format(pull_type, " ".join(pull_opts), image, name)
    result = _machinectl(cmd, use_vt=True)
    if result["retcode"] != 0:
        msg = (
            "Error occurred pulling image. Stderr from the pull command "
            "(if any) follows: "
        )
        if result["stderr"]:
            msg += "\n\n{}".format(result["stderr"])
        raise CommandExecutionError(msg)
    return True
def pull_raw(url, name, verify=False):
    """
    Execute a ``machinectl pull-raw`` to download a .qcow2 or raw disk image,
    and add it to /var/lib/machines as a new container.
    .. note::
        **Requires systemd &gt;= 219**
    url
        URL from which to download the container
    name
        Name for the new container
    verify : False
        Perform signature or checksum verification on the container. See the
        ``machinectl(1)`` man page (section titled "Image Transfer Commands")
        for more information on requirements for image verification. To perform
        signature verification, use ``verify=signature``. For checksum
        verification, use ``verify=checksum``. By default, no verification will
        be performed.
    CLI Examples:
    .. code-block:: bash
        salt myminion nspawn.pull_raw http://ftp.halifax.rwth-aachen.de/fedora/linux/releases/21/Cloud/Images/x86_64/Fedora-Cloud-Base-20141203-21.x86_64.raw.xz fedora21
    """
    return _pull_image("raw", url, name, verify=verify)
def pull_tar(url, name, verify=False):
    """
    Execute a ``machinectl pull-raw`` to download a .tar container image,
    and add it to /var/lib/machines as a new container.
    .. note::
        **Requires systemd &gt;= 219**
    url
        URL from which to download the container
    name
        Name for the new container
    verify : False
        Perform signature or checksum verification on the container. See the
        ``machinectl(1)`` man page (section titled "Image Transfer Commands")
        for more information on requirements for image verification. To perform
        signature verification, use ``verify=signature``. For checksum
        verification, use ``verify=checksum``. By default, no verification will
        be performed.
    CLI Examples:
    .. code-block:: bash
        salt myminion nspawn.pull_tar http://foo.domain.tld/containers/archlinux-2015.02.01.tar.gz arch2
    """
    return _pull_image("tar", url, name, verify=verify)
def pull_dkr(url, name, index):
    """
    Execute a ``machinectl pull-dkr`` to download a docker image and add it to
    /var/lib/machines as a new container.
    .. note::
        **Requires systemd &gt;= 219**
    url
        URL from which to download the container
    name
        Name for the new container
    index
        URL of the Docker index server from which to pull (must be an
        ``http://`` or ``https://`` URL).
    CLI Examples:
    .. code-block:: bash
        salt myminion nspawn.pull_dkr centos/centos6 cent6 index=https://get.docker.com
        salt myminion nspawn.pull_docker centos/centos6 cent6 index=https://get.docker.com
    """
    return _pull_image("dkr", url, name, index=index)
pull_docker = salt.utils.functools.alias_function(pull_dkr, "pull_docker")
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
