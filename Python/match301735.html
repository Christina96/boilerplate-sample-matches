<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for openbsdpkg.py &amp; file_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for openbsdpkg.py &amp; file_1.py
      </h3>
<h1 align="center">
        0.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>openbsdpkg.py (3.4482758%)<th>file_1.py (0.16438356%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(93-98)<td><a href="#" name="0">(7143-7150)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>openbsdpkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import copy
import logging
import re
import salt.utils.data
import salt.utils.versions
from salt.exceptions import CommandExecutionError, MinionError
log = logging.getLogger(__name__)
__PKG_RE = re.compile("^((?:[^-]+|-(?![0-9]))+)-([0-9][^-]*)(?:-(.*))?$")
__virtualname__ = "pkg"
def __virtual__():
    if __grains__["os"] == "OpenBSD":
        return __virtualname__
    return (
        False,
        "The openbsdpkg execution module cannot be loaded: "
        "only available on OpenBSD systems.",
    )
def _list_pkgs_from_context(versions_as_list):
    if versions_as_list:
        return __context__["pkg.list_pkgs"]
    else:
        ret = copy.deepcopy(__context__["pkg.list_pkgs"])
        __salt__["pkg_resource.stringify"](ret)
        return ret
def list_pkgs(versions_as_list=False, **kwargs):
    versions_as_list = salt.utils.data.is_true(versions_as_list)
    if any(
        [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
    ):
        return {}
    if "pkg.list_pkgs" in __context__ and kwargs.get("use_context", True):
        return _list_pkgs_from_context(versions_as_list)
<a name="0"></a>    ret = {}
    cmd = "pkg_info -q -a"
    out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace")
    for line in out<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.splitlines():
        try:
            pkgname, pkgver, flavor = __PKG_RE.match(line).groups()
        except AttributeError:
            continue
        pkgname +=</b></font> "--{}".format(flavor) if flavor else ""
        __salt__["pkg_resource.add_pkg"](ret, pkgname, pkgver)
    __salt__["pkg_resource.sort_pkglist"](ret)
    __context__["pkg.list_pkgs"] = copy.deepcopy(ret)
    if not versions_as_list:
        __salt__["pkg_resource.stringify"](ret)
    return ret
def latest_version(*names, **kwargs):
    kwargs.pop("refresh", True)
    pkgs = list_pkgs()
    ret = {}
    for name in names:
        ret[name] = ""
        cmd = "pkg_info -Q {}".format(name)
        out = __salt__["cmd.run_stdout"](
            cmd, python_shell=False, output_loglevel="trace"
        )
        for line in out.splitlines():
            try:
                pkgname, pkgver, flavor = __PKG_RE.match(line).groups()
            except AttributeError:
                continue
            match = re.match(r".*\(installed\)$", pkgver)
            if match:
                break
            if "{}--{}".format(pkgname, flavor) == name:
                pkgname += "--{}".format(flavor)
            elif pkgname == name:
                pass
            else:
                continue
            cur = pkgs.get(pkgname, "")
            if not cur or salt.utils.versions.compare(ver1=cur, oper="&lt;", ver2=pkgver):
                ret[pkgname] = pkgver
    if len(names) == 1:
        return ret[names[0]]
    return ret
def version(*names, **kwargs):
    return __salt__["pkg_resource.version"](*names, **kwargs)
def install(name=None, pkgs=None, sources=None, **kwargs):
    try:
        pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
            name, pkgs, sources, **kwargs
        )
    except MinionError as exc:
        raise CommandExecutionError(exc)
    if pkg_params is None or len(pkg_params) == 0:
        return {}
    old = list_pkgs()
    errors = []
    for pkg in pkg_params:
        if pkg_type == "repository":
            stem, branch = (pkg.split("%") + [""])[:2]
            base, flavor = (stem.split("--") + [""])[:2]
            pkg = "{}--{}%{}".format(base, flavor, branch)
        cmd = "pkg_add -x -I {}".format(pkg)
        out = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="trace")
        if out["retcode"] != 0 and out["stderr"]:
            errors.append(out["stderr"])
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)
    if errors:
        raise CommandExecutionError(
            "Problem encountered installing package(s)",
            info={"errors": errors, "changes": ret},
        )
    return ret
def remove(name=None, pkgs=None, purge=False, **kwargs):
    try:
        pkg_params = [
            x.split("--")[0]
            for x in __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
        ]
    except MinionError as exc:
        raise CommandExecutionError(exc)
    old = list_pkgs()
    targets = [x for x in pkg_params if x in old]
    if not targets:
        return {}
    cmd = ["pkg_delete", "-Ix", "-Ddependencies"]
    if purge:
        cmd.append("-cqq")
    cmd.extend(targets)
    out = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="trace")
    if out["retcode"] != 0 and out["stderr"]:
        errors = [out["stderr"]]
    else:
        errors = []
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)
    if errors:
        raise CommandExecutionError(
            "Problem encountered removing package(s)",
            info={"errors": errors, "changes": ret},
        )
    return ret
def purge(name=None, pkgs=None, **kwargs):
    return remove(name=name, pkgs=pkgs, purge=True)
def upgrade_available(name, **kwargs):
    return latest_version(name) != ""
def upgrade(name=None, pkgs=None, **kwargs):
    old = list_pkgs()
    cmd = ["pkg_add", "-Ix", "-u"]
    if kwargs.get("noop", False):
        cmd.append("-n")
    if pkgs:
        cmd.extend(pkgs)
    elif name:
        cmd.append(name)
    result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
    __context__.pop("pkg.list_pkgs", None)
    new = list_pkgs()
    ret = salt.utils.data.compare_dicts(old, new)
    if result["retcode"] != 0:
        raise CommandExecutionError(
            "Problem encountered upgrading packages",
            info={"changes": ret, "result": result},
        )
    return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>file_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
import errno
import fnmatch
import glob
import hashlib
import itertools
import logging
import mmap
import operator
import os
import re
import shutil
import stat
import string
import sys
import tempfile
import time
import urllib.parse
from collections import namedtuple
from collections.abc import Iterable, Mapping
from functools import reduce
import salt.utils.args
import salt.utils.atomicfile
import salt.utils.data
import salt.utils.filebuffer
import salt.utils.files
import salt.utils.find
import salt.utils.functools
import salt.utils.hashutils
import salt.utils.http
import salt.utils.itertools
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
import salt.utils.templates
import salt.utils.url
import salt.utils.user
import salt.utils.versions
from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
from salt.exceptions import get_error_message as _get_error_message
from salt.utils.files import HASHES, HASHES_REVMAP
try:
    import grp
    import pwd
except ImportError:
    pass
log = logging.getLogger(__name__)
__func_alias__ = {"makedirs_": "makedirs"}
AttrChanges = namedtuple("AttrChanges", "added,removed")
def __virtual__():
    if salt.utils.platform.is_windows():
        return (
            False,
            "The file execution module cannot be loaded: only available on "
            "non-Windows systems - use win_file instead.",
        )
    return True
def __clean_tmp(sfn):
    if sfn.startswith(
        os.path.join(tempfile.gettempdir(), salt.utils.files.TEMPFILE_PREFIX)
    ):
        all_roots = itertools.chain.from_iterable(__opts__["file_roots"].values())
        in_roots = any(sfn.startswith(root) for root in all_roots)
        if os.path.exists(sfn) and not in_roots:
            os.remove(sfn)
def _error(ret, err_msg):
    ret["result"] = False
    ret["comment"] = err_msg
    return ret
def _binary_replace(old, new):
    old_isbin = not __utils__["files.is_text"](old)
    new_isbin = not __utils__["files.is_text"](new)
    if any((old_isbin, new_isbin)):
        if all((old_isbin, new_isbin)):
            return "Replace binary file"
        elif old_isbin:
            return "Replace binary file with text file"
        elif new_isbin:
            return "Replace text file with binary file"
    return ""
def _get_bkroot():
    return os.path.join(__salt__["config.get"]("cachedir"), "file_backup")
def _splitlines_preserving_trailing_newline(str):
    lines = str.splitlines()
    if str.endswith("\n") or str.endswith("\r"):
        lines.append("")
    return lines
def _chattr_version():
    tune2fs = salt.utils.path.which("tune2fs")
    if not tune2fs or salt.utils.platform.is_aix():
        return None
    cmd = [tune2fs]
    result = __salt__["cmd.run"](cmd, ignore_retcode=True, python_shell=False)
    match = re.search(
        r"tune2fs (?P&lt;version&gt;[0-9\.]+)",
        salt.utils.stringutils.to_str(result),
    )
    if match is None:
        version = None
    else:
        version = match.group("version")
    return version
def _chattr_has_extended_attrs():
    ver = _chattr_version()
    if ver is None:
        return False
    needed_version = salt.utils.versions.LooseVersion("1.41.12")
    chattr_version = salt.utils.versions.LooseVersion(ver)
    return chattr_version &gt; needed_version
def gid_to_group(gid):
    try:
        gid = int(gid)
    except ValueError:
        gid = group_to_gid(gid)
    if gid == "":
        return ""
    try:
        return grp.getgrgid(gid).gr_name
    except (KeyError, NameError):
        return gid
def group_to_gid(group):
    if group is None:
        return ""
    try:
        if isinstance(group, int):
            return group
        return grp.getgrnam(group).gr_gid
    except KeyError:
        return ""
def get_gid(path, follow_symlinks=True):
    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
        "gid", -1
    )
def get_group(path, follow_symlinks=True):
    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
        "group", False
    )
def uid_to_user(uid):
    try:
        return pwd.getpwuid(uid).pw_name
    except (KeyError, NameError):
        return uid
def user_to_uid(user):
    if user is None:
        user = salt.utils.user.get_user()
    try:
        if isinstance(user, int):
            return user
        return pwd.getpwnam(user).pw_uid
    except KeyError:
        return ""
def get_uid(path, follow_symlinks=True):
    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
        "uid", -1
    )
def get_user(path, follow_symlinks=True):
    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
        "user", False
    )
def get_mode(path, follow_symlinks=True):
    return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
        "mode", ""
    )
def set_mode(path, mode):
    path = os.path.expanduser(path)
    mode = str(mode).lstrip("0Oo")
    if not mode:
        mode = "0"
    if not os.path.exists(path):
        raise CommandExecutionError("{}: File not found".format(path))
    try:
        os.chmod(path, int(mode, 8))
    except Exception:  # pylint: disable=broad-except
        return "Invalid Mode " + mode
    return get_mode(path)
def lchown(path, user, group):
    path = os.path.expanduser(path)
    uid = user_to_uid(user)
    gid = group_to_gid(group)
    err = ""
    if uid == "":
        if user:
            err += "User does not exist\n"
        else:
            uid = -1
    if gid == "":
        if group:
            err += "Group does not exist\n"
        else:
            gid = -1
    return os.lchown(path, uid, gid)
def chown(path, user, group):
    path = os.path.expanduser(path)
    uid = user_to_uid(user)
    gid = group_to_gid(group)
    err = ""
    if uid == "":
        if user:
            err += "User does not exist\n"
        else:
            uid = -1
    if gid == "":
        if group:
            err += "Group does not exist\n"
        else:
            gid = -1
    if not os.path.exists(path):
        try:
            return os.lchown(path, uid, gid)
        except OSError:
            pass
        err += "File not found"
    if err:
        return err
    return os.chown(path, uid, gid)
def chgrp(path, group):
    path = os.path.expanduser(path)
    user = get_user(path)
    return chown(path, user, group)
def _cmp_attrs(path, attrs):
    if salt.utils.platform.is_aix():
        return None
    try:
        lattrs = lsattr(path).get(path, "")
    except AttributeError:
        return None
    new = set(attrs)
    old = set(lattrs)
    if "e" in old:
        new.add("e")
    return AttrChanges(
        added="".join(new - old) or None,
        removed="".join(old - new) or None,
    )
def lsattr(path):
    if not salt.utils.path.which("lsattr") or salt.utils.platform.is_aix():
        return None
    if not os.path.exists(path):
        raise SaltInvocationError("File or directory does not exist: " + path)
    cmd = ["lsattr", path]
    result = __salt__["cmd.run"](cmd, ignore_retcode=True, python_shell=False)
    results = {}
    for line in result.splitlines():
        if not line.startswith("lsattr: "):
            attrs, file = line.split(None, 1)
            if _chattr_has_extended_attrs():
                pattern = r"[aAcCdDeijPsStTu]"
            else:
                pattern = r"[acdijstuADST]"
            results[file] = re.findall(pattern, attrs)
    return results
def chattr(*files, **kwargs):
    operator = kwargs.pop("operator", None)
    attributes = kwargs.pop("attributes", None)
    flags = kwargs.pop("flags", None)
    version = kwargs.pop("version", None)
    if (operator is None) or (operator not in ("add", "remove")):
        raise SaltInvocationError(
            "Need an operator: 'add' or 'remove' to modify attributes."
        )
    if attributes is None:
        raise SaltInvocationError("Need attributes: [aAcCdDeijPsStTu]")
    cmd = ["chattr"]
    if operator == "add":
        attrs = "+{}".format(attributes)
    elif operator == "remove":
        attrs = "-{}".format(attributes)
    cmd.append(attrs)
    if flags is not None:
        cmd.append("-{}".format(flags))
    if version is not None:
        cmd.extend(["-v", version])
    cmd.extend(files)
    result = __salt__["cmd.run"](cmd, python_shell=False)
    if bool(result):
        return False
    return True
def get_sum(path, form="sha256"):
    path = os.path.expanduser(path)
    if not os.path.isfile(path):
        return "File not found"
    return salt.utils.hashutils.get_hash(path, form, 4096)
def get_hash(path, form="sha256", chunk_size=65536):
    return salt.utils.hashutils.get_hash(os.path.expanduser(path), form, chunk_size)
def get_source_sum(
    file_name="",
    source="",
    source_hash=None,
    source_hash_name=None,
    saltenv="base",
    verify_ssl=True,
):
    def _invalid_source_hash_format():
        raise CommandExecutionError(
            "Source hash {} format is invalid. The supported formats are: "
            "1) a hash, 2) an expression in the format &lt;hash_type&gt;=&lt;hash&gt;, or "
            "3) either a path to a local file containing hashes, or a URI of "
            "a remote hash file. Supported protocols for remote hash files "
            "are: {}. The hash may also not be of a valid length, the "
            "following are supported hash types and lengths: {}.".format(
                source_hash,
                ", ".join(salt.utils.files.VALID_PROTOS),
                ", ".join(
                    [
                        "{} ({})".format(HASHES_REVMAP[x], x)
                        for x in sorted(HASHES_REVMAP)
                    ]
                ),
            )
        )
    hash_fn = None
    if os.path.isabs(source_hash):
        hash_fn = source_hash
    else:
        try:
            proto = urllib.parse.urlparse(source_hash).scheme
            if proto in salt.utils.files.VALID_PROTOS:
                hash_fn = __salt__["cp.cache_file"](
                    source_hash, saltenv, verify_ssl=verify_ssl
                )
                if not hash_fn:
                    raise CommandExecutionError(
                        "Source hash file {} not found".format(source_hash)
                    )
            else:
                if proto != "":
                    _invalid_source_hash_format()
        except (AttributeError, TypeError):
            _invalid_source_hash_format()
    if hash_fn is not None:
        ret = extract_hash(hash_fn, "", file_name, source, source_hash_name)
        if ret is None:
            _invalid_source_hash_format()
        ret["hsum"] = ret["hsum"].lower()
        return ret
    else:
        ret = {}
        try:
            ret["hash_type"], ret["hsum"] = (
                x.strip() for x in source_hash.split("=", 1)
            )
        except AttributeError:
            _invalid_source_hash_format()
        except ValueError:
            if not re.match("^[{}]+$".format(string.hexdigits), source_hash):
                _invalid_source_hash_format()
            ret["hsum"] = source_hash
            source_hash_len = len(source_hash)
            if source_hash_len in HASHES_REVMAP:
                ret["hash_type"] = HASHES_REVMAP[source_hash_len]
            else:
                _invalid_source_hash_format()
        if ret["hash_type"] not in HASHES:
            raise CommandExecutionError(
                "Invalid hash type '{}'. Supported hash types are: {}. "
                "Either remove the hash type and simply use '{}' as the "
                "source_hash, or change the hash type to a supported type.".format(
                    ret["hash_type"], ", ".join(HASHES), ret["hsum"]
                )
            )
        else:
            hsum_len = len(ret["hsum"])
            if hsum_len not in HASHES_REVMAP:
                _invalid_source_hash_format()
            elif hsum_len != HASHES[ret["hash_type"]]:
                raise CommandExecutionError(
                    "Invalid length ({}) for hash type '{}'. Either "
                    "remove the hash type and simply use '{}' as the "
                    "source_hash, or change the hash type to '{}'".format(
                        hsum_len,
                        ret["hash_type"],
                        ret["hsum"],
                        HASHES_REVMAP[hsum_len],
                    )
                )
        ret["hsum"] = ret["hsum"].lower()
        return ret
def check_hash(path, file_hash):
    path = os.path.expanduser(path)
    if not isinstance(file_hash, str):
        raise SaltInvocationError("hash must be a string")
    for sep in (":", "="):
        if sep in file_hash:
            hash_type, hash_value = file_hash.split(sep, 1)
            break
    else:
        hash_value = file_hash
        hash_len = len(file_hash)
        hash_type = HASHES_REVMAP.get(hash_len)
        if hash_type is None:
            raise SaltInvocationError(
                "Hash {} (length: {}) could not be matched to a supported "
                "hash type. The supported hash types and lengths are: "
                "{}".format(
                    file_hash,
                    hash_len,
                    ", ".join(
                        [
                            "{} ({})".format(HASHES_REVMAP[x], x)
                            for x in sorted(HASHES_REVMAP)
                        ]
                    ),
                )
            )
    return get_hash(path, hash_type) == hash_value
def find(path, *args, **kwargs):
    if "delete" in args:
        kwargs["delete"] = "f"
    elif "print" in args:
        kwargs["print"] = "path"
    try:
        finder = salt.utils.find.Finder(kwargs)
    except ValueError as ex:
        return "error: {}".format(ex)
    ret = [
        item
        for i in [finder.find(p) for p in glob.glob(os.path.expanduser(path))]
        for item in i
    ]
    ret.sort()
    return ret
def _sed_esc(string, escape_all=False):
    special_chars = "^.[$()|*+?{"
    string = string.replace("'", "'\"'\"'").replace("/", "\\/")
    if escape_all is True:
        for char in special_chars:
            string = string.replace(char, "\\" + char)
    return string
def sed(
    path,
    before,
    after,
    limit="",
    backup=".bak",
    options="-r -e",
    flags="g",
    escape_all=False,
    negate_match=False,
):
    path = os.path.expanduser(path)
    if not os.path.exists(path):
        return False
    before = str(before)
    after = str(after)
    before = _sed_esc(before, escape_all)
    after = _sed_esc(after, escape_all)
    limit = _sed_esc(limit, escape_all)
    if sys.platform == "darwin":
        options = options.replace("-r", "-E")
    cmd = ["sed"]
    cmd.append("-i{}".format(backup) if backup else "-i")
    cmd.extend(salt.utils.args.shlex_split(options))
    cmd.append(
        r"{limit}{negate_match}s/{before}/{after}/{flags}".format(
            limit="/{}/ ".format(limit) if limit else "",
            negate_match="!" if negate_match else "",
            before=before,
            after=after,
            flags=flags,
        )
    )
    cmd.append(path)
    return __salt__["cmd.run_all"](cmd, python_shell=False)
def sed_contains(path, text, limit="", flags="g"):
    path = os.path.expanduser(path)
    if not os.path.exists(path):
        return False
    before = _sed_esc(str(text), False)
    limit = _sed_esc(str(limit), False)
    options = "-n -r -e"
    if sys.platform == "darwin":
        options = options.replace("-r", "-E")
    cmd = ["sed"]
    cmd.extend(salt.utils.args.shlex_split(options))
    cmd.append(
        r"{limit}s/{before}/$/{flags}".format(
            limit="/{}/ ".format(limit) if limit else "",
            before=before,
            flags="p{}".format(flags),
        )
    )
    cmd.append(path)
    result = __salt__["cmd.run"](cmd, python_shell=False)
    return bool(result)
def psed(
    path,
    before,
    after,
    limit="",
    backup=".bak",
    flags="gMS",
    escape_all=False,
    multi=False,
):
    path = os.path.expanduser(path)
    multi = bool(multi)
    before = str(before)
    after = str(after)
    before = _sed_esc(before, escape_all)
    limit = _sed_esc(limit, escape_all)
    shutil.copy2(path, "{}{}".format(path, backup))
    with salt.utils.files.fopen(path, "w") as ofile:
        with salt.utils.files.fopen("{}{}".format(path, backup), "r") as ifile:
            if multi is True:
                for line in ifile.readline():
                    ofile.write(
                        salt.utils.stringutils.to_str(
                            _psed(
                                salt.utils.stringutils.to_unicode(line),
                                before,
                                after,
                                limit,
                                flags,
                            )
                        )
                    )
            else:
                ofile.write(
                    salt.utils.stringutils.to_str(
                        _psed(
                            salt.utils.stringutils.to_unicode(ifile.read()),
                            before,
                            after,
                            limit,
                            flags,
                        )
                    )
                )
RE_FLAG_TABLE = {"I": re.I, "L": re.L, "M": re.M, "S": re.S, "U": re.U, "X": re.X}
def _psed(text, before, after, limit, flags):
    atext = text
    if limit:
        limit = re.compile(limit)
        comps = text.split(limit)
        atext = "".join(comps[1:])
    count = 1
    if "g" in flags:
        count = 0
        flags = flags.replace("g", "")
    aflags = 0
    for flag in flags:
        aflags |= RE_FLAG_TABLE[flag]
    before = re.compile(before, flags=aflags)
    text = re.sub(before, after, atext, count=count)
    return text
def uncomment(path, regex, char="#", backup=".bak"):
    return comment_line(path=path, regex=regex, char=char, cmnt=False, backup=backup)
def comment(path, regex, char="#", backup=".bak"):
    return comment_line(path=path, regex=regex, char=char, cmnt=True, backup=backup)
def comment_line(path, regex, char="#", cmnt=True, backup=".bak"):
    r"""
    Comment or Uncomment a line in a text file.
    :param path: string
        The full path to the text file.
    :param regex: string
        A regex expression that begins with ``^`` that will find the line you wish
        to comment. Can be as simple as ``^color =``
    :param char: string
        The character used to comment a line in the type of file you're referencing.
        Default is ``#``
    :param cmnt: boolean
        True to comment the line. False to uncomment the line. Default is True.
    :param backup: string
        The file extension to give the backup file. Default is ``.bak``
        Set to False/None to not keep a backup.
    :return: boolean
        Returns True if successful, False if not
    CLI Example:
    The following example will comment out the ``pcspkr`` line in the
    ``/etc/modules`` file using the default ``#`` character and create a backup
    file named ``modules.bak``
    .. code-block:: bash
        salt '*' file.comment_line '/etc/modules' '^pcspkr'
    CLI Example:
    The following example will uncomment the ``log_level`` setting in ``minion``
    config file if it is set to either ``warning``, ``info``, or ``debug`` using
    the ``#`` character and create a backup file named ``minion.bk``
    .. code-block:: bash
        salt '*' file.comment_line 'C:\salt\conf\minion' '^log_level: (warning|info|debug)' '#' False '.bk'
    Return an integer appropriate for use as a flag for the re module from a
    list of human-readable strings
    .. code-block:: python
        &gt;&gt;&gt; _get_flags(['MULTILINE', 'IGNORECASE'])
        10
        &gt;&gt;&gt; _get_flags('MULTILINE')
        8
        &gt;&gt;&gt; _get_flags(2)
        2
    Combine ``flags`` and ``new_flags``
    Create a temp file and move/copy the contents of ``path`` to the temp file.
    Return the path to the temp file.
    path
        The full path to the file whose contents will be moved/copied to a temp file.
        Whether it's moved or copied depends on the value of ``preserve_inode``.
    preserve_inode
        Preserve the inode of the file, so that any hard links continue to share the
        inode with the original filename. This works by *copying* the file, reading
        from the copy, and writing to the file at the original inode. If ``False``, the
        file will be *moved* rather than copied, and a new file will be written to a
        new inode, but using the original filename. Hard links will then share an inode
        with the backup, instead (if using ``backup`` to create a backup copy).
        Default is ``True``.
    Expand regular expression to static match.
    Raise an exception, if there are different amount of specified occurrences in src.
    Indent the line with the source line.
    Add line ending
    Take ``lines`` and insert ``content`` and the correct place. If
    ``mode`` is ``'delete'`` then delete the ``content`` line instead.
    Returns a list of modified lines.
    lines
        The original file lines to modify.
    content
        Content of the line. Allowed to be empty if ``mode='delete'``.
    match
        The regex or contents to seek for on the line.
    mode
        What to do with the matching line. One of the following options
        is required:
        - ensure
            If ``content`` does not exist, it will be added.
        - replace
            If the line already exists, it will be replaced(???? TODO WHAT DOES THIS MEAN?)
        - delete
            Delete the line, if found.
        - insert
            Insert a line if it does not already exist.
        .. note::
            If ``mode=insert`` is used, at least one of the following
            options must also be defined: ``location``, ``before``, or
            ``after``. If ``location`` is used, it takes precedence
            over the other two options
    location
        ``start`` or ``end``. Defines where to place the content in the
        lines. **Note** this option is only used when ``mode='insert`` is
        specified. If a location is passed in, it takes precedence over
        both the ``before`` and ``after`` kwargs.
        - start
            Place the ``content`` at the beginning of the lines.
        - end
            Place the ``content`` at the end of the lines.
    before
        Regular expression or an exact, case-sensitive fragment of the
        line to place the ``content`` before. This option is only used
        when either ``ensure`` or ``insert`` mode is specified.
    after
        Regular expression or an exact, case-sensitive fragment of the
        line to plaece the ``content`` after. This option is only used
        when either ``ensure`` or ``insert`` mode is specified.
    indent
        Keep indentation to match the previous line. Ignored when
        ``mode='delete'`` is specified.
    .. versionadded:: 2015.8.0
    Line-focused editing of a file.
    .. note::
        ``file.line`` exists for historic reasons, and is not
        generally recommended. It has a lot of quirks.  You may find
        ``file.replace`` to be more suitable.
    ``file.line`` is most useful if you have single lines in a file
    (potentially a config file) that you would like to manage. It can
    remove, add, and replace a single line at a time.
    path
        Filesystem path to the file to be edited.
    content
        Content of the line. Allowed to be empty if ``mode='delete'``.
    match
        Match the target line for an action by
        a fragment of a string or regular expression.
        If neither ``before`` nor ``after`` are provided, and ``match``
        is also ``None``, match falls back to the ``content`` value.
    mode
        Defines how to edit a line. One of the following options is
        required:
        - ensure
            If line does not exist, it will be added. If ``before``
            and ``after`` are specified either zero lines, or lines
            that contain the ``content`` line are allowed to be in between
            ``before`` and ``after``. If there are lines, and none of
            them match then it will produce an error.
        - replace
            If line already exists, the entire line will be replaced.
        - delete
            Delete the line, if found.
        - insert
            Nearly identical to ``ensure``. If a line does not exist,
            it will be added.
            The differences are that multiple (and non-matching) lines are
            alloweed between ``before`` and ``after``, if they are
            specified. The line will always be inserted right before
            ``before``. ``insert`` also allows the use of ``location`` to
            specify that the line should be added at the beginning or end of
            the file.
        .. note::
            If ``mode='insert'`` is used, at least one of ``location``,
            ``before``, or ``after`` is required.  If ``location`` is used,
            ``before`` and ``after`` are ignored.
    location
        In ``mode='insert'`` only, whether to place the ``content`` at the
        beginning or end of a the file. If ``location`` is provided,
        ``before`` and ``after`` are ignored. Valid locations:
        - start
            Place the content at the beginning of the file.
        - end
            Place the content at the end of the file.
    before
        Regular expression or an exact case-sensitive fragment of the string.
        Will be tried as **both** a regex **and** a part of the line.  Must
        match **exactly** one line in the file.  This value is only used in
        ``ensure`` and ``insert`` modes. The ``content`` will be inserted just
        before this line, with matching indentation unless ``indent=False``.
    after
        Regular expression or an exact case-sensitive fragment of the string.
        Will be tried as **both** a regex **and** a part of the line.  Must
        match **exactly** one line in the file.  This value is only used in
        ``ensure`` and ``insert`` modes. The ``content`` will be inserted
        directly after this line, unless ``before`` is also provided. If
        ``before`` is not provided, indentation will match this line, unless
        ``indent=False``.
    show_changes
        Output a unified diff of the old file and the new file.
        If ``False`` return a boolean if any changes were made.
        Default is ``True``
        .. note::
            Using this option will store two copies of the file in-memory
            (the original version and the edited version) in order to generate the diff.
    backup
        Create a backup of the original file with the extension:
        "Year-Month-Day-Hour-Minutes-Seconds".
    quiet
        Do not raise any exceptions. E.g. ignore the fact that the file that is
        tried to be edited does not exist and nothing really happened.
    indent
        Keep indentation with the previous line. This option is not considered when
        the ``delete`` mode is specified. Default is ``True``
    CLI Example:
    .. code-block:: bash
        salt '*' file.line /etc/nsswitch.conf "networks:\tfiles dns" after="hosts:.*?" mode='ensure'
    .. note::
        If an equal sign (``=``) appears in an argument to a Salt command, it is
        interpreted as a keyword argument in the format of ``key=val``. That
        processing can be bypassed in order to pass an equal sign through to the
        remote shell command by manually specifying the kwarg:
        .. code-block:: bash
            salt '*' file.line /path/to/file content="CREATEMAIL_SPOOL=no" match="CREATE_MAIL_SPOOL=yes" mode="replace"
    **Examples:**
    Here's a simple config file.
    .. code-block:: ini
        [some_config]
        here=False
        away=True
        goodybe=away
    .. code-block:: bash
        salt \\* file.line /some/file.conf mode=delete match=away
    This will produce:
    .. code-block:: ini
        [some_config]
        here=False
        away=True
        goodbye=away
    If that command is executed 2 more times, this will be the result:
    .. code-block:: ini
        [some_config]
        here=False
    If we reset the file to its original state and run
    .. code-block:: bash
        salt \\* file.line /some/file.conf mode=replace match=away content=here
    Three passes will this state will result in this file:
    .. code-block:: ini
        [some_config]
        here
        here=False
        here
        here
    Each pass replacing the first line found.
    Given this file:
    .. code-block:: text
        insert after me
        something
        insert before me
    The following command
    .. code-block:: bash
        salt \\* file.line /some/file.txt mode=insert after="insert after me" before="insert before me" content=thrice
    If that command is executed 3 times, the result will be:
    .. code-block:: text
        insert after me
        something
        thrice
        thrice
        thrice
        insert before me
    If the mode is ``ensure`` instead, it will fail each time. To succeed, we
    need to remove the incorrect line between before and after:
    .. code-block:: text
        insert after me
        insert before me
    With an ensure mode, this will insert ``thrice`` the first time and
    make no changes for subsequent calls. For something simple this is
    fine, but if you have instead blocks like this:
    .. code-block:: text
        Begin SomeBlock
            foo = bar
        End
        Begin AnotherBlock
            another = value
        End
    And you try to use ensure this way:
    .. code-block:: bash
        salt \\* file.line  /tmp/fun.txt mode="ensure" content="this = should be my content" after="Begin SomeBlock" before="End"
    This will fail because there are multiple ``End`` lines. Without that
    problem, it still would fail because there is a non-matching line,
    ``foo = bar``. Ensure **only** allows either zero, or the matching
    line present to be present in between ``before`` and ``after``.
    .. versionadded:: 0.17.0
    Replace occurrences of a pattern in a file. If ``show_changes`` is
    ``True``, then a diff of what changed will be returned, otherwise a
    ``True`` will be returned when changes are made, and ``False`` when
    no changes are made.
    This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.
    path
        Filesystem path to the file to be edited. If a symlink is specified, it
        will be resolved to its target.
    pattern
        A regular expression, to be matched using Python's
        :py:func:`~re.search`.
    repl
        The replacement text
    count: 0
        Maximum number of pattern occurrences to be replaced. If count is a
        positive integer ``n``, only ``n`` occurrences will be replaced,
        otherwise all occurrences will be replaced.
    flags (list or int)
        A list of flags defined in the ``re`` module documentation from the
        Python standard library. Each list item should be a string that will
        correlate to the human-friendly flag name. E.g., ``['IGNORECASE',
        'MULTILINE']``. Optionally, ``flags`` may be an int, with a value
        corresponding to the XOR (``|``) of all the desired flags. Defaults to
        8 (which supports 'MULTILINE').
    bufsize (int or str)
        How much of the file to buffer into memory at once. The
        default value ``1`` processes one line at a time. The special value
        ``file`` may be specified which will read the entire file into memory
        before processing.
    append_if_not_found: False
        .. versionadded:: 2014.7.0
        If set to ``True``, and pattern is not found, then the content will be
        appended to the file.
    prepend_if_not_found: False
        .. versionadded:: 2014.7.0
        If set to ``True`` and pattern is not found, then the content will be
        prepended to the file.
    not_found_content
        .. versionadded:: 2014.7.0
        Content to use for append/prepend if not found. If None (default), uses
        ``repl``. Useful when ``repl`` uses references to group in pattern.
    backup: .bak
        The file extension to use for a backup of the file before editing. Set
        to ``False`` to skip making a backup.
    dry_run: False
        If set to ``True``, no changes will be made to the file, the function
        will just return the changes that would have been made (or a
        ``True``/``False`` value if ``show_changes`` is set to ``False``).
    search_only: False
        If set to true, this no changes will be performed on the file, and this
        function will simply return ``True`` if the pattern was matched, and
        ``False`` if not.
    show_changes: True
        If ``True``, return a diff of changes made. Otherwise, return ``True``
        if changes were made, and ``False`` if not.
        .. note::
            Using this option will store two copies of the file in memory (the
            original version and the edited version) in order to generate the
            diff. This may not normally be a concern, but could impact
            performance if used with large files.
    ignore_if_missing: False
        .. versionadded:: 2015.8.0
        If set to ``True``, this function will simply return ``False``
        if the file doesn't exist. Otherwise, an error will be thrown.
    preserve_inode: True
        .. versionadded:: 2015.8.0
        Preserve the inode of the file, so that any hard links continue to
        share the inode with the original filename. This works by *copying* the
        file, reading from the copy, and writing to the file at the original
        inode. If ``False``, the file will be *moved* rather than copied, and a
        new file will be written to a new inode, but using the original
        filename. Hard links will then share an inode with the backup, instead
        (if using ``backup`` to create a backup copy).
    backslash_literal: False
        .. versionadded:: 2016.11.7
        Interpret backslashes as literal backslashes for the repl and not
        escape characters.  This will help when using append/prepend so that
        the backslashes are not interpreted for the repl on the second run of
        the state.
    If an equal sign (``=``) appears in an argument to a Salt command it is
    interpreted as a keyword argument in the format ``key=val``. That
    processing can be bypassed in order to pass an equal sign through to the
    remote shell command by manually specifying the kwarg:
    .. code-block:: bash
        salt '*' file.replace /path/to/file pattern='=' repl=':'
        salt '*' file.replace /path/to/file pattern="bind-address\\s*=" repl='bind-address:'
    CLI Examples:
    .. code-block:: bash
        salt '*' file.replace /etc/httpd/httpd.conf pattern='LogLevel warn' repl='LogLevel info'
        salt '*' file.replace /some/file pattern='before' repl='after' flags='[MULTILINE, IGNORECASE]'
    .. versionadded:: 2014.1.0
    Replace content of a text block in a file, delimited by line markers
    A block of content delimited by comments can help you manage several lines
    entries without worrying about old entries removal.
    .. note::
        This function will store two copies of the file in-memory (the original
        version and the edited version) in order to detect changes and only
        edit the targeted file if necessary.
    path
        Filesystem path to the file to be edited
    marker_start
        The line content identifying a line as the start of the content block.
        Note that the whole line containing this marker will be considered, so
        whitespace or extra content before or after the marker is included in
        final output
    marker_end
        The line content identifying the end of the content block. As of
        versions 2017.7.5 and 2018.3.1, everything up to the text matching the
        marker will be replaced, so it's important to ensure that your marker
        includes the beginning of the text you wish to replace.
    content
        The content to be used between the two lines identified by marker_start
        and marker_stop.
    append_if_not_found: False
        If markers are not found and set to ``True`` then, the markers and
        content will be appended to the file.
    prepend_if_not_found: False
        If markers are not found and set to ``True`` then, the markers and
        content will be prepended to the file.
    insert_before_match
        If markers are not found, this parameter can be set to a regex which will
        insert the block before the first found occurrence in the file.
        .. versionadded:: 3001
    insert_after_match
        If markers are not found, this parameter can be set to a regex which will
        insert the block after the first found occurrence in the file.
        .. versionadded:: 3001
    backup
        The file extension to use for a backup of the file if any edit is made.
        Set to ``False`` to skip making a backup.
    dry_run: False
        If ``True``, do not make any edits to the file and simply return the
        changes that *would* be made.
    show_changes: True
        Controls how changes are presented. If ``True``, this function will
        return a unified diff of the changes made. If False, then it will
        return a boolean (``True`` if any changes were made, otherwise
        ``False``).
    append_newline: False
        Controls whether or not a newline is appended to the content block. If
        the value of this argument is ``True`` then a newline will be added to
        the content block. If it is ``False``, then a newline will *not* be
        added to the content block. If it is ``None`` then a newline will only
        be added to the content block if it does not already end in a newline.
        .. versionadded:: 2016.3.4
        .. versionchanged:: 2017.7.5,2018.3.1
            New behavior added when value is ``None``.
        .. versionchanged:: 2019.2.0
            The default value of this argument will change to ``None`` to match
            the behavior of the :py:func:`file.blockreplace state
            &lt;salt.states.file.blockreplace&gt;`
    CLI Example:
    .. code-block:: bash
        salt '*' file.blockreplace /etc/hosts '#-- start managed zone foobar : DO NOT EDIT --' \\
        '#-- end managed zone foobar --' $'10.0.1.1 foo.foobar\\n10.0.1.2 bar.foobar' True
    .. versionadded:: 0.17.0
    Search for occurrences of a pattern in a file
    Except for multiline, params are identical to
    :py:func:`~salt.modules.file.replace`.
    multiline
        If true, inserts 'MULTILINE' into ``flags`` and sets ``bufsize`` to
        'file'.
        .. versionadded:: 2015.8.0
    CLI Example:
    .. code-block:: bash
        salt '*' file.search /etc/crontab 'mymaintenance.sh'
    .. versionadded:: 0.10.4
    Apply a patch to a file or directory.
    Equivalent to:
    .. code-block:: bash
        patch &lt;options&gt; -i &lt;patchfile&gt; &lt;originalfile&gt;
    Or, when a directory is patched:
    .. code-block:: bash
        patch &lt;options&gt; -i &lt;patchfile&gt; -d &lt;originalfile&gt; -p0
    originalfile
        The full path to the file or directory to be patched
    patchfile
        A patch file to apply to ``originalfile``
    options
        Options to pass to patch.
    .. note::
        Windows now supports using patch as of 3004.
        In order to use this function in Windows, please install the
        patch binary through your own means and ensure it's found
        in the system Path. If installing through git-for-windows,
        please select the optional "Use Git and optional Unix tools
        from the Command Prompt" option when installing Git.
    CLI Example:
    .. code-block:: bash
        salt '*' file.patch /opt/file.txt /tmp/file.txt.patch
        salt '*' file.patch C:\\file1.txt C:\\file3.patch
    .. deprecated:: 0.17.0
       Use :func:`search` instead.
    Return ``True`` if the file at ``path`` contains ``text``
    CLI Example:
    .. code-block:: bash
        salt '*' file.contains /etc/crontab 'mymaintenance.sh'
    .. deprecated:: 0.17.0
       Use :func:`search` instead.
    Return True if the given regular expression matches on any line in the text
    of a given file.
    If the lchar argument (leading char) is specified, it
    will strip `lchar` from the left side of each line before trying to match
    CLI Example:
    .. code-block:: bash
        salt '*' file.contains_regex /etc/crontab
    .. deprecated:: 0.17.0
       Use :func:`search` instead.
    Return ``True`` if the given glob matches a string in the named file
    CLI Example:
    .. code-block:: bash
        salt '*' file.contains_glob /etc/foobar '*cheese*'
    .. versionadded:: 0.9.5
    Append text to the end of a file
    path
        path to file
    `*args`
        strings to append to file
    CLI Example:
    .. code-block:: bash
        salt '*' file.append /etc/motd \\
                "With all thine offerings thou shalt offer salt." \\
                "Salt is what makes things taste bad when it isn't in them."
    .. admonition:: Attention
        If you need to pass a string to append and that string contains
        an equal sign, you **must** include the argument name, args.
        For example:
        .. code-block:: bash
            salt '*' file.append /etc/motd args='cheese=spam'
            salt '*' file.append /etc/motd args="['cheese=spam','spam=cheese']"
    .. versionadded:: 2014.7.0
    Prepend text to the beginning of a file
    path
        path to file
    `*args`
        strings to prepend to the file
    CLI Example:
    .. code-block:: bash
        salt '*' file.prepend /etc/motd \\
                "With all thine offerings thou shalt offer salt." \\
                "Salt is what makes things taste bad when it isn't in them."
    .. admonition:: Attention
        If you need to pass a string to append and that string contains
        an equal sign, you **must** include the argument name, args.
        For example:
        .. code-block:: bash
            salt '*' file.prepend /etc/motd args='cheese=spam'
            salt '*' file.prepend /etc/motd args="['cheese=spam','spam=cheese']"
    .. versionadded:: 2014.7.0
    Write text to a file, overwriting any existing contents.
    path
        path to file
    `*args`
        strings to write to the file
    CLI Example:
    .. code-block:: bash
        salt '*' file.write /etc/motd \\
                "With all thine offerings thou shalt offer salt."
    .. admonition:: Attention
        If you need to pass a string to append and that string contains
        an equal sign, you **must** include the argument name, args.
        For example:
        .. code-block:: bash
            salt '*' file.write /etc/motd args='cheese=spam'
            salt '*' file.write /etc/motd args="['cheese=spam','spam=cheese']"
    .. versionadded:: 0.9.5
    Just like the ``touch`` command, create a file if it doesn't exist or
    simply update the atime and mtime if it already does.
    atime:
        Access time in Unix epoch time
    mtime:
        Last modification in Unix epoch time
    CLI Example:
    .. code-block:: bash
        salt '*' file.touch /var/log/emptyfile
    .. versionadded:: 2014.1.0
    Seek to a position on a file and read it
    path
        path to file
    seek
        amount to read at once
    offset
        offset to start into the file
    CLI Example:
    .. code-block:: bash
        salt '*' file.seek_read /path/to/file 4096 0
    .. versionadded:: 2014.1.0
    Seek to a position on a file and write to it
    path
        path to file
    data
        data to write to file
    offset
        position in file to start writing
    CLI Example:
    .. code-block:: bash
        salt '*' file.seek_write /path/to/file 'some data' 4096
    .. versionadded:: 2014.1.0
    Seek to a position on a file and delete everything after that point
    path
        path to file
    length
        offset into file to truncate
    CLI Example:
    .. code-block:: bash
        salt '*' file.truncate /path/to/file 512
    .. versionadded:: 2014.1.0
    Create a hard link to a file
    CLI Example:
    .. code-block:: bash
        salt '*' file.link /path/to/file /path/to/link
    Check if the path is a hard link by verifying that the number of links
    is larger than 1
    CLI Example:
    .. code-block:: bash
       salt '*' file.is_hardlink /path/to/link
    Check if the path is a symbolic link
    CLI Example:
    .. code-block:: bash
       salt '*' file.is_link /path/to/link
    Create a symbolic link (symlink, soft link) to a file
    Args:
        src (str): The path to a file or directory
        path (str): The path to the link. Must be an absolute path
        force (bool):
            Overwrite an existing symlink with the same name
            .. versionadded:: 3005
    Returns:
        bool: True if successful, otherwise False
    CLI Example:
    .. code-block:: bash
        salt '*' file.symlink /path/to/file /path/to/link
    Rename a file or directory
    CLI Example:
    .. code-block:: bash
        salt '*' file.rename /path/to/src /path/to/dst
    Copy a file or directory from source to dst
    In order to copy a directory, the recurse flag is required, and
    will by default overwrite files in the destination with the same path,
    and retain all other existing files. (similar to cp -r on unix)
    remove_existing will remove all files in the target directory,
    and then copy files from the source.
    .. note::
        The copy function accepts paths that are local to the Salt minion.
        This function does not support salt://, http://, or the other
        additional file paths that are supported by :mod:`states.file.managed
        &lt;salt.states.file.managed&gt;` and :mod:`states.file.recurse
        &lt;salt.states.file.recurse&gt;`.
    CLI Example:
    .. code-block:: bash
        salt '*' file.copy /path/to/src /path/to/dst
        salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True
        salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True remove_existing=True
    .. versionadded:: 2014.1.0
    Returns the lstat attributes for the given file or dir. Does not support
    symbolic links.
    CLI Example:
    .. code-block:: bash
        salt '*' file.lstat /path/to/file
    .. versionadded:: 2014.1.0
    Test whether the Salt process has the specified access to the file. One of
    the following modes must be specified:
    .. code-block:: text
        f: Test the existence of the path
        r: Test the readability of the path
        w: Test the writability of the path
        x: Test whether the path can be executed
    CLI Example:
    .. code-block:: bash
        salt '*' file.access /path/to/file f
        salt '*' file.access /path/to/file x
    .. versionadded:: 2017.7.0
    Return the content of the file.
    :param bool binary:
        Whether to read and return binary data
    CLI Example:
    .. code-block:: bash
        salt '*' file.read /path/to/file
    .. versionadded:: 2014.1.0
    Return the path that a symlink points to
    Args:
        path (str):
            The path to the symlink
        canonicalize (bool):
            Get the canonical path eliminating any symbolic links encountered in
            the path
    Returns:
        str: The path that the symlink points to
    Raises:
        SaltInvocationError: path is not absolute
        SaltInvocationError: path is not a link
        CommandExecutionError: error reading the symbolic link
    CLI Example:
    .. code-block:: bash
        salt '*' file.readlink /path/to/link
    .. versionadded:: 2014.1.0
    Return a list containing the contents of a directory
    CLI Example:
    .. code-block:: bash
        salt '*' file.readdir /path/to/dir/
    .. versionadded:: 2014.1.0
    Perform a statvfs call against the filesystem that the file resides on
    CLI Example:
    .. code-block:: bash
        salt '*' file.statvfs /path/to/file
    Return a dict containing the stats for a given file
    CLI Example:
    .. code-block:: bash
        salt '*' file.stats /etc/passwd
    .. versionadded:: 2014.1.0
    Remove the specified directory. Fails if a directory is not empty.
    CLI Example:
    .. code-block:: bash
        salt '*' file.rmdir /tmp/foo/
    Remove the named file. If a directory is supplied, it will be recursively
    deleted.
    CLI Example:
    .. code-block:: bash
        salt '*' file.remove /tmp/foo
    .. versionchanged:: 3000
        The method now works on all types of file system entries, not just
        files, directories and symlinks.
    Tests to see if path is a valid directory.  Returns True/False.
    CLI Example:
    .. code-block:: bash
        salt '*' file.directory_exists /etc
    Tests to see if path is a valid file.  Returns True/False.
    CLI Example:
    .. code-block:: bash
        salt '*' file.file_exists /etc/passwd
    Tests to see if path after expansion is a valid path (file or directory).
    Expansion allows usage of ? * and character ranges []. Tilde expansion
    is not supported. Returns True/False.
    .. versionadded:: 2014.7.0
    CLI Example:
    .. code-block:: bash
        salt '*' file.path_exists_glob /etc/pam*/pass*
    Reset the SELinux context on a given path
    CLI Example:
    .. code-block:: bash
         salt '*' file.restorecon /home/user/.ssh/authorized_keys
    Get an SELinux context from a given path
    CLI Example:
    .. code-block:: bash
        salt '*' file.get_selinux_context /etc/hosts
    .. versionchanged:: 3001
        Added persist option
    Set a specific SELinux label on a given path
    CLI Example:
    .. code-block:: bash
        salt '*' file.set_selinux_context path &lt;user&gt; &lt;role&gt; &lt;type&gt; &lt;range&gt;
        salt '*' file.set_selinux_context /etc/yum.repos.d/epel.repo system_u object_r system_conf_t s0
    Check the source list and return the source to use
    CLI Example:
    .. code-block:: bash
        salt '*' file.source_list salt://http/httpd.conf '{hash_type: 'md5', 'hsum': &lt;md5sum&gt;}' base
    """
    contextkey = "{}_|-{}_|-{}".format(source, source_hash, saltenv)
    if contextkey in __context__:
        return __context__[contextkey]
    if isinstance(source, list):
        mfiles = [(f, saltenv) for f in __salt__["cp.list_master"](saltenv)]
        mdirs = [(d, saltenv) for d in __salt__["cp.list_master_dirs"](saltenv)]
        for single in source:
            if isinstance(single, dict):
                single = next(iter(single))
            path, senv = salt.utils.url.parse(single)
            if senv:
                mfiles += [(f, senv) for f in __salt__["cp.list_master"](senv)]
                mdirs += [(d, senv) for d in __salt__["cp.list_master_dirs"](senv)]
        ret = None
        for single in source:
            if isinstance(single, dict):
                if len(single) != 1:
                    continue
                single_src = next(iter(single))
                single_hash = single[single_src] if single[single_src] else source_hash
                urlparsed_single_src = urllib.parse.urlparse(single_src)
                if salt.utils.platform.is_windows():
                    if urlparsed_single_src.scheme.lower() in string.ascii_lowercase:
                        urlparsed_single_src = urllib.parse.urlparse(
                            "file://" + single_src
                        )
                proto = urlparsed_single_src.scheme
                if proto == "salt":
                    path, senv = salt.utils.url.parse(single_src)
                    if not senv:
                        senv = saltenv
                    if (path, saltenv) in mfiles or (path, saltenv) in mdirs:
                        ret = (single_src, single_hash)
                        break
                elif proto.startswith("http") or proto == "ftp":
                    query_res = salt.utils.http.query(
                        single_src, method="HEAD", decode_body=False
                    )
                    if "error" not in query_res:
                        ret = (single_src, single_hash)
                        break
                elif proto == "file" and (
                    os.path.exists(urlparsed_single_src.netloc)
                    or os.path.exists(urlparsed_single_src.path)
                    or os.path.exists(
                        os.path.join(
                            urlparsed_single_src.netloc, urlparsed_single_src.path
                        )
                    )
                ):
                    ret = (single_src, single_hash)
                    break
                elif single_src.startswith(os.sep) and os.path.exists(single_src):
                    ret = (single_src, single_hash)
                    break
            elif isinstance(single, str):
                path, senv = salt.utils.url.parse(single)
                if not senv:
                    senv = saltenv
                if (path, senv) in mfiles or (path, senv) in mdirs:
                    ret = (single, source_hash)
                    break
                urlparsed_src = urllib.parse.urlparse(single)
                if salt.utils.platform.is_windows():
                    if urlparsed_src.scheme.lower() in string.ascii_lowercase:
                        urlparsed_src = urllib.parse.urlparse("file://" + single)
                proto = urlparsed_src.scheme
                if proto == "file" and (
                    os.path.exists(urlparsed_src.netloc)
                    or os.path.exists(urlparsed_src.path)
                    or os.path.exists(
                        os.path.join(urlparsed_src.netloc, urlparsed_src.path)
                    )
                ):
                    ret = (single, source_hash)
                    break
                elif proto.startswith("http") or proto == "ftp":
                    query_res = salt.utils.http.query(
                        single, method="HEAD", decode_body=False
                    )
                    if "error" not in query_res:
                        ret = (single, source_hash)
                        break
                elif single.startswith(os.sep) and os.path.exists(single):
                    ret = (single, source_hash)
                    break
        if ret is None:
            raise CommandExecutionError("none of the specified sources were found")
    else:
        ret = (source, source_hash)
    __context__[contextkey] = ret
    return ret
def apply_template_on_contents(contents, template, context, defaults, saltenv):
    if template in salt.utils.templates.TEMPLATE_REGISTRY:
        context_dict = defaults if defaults else {}
        if context:
            context_dict.update(context)
        contents = salt.utils.templates.TEMPLATE_REGISTRY[template](
            contents,
            from_str=True,
            to_str=True,
            context=context_dict,
            saltenv=saltenv,
            grains=__opts__["grains"],
            pillar=__pillar__,
            salt=__salt__,
            opts=__opts__,
        )["data"]
        if isinstance(contents, bytes):
            contents = contents.decode("utf-8")
    else:
        ret = {}
        ret["result"] = False
        ret["comment"] = "Specified template format {} is not supported".format(
            template
        )
        return ret
    return contents
def get_managed(
    name,
    template,
    source,
    source_hash,
    source_hash_name,
    user,
    group,
    mode,
    attrs,
    saltenv,
    context,
    defaults,
    skip_verify=False,
    verify_ssl=True,
    use_etag=False,
    **kwargs
):
    sfn = ""
    source_sum = {}
    def _get_local_file_source_sum(path):
        return {"hsum": get_hash(path, form="sha256"), "hash_type": "sha256"}
    if source:
        urlparsed_source = urllib.parse.urlparse(source)
        if urlparsed_source.scheme in salt.utils.files.VALID_PROTOS:
            parsed_scheme = urlparsed_source.scheme
        else:
            parsed_scheme = ""
        parsed_path = os.path.join(
            urlparsed_source.netloc, urlparsed_source.path
        ).rstrip(os.sep)
        unix_local_source = parsed_scheme in ("file", "")
        if parsed_scheme == "":
            parsed_path = sfn = source
            if not os.path.exists(sfn):
                msg = "Local file source {} does not exist".format(sfn)
                return "", {}, msg
        elif parsed_scheme == "file":
            sfn = parsed_path
            if not os.path.exists(sfn):
                msg = "Local file source {} does not exist".format(sfn)
                return "", {}, msg
        if parsed_scheme and parsed_scheme.lower() in string.ascii_lowercase:
            parsed_path = ":".join([parsed_scheme, parsed_path])
            parsed_scheme = "file"
        if parsed_scheme == "salt":
            source_sum = __salt__["cp.hash_file"](source, saltenv)
            if not source_sum:
                return (
                    "",
                    {},
                    "Source file {} not found in saltenv '{}'".format(source, saltenv),
                )
        elif not source_hash and unix_local_source:
            source_sum = _get_local_file_source_sum(parsed_path)
        elif not source_hash and source.startswith(os.sep):
            source_sum = _get_local_file_source_sum(source)
        else:
            if not skip_verify:
                if source_hash:
                    try:
                        source_sum = get_source_sum(
                            name,
                            source,
                            source_hash,
                            source_hash_name,
                            saltenv,
                            verify_ssl=verify_ssl,
                        )
                    except CommandExecutionError as exc:
                        return "", {}, exc.strerror
                elif not use_etag:
                    msg = (
                        "Unable to verify upstream hash of source file {}, "
                        "please set source_hash or set skip_verify to True".format(
                            salt.utils.url.redact_http_basic_auth(source)
                        )
                    )
                    return "", {}, msg
    if source and (template or parsed_scheme in salt.utils.files.REMOTE_PROTOS):
        cache_refetch = False
        cached_dest = __salt__["cp.is_cached"](source, saltenv)
        if cached_dest and (source_hash or skip_verify or use_etag):
            htype = source_sum.get("hash_type", "sha256")
            cached_sum = get_hash(cached_dest, form=htype)
            if skip_verify:
                sfn = cached_dest
                source_sum = {"hsum": cached_sum, "hash_type": htype}
            elif use_etag or cached_sum != source_sum.get(
                "hsum", __opts__["hash_type"]
            ):
                cache_refetch = True
            else:
                sfn = cached_dest
        if not sfn or cache_refetch:
            try:
                sfn = __salt__["cp.cache_file"](
                    source,
                    saltenv,
                    source_hash=source_sum.get("hsum"),
                    verify_ssl=verify_ssl,
                    use_etag=use_etag,
                )
            except Exception as exc:  # pylint: disable=broad-except
                _source = salt.utils.url.redact_http_basic_auth(source)
                return "", {}, "Failed to cache {}: {}".format(_source, exc)
        if not sfn or not os.path.exists(sfn):
            _source = salt.utils.url.redact_http_basic_auth(source)
            return sfn, {}, "Source file '{}' not found".format(_source)
        if sfn == name:
            raise SaltInvocationError("Source file cannot be the same as destination")
        if template:
            if template in salt.utils.templates.TEMPLATE_REGISTRY:
                context_dict = defaults if defaults else {}
                if context:
                    context_dict.update(context)
                data = salt.utils.templates.TEMPLATE_REGISTRY[template](
                    sfn,
                    name=name,
                    source=source,
                    user=user,
                    group=group,
                    mode=mode,
                    attrs=attrs,
                    saltenv=saltenv,
                    context=context_dict,
                    salt=__salt__,
                    pillar=__pillar__,
                    grains=__opts__["grains"],
                    opts=__opts__,
                    **kwargs
                )
            else:
                return (
                    sfn,
                    {},
                    "Specified template format {} is not supported".format(template),
                )
            if data["result"]:
                sfn = data["data"]
                hsum = get_hash(sfn, form="sha256")
                source_sum = {"hash_type": "sha256", "hsum": hsum}
            else:
                __clean_tmp(sfn)
                return sfn, {}, data["data"]
    return sfn, source_sum, ""
def extract_hash(
    hash_fn, hash_type="sha256", file_name="", source="", source_hash_name=None
):
    hash_len = HASHES.get(hash_type)
    if hash_len is None:
        if hash_type:
            log.warning(
                "file.extract_hash: Unsupported hash_type '%s', falling "
                "back to matching any supported hash_type",
                hash_type,
            )
            hash_type = ""
        hash_len_expr = "{},{}".format(min(HASHES_REVMAP), max(HASHES_REVMAP))
    else:
        hash_len_expr = str(hash_len)
    filename_separators = string.whitespace + r"\/*"
    if source_hash_name:
        if not isinstance(source_hash_name, str):
            source_hash_name = str(source_hash_name)
        source_hash_name_idx = (len(source_hash_name) + 1) * -1
        log.debug(
            "file.extract_hash: Extracting %s hash for file matching "
            "source_hash_name '%s'",
            "any supported" if not hash_type else hash_type,
            source_hash_name,
        )
    if file_name:
        if not isinstance(file_name, str):
            file_name = str(file_name)
        file_name_basename = os.path.basename(file_name)
        file_name_idx = (len(file_name_basename) + 1) * -1
    if source:
        if not isinstance(source, str):
            source = str(source)
        urlparsed_source = urllib.parse.urlparse(source)
        source_basename = os.path.basename(
            urlparsed_source.path or urlparsed_source.netloc
        )
        source_idx = (len(source_basename) + 1) * -1
    basename_searches = [x for x in (file_name, source) if x]
    if basename_searches:
        log.debug(
            "file.extract_hash: %s %s hash for file matching%s: %s",
            "If no source_hash_name match found, will extract"
            if source_hash_name
            else "Extracting",
            "any supported" if not hash_type else hash_type,
            "" if len(basename_searches) == 1 else " either of the following",
            ", ".join(basename_searches),
        )
    partial = None
    found = {}
    with salt.utils.files.fopen(hash_fn, "r") as fp_:
        for line in fp_:
            line = salt.utils.stringutils.to_unicode(line.strip())
            hash_re = r"(?i)(?&lt;![a-z0-9])([a-f0-9]{" + hash_len_expr + "})(?![a-z0-9])"
            hash_match = re.search(hash_re, line)
            matched = None
            if hash_match:
                matched_hsum = hash_match.group(1)
                if matched_hsum is not None:
                    matched_type = HASHES_REVMAP.get(len(matched_hsum))
                    if matched_type is None:
                        matched = None
                    else:
                        matched = {"hsum": matched_hsum, "hash_type": matched_type}
            if matched is None:
                log.debug(
                    "file.extract_hash: In line '%s', no %shash found",
                    line,
                    "" if not hash_type else hash_type + " ",
                )
                continue
            if partial is None:
                partial = matched
            def _add_to_matches(found, line, match_type, value, matched):
                log.debug(
                    "file.extract_hash: Line '%s' matches %s '%s'",
                    line,
                    match_type,
                    value,
                )
                found.setdefault(match_type, []).append(matched)
            hash_matched = False
            if source_hash_name:
                if line.endswith(source_hash_name):
                    try:
                        if line[source_hash_name_idx] in string.whitespace:
                            _add_to_matches(
                                found,
                                line,
                                "source_hash_name",
                                source_hash_name,
                                matched,
                            )
                            hash_matched = True
                    except IndexError:
                        pass
                elif re.match(re.escape(source_hash_name) + r"\s+", line):
                    _add_to_matches(
                        found, line, "source_hash_name", source_hash_name, matched
                    )
                    hash_matched = True
            if file_name:
                if line.endswith(file_name_basename):
                    try:
                        if line[file_name_idx] in filename_separators:
                            _add_to_matches(
                                found, line, "file_name", file_name, matched
                            )
                            hash_matched = True
                    except IndexError:
                        pass
                elif re.match(re.escape(file_name) + r"\s+", line):
                    _add_to_matches(found, line, "file_name", file_name, matched)
                    hash_matched = True
            if source:
                if line.endswith(source_basename):
                    try:
                        if line[source_idx] in filename_separators:
                            _add_to_matches(found, line, "source", source, matched)
                            hash_matched = True
                    except IndexError:
                        pass
                elif re.match(re.escape(source) + r"\s+", line):
                    _add_to_matches(found, line, "source", source, matched)
                    hash_matched = True
            if not hash_matched:
                log.debug(
                    "file.extract_hash: Line '%s' contains %s hash "
                    "'%s', but line did not meet the search criteria",
                    line,
                    matched["hash_type"],
                    matched["hsum"],
                )
    for found_type, found_str in (
        ("source_hash_name", source_hash_name),
        ("file_name", file_name),
        ("source", source),
    ):
        if found_type in found:
            if len(found[found_type]) &gt; 1:
                log.debug(
                    "file.extract_hash: Multiple %s matches for %s: %s",
                    found_type,
                    found_str,
                    ", ".join(
                        [
                            "{} ({})".format(x["hsum"], x["hash_type"])
                            for x in found[found_type]
                        ]
                    ),
                )
            ret = found[found_type][0]
            log.debug(
                "file.extract_hash: Returning %s hash '%s' as a match of %s",
                ret["hash_type"],
                ret["hsum"],
                found_str,
            )
            return ret
    if partial:
        log.debug(
            "file.extract_hash: Returning the partially identified %s hash '%s'",
            partial["hash_type"],
            partial["hsum"],
        )
        return partial
    log.debug("file.extract_hash: No matches, returning None")
    return None
def check_perms(
    name,
    ret,
    user,
    group,
    mode,
    attrs=None,
    follow_symlinks=False,
    seuser=None,
    serole=None,
    setype=None,
    serange=None,
):
    name = os.path.expanduser(name)
    if not ret:
        ret = {"name": name, "changes": {}, "comment": [], "result": True}
        orig_comment = ""
    else:
        orig_comment = ret["comment"]
        ret["comment"] = []
    perms = {}
    cur = stats(name, follow_symlinks=follow_symlinks)
    perms["luser"] = cur["user"]
    perms["lgroup"] = cur["group"]
    perms["lmode"] = salt.utils.files.normalize_mode(cur["mode"])
    is_dir = os.path.isdir(name)
    is_link = os.path.islink(name)
    if user:
        if isinstance(user, int):
            user = uid_to_user(user)
        if (
            salt.utils.platform.is_windows()
            and user_to_uid(user) != user_to_uid(perms["luser"])
        ) or (not salt.utils.platform.is_windows() and user != perms["luser"]):
            perms["cuser"] = user
    if group:
        if isinstance(group, int):
            group = gid_to_group(group)
        if (
            salt.utils.platform.is_windows()
            and group_to_gid(group) != group_to_gid(perms["lgroup"])
        ) or (not salt.utils.platform.is_windows() and group != perms["lgroup"]):
            perms["cgroup"] = group
    if "cuser" in perms or "cgroup" in perms:
        if not __opts__["test"]:
            if os.path.islink(name) and not follow_symlinks:
                chown_func = lchown
            else:
                chown_func = chown
            if user is None:
                user = perms["luser"]
            if group is None:
                group = perms["lgroup"]
            try:
                chown_func(name, user, group)
                set_mode(name, mode)
            except OSError:
                ret["result"] = False
    if user:
        if isinstance(user, int):
            user = uid_to_user(user)
        if (
            salt.utils.platform.is_windows()
            and user_to_uid(user)
            != user_to_uid(get_user(name, follow_symlinks=follow_symlinks))
            and user != ""
        ) or (
            not salt.utils.platform.is_windows()
            and user != get_user(name, follow_symlinks=follow_symlinks)
            and user != ""
        ):
            if __opts__["test"] is True:
                ret["changes"]["user"] = user
            else:
                ret["result"] = False
                ret["comment"].append("Failed to change user to {}".format(user))
        elif "cuser" in perms and user != "":
            ret["changes"]["user"] = user
    if group:
        if isinstance(group, int):
            group = gid_to_group(group)
        if (
            salt.utils.platform.is_windows()
            and group_to_gid(group)
            != group_to_gid(get_group(name, follow_symlinks=follow_symlinks))
            and user != ""
        ) or (
            not salt.utils.platform.is_windows()
            and group != get_group(name, follow_symlinks=follow_symlinks)
            and user != ""
        ):
            if __opts__["test"] is True:
                ret["changes"]["group"] = group
            else:
                ret["result"] = False
                ret["comment"].append("Failed to change group to {}".format(group))
        elif "cgroup" in perms and user != "":
            ret["changes"]["group"] = group
    if mode is not None:
        if os.path.islink(name) and not follow_symlinks:
            pass
        else:
            mode = salt.utils.files.normalize_mode(mode)
            if mode != perms["lmode"]:
                if __opts__["test"] is True:
                    ret["changes"]["mode"] = mode
                else:
                    set_mode(name, mode)
                    if mode != salt.utils.files.normalize_mode(get_mode(name)):
                        ret["result"] = False
                        ret["comment"].append(
                            "Failed to change mode to {}".format(mode)
                        )
                    else:
                        ret["changes"]["mode"] = mode
    if attrs is not None and not is_dir:
        if os.path.islink(name) and not follow_symlinks:
            pass
        else:
            diff_attrs = _cmp_attrs(name, attrs)
            if diff_attrs and any(attr for attr in diff_attrs):
                changes = {
                    "old": "".join(lsattr(name)[name]),
                    "new": None,
                }
                if __opts__["test"] is True:
                    changes["new"] = attrs
                else:
                    if diff_attrs.added:
                        chattr(
                            name,
                            operator="add",
                            attributes=diff_attrs.added,
                        )
                    if diff_attrs.removed:
                        chattr(
                            name,
                            operator="remove",
                            attributes=diff_attrs.removed,
                        )
                    cmp_attrs = _cmp_attrs(name, attrs)
                    if any(attr for attr in cmp_attrs):
                        ret["result"] = False
                        ret["comment"].append(
                            "Failed to change attributes to {}".format(attrs)
                        )
                        changes["new"] = "".join(lsattr(name)[name])
                    else:
                        changes["new"] = attrs
                if changes["old"] != changes["new"]:
                    ret["changes"]["attrs"] = changes
    if salt.utils.platform.is_linux() and (seuser or serole or setype or serange):
        selinux_error = False
        try:
            (
                current_seuser,
                current_serole,
                current_setype,
                current_serange,
            ) = get_selinux_context(name).split(":")
            log.debug(
                "Current selinux context user:%s role:%s type:%s range:%s",
                current_seuser,
                current_serole,
                current_setype,
                current_serange,
            )
        except ValueError:
            log.error("Unable to get current selinux attributes")
            ret["result"] = False
            ret["comment"].append("Failed to get selinux attributes")
            selinux_error = True
        if not selinux_error:
            requested_seuser = None
            requested_serole = None
            requested_setype = None
            requested_serange = None
            if seuser and seuser != current_seuser:
                requested_seuser = seuser
            if serole and serole != current_serole:
                requested_serole = serole
            if setype and setype != current_setype:
                requested_setype = setype
            if serange and serange != current_serange:
                requested_serange = serange
            if (
                requested_seuser
                or requested_serole
                or requested_setype
                or requested_serange
            ):
                selinux_change_new = ""
                selinux_change_orig = ""
                if requested_seuser:
                    selinux_change_new += "User: {} ".format(requested_seuser)
                    selinux_change_orig += "User: {} ".format(current_seuser)
                if requested_serole:
                    selinux_change_new += "Role: {} ".format(requested_serole)
                    selinux_change_orig += "Role: {} ".format(current_serole)
                if requested_setype:
                    selinux_change_new += "Type: {} ".format(requested_setype)
                    selinux_change_orig += "Type: {} ".format(current_setype)
                if requested_serange:
                    selinux_change_new += "Range: {} ".format(requested_serange)
                    selinux_change_orig += "Range: {} ".format(current_serange)
                if __opts__["test"]:
                    ret["comment"] = "File {} selinux context to be updated".format(
                        name
                    )
                    ret["result"] = None
                    ret["changes"]["selinux"] = {
                        "Old": selinux_change_orig.strip(),
                        "New": selinux_change_new.strip(),
                    }
                else:
                    try:
                        if (
                            requested_seuser or requested_serole or requested_serange
                        ) and not requested_setype:
                            requested_setype = current_setype
                        result = set_selinux_context(
                            name,
                            user=requested_seuser,
                            role=requested_serole,
                            type=requested_setype,
                            range=requested_serange,
                            persist=True,
                        )
                        log.debug("selinux set result: %s", result)
                        (
                            current_seuser,
                            current_serole,
                            current_setype,
                            current_serange,
                        ) = result.split(":")
                    except ValueError:
                        log.error("Unable to set current selinux attributes")
                        ret["result"] = False
                        ret["comment"].append("Failed to set selinux attributes")
                        selinux_error = True
                    if not selinux_error:
                        ret["comment"].append(
                            "The file {} is set to be changed".format(name)
                        )
                        if requested_seuser:
                            if current_seuser != requested_seuser:
                                ret["comment"].append("Unable to update seuser context")
                                ret["result"] = False
                        if requested_serole:
                            if current_serole != requested_serole:
                                ret["comment"].append("Unable to update serole context")
                                ret["result"] = False
                        if requested_setype:
                            if current_setype != requested_setype:
                                ret["comment"].append("Unable to update setype context")
                                ret["result"] = False
                        if requested_serange:
                            if current_serange != requested_serange:
                                ret["comment"].append(
                                    "Unable to update serange context"
                                )
                                ret["result"] = False
                        ret["changes"]["selinux"] = {
                            "Old": selinux_change_orig.strip(),
                            "New": selinux_change_new.strip(),
                        }
    if isinstance(orig_comment, str):
        if orig_comment:
            ret["comment"].insert(0, orig_comment)
        ret["comment"] = "; ".join(ret["comment"])
    if __opts__["test"] is True and ret["changes"]:
        ret["result"] = None
    return ret, perms
def check_managed(
    name,
    source,
    source_hash,
    source_hash_name,
    user,
    group,
    mode,
    attrs,
    template,
    context,
    defaults,
    saltenv,
    contents=None,
    skip_verify=False,
    seuser=None,
    serole=None,
    setype=None,
    serange=None,
    **kwargs
):
    source, source_hash = source_list(
        source, source_hash, saltenv  # pylint: disable=W0633
    )
    sfn = ""
    source_sum = None
    if contents is None:
        sfn, source_sum, comments = get_managed(
            name,
            template,
            source,
            source_hash,
            source_hash_name,
            user,
            group,
            mode,
            attrs,
            saltenv,
            context,
            defaults,
            skip_verify,
            **kwargs
        )
        if comments:
            __clean_tmp(sfn)
            return False, comments
    changes = check_file_meta(
        name,
        sfn,
        source,
        source_sum,
        user,
        group,
        mode,
        attrs,
        saltenv,
        contents,
        seuser=seuser,
        serole=serole,
        setype=setype,
        serange=serange,
    )
    if name.startswith(tempfile.gettempdir()):
        for key in ["user", "group", "mode"]:
            changes.pop(key, None)
    __clean_tmp(sfn)
    if changes:
        log.info(changes)
        comments = ["The following values are set to be changed:\n"]
        comments.extend("{}: {}\n".format(key, val) for key, val in changes.items())
        return None, "".join(comments)
    return True, "The file {} is in the correct state".format(name)
def check_managed_changes(
    name,
    source,
    source_hash,
    source_hash_name,
    user,
    group,
    mode,
    attrs,
    template,
    context,
    defaults,
    saltenv,
    contents=None,
    skip_verify=False,
    keep_mode=False,
    seuser=None,
    serole=None,
    setype=None,
    serange=None,
    verify_ssl=True,
    **kwargs
):
    source, source_hash = source_list(
        source, source_hash, saltenv  # pylint: disable=W0633
    )
    sfn = ""
    source_sum = None
    if contents is None:
        sfn, source_sum, comments = get_managed(
            name,
            template,
            source,
            source_hash,
            source_hash_name,
            user,
            group,
            mode,
            attrs,
            saltenv,
            context,
            defaults,
            skip_verify,
            verify_ssl=verify_ssl,
            **kwargs
        )
        if source_sum and ("hsum" in source_sum):
            source_sum["hsum"] = source_sum["hsum"].lower()
        if comments:
            __clean_tmp(sfn)
            return False, comments
        if sfn and source and keep_mode:
            if (
                urllib.parse.urlparse(source).scheme
                in (
                    "salt",
                    "file",
                )
                or source.startswith("/")
            ):
                try:
                    mode = __salt__["cp.stat_file"](source, saltenv=saltenv, octal=True)
                except Exception as exc:  # pylint: disable=broad-except
                    log.warning("Unable to stat %s: %s", sfn, exc)
    changes = check_file_meta(
        name,
        sfn,
        source,
        source_sum,
        user,
        group,
        mode,
        attrs,
        saltenv,
        contents,
        seuser=seuser,
        serole=serole,
        setype=setype,
        serange=serange,
    )
    __clean_tmp(sfn)
    return changes
def check_file_meta(
    name,
    sfn,
    source,
    source_sum,
    user,
    group,
    mode,
    attrs,
    saltenv,
    contents=None,
    seuser=None,
    serole=None,
    setype=None,
    serange=None,
    verify_ssl=True,
):
    changes = {}
    if not source_sum:
        source_sum = dict()
    try:
        lstats = stats(
            name, hash_type=source_sum.get("hash_type", None), follow_symlinks=False
        )
    except CommandExecutionError:
        lstats = {}
    if not lstats:
        changes["newfile"] = name
        return changes
    if "hsum" in source_sum:
        if source_sum["hsum"] != lstats["sum"]:
            if not sfn and source:
                sfn = __salt__["cp.cache_file"](
                    source,
                    saltenv,
                    source_hash=source_sum["hsum"],
                    verify_ssl=verify_ssl,
                )
            if sfn:
                try:
                    changes["diff"] = get_diff(
                        name, sfn, template=True, show_filenames=False
                    )
                except CommandExecutionError as exc:
                    changes["diff"] = exc.strerror
            else:
                changes["sum"] = "Checksum differs"
    if contents is not None:
        if isinstance(contents, bytes):
            tmp = salt.utils.files.mkstemp(
                prefix=salt.utils.files.TEMPFILE_PREFIX, text=False
            )
            with salt.utils.files.fopen(tmp, "wb") as tmp_:
                tmp_.write(contents)
        else:
            tmp = salt.utils.files.mkstemp(
                prefix=salt.utils.files.TEMPFILE_PREFIX, text=True
            )
            if salt.utils.platform.is_windows():
                contents = os.linesep.join(
                    _splitlines_preserving_trailing_newline(contents)
                )
            with salt.utils.files.fopen(tmp, "w") as tmp_:
                tmp_.write(salt.utils.stringutils.to_str(contents))
        try:
            differences = get_diff(name, tmp, show_filenames=False)
        except CommandExecutionError as exc:
            log.error("Failed to diff files: %s", exc)
            differences = exc.strerror
        __clean_tmp(tmp)
        if differences:
            if __salt__["config.option"]("obfuscate_templates"):
                changes["diff"] = "&lt;Obfuscated Template&gt;"
            else:
                changes["diff"] = differences
    if not salt.utils.platform.is_windows():
        if user is not None and user != lstats["user"] and user != lstats["uid"]:
            changes["user"] = user
        if group is not None and group != lstats["group"] and group != lstats["gid"]:
            changes["group"] = group
        smode = salt.utils.files.normalize_mode(lstats["mode"])
        mode = salt.utils.files.normalize_mode(mode)
        if mode is not None and mode != smode:
            changes["mode"] = mode
        if attrs:
            diff_attrs = _cmp_attrs(name, attrs)
            if diff_attrs is not None:
                if attrs is not None and (
                    diff_attrs[0] is not None or diff_attrs[1] is not None
                ):
                    changes["attrs"] = attrs
        if seuser or serole or setype or serange:
            try:
                (
                    current_seuser,
                    current_serole,
                    current_setype,
                    current_serange,
                ) = get_selinux_context(name).split(":")
                log.debug(
                    "Current selinux context user:%s role:%s type:%s range:%s",
                    current_seuser,
                    current_serole,
                    current_setype,
                    current_serange,
                )
            except ValueError as exc:
                log.error("Unable to get current selinux attributes")
                changes["selinux"] = exc.strerror
            if seuser and seuser != current_seuser:
                changes["selinux"] = {"user": seuser}
            if serole and serole != current_serole:
                changes["selinux"] = {"role": serole}
            if setype and setype != current_setype:
                changes["selinux"] = {"type": setype}
            if serange and serange != current_serange:
                changes["selinux"] = {"range": serange}
    return changes
def get_diff(
    file1,
    file2,
    saltenv="base",
    show_filenames=True,
    show_changes=True,
    template=False,
    source_hash_file1=None,
    source_hash_file2=None,
):
    files = (file1, file2)
    source_hashes = (source_hash_file1, source_hash_file2)
    paths = []
    errors = []
    for filename, source_hash in zip(files, source_hashes):
        try:
            cached_path = __salt__["cp.cache_file"](
                filename, saltenv, source_hash=source_hash
            )
            if cached_path is False:
                errors.append(
                    "File {} not found".format(
                        salt.utils.stringutils.to_unicode(filename)
                    )
                )
                continue
            paths.append(cached_path)
        except MinionError as exc:
            errors.append(salt.utils.stringutils.to_unicode(exc.__str__()))
            continue
    if errors:
        raise CommandExecutionError("Failed to cache one or more files", info=errors)
    args = []
    for filename in paths:
        try:
            with salt.utils.files.fopen(filename, "rb") as fp_:
                args.append(fp_.readlines())
        except OSError as exc:
            raise CommandExecutionError(
                "Failed to read {}: {}".format(
                    salt.utils.stringutils.to_unicode(filename), exc.strerror
                )
            )
    if args[0] != args[1]:
        if template and __salt__["config.option"]("obfuscate_templates"):
            ret = "&lt;Obfuscated Template&gt;"
        elif not show_changes:
            ret = "&lt;show_changes=False&gt;"
        else:
            bdiff = _binary_replace(*paths)  # pylint: disable=no-value-for-parameter
            if bdiff:
                ret = bdiff
            else:
                if show_filenames:
                    args.extend(paths)
                ret = __utils__["stringutils.get_diff"](*args)
        return ret
    return ""
def manage_file(
    name,
    sfn,
    ret,
    source,
    source_sum,
    user,
    group,
    mode,
    attrs,
    saltenv,
    backup,
    makedirs=False,
    template=None,  # pylint: disable=W0613
    show_changes=True,
    contents=None,
    dir_mode=None,
    follow_symlinks=True,
    skip_verify=False,
    keep_mode=False,
    encoding=None,
    encoding_errors="strict",
    seuser=None,
    serole=None,
    setype=None,
    serange=None,
    verify_ssl=True,
    use_etag=False,
    **kwargs
):
    name = os.path.expanduser(name)
    check_web_source_hash = bool(
        source
        and urllib.parse.urlparse(source).scheme != "salt"
        and not skip_verify
        and not use_etag
    )
    if not ret:
        ret = {"name": name, "changes": {}, "comment": "", "result": True}
    if source_sum and ("hsum" in source_sum):
        source_sum["hsum"] = source_sum["hsum"].lower()
    if source:
        if not sfn:
            sfn = __salt__["cp.cache_file"](source, saltenv, verify_ssl=verify_ssl)
            if not sfn:
                return _error(ret, "Source file '{}' not found".format(source))
            htype = source_sum.get("hash_type", __opts__["hash_type"])
            source_sum = {"hash_type": htype, "hsum": get_hash(sfn, form=htype)}
        if keep_mode:
            if urllib.parse.urlparse(source).scheme in ("salt", "file", ""):
                try:
                    mode = __salt__["cp.stat_file"](source, saltenv=saltenv, octal=True)
                except Exception as exc:  # pylint: disable=broad-except
                    log.warning("Unable to stat %s: %s", sfn, exc)
    if os.path.isfile(name) or os.path.islink(name):
        if os.path.islink(name) and follow_symlinks:
            real_name = os.path.realpath(name)
        else:
            real_name = name
        if source and not (not follow_symlinks and os.path.islink(real_name)):
            name_sum = get_hash(
                real_name, source_sum.get("hash_type", __opts__["hash_type"])
            )
        else:
            name_sum = None
        if source and (
            name_sum is None
            or source_sum.get("hsum", __opts__["hash_type"]) != name_sum
        ):
            if not sfn:
                sfn = __salt__["cp.cache_file"](
                    source, saltenv, verify_ssl=verify_ssl, use_etag=use_etag
                )
            if not sfn:
                return _error(ret, "Source file '{}' not found".format(source))
            if check_web_source_hash:
                dl_sum = get_hash(sfn, source_sum["hash_type"])
                if dl_sum != source_sum["hsum"]:
                    ret["comment"] = (
                        "Specified {} checksum for {} ({}) does not match "
                        "actual checksum ({}). If the 'source_hash' value "
                        "refers to a remote file with multiple possible "
                        "matches, then it may be necessary to set "
                        "'source_hash_name'.".format(
                            source_sum["hash_type"], source, source_sum["hsum"], dl_sum
                        )
                    )
                    ret["result"] = False
                    return ret
            if __salt__["config.option"]("obfuscate_templates"):
                ret["changes"]["diff"] = "&lt;Obfuscated Template&gt;"
            elif not show_changes:
                ret["changes"]["diff"] = "&lt;show_changes=False&gt;"
            else:
                try:
                    file_diff = get_diff(real_name, sfn, show_filenames=False)
                    if file_diff:
                        ret["changes"]["diff"] = file_diff
                except CommandExecutionError as exc:
                    ret["changes"]["diff"] = exc.strerror
            try:
                salt.utils.files.copyfile(
                    sfn,
                    real_name,
                    __salt__["config.backup_mode"](backup),
                    __opts__["cachedir"],
                )
            except OSError as io_error:
                __clean_tmp(sfn)
                return _error(ret, "Failed to commit change: {}".format(io_error))
        if contents is not None:
            tmp = salt.utils.files.mkstemp(
                prefix=salt.utils.files.TEMPFILE_PREFIX, text=True
            )
            with salt.utils.files.fopen(tmp, "wb") as tmp_:
                if encoding:
                    if salt.utils.platform.is_windows():
                        contents = os.linesep.join(
                            _splitlines_preserving_trailing_newline(contents)
                        )
                    log.debug("File will be encoded with %s", encoding)
                    tmp_.write(
                        contents.encode(encoding=encoding, errors=encoding_errors)
                    )
                else:
                    tmp_.write(salt.utils.stringutils.to_bytes(contents))
            try:
                differences = get_diff(
                    real_name,
                    tmp,
                    show_filenames=False,
                    show_changes=show_changes,
                    template=True,
                )
            except CommandExecutionError as exc:
                ret.setdefault("warnings", []).append(
                    "Failed to detect changes to file: {}".format(exc.strerror)
                )
                differences = ""
            if differences:
                ret["changes"]["diff"] = differences
                try:
                    salt.utils.files.copyfile(
                        tmp,
                        real_name,
                        __salt__["config.backup_mode"](backup),
                        __opts__["cachedir"],
                    )
                except OSError as io_error:
                    __clean_tmp(tmp)
                    return _error(ret, "Failed to commit change: {}".format(io_error))
            __clean_tmp(tmp)
        if os.path.islink(name) and not follow_symlinks:
            if not sfn:
                sfn = __salt__["cp.cache_file"](source, saltenv, verify_ssl=verify_ssl)
            if not sfn:
                return _error(ret, "Source file '{}' not found".format(source))
            if check_web_source_hash:
                dl_sum = get_hash(sfn, source_sum["hash_type"])
                if dl_sum != source_sum["hsum"]:
                    ret["comment"] = (
                        "Specified {} checksum for {} ({}) does not match "
                        "actual checksum ({})".format(
                            source_sum["hash_type"], name, source_sum["hsum"], dl_sum
                        )
                    )
                    ret["result"] = False
                    return ret
            try:
                salt.utils.files.copyfile(
                    sfn,
                    name,
                    __salt__["config.backup_mode"](backup),
                    __opts__["cachedir"],
                )
            except OSError as io_error:
                __clean_tmp(sfn)
                return _error(ret, "Failed to commit change: {}".format(io_error))
            ret["changes"]["diff"] = "Replace symbolic link with regular file"
        if salt.utils.platform.is_windows():
            ret = check_perms(
                path=name,
                ret=ret,
                owner=kwargs.get("win_owner"),
                grant_perms=kwargs.get("win_perms"),
                deny_perms=kwargs.get("win_deny_perms"),
                inheritance=kwargs.get("win_inheritance", True),
                reset=kwargs.get("win_perms_reset", False),
            )
        else:
            ret, _ = check_perms(
                name,
                ret,
                user,
                group,
                mode,
                attrs,
                follow_symlinks,
                seuser=seuser,
                serole=serole,
                setype=setype,
                serange=serange,
            )
        if ret["changes"]:
            ret["comment"] = "File {} updated".format(salt.utils.data.decode(name))
        elif not ret["changes"] and ret["result"]:
            ret["comment"] = "File {} is in the correct state".format(
                salt.utils.data.decode(name)
            )
        if sfn:
            __clean_tmp(sfn)
        return ret
    else:  # target file does not exist
        contain_dir = os.path.dirname(name)
        def _set_mode_and_make_dirs(name, dir_mode, mode, user, group):
            if salt.utils.platform.is_windows():
                drive, _ = os.path.splitdrive(name)
                if drive and not os.path.exists(drive):
                    __clean_tmp(sfn)
                    return _error(ret, "{} drive not present".format(drive))
            if dir_mode is None and mode is not None:
                mode_list = [x for x in str(mode)][-3:]
                for idx, part in enumerate(mode_list):
                    if part != "0":
                        mode_list[idx] = str(int(part) | 1)
                dir_mode = "".join(mode_list)
            if salt.utils.platform.is_windows():
                makedirs_(
                    path=name,
                    owner=kwargs.get("win_owner"),
                    grant_perms=kwargs.get("win_perms"),
                    deny_perms=kwargs.get("win_deny_perms"),
                    inheritance=kwargs.get("win_inheritance", True),
                    reset=kwargs.get("win_perms_reset", False),
                )
            else:
                makedirs_(name, user=user, group=group, mode=dir_mode)
        if source:
            if not sfn:
                sfn = __salt__["cp.cache_file"](source, saltenv, verify_ssl=verify_ssl)
            if not sfn:
                return _error(ret, "Source file '{}' not found".format(source))
            if check_web_source_hash:
                dl_sum = get_hash(sfn, source_sum["hash_type"])
                if dl_sum != source_sum["hsum"]:
                    ret["comment"] = (
                        "Specified {} checksum for {} ({}) does not match "
                        "actual checksum ({})".format(
                            source_sum["hash_type"], name, source_sum["hsum"], dl_sum
                        )
                    )
                    ret["result"] = False
                    return ret
            ret["changes"]["diff"] = "New file"
            if not os.path.isdir(contain_dir):
                if makedirs:
                    _set_mode_and_make_dirs(name, dir_mode, mode, user, group)
                else:
                    __clean_tmp(sfn)
                    ret["changes"].pop("diff", None)
                    return _error(ret, "Parent directory not present")
        else:  # source != True
            if not os.path.isdir(contain_dir):
                if makedirs:
                    _set_mode_and_make_dirs(name, dir_mode, mode, user, group)
                else:
                    __clean_tmp(sfn)
                    ret["changes"].pop("diff", None)
                    return _error(ret, "Parent directory not present")
            with salt.utils.files.set_umask(0o077 if mode else None):
                if contents is None:
                    if not __opts__["test"]:
                        if touch(name):
                            ret["changes"]["new"] = "file {} created".format(name)
                            ret["comment"] = "Empty file"
                        else:
                            return _error(ret, "Empty file {} not created".format(name))
                else:
                    if not __opts__["test"]:
                        if touch(name):
                            ret["changes"]["diff"] = "New file"
                        else:
                            return _error(ret, "File {} not created".format(name))
        if contents is not None:
            tmp = salt.utils.files.mkstemp(
                prefix=salt.utils.files.TEMPFILE_PREFIX, text=True
            )
            with salt.utils.files.fopen(tmp, "wb") as tmp_:
                if encoding:
                    if salt.utils.platform.is_windows():
                        contents = os.linesep.join(
                            _splitlines_preserving_trailing_newline(contents)
                        )
                    log.debug("File will be encoded with %s", encoding)
                    tmp_.write(
                        contents.encode(encoding=encoding, errors=encoding_errors)
                    )
                else:
                    tmp_.write(salt.utils.stringutils.to_bytes(contents))
            salt.utils.files.copyfile(
                tmp, name, __salt__["config.backup_mode"](backup), __opts__["cachedir"]
            )
            __clean_tmp(tmp)
        elif sfn:
            salt.utils.files.copyfile(
                sfn, name, __salt__["config.backup_mode"](backup), __opts__["cachedir"]
            )
            __clean_tmp(sfn)
        if mode is None and not salt.utils.platform.is_windows():
            mask = salt.utils.files.get_umask()
            mode = oct((0o777 ^ mask) &amp; 0o666)
        if salt.utils.platform.is_windows():
            ret = check_perms(
                path=name,
                ret=ret,
                owner=kwargs.get("win_owner"),
                grant_perms=kwargs.get("win_perms"),
                deny_perms=kwargs.get("win_deny_perms"),
                inheritance=kwargs.get("win_inheritance", True),
                reset=kwargs.get("win_perms_reset", False),
            )
        else:
            ret, _ = check_perms(
                name,
                ret,
                user,
                group,
                mode,
                attrs,
                seuser=seuser,
                serole=serole,
                setype=setype,
                serange=serange,
            )
        if not ret["comment"]:
            ret["comment"] = "File " + name + " updated"
        if __opts__["test"]:
            ret["comment"] = "File " + name + " not updated"
        elif not ret["changes"] and ret["result"]:
            ret["comment"] = "File " + name + " is in the correct state"
        if sfn:
            __clean_tmp(sfn)
        return ret
def mkdir(dir_path, user=None, group=None, mode=None):
    dir_path = os.path.expanduser(dir_path)
    directory = os.path.normpath(dir_path)
    if not os.path.isdir(directory):
        makedirs_perms(directory, user, group, mode)
    return True
def makedirs_(path, user=None, group=None, mode=None):
    path = os.path.expanduser(path)
    if mode:
        mode = salt.utils.files.normalize_mode(mode)
    dirname = os.path.normpath(os.path.dirname(path))
    if os.path.isdir(dirname):
        msg = "Directory '{}' already exists".format(dirname)
        log.debug(msg)
        return msg
    if os.path.exists(dirname):
        msg = "The path '{}' already exists and is not a directory".format(dirname)
        log.debug(msg)
        return msg
    directories_to_create = []
    while True:
        if os.path.isdir(dirname):
            break
        directories_to_create.append(dirname)
        current_dirname = dirname
        dirname = os.path.dirname(dirname)
        if current_dirname == dirname:
            raise SaltInvocationError(
                "Recursive creation for path '{}' would result in an "
                "infinite loop. Please use an absolute path.".format(dirname)
            )
    directories_to_create.reverse()
    for directory_to_create in directories_to_create:
        log.debug("Creating directory: %s", directory_to_create)
        mkdir(directory_to_create, user=user, group=group, mode=mode)
def makedirs_perms(name, user=None, group=None, mode="0755"):
    name = os.path.expanduser(name)
    path = os.path
    head, tail = path.split(name)
    if not tail:
        head, tail = path.split(head)
    if head and tail and not path.exists(head):
        try:
            makedirs_perms(head, user, group, mode)
        except OSError as exc:
            if exc.errno != errno.EEXIST:
                raise
        if tail == os.curdir:  # xxx/newdir/. exists if xxx/newdir exists
            return
    os.mkdir(name)
    check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
def get_devmm(name):
    name = os.path.expanduser(name)
    if is_chrdev(name) or is_blkdev(name):
        stat_structure = os.stat(name)
        return (os.major(stat_structure.st_rdev), os.minor(stat_structure.st_rdev))
    else:
        return (0, 0)
def is_chrdev(name):
    name = os.path.expanduser(name)
    stat_structure = None
    try:
        stat_structure = os.stat(name)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            return False
        else:
            raise
    return stat.S_ISCHR(stat_structure.st_mode)
def mknod_chrdev(name, major, minor, user=None, group=None, mode="0660"):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "comment": "", "result": False}
    log.debug(
        "Creating character device name:%s major:%s minor:%s mode:%s",
        name,
        major,
        minor,
        mode,
    )
    try:
        if __opts__["test"]:
            ret["changes"] = {"new": "Character device {} created.".format(name)}
            ret["result"] = None
        else:
            if (
                os.mknod(
                    name,
                    int(str(mode).lstrip("0Oo"), 8) | stat.S_IFCHR,
                    os.makedev(major, minor),
                )
                is None
            ):
                ret["changes"] = {"new": "Character device {} created.".format(name)}
                ret["result"] = True
    except OSError as exc:
        if exc.errno != errno.EEXIST:
            raise
        else:
            ret["comment"] = "File {} exists and cannot be overwritten".format(name)
    check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
    return ret
def is_blkdev(name):
    name = os.path.expanduser(name)
    stat_structure = None
    try:
        stat_structure = os.stat(name)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            return False
        else:
            raise
    return stat.S_ISBLK(stat_structure.st_mode)
def mknod_blkdev(name, major, minor, user=None, group=None, mode="0660"):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "comment": "", "result": False}
    log.debug(
        "Creating block device name:%s major:%s minor:%s mode:%s",
        name,
        major,
        minor,
        mode,
    )
    try:
        if __opts__["test"]:
            ret["changes"] = {"new": "Block device {} created.".format(name)}
            ret["result"] = None
        else:
            if (
                os.mknod(
                    name,
                    int(str(mode).lstrip("0Oo"), 8) | stat.S_IFBLK,
                    os.makedev(major, minor),
                )
                is None
            ):
                ret["changes"] = {"new": "Block device {} created.".format(name)}
                ret["result"] = True
    except OSError as exc:
        if exc.errno != errno.EEXIST:
            raise
        else:
            ret["comment"] = "File {} exists and cannot be overwritten".format(name)
    check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
    return ret
def is_fifo(name):
    name = os.path.expanduser(name)
    stat_structure = None
    try:
        stat_structure = os.stat(name)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            return False
        else:
            raise
    return stat.S_ISFIFO(stat_structure.st_mode)
def mknod_fifo(name, user=None, group=None, mode="0660"):
    name = os.path.expanduser(name)
    ret = {"name": name, "changes": {}, "comment": "", "result": False}
    log.debug("Creating FIFO name: %s", name)
    try:
        if __opts__["test"]:
            ret["changes"] = {"new": "Fifo pipe {} created.".format(name)}
            ret["result"] = None
        else:
            if os.mkfifo(name, int(str(mode).lstrip("0Oo"), 8)) is None:
                ret["changes"] = {"new": "Fifo pipe {} created.".format(name)}
                ret["result"] = True
    except OSError as exc:
        if exc.errno != errno.EEXIST:
            raise
        else:
            ret["comment"] = "File {} exists and cannot be overwritten".format(name)
    check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
    return ret
def mknod(name, ntype, major=0, minor=0, user=None, group=None, mode="0600"):
    ret = False
    makedirs_(name, user, group)
    if ntype == "c":
        ret = mknod_chrdev(name, major, minor, user, group, mode)
    elif ntype == "b":
        ret = mknod_blkdev(name, major, minor, user, group, mode)
    elif ntype == "p":
        ret = mknod_fifo(name, user, group, mode)
    else:
        raise SaltInvocationError(
            "Node type unavailable: '{}'. Available node types are "
            "character ('c'), block ('b'), and pipe ('p').".format(ntype)
        )
    return ret
def list_backups(path, limit=None):
    path = os.path.expanduser(path)
    try:
        limit = int(limit)
    except TypeError:
        pass
    except ValueError:
        log.error("file.list_backups: 'limit' value must be numeric")
        limit = None
    bkroot = _get_bkroot()
    parent_dir, basename = os.path.split(path)
    if salt.utils.platform.is_windows():
        src_dir = parent_dir.replace(":", "_")
    else:
        src_dir = parent_dir[1:]
    bkdir = os.path.join(bkroot, src_dir)
    if not os.path.isdir(bkdir):
        return {}
    files = {}
    for fname in [
        x for x in os.listdir(bkdir) if os.path.isfile(os.path.join(bkdir, x))
    ]:
        if salt.utils.platform.is_windows():
            strpfmt = "{}_%a_%b_%d_%H-%M-%S_%f_%Y".format(basename)
        else:
            strpfmt = "{}_%a_%b_%d_%H:%M:%S_%f_%Y".format(basename)
        try:
            timestamp = datetime.datetime.strptime(fname, strpfmt)
        except ValueError:
            continue
        if salt.utils.platform.is_windows():
            str_format = "%a %b %d %Y %H-%M-%S.%f"
        else:
            str_format = "%a %b %d %Y %H:%M:%S.%f"
        files.setdefault(timestamp, {})["Backup Time"] = timestamp.strftime(str_format)
        location = os.path.join(bkdir, fname)
        files[timestamp]["Size"] = os.stat(location).st_size
        files[timestamp]["Location"] = location
    return dict(
        list(
            zip(
                list(range(len(files))),
                [files[x] for x in sorted(files, reverse=True)[:limit]],
            )
        )
    )
list_backup = salt.utils.functools.alias_function(list_backups, "list_backup")
def list_backups_dir(path, limit=None):
    path = os.path.expanduser(path)
    try:
        limit = int(limit)
    except TypeError:
        pass
    except ValueError:
        log.error("file.list_backups_dir: 'limit' value must be numeric")
        limit = None
    bkroot = _get_bkroot()
    parent_dir, basename = os.path.split(path)
    bkdir = os.path.join(bkroot, parent_dir[1:])
    if not os.path.isdir(bkdir):
        return {}
    files = {}
    f = {
        i: len(list(n))
        for i, n in itertools.groupby(
            [x.split("_")[0] for x in sorted(os.listdir(bkdir))]
        )
    }
    ff = os.listdir(bkdir)
    for i, n in f.items():
        ssfile = {}
        for x in sorted(ff):
            basename = x.split("_")[0]
            if i == basename:
                strpfmt = "{}_%a_%b_%d_%H:%M:%S_%f_%Y".format(basename)
                try:
                    timestamp = datetime.datetime.strptime(x, strpfmt)
                except ValueError:
                    continue
                ssfile.setdefault(timestamp, {})["Backup Time"] = timestamp.strftime(
                    "%a %b %d %Y %H:%M:%S.%f"
                )
                location = os.path.join(bkdir, x)
                ssfile[timestamp]["Size"] = os.stat(location).st_size
                ssfile[timestamp]["Location"] = location
        sfiles = dict(
            list(
                zip(
                    list(range(n)),
                    [ssfile[x] for x in sorted(ssfile, reverse=True)[:limit]],
                )
            )
        )
        sefiles = {i: sfiles}
        files.update(sefiles)
    return files
def restore_backup(path, backup_id):
    path = os.path.expanduser(path)
    ret = {"result": False, "comment": "Invalid backup_id '{}'".format(backup_id)}
    try:
        if len(str(backup_id)) == len(str(int(backup_id))):
            backup = list_backups(path)[int(backup_id)]
        else:
            return ret
    except ValueError:
        return ret
    except KeyError:
        ret["comment"] = "backup_id '{}' does not exist for {}".format(backup_id, path)
        return ret
    salt.utils.files.backup_minion(path, _get_bkroot())
    try:
        shutil.copyfile(backup["Location"], path)
    except OSError as exc:
        ret["comment"] = "Unable to restore {} to {}: {}".format(
            backup["Location"], path, exc
        )
        return ret
    else:
        ret["result"] = True
        ret["comment"] = "Successfully restored {} to {}".format(
            backup["Location"], path
        )
    if not salt.utils.platform.is_windows():
        try:
            fstat = os.stat(path)
        except OSError:
            ret["comment"] += ", but was unable to set ownership"
        else:
            os.chown(path, fstat.st_uid, fstat.st_gid)
    return ret
def delete_backup(path, backup_id):
    path = os.path.expanduser(path)
    ret = {"result": False, "comment": "Invalid backup_id '{}'".format(backup_id)}
    try:
        if len(str(backup_id)) == len(str(int(backup_id))):
            backup = list_backups(path)[int(backup_id)]
        else:
            return ret
    except ValueError:
        return ret
    except KeyError:
        ret["comment"] = "backup_id '{}' does not exist for {}".format(backup_id, path)
        return ret
    try:
        os.remove(backup["Location"])
    except OSError as exc:
        ret["comment"] = "Unable to remove {}: {}".format(backup["Location"], exc)
    else:
        ret["result"] = True
        ret["comment"] = "Successfully removed {}".format(backup["Location"])
    return ret
remove_backup = salt.utils.functools.alias_function(delete_backup, "remove_backup")
def grep(path, pattern, *opts):
    path = os.path.expanduser(path)
    _path = path
    path = glob.glob(path)
    if not path:
        path = _path
    split_opts = []
    for opt in opts:
        try:
            split = salt.utils.args.shlex_split(opt)
        except AttributeError:
            split = salt.utils.args.shlex_split(str(opt))
        if len(split) &gt; 1:
            raise SaltInvocationError(
                "Passing multiple command line arguments in a single string "
                "is not supported, please pass the following arguments "
                "separately: {}".format(opt)
            )
        split_opts.extend(split)
    if isinstance(path, list):
        cmd = ["grep"] + split_opts + [pattern] + path
    else:
        cmd = ["grep"] + split_opts + [pattern, path]
    try:
        ret = __salt__["cmd.run_all"](cmd, python_shell=False)
    except OSError as exc:
        raise CommandExecutionError(exc.strerror)
    return ret
def open_files(by_pid=False):
    pids = {}
    procfs = os.listdir("/proc/")
    for pfile in procfs:
        try:
            pids[int(pfile)] = []
        except ValueError:
            pass
    files = {}
    for pid in pids:
        ppath = "/proc/{}"<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.format(pid)
        try:
            tids = os.listdir("{}/task".format(ppath))
        except OSError:
            continue
        fd_ =</b></font> []
        for fpath in os.listdir("{}/fd".format(ppath)):
            fd_.append("{}/fd/{}".format(ppath, fpath))
        for tid in tids:
            try:
                fd_.append(os.path.realpath("{}/task/{}/exe".format(ppath, tid)))
            except OSError:
                continue
            for tpath in os.listdir("{}/task/{}/fd".format(ppath, tid)):
                fd_.append("{}/task/{}/fd/{}".format(ppath, tid, tpath))
        fd_ = sorted(set(fd_))
        for fdpath in fd_:
            try:
                name = os.path.realpath(fdpath)
                os.stat(name)
            except OSError:
                continue
            if name not in files:
                files[name] = [pid]
            else:
                files[name].append(pid)
                files[name] = sorted(set(files[name]))
            pids[pid].append(name)
            pids[pid] = sorted(set(pids[pid]))
    if by_pid:
        return pids
    return files
def pardir():
    return os.path.pardir
def normpath(path):
    return os.path.normpath(path)
def basename(path):
    return os.path.basename(path)
def dirname(path):
    return os.path.dirname(path)
def join(*args):
    return os.path.join(*args)
def move(src, dst):
    src = os.path.expanduser(src)
    dst = os.path.expanduser(dst)
    if not os.path.isabs(src):
        raise SaltInvocationError("Source path must be absolute.")
    if not os.path.isabs(dst):
        raise SaltInvocationError("Destination path must be absolute.")
    ret = {
        "result": True,
        "comment": "'{}' moved to '{}'".format(src, dst),
    }
    try:
        shutil.move(src, dst)
    except OSError as exc:
        raise CommandExecutionError(
            "Unable to move '{}' to '{}': {}".format(src, dst, exc)
        )
    return ret
def diskusage(path):
    total_size = 0
    seen = set()
    if os.path.isfile(path):
        stat_structure = os.stat(path)
        ret = stat_structure.st_size
        return ret
    for dirpath, dirnames, filenames in salt.utils.path.os_walk(path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            try:
                stat_structure = os.stat(fp)
            except OSError:
                continue
            if stat_structure.st_ino in seen:
                continue
            seen.add(stat_structure.st_ino)
            total_size += stat_structure.st_size
    ret = total_size
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
