<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for openbsdpkg.py &amp; file_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for openbsdpkg.py &amp; file_1.py
      </h3>
<h1 align="center">
        0.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>openbsdpkg.py (3.4482758%)<th>file_1.py (0.16438356%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(93-98)<td><a href="#" name="0">(7143-7150)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>openbsdpkg.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import copy
2 import logging
3 import re
4 import salt.utils.data
5 import salt.utils.versions
6 from salt.exceptions import CommandExecutionError, MinionError
7 log = logging.getLogger(__name__)
8 __PKG_RE = re.compile("^((?:[^-]+|-(?![0-9]))+)-([0-9][^-]*)(?:-(.*))?$")
9 __virtualname__ = "pkg"
10 def __virtual__():
11     if __grains__["os"] == "OpenBSD":
12         return __virtualname__
13     return (
14         False,
15         "The openbsdpkg execution module cannot be loaded: "
16         "only available on OpenBSD systems.",
17     )
18 def _list_pkgs_from_context(versions_as_list):
19     if versions_as_list:
20         return __context__["pkg.list_pkgs"]
21     else:
22         ret = copy.deepcopy(__context__["pkg.list_pkgs"])
23         __salt__["pkg_resource.stringify"](ret)
24         return ret
25 def list_pkgs(versions_as_list=False, **kwargs):
26     versions_as_list = salt.utils.data.is_true(versions_as_list)
27     if any(
28         [salt.utils.data.is_true(kwargs.get(x)) for x in ("removed", "purge_desired")]
29     ):
30         return {}
31     if "pkg.list_pkgs" in __context__ and kwargs.get("use_context", True):
32         return _list_pkgs_from_context(versions_as_list)
33 <a name="0"></a>    ret = {}
34     cmd = "pkg_info -q -a"
35     out = __salt__["cmd.run_stdout"](cmd, output_loglevel="trace")
36     for line in out<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.splitlines():
37         try:
38             pkgname, pkgver, flavor = __PKG_RE.match(line).groups()
39         except AttributeError:
40             continue
41         pkgname +=</b></font> "--{}".format(flavor) if flavor else ""
42         __salt__["pkg_resource.add_pkg"](ret, pkgname, pkgver)
43     __salt__["pkg_resource.sort_pkglist"](ret)
44     __context__["pkg.list_pkgs"] = copy.deepcopy(ret)
45     if not versions_as_list:
46         __salt__["pkg_resource.stringify"](ret)
47     return ret
48 def latest_version(*names, **kwargs):
49     kwargs.pop("refresh", True)
50     pkgs = list_pkgs()
51     ret = {}
52     for name in names:
53         ret[name] = ""
54         cmd = "pkg_info -Q {}".format(name)
55         out = __salt__["cmd.run_stdout"](
56             cmd, python_shell=False, output_loglevel="trace"
57         )
58         for line in out.splitlines():
59             try:
60                 pkgname, pkgver, flavor = __PKG_RE.match(line).groups()
61             except AttributeError:
62                 continue
63             match = re.match(r".*\(installed\)$", pkgver)
64             if match:
65                 break
66             if "{}--{}".format(pkgname, flavor) == name:
67                 pkgname += "--{}".format(flavor)
68             elif pkgname == name:
69                 pass
70             else:
71                 continue
72             cur = pkgs.get(pkgname, "")
73             if not cur or salt.utils.versions.compare(ver1=cur, oper="&lt;", ver2=pkgver):
74                 ret[pkgname] = pkgver
75     if len(names) == 1:
76         return ret[names[0]]
77     return ret
78 def version(*names, **kwargs):
79     return __salt__["pkg_resource.version"](*names, **kwargs)
80 def install(name=None, pkgs=None, sources=None, **kwargs):
81     try:
82         pkg_params, pkg_type = __salt__["pkg_resource.parse_targets"](
83             name, pkgs, sources, **kwargs
84         )
85     except MinionError as exc:
86         raise CommandExecutionError(exc)
87     if pkg_params is None or len(pkg_params) == 0:
88         return {}
89     old = list_pkgs()
90     errors = []
91     for pkg in pkg_params:
92         if pkg_type == "repository":
93             stem, branch = (pkg.split("%") + [""])[:2]
94             base, flavor = (stem.split("--") + [""])[:2]
95             pkg = "{}--{}%{}".format(base, flavor, branch)
96         cmd = "pkg_add -x -I {}".format(pkg)
97         out = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="trace")
98         if out["retcode"] != 0 and out["stderr"]:
99             errors.append(out["stderr"])
100     __context__.pop("pkg.list_pkgs", None)
101     new = list_pkgs()
102     ret = salt.utils.data.compare_dicts(old, new)
103     if errors:
104         raise CommandExecutionError(
105             "Problem encountered installing package(s)",
106             info={"errors": errors, "changes": ret},
107         )
108     return ret
109 def remove(name=None, pkgs=None, purge=False, **kwargs):
110     try:
111         pkg_params = [
112             x.split("--")[0]
113             for x in __salt__["pkg_resource.parse_targets"](name, pkgs)[0]
114         ]
115     except MinionError as exc:
116         raise CommandExecutionError(exc)
117     old = list_pkgs()
118     targets = [x for x in pkg_params if x in old]
119     if not targets:
120         return {}
121     cmd = ["pkg_delete", "-Ix", "-Ddependencies"]
122     if purge:
123         cmd.append("-cqq")
124     cmd.extend(targets)
125     out = __salt__["cmd.run_all"](cmd, python_shell=False, output_loglevel="trace")
126     if out["retcode"] != 0 and out["stderr"]:
127         errors = [out["stderr"]]
128     else:
129         errors = []
130     __context__.pop("pkg.list_pkgs", None)
131     new = list_pkgs()
132     ret = salt.utils.data.compare_dicts(old, new)
133     if errors:
134         raise CommandExecutionError(
135             "Problem encountered removing package(s)",
136             info={"errors": errors, "changes": ret},
137         )
138     return ret
139 def purge(name=None, pkgs=None, **kwargs):
140     return remove(name=name, pkgs=pkgs, purge=True)
141 def upgrade_available(name, **kwargs):
142     return latest_version(name) != ""
143 def upgrade(name=None, pkgs=None, **kwargs):
144     old = list_pkgs()
145     cmd = ["pkg_add", "-Ix", "-u"]
146     if kwargs.get("noop", False):
147         cmd.append("-n")
148     if pkgs:
149         cmd.extend(pkgs)
150     elif name:
151         cmd.append(name)
152     result = __salt__["cmd.run_all"](cmd, output_loglevel="trace", python_shell=False)
153     __context__.pop("pkg.list_pkgs", None)
154     new = list_pkgs()
155     ret = salt.utils.data.compare_dicts(old, new)
156     if result["retcode"] != 0:
157         raise CommandExecutionError(
158             "Problem encountered upgrading packages",
159             info={"changes": ret, "result": result},
160         )
161     return ret
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>file_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import errno
3 import fnmatch
4 import glob
5 import hashlib
6 import itertools
7 import logging
8 import mmap
9 import operator
10 import os
11 import re
12 import shutil
13 import stat
14 import string
15 import sys
16 import tempfile
17 import time
18 import urllib.parse
19 from collections import namedtuple
20 from collections.abc import Iterable, Mapping
21 from functools import reduce
22 import salt.utils.args
23 import salt.utils.atomicfile
24 import salt.utils.data
25 import salt.utils.filebuffer
26 import salt.utils.files
27 import salt.utils.find
28 import salt.utils.functools
29 import salt.utils.hashutils
30 import salt.utils.http
31 import salt.utils.itertools
32 import salt.utils.path
33 import salt.utils.platform
34 import salt.utils.stringutils
35 import salt.utils.templates
36 import salt.utils.url
37 import salt.utils.user
38 import salt.utils.versions
39 from salt.exceptions import CommandExecutionError, MinionError, SaltInvocationError
40 from salt.exceptions import get_error_message as _get_error_message
41 from salt.utils.files import HASHES, HASHES_REVMAP
42 try:
43     import grp
44     import pwd
45 except ImportError:
46     pass
47 log = logging.getLogger(__name__)
48 __func_alias__ = {"makedirs_": "makedirs"}
49 AttrChanges = namedtuple("AttrChanges", "added,removed")
50 def __virtual__():
51     if salt.utils.platform.is_windows():
52         return (
53             False,
54             "The file execution module cannot be loaded: only available on "
55             "non-Windows systems - use win_file instead.",
56         )
57     return True
58 def __clean_tmp(sfn):
59     if sfn.startswith(
60         os.path.join(tempfile.gettempdir(), salt.utils.files.TEMPFILE_PREFIX)
61     ):
62         all_roots = itertools.chain.from_iterable(__opts__["file_roots"].values())
63         in_roots = any(sfn.startswith(root) for root in all_roots)
64         if os.path.exists(sfn) and not in_roots:
65             os.remove(sfn)
66 def _error(ret, err_msg):
67     ret["result"] = False
68     ret["comment"] = err_msg
69     return ret
70 def _binary_replace(old, new):
71     old_isbin = not __utils__["files.is_text"](old)
72     new_isbin = not __utils__["files.is_text"](new)
73     if any((old_isbin, new_isbin)):
74         if all((old_isbin, new_isbin)):
75             return "Replace binary file"
76         elif old_isbin:
77             return "Replace binary file with text file"
78         elif new_isbin:
79             return "Replace text file with binary file"
80     return ""
81 def _get_bkroot():
82     return os.path.join(__salt__["config.get"]("cachedir"), "file_backup")
83 def _splitlines_preserving_trailing_newline(str):
84     lines = str.splitlines()
85     if str.endswith("\n") or str.endswith("\r"):
86         lines.append("")
87     return lines
88 def _chattr_version():
89     tune2fs = salt.utils.path.which("tune2fs")
90     if not tune2fs or salt.utils.platform.is_aix():
91         return None
92     cmd = [tune2fs]
93     result = __salt__["cmd.run"](cmd, ignore_retcode=True, python_shell=False)
94     match = re.search(
95         r"tune2fs (?P&lt;version&gt;[0-9\.]+)",
96         salt.utils.stringutils.to_str(result),
97     )
98     if match is None:
99         version = None
100     else:
101         version = match.group("version")
102     return version
103 def _chattr_has_extended_attrs():
104     ver = _chattr_version()
105     if ver is None:
106         return False
107     needed_version = salt.utils.versions.LooseVersion("1.41.12")
108     chattr_version = salt.utils.versions.LooseVersion(ver)
109     return chattr_version &gt; needed_version
110 def gid_to_group(gid):
111     try:
112         gid = int(gid)
113     except ValueError:
114         gid = group_to_gid(gid)
115     if gid == "":
116         return ""
117     try:
118         return grp.getgrgid(gid).gr_name
119     except (KeyError, NameError):
120         return gid
121 def group_to_gid(group):
122     if group is None:
123         return ""
124     try:
125         if isinstance(group, int):
126             return group
127         return grp.getgrnam(group).gr_gid
128     except KeyError:
129         return ""
130 def get_gid(path, follow_symlinks=True):
131     return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
132         "gid", -1
133     )
134 def get_group(path, follow_symlinks=True):
135     return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
136         "group", False
137     )
138 def uid_to_user(uid):
139     try:
140         return pwd.getpwuid(uid).pw_name
141     except (KeyError, NameError):
142         return uid
143 def user_to_uid(user):
144     if user is None:
145         user = salt.utils.user.get_user()
146     try:
147         if isinstance(user, int):
148             return user
149         return pwd.getpwnam(user).pw_uid
150     except KeyError:
151         return ""
152 def get_uid(path, follow_symlinks=True):
153     return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
154         "uid", -1
155     )
156 def get_user(path, follow_symlinks=True):
157     return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
158         "user", False
159     )
160 def get_mode(path, follow_symlinks=True):
161     return stats(os.path.expanduser(path), follow_symlinks=follow_symlinks).get(
162         "mode", ""
163     )
164 def set_mode(path, mode):
165     path = os.path.expanduser(path)
166     mode = str(mode).lstrip("0Oo")
167     if not mode:
168         mode = "0"
169     if not os.path.exists(path):
170         raise CommandExecutionError("{}: File not found".format(path))
171     try:
172         os.chmod(path, int(mode, 8))
173     except Exception:  # pylint: disable=broad-except
174         return "Invalid Mode " + mode
175     return get_mode(path)
176 def lchown(path, user, group):
177     path = os.path.expanduser(path)
178     uid = user_to_uid(user)
179     gid = group_to_gid(group)
180     err = ""
181     if uid == "":
182         if user:
183             err += "User does not exist\n"
184         else:
185             uid = -1
186     if gid == "":
187         if group:
188             err += "Group does not exist\n"
189         else:
190             gid = -1
191     return os.lchown(path, uid, gid)
192 def chown(path, user, group):
193     path = os.path.expanduser(path)
194     uid = user_to_uid(user)
195     gid = group_to_gid(group)
196     err = ""
197     if uid == "":
198         if user:
199             err += "User does not exist\n"
200         else:
201             uid = -1
202     if gid == "":
203         if group:
204             err += "Group does not exist\n"
205         else:
206             gid = -1
207     if not os.path.exists(path):
208         try:
209             return os.lchown(path, uid, gid)
210         except OSError:
211             pass
212         err += "File not found"
213     if err:
214         return err
215     return os.chown(path, uid, gid)
216 def chgrp(path, group):
217     path = os.path.expanduser(path)
218     user = get_user(path)
219     return chown(path, user, group)
220 def _cmp_attrs(path, attrs):
221     if salt.utils.platform.is_aix():
222         return None
223     try:
224         lattrs = lsattr(path).get(path, "")
225     except AttributeError:
226         return None
227     new = set(attrs)
228     old = set(lattrs)
229     if "e" in old:
230         new.add("e")
231     return AttrChanges(
232         added="".join(new - old) or None,
233         removed="".join(old - new) or None,
234     )
235 def lsattr(path):
236     if not salt.utils.path.which("lsattr") or salt.utils.platform.is_aix():
237         return None
238     if not os.path.exists(path):
239         raise SaltInvocationError("File or directory does not exist: " + path)
240     cmd = ["lsattr", path]
241     result = __salt__["cmd.run"](cmd, ignore_retcode=True, python_shell=False)
242     results = {}
243     for line in result.splitlines():
244         if not line.startswith("lsattr: "):
245             attrs, file = line.split(None, 1)
246             if _chattr_has_extended_attrs():
247                 pattern = r"[aAcCdDeijPsStTu]"
248             else:
249                 pattern = r"[acdijstuADST]"
250             results[file] = re.findall(pattern, attrs)
251     return results
252 def chattr(*files, **kwargs):
253     operator = kwargs.pop("operator", None)
254     attributes = kwargs.pop("attributes", None)
255     flags = kwargs.pop("flags", None)
256     version = kwargs.pop("version", None)
257     if (operator is None) or (operator not in ("add", "remove")):
258         raise SaltInvocationError(
259             "Need an operator: 'add' or 'remove' to modify attributes."
260         )
261     if attributes is None:
262         raise SaltInvocationError("Need attributes: [aAcCdDeijPsStTu]")
263     cmd = ["chattr"]
264     if operator == "add":
265         attrs = "+{}".format(attributes)
266     elif operator == "remove":
267         attrs = "-{}".format(attributes)
268     cmd.append(attrs)
269     if flags is not None:
270         cmd.append("-{}".format(flags))
271     if version is not None:
272         cmd.extend(["-v", version])
273     cmd.extend(files)
274     result = __salt__["cmd.run"](cmd, python_shell=False)
275     if bool(result):
276         return False
277     return True
278 def get_sum(path, form="sha256"):
279     path = os.path.expanduser(path)
280     if not os.path.isfile(path):
281         return "File not found"
282     return salt.utils.hashutils.get_hash(path, form, 4096)
283 def get_hash(path, form="sha256", chunk_size=65536):
284     return salt.utils.hashutils.get_hash(os.path.expanduser(path), form, chunk_size)
285 def get_source_sum(
286     file_name="",
287     source="",
288     source_hash=None,
289     source_hash_name=None,
290     saltenv="base",
291     verify_ssl=True,
292 ):
293     def _invalid_source_hash_format():
294         raise CommandExecutionError(
295             "Source hash {} format is invalid. The supported formats are: "
296             "1) a hash, 2) an expression in the format &lt;hash_type&gt;=&lt;hash&gt;, or "
297             "3) either a path to a local file containing hashes, or a URI of "
298             "a remote hash file. Supported protocols for remote hash files "
299             "are: {}. The hash may also not be of a valid length, the "
300             "following are supported hash types and lengths: {}.".format(
301                 source_hash,
302                 ", ".join(salt.utils.files.VALID_PROTOS),
303                 ", ".join(
304                     [
305                         "{} ({})".format(HASHES_REVMAP[x], x)
306                         for x in sorted(HASHES_REVMAP)
307                     ]
308                 ),
309             )
310         )
311     hash_fn = None
312     if os.path.isabs(source_hash):
313         hash_fn = source_hash
314     else:
315         try:
316             proto = urllib.parse.urlparse(source_hash).scheme
317             if proto in salt.utils.files.VALID_PROTOS:
318                 hash_fn = __salt__["cp.cache_file"](
319                     source_hash, saltenv, verify_ssl=verify_ssl
320                 )
321                 if not hash_fn:
322                     raise CommandExecutionError(
323                         "Source hash file {} not found".format(source_hash)
324                     )
325             else:
326                 if proto != "":
327                     _invalid_source_hash_format()
328         except (AttributeError, TypeError):
329             _invalid_source_hash_format()
330     if hash_fn is not None:
331         ret = extract_hash(hash_fn, "", file_name, source, source_hash_name)
332         if ret is None:
333             _invalid_source_hash_format()
334         ret["hsum"] = ret["hsum"].lower()
335         return ret
336     else:
337         ret = {}
338         try:
339             ret["hash_type"], ret["hsum"] = (
340                 x.strip() for x in source_hash.split("=", 1)
341             )
342         except AttributeError:
343             _invalid_source_hash_format()
344         except ValueError:
345             if not re.match("^[{}]+$".format(string.hexdigits), source_hash):
346                 _invalid_source_hash_format()
347             ret["hsum"] = source_hash
348             source_hash_len = len(source_hash)
349             if source_hash_len in HASHES_REVMAP:
350                 ret["hash_type"] = HASHES_REVMAP[source_hash_len]
351             else:
352                 _invalid_source_hash_format()
353         if ret["hash_type"] not in HASHES:
354             raise CommandExecutionError(
355                 "Invalid hash type '{}'. Supported hash types are: {}. "
356                 "Either remove the hash type and simply use '{}' as the "
357                 "source_hash, or change the hash type to a supported type.".format(
358                     ret["hash_type"], ", ".join(HASHES), ret["hsum"]
359                 )
360             )
361         else:
362             hsum_len = len(ret["hsum"])
363             if hsum_len not in HASHES_REVMAP:
364                 _invalid_source_hash_format()
365             elif hsum_len != HASHES[ret["hash_type"]]:
366                 raise CommandExecutionError(
367                     "Invalid length ({}) for hash type '{}'. Either "
368                     "remove the hash type and simply use '{}' as the "
369                     "source_hash, or change the hash type to '{}'".format(
370                         hsum_len,
371                         ret["hash_type"],
372                         ret["hsum"],
373                         HASHES_REVMAP[hsum_len],
374                     )
375                 )
376         ret["hsum"] = ret["hsum"].lower()
377         return ret
378 def check_hash(path, file_hash):
379     path = os.path.expanduser(path)
380     if not isinstance(file_hash, str):
381         raise SaltInvocationError("hash must be a string")
382     for sep in (":", "="):
383         if sep in file_hash:
384             hash_type, hash_value = file_hash.split(sep, 1)
385             break
386     else:
387         hash_value = file_hash
388         hash_len = len(file_hash)
389         hash_type = HASHES_REVMAP.get(hash_len)
390         if hash_type is None:
391             raise SaltInvocationError(
392                 "Hash {} (length: {}) could not be matched to a supported "
393                 "hash type. The supported hash types and lengths are: "
394                 "{}".format(
395                     file_hash,
396                     hash_len,
397                     ", ".join(
398                         [
399                             "{} ({})".format(HASHES_REVMAP[x], x)
400                             for x in sorted(HASHES_REVMAP)
401                         ]
402                     ),
403                 )
404             )
405     return get_hash(path, hash_type) == hash_value
406 def find(path, *args, **kwargs):
407     if "delete" in args:
408         kwargs["delete"] = "f"
409     elif "print" in args:
410         kwargs["print"] = "path"
411     try:
412         finder = salt.utils.find.Finder(kwargs)
413     except ValueError as ex:
414         return "error: {}".format(ex)
415     ret = [
416         item
417         for i in [finder.find(p) for p in glob.glob(os.path.expanduser(path))]
418         for item in i
419     ]
420     ret.sort()
421     return ret
422 def _sed_esc(string, escape_all=False):
423     special_chars = "^.[$()|*+?{"
424     string = string.replace("'", "'\"'\"'").replace("/", "\\/")
425     if escape_all is True:
426         for char in special_chars:
427             string = string.replace(char, "\\" + char)
428     return string
429 def sed(
430     path,
431     before,
432     after,
433     limit="",
434     backup=".bak",
435     options="-r -e",
436     flags="g",
437     escape_all=False,
438     negate_match=False,
439 ):
440     path = os.path.expanduser(path)
441     if not os.path.exists(path):
442         return False
443     before = str(before)
444     after = str(after)
445     before = _sed_esc(before, escape_all)
446     after = _sed_esc(after, escape_all)
447     limit = _sed_esc(limit, escape_all)
448     if sys.platform == "darwin":
449         options = options.replace("-r", "-E")
450     cmd = ["sed"]
451     cmd.append("-i{}".format(backup) if backup else "-i")
452     cmd.extend(salt.utils.args.shlex_split(options))
453     cmd.append(
454         r"{limit}{negate_match}s/{before}/{after}/{flags}".format(
455             limit="/{}/ ".format(limit) if limit else "",
456             negate_match="!" if negate_match else "",
457             before=before,
458             after=after,
459             flags=flags,
460         )
461     )
462     cmd.append(path)
463     return __salt__["cmd.run_all"](cmd, python_shell=False)
464 def sed_contains(path, text, limit="", flags="g"):
465     path = os.path.expanduser(path)
466     if not os.path.exists(path):
467         return False
468     before = _sed_esc(str(text), False)
469     limit = _sed_esc(str(limit), False)
470     options = "-n -r -e"
471     if sys.platform == "darwin":
472         options = options.replace("-r", "-E")
473     cmd = ["sed"]
474     cmd.extend(salt.utils.args.shlex_split(options))
475     cmd.append(
476         r"{limit}s/{before}/$/{flags}".format(
477             limit="/{}/ ".format(limit) if limit else "",
478             before=before,
479             flags="p{}".format(flags),
480         )
481     )
482     cmd.append(path)
483     result = __salt__["cmd.run"](cmd, python_shell=False)
484     return bool(result)
485 def psed(
486     path,
487     before,
488     after,
489     limit="",
490     backup=".bak",
491     flags="gMS",
492     escape_all=False,
493     multi=False,
494 ):
495     path = os.path.expanduser(path)
496     multi = bool(multi)
497     before = str(before)
498     after = str(after)
499     before = _sed_esc(before, escape_all)
500     limit = _sed_esc(limit, escape_all)
501     shutil.copy2(path, "{}{}".format(path, backup))
502     with salt.utils.files.fopen(path, "w") as ofile:
503         with salt.utils.files.fopen("{}{}".format(path, backup), "r") as ifile:
504             if multi is True:
505                 for line in ifile.readline():
506                     ofile.write(
507                         salt.utils.stringutils.to_str(
508                             _psed(
509                                 salt.utils.stringutils.to_unicode(line),
510                                 before,
511                                 after,
512                                 limit,
513                                 flags,
514                             )
515                         )
516                     )
517             else:
518                 ofile.write(
519                     salt.utils.stringutils.to_str(
520                         _psed(
521                             salt.utils.stringutils.to_unicode(ifile.read()),
522                             before,
523                             after,
524                             limit,
525                             flags,
526                         )
527                     )
528                 )
529 RE_FLAG_TABLE = {"I": re.I, "L": re.L, "M": re.M, "S": re.S, "U": re.U, "X": re.X}
530 def _psed(text, before, after, limit, flags):
531     atext = text
532     if limit:
533         limit = re.compile(limit)
534         comps = text.split(limit)
535         atext = "".join(comps[1:])
536     count = 1
537     if "g" in flags:
538         count = 0
539         flags = flags.replace("g", "")
540     aflags = 0
541     for flag in flags:
542         aflags |= RE_FLAG_TABLE[flag]
543     before = re.compile(before, flags=aflags)
544     text = re.sub(before, after, atext, count=count)
545     return text
546 def uncomment(path, regex, char="#", backup=".bak"):
547     return comment_line(path=path, regex=regex, char=char, cmnt=False, backup=backup)
548 def comment(path, regex, char="#", backup=".bak"):
549     return comment_line(path=path, regex=regex, char=char, cmnt=True, backup=backup)
550 def comment_line(path, regex, char="#", cmnt=True, backup=".bak"):
551     r"""
552     Comment or Uncomment a line in a text file.
553     :param path: string
554         The full path to the text file.
555     :param regex: string
556         A regex expression that begins with ``^`` that will find the line you wish
557         to comment. Can be as simple as ``^color =``
558     :param char: string
559         The character used to comment a line in the type of file you're referencing.
560         Default is ``#``
561     :param cmnt: boolean
562         True to comment the line. False to uncomment the line. Default is True.
563     :param backup: string
564         The file extension to give the backup file. Default is ``.bak``
565         Set to False/None to not keep a backup.
566     :return: boolean
567         Returns True if successful, False if not
568     CLI Example:
569     The following example will comment out the ``pcspkr`` line in the
570     ``/etc/modules`` file using the default ``#`` character and create a backup
571     file named ``modules.bak``
572     .. code-block:: bash
573         salt '*' file.comment_line '/etc/modules' '^pcspkr'
574     CLI Example:
575     The following example will uncomment the ``log_level`` setting in ``minion``
576     config file if it is set to either ``warning``, ``info``, or ``debug`` using
577     the ``#`` character and create a backup file named ``minion.bk``
578     .. code-block:: bash
579         salt '*' file.comment_line 'C:\salt\conf\minion' '^log_level: (warning|info|debug)' '#' False '.bk'
580     Return an integer appropriate for use as a flag for the re module from a
581     list of human-readable strings
582     .. code-block:: python
583         &gt;&gt;&gt; _get_flags(['MULTILINE', 'IGNORECASE'])
584         10
585         &gt;&gt;&gt; _get_flags('MULTILINE')
586         8
587         &gt;&gt;&gt; _get_flags(2)
588         2
589     Combine ``flags`` and ``new_flags``
590     Create a temp file and move/copy the contents of ``path`` to the temp file.
591     Return the path to the temp file.
592     path
593         The full path to the file whose contents will be moved/copied to a temp file.
594         Whether it's moved or copied depends on the value of ``preserve_inode``.
595     preserve_inode
596         Preserve the inode of the file, so that any hard links continue to share the
597         inode with the original filename. This works by *copying* the file, reading
598         from the copy, and writing to the file at the original inode. If ``False``, the
599         file will be *moved* rather than copied, and a new file will be written to a
600         new inode, but using the original filename. Hard links will then share an inode
601         with the backup, instead (if using ``backup`` to create a backup copy).
602         Default is ``True``.
603     Expand regular expression to static match.
604     Raise an exception, if there are different amount of specified occurrences in src.
605     Indent the line with the source line.
606     Add line ending
607     Take ``lines`` and insert ``content`` and the correct place. If
608     ``mode`` is ``'delete'`` then delete the ``content`` line instead.
609     Returns a list of modified lines.
610     lines
611         The original file lines to modify.
612     content
613         Content of the line. Allowed to be empty if ``mode='delete'``.
614     match
615         The regex or contents to seek for on the line.
616     mode
617         What to do with the matching line. One of the following options
618         is required:
619         - ensure
620             If ``content`` does not exist, it will be added.
621         - replace
622             If the line already exists, it will be replaced(???? TODO WHAT DOES THIS MEAN?)
623         - delete
624             Delete the line, if found.
625         - insert
626             Insert a line if it does not already exist.
627         .. note::
628             If ``mode=insert`` is used, at least one of the following
629             options must also be defined: ``location``, ``before``, or
630             ``after``. If ``location`` is used, it takes precedence
631             over the other two options
632     location
633         ``start`` or ``end``. Defines where to place the content in the
634         lines. **Note** this option is only used when ``mode='insert`` is
635         specified. If a location is passed in, it takes precedence over
636         both the ``before`` and ``after`` kwargs.
637         - start
638             Place the ``content`` at the beginning of the lines.
639         - end
640             Place the ``content`` at the end of the lines.
641     before
642         Regular expression or an exact, case-sensitive fragment of the
643         line to place the ``content`` before. This option is only used
644         when either ``ensure`` or ``insert`` mode is specified.
645     after
646         Regular expression or an exact, case-sensitive fragment of the
647         line to plaece the ``content`` after. This option is only used
648         when either ``ensure`` or ``insert`` mode is specified.
649     indent
650         Keep indentation to match the previous line. Ignored when
651         ``mode='delete'`` is specified.
652     .. versionadded:: 2015.8.0
653     Line-focused editing of a file.
654     .. note::
655         ``file.line`` exists for historic reasons, and is not
656         generally recommended. It has a lot of quirks.  You may find
657         ``file.replace`` to be more suitable.
658     ``file.line`` is most useful if you have single lines in a file
659     (potentially a config file) that you would like to manage. It can
660     remove, add, and replace a single line at a time.
661     path
662         Filesystem path to the file to be edited.
663     content
664         Content of the line. Allowed to be empty if ``mode='delete'``.
665     match
666         Match the target line for an action by
667         a fragment of a string or regular expression.
668         If neither ``before`` nor ``after`` are provided, and ``match``
669         is also ``None``, match falls back to the ``content`` value.
670     mode
671         Defines how to edit a line. One of the following options is
672         required:
673         - ensure
674             If line does not exist, it will be added. If ``before``
675             and ``after`` are specified either zero lines, or lines
676             that contain the ``content`` line are allowed to be in between
677             ``before`` and ``after``. If there are lines, and none of
678             them match then it will produce an error.
679         - replace
680             If line already exists, the entire line will be replaced.
681         - delete
682             Delete the line, if found.
683         - insert
684             Nearly identical to ``ensure``. If a line does not exist,
685             it will be added.
686             The differences are that multiple (and non-matching) lines are
687             alloweed between ``before`` and ``after``, if they are
688             specified. The line will always be inserted right before
689             ``before``. ``insert`` also allows the use of ``location`` to
690             specify that the line should be added at the beginning or end of
691             the file.
692         .. note::
693             If ``mode='insert'`` is used, at least one of ``location``,
694             ``before``, or ``after`` is required.  If ``location`` is used,
695             ``before`` and ``after`` are ignored.
696     location
697         In ``mode='insert'`` only, whether to place the ``content`` at the
698         beginning or end of a the file. If ``location`` is provided,
699         ``before`` and ``after`` are ignored. Valid locations:
700         - start
701             Place the content at the beginning of the file.
702         - end
703             Place the content at the end of the file.
704     before
705         Regular expression or an exact case-sensitive fragment of the string.
706         Will be tried as **both** a regex **and** a part of the line.  Must
707         match **exactly** one line in the file.  This value is only used in
708         ``ensure`` and ``insert`` modes. The ``content`` will be inserted just
709         before this line, with matching indentation unless ``indent=False``.
710     after
711         Regular expression or an exact case-sensitive fragment of the string.
712         Will be tried as **both** a regex **and** a part of the line.  Must
713         match **exactly** one line in the file.  This value is only used in
714         ``ensure`` and ``insert`` modes. The ``content`` will be inserted
715         directly after this line, unless ``before`` is also provided. If
716         ``before`` is not provided, indentation will match this line, unless
717         ``indent=False``.
718     show_changes
719         Output a unified diff of the old file and the new file.
720         If ``False`` return a boolean if any changes were made.
721         Default is ``True``
722         .. note::
723             Using this option will store two copies of the file in-memory
724             (the original version and the edited version) in order to generate the diff.
725     backup
726         Create a backup of the original file with the extension:
727         "Year-Month-Day-Hour-Minutes-Seconds".
728     quiet
729         Do not raise any exceptions. E.g. ignore the fact that the file that is
730         tried to be edited does not exist and nothing really happened.
731     indent
732         Keep indentation with the previous line. This option is not considered when
733         the ``delete`` mode is specified. Default is ``True``
734     CLI Example:
735     .. code-block:: bash
736         salt '*' file.line /etc/nsswitch.conf "networks:\tfiles dns" after="hosts:.*?" mode='ensure'
737     .. note::
738         If an equal sign (``=``) appears in an argument to a Salt command, it is
739         interpreted as a keyword argument in the format of ``key=val``. That
740         processing can be bypassed in order to pass an equal sign through to the
741         remote shell command by manually specifying the kwarg:
742         .. code-block:: bash
743             salt '*' file.line /path/to/file content="CREATEMAIL_SPOOL=no" match="CREATE_MAIL_SPOOL=yes" mode="replace"
744     **Examples:**
745     Here's a simple config file.
746     .. code-block:: ini
747         [some_config]
748         here=False
749         away=True
750         goodybe=away
751     .. code-block:: bash
752         salt \\* file.line /some/file.conf mode=delete match=away
753     This will produce:
754     .. code-block:: ini
755         [some_config]
756         here=False
757         away=True
758         goodbye=away
759     If that command is executed 2 more times, this will be the result:
760     .. code-block:: ini
761         [some_config]
762         here=False
763     If we reset the file to its original state and run
764     .. code-block:: bash
765         salt \\* file.line /some/file.conf mode=replace match=away content=here
766     Three passes will this state will result in this file:
767     .. code-block:: ini
768         [some_config]
769         here
770         here=False
771         here
772         here
773     Each pass replacing the first line found.
774     Given this file:
775     .. code-block:: text
776         insert after me
777         something
778         insert before me
779     The following command
780     .. code-block:: bash
781         salt \\* file.line /some/file.txt mode=insert after="insert after me" before="insert before me" content=thrice
782     If that command is executed 3 times, the result will be:
783     .. code-block:: text
784         insert after me
785         something
786         thrice
787         thrice
788         thrice
789         insert before me
790     If the mode is ``ensure`` instead, it will fail each time. To succeed, we
791     need to remove the incorrect line between before and after:
792     .. code-block:: text
793         insert after me
794         insert before me
795     With an ensure mode, this will insert ``thrice`` the first time and
796     make no changes for subsequent calls. For something simple this is
797     fine, but if you have instead blocks like this:
798     .. code-block:: text
799         Begin SomeBlock
800             foo = bar
801         End
802         Begin AnotherBlock
803             another = value
804         End
805     And you try to use ensure this way:
806     .. code-block:: bash
807         salt \\* file.line  /tmp/fun.txt mode="ensure" content="this = should be my content" after="Begin SomeBlock" before="End"
808     This will fail because there are multiple ``End`` lines. Without that
809     problem, it still would fail because there is a non-matching line,
810     ``foo = bar``. Ensure **only** allows either zero, or the matching
811     line present to be present in between ``before`` and ``after``.
812     .. versionadded:: 0.17.0
813     Replace occurrences of a pattern in a file. If ``show_changes`` is
814     ``True``, then a diff of what changed will be returned, otherwise a
815     ``True`` will be returned when changes are made, and ``False`` when
816     no changes are made.
817     This is a pure Python implementation that wraps Python's :py:func:`~re.sub`.
818     path
819         Filesystem path to the file to be edited. If a symlink is specified, it
820         will be resolved to its target.
821     pattern
822         A regular expression, to be matched using Python's
823         :py:func:`~re.search`.
824     repl
825         The replacement text
826     count: 0
827         Maximum number of pattern occurrences to be replaced. If count is a
828         positive integer ``n``, only ``n`` occurrences will be replaced,
829         otherwise all occurrences will be replaced.
830     flags (list or int)
831         A list of flags defined in the ``re`` module documentation from the
832         Python standard library. Each list item should be a string that will
833         correlate to the human-friendly flag name. E.g., ``['IGNORECASE',
834         'MULTILINE']``. Optionally, ``flags`` may be an int, with a value
835         corresponding to the XOR (``|``) of all the desired flags. Defaults to
836         8 (which supports 'MULTILINE').
837     bufsize (int or str)
838         How much of the file to buffer into memory at once. The
839         default value ``1`` processes one line at a time. The special value
840         ``file`` may be specified which will read the entire file into memory
841         before processing.
842     append_if_not_found: False
843         .. versionadded:: 2014.7.0
844         If set to ``True``, and pattern is not found, then the content will be
845         appended to the file.
846     prepend_if_not_found: False
847         .. versionadded:: 2014.7.0
848         If set to ``True`` and pattern is not found, then the content will be
849         prepended to the file.
850     not_found_content
851         .. versionadded:: 2014.7.0
852         Content to use for append/prepend if not found. If None (default), uses
853         ``repl``. Useful when ``repl`` uses references to group in pattern.
854     backup: .bak
855         The file extension to use for a backup of the file before editing. Set
856         to ``False`` to skip making a backup.
857     dry_run: False
858         If set to ``True``, no changes will be made to the file, the function
859         will just return the changes that would have been made (or a
860         ``True``/``False`` value if ``show_changes`` is set to ``False``).
861     search_only: False
862         If set to true, this no changes will be performed on the file, and this
863         function will simply return ``True`` if the pattern was matched, and
864         ``False`` if not.
865     show_changes: True
866         If ``True``, return a diff of changes made. Otherwise, return ``True``
867         if changes were made, and ``False`` if not.
868         .. note::
869             Using this option will store two copies of the file in memory (the
870             original version and the edited version) in order to generate the
871             diff. This may not normally be a concern, but could impact
872             performance if used with large files.
873     ignore_if_missing: False
874         .. versionadded:: 2015.8.0
875         If set to ``True``, this function will simply return ``False``
876         if the file doesn't exist. Otherwise, an error will be thrown.
877     preserve_inode: True
878         .. versionadded:: 2015.8.0
879         Preserve the inode of the file, so that any hard links continue to
880         share the inode with the original filename. This works by *copying* the
881         file, reading from the copy, and writing to the file at the original
882         inode. If ``False``, the file will be *moved* rather than copied, and a
883         new file will be written to a new inode, but using the original
884         filename. Hard links will then share an inode with the backup, instead
885         (if using ``backup`` to create a backup copy).
886     backslash_literal: False
887         .. versionadded:: 2016.11.7
888         Interpret backslashes as literal backslashes for the repl and not
889         escape characters.  This will help when using append/prepend so that
890         the backslashes are not interpreted for the repl on the second run of
891         the state.
892     If an equal sign (``=``) appears in an argument to a Salt command it is
893     interpreted as a keyword argument in the format ``key=val``. That
894     processing can be bypassed in order to pass an equal sign through to the
895     remote shell command by manually specifying the kwarg:
896     .. code-block:: bash
897         salt '*' file.replace /path/to/file pattern='=' repl=':'
898         salt '*' file.replace /path/to/file pattern="bind-address\\s*=" repl='bind-address:'
899     CLI Examples:
900     .. code-block:: bash
901         salt '*' file.replace /etc/httpd/httpd.conf pattern='LogLevel warn' repl='LogLevel info'
902         salt '*' file.replace /some/file pattern='before' repl='after' flags='[MULTILINE, IGNORECASE]'
903     .. versionadded:: 2014.1.0
904     Replace content of a text block in a file, delimited by line markers
905     A block of content delimited by comments can help you manage several lines
906     entries without worrying about old entries removal.
907     .. note::
908         This function will store two copies of the file in-memory (the original
909         version and the edited version) in order to detect changes and only
910         edit the targeted file if necessary.
911     path
912         Filesystem path to the file to be edited
913     marker_start
914         The line content identifying a line as the start of the content block.
915         Note that the whole line containing this marker will be considered, so
916         whitespace or extra content before or after the marker is included in
917         final output
918     marker_end
919         The line content identifying the end of the content block. As of
920         versions 2017.7.5 and 2018.3.1, everything up to the text matching the
921         marker will be replaced, so it's important to ensure that your marker
922         includes the beginning of the text you wish to replace.
923     content
924         The content to be used between the two lines identified by marker_start
925         and marker_stop.
926     append_if_not_found: False
927         If markers are not found and set to ``True`` then, the markers and
928         content will be appended to the file.
929     prepend_if_not_found: False
930         If markers are not found and set to ``True`` then, the markers and
931         content will be prepended to the file.
932     insert_before_match
933         If markers are not found, this parameter can be set to a regex which will
934         insert the block before the first found occurrence in the file.
935         .. versionadded:: 3001
936     insert_after_match
937         If markers are not found, this parameter can be set to a regex which will
938         insert the block after the first found occurrence in the file.
939         .. versionadded:: 3001
940     backup
941         The file extension to use for a backup of the file if any edit is made.
942         Set to ``False`` to skip making a backup.
943     dry_run: False
944         If ``True``, do not make any edits to the file and simply return the
945         changes that *would* be made.
946     show_changes: True
947         Controls how changes are presented. If ``True``, this function will
948         return a unified diff of the changes made. If False, then it will
949         return a boolean (``True`` if any changes were made, otherwise
950         ``False``).
951     append_newline: False
952         Controls whether or not a newline is appended to the content block. If
953         the value of this argument is ``True`` then a newline will be added to
954         the content block. If it is ``False``, then a newline will *not* be
955         added to the content block. If it is ``None`` then a newline will only
956         be added to the content block if it does not already end in a newline.
957         .. versionadded:: 2016.3.4
958         .. versionchanged:: 2017.7.5,2018.3.1
959             New behavior added when value is ``None``.
960         .. versionchanged:: 2019.2.0
961             The default value of this argument will change to ``None`` to match
962             the behavior of the :py:func:`file.blockreplace state
963             &lt;salt.states.file.blockreplace&gt;`
964     CLI Example:
965     .. code-block:: bash
966         salt '*' file.blockreplace /etc/hosts '#-- start managed zone foobar : DO NOT EDIT --' \\
967         '#-- end managed zone foobar --' $'10.0.1.1 foo.foobar\\n10.0.1.2 bar.foobar' True
968     .. versionadded:: 0.17.0
969     Search for occurrences of a pattern in a file
970     Except for multiline, params are identical to
971     :py:func:`~salt.modules.file.replace`.
972     multiline
973         If true, inserts 'MULTILINE' into ``flags`` and sets ``bufsize`` to
974         'file'.
975         .. versionadded:: 2015.8.0
976     CLI Example:
977     .. code-block:: bash
978         salt '*' file.search /etc/crontab 'mymaintenance.sh'
979     .. versionadded:: 0.10.4
980     Apply a patch to a file or directory.
981     Equivalent to:
982     .. code-block:: bash
983         patch &lt;options&gt; -i &lt;patchfile&gt; &lt;originalfile&gt;
984     Or, when a directory is patched:
985     .. code-block:: bash
986         patch &lt;options&gt; -i &lt;patchfile&gt; -d &lt;originalfile&gt; -p0
987     originalfile
988         The full path to the file or directory to be patched
989     patchfile
990         A patch file to apply to ``originalfile``
991     options
992         Options to pass to patch.
993     .. note::
994         Windows now supports using patch as of 3004.
995         In order to use this function in Windows, please install the
996         patch binary through your own means and ensure it's found
997         in the system Path. If installing through git-for-windows,
998         please select the optional "Use Git and optional Unix tools
999         from the Command Prompt" option when installing Git.
1000     CLI Example:
1001     .. code-block:: bash
1002         salt '*' file.patch /opt/file.txt /tmp/file.txt.patch
1003         salt '*' file.patch C:\\file1.txt C:\\file3.patch
1004     .. deprecated:: 0.17.0
1005        Use :func:`search` instead.
1006     Return ``True`` if the file at ``path`` contains ``text``
1007     CLI Example:
1008     .. code-block:: bash
1009         salt '*' file.contains /etc/crontab 'mymaintenance.sh'
1010     .. deprecated:: 0.17.0
1011        Use :func:`search` instead.
1012     Return True if the given regular expression matches on any line in the text
1013     of a given file.
1014     If the lchar argument (leading char) is specified, it
1015     will strip `lchar` from the left side of each line before trying to match
1016     CLI Example:
1017     .. code-block:: bash
1018         salt '*' file.contains_regex /etc/crontab
1019     .. deprecated:: 0.17.0
1020        Use :func:`search` instead.
1021     Return ``True`` if the given glob matches a string in the named file
1022     CLI Example:
1023     .. code-block:: bash
1024         salt '*' file.contains_glob /etc/foobar '*cheese*'
1025     .. versionadded:: 0.9.5
1026     Append text to the end of a file
1027     path
1028         path to file
1029     `*args`
1030         strings to append to file
1031     CLI Example:
1032     .. code-block:: bash
1033         salt '*' file.append /etc/motd \\
1034                 "With all thine offerings thou shalt offer salt." \\
1035                 "Salt is what makes things taste bad when it isn't in them."
1036     .. admonition:: Attention
1037         If you need to pass a string to append and that string contains
1038         an equal sign, you **must** include the argument name, args.
1039         For example:
1040         .. code-block:: bash
1041             salt '*' file.append /etc/motd args='cheese=spam'
1042             salt '*' file.append /etc/motd args="['cheese=spam','spam=cheese']"
1043     .. versionadded:: 2014.7.0
1044     Prepend text to the beginning of a file
1045     path
1046         path to file
1047     `*args`
1048         strings to prepend to the file
1049     CLI Example:
1050     .. code-block:: bash
1051         salt '*' file.prepend /etc/motd \\
1052                 "With all thine offerings thou shalt offer salt." \\
1053                 "Salt is what makes things taste bad when it isn't in them."
1054     .. admonition:: Attention
1055         If you need to pass a string to append and that string contains
1056         an equal sign, you **must** include the argument name, args.
1057         For example:
1058         .. code-block:: bash
1059             salt '*' file.prepend /etc/motd args='cheese=spam'
1060             salt '*' file.prepend /etc/motd args="['cheese=spam','spam=cheese']"
1061     .. versionadded:: 2014.7.0
1062     Write text to a file, overwriting any existing contents.
1063     path
1064         path to file
1065     `*args`
1066         strings to write to the file
1067     CLI Example:
1068     .. code-block:: bash
1069         salt '*' file.write /etc/motd \\
1070                 "With all thine offerings thou shalt offer salt."
1071     .. admonition:: Attention
1072         If you need to pass a string to append and that string contains
1073         an equal sign, you **must** include the argument name, args.
1074         For example:
1075         .. code-block:: bash
1076             salt '*' file.write /etc/motd args='cheese=spam'
1077             salt '*' file.write /etc/motd args="['cheese=spam','spam=cheese']"
1078     .. versionadded:: 0.9.5
1079     Just like the ``touch`` command, create a file if it doesn't exist or
1080     simply update the atime and mtime if it already does.
1081     atime:
1082         Access time in Unix epoch time
1083     mtime:
1084         Last modification in Unix epoch time
1085     CLI Example:
1086     .. code-block:: bash
1087         salt '*' file.touch /var/log/emptyfile
1088     .. versionadded:: 2014.1.0
1089     Seek to a position on a file and read it
1090     path
1091         path to file
1092     seek
1093         amount to read at once
1094     offset
1095         offset to start into the file
1096     CLI Example:
1097     .. code-block:: bash
1098         salt '*' file.seek_read /path/to/file 4096 0
1099     .. versionadded:: 2014.1.0
1100     Seek to a position on a file and write to it
1101     path
1102         path to file
1103     data
1104         data to write to file
1105     offset
1106         position in file to start writing
1107     CLI Example:
1108     .. code-block:: bash
1109         salt '*' file.seek_write /path/to/file 'some data' 4096
1110     .. versionadded:: 2014.1.0
1111     Seek to a position on a file and delete everything after that point
1112     path
1113         path to file
1114     length
1115         offset into file to truncate
1116     CLI Example:
1117     .. code-block:: bash
1118         salt '*' file.truncate /path/to/file 512
1119     .. versionadded:: 2014.1.0
1120     Create a hard link to a file
1121     CLI Example:
1122     .. code-block:: bash
1123         salt '*' file.link /path/to/file /path/to/link
1124     Check if the path is a hard link by verifying that the number of links
1125     is larger than 1
1126     CLI Example:
1127     .. code-block:: bash
1128        salt '*' file.is_hardlink /path/to/link
1129     Check if the path is a symbolic link
1130     CLI Example:
1131     .. code-block:: bash
1132        salt '*' file.is_link /path/to/link
1133     Create a symbolic link (symlink, soft link) to a file
1134     Args:
1135         src (str): The path to a file or directory
1136         path (str): The path to the link. Must be an absolute path
1137         force (bool):
1138             Overwrite an existing symlink with the same name
1139             .. versionadded:: 3005
1140     Returns:
1141         bool: True if successful, otherwise False
1142     CLI Example:
1143     .. code-block:: bash
1144         salt '*' file.symlink /path/to/file /path/to/link
1145     Rename a file or directory
1146     CLI Example:
1147     .. code-block:: bash
1148         salt '*' file.rename /path/to/src /path/to/dst
1149     Copy a file or directory from source to dst
1150     In order to copy a directory, the recurse flag is required, and
1151     will by default overwrite files in the destination with the same path,
1152     and retain all other existing files. (similar to cp -r on unix)
1153     remove_existing will remove all files in the target directory,
1154     and then copy files from the source.
1155     .. note::
1156         The copy function accepts paths that are local to the Salt minion.
1157         This function does not support salt://, http://, or the other
1158         additional file paths that are supported by :mod:`states.file.managed
1159         &lt;salt.states.file.managed&gt;` and :mod:`states.file.recurse
1160         &lt;salt.states.file.recurse&gt;`.
1161     CLI Example:
1162     .. code-block:: bash
1163         salt '*' file.copy /path/to/src /path/to/dst
1164         salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True
1165         salt '*' file.copy /path/to/src_dir /path/to/dst_dir recurse=True remove_existing=True
1166     .. versionadded:: 2014.1.0
1167     Returns the lstat attributes for the given file or dir. Does not support
1168     symbolic links.
1169     CLI Example:
1170     .. code-block:: bash
1171         salt '*' file.lstat /path/to/file
1172     .. versionadded:: 2014.1.0
1173     Test whether the Salt process has the specified access to the file. One of
1174     the following modes must be specified:
1175     .. code-block:: text
1176         f: Test the existence of the path
1177         r: Test the readability of the path
1178         w: Test the writability of the path
1179         x: Test whether the path can be executed
1180     CLI Example:
1181     .. code-block:: bash
1182         salt '*' file.access /path/to/file f
1183         salt '*' file.access /path/to/file x
1184     .. versionadded:: 2017.7.0
1185     Return the content of the file.
1186     :param bool binary:
1187         Whether to read and return binary data
1188     CLI Example:
1189     .. code-block:: bash
1190         salt '*' file.read /path/to/file
1191     .. versionadded:: 2014.1.0
1192     Return the path that a symlink points to
1193     Args:
1194         path (str):
1195             The path to the symlink
1196         canonicalize (bool):
1197             Get the canonical path eliminating any symbolic links encountered in
1198             the path
1199     Returns:
1200         str: The path that the symlink points to
1201     Raises:
1202         SaltInvocationError: path is not absolute
1203         SaltInvocationError: path is not a link
1204         CommandExecutionError: error reading the symbolic link
1205     CLI Example:
1206     .. code-block:: bash
1207         salt '*' file.readlink /path/to/link
1208     .. versionadded:: 2014.1.0
1209     Return a list containing the contents of a directory
1210     CLI Example:
1211     .. code-block:: bash
1212         salt '*' file.readdir /path/to/dir/
1213     .. versionadded:: 2014.1.0
1214     Perform a statvfs call against the filesystem that the file resides on
1215     CLI Example:
1216     .. code-block:: bash
1217         salt '*' file.statvfs /path/to/file
1218     Return a dict containing the stats for a given file
1219     CLI Example:
1220     .. code-block:: bash
1221         salt '*' file.stats /etc/passwd
1222     .. versionadded:: 2014.1.0
1223     Remove the specified directory. Fails if a directory is not empty.
1224     CLI Example:
1225     .. code-block:: bash
1226         salt '*' file.rmdir /tmp/foo/
1227     Remove the named file. If a directory is supplied, it will be recursively
1228     deleted.
1229     CLI Example:
1230     .. code-block:: bash
1231         salt '*' file.remove /tmp/foo
1232     .. versionchanged:: 3000
1233         The method now works on all types of file system entries, not just
1234         files, directories and symlinks.
1235     Tests to see if path is a valid directory.  Returns True/False.
1236     CLI Example:
1237     .. code-block:: bash
1238         salt '*' file.directory_exists /etc
1239     Tests to see if path is a valid file.  Returns True/False.
1240     CLI Example:
1241     .. code-block:: bash
1242         salt '*' file.file_exists /etc/passwd
1243     Tests to see if path after expansion is a valid path (file or directory).
1244     Expansion allows usage of ? * and character ranges []. Tilde expansion
1245     is not supported. Returns True/False.
1246     .. versionadded:: 2014.7.0
1247     CLI Example:
1248     .. code-block:: bash
1249         salt '*' file.path_exists_glob /etc/pam*/pass*
1250     Reset the SELinux context on a given path
1251     CLI Example:
1252     .. code-block:: bash
1253          salt '*' file.restorecon /home/user/.ssh/authorized_keys
1254     Get an SELinux context from a given path
1255     CLI Example:
1256     .. code-block:: bash
1257         salt '*' file.get_selinux_context /etc/hosts
1258     .. versionchanged:: 3001
1259         Added persist option
1260     Set a specific SELinux label on a given path
1261     CLI Example:
1262     .. code-block:: bash
1263         salt '*' file.set_selinux_context path &lt;user&gt; &lt;role&gt; &lt;type&gt; &lt;range&gt;
1264         salt '*' file.set_selinux_context /etc/yum.repos.d/epel.repo system_u object_r system_conf_t s0
1265     Check the source list and return the source to use
1266     CLI Example:
1267     .. code-block:: bash
1268         salt '*' file.source_list salt://http/httpd.conf '{hash_type: 'md5', 'hsum': &lt;md5sum&gt;}' base
1269     """
1270     contextkey = "{}_|-{}_|-{}".format(source, source_hash, saltenv)
1271     if contextkey in __context__:
1272         return __context__[contextkey]
1273     if isinstance(source, list):
1274         mfiles = [(f, saltenv) for f in __salt__["cp.list_master"](saltenv)]
1275         mdirs = [(d, saltenv) for d in __salt__["cp.list_master_dirs"](saltenv)]
1276         for single in source:
1277             if isinstance(single, dict):
1278                 single = next(iter(single))
1279             path, senv = salt.utils.url.parse(single)
1280             if senv:
1281                 mfiles += [(f, senv) for f in __salt__["cp.list_master"](senv)]
1282                 mdirs += [(d, senv) for d in __salt__["cp.list_master_dirs"](senv)]
1283         ret = None
1284         for single in source:
1285             if isinstance(single, dict):
1286                 if len(single) != 1:
1287                     continue
1288                 single_src = next(iter(single))
1289                 single_hash = single[single_src] if single[single_src] else source_hash
1290                 urlparsed_single_src = urllib.parse.urlparse(single_src)
1291                 if salt.utils.platform.is_windows():
1292                     if urlparsed_single_src.scheme.lower() in string.ascii_lowercase:
1293                         urlparsed_single_src = urllib.parse.urlparse(
1294                             "file://" + single_src
1295                         )
1296                 proto = urlparsed_single_src.scheme
1297                 if proto == "salt":
1298                     path, senv = salt.utils.url.parse(single_src)
1299                     if not senv:
1300                         senv = saltenv
1301                     if (path, saltenv) in mfiles or (path, saltenv) in mdirs:
1302                         ret = (single_src, single_hash)
1303                         break
1304                 elif proto.startswith("http") or proto == "ftp":
1305                     query_res = salt.utils.http.query(
1306                         single_src, method="HEAD", decode_body=False
1307                     )
1308                     if "error" not in query_res:
1309                         ret = (single_src, single_hash)
1310                         break
1311                 elif proto == "file" and (
1312                     os.path.exists(urlparsed_single_src.netloc)
1313                     or os.path.exists(urlparsed_single_src.path)
1314                     or os.path.exists(
1315                         os.path.join(
1316                             urlparsed_single_src.netloc, urlparsed_single_src.path
1317                         )
1318                     )
1319                 ):
1320                     ret = (single_src, single_hash)
1321                     break
1322                 elif single_src.startswith(os.sep) and os.path.exists(single_src):
1323                     ret = (single_src, single_hash)
1324                     break
1325             elif isinstance(single, str):
1326                 path, senv = salt.utils.url.parse(single)
1327                 if not senv:
1328                     senv = saltenv
1329                 if (path, senv) in mfiles or (path, senv) in mdirs:
1330                     ret = (single, source_hash)
1331                     break
1332                 urlparsed_src = urllib.parse.urlparse(single)
1333                 if salt.utils.platform.is_windows():
1334                     if urlparsed_src.scheme.lower() in string.ascii_lowercase:
1335                         urlparsed_src = urllib.parse.urlparse("file://" + single)
1336                 proto = urlparsed_src.scheme
1337                 if proto == "file" and (
1338                     os.path.exists(urlparsed_src.netloc)
1339                     or os.path.exists(urlparsed_src.path)
1340                     or os.path.exists(
1341                         os.path.join(urlparsed_src.netloc, urlparsed_src.path)
1342                     )
1343                 ):
1344                     ret = (single, source_hash)
1345                     break
1346                 elif proto.startswith("http") or proto == "ftp":
1347                     query_res = salt.utils.http.query(
1348                         single, method="HEAD", decode_body=False
1349                     )
1350                     if "error" not in query_res:
1351                         ret = (single, source_hash)
1352                         break
1353                 elif single.startswith(os.sep) and os.path.exists(single):
1354                     ret = (single, source_hash)
1355                     break
1356         if ret is None:
1357             raise CommandExecutionError("none of the specified sources were found")
1358     else:
1359         ret = (source, source_hash)
1360     __context__[contextkey] = ret
1361     return ret
1362 def apply_template_on_contents(contents, template, context, defaults, saltenv):
1363     if template in salt.utils.templates.TEMPLATE_REGISTRY:
1364         context_dict = defaults if defaults else {}
1365         if context:
1366             context_dict.update(context)
1367         contents = salt.utils.templates.TEMPLATE_REGISTRY[template](
1368             contents,
1369             from_str=True,
1370             to_str=True,
1371             context=context_dict,
1372             saltenv=saltenv,
1373             grains=__opts__["grains"],
1374             pillar=__pillar__,
1375             salt=__salt__,
1376             opts=__opts__,
1377         )["data"]
1378         if isinstance(contents, bytes):
1379             contents = contents.decode("utf-8")
1380     else:
1381         ret = {}
1382         ret["result"] = False
1383         ret["comment"] = "Specified template format {} is not supported".format(
1384             template
1385         )
1386         return ret
1387     return contents
1388 def get_managed(
1389     name,
1390     template,
1391     source,
1392     source_hash,
1393     source_hash_name,
1394     user,
1395     group,
1396     mode,
1397     attrs,
1398     saltenv,
1399     context,
1400     defaults,
1401     skip_verify=False,
1402     verify_ssl=True,
1403     use_etag=False,
1404     **kwargs
1405 ):
1406     sfn = ""
1407     source_sum = {}
1408     def _get_local_file_source_sum(path):
1409         return {"hsum": get_hash(path, form="sha256"), "hash_type": "sha256"}
1410     if source:
1411         urlparsed_source = urllib.parse.urlparse(source)
1412         if urlparsed_source.scheme in salt.utils.files.VALID_PROTOS:
1413             parsed_scheme = urlparsed_source.scheme
1414         else:
1415             parsed_scheme = ""
1416         parsed_path = os.path.join(
1417             urlparsed_source.netloc, urlparsed_source.path
1418         ).rstrip(os.sep)
1419         unix_local_source = parsed_scheme in ("file", "")
1420         if parsed_scheme == "":
1421             parsed_path = sfn = source
1422             if not os.path.exists(sfn):
1423                 msg = "Local file source {} does not exist".format(sfn)
1424                 return "", {}, msg
1425         elif parsed_scheme == "file":
1426             sfn = parsed_path
1427             if not os.path.exists(sfn):
1428                 msg = "Local file source {} does not exist".format(sfn)
1429                 return "", {}, msg
1430         if parsed_scheme and parsed_scheme.lower() in string.ascii_lowercase:
1431             parsed_path = ":".join([parsed_scheme, parsed_path])
1432             parsed_scheme = "file"
1433         if parsed_scheme == "salt":
1434             source_sum = __salt__["cp.hash_file"](source, saltenv)
1435             if not source_sum:
1436                 return (
1437                     "",
1438                     {},
1439                     "Source file {} not found in saltenv '{}'".format(source, saltenv),
1440                 )
1441         elif not source_hash and unix_local_source:
1442             source_sum = _get_local_file_source_sum(parsed_path)
1443         elif not source_hash and source.startswith(os.sep):
1444             source_sum = _get_local_file_source_sum(source)
1445         else:
1446             if not skip_verify:
1447                 if source_hash:
1448                     try:
1449                         source_sum = get_source_sum(
1450                             name,
1451                             source,
1452                             source_hash,
1453                             source_hash_name,
1454                             saltenv,
1455                             verify_ssl=verify_ssl,
1456                         )
1457                     except CommandExecutionError as exc:
1458                         return "", {}, exc.strerror
1459                 elif not use_etag:
1460                     msg = (
1461                         "Unable to verify upstream hash of source file {}, "
1462                         "please set source_hash or set skip_verify to True".format(
1463                             salt.utils.url.redact_http_basic_auth(source)
1464                         )
1465                     )
1466                     return "", {}, msg
1467     if source and (template or parsed_scheme in salt.utils.files.REMOTE_PROTOS):
1468         cache_refetch = False
1469         cached_dest = __salt__["cp.is_cached"](source, saltenv)
1470         if cached_dest and (source_hash or skip_verify or use_etag):
1471             htype = source_sum.get("hash_type", "sha256")
1472             cached_sum = get_hash(cached_dest, form=htype)
1473             if skip_verify:
1474                 sfn = cached_dest
1475                 source_sum = {"hsum": cached_sum, "hash_type": htype}
1476             elif use_etag or cached_sum != source_sum.get(
1477                 "hsum", __opts__["hash_type"]
1478             ):
1479                 cache_refetch = True
1480             else:
1481                 sfn = cached_dest
1482         if not sfn or cache_refetch:
1483             try:
1484                 sfn = __salt__["cp.cache_file"](
1485                     source,
1486                     saltenv,
1487                     source_hash=source_sum.get("hsum"),
1488                     verify_ssl=verify_ssl,
1489                     use_etag=use_etag,
1490                 )
1491             except Exception as exc:  # pylint: disable=broad-except
1492                 _source = salt.utils.url.redact_http_basic_auth(source)
1493                 return "", {}, "Failed to cache {}: {}".format(_source, exc)
1494         if not sfn or not os.path.exists(sfn):
1495             _source = salt.utils.url.redact_http_basic_auth(source)
1496             return sfn, {}, "Source file '{}' not found".format(_source)
1497         if sfn == name:
1498             raise SaltInvocationError("Source file cannot be the same as destination")
1499         if template:
1500             if template in salt.utils.templates.TEMPLATE_REGISTRY:
1501                 context_dict = defaults if defaults else {}
1502                 if context:
1503                     context_dict.update(context)
1504                 data = salt.utils.templates.TEMPLATE_REGISTRY[template](
1505                     sfn,
1506                     name=name,
1507                     source=source,
1508                     user=user,
1509                     group=group,
1510                     mode=mode,
1511                     attrs=attrs,
1512                     saltenv=saltenv,
1513                     context=context_dict,
1514                     salt=__salt__,
1515                     pillar=__pillar__,
1516                     grains=__opts__["grains"],
1517                     opts=__opts__,
1518                     **kwargs
1519                 )
1520             else:
1521                 return (
1522                     sfn,
1523                     {},
1524                     "Specified template format {} is not supported".format(template),
1525                 )
1526             if data["result"]:
1527                 sfn = data["data"]
1528                 hsum = get_hash(sfn, form="sha256")
1529                 source_sum = {"hash_type": "sha256", "hsum": hsum}
1530             else:
1531                 __clean_tmp(sfn)
1532                 return sfn, {}, data["data"]
1533     return sfn, source_sum, ""
1534 def extract_hash(
1535     hash_fn, hash_type="sha256", file_name="", source="", source_hash_name=None
1536 ):
1537     hash_len = HASHES.get(hash_type)
1538     if hash_len is None:
1539         if hash_type:
1540             log.warning(
1541                 "file.extract_hash: Unsupported hash_type '%s', falling "
1542                 "back to matching any supported hash_type",
1543                 hash_type,
1544             )
1545             hash_type = ""
1546         hash_len_expr = "{},{}".format(min(HASHES_REVMAP), max(HASHES_REVMAP))
1547     else:
1548         hash_len_expr = str(hash_len)
1549     filename_separators = string.whitespace + r"\/*"
1550     if source_hash_name:
1551         if not isinstance(source_hash_name, str):
1552             source_hash_name = str(source_hash_name)
1553         source_hash_name_idx = (len(source_hash_name) + 1) * -1
1554         log.debug(
1555             "file.extract_hash: Extracting %s hash for file matching "
1556             "source_hash_name '%s'",
1557             "any supported" if not hash_type else hash_type,
1558             source_hash_name,
1559         )
1560     if file_name:
1561         if not isinstance(file_name, str):
1562             file_name = str(file_name)
1563         file_name_basename = os.path.basename(file_name)
1564         file_name_idx = (len(file_name_basename) + 1) * -1
1565     if source:
1566         if not isinstance(source, str):
1567             source = str(source)
1568         urlparsed_source = urllib.parse.urlparse(source)
1569         source_basename = os.path.basename(
1570             urlparsed_source.path or urlparsed_source.netloc
1571         )
1572         source_idx = (len(source_basename) + 1) * -1
1573     basename_searches = [x for x in (file_name, source) if x]
1574     if basename_searches:
1575         log.debug(
1576             "file.extract_hash: %s %s hash for file matching%s: %s",
1577             "If no source_hash_name match found, will extract"
1578             if source_hash_name
1579             else "Extracting",
1580             "any supported" if not hash_type else hash_type,
1581             "" if len(basename_searches) == 1 else " either of the following",
1582             ", ".join(basename_searches),
1583         )
1584     partial = None
1585     found = {}
1586     with salt.utils.files.fopen(hash_fn, "r") as fp_:
1587         for line in fp_:
1588             line = salt.utils.stringutils.to_unicode(line.strip())
1589             hash_re = r"(?i)(?&lt;![a-z0-9])([a-f0-9]{" + hash_len_expr + "})(?![a-z0-9])"
1590             hash_match = re.search(hash_re, line)
1591             matched = None
1592             if hash_match:
1593                 matched_hsum = hash_match.group(1)
1594                 if matched_hsum is not None:
1595                     matched_type = HASHES_REVMAP.get(len(matched_hsum))
1596                     if matched_type is None:
1597                         matched = None
1598                     else:
1599                         matched = {"hsum": matched_hsum, "hash_type": matched_type}
1600             if matched is None:
1601                 log.debug(
1602                     "file.extract_hash: In line '%s', no %shash found",
1603                     line,
1604                     "" if not hash_type else hash_type + " ",
1605                 )
1606                 continue
1607             if partial is None:
1608                 partial = matched
1609             def _add_to_matches(found, line, match_type, value, matched):
1610                 log.debug(
1611                     "file.extract_hash: Line '%s' matches %s '%s'",
1612                     line,
1613                     match_type,
1614                     value,
1615                 )
1616                 found.setdefault(match_type, []).append(matched)
1617             hash_matched = False
1618             if source_hash_name:
1619                 if line.endswith(source_hash_name):
1620                     try:
1621                         if line[source_hash_name_idx] in string.whitespace:
1622                             _add_to_matches(
1623                                 found,
1624                                 line,
1625                                 "source_hash_name",
1626                                 source_hash_name,
1627                                 matched,
1628                             )
1629                             hash_matched = True
1630                     except IndexError:
1631                         pass
1632                 elif re.match(re.escape(source_hash_name) + r"\s+", line):
1633                     _add_to_matches(
1634                         found, line, "source_hash_name", source_hash_name, matched
1635                     )
1636                     hash_matched = True
1637             if file_name:
1638                 if line.endswith(file_name_basename):
1639                     try:
1640                         if line[file_name_idx] in filename_separators:
1641                             _add_to_matches(
1642                                 found, line, "file_name", file_name, matched
1643                             )
1644                             hash_matched = True
1645                     except IndexError:
1646                         pass
1647                 elif re.match(re.escape(file_name) + r"\s+", line):
1648                     _add_to_matches(found, line, "file_name", file_name, matched)
1649                     hash_matched = True
1650             if source:
1651                 if line.endswith(source_basename):
1652                     try:
1653                         if line[source_idx] in filename_separators:
1654                             _add_to_matches(found, line, "source", source, matched)
1655                             hash_matched = True
1656                     except IndexError:
1657                         pass
1658                 elif re.match(re.escape(source) + r"\s+", line):
1659                     _add_to_matches(found, line, "source", source, matched)
1660                     hash_matched = True
1661             if not hash_matched:
1662                 log.debug(
1663                     "file.extract_hash: Line '%s' contains %s hash "
1664                     "'%s', but line did not meet the search criteria",
1665                     line,
1666                     matched["hash_type"],
1667                     matched["hsum"],
1668                 )
1669     for found_type, found_str in (
1670         ("source_hash_name", source_hash_name),
1671         ("file_name", file_name),
1672         ("source", source),
1673     ):
1674         if found_type in found:
1675             if len(found[found_type]) &gt; 1:
1676                 log.debug(
1677                     "file.extract_hash: Multiple %s matches for %s: %s",
1678                     found_type,
1679                     found_str,
1680                     ", ".join(
1681                         [
1682                             "{} ({})".format(x["hsum"], x["hash_type"])
1683                             for x in found[found_type]
1684                         ]
1685                     ),
1686                 )
1687             ret = found[found_type][0]
1688             log.debug(
1689                 "file.extract_hash: Returning %s hash '%s' as a match of %s",
1690                 ret["hash_type"],
1691                 ret["hsum"],
1692                 found_str,
1693             )
1694             return ret
1695     if partial:
1696         log.debug(
1697             "file.extract_hash: Returning the partially identified %s hash '%s'",
1698             partial["hash_type"],
1699             partial["hsum"],
1700         )
1701         return partial
1702     log.debug("file.extract_hash: No matches, returning None")
1703     return None
1704 def check_perms(
1705     name,
1706     ret,
1707     user,
1708     group,
1709     mode,
1710     attrs=None,
1711     follow_symlinks=False,
1712     seuser=None,
1713     serole=None,
1714     setype=None,
1715     serange=None,
1716 ):
1717     name = os.path.expanduser(name)
1718     if not ret:
1719         ret = {"name": name, "changes": {}, "comment": [], "result": True}
1720         orig_comment = ""
1721     else:
1722         orig_comment = ret["comment"]
1723         ret["comment"] = []
1724     perms = {}
1725     cur = stats(name, follow_symlinks=follow_symlinks)
1726     perms["luser"] = cur["user"]
1727     perms["lgroup"] = cur["group"]
1728     perms["lmode"] = salt.utils.files.normalize_mode(cur["mode"])
1729     is_dir = os.path.isdir(name)
1730     is_link = os.path.islink(name)
1731     if user:
1732         if isinstance(user, int):
1733             user = uid_to_user(user)
1734         if (
1735             salt.utils.platform.is_windows()
1736             and user_to_uid(user) != user_to_uid(perms["luser"])
1737         ) or (not salt.utils.platform.is_windows() and user != perms["luser"]):
1738             perms["cuser"] = user
1739     if group:
1740         if isinstance(group, int):
1741             group = gid_to_group(group)
1742         if (
1743             salt.utils.platform.is_windows()
1744             and group_to_gid(group) != group_to_gid(perms["lgroup"])
1745         ) or (not salt.utils.platform.is_windows() and group != perms["lgroup"]):
1746             perms["cgroup"] = group
1747     if "cuser" in perms or "cgroup" in perms:
1748         if not __opts__["test"]:
1749             if os.path.islink(name) and not follow_symlinks:
1750                 chown_func = lchown
1751             else:
1752                 chown_func = chown
1753             if user is None:
1754                 user = perms["luser"]
1755             if group is None:
1756                 group = perms["lgroup"]
1757             try:
1758                 chown_func(name, user, group)
1759                 set_mode(name, mode)
1760             except OSError:
1761                 ret["result"] = False
1762     if user:
1763         if isinstance(user, int):
1764             user = uid_to_user(user)
1765         if (
1766             salt.utils.platform.is_windows()
1767             and user_to_uid(user)
1768             != user_to_uid(get_user(name, follow_symlinks=follow_symlinks))
1769             and user != ""
1770         ) or (
1771             not salt.utils.platform.is_windows()
1772             and user != get_user(name, follow_symlinks=follow_symlinks)
1773             and user != ""
1774         ):
1775             if __opts__["test"] is True:
1776                 ret["changes"]["user"] = user
1777             else:
1778                 ret["result"] = False
1779                 ret["comment"].append("Failed to change user to {}".format(user))
1780         elif "cuser" in perms and user != "":
1781             ret["changes"]["user"] = user
1782     if group:
1783         if isinstance(group, int):
1784             group = gid_to_group(group)
1785         if (
1786             salt.utils.platform.is_windows()
1787             and group_to_gid(group)
1788             != group_to_gid(get_group(name, follow_symlinks=follow_symlinks))
1789             and user != ""
1790         ) or (
1791             not salt.utils.platform.is_windows()
1792             and group != get_group(name, follow_symlinks=follow_symlinks)
1793             and user != ""
1794         ):
1795             if __opts__["test"] is True:
1796                 ret["changes"]["group"] = group
1797             else:
1798                 ret["result"] = False
1799                 ret["comment"].append("Failed to change group to {}".format(group))
1800         elif "cgroup" in perms and user != "":
1801             ret["changes"]["group"] = group
1802     if mode is not None:
1803         if os.path.islink(name) and not follow_symlinks:
1804             pass
1805         else:
1806             mode = salt.utils.files.normalize_mode(mode)
1807             if mode != perms["lmode"]:
1808                 if __opts__["test"] is True:
1809                     ret["changes"]["mode"] = mode
1810                 else:
1811                     set_mode(name, mode)
1812                     if mode != salt.utils.files.normalize_mode(get_mode(name)):
1813                         ret["result"] = False
1814                         ret["comment"].append(
1815                             "Failed to change mode to {}".format(mode)
1816                         )
1817                     else:
1818                         ret["changes"]["mode"] = mode
1819     if attrs is not None and not is_dir:
1820         if os.path.islink(name) and not follow_symlinks:
1821             pass
1822         else:
1823             diff_attrs = _cmp_attrs(name, attrs)
1824             if diff_attrs and any(attr for attr in diff_attrs):
1825                 changes = {
1826                     "old": "".join(lsattr(name)[name]),
1827                     "new": None,
1828                 }
1829                 if __opts__["test"] is True:
1830                     changes["new"] = attrs
1831                 else:
1832                     if diff_attrs.added:
1833                         chattr(
1834                             name,
1835                             operator="add",
1836                             attributes=diff_attrs.added,
1837                         )
1838                     if diff_attrs.removed:
1839                         chattr(
1840                             name,
1841                             operator="remove",
1842                             attributes=diff_attrs.removed,
1843                         )
1844                     cmp_attrs = _cmp_attrs(name, attrs)
1845                     if any(attr for attr in cmp_attrs):
1846                         ret["result"] = False
1847                         ret["comment"].append(
1848                             "Failed to change attributes to {}".format(attrs)
1849                         )
1850                         changes["new"] = "".join(lsattr(name)[name])
1851                     else:
1852                         changes["new"] = attrs
1853                 if changes["old"] != changes["new"]:
1854                     ret["changes"]["attrs"] = changes
1855     if salt.utils.platform.is_linux() and (seuser or serole or setype or serange):
1856         selinux_error = False
1857         try:
1858             (
1859                 current_seuser,
1860                 current_serole,
1861                 current_setype,
1862                 current_serange,
1863             ) = get_selinux_context(name).split(":")
1864             log.debug(
1865                 "Current selinux context user:%s role:%s type:%s range:%s",
1866                 current_seuser,
1867                 current_serole,
1868                 current_setype,
1869                 current_serange,
1870             )
1871         except ValueError:
1872             log.error("Unable to get current selinux attributes")
1873             ret["result"] = False
1874             ret["comment"].append("Failed to get selinux attributes")
1875             selinux_error = True
1876         if not selinux_error:
1877             requested_seuser = None
1878             requested_serole = None
1879             requested_setype = None
1880             requested_serange = None
1881             if seuser and seuser != current_seuser:
1882                 requested_seuser = seuser
1883             if serole and serole != current_serole:
1884                 requested_serole = serole
1885             if setype and setype != current_setype:
1886                 requested_setype = setype
1887             if serange and serange != current_serange:
1888                 requested_serange = serange
1889             if (
1890                 requested_seuser
1891                 or requested_serole
1892                 or requested_setype
1893                 or requested_serange
1894             ):
1895                 selinux_change_new = ""
1896                 selinux_change_orig = ""
1897                 if requested_seuser:
1898                     selinux_change_new += "User: {} ".format(requested_seuser)
1899                     selinux_change_orig += "User: {} ".format(current_seuser)
1900                 if requested_serole:
1901                     selinux_change_new += "Role: {} ".format(requested_serole)
1902                     selinux_change_orig += "Role: {} ".format(current_serole)
1903                 if requested_setype:
1904                     selinux_change_new += "Type: {} ".format(requested_setype)
1905                     selinux_change_orig += "Type: {} ".format(current_setype)
1906                 if requested_serange:
1907                     selinux_change_new += "Range: {} ".format(requested_serange)
1908                     selinux_change_orig += "Range: {} ".format(current_serange)
1909                 if __opts__["test"]:
1910                     ret["comment"] = "File {} selinux context to be updated".format(
1911                         name
1912                     )
1913                     ret["result"] = None
1914                     ret["changes"]["selinux"] = {
1915                         "Old": selinux_change_orig.strip(),
1916                         "New": selinux_change_new.strip(),
1917                     }
1918                 else:
1919                     try:
1920                         if (
1921                             requested_seuser or requested_serole or requested_serange
1922                         ) and not requested_setype:
1923                             requested_setype = current_setype
1924                         result = set_selinux_context(
1925                             name,
1926                             user=requested_seuser,
1927                             role=requested_serole,
1928                             type=requested_setype,
1929                             range=requested_serange,
1930                             persist=True,
1931                         )
1932                         log.debug("selinux set result: %s", result)
1933                         (
1934                             current_seuser,
1935                             current_serole,
1936                             current_setype,
1937                             current_serange,
1938                         ) = result.split(":")
1939                     except ValueError:
1940                         log.error("Unable to set current selinux attributes")
1941                         ret["result"] = False
1942                         ret["comment"].append("Failed to set selinux attributes")
1943                         selinux_error = True
1944                     if not selinux_error:
1945                         ret["comment"].append(
1946                             "The file {} is set to be changed".format(name)
1947                         )
1948                         if requested_seuser:
1949                             if current_seuser != requested_seuser:
1950                                 ret["comment"].append("Unable to update seuser context")
1951                                 ret["result"] = False
1952                         if requested_serole:
1953                             if current_serole != requested_serole:
1954                                 ret["comment"].append("Unable to update serole context")
1955                                 ret["result"] = False
1956                         if requested_setype:
1957                             if current_setype != requested_setype:
1958                                 ret["comment"].append("Unable to update setype context")
1959                                 ret["result"] = False
1960                         if requested_serange:
1961                             if current_serange != requested_serange:
1962                                 ret["comment"].append(
1963                                     "Unable to update serange context"
1964                                 )
1965                                 ret["result"] = False
1966                         ret["changes"]["selinux"] = {
1967                             "Old": selinux_change_orig.strip(),
1968                             "New": selinux_change_new.strip(),
1969                         }
1970     if isinstance(orig_comment, str):
1971         if orig_comment:
1972             ret["comment"].insert(0, orig_comment)
1973         ret["comment"] = "; ".join(ret["comment"])
1974     if __opts__["test"] is True and ret["changes"]:
1975         ret["result"] = None
1976     return ret, perms
1977 def check_managed(
1978     name,
1979     source,
1980     source_hash,
1981     source_hash_name,
1982     user,
1983     group,
1984     mode,
1985     attrs,
1986     template,
1987     context,
1988     defaults,
1989     saltenv,
1990     contents=None,
1991     skip_verify=False,
1992     seuser=None,
1993     serole=None,
1994     setype=None,
1995     serange=None,
1996     **kwargs
1997 ):
1998     source, source_hash = source_list(
1999         source, source_hash, saltenv  # pylint: disable=W0633
2000     )
2001     sfn = ""
2002     source_sum = None
2003     if contents is None:
2004         sfn, source_sum, comments = get_managed(
2005             name,
2006             template,
2007             source,
2008             source_hash,
2009             source_hash_name,
2010             user,
2011             group,
2012             mode,
2013             attrs,
2014             saltenv,
2015             context,
2016             defaults,
2017             skip_verify,
2018             **kwargs
2019         )
2020         if comments:
2021             __clean_tmp(sfn)
2022             return False, comments
2023     changes = check_file_meta(
2024         name,
2025         sfn,
2026         source,
2027         source_sum,
2028         user,
2029         group,
2030         mode,
2031         attrs,
2032         saltenv,
2033         contents,
2034         seuser=seuser,
2035         serole=serole,
2036         setype=setype,
2037         serange=serange,
2038     )
2039     if name.startswith(tempfile.gettempdir()):
2040         for key in ["user", "group", "mode"]:
2041             changes.pop(key, None)
2042     __clean_tmp(sfn)
2043     if changes:
2044         log.info(changes)
2045         comments = ["The following values are set to be changed:\n"]
2046         comments.extend("{}: {}\n".format(key, val) for key, val in changes.items())
2047         return None, "".join(comments)
2048     return True, "The file {} is in the correct state".format(name)
2049 def check_managed_changes(
2050     name,
2051     source,
2052     source_hash,
2053     source_hash_name,
2054     user,
2055     group,
2056     mode,
2057     attrs,
2058     template,
2059     context,
2060     defaults,
2061     saltenv,
2062     contents=None,
2063     skip_verify=False,
2064     keep_mode=False,
2065     seuser=None,
2066     serole=None,
2067     setype=None,
2068     serange=None,
2069     verify_ssl=True,
2070     **kwargs
2071 ):
2072     source, source_hash = source_list(
2073         source, source_hash, saltenv  # pylint: disable=W0633
2074     )
2075     sfn = ""
2076     source_sum = None
2077     if contents is None:
2078         sfn, source_sum, comments = get_managed(
2079             name,
2080             template,
2081             source,
2082             source_hash,
2083             source_hash_name,
2084             user,
2085             group,
2086             mode,
2087             attrs,
2088             saltenv,
2089             context,
2090             defaults,
2091             skip_verify,
2092             verify_ssl=verify_ssl,
2093             **kwargs
2094         )
2095         if source_sum and ("hsum" in source_sum):
2096             source_sum["hsum"] = source_sum["hsum"].lower()
2097         if comments:
2098             __clean_tmp(sfn)
2099             return False, comments
2100         if sfn and source and keep_mode:
2101             if (
2102                 urllib.parse.urlparse(source).scheme
2103                 in (
2104                     "salt",
2105                     "file",
2106                 )
2107                 or source.startswith("/")
2108             ):
2109                 try:
2110                     mode = __salt__["cp.stat_file"](source, saltenv=saltenv, octal=True)
2111                 except Exception as exc:  # pylint: disable=broad-except
2112                     log.warning("Unable to stat %s: %s", sfn, exc)
2113     changes = check_file_meta(
2114         name,
2115         sfn,
2116         source,
2117         source_sum,
2118         user,
2119         group,
2120         mode,
2121         attrs,
2122         saltenv,
2123         contents,
2124         seuser=seuser,
2125         serole=serole,
2126         setype=setype,
2127         serange=serange,
2128     )
2129     __clean_tmp(sfn)
2130     return changes
2131 def check_file_meta(
2132     name,
2133     sfn,
2134     source,
2135     source_sum,
2136     user,
2137     group,
2138     mode,
2139     attrs,
2140     saltenv,
2141     contents=None,
2142     seuser=None,
2143     serole=None,
2144     setype=None,
2145     serange=None,
2146     verify_ssl=True,
2147 ):
2148     changes = {}
2149     if not source_sum:
2150         source_sum = dict()
2151     try:
2152         lstats = stats(
2153             name, hash_type=source_sum.get("hash_type", None), follow_symlinks=False
2154         )
2155     except CommandExecutionError:
2156         lstats = {}
2157     if not lstats:
2158         changes["newfile"] = name
2159         return changes
2160     if "hsum" in source_sum:
2161         if source_sum["hsum"] != lstats["sum"]:
2162             if not sfn and source:
2163                 sfn = __salt__["cp.cache_file"](
2164                     source,
2165                     saltenv,
2166                     source_hash=source_sum["hsum"],
2167                     verify_ssl=verify_ssl,
2168                 )
2169             if sfn:
2170                 try:
2171                     changes["diff"] = get_diff(
2172                         name, sfn, template=True, show_filenames=False
2173                     )
2174                 except CommandExecutionError as exc:
2175                     changes["diff"] = exc.strerror
2176             else:
2177                 changes["sum"] = "Checksum differs"
2178     if contents is not None:
2179         if isinstance(contents, bytes):
2180             tmp = salt.utils.files.mkstemp(
2181                 prefix=salt.utils.files.TEMPFILE_PREFIX, text=False
2182             )
2183             with salt.utils.files.fopen(tmp, "wb") as tmp_:
2184                 tmp_.write(contents)
2185         else:
2186             tmp = salt.utils.files.mkstemp(
2187                 prefix=salt.utils.files.TEMPFILE_PREFIX, text=True
2188             )
2189             if salt.utils.platform.is_windows():
2190                 contents = os.linesep.join(
2191                     _splitlines_preserving_trailing_newline(contents)
2192                 )
2193             with salt.utils.files.fopen(tmp, "w") as tmp_:
2194                 tmp_.write(salt.utils.stringutils.to_str(contents))
2195         try:
2196             differences = get_diff(name, tmp, show_filenames=False)
2197         except CommandExecutionError as exc:
2198             log.error("Failed to diff files: %s", exc)
2199             differences = exc.strerror
2200         __clean_tmp(tmp)
2201         if differences:
2202             if __salt__["config.option"]("obfuscate_templates"):
2203                 changes["diff"] = "&lt;Obfuscated Template&gt;"
2204             else:
2205                 changes["diff"] = differences
2206     if not salt.utils.platform.is_windows():
2207         if user is not None and user != lstats["user"] and user != lstats["uid"]:
2208             changes["user"] = user
2209         if group is not None and group != lstats["group"] and group != lstats["gid"]:
2210             changes["group"] = group
2211         smode = salt.utils.files.normalize_mode(lstats["mode"])
2212         mode = salt.utils.files.normalize_mode(mode)
2213         if mode is not None and mode != smode:
2214             changes["mode"] = mode
2215         if attrs:
2216             diff_attrs = _cmp_attrs(name, attrs)
2217             if diff_attrs is not None:
2218                 if attrs is not None and (
2219                     diff_attrs[0] is not None or diff_attrs[1] is not None
2220                 ):
2221                     changes["attrs"] = attrs
2222         if seuser or serole or setype or serange:
2223             try:
2224                 (
2225                     current_seuser,
2226                     current_serole,
2227                     current_setype,
2228                     current_serange,
2229                 ) = get_selinux_context(name).split(":")
2230                 log.debug(
2231                     "Current selinux context user:%s role:%s type:%s range:%s",
2232                     current_seuser,
2233                     current_serole,
2234                     current_setype,
2235                     current_serange,
2236                 )
2237             except ValueError as exc:
2238                 log.error("Unable to get current selinux attributes")
2239                 changes["selinux"] = exc.strerror
2240             if seuser and seuser != current_seuser:
2241                 changes["selinux"] = {"user": seuser}
2242             if serole and serole != current_serole:
2243                 changes["selinux"] = {"role": serole}
2244             if setype and setype != current_setype:
2245                 changes["selinux"] = {"type": setype}
2246             if serange and serange != current_serange:
2247                 changes["selinux"] = {"range": serange}
2248     return changes
2249 def get_diff(
2250     file1,
2251     file2,
2252     saltenv="base",
2253     show_filenames=True,
2254     show_changes=True,
2255     template=False,
2256     source_hash_file1=None,
2257     source_hash_file2=None,
2258 ):
2259     files = (file1, file2)
2260     source_hashes = (source_hash_file1, source_hash_file2)
2261     paths = []
2262     errors = []
2263     for filename, source_hash in zip(files, source_hashes):
2264         try:
2265             cached_path = __salt__["cp.cache_file"](
2266                 filename, saltenv, source_hash=source_hash
2267             )
2268             if cached_path is False:
2269                 errors.append(
2270                     "File {} not found".format(
2271                         salt.utils.stringutils.to_unicode(filename)
2272                     )
2273                 )
2274                 continue
2275             paths.append(cached_path)
2276         except MinionError as exc:
2277             errors.append(salt.utils.stringutils.to_unicode(exc.__str__()))
2278             continue
2279     if errors:
2280         raise CommandExecutionError("Failed to cache one or more files", info=errors)
2281     args = []
2282     for filename in paths:
2283         try:
2284             with salt.utils.files.fopen(filename, "rb") as fp_:
2285                 args.append(fp_.readlines())
2286         except OSError as exc:
2287             raise CommandExecutionError(
2288                 "Failed to read {}: {}".format(
2289                     salt.utils.stringutils.to_unicode(filename), exc.strerror
2290                 )
2291             )
2292     if args[0] != args[1]:
2293         if template and __salt__["config.option"]("obfuscate_templates"):
2294             ret = "&lt;Obfuscated Template&gt;"
2295         elif not show_changes:
2296             ret = "&lt;show_changes=False&gt;"
2297         else:
2298             bdiff = _binary_replace(*paths)  # pylint: disable=no-value-for-parameter
2299             if bdiff:
2300                 ret = bdiff
2301             else:
2302                 if show_filenames:
2303                     args.extend(paths)
2304                 ret = __utils__["stringutils.get_diff"](*args)
2305         return ret
2306     return ""
2307 def manage_file(
2308     name,
2309     sfn,
2310     ret,
2311     source,
2312     source_sum,
2313     user,
2314     group,
2315     mode,
2316     attrs,
2317     saltenv,
2318     backup,
2319     makedirs=False,
2320     template=None,  # pylint: disable=W0613
2321     show_changes=True,
2322     contents=None,
2323     dir_mode=None,
2324     follow_symlinks=True,
2325     skip_verify=False,
2326     keep_mode=False,
2327     encoding=None,
2328     encoding_errors="strict",
2329     seuser=None,
2330     serole=None,
2331     setype=None,
2332     serange=None,
2333     verify_ssl=True,
2334     use_etag=False,
2335     **kwargs
2336 ):
2337     name = os.path.expanduser(name)
2338     check_web_source_hash = bool(
2339         source
2340         and urllib.parse.urlparse(source).scheme != "salt"
2341         and not skip_verify
2342         and not use_etag
2343     )
2344     if not ret:
2345         ret = {"name": name, "changes": {}, "comment": "", "result": True}
2346     if source_sum and ("hsum" in source_sum):
2347         source_sum["hsum"] = source_sum["hsum"].lower()
2348     if source:
2349         if not sfn:
2350             sfn = __salt__["cp.cache_file"](source, saltenv, verify_ssl=verify_ssl)
2351             if not sfn:
2352                 return _error(ret, "Source file '{}' not found".format(source))
2353             htype = source_sum.get("hash_type", __opts__["hash_type"])
2354             source_sum = {"hash_type": htype, "hsum": get_hash(sfn, form=htype)}
2355         if keep_mode:
2356             if urllib.parse.urlparse(source).scheme in ("salt", "file", ""):
2357                 try:
2358                     mode = __salt__["cp.stat_file"](source, saltenv=saltenv, octal=True)
2359                 except Exception as exc:  # pylint: disable=broad-except
2360                     log.warning("Unable to stat %s: %s", sfn, exc)
2361     if os.path.isfile(name) or os.path.islink(name):
2362         if os.path.islink(name) and follow_symlinks:
2363             real_name = os.path.realpath(name)
2364         else:
2365             real_name = name
2366         if source and not (not follow_symlinks and os.path.islink(real_name)):
2367             name_sum = get_hash(
2368                 real_name, source_sum.get("hash_type", __opts__["hash_type"])
2369             )
2370         else:
2371             name_sum = None
2372         if source and (
2373             name_sum is None
2374             or source_sum.get("hsum", __opts__["hash_type"]) != name_sum
2375         ):
2376             if not sfn:
2377                 sfn = __salt__["cp.cache_file"](
2378                     source, saltenv, verify_ssl=verify_ssl, use_etag=use_etag
2379                 )
2380             if not sfn:
2381                 return _error(ret, "Source file '{}' not found".format(source))
2382             if check_web_source_hash:
2383                 dl_sum = get_hash(sfn, source_sum["hash_type"])
2384                 if dl_sum != source_sum["hsum"]:
2385                     ret["comment"] = (
2386                         "Specified {} checksum for {} ({}) does not match "
2387                         "actual checksum ({}). If the 'source_hash' value "
2388                         "refers to a remote file with multiple possible "
2389                         "matches, then it may be necessary to set "
2390                         "'source_hash_name'.".format(
2391                             source_sum["hash_type"], source, source_sum["hsum"], dl_sum
2392                         )
2393                     )
2394                     ret["result"] = False
2395                     return ret
2396             if __salt__["config.option"]("obfuscate_templates"):
2397                 ret["changes"]["diff"] = "&lt;Obfuscated Template&gt;"
2398             elif not show_changes:
2399                 ret["changes"]["diff"] = "&lt;show_changes=False&gt;"
2400             else:
2401                 try:
2402                     file_diff = get_diff(real_name, sfn, show_filenames=False)
2403                     if file_diff:
2404                         ret["changes"]["diff"] = file_diff
2405                 except CommandExecutionError as exc:
2406                     ret["changes"]["diff"] = exc.strerror
2407             try:
2408                 salt.utils.files.copyfile(
2409                     sfn,
2410                     real_name,
2411                     __salt__["config.backup_mode"](backup),
2412                     __opts__["cachedir"],
2413                 )
2414             except OSError as io_error:
2415                 __clean_tmp(sfn)
2416                 return _error(ret, "Failed to commit change: {}".format(io_error))
2417         if contents is not None:
2418             tmp = salt.utils.files.mkstemp(
2419                 prefix=salt.utils.files.TEMPFILE_PREFIX, text=True
2420             )
2421             with salt.utils.files.fopen(tmp, "wb") as tmp_:
2422                 if encoding:
2423                     if salt.utils.platform.is_windows():
2424                         contents = os.linesep.join(
2425                             _splitlines_preserving_trailing_newline(contents)
2426                         )
2427                     log.debug("File will be encoded with %s", encoding)
2428                     tmp_.write(
2429                         contents.encode(encoding=encoding, errors=encoding_errors)
2430                     )
2431                 else:
2432                     tmp_.write(salt.utils.stringutils.to_bytes(contents))
2433             try:
2434                 differences = get_diff(
2435                     real_name,
2436                     tmp,
2437                     show_filenames=False,
2438                     show_changes=show_changes,
2439                     template=True,
2440                 )
2441             except CommandExecutionError as exc:
2442                 ret.setdefault("warnings", []).append(
2443                     "Failed to detect changes to file: {}".format(exc.strerror)
2444                 )
2445                 differences = ""
2446             if differences:
2447                 ret["changes"]["diff"] = differences
2448                 try:
2449                     salt.utils.files.copyfile(
2450                         tmp,
2451                         real_name,
2452                         __salt__["config.backup_mode"](backup),
2453                         __opts__["cachedir"],
2454                     )
2455                 except OSError as io_error:
2456                     __clean_tmp(tmp)
2457                     return _error(ret, "Failed to commit change: {}".format(io_error))
2458             __clean_tmp(tmp)
2459         if os.path.islink(name) and not follow_symlinks:
2460             if not sfn:
2461                 sfn = __salt__["cp.cache_file"](source, saltenv, verify_ssl=verify_ssl)
2462             if not sfn:
2463                 return _error(ret, "Source file '{}' not found".format(source))
2464             if check_web_source_hash:
2465                 dl_sum = get_hash(sfn, source_sum["hash_type"])
2466                 if dl_sum != source_sum["hsum"]:
2467                     ret["comment"] = (
2468                         "Specified {} checksum for {} ({}) does not match "
2469                         "actual checksum ({})".format(
2470                             source_sum["hash_type"], name, source_sum["hsum"], dl_sum
2471                         )
2472                     )
2473                     ret["result"] = False
2474                     return ret
2475             try:
2476                 salt.utils.files.copyfile(
2477                     sfn,
2478                     name,
2479                     __salt__["config.backup_mode"](backup),
2480                     __opts__["cachedir"],
2481                 )
2482             except OSError as io_error:
2483                 __clean_tmp(sfn)
2484                 return _error(ret, "Failed to commit change: {}".format(io_error))
2485             ret["changes"]["diff"] = "Replace symbolic link with regular file"
2486         if salt.utils.platform.is_windows():
2487             ret = check_perms(
2488                 path=name,
2489                 ret=ret,
2490                 owner=kwargs.get("win_owner"),
2491                 grant_perms=kwargs.get("win_perms"),
2492                 deny_perms=kwargs.get("win_deny_perms"),
2493                 inheritance=kwargs.get("win_inheritance", True),
2494                 reset=kwargs.get("win_perms_reset", False),
2495             )
2496         else:
2497             ret, _ = check_perms(
2498                 name,
2499                 ret,
2500                 user,
2501                 group,
2502                 mode,
2503                 attrs,
2504                 follow_symlinks,
2505                 seuser=seuser,
2506                 serole=serole,
2507                 setype=setype,
2508                 serange=serange,
2509             )
2510         if ret["changes"]:
2511             ret["comment"] = "File {} updated".format(salt.utils.data.decode(name))
2512         elif not ret["changes"] and ret["result"]:
2513             ret["comment"] = "File {} is in the correct state".format(
2514                 salt.utils.data.decode(name)
2515             )
2516         if sfn:
2517             __clean_tmp(sfn)
2518         return ret
2519     else:  # target file does not exist
2520         contain_dir = os.path.dirname(name)
2521         def _set_mode_and_make_dirs(name, dir_mode, mode, user, group):
2522             if salt.utils.platform.is_windows():
2523                 drive, _ = os.path.splitdrive(name)
2524                 if drive and not os.path.exists(drive):
2525                     __clean_tmp(sfn)
2526                     return _error(ret, "{} drive not present".format(drive))
2527             if dir_mode is None and mode is not None:
2528                 mode_list = [x for x in str(mode)][-3:]
2529                 for idx, part in enumerate(mode_list):
2530                     if part != "0":
2531                         mode_list[idx] = str(int(part) | 1)
2532                 dir_mode = "".join(mode_list)
2533             if salt.utils.platform.is_windows():
2534                 makedirs_(
2535                     path=name,
2536                     owner=kwargs.get("win_owner"),
2537                     grant_perms=kwargs.get("win_perms"),
2538                     deny_perms=kwargs.get("win_deny_perms"),
2539                     inheritance=kwargs.get("win_inheritance", True),
2540                     reset=kwargs.get("win_perms_reset", False),
2541                 )
2542             else:
2543                 makedirs_(name, user=user, group=group, mode=dir_mode)
2544         if source:
2545             if not sfn:
2546                 sfn = __salt__["cp.cache_file"](source, saltenv, verify_ssl=verify_ssl)
2547             if not sfn:
2548                 return _error(ret, "Source file '{}' not found".format(source))
2549             if check_web_source_hash:
2550                 dl_sum = get_hash(sfn, source_sum["hash_type"])
2551                 if dl_sum != source_sum["hsum"]:
2552                     ret["comment"] = (
2553                         "Specified {} checksum for {} ({}) does not match "
2554                         "actual checksum ({})".format(
2555                             source_sum["hash_type"], name, source_sum["hsum"], dl_sum
2556                         )
2557                     )
2558                     ret["result"] = False
2559                     return ret
2560             ret["changes"]["diff"] = "New file"
2561             if not os.path.isdir(contain_dir):
2562                 if makedirs:
2563                     _set_mode_and_make_dirs(name, dir_mode, mode, user, group)
2564                 else:
2565                     __clean_tmp(sfn)
2566                     ret["changes"].pop("diff", None)
2567                     return _error(ret, "Parent directory not present")
2568         else:  # source != True
2569             if not os.path.isdir(contain_dir):
2570                 if makedirs:
2571                     _set_mode_and_make_dirs(name, dir_mode, mode, user, group)
2572                 else:
2573                     __clean_tmp(sfn)
2574                     ret["changes"].pop("diff", None)
2575                     return _error(ret, "Parent directory not present")
2576             with salt.utils.files.set_umask(0o077 if mode else None):
2577                 if contents is None:
2578                     if not __opts__["test"]:
2579                         if touch(name):
2580                             ret["changes"]["new"] = "file {} created".format(name)
2581                             ret["comment"] = "Empty file"
2582                         else:
2583                             return _error(ret, "Empty file {} not created".format(name))
2584                 else:
2585                     if not __opts__["test"]:
2586                         if touch(name):
2587                             ret["changes"]["diff"] = "New file"
2588                         else:
2589                             return _error(ret, "File {} not created".format(name))
2590         if contents is not None:
2591             tmp = salt.utils.files.mkstemp(
2592                 prefix=salt.utils.files.TEMPFILE_PREFIX, text=True
2593             )
2594             with salt.utils.files.fopen(tmp, "wb") as tmp_:
2595                 if encoding:
2596                     if salt.utils.platform.is_windows():
2597                         contents = os.linesep.join(
2598                             _splitlines_preserving_trailing_newline(contents)
2599                         )
2600                     log.debug("File will be encoded with %s", encoding)
2601                     tmp_.write(
2602                         contents.encode(encoding=encoding, errors=encoding_errors)
2603                     )
2604                 else:
2605                     tmp_.write(salt.utils.stringutils.to_bytes(contents))
2606             salt.utils.files.copyfile(
2607                 tmp, name, __salt__["config.backup_mode"](backup), __opts__["cachedir"]
2608             )
2609             __clean_tmp(tmp)
2610         elif sfn:
2611             salt.utils.files.copyfile(
2612                 sfn, name, __salt__["config.backup_mode"](backup), __opts__["cachedir"]
2613             )
2614             __clean_tmp(sfn)
2615         if mode is None and not salt.utils.platform.is_windows():
2616             mask = salt.utils.files.get_umask()
2617             mode = oct((0o777 ^ mask) &amp; 0o666)
2618         if salt.utils.platform.is_windows():
2619             ret = check_perms(
2620                 path=name,
2621                 ret=ret,
2622                 owner=kwargs.get("win_owner"),
2623                 grant_perms=kwargs.get("win_perms"),
2624                 deny_perms=kwargs.get("win_deny_perms"),
2625                 inheritance=kwargs.get("win_inheritance", True),
2626                 reset=kwargs.get("win_perms_reset", False),
2627             )
2628         else:
2629             ret, _ = check_perms(
2630                 name,
2631                 ret,
2632                 user,
2633                 group,
2634                 mode,
2635                 attrs,
2636                 seuser=seuser,
2637                 serole=serole,
2638                 setype=setype,
2639                 serange=serange,
2640             )
2641         if not ret["comment"]:
2642             ret["comment"] = "File " + name + " updated"
2643         if __opts__["test"]:
2644             ret["comment"] = "File " + name + " not updated"
2645         elif not ret["changes"] and ret["result"]:
2646             ret["comment"] = "File " + name + " is in the correct state"
2647         if sfn:
2648             __clean_tmp(sfn)
2649         return ret
2650 def mkdir(dir_path, user=None, group=None, mode=None):
2651     dir_path = os.path.expanduser(dir_path)
2652     directory = os.path.normpath(dir_path)
2653     if not os.path.isdir(directory):
2654         makedirs_perms(directory, user, group, mode)
2655     return True
2656 def makedirs_(path, user=None, group=None, mode=None):
2657     path = os.path.expanduser(path)
2658     if mode:
2659         mode = salt.utils.files.normalize_mode(mode)
2660     dirname = os.path.normpath(os.path.dirname(path))
2661     if os.path.isdir(dirname):
2662         msg = "Directory '{}' already exists".format(dirname)
2663         log.debug(msg)
2664         return msg
2665     if os.path.exists(dirname):
2666         msg = "The path '{}' already exists and is not a directory".format(dirname)
2667         log.debug(msg)
2668         return msg
2669     directories_to_create = []
2670     while True:
2671         if os.path.isdir(dirname):
2672             break
2673         directories_to_create.append(dirname)
2674         current_dirname = dirname
2675         dirname = os.path.dirname(dirname)
2676         if current_dirname == dirname:
2677             raise SaltInvocationError(
2678                 "Recursive creation for path '{}' would result in an "
2679                 "infinite loop. Please use an absolute path.".format(dirname)
2680             )
2681     directories_to_create.reverse()
2682     for directory_to_create in directories_to_create:
2683         log.debug("Creating directory: %s", directory_to_create)
2684         mkdir(directory_to_create, user=user, group=group, mode=mode)
2685 def makedirs_perms(name, user=None, group=None, mode="0755"):
2686     name = os.path.expanduser(name)
2687     path = os.path
2688     head, tail = path.split(name)
2689     if not tail:
2690         head, tail = path.split(head)
2691     if head and tail and not path.exists(head):
2692         try:
2693             makedirs_perms(head, user, group, mode)
2694         except OSError as exc:
2695             if exc.errno != errno.EEXIST:
2696                 raise
2697         if tail == os.curdir:  # xxx/newdir/. exists if xxx/newdir exists
2698             return
2699     os.mkdir(name)
2700     check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
2701 def get_devmm(name):
2702     name = os.path.expanduser(name)
2703     if is_chrdev(name) or is_blkdev(name):
2704         stat_structure = os.stat(name)
2705         return (os.major(stat_structure.st_rdev), os.minor(stat_structure.st_rdev))
2706     else:
2707         return (0, 0)
2708 def is_chrdev(name):
2709     name = os.path.expanduser(name)
2710     stat_structure = None
2711     try:
2712         stat_structure = os.stat(name)
2713     except OSError as exc:
2714         if exc.errno == errno.ENOENT:
2715             return False
2716         else:
2717             raise
2718     return stat.S_ISCHR(stat_structure.st_mode)
2719 def mknod_chrdev(name, major, minor, user=None, group=None, mode="0660"):
2720     name = os.path.expanduser(name)
2721     ret = {"name": name, "changes": {}, "comment": "", "result": False}
2722     log.debug(
2723         "Creating character device name:%s major:%s minor:%s mode:%s",
2724         name,
2725         major,
2726         minor,
2727         mode,
2728     )
2729     try:
2730         if __opts__["test"]:
2731             ret["changes"] = {"new": "Character device {} created.".format(name)}
2732             ret["result"] = None
2733         else:
2734             if (
2735                 os.mknod(
2736                     name,
2737                     int(str(mode).lstrip("0Oo"), 8) | stat.S_IFCHR,
2738                     os.makedev(major, minor),
2739                 )
2740                 is None
2741             ):
2742                 ret["changes"] = {"new": "Character device {} created.".format(name)}
2743                 ret["result"] = True
2744     except OSError as exc:
2745         if exc.errno != errno.EEXIST:
2746             raise
2747         else:
2748             ret["comment"] = "File {} exists and cannot be overwritten".format(name)
2749     check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
2750     return ret
2751 def is_blkdev(name):
2752     name = os.path.expanduser(name)
2753     stat_structure = None
2754     try:
2755         stat_structure = os.stat(name)
2756     except OSError as exc:
2757         if exc.errno == errno.ENOENT:
2758             return False
2759         else:
2760             raise
2761     return stat.S_ISBLK(stat_structure.st_mode)
2762 def mknod_blkdev(name, major, minor, user=None, group=None, mode="0660"):
2763     name = os.path.expanduser(name)
2764     ret = {"name": name, "changes": {}, "comment": "", "result": False}
2765     log.debug(
2766         "Creating block device name:%s major:%s minor:%s mode:%s",
2767         name,
2768         major,
2769         minor,
2770         mode,
2771     )
2772     try:
2773         if __opts__["test"]:
2774             ret["changes"] = {"new": "Block device {} created.".format(name)}
2775             ret["result"] = None
2776         else:
2777             if (
2778                 os.mknod(
2779                     name,
2780                     int(str(mode).lstrip("0Oo"), 8) | stat.S_IFBLK,
2781                     os.makedev(major, minor),
2782                 )
2783                 is None
2784             ):
2785                 ret["changes"] = {"new": "Block device {} created.".format(name)}
2786                 ret["result"] = True
2787     except OSError as exc:
2788         if exc.errno != errno.EEXIST:
2789             raise
2790         else:
2791             ret["comment"] = "File {} exists and cannot be overwritten".format(name)
2792     check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
2793     return ret
2794 def is_fifo(name):
2795     name = os.path.expanduser(name)
2796     stat_structure = None
2797     try:
2798         stat_structure = os.stat(name)
2799     except OSError as exc:
2800         if exc.errno == errno.ENOENT:
2801             return False
2802         else:
2803             raise
2804     return stat.S_ISFIFO(stat_structure.st_mode)
2805 def mknod_fifo(name, user=None, group=None, mode="0660"):
2806     name = os.path.expanduser(name)
2807     ret = {"name": name, "changes": {}, "comment": "", "result": False}
2808     log.debug("Creating FIFO name: %s", name)
2809     try:
2810         if __opts__["test"]:
2811             ret["changes"] = {"new": "Fifo pipe {} created.".format(name)}
2812             ret["result"] = None
2813         else:
2814             if os.mkfifo(name, int(str(mode).lstrip("0Oo"), 8)) is None:
2815                 ret["changes"] = {"new": "Fifo pipe {} created.".format(name)}
2816                 ret["result"] = True
2817     except OSError as exc:
2818         if exc.errno != errno.EEXIST:
2819             raise
2820         else:
2821             ret["comment"] = "File {} exists and cannot be overwritten".format(name)
2822     check_perms(name, None, user, group, int("{}".format(mode)) if mode else None)
2823     return ret
2824 def mknod(name, ntype, major=0, minor=0, user=None, group=None, mode="0600"):
2825     ret = False
2826     makedirs_(name, user, group)
2827     if ntype == "c":
2828         ret = mknod_chrdev(name, major, minor, user, group, mode)
2829     elif ntype == "b":
2830         ret = mknod_blkdev(name, major, minor, user, group, mode)
2831     elif ntype == "p":
2832         ret = mknod_fifo(name, user, group, mode)
2833     else:
2834         raise SaltInvocationError(
2835             "Node type unavailable: '{}'. Available node types are "
2836             "character ('c'), block ('b'), and pipe ('p').".format(ntype)
2837         )
2838     return ret
2839 def list_backups(path, limit=None):
2840     path = os.path.expanduser(path)
2841     try:
2842         limit = int(limit)
2843     except TypeError:
2844         pass
2845     except ValueError:
2846         log.error("file.list_backups: 'limit' value must be numeric")
2847         limit = None
2848     bkroot = _get_bkroot()
2849     parent_dir, basename = os.path.split(path)
2850     if salt.utils.platform.is_windows():
2851         src_dir = parent_dir.replace(":", "_")
2852     else:
2853         src_dir = parent_dir[1:]
2854     bkdir = os.path.join(bkroot, src_dir)
2855     if not os.path.isdir(bkdir):
2856         return {}
2857     files = {}
2858     for fname in [
2859         x for x in os.listdir(bkdir) if os.path.isfile(os.path.join(bkdir, x))
2860     ]:
2861         if salt.utils.platform.is_windows():
2862             strpfmt = "{}_%a_%b_%d_%H-%M-%S_%f_%Y".format(basename)
2863         else:
2864             strpfmt = "{}_%a_%b_%d_%H:%M:%S_%f_%Y".format(basename)
2865         try:
2866             timestamp = datetime.datetime.strptime(fname, strpfmt)
2867         except ValueError:
2868             continue
2869         if salt.utils.platform.is_windows():
2870             str_format = "%a %b %d %Y %H-%M-%S.%f"
2871         else:
2872             str_format = "%a %b %d %Y %H:%M:%S.%f"
2873         files.setdefault(timestamp, {})["Backup Time"] = timestamp.strftime(str_format)
2874         location = os.path.join(bkdir, fname)
2875         files[timestamp]["Size"] = os.stat(location).st_size
2876         files[timestamp]["Location"] = location
2877     return dict(
2878         list(
2879             zip(
2880                 list(range(len(files))),
2881                 [files[x] for x in sorted(files, reverse=True)[:limit]],
2882             )
2883         )
2884     )
2885 list_backup = salt.utils.functools.alias_function(list_backups, "list_backup")
2886 def list_backups_dir(path, limit=None):
2887     path = os.path.expanduser(path)
2888     try:
2889         limit = int(limit)
2890     except TypeError:
2891         pass
2892     except ValueError:
2893         log.error("file.list_backups_dir: 'limit' value must be numeric")
2894         limit = None
2895     bkroot = _get_bkroot()
2896     parent_dir, basename = os.path.split(path)
2897     bkdir = os.path.join(bkroot, parent_dir[1:])
2898     if not os.path.isdir(bkdir):
2899         return {}
2900     files = {}
2901     f = {
2902         i: len(list(n))
2903         for i, n in itertools.groupby(
2904             [x.split("_")[0] for x in sorted(os.listdir(bkdir))]
2905         )
2906     }
2907     ff = os.listdir(bkdir)
2908     for i, n in f.items():
2909         ssfile = {}
2910         for x in sorted(ff):
2911             basename = x.split("_")[0]
2912             if i == basename:
2913                 strpfmt = "{}_%a_%b_%d_%H:%M:%S_%f_%Y".format(basename)
2914                 try:
2915                     timestamp = datetime.datetime.strptime(x, strpfmt)
2916                 except ValueError:
2917                     continue
2918                 ssfile.setdefault(timestamp, {})["Backup Time"] = timestamp.strftime(
2919                     "%a %b %d %Y %H:%M:%S.%f"
2920                 )
2921                 location = os.path.join(bkdir, x)
2922                 ssfile[timestamp]["Size"] = os.stat(location).st_size
2923                 ssfile[timestamp]["Location"] = location
2924         sfiles = dict(
2925             list(
2926                 zip(
2927                     list(range(n)),
2928                     [ssfile[x] for x in sorted(ssfile, reverse=True)[:limit]],
2929                 )
2930             )
2931         )
2932         sefiles = {i: sfiles}
2933         files.update(sefiles)
2934     return files
2935 def restore_backup(path, backup_id):
2936     path = os.path.expanduser(path)
2937     ret = {"result": False, "comment": "Invalid backup_id '{}'".format(backup_id)}
2938     try:
2939         if len(str(backup_id)) == len(str(int(backup_id))):
2940             backup = list_backups(path)[int(backup_id)]
2941         else:
2942             return ret
2943     except ValueError:
2944         return ret
2945     except KeyError:
2946         ret["comment"] = "backup_id '{}' does not exist for {}".format(backup_id, path)
2947         return ret
2948     salt.utils.files.backup_minion(path, _get_bkroot())
2949     try:
2950         shutil.copyfile(backup["Location"], path)
2951     except OSError as exc:
2952         ret["comment"] = "Unable to restore {} to {}: {}".format(
2953             backup["Location"], path, exc
2954         )
2955         return ret
2956     else:
2957         ret["result"] = True
2958         ret["comment"] = "Successfully restored {} to {}".format(
2959             backup["Location"], path
2960         )
2961     if not salt.utils.platform.is_windows():
2962         try:
2963             fstat = os.stat(path)
2964         except OSError:
2965             ret["comment"] += ", but was unable to set ownership"
2966         else:
2967             os.chown(path, fstat.st_uid, fstat.st_gid)
2968     return ret
2969 def delete_backup(path, backup_id):
2970     path = os.path.expanduser(path)
2971     ret = {"result": False, "comment": "Invalid backup_id '{}'".format(backup_id)}
2972     try:
2973         if len(str(backup_id)) == len(str(int(backup_id))):
2974             backup = list_backups(path)[int(backup_id)]
2975         else:
2976             return ret
2977     except ValueError:
2978         return ret
2979     except KeyError:
2980         ret["comment"] = "backup_id '{}' does not exist for {}".format(backup_id, path)
2981         return ret
2982     try:
2983         os.remove(backup["Location"])
2984     except OSError as exc:
2985         ret["comment"] = "Unable to remove {}: {}".format(backup["Location"], exc)
2986     else:
2987         ret["result"] = True
2988         ret["comment"] = "Successfully removed {}".format(backup["Location"])
2989     return ret
2990 remove_backup = salt.utils.functools.alias_function(delete_backup, "remove_backup")
2991 def grep(path, pattern, *opts):
2992     path = os.path.expanduser(path)
2993     _path = path
2994     path = glob.glob(path)
2995     if not path:
2996         path = _path
2997     split_opts = []
2998     for opt in opts:
2999         try:
3000             split = salt.utils.args.shlex_split(opt)
3001         except AttributeError:
3002             split = salt.utils.args.shlex_split(str(opt))
3003         if len(split) &gt; 1:
3004             raise SaltInvocationError(
3005                 "Passing multiple command line arguments in a single string "
3006                 "is not supported, please pass the following arguments "
3007                 "separately: {}".format(opt)
3008             )
3009         split_opts.extend(split)
3010     if isinstance(path, list):
3011         cmd = ["grep"] + split_opts + [pattern] + path
3012     else:
3013         cmd = ["grep"] + split_opts + [pattern, path]
3014     try:
3015         ret = __salt__["cmd.run_all"](cmd, python_shell=False)
3016     except OSError as exc:
3017         raise CommandExecutionError(exc.strerror)
3018     return ret
3019 def open_files(by_pid=False):
3020     pids = {}
3021     procfs = os.listdir("/proc/")
3022     for pfile in procfs:
3023         try:
3024             pids[int(pfile)] = []
3025         except ValueError:
3026             pass
3027     files = {}
3028     for pid in pids:
3029         ppath = "/proc/{}"<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.format(pid)
3030         try:
3031             tids = os.listdir("{}/task".format(ppath))
3032         except OSError:
3033             continue
3034         fd_ =</b></font> []
3035         for fpath in os.listdir("{}/fd".format(ppath)):
3036             fd_.append("{}/fd/{}".format(ppath, fpath))
3037         for tid in tids:
3038             try:
3039                 fd_.append(os.path.realpath("{}/task/{}/exe".format(ppath, tid)))
3040             except OSError:
3041                 continue
3042             for tpath in os.listdir("{}/task/{}/fd".format(ppath, tid)):
3043                 fd_.append("{}/task/{}/fd/{}".format(ppath, tid, tpath))
3044         fd_ = sorted(set(fd_))
3045         for fdpath in fd_:
3046             try:
3047                 name = os.path.realpath(fdpath)
3048                 os.stat(name)
3049             except OSError:
3050                 continue
3051             if name not in files:
3052                 files[name] = [pid]
3053             else:
3054                 files[name].append(pid)
3055                 files[name] = sorted(set(files[name]))
3056             pids[pid].append(name)
3057             pids[pid] = sorted(set(pids[pid]))
3058     if by_pid:
3059         return pids
3060     return files
3061 def pardir():
3062     return os.path.pardir
3063 def normpath(path):
3064     return os.path.normpath(path)
3065 def basename(path):
3066     return os.path.basename(path)
3067 def dirname(path):
3068     return os.path.dirname(path)
3069 def join(*args):
3070     return os.path.join(*args)
3071 def move(src, dst):
3072     src = os.path.expanduser(src)
3073     dst = os.path.expanduser(dst)
3074     if not os.path.isabs(src):
3075         raise SaltInvocationError("Source path must be absolute.")
3076     if not os.path.isabs(dst):
3077         raise SaltInvocationError("Destination path must be absolute.")
3078     ret = {
3079         "result": True,
3080         "comment": "'{}' moved to '{}'".format(src, dst),
3081     }
3082     try:
3083         shutil.move(src, dst)
3084     except OSError as exc:
3085         raise CommandExecutionError(
3086             "Unable to move '{}' to '{}': {}".format(src, dst, exc)
3087         )
3088     return ret
3089 def diskusage(path):
3090     total_size = 0
3091     seen = set()
3092     if os.path.isfile(path):
3093         stat_structure = os.stat(path)
3094         ret = stat_structure.st_size
3095         return ret
3096     for dirpath, dirnames, filenames in salt.utils.path.os_walk(path):
3097         for f in filenames:
3098             fp = os.path.join(dirpath, f)
3099             try:
3100                 stat_structure = os.stat(fp)
3101             except OSError:
3102                 continue
3103             if stat_structure.st_ino in seen:
3104                 continue
3105             seen.add(stat_structure.st_ino)
3106             total_size += stat_structure.st_size
3107     ret = total_size
3108     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
