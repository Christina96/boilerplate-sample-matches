<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_internet_as_graphs.py & test_isomorphism.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_internet_as_graphs.py & test_isomorphism.py
      </h3>
      <h1 align="center">
        8.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_internet_as_graphs.py (6.004619%)<TH>test_isomorphism.py (17.105263%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2368-0.html#0',2,'match2368-1.html#0',3)" NAME="0">(24-27)<TD><A HREF="javascript:ZweiFrames('match2368-0.html#0',2,'match2368-1.html#0',3)" NAME="0">(16-18)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2368-0.html#1',2,'match2368-1.html#1',3)" NAME="1">(20-23)<TD><A HREF="javascript:ZweiFrames('match2368-0.html#1',2,'match2368-1.html#1',3)" NAME="1">(14-16)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_internet_as_graphs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
from pytest import approx
from networkx import is_connected, neighbors
from networkx.generators.internet_as_graphs import random_internet_as_graph


class TestInternetASTopology:
    @classmethod
    def setup_class(cls):
        cls.n = 1000
        cls.seed = 42
        cls.G = random_internet_as_graph(cls.n, cls.seed)
        cls.T = []
        cls.M = []
        cls.C = []
        cls.CP = []
        cls.customers = {}
<A NAME="1"></A>        cls.providers = {}

        for i in cls.G.nodes():
            if cls<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2368-1.html#1',3,'match2368-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.G.nodes[i][&quot;type&quot;] == &quot;T&quot;:
<A NAME="0"></A>                cls.T.append(i)
            elif cls.G.nodes[i][&quot;type&quot;] == &quot;M&quot;:
                cls.M.</B></FONT>append(i)
            elif cls<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2368-1.html#0',3,'match2368-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.G.nodes[i][&quot;type&quot;] == &quot;C&quot;:
                cls.C.append(i)
            elif cls.G.nodes[i][&quot;type&quot;] == &quot;CP&quot;:
                cls.CP.</B></FONT>append(i)
            else:
                raise ValueError(
                    &quot;Inconsistent data in the graph\
                        node attributes&quot;
                )
            cls.set_customers(i)
            cls.set_providers(i)

    @classmethod
    def set_customers(cls, i):
        if i not in cls.customers:
            cls.customers[i] = set()
            for j in neighbors(cls.G, i):
                e = cls.G.edges[(i, j)]
                if e[&quot;type&quot;] == &quot;transit&quot;:
                    customer = int(e[&quot;customer&quot;])
                    if j == customer:
                        cls.set_customers(j)
                        cls.customers[i] = cls.customers[i].union(cls.customers[j])
                        cls.customers[i].add(j)
                    elif i != customer:
                        raise ValueError(
                            &quot;Inconsistent data in the graph\
                                edge attributes&quot;
                        )

    @classmethod
    def set_providers(cls, i):
        if i not in cls.providers:
            cls.providers[i] = set()
            for j in neighbors(cls.G, i):
                e = cls.G.edges[(i, j)]
                if e[&quot;type&quot;] == &quot;transit&quot;:
                    customer = int(e[&quot;customer&quot;])
                    if i == customer:
                        cls.set_providers(j)
                        cls.providers[i] = cls.providers[i].union(cls.providers[j])
                        cls.providers[i].add(j)
                    elif j != customer:
                        raise ValueError(
                            &quot;Inconsistent data in the graph\
                                edge attributes&quot;
                        )

    def test_wrong_input(self):
        G = random_internet_as_graph(0)
        assert len(G.nodes()) == 0

        G = random_internet_as_graph(-1)
        assert len(G.nodes()) == 0

        G = random_internet_as_graph(1)
        assert len(G.nodes()) == 1

    def test_node_numbers(self):
        assert len(self.G.nodes()) == self.n
        assert len(self.T) &lt; 7
        assert len(self.M) == int(round(self.n * 0.15))
        assert len(self.CP) == int(round(self.n * 0.05))
        numb = self.n - len(self.T) - len(self.M) - len(self.CP)
        assert len(self.C) == numb

    def test_connectivity(self):
        assert is_connected(self.G)

    def test_relationships(self):
        # T nodes are not customers of anyone
        for i in self.T:
            assert len(self.providers[i]) == 0

        # C nodes are not providers of anyone
        for i in self.C:
            assert len(self.customers[i]) == 0

        # CP nodes are not providers of anyone
        for i in self.CP:
            assert len(self.customers[i]) == 0

        # test whether there is a customer-provider loop
        for i in self.G.nodes():
            assert len(self.customers[i].intersection(self.providers[i])) == 0

        # test whether there is a peering with a customer or provider
        for i, j in self.G.edges():
            if self.G.edges[(i, j)][&quot;type&quot;] == &quot;peer&quot;:
                assert j not in self.customers[i]
                assert i not in self.customers[j]
                assert j not in self.providers[i]
                assert i not in self.providers[j]

    def test_degree_values(self):
        d_m = 0  # multihoming degree for M nodes
        d_cp = 0  # multihoming degree for CP nodes
        d_c = 0  # multihoming degree for C nodes
        p_m_m = 0  # avg number of peering edges between M and M
        p_cp_m = 0  # avg number of peering edges between CP and M
        p_cp_cp = 0  # avg number of peering edges between CP and CP
        t_m = 0  # probability M's provider is T
        t_cp = 0  # probability CP's provider is T
        t_c = 0  # probability C's provider is T

        for i, j in self.G.edges():
            e = self.G.edges[(i, j)]
            if e[&quot;type&quot;] == &quot;transit&quot;:
                cust = int(e[&quot;customer&quot;])
                if i == cust:
                    prov = j
                elif j == cust:
                    prov = i
                else:
                    raise ValueError(
                        &quot;Inconsistent data in the graph edge\
                            attributes&quot;
                    )
                if cust in self.M:
                    d_m += 1
                    if self.G.nodes[prov][&quot;type&quot;] == &quot;T&quot;:
                        t_m += 1
                elif cust in self.C:
                    d_c += 1
                    if self.G.nodes[prov][&quot;type&quot;] == &quot;T&quot;:
                        t_c += 1
                elif cust in self.CP:
                    d_cp += 1
                    if self.G.nodes[prov][&quot;type&quot;] == &quot;T&quot;:
                        t_cp += 1
                else:
                    raise ValueError(
                        &quot;Inconsistent data in the graph edge\
                            attributes&quot;
                    )
            elif e[&quot;type&quot;] == &quot;peer&quot;:
                if self.G.nodes[i][&quot;type&quot;] == &quot;M&quot; and self.G.nodes[j][&quot;type&quot;] == &quot;M&quot;:
                    p_m_m += 1
                if self.G.nodes[i][&quot;type&quot;] == &quot;CP&quot; and self.G.nodes[j][&quot;type&quot;] == &quot;CP&quot;:
                    p_cp_cp += 1
                if (
                    self.G.nodes[i][&quot;type&quot;] == &quot;M&quot;
                    and self.G.nodes[j][&quot;type&quot;] == &quot;CP&quot;
                    or self.G.nodes[i][&quot;type&quot;] == &quot;CP&quot;
                    and self.G.nodes[j][&quot;type&quot;] == &quot;M&quot;
                ):
                    p_cp_m += 1
            else:
                raise ValueError(
                    &quot;Unexpected data in the graph edge\
                        attributes&quot;
                )

        assert d_m / len(self.M) == approx((2 + (2.5 * self.n) / 10000), abs=1e-0)
        assert d_cp / len(self.CP) == approx((2 + (1.5 * self.n) / 10000), abs=1e-0)
        assert d_c / len(self.C) == approx((1 + (5 * self.n) / 100000), abs=1e-0)

        assert p_m_m / len(self.M) == approx((1 + (2 * self.n) / 10000), abs=1e-0)
        assert p_cp_m / len(self.CP) == approx((0.2 + (2 * self.n) / 10000), abs=1e-0)
        assert p_cp_cp / len(self.CP) == approx(
            (0.05 + (2 * self.n) / 100000), abs=1e-0
        )

        assert t_m / d_m == approx(0.375, abs=1e-1)
        assert t_cp / d_cp == approx(0.375, abs=1e-1)
        assert t_c / d_c == approx(0.125, abs=1e-1)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_isomorphism.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import networkx as nx
from networkx.algorithms import isomorphism as iso


class TestIsomorph:
    @classmethod
    def setup_class(cls):
        cls.G1 = nx.Graph()
        cls.G2 = nx.Graph()
        cls.G3 = nx.Graph()
<A NAME="1"></A>        cls.G4 = nx.Graph()
        cls.G5 = nx.Graph()
<A NAME="0"></A>        cls.G6 = nx.Graph()
        cls.G1.add_edges_from([[<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2368-0.html#1',2,'match2368-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>1, 2], [1, 3], [1, 5], [2, 3]])
        cls.G2.add_edges_from([[10, 20], [20, 30], [10, 30], [10, 50]])
        cls.</B></FONT>G3.add_edges_from([[<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2368-0.html#0',2,'match2368-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>1, 2], [1, 3], [1, 5], [2, 5]])
        cls.G4.add_edges_from([[1, 2], [1, 3], [1, 5], [2, 4]])
        cls.</B></FONT>G5.add_edges_from([[1, 2], [1, 3]])
        cls.G6.add_edges_from([[10, 20], [20, 30], [10, 30], [10, 50], [20, 50]])

    def test_could_be_isomorphic(self):
        assert iso.could_be_isomorphic(self.G1, self.G2)
        assert iso.could_be_isomorphic(self.G1, self.G3)
        assert not iso.could_be_isomorphic(self.G1, self.G4)
        assert iso.could_be_isomorphic(self.G3, self.G2)
        assert not iso.could_be_isomorphic(self.G1, self.G6)

    def test_fast_could_be_isomorphic(self):
        assert iso.fast_could_be_isomorphic(self.G3, self.G2)
        assert not iso.fast_could_be_isomorphic(self.G3, self.G5)
        assert not iso.fast_could_be_isomorphic(self.G1, self.G6)

    def test_faster_could_be_isomorphic(self):
        assert iso.faster_could_be_isomorphic(self.G3, self.G2)
        assert not iso.faster_could_be_isomorphic(self.G3, self.G5)
        assert not iso.faster_could_be_isomorphic(self.G1, self.G6)

    def test_is_isomorphic(self):
        assert iso.is_isomorphic(self.G1, self.G2)
        assert not iso.is_isomorphic(self.G1, self.G4)
</PRE>
</div>
  </div>
</body>
</html>
