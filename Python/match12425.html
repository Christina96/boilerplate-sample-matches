<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_multigraph.py & test_cuts.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_multigraph.py & test_cuts.py
      </h3>
      <h1 align="center">
        1.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_multigraph.py (1.451613%)<TH>test_cuts.py (2.9850745%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match12425-0.html#0',2,'match12425-1.html#0',3)" NAME="0">(447-448)<TD><A HREF="javascript:ZweiFrames('match12425-0.html#0',2,'match12425-1.html#0',3)" NAME="0">(52-68)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_multigraph.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest

import networkx as nx
from networkx.utils import edges_equal

from .test_graph import BaseAttrGraphTester
from .test_graph import TestGraph as _TestGraph


class BaseMultiGraphTester(BaseAttrGraphTester):
    def test_has_edge(self):
        G = self.K3
        assert G.has_edge(0, 1)
        assert not G.has_edge(0, -1)
        assert G.has_edge(0, 1, 0)
        assert not G.has_edge(0, 1, 1)

    def test_get_edge_data(self):
        G = self.K3
        assert G.get_edge_data(0, 1) == {0: {}}
        assert G[0][1] == {0: {}}
        assert G[0][1][0] == {}
        assert G.get_edge_data(10, 20) is None
        assert G.get_edge_data(0, 1, 0) == {}

    def test_adjacency(self):
        G = self.K3
        assert dict(G.adjacency()) == {
            0: {1: {0: {}}, 2: {0: {}}},
            1: {0: {0: {}}, 2: {0: {}}},
            2: {0: {0: {}}, 1: {0: {}}},
        }

    def deepcopy_edge_attr(self, H, G):
        assert G[1][2][0][&quot;foo&quot;] == H[1][2][0][&quot;foo&quot;]
        G[1][2][0][&quot;foo&quot;].append(1)
        assert G[1][2][0][&quot;foo&quot;] != H[1][2][0][&quot;foo&quot;]

    def shallow_copy_edge_attr(self, H, G):
        assert G[1][2][0][&quot;foo&quot;] == H[1][2][0][&quot;foo&quot;]
        G[1][2][0][&quot;foo&quot;].append(1)
        assert G[1][2][0][&quot;foo&quot;] == H[1][2][0][&quot;foo&quot;]

    def graphs_equal(self, H, G):
        assert G._adj == H._adj
        assert G._node == H._node
        assert G.graph == H.graph
        assert G.name == H.name
        if not G.is_directed() and not H.is_directed():
            assert H._adj[1][2][0] is H._adj[2][1][0]
            assert G._adj[1][2][0] is G._adj[2][1][0]
        else:  # at least one is directed
            if not G.is_directed():
                G._pred = G._adj
                G._succ = G._adj
            if not H.is_directed():
                H._pred = H._adj
                H._succ = H._adj
            assert G._pred == H._pred
            assert G._succ == H._succ
            assert H._succ[1][2][0] is H._pred[2][1][0]
            assert G._succ[1][2][0] is G._pred[2][1][0]

    def same_attrdict(self, H, G):
        # same attrdict in the edgedata
        old_foo = H[1][2][0][&quot;foo&quot;]
        H.adj[1][2][0][&quot;foo&quot;] = &quot;baz&quot;
        assert G._adj == H._adj
        H.adj[1][2][0][&quot;foo&quot;] = old_foo
        assert G._adj == H._adj

        old_foo = H.nodes[0][&quot;foo&quot;]
        H.nodes[0][&quot;foo&quot;] = &quot;baz&quot;
        assert G._node == H._node
        H.nodes[0][&quot;foo&quot;] = old_foo
        assert G._node == H._node

    def different_attrdict(self, H, G):
        # used by graph_equal_but_different
        old_foo = H[1][2][0][&quot;foo&quot;]
        H.adj[1][2][0][&quot;foo&quot;] = &quot;baz&quot;
        assert G._adj != H._adj
        H.adj[1][2][0][&quot;foo&quot;] = old_foo
        assert G._adj == H._adj

        old_foo = H.nodes[0][&quot;foo&quot;]
        H.nodes[0][&quot;foo&quot;] = &quot;baz&quot;
        assert G._node != H._node
        H.nodes[0][&quot;foo&quot;] = old_foo
        assert G._node == H._node

    def test_to_undirected(self):
        G = self.K3
        self.add_attributes(G)
        H = nx.MultiGraph(G)
        self.is_shallow_copy(H, G)
        H = G.to_undirected()
        self.is_deepcopy(H, G)

    def test_to_directed(self):
        G = self.K3
        self.add_attributes(G)
        H = nx.MultiDiGraph(G)
        self.is_shallow_copy(H, G)
        H = G.to_directed()
        self.is_deepcopy(H, G)

    def test_number_of_edges_selfloops(self):
        G = self.K3
        G.add_edge(0, 0)
        G.add_edge(0, 0)
        G.add_edge(0, 0, key=&quot;parallel edge&quot;)
        G.remove_edge(0, 0, key=&quot;parallel edge&quot;)
        assert G.number_of_edges(0, 0) == 2
        G.remove_edge(0, 0)
        assert G.number_of_edges(0, 0) == 1

    def test_edge_lookup(self):
        G = self.Graph()
        G.add_edge(1, 2, foo=&quot;bar&quot;)
        G.add_edge(1, 2, &quot;key&quot;, foo=&quot;biz&quot;)
        assert edges_equal(G.edges[1, 2, 0], {&quot;foo&quot;: &quot;bar&quot;})
        assert edges_equal(G.edges[1, 2, &quot;key&quot;], {&quot;foo&quot;: &quot;biz&quot;})

    def test_edge_attr4(self):
        G = self.Graph()
        G.add_edge(1, 2, key=0, data=7, spam=&quot;bar&quot;, bar=&quot;foo&quot;)
        assert edges_equal(
            G.edges(data=True), [(1, 2, {&quot;data&quot;: 7, &quot;spam&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;foo&quot;})]
        )
        G[1][2][0][&quot;data&quot;] = 10  # OK to set data like this
        assert edges_equal(
            G.edges(data=True), [(1, 2, {&quot;data&quot;: 10, &quot;spam&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;foo&quot;})]
        )

        G.adj[1][2][0][&quot;data&quot;] = 20
        assert edges_equal(
            G.edges(data=True), [(1, 2, {&quot;data&quot;: 20, &quot;spam&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;foo&quot;})]
        )
        G.edges[1, 2, 0][&quot;data&quot;] = 21  # another spelling, &quot;edge&quot;
        assert edges_equal(
            G.edges(data=True), [(1, 2, {&quot;data&quot;: 21, &quot;spam&quot;: &quot;bar&quot;, &quot;bar&quot;: &quot;foo&quot;})]
        )
        G.adj[1][2][0][&quot;listdata&quot;] = [20, 200]
        G.adj[1][2][0][&quot;weight&quot;] = 20
        assert edges_equal(
            G.edges(data=True),
            [
                (
                    1,
                    2,
                    {
                        &quot;data&quot;: 21,
                        &quot;spam&quot;: &quot;bar&quot;,
                        &quot;bar&quot;: &quot;foo&quot;,
                        &quot;listdata&quot;: [20, 200],
                        &quot;weight&quot;: 20,
                    },
                )
            ],
        )


class TestMultiGraph(BaseMultiGraphTester, _TestGraph):
    def setup_method(self):
        self.Graph = nx.MultiGraph
        # build K3
        ed1, ed2, ed3 = ({0: {}}, {0: {}}, {0: {}})
        self.k3adj = {0: {1: ed1, 2: ed2}, 1: {0: ed1, 2: ed3}, 2: {0: ed2, 1: ed3}}
        self.k3edges = [(0, 1), (0, 2), (1, 2)]
        self.k3nodes = [0, 1, 2]
        self.K3 = self.Graph()
        self.K3._adj = self.k3adj
        self.K3._node = {}
        self.K3._node[0] = {}
        self.K3._node[1] = {}
        self.K3._node[2] = {}

    def test_data_input(self):
        G = self.Graph({1: [2], 2: [1]}, name=&quot;test&quot;)
        assert G.name == &quot;test&quot;
        expected = [(1, {2: {0: {}}}), (2, {1: {0: {}}})]
        assert sorted(G.adj.items()) == expected

    def test_data_multigraph_input(self):
        # standard case with edge keys and edge data
        edata0 = dict(w=200, s=&quot;foo&quot;)
        edata1 = dict(w=201, s=&quot;bar&quot;)
        keydict = {0: edata0, 1: edata1}
        dododod = {&quot;a&quot;: {&quot;b&quot;: keydict}}

        multiple_edge = [(&quot;a&quot;, &quot;b&quot;, 0, edata0), (&quot;a&quot;, &quot;b&quot;, 1, edata1)]
        single_edge = [(&quot;a&quot;, &quot;b&quot;, 0, keydict)]

        G = self.Graph(dododod, multigraph_input=True)
        assert list(G.edges(keys=True, data=True)) == multiple_edge
        G = self.Graph(dododod, multigraph_input=None)
        assert list(G.edges(keys=True, data=True)) == multiple_edge
        G = self.Graph(dododod, multigraph_input=False)
        assert list(G.edges(keys=True, data=True)) == single_edge

        # test round-trip to_dict_of_dict and MultiGraph constructor
        G = self.Graph(dododod, multigraph_input=True)
        H = self.Graph(nx.to_dict_of_dicts(G))
        assert nx.is_isomorphic(G, H) is True  # test that default is True
        for mgi in [True, False]:
            H = self.Graph(nx.to_dict_of_dicts(G), multigraph_input=mgi)
            assert nx.is_isomorphic(G, H) == mgi

    # Set up cases for when incoming_graph_data is not multigraph_input
    etraits = {&quot;w&quot;: 200, &quot;s&quot;: &quot;foo&quot;}
    egraphics = {&quot;color&quot;: &quot;blue&quot;, &quot;shape&quot;: &quot;box&quot;}
    edata = {&quot;traits&quot;: etraits, &quot;graphics&quot;: egraphics}
    dodod1 = {&quot;a&quot;: {&quot;b&quot;: edata}}
    dodod2 = {&quot;a&quot;: {&quot;b&quot;: etraits}}
    dodod3 = {&quot;a&quot;: {&quot;b&quot;: {&quot;traits&quot;: etraits, &quot;s&quot;: &quot;foo&quot;}}}
    dol = {&quot;a&quot;: [&quot;b&quot;]}

    multiple_edge = [(&quot;a&quot;, &quot;b&quot;, &quot;traits&quot;, etraits), (&quot;a&quot;, &quot;b&quot;, &quot;graphics&quot;, egraphics)]
    single_edge = [(&quot;a&quot;, &quot;b&quot;, 0, {})]  # type: ignore
    single_edge1 = [(&quot;a&quot;, &quot;b&quot;, 0, edata)]
    single_edge2 = [(&quot;a&quot;, &quot;b&quot;, 0, etraits)]
    single_edge3 = [(&quot;a&quot;, &quot;b&quot;, 0, {&quot;traits&quot;: etraits, &quot;s&quot;: &quot;foo&quot;})]

    cases = [  # (dod, mgi, edges)
        (dodod1, True, multiple_edge),
        (dodod1, False, single_edge1),
        (dodod2, False, single_edge2),
        (dodod3, False, single_edge3),
        (dol, False, single_edge),
    ]

    @pytest.mark.parametrize(&quot;dod, mgi, edges&quot;, cases)
    def test_non_multigraph_input(self, dod, mgi, edges):
        G = self.Graph(dod, multigraph_input=mgi)
        assert list(G.edges(keys=True, data=True)) == edges
        G = nx.to_networkx_graph(dod, create_using=self.Graph, multigraph_input=mgi)
        assert list(G.edges(keys=True, data=True)) == edges

    mgi_none_cases = [
        (dodod1, multiple_edge),
        (dodod2, single_edge2),
        (dodod3, single_edge3),
    ]

    @pytest.mark.parametrize(&quot;dod, edges&quot;, mgi_none_cases)
    def test_non_multigraph_input_mgi_none(self, dod, edges):
        # test constructor without to_networkx_graph for mgi=None
        G = self.Graph(dod)
        assert list(G.edges(keys=True, data=True)) == edges

    raise_cases = [dodod2, dodod3, dol]

    @pytest.mark.parametrize(&quot;dod&quot;, raise_cases)
    def test_non_multigraph_input_raise(self, dod):
        # cases where NetworkXError is raised
        pytest.raises(nx.NetworkXError, self.Graph, dod, multigraph_input=True)
        pytest.raises(
            nx.NetworkXError,
            nx.to_networkx_graph,
            dod,
            create_using=self.Graph,
            multigraph_input=True,
        )

    def test_getitem(self):
        G = self.K3
        assert G[0] == {1: {0: {}}, 2: {0: {}}}
        with pytest.raises(KeyError):
            G.__getitem__(&quot;j&quot;)
        with pytest.raises(TypeError):
            G.__getitem__([&quot;A&quot;])

    def test_remove_node(self):
        G = self.K3
        G.remove_node(0)
        assert G.adj == {1: {2: {0: {}}}, 2: {1: {0: {}}}}
        with pytest.raises(nx.NetworkXError):
            G.remove_node(-1)

    def test_add_edge(self):
        G = self.Graph()
        G.add_edge(0, 1)
        assert G.adj == {0: {1: {0: {}}}, 1: {0: {0: {}}}}
        G = self.Graph()
        G.add_edge(*(0, 1))
        assert G.adj == {0: {1: {0: {}}}, 1: {0: {0: {}}}}

    def test_add_edge_conflicting_key(self):
        G = self.Graph()
        G.add_edge(0, 1, key=1)
        G.add_edge(0, 1)
        assert G.number_of_edges() == 2
        G = self.Graph()
        G.add_edges_from([(0, 1, 1, {})])
        G.add_edges_from([(0, 1)])
        assert G.number_of_edges() == 2

    def test_add_edges_from(self):
        G = self.Graph()
        G.add_edges_from([(0, 1), (0, 1, {&quot;weight&quot;: 3})])
        assert G.adj == {
            0: {1: {0: {}, 1: {&quot;weight&quot;: 3}}},
            1: {0: {0: {}, 1: {&quot;weight&quot;: 3}}},
        }
        G.add_edges_from([(0, 1), (0, 1, {&quot;weight&quot;: 3})], weight=2)
        assert G.adj == {
            0: {1: {0: {}, 1: {&quot;weight&quot;: 3}, 2: {&quot;weight&quot;: 2}, 3: {&quot;weight&quot;: 3}}},
            1: {0: {0: {}, 1: {&quot;weight&quot;: 3}, 2: {&quot;weight&quot;: 2}, 3: {&quot;weight&quot;: 3}}},
        }
        G = self.Graph()
        edges = [
            (0, 1, {&quot;weight&quot;: 3}),
            (0, 1, ((&quot;weight&quot;, 2),)),
            (0, 1, 5),
            (0, 1, &quot;s&quot;),
        ]
        G.add_edges_from(edges)
        keydict = {0: {&quot;weight&quot;: 3}, 1: {&quot;weight&quot;: 2}, 5: {}, &quot;s&quot;: {}}
        assert G._adj == {0: {1: keydict}, 1: {0: keydict}}

        # too few in tuple
        with pytest.raises(nx.NetworkXError):
            G.add_edges_from([(0,)])
        # too many in tuple
        with pytest.raises(nx.NetworkXError):
            G.add_edges_from([(0, 1, 2, 3, 4)])
        # not a tuple
        with pytest.raises(TypeError):
            G.add_edges_from([0])

    def test_remove_edge(self):
        G = self.K3
        G.remove_edge(0, 1)
        assert G.adj == {0: {2: {0: {}}}, 1: {2: {0: {}}}, 2: {0: {0: {}}, 1: {0: {}}}}

        with pytest.raises(nx.NetworkXError):
            G.remove_edge(-1, 0)
        with pytest.raises(nx.NetworkXError):
            G.remove_edge(0, 2, key=1)

    def test_remove_edges_from(self):
        G = self.K3.copy()
        G.remove_edges_from([(0, 1)])
        kd = {0: {}}
        assert G.adj == {0: {2: kd}, 1: {2: kd}, 2: {0: kd, 1: kd}}
        G.remove_edges_from([(0, 0)])  # silent fail
        self.K3.add_edge(0, 1)
        G = self.K3.copy()
        G.remove_edges_from(list(G.edges(data=True, keys=True)))
        assert G.adj == {0: {}, 1: {}, 2: {}}
        G = self.K3.copy()
        G.remove_edges_from(list(G.edges(data=False, keys=True)))
        assert G.adj == {0: {}, 1: {}, 2: {}}
        G = self.K3.copy()
        G.remove_edges_from(list(G.edges(data=False, keys=False)))
        assert G.adj == {0: {}, 1: {}, 2: {}}
        G = self.K3.copy()
        G.remove_edges_from([(0, 1, 0), (0, 2, 0, {}), (1, 2)])
        assert G.adj == {0: {1: {1: {}}}, 1: {0: {1: {}}}, 2: {}}

    def test_remove_multiedge(self):
        G = self.K3
        G.add_edge(0, 1, key=&quot;parallel edge&quot;)
        G.remove_edge(0, 1, key=&quot;parallel edge&quot;)
        assert G.adj == {
            0: {1: {0: {}}, 2: {0: {}}},
            1: {0: {0: {}}, 2: {0: {}}},
            2: {0: {0: {}}, 1: {0: {}}},
        }
        G.remove_edge(0, 1)
        kd = {0: {}}
        assert G.adj == {0: {2: kd}, 1: {2: kd}, 2: {0: kd, 1: kd}}
        with pytest.raises(nx.NetworkXError):
            G.remove_edge(-1, 0)


class TestEdgeSubgraph:
    &quot;&quot;&quot;Unit tests for the :meth:`MultiGraph.edge_subgraph` method.&quot;&quot;&quot;

    def setup_method(self):
        # Create a doubly-linked path graph on five nodes.
        G = nx.MultiGraph()
        nx.add_path(G, range(5))
        nx.add_path(G, range(5))
        # Add some node, edge, and graph attributes.
        for i in range(5):
            G.nodes[i][&quot;name&quot;] = f&quot;node{i}&quot;
        G.adj[0][1][0][&quot;name&quot;] = &quot;edge010&quot;
        G.adj[0][1][1][&quot;name&quot;] = &quot;edge011&quot;
        G.adj[3][4][0][&quot;name&quot;] = &quot;edge340&quot;
        G.adj[3][4][1][&quot;name&quot;] = &quot;edge341&quot;
        G.graph[&quot;name&quot;] = &quot;graph&quot;
        # Get the subgraph induced by one of the first edges and one of
        # the last edges.
        self.G = G
        self.H = G.edge_subgraph([(0, 1, 0), (3, 4, 1)])

    def test_correct_nodes(self):
        &quot;&quot;&quot;Tests that the subgraph has the correct nodes.&quot;&quot;&quot;
        assert [0, 1, 3, 4] == sorted(self.H.nodes())

    def test_correct_edges(self):
        &quot;&quot;&quot;Tests that the subgraph has the correct edges.&quot;&quot;&quot;
        assert [(0, 1, 0, &quot;edge010&quot;), (3, 4, 1, &quot;edge341&quot;)] == sorted(
            self.H.edges(keys=True, data=&quot;name&quot;)
        )

    def test_add_node(self):
        &quot;&quot;&quot;Tests that adding a node to the original graph does not
        affect the nodes of the subgraph.

        &quot;&quot;&quot;
        self.G.add_node(5)
        assert [0, 1, 3, 4] == sorted(self.H.nodes())

    def test_remove_node(self):
        &quot;&quot;&quot;Tests that removing a node in the original graph does
        affect the nodes of the subgraph.

        &quot;&quot;&quot;
        self.G.remove_node(0)
        assert [1, 3, 4] == sorted(self.H.nodes())

    def test_node_attr_dict(self):
        &quot;&quot;&quot;Tests that the node attribute dictionary of the two graphs is
        the same object.

        &quot;&quot;&quot;
        for v in self.H:
            assert self.G.nodes[v] == self.H.nodes[v]
        # Making a change to G should make a change in H and vice versa.
        self.G.nodes[0][&quot;name&quot;] = &quot;foo&quot;
        assert self.G.nodes[0] == self.H.nodes[0]
        self.H.nodes[1][&quot;name&quot;] = &quot;bar&quot;
        assert self.G.nodes[1] == self.H.nodes[1]

    def test_edge_attr_dict(self):
        &quot;&quot;&quot;Tests that the edge attribute dictionary of the two graphs is
        the same object.

        &quot;&quot;&quot;
        for u, v, k in self.H.edges(keys=True):
<A NAME="0"></A>            assert self.G._adj[u][v][k] == self.H._adj[u][v][k]
        # Making a change to G should make a change in H and vice versa.
        self.G._adj[0][1][0][&quot;name&quot;] = &quot;foo&quot;
        assert self<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match12425-1.html#0',3,'match12425-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.G._adj[0][1][0][&quot;name&quot;] == self.H._adj[0][1][0][&quot;name&quot;]
        self.H._adj[3][4][1][</B></FONT>&quot;name&quot;] = &quot;bar&quot;
        assert self.G._adj[3][4][1][&quot;name&quot;] == self.H._adj[3][4][1][&quot;name&quot;]

    def test_graph_attr_dict(self):
        &quot;&quot;&quot;Tests that the graph attribute dictionary of the two graphs
        is the same object.

        &quot;&quot;&quot;
        assert self.G.graph is self.H.graph


def test_multigraph_add_edges_from_four_tuple_misordered():
    &quot;&quot;&quot;add_edges_from expects 4-tuples of the format (u, v, key, data_dict).

    Ensure 4-tuples of form (u, v, data_dict, key) raises exception.
    &quot;&quot;&quot;
    G = nx.MultiGraph()
    with pytest.raises(TypeError):
        # key/data values flipped in 4-tuple
        G.add_edges_from([(0, 1, {&quot;color&quot;: &quot;red&quot;}, 0)])
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cuts.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest

import networkx as nx
from networkx.algorithms import flow
from networkx.algorithms.connectivity import minimum_st_edge_cut
from networkx.algorithms.connectivity import minimum_st_node_cut
from networkx.utils import arbitrary_element

flow_funcs = [
    flow.boykov_kolmogorov,
    flow.dinitz,
    flow.edmonds_karp,
    flow.preflow_push,
    flow.shortest_augmenting_path,
]

# Tests for node and edge cutsets


def _generate_no_biconnected(max_attempts=50):
    attempts = 0
    while True:
        G = nx.fast_gnp_random_graph(100, 0.0575, seed=42)
        if nx.is_connected(G) and not nx.is_biconnected(G):
            attempts = 0
            yield G
        else:
            if attempts &gt;= max_attempts:
                msg = f&quot;Tried {attempts} times: no suitable Graph.&quot;
                raise Exception(msg)
            else:
                attempts += 1


def test_articulation_points():
    Ggen = _generate_no_biconnected()
    for flow_func in flow_funcs:
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        for i in range(1):  # change 1 to 3 or more for more realizations.
            G = next(Ggen)
            cut = nx.minimum_node_cut(G, flow_func=flow_func)
            assert len(cut) == 1, errmsg
            assert cut.pop() in set(nx.articulation_points(G)), errmsg


def test_brandes_erlebach_book():
    # Figure 1 chapter 7: Connectivity
    # http://www.informatik.uni-augsburg.de/thi/personen/kammer/Graph_Connectivity.pdf
<A NAME="0"></A>    G = nx.Graph()
    G.add_edges_from(
        [
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12425-0.html#0',2,'match12425-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(1, 2),
            (1, 3),
            (1, 4),
            (1, 5),
            (2, 3),
            (2, 6),
            (3, 4),
            (3, 6),
            (4, 6),
            (4, 7),
            (5, 7),
            (6, 8),
            (6, 9),
            (7, 8),
            (7, 10),
            (8, 11),
            (9</B></FONT>, 10),
            (9, 11),
            (10, 11),
        ]
    )
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge cutsets
        assert 3 == len(nx.minimum_edge_cut(G, 1, 11, **kwargs)), errmsg
        edge_cut = nx.minimum_edge_cut(G, **kwargs)
        # Node 5 has only two edges
        assert 2 == len(edge_cut), errmsg
        H = G.copy()
        H.remove_edges_from(edge_cut)
        assert not nx.is_connected(H), errmsg
        # node cuts
        assert {6, 7} == minimum_st_node_cut(G, 1, 11, **kwargs), errmsg
        assert {6, 7} == nx.minimum_node_cut(G, 1, 11, **kwargs), errmsg
        node_cut = nx.minimum_node_cut(G, **kwargs)
        assert 2 == len(node_cut), errmsg
        H = G.copy()
        H.remove_nodes_from(node_cut)
        assert not nx.is_connected(H), errmsg


def test_white_harary_paper():
    # Figure 1b white and harary (2001)
    # https://doi.org/10.1111/0081-1750.00098
    # A graph with high adhesion (edge connectivity) and low cohesion
    # (node connectivity)
    G = nx.disjoint_union(nx.complete_graph(4), nx.complete_graph(4))
    G.remove_node(7)
    for i in range(4, 7):
        G.add_edge(0, i)
    G = nx.disjoint_union(G, nx.complete_graph(4))
    G.remove_node(G.order() - 1)
    for i in range(7, 10):
        G.add_edge(0, i)
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge cuts
        edge_cut = nx.minimum_edge_cut(G, **kwargs)
        assert 3 == len(edge_cut), errmsg
        H = G.copy()
        H.remove_edges_from(edge_cut)
        assert not nx.is_connected(H), errmsg
        # node cuts
        node_cut = nx.minimum_node_cut(G, **kwargs)
        assert {0} == node_cut, errmsg
        H = G.copy()
        H.remove_nodes_from(node_cut)
        assert not nx.is_connected(H), errmsg


def test_petersen_cutset():
    G = nx.petersen_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge cuts
        edge_cut = nx.minimum_edge_cut(G, **kwargs)
        assert 3 == len(edge_cut), errmsg
        H = G.copy()
        H.remove_edges_from(edge_cut)
        assert not nx.is_connected(H), errmsg
        # node cuts
        node_cut = nx.minimum_node_cut(G, **kwargs)
        assert 3 == len(node_cut), errmsg
        H = G.copy()
        H.remove_nodes_from(node_cut)
        assert not nx.is_connected(H), errmsg


def test_octahedral_cutset():
    G = nx.octahedral_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge cuts
        edge_cut = nx.minimum_edge_cut(G, **kwargs)
        assert 4 == len(edge_cut), errmsg
        H = G.copy()
        H.remove_edges_from(edge_cut)
        assert not nx.is_connected(H), errmsg
        # node cuts
        node_cut = nx.minimum_node_cut(G, **kwargs)
        assert 4 == len(node_cut), errmsg
        H = G.copy()
        H.remove_nodes_from(node_cut)
        assert not nx.is_connected(H), errmsg


def test_icosahedral_cutset():
    G = nx.icosahedral_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge cuts
        edge_cut = nx.minimum_edge_cut(G, **kwargs)
        assert 5 == len(edge_cut), errmsg
        H = G.copy()
        H.remove_edges_from(edge_cut)
        assert not nx.is_connected(H), errmsg
        # node cuts
        node_cut = nx.minimum_node_cut(G, **kwargs)
        assert 5 == len(node_cut), errmsg
        H = G.copy()
        H.remove_nodes_from(node_cut)
        assert not nx.is_connected(H), errmsg


def test_node_cutset_exception():
    G = nx.Graph()
    G.add_edges_from([(1, 2), (3, 4)])
    for flow_func in flow_funcs:
        pytest.raises(nx.NetworkXError, nx.minimum_node_cut, G, flow_func=flow_func)


def test_node_cutset_random_graphs():
    for flow_func in flow_funcs:
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        for i in range(3):
            G = nx.fast_gnp_random_graph(50, 0.25, seed=42)
            if not nx.is_connected(G):
                ccs = iter(nx.connected_components(G))
                start = arbitrary_element(next(ccs))
                G.add_edges_from((start, arbitrary_element(c)) for c in ccs)
            cutset = nx.minimum_node_cut(G, flow_func=flow_func)
            assert nx.node_connectivity(G) == len(cutset), errmsg
            G.remove_nodes_from(cutset)
            assert not nx.is_connected(G), errmsg


def test_edge_cutset_random_graphs():
    for flow_func in flow_funcs:
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        for i in range(3):
            G = nx.fast_gnp_random_graph(50, 0.25, seed=42)
            if not nx.is_connected(G):
                ccs = iter(nx.connected_components(G))
                start = arbitrary_element(next(ccs))
                G.add_edges_from((start, arbitrary_element(c)) for c in ccs)
            cutset = nx.minimum_edge_cut(G, flow_func=flow_func)
            assert nx.edge_connectivity(G) == len(cutset), errmsg
            G.remove_edges_from(cutset)
            assert not nx.is_connected(G), errmsg


def test_empty_graphs():
    G = nx.Graph()
    D = nx.DiGraph()
    for interface_func in [nx.minimum_node_cut, nx.minimum_edge_cut]:
        for flow_func in flow_funcs:
            pytest.raises(
                nx.NetworkXPointlessConcept, interface_func, G, flow_func=flow_func
            )
            pytest.raises(
                nx.NetworkXPointlessConcept, interface_func, D, flow_func=flow_func
            )


def test_unbounded():
    G = nx.complete_graph(5)
    for flow_func in flow_funcs:
        assert 4 == len(minimum_st_edge_cut(G, 1, 4, flow_func=flow_func))


def test_missing_source():
    G = nx.path_graph(4)
    for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
        for flow_func in flow_funcs:
            pytest.raises(
                nx.NetworkXError, interface_func, G, 10, 1, flow_func=flow_func
            )


def test_missing_target():
    G = nx.path_graph(4)
    for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
        for flow_func in flow_funcs:
            pytest.raises(
                nx.NetworkXError, interface_func, G, 1, 10, flow_func=flow_func
            )


def test_not_weakly_connected():
    G = nx.DiGraph()
    nx.add_path(G, [1, 2, 3])
    nx.add_path(G, [4, 5])
    for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
        for flow_func in flow_funcs:
            pytest.raises(nx.NetworkXError, interface_func, G, flow_func=flow_func)


def test_not_connected():
    G = nx.Graph()
    nx.add_path(G, [1, 2, 3])
    nx.add_path(G, [4, 5])
    for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
        for flow_func in flow_funcs:
            pytest.raises(nx.NetworkXError, interface_func, G, flow_func=flow_func)


def tests_min_cut_complete():
    G = nx.complete_graph(5)
    for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
        for flow_func in flow_funcs:
            assert 4 == len(interface_func(G, flow_func=flow_func))


def tests_min_cut_complete_directed():
    G = nx.complete_graph(5)
    G = G.to_directed()
    for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
        for flow_func in flow_funcs:
            assert 4 == len(interface_func(G, flow_func=flow_func))


def tests_minimum_st_node_cut():
    G = nx.Graph()
    G.add_nodes_from([0, 1, 2, 3, 7, 8, 11, 12])
    G.add_edges_from([(7, 11), (1, 11), (1, 12), (12, 8), (0, 1)])
    nodelist = minimum_st_node_cut(G, 7, 11)
    assert nodelist == {}


def test_invalid_auxiliary():
    G = nx.complete_graph(5)
    pytest.raises(nx.NetworkXError, minimum_st_node_cut, G, 0, 3, auxiliary=G)


def test_interface_only_source():
    G = nx.complete_graph(5)
    for interface_func in [nx.minimum_node_cut, nx.minimum_edge_cut]:
        pytest.raises(nx.NetworkXError, interface_func, G, s=0)


def test_interface_only_target():
    G = nx.complete_graph(5)
    for interface_func in [nx.minimum_node_cut, nx.minimum_edge_cut]:
        pytest.raises(nx.NetworkXError, interface_func, G, t=3)
</PRE>
</div>
  </div>
</body>
</html>
