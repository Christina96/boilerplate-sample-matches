<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_multigraph.py &amp; test_cuts.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_multigraph.py &amp; test_cuts.py
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_multigraph.py (1.451613%)<th>test_cuts.py (2.9850745%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(447-448)<td><a href="#" name="0">(52-68)</a><td align="center"><font color="#ff0000">18</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_multigraph.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 from networkx.utils import edges_equal
4 from .test_graph import BaseAttrGraphTester
5 from .test_graph import TestGraph as _TestGraph
6 class BaseMultiGraphTester(BaseAttrGraphTester):
7     def test_has_edge(self):
8         G = self.K3
9         assert G.has_edge(0, 1)
10         assert not G.has_edge(0, -1)
11         assert G.has_edge(0, 1, 0)
12         assert not G.has_edge(0, 1, 1)
13     def test_get_edge_data(self):
14         G = self.K3
15         assert G.get_edge_data(0, 1) == {0: {}}
16         assert G[0][1] == {0: {}}
17         assert G[0][1][0] == {}
18         assert G.get_edge_data(10, 20) is None
19         assert G.get_edge_data(0, 1, 0) == {}
20     def test_adjacency(self):
21         G = self.K3
22         assert dict(G.adjacency()) == {
23             0: {1: {0: {}}, 2: {0: {}}},
24             1: {0: {0: {}}, 2: {0: {}}},
25             2: {0: {0: {}}, 1: {0: {}}},
26         }
27     def deepcopy_edge_attr(self, H, G):
28         assert G[1][2][0]["foo"] == H[1][2][0]["foo"]
29         G[1][2][0]["foo"].append(1)
30         assert G[1][2][0]["foo"] != H[1][2][0]["foo"]
31     def shallow_copy_edge_attr(self, H, G):
32         assert G[1][2][0]["foo"] == H[1][2][0]["foo"]
33         G[1][2][0]["foo"].append(1)
34         assert G[1][2][0]["foo"] == H[1][2][0]["foo"]
35     def graphs_equal(self, H, G):
36         assert G._adj == H._adj
37         assert G._node == H._node
38         assert G.graph == H.graph
39         assert G.name == H.name
40         if not G.is_directed() and not H.is_directed():
41             assert H._adj[1][2][0] is H._adj[2][1][0]
42             assert G._adj[1][2][0] is G._adj[2][1][0]
43         else:  # at least one is directed
44             if not G.is_directed():
45                 G._pred = G._adj
46                 G._succ = G._adj
47             if not H.is_directed():
48                 H._pred = H._adj
49                 H._succ = H._adj
50             assert G._pred == H._pred
51             assert G._succ == H._succ
52             assert H._succ[1][2][0] is H._pred[2][1][0]
53             assert G._succ[1][2][0] is G._pred[2][1][0]
54     def same_attrdict(self, H, G):
55         old_foo = H[1][2][0]["foo"]
56         H.adj[1][2][0]["foo"] = "baz"
57         assert G._adj == H._adj
58         H.adj[1][2][0]["foo"] = old_foo
59         assert G._adj == H._adj
60         old_foo = H.nodes[0]["foo"]
61         H.nodes[0]["foo"] = "baz"
62         assert G._node == H._node
63         H.nodes[0]["foo"] = old_foo
64         assert G._node == H._node
65     def different_attrdict(self, H, G):
66         old_foo = H[1][2][0]["foo"]
67         H.adj[1][2][0]["foo"] = "baz"
68         assert G._adj != H._adj
69         H.adj[1][2][0]["foo"] = old_foo
70         assert G._adj == H._adj
71         old_foo = H.nodes[0]["foo"]
72         H.nodes[0]["foo"] = "baz"
73         assert G._node != H._node
74         H.nodes[0]["foo"] = old_foo
75         assert G._node == H._node
76     def test_to_undirected(self):
77         G = self.K3
78         self.add_attributes(G)
79         H = nx.MultiGraph(G)
80         self.is_shallow_copy(H, G)
81         H = G.to_undirected()
82         self.is_deepcopy(H, G)
83     def test_to_directed(self):
84         G = self.K3
85         self.add_attributes(G)
86         H = nx.MultiDiGraph(G)
87         self.is_shallow_copy(H, G)
88         H = G.to_directed()
89         self.is_deepcopy(H, G)
90     def test_number_of_edges_selfloops(self):
91         G = self.K3
92         G.add_edge(0, 0)
93         G.add_edge(0, 0)
94         G.add_edge(0, 0, key="parallel edge")
95         G.remove_edge(0, 0, key="parallel edge")
96         assert G.number_of_edges(0, 0) == 2
97         G.remove_edge(0, 0)
98         assert G.number_of_edges(0, 0) == 1
99     def test_edge_lookup(self):
100         G = self.Graph()
101         G.add_edge(1, 2, foo="bar")
102         G.add_edge(1, 2, "key", foo="biz")
103         assert edges_equal(G.edges[1, 2, 0], {"foo": "bar"})
104         assert edges_equal(G.edges[1, 2, "key"], {"foo": "biz"})
105     def test_edge_attr4(self):
106         G = self.Graph()
107         G.add_edge(1, 2, key=0, data=7, spam="bar", bar="foo")
108         assert edges_equal(
109             G.edges(data=True), [(1, 2, {"data": 7, "spam": "bar", "bar": "foo"})]
110         )
111         G[1][2][0]["data"] = 10  # OK to set data like this
112         assert edges_equal(
113             G.edges(data=True), [(1, 2, {"data": 10, "spam": "bar", "bar": "foo"})]
114         )
115         G.adj[1][2][0]["data"] = 20
116         assert edges_equal(
117             G.edges(data=True), [(1, 2, {"data": 20, "spam": "bar", "bar": "foo"})]
118         )
119         G.edges[1, 2, 0]["data"] = 21  # another spelling, "edge"
120         assert edges_equal(
121             G.edges(data=True), [(1, 2, {"data": 21, "spam": "bar", "bar": "foo"})]
122         )
123         G.adj[1][2][0]["listdata"] = [20, 200]
124         G.adj[1][2][0]["weight"] = 20
125         assert edges_equal(
126             G.edges(data=True),
127             [
128                 (
129                     1,
130                     2,
131                     {
132                         "data": 21,
133                         "spam": "bar",
134                         "bar": "foo",
135                         "listdata": [20, 200],
136                         "weight": 20,
137                     },
138                 )
139             ],
140         )
141 class TestMultiGraph(BaseMultiGraphTester, _TestGraph):
142     def setup_method(self):
143         self.Graph = nx.MultiGraph
144         ed1, ed2, ed3 = ({0: {}}, {0: {}}, {0: {}})
145         self.k3adj = {0: {1: ed1, 2: ed2}, 1: {0: ed1, 2: ed3}, 2: {0: ed2, 1: ed3}}
146         self.k3edges = [(0, 1), (0, 2), (1, 2)]
147         self.k3nodes = [0, 1, 2]
148         self.K3 = self.Graph()
149         self.K3._adj = self.k3adj
150         self.K3._node = {}
151         self.K3._node[0] = {}
152         self.K3._node[1] = {}
153         self.K3._node[2] = {}
154     def test_data_input(self):
155         G = self.Graph({1: [2], 2: [1]}, name="test")
156         assert G.name == "test"
157         expected = [(1, {2: {0: {}}}), (2, {1: {0: {}}})]
158         assert sorted(G.adj.items()) == expected
159     def test_data_multigraph_input(self):
160         edata0 = dict(w=200, s="foo")
161         edata1 = dict(w=201, s="bar")
162         keydict = {0: edata0, 1: edata1}
163         dododod = {"a": {"b": keydict}}
164         multiple_edge = [("a", "b", 0, edata0), ("a", "b", 1, edata1)]
165         single_edge = [("a", "b", 0, keydict)]
166         G = self.Graph(dododod, multigraph_input=True)
167         assert list(G.edges(keys=True, data=True)) == multiple_edge
168         G = self.Graph(dododod, multigraph_input=None)
169         assert list(G.edges(keys=True, data=True)) == multiple_edge
170         G = self.Graph(dododod, multigraph_input=False)
171         assert list(G.edges(keys=True, data=True)) == single_edge
172         G = self.Graph(dododod, multigraph_input=True)
173         H = self.Graph(nx.to_dict_of_dicts(G))
174         assert nx.is_isomorphic(G, H) is True  # test that default is True
175         for mgi in [True, False]:
176             H = self.Graph(nx.to_dict_of_dicts(G), multigraph_input=mgi)
177             assert nx.is_isomorphic(G, H) == mgi
178     etraits = {"w": 200, "s": "foo"}
179     egraphics = {"color": "blue", "shape": "box"}
180     edata = {"traits": etraits, "graphics": egraphics}
181     dodod1 = {"a": {"b": edata}}
182     dodod2 = {"a": {"b": etraits}}
183     dodod3 = {"a": {"b": {"traits": etraits, "s": "foo"}}}
184     dol = {"a": ["b"]}
185     multiple_edge = [("a", "b", "traits", etraits), ("a", "b", "graphics", egraphics)]
186     single_edge = [("a", "b", 0, {})]  # type: ignore
187     single_edge1 = [("a", "b", 0, edata)]
188     single_edge2 = [("a", "b", 0, etraits)]
189     single_edge3 = [("a", "b", 0, {"traits": etraits, "s": "foo"})]
190     cases = [  # (dod, mgi, edges)
191         (dodod1, True, multiple_edge),
192         (dodod1, False, single_edge1),
193         (dodod2, False, single_edge2),
194         (dodod3, False, single_edge3),
195         (dol, False, single_edge),
196     ]
197     @pytest.mark.parametrize("dod, mgi, edges", cases)
198     def test_non_multigraph_input(self, dod, mgi, edges):
199         G = self.Graph(dod, multigraph_input=mgi)
200         assert list(G.edges(keys=True, data=True)) == edges
201         G = nx.to_networkx_graph(dod, create_using=self.Graph, multigraph_input=mgi)
202         assert list(G.edges(keys=True, data=True)) == edges
203     mgi_none_cases = [
204         (dodod1, multiple_edge),
205         (dodod2, single_edge2),
206         (dodod3, single_edge3),
207     ]
208     @pytest.mark.parametrize("dod, edges", mgi_none_cases)
209     def test_non_multigraph_input_mgi_none(self, dod, edges):
210         G = self.Graph(dod)
211         assert list(G.edges(keys=True, data=True)) == edges
212     raise_cases = [dodod2, dodod3, dol]
213     @pytest.mark.parametrize("dod", raise_cases)
214     def test_non_multigraph_input_raise(self, dod):
215         pytest.raises(nx.NetworkXError, self.Graph, dod, multigraph_input=True)
216         pytest.raises(
217             nx.NetworkXError,
218             nx.to_networkx_graph,
219             dod,
220             create_using=self.Graph,
221             multigraph_input=True,
222         )
223     def test_getitem(self):
224         G = self.K3
225         assert G[0] == {1: {0: {}}, 2: {0: {}}}
226         with pytest.raises(KeyError):
227             G.__getitem__("j")
228         with pytest.raises(TypeError):
229             G.__getitem__(["A"])
230     def test_remove_node(self):
231         G = self.K3
232         G.remove_node(0)
233         assert G.adj == {1: {2: {0: {}}}, 2: {1: {0: {}}}}
234         with pytest.raises(nx.NetworkXError):
235             G.remove_node(-1)
236     def test_add_edge(self):
237         G = self.Graph()
238         G.add_edge(0, 1)
239         assert G.adj == {0: {1: {0: {}}}, 1: {0: {0: {}}}}
240         G = self.Graph()
241         G.add_edge(*(0, 1))
242         assert G.adj == {0: {1: {0: {}}}, 1: {0: {0: {}}}}
243     def test_add_edge_conflicting_key(self):
244         G = self.Graph()
245         G.add_edge(0, 1, key=1)
246         G.add_edge(0, 1)
247         assert G.number_of_edges() == 2
248         G = self.Graph()
249         G.add_edges_from([(0, 1, 1, {})])
250         G.add_edges_from([(0, 1)])
251         assert G.number_of_edges() == 2
252     def test_add_edges_from(self):
253         G = self.Graph()
254         G.add_edges_from([(0, 1), (0, 1, {"weight": 3})])
255         assert G.adj == {
256             0: {1: {0: {}, 1: {"weight": 3}}},
257             1: {0: {0: {}, 1: {"weight": 3}}},
258         }
259         G.add_edges_from([(0, 1), (0, 1, {"weight": 3})], weight=2)
260         assert G.adj == {
261             0: {1: {0: {}, 1: {"weight": 3}, 2: {"weight": 2}, 3: {"weight": 3}}},
262             1: {0: {0: {}, 1: {"weight": 3}, 2: {"weight": 2}, 3: {"weight": 3}}},
263         }
264         G = self.Graph()
265         edges = [
266             (0, 1, {"weight": 3}),
267             (0, 1, (("weight", 2),)),
268             (0, 1, 5),
269             (0, 1, "s"),
270         ]
271         G.add_edges_from(edges)
272         keydict = {0: {"weight": 3}, 1: {"weight": 2}, 5: {}, "s": {}}
273         assert G._adj == {0: {1: keydict}, 1: {0: keydict}}
274         with pytest.raises(nx.NetworkXError):
275             G.add_edges_from([(0,)])
276         with pytest.raises(nx.NetworkXError):
277             G.add_edges_from([(0, 1, 2, 3, 4)])
278         with pytest.raises(TypeError):
279             G.add_edges_from([0])
280     def test_remove_edge(self):
281         G = self.K3
282         G.remove_edge(0, 1)
283         assert G.adj == {0: {2: {0: {}}}, 1: {2: {0: {}}}, 2: {0: {0: {}}, 1: {0: {}}}}
284         with pytest.raises(nx.NetworkXError):
285             G.remove_edge(-1, 0)
286         with pytest.raises(nx.NetworkXError):
287             G.remove_edge(0, 2, key=1)
288     def test_remove_edges_from(self):
289         G = self.K3.copy()
290         G.remove_edges_from([(0, 1)])
291         kd = {0: {}}
292         assert G.adj == {0: {2: kd}, 1: {2: kd}, 2: {0: kd, 1: kd}}
293         G.remove_edges_from([(0, 0)])  # silent fail
294         self.K3.add_edge(0, 1)
295         G = self.K3.copy()
296         G.remove_edges_from(list(G.edges(data=True, keys=True)))
297         assert G.adj == {0: {}, 1: {}, 2: {}}
298         G = self.K3.copy()
299         G.remove_edges_from(list(G.edges(data=False, keys=True)))
300         assert G.adj == {0: {}, 1: {}, 2: {}}
301         G = self.K3.copy()
302         G.remove_edges_from(list(G.edges(data=False, keys=False)))
303         assert G.adj == {0: {}, 1: {}, 2: {}}
304         G = self.K3.copy()
305         G.remove_edges_from([(0, 1, 0), (0, 2, 0, {}), (1, 2)])
306         assert G.adj == {0: {1: {1: {}}}, 1: {0: {1: {}}}, 2: {}}
307     def test_remove_multiedge(self):
308         G = self.K3
309         G.add_edge(0, 1, key="parallel edge")
310         G.remove_edge(0, 1, key="parallel edge")
311         assert G.adj == {
312             0: {1: {0: {}}, 2: {0: {}}},
313             1: {0: {0: {}}, 2: {0: {}}},
314             2: {0: {0: {}}, 1: {0: {}}},
315         }
316         G.remove_edge(0, 1)
317         kd = {0: {}}
318         assert G.adj == {0: {2: kd}, 1: {2: kd}, 2: {0: kd, 1: kd}}
319         with pytest.raises(nx.NetworkXError):
320             G.remove_edge(-1, 0)
321 class TestEdgeSubgraph:
322     def setup_method(self):
323         G = nx.MultiGraph()
324         nx.add_path(G, range(5))
325         nx.add_path(G, range(5))
326         for i in range(5):
327             G.nodes[i]["name"] = f"node{i}"
328         G.adj[0][1][0]["name"] = "edge010"
329         G.adj[0][1][1]["name"] = "edge011"
330         G.adj[3][4][0]["name"] = "edge340"
331         G.adj[3][4][1]["name"] = "edge341"
332         G.graph["name"] = "graph"
333         self.G = G
334         self.H = G.edge_subgraph([(0, 1, 0), (3, 4, 1)])
335     def test_correct_nodes(self):
336         assert [0, 1, 3, 4] == sorted(self.H.nodes())
337     def test_correct_edges(self):
338         assert [(0, 1, 0, "edge010"), (3, 4, 1, "edge341")] == sorted(
339             self.H.edges(keys=True, data="name")
340         )
341     def test_add_node(self):
342         self.G.add_node(5)
343         assert [0, 1, 3, 4] == sorted(self.H.nodes())
344     def test_remove_node(self):
345         self.G.remove_node(0)
346         assert [1, 3, 4] == sorted(self.H.nodes())
347     def test_node_attr_dict(self):
348         for v in self.H:
349             assert self.G.nodes[v] == self.H.nodes[v]
350         self.G.nodes[0]["name"] = "foo"
351         assert self.G.nodes[0] == self.H.nodes[0]
352         self.H.nodes[1]["name"] = "bar"
353         assert self.G.nodes[1] == self.H.nodes[1]
354     def test_edge_attr_dict(self):
355         for u, v, k in self.H.edges(keys=True):
356 <a name="0"></a>            assert self.G._adj[u][v][k] == self.H._adj[u][v][k]
357         self.G._adj[0][1][0]["name"] = "foo"
358         assert self<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.G._adj[0][1][0]["name"] == self.H._adj[0][1][0]["name"]
359         self.H._adj[3][4][1][</b></font>"name"] = "bar"
360         assert self.G._adj[3][4][1]["name"] == self.H._adj[3][4][1]["name"]
361     def test_graph_attr_dict(self):
362         assert self.G.graph is self.H.graph
363 def test_multigraph_add_edges_from_four_tuple_misordered():
364     G = nx.MultiGraph()
365     with pytest.raises(TypeError):
366         G.add_edges_from([(0, 1, {"color": "red"}, 0)])
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_cuts.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import pytest
2 import networkx as nx
3 from networkx.algorithms import flow
4 from networkx.algorithms.connectivity import minimum_st_edge_cut
5 from networkx.algorithms.connectivity import minimum_st_node_cut
6 from networkx.utils import arbitrary_element
7 flow_funcs = [
8     flow.boykov_kolmogorov,
9     flow.dinitz,
10     flow.edmonds_karp,
11     flow.preflow_push,
12     flow.shortest_augmenting_path,
13 ]
14 def _generate_no_biconnected(max_attempts=50):
15     attempts = 0
16     while True:
17         G = nx.fast_gnp_random_graph(100, 0.0575, seed=42)
18         if nx.is_connected(G) and not nx.is_biconnected(G):
19             attempts = 0
20             yield G
21         else:
22             if attempts &gt;= max_attempts:
23                 msg = f"Tried {attempts} times: no suitable Graph."
24                 raise Exception(msg)
25             else:
26                 attempts += 1
27 def test_articulation_points():
28     Ggen = _generate_no_biconnected()
29     for flow_func in flow_funcs:
30         errmsg = f"Assertion failed in function: {flow_func.__name__}"
31         for i in range(1):  # change 1 to 3 or more for more realizations.
32             G = next(Ggen)
33             cut = nx.minimum_node_cut(G, flow_func=flow_func)
34             assert len(cut) == 1, errmsg
35             assert cut.pop() in set(nx.articulation_points(G)), errmsg
36 def test_brandes_erlebach_book():
37 <a name="0"></a>    G = nx.Graph()
38     G.add_edges_from(
39         [
40             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>(1, 2),
41             (1, 3),
42             (1, 4),
43             (1, 5),
44             (2, 3),
45             (2, 6),
46             (3, 4),
47             (3, 6),
48             (4, 6),
49             (4, 7),
50             (5, 7),
51             (6, 8),
52             (6, 9),
53             (7, 8),
54             (7, 10),
55             (8, 11),
56             (9</b></font>, 10),
57             (9, 11),
58             (10, 11),
59         ]
60     )
61     for flow_func in flow_funcs:
62         kwargs = dict(flow_func=flow_func)
63         errmsg = f"Assertion failed in function: {flow_func.__name__}"
64         assert 3 == len(nx.minimum_edge_cut(G, 1, 11, **kwargs)), errmsg
65         edge_cut = nx.minimum_edge_cut(G, **kwargs)
66         assert 2 == len(edge_cut), errmsg
67         H = G.copy()
68         H.remove_edges_from(edge_cut)
69         assert not nx.is_connected(H), errmsg
70         assert {6, 7} == minimum_st_node_cut(G, 1, 11, **kwargs), errmsg
71         assert {6, 7} == nx.minimum_node_cut(G, 1, 11, **kwargs), errmsg
72         node_cut = nx.minimum_node_cut(G, **kwargs)
73         assert 2 == len(node_cut), errmsg
74         H = G.copy()
75         H.remove_nodes_from(node_cut)
76         assert not nx.is_connected(H), errmsg
77 def test_white_harary_paper():
78     G = nx.disjoint_union(nx.complete_graph(4), nx.complete_graph(4))
79     G.remove_node(7)
80     for i in range(4, 7):
81         G.add_edge(0, i)
82     G = nx.disjoint_union(G, nx.complete_graph(4))
83     G.remove_node(G.order() - 1)
84     for i in range(7, 10):
85         G.add_edge(0, i)
86     for flow_func in flow_funcs:
87         kwargs = dict(flow_func=flow_func)
88         errmsg = f"Assertion failed in function: {flow_func.__name__}"
89         edge_cut = nx.minimum_edge_cut(G, **kwargs)
90         assert 3 == len(edge_cut), errmsg
91         H = G.copy()
92         H.remove_edges_from(edge_cut)
93         assert not nx.is_connected(H), errmsg
94         node_cut = nx.minimum_node_cut(G, **kwargs)
95         assert {0} == node_cut, errmsg
96         H = G.copy()
97         H.remove_nodes_from(node_cut)
98         assert not nx.is_connected(H), errmsg
99 def test_petersen_cutset():
100     G = nx.petersen_graph()
101     for flow_func in flow_funcs:
102         kwargs = dict(flow_func=flow_func)
103         errmsg = f"Assertion failed in function: {flow_func.__name__}"
104         edge_cut = nx.minimum_edge_cut(G, **kwargs)
105         assert 3 == len(edge_cut), errmsg
106         H = G.copy()
107         H.remove_edges_from(edge_cut)
108         assert not nx.is_connected(H), errmsg
109         node_cut = nx.minimum_node_cut(G, **kwargs)
110         assert 3 == len(node_cut), errmsg
111         H = G.copy()
112         H.remove_nodes_from(node_cut)
113         assert not nx.is_connected(H), errmsg
114 def test_octahedral_cutset():
115     G = nx.octahedral_graph()
116     for flow_func in flow_funcs:
117         kwargs = dict(flow_func=flow_func)
118         errmsg = f"Assertion failed in function: {flow_func.__name__}"
119         edge_cut = nx.minimum_edge_cut(G, **kwargs)
120         assert 4 == len(edge_cut), errmsg
121         H = G.copy()
122         H.remove_edges_from(edge_cut)
123         assert not nx.is_connected(H), errmsg
124         node_cut = nx.minimum_node_cut(G, **kwargs)
125         assert 4 == len(node_cut), errmsg
126         H = G.copy()
127         H.remove_nodes_from(node_cut)
128         assert not nx.is_connected(H), errmsg
129 def test_icosahedral_cutset():
130     G = nx.icosahedral_graph()
131     for flow_func in flow_funcs:
132         kwargs = dict(flow_func=flow_func)
133         errmsg = f"Assertion failed in function: {flow_func.__name__}"
134         edge_cut = nx.minimum_edge_cut(G, **kwargs)
135         assert 5 == len(edge_cut), errmsg
136         H = G.copy()
137         H.remove_edges_from(edge_cut)
138         assert not nx.is_connected(H), errmsg
139         node_cut = nx.minimum_node_cut(G, **kwargs)
140         assert 5 == len(node_cut), errmsg
141         H = G.copy()
142         H.remove_nodes_from(node_cut)
143         assert not nx.is_connected(H), errmsg
144 def test_node_cutset_exception():
145     G = nx.Graph()
146     G.add_edges_from([(1, 2), (3, 4)])
147     for flow_func in flow_funcs:
148         pytest.raises(nx.NetworkXError, nx.minimum_node_cut, G, flow_func=flow_func)
149 def test_node_cutset_random_graphs():
150     for flow_func in flow_funcs:
151         errmsg = f"Assertion failed in function: {flow_func.__name__}"
152         for i in range(3):
153             G = nx.fast_gnp_random_graph(50, 0.25, seed=42)
154             if not nx.is_connected(G):
155                 ccs = iter(nx.connected_components(G))
156                 start = arbitrary_element(next(ccs))
157                 G.add_edges_from((start, arbitrary_element(c)) for c in ccs)
158             cutset = nx.minimum_node_cut(G, flow_func=flow_func)
159             assert nx.node_connectivity(G) == len(cutset), errmsg
160             G.remove_nodes_from(cutset)
161             assert not nx.is_connected(G), errmsg
162 def test_edge_cutset_random_graphs():
163     for flow_func in flow_funcs:
164         errmsg = f"Assertion failed in function: {flow_func.__name__}"
165         for i in range(3):
166             G = nx.fast_gnp_random_graph(50, 0.25, seed=42)
167             if not nx.is_connected(G):
168                 ccs = iter(nx.connected_components(G))
169                 start = arbitrary_element(next(ccs))
170                 G.add_edges_from((start, arbitrary_element(c)) for c in ccs)
171             cutset = nx.minimum_edge_cut(G, flow_func=flow_func)
172             assert nx.edge_connectivity(G) == len(cutset), errmsg
173             G.remove_edges_from(cutset)
174             assert not nx.is_connected(G), errmsg
175 def test_empty_graphs():
176     G = nx.Graph()
177     D = nx.DiGraph()
178     for interface_func in [nx.minimum_node_cut, nx.minimum_edge_cut]:
179         for flow_func in flow_funcs:
180             pytest.raises(
181                 nx.NetworkXPointlessConcept, interface_func, G, flow_func=flow_func
182             )
183             pytest.raises(
184                 nx.NetworkXPointlessConcept, interface_func, D, flow_func=flow_func
185             )
186 def test_unbounded():
187     G = nx.complete_graph(5)
188     for flow_func in flow_funcs:
189         assert 4 == len(minimum_st_edge_cut(G, 1, 4, flow_func=flow_func))
190 def test_missing_source():
191     G = nx.path_graph(4)
192     for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
193         for flow_func in flow_funcs:
194             pytest.raises(
195                 nx.NetworkXError, interface_func, G, 10, 1, flow_func=flow_func
196             )
197 def test_missing_target():
198     G = nx.path_graph(4)
199     for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
200         for flow_func in flow_funcs:
201             pytest.raises(
202                 nx.NetworkXError, interface_func, G, 1, 10, flow_func=flow_func
203             )
204 def test_not_weakly_connected():
205     G = nx.DiGraph()
206     nx.add_path(G, [1, 2, 3])
207     nx.add_path(G, [4, 5])
208     for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
209         for flow_func in flow_funcs:
210             pytest.raises(nx.NetworkXError, interface_func, G, flow_func=flow_func)
211 def test_not_connected():
212     G = nx.Graph()
213     nx.add_path(G, [1, 2, 3])
214     nx.add_path(G, [4, 5])
215     for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
216         for flow_func in flow_funcs:
217             pytest.raises(nx.NetworkXError, interface_func, G, flow_func=flow_func)
218 def tests_min_cut_complete():
219     G = nx.complete_graph(5)
220     for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
221         for flow_func in flow_funcs:
222             assert 4 == len(interface_func(G, flow_func=flow_func))
223 def tests_min_cut_complete_directed():
224     G = nx.complete_graph(5)
225     G = G.to_directed()
226     for interface_func in [nx.minimum_edge_cut, nx.minimum_node_cut]:
227         for flow_func in flow_funcs:
228             assert 4 == len(interface_func(G, flow_func=flow_func))
229 def tests_minimum_st_node_cut():
230     G = nx.Graph()
231     G.add_nodes_from([0, 1, 2, 3, 7, 8, 11, 12])
232     G.add_edges_from([(7, 11), (1, 11), (1, 12), (12, 8), (0, 1)])
233     nodelist = minimum_st_node_cut(G, 7, 11)
234     assert nodelist == {}
235 def test_invalid_auxiliary():
236     G = nx.complete_graph(5)
237     pytest.raises(nx.NetworkXError, minimum_st_node_cut, G, 0, 3, auxiliary=G)
238 def test_interface_only_source():
239     G = nx.complete_graph(5)
240     for interface_func in [nx.minimum_node_cut, nx.minimum_edge_cut]:
241         pytest.raises(nx.NetworkXError, interface_func, G, s=0)
242 def test_interface_only_target():
243     G = nx.complete_graph(5)
244     for interface_func in [nx.minimum_node_cut, nx.minimum_edge_cut]:
245         pytest.raises(nx.NetworkXError, interface_func, G, t=3)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
