<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for adn.py &amp; drtv.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for adn.py &amp; drtv.py
      </h3>
<h1 align="center">
        8.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>adn.py (8.830549%)<th>drtv.py (8.665106%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(240-246)<td><a href="#" name="0">(235-241)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(255-260)<td><a href="#" name="1">(270-273)</a><td align="center"><font color="#eb0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(5-36)<td><a href="#" name="2">(2-37)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>adn.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <a name="2"></a>from __future__ import unicode_literals
2 import base64
3 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import binascii
4 import json
5 import os
6 import random
7 from .common import InfoExtractor
8 from ..aes import aes_cbc_decrypt
9 from ..compat import (
10     compat_HTTPError,
11     compat_b64decode,
12     compat_ord,
13 )
14 from ..utils import (
15     bytes_to_intlist,
16     bytes_to_long,
17     ExtractorError,
18     float_or_none,
19     int_or_none,
20     intlist_to_bytes,
21     long_to_bytes,
22     pkcs1pad,
23     strip_or_none,
24     try_get,
25     unified_strdate,
26     urlencode_postdata,
27 )
28 class ADNIE(InfoExtractor):
29     IE_DESC = 'Anime Digital Network'
30     _VALID_URL = r'https?://(?:www\.)?animedigitalnetwork\.fr/video/[^/]+/(?P&lt;id&gt;\d+)'
31     _TEST =</b></font> {
32         'url': 'http://animedigitalnetwork.fr/video/blue-exorcist-kyoto-saga/7778-episode-1-debut-des-hostilites',
33         'md5': '0319c99885ff5547565cacb4f3f9348d',
34         'info_dict': {
35             'id': '7778',
36             'ext': 'mp4',
37             'title': 'Blue Exorcist - Kyôto Saga - Episode 1',
38             'description': 'md5:2f7b5aa76edbc1a7a92cedcda8a528d5',
39             'series': 'Blue Exorcist - Kyôto Saga',
40             'duration': 1467,
41             'release_date': '20170106',
42             'comment_count': int,
43             'average_rating': float,
44             'season_number': 2,
45             'episode': 'Début des hostilités',
46             'episode_number': 1,
47         }
48     }
49     _NETRC_MACHINE = 'animedigitalnetwork'
50     _BASE_URL = 'http://animedigitalnetwork.fr'
51     _API_BASE_URL = 'https://gw.api.animedigitalnetwork.fr/'
52     _PLAYER_BASE_URL = _API_BASE_URL + 'player/'
53     _HEADERS = {}
54     _LOGIN_ERR_MESSAGE = 'Unable to log in'
55     _RSA_KEY = (0x9B42B08905199A5CCE2026274399CA560ECB209EE9878A708B1C0812E1BB8CB5D1FB7441861147C1A1F2F3A0476DD63A9CAC20D3E983613346850AA6CB38F16DC7D720FD7D86FC6E5B3D5BBC72E14CD0BF9E869F2CEA2CCAD648F1DCE38F1FF916CEFB2D339B64AA0264372344BC775E265E8A852F88144AB0BD9AA06C1A4ABB, 65537)
56     _POS_ALIGN_MAP = {
57         'start': 1,
58         'end': 3,
59     }
60     _LINE_ALIGN_MAP = {
61         'middle': 8,
62         'end': 4,
63     }
64     @staticmethod
65     def _ass_subtitles_timecode(seconds):
66         return '%01d:%02d:%02d.%02d' % (seconds / 3600, (seconds % 3600) / 60, seconds % 60, (seconds % 1) * 100)
67     def _get_subtitles(self, sub_url, video_id):
68         if not sub_url:
69             return None
70         enc_subtitles = self._download_webpage(
71             sub_url, video_id, 'Downloading subtitles location', fatal=False) or '{}'
72         subtitle_location = (self._parse_json(enc_subtitles, video_id, fatal=False) or {}).get('location')
73         if subtitle_location:
74             enc_subtitles = self._download_webpage(
75                 subtitle_location, video_id, 'Downloading subtitles data',
76                 fatal=False, headers={'Origin': 'https://animedigitalnetwork.fr'})
77         if not enc_subtitles:
78             return None
79         dec_subtitles = intlist_to_bytes(aes_cbc_decrypt(
80             bytes_to_intlist(compat_b64decode(enc_subtitles[24:])),
81             bytes_to_intlist(binascii.unhexlify(self._K + 'ab9f52f5baae7c72')),
82             bytes_to_intlist(compat_b64decode(enc_subtitles[:24]))
83         ))
84         subtitles_json = self._parse_json(
85             dec_subtitles[:-compat_ord(dec_subtitles[-1])].decode(),
86             None, fatal=False)
87         if not subtitles_json:
88             return None
89         subtitles = {}
90         for sub_lang, sub in subtitles_json.items():
91             ssa = '''[Script Info]
92 ScriptType:V4.00
93 [V4 Styles]
94 Format: Name,Fontname,Fontsize,PrimaryColour,SecondaryColour,TertiaryColour,BackColour,Bold,Italic,BorderStyle,Outline,Shadow,Alignment,MarginL,MarginR,MarginV,AlphaLevel,Encoding
95 Style: Default,Arial,18,16777215,16777215,16777215,0,-1,0,1,1,0,2,20,20,20,0,0
96 [Events]
97 Format: Marked,Start,End,Style,Name,MarginL,MarginR,MarginV,Effect,Text'''
98             for current in sub:
99                 start, end, text, line_align, position_align = (
100                     float_or_none(current.get('startTime')),
101                     float_or_none(current.get('endTime')),
102                     current.get('text'), current.get('lineAlign'),
103                     current.get('positionAlign'))
104                 if start is None or end is None or text is None:
105                     continue
106                 alignment = self._POS_ALIGN_MAP.get(position_align, 2) + self._LINE_ALIGN_MAP.get(line_align, 0)
107                 ssa += os.linesep + 'Dialogue: Marked=0,%s,%s,Default,,0,0,0,,%s%s' % (
108                     self._ass_subtitles_timecode(start),
109                     self._ass_subtitles_timecode(end),
110                     '{\\a%d}' % alignment if alignment != 2 else '',
111                     text.replace('\n', '\\N').replace('&lt;i&gt;', '{\\i1}').replace('&lt;/i&gt;', '{\\i0}'))
112             if sub_lang == 'vostf':
113                 sub_lang = 'fr'
114             subtitles.setdefault(sub_lang, []).extend([{
115                 'ext': 'json',
116                 'data': json.dumps(sub),
117             }, {
118                 'ext': 'ssa',
119                 'data': ssa,
120             }])
121         return subtitles
122     def _real_initialize(self):
123         username, password = self._get_login_info()
124         if not username:
125             return
126         try:
127             access_token = (self._download_json(
128                 self._API_BASE_URL + 'authentication/login', None,
129                 'Logging in', self._LOGIN_ERR_MESSAGE, fatal=False,
130                 data=urlencode_postdata({
131                     'password': password,
132                     'rememberMe': False,
133                     'source': 'Web',
134                     'username': username,
135                 })) or {}).get('accessToken')
136             if access_token:
137                 self._HEADERS = {'authorization': 'Bearer ' + access_token}
138         except ExtractorError as e:
139             message = None
140             if isinstance(e.cause, compat_HTTPError) and e.cause.code == 401:
141                 resp = self._parse_json(
142                     e.cause.read().decode(), None, fatal=False) or {}
143                 message = resp.get('message') or resp.get('code')
144             self.report_warning(message or self._LOGIN_ERR_MESSAGE)
145     def _real_extract(self, url):
146         video_id = self._match_id(url)
147         video_base_url = self._PLAYER_BASE_URL + 'video/%s/' % video_id
148         player = self._download_json(
149             video_base_url + 'configuration', video_id,
150             'Downloading player config JSON metadata',
151             headers=self._HEADERS)['player']
152         options = player['options']
153         user = options['user']
154         if not user.get('hasAccess'):
155             self.raise_login_required()
156         token = self._download_json(
157             user.get('refreshTokenUrl') or (self._PLAYER_BASE_URL + 'refresh/token'),
158             video_id, 'Downloading access token', headers={
159                 'x-player-refresh-token': user['refreshToken']
160             }, data=b'')['token']
161         links_url = try_get(options, lambda x: x['video']['url']) or (video_base_url + 'link')
162         self._K = ''.join([random.choice('0123456789abcdef') for _ in range(16)])
163         message = bytes_to_intlist(json.dumps({
164             'k': self._K,
165             't': token,
166         }))
167         links_data = None
168         for _ in range(3):
169             padded_message = intlist_to_bytes(pkcs1pad(message, 128))
170             n, e = self._RSA_KEY
171             encrypted_message = long_to_bytes(pow(bytes_to_long(padded_message), e, n))
172             authorization = base64.b64encode(encrypted_message).decode()
173             try:
174                 links_data = self._download_json(
175                     links_url, video_id, 'Downloading links JSON metadata', headers={
176                         'X-Player-Token': authorization
177                     }, query={
178                         'freeWithAds': 'true',
179                         'adaptive': 'false',
180                         'withMetadata': 'true',
181                         'source': 'Web'
182                     })
183                 break
184             except ExtractorError as e:
185                 if not isinstance(e.cause, compat_HTTPError):
186                     raise e
187                 if e.cause.code == 401:
188                     continue
189                 error = self._parse_json(e.cause.read(), video_id)
190                 message = error.get('message')
191                 if e.cause.code == 403 and error.get('code') == 'player-bad-geolocation-country':
192                     self.raise_geo_restricted(msg=message)
193                 raise ExtractorError(message)
194         else:
195             raise ExtractorError('Giving up retrying')
196         links = links_data.get('links') or {}
197         metas = links_data.get('metadata') or {}
198         sub_url = (links.get('subtitles') or {}).get('all')
199         video_info = links_data.get('video') or {}
200         title = metas['title']
201         formats = []
202         for format_id, qualities in (links.get('streaming') or {}).items():
203             if not isinstance(qualities, dict):
204                 continue
205             for quality, load_balancer_url in qualities.items():
206                 load_balancer_data = self._download_json(
207                     load_balancer_url, video_id,
208                     'Downloading %s %s JSON metadata' % (format_id, quality),
209                     fatal=False) or {}
210 <a name="0"></a>                m3u8_url = load_balancer_data.get('location')
211                 if not m3u8_url:
212                     continue
213                 m3u8_formats <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= self._extract_m3u8_formats(
214                     m3u8_url, video_id, 'mp4', 'm3u8_native',
215                     m3u8_id=format_id, fatal=False)
216                 if format_id == 'vf':
217                     for f in m3u8_formats:
218                         f['language'] = 'fr'
219                 formats.extend(</b></font>m3u8_formats)
220         self._sort_formats(formats)
221         video = (self._download_json(
222             self._API_BASE_URL + 'video/%s' % video_id, video_id,
223             'Downloading additional video metadata', fatal=False) or {}).get('video') or {}
224 <a name="1"></a>        show = video.get('show') or {}
225         return {
226             <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>'id': video_id,
227             'title': title,
228             'description': strip_or_none(metas.get('summary') or video.get('summary')),
229             'thumbnail': video_info.get('image') or player.get('image'),
230             'formats': formats,
231             'subtitles': self.extract_subtitles(</b></font>sub_url, video_id),
232             'episode': metas.get('subtitle') or video.get('name'),
233             'episode_number': int_or_none(video.get('shortNumber')),
234             'series': show.get('title'),
235             'season_number': int_or_none(video.get('season')),
236             'duration': int_or_none(video_info.get('duration') or video.get('duration')),
237             'release_date': unified_strdate(video.get('releaseDate')),
238             'average_rating': float_or_none(video.get('rating') or metas.get('rating')),
239             'comment_count': int_or_none(video.get('commentsCount')),
240         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>drtv.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>from __future__ import unicode_literals
2 import binascii
3 import hashlib
4 import re
5 from .common import InfoExtractor
6 from ..aes import aes_cbc_decrypt
7 from ..compat import compat_urllib_parse_unquote
8 from ..utils import (
9     bytes_to_intlist,
10     ExtractorError,
11     int_or_none,
12     intlist_to_bytes,
13     float_or_none,
14     mimetype2ext,
15     str_or_none,
16     try_get,
17     unified_timestamp,
18     update_url_query,
19     url_or_none,
20 )
21 class DRTVIE(InfoExtractor):
22     _VALID_URL = r'''(?x)
23                     https?://
24                         (?:
25                             (?:www\.)?dr\.dk/(?:tv/se|nyheder|radio(?:/ondemand)?)/(?:[^/]+/)*|
26                             (?:www\.)?(?:dr\.dk|dr-massive\.com)/drtv/(?:se|episode|program)/
27                         )
28                         (?P&lt;id&gt;[\da-z_-]+)
29                     '''
30     _GEO_BYPASS = False
31     _GEO_COUNTRIES =</b></font> ['DK']
32     IE_NAME = 'drtv'
33     _TESTS = [{
34         'url': 'https://www.dr.dk/tv/se/boern/ultra/klassen-ultra/klassen-darlig-taber-10',
35         'md5': '25e659cccc9a2ed956110a299fdf5983',
36         'info_dict': {
37             'id': 'klassen-darlig-taber-10',
38             'ext': 'mp4',
39             'title': 'Klassen - Dårlig taber (10)',
40             'description': 'md5:815fe1b7fa656ed80580f31e8b3c79aa',
41             'timestamp': 1539085800,
42             'upload_date': '20181009',
43             'duration': 606.84,
44             'series': 'Klassen',
45             'season': 'Klassen I',
46             'season_number': 1,
47             'season_id': 'urn:dr:mu:bundle:57d7e8216187a4031cfd6f6b',
48             'episode': 'Episode 10',
49             'episode_number': 10,
50             'release_year': 2016,
51         },
52         'expected_warnings': ['Unable to download f4m manifest'],
53     }, {
54         'url': 'https://www.dr.dk/nyheder/indland/live-christianias-rydning-af-pusher-street-er-i-gang',
55         'info_dict': {
56             'id': 'urn:dr:mu:programcard:57c926176187a50a9c6e83c6',
57             'ext': 'mp4',
58             'title': 'christiania pusher street ryddes drdkrjpo',
59             'description': 'md5:2a71898b15057e9b97334f61d04e6eb5',
60             'timestamp': 1472800279,
61             'upload_date': '20160902',
62             'duration': 131.4,
63         },
64         'params': {
65             'skip_download': True,
66         },
67         'expected_warnings': ['Unable to download f4m manifest'],
68     }, {
69         'url': 'https://www.dr.dk/tv/se/historien-om-danmark/-/historien-om-danmark-stenalder',
70         'info_dict': {
71             'id': 'historien-om-danmark-stenalder',
72             'ext': 'mp4',
73             'title': 'Historien om Danmark: Stenalder',
74             'description': 'md5:8c66dcbc1669bbc6f873879880f37f2a',
75             'timestamp': 1546628400,
76             'upload_date': '20190104',
77             'duration': 3502.56,
78             'formats': 'mincount:20',
79         },
80         'params': {
81             'skip_download': True,
82         },
83     }, {
84         'url': 'https://www.dr.dk/radio/p4kbh/regionale-nyheder-kh4/p4-nyheder-2019-06-26-17-30-9',
85         'only_matching': True,
86     }, {
87         'url': 'https://www.dr.dk/drtv/se/bonderoeven_71769',
88         'info_dict': {
89             'id': '00951930010',
90             'ext': 'mp4',
91             'title': 'Bonderøven (1:8)',
92             'description': 'md5:3cf18fc0d3b205745d4505f896af8121',
93             'timestamp': 1546542000,
94             'upload_date': '20190103',
95             'duration': 2576.6,
96         },
97         'params': {
98             'skip_download': True,
99         },
100     }, {
101         'url': 'https://www.dr.dk/drtv/episode/bonderoeven_71769',
102         'only_matching': True,
103     }, {
104         'url': 'https://dr-massive.com/drtv/se/bonderoeven_71769',
105         'only_matching': True,
106     }, {
107         'url': 'https://www.dr.dk/drtv/program/jagten_220924',
108         'only_matching': True,
109     }]
110     def _real_extract(self, url):
111         video_id = self._match_id(url)
112         webpage = self._download_webpage(url, video_id)
113         if '&gt;Programmet er ikke længere tilgængeligt' in webpage:
114             raise ExtractorError(
115                 'Video %s is not available' % video_id, expected=True)
116         video_id = self._search_regex(
117             (r'data-(?:material-identifier|episode-slug)="([^"]+)"',
118              r'data-resource="[^&gt;"]+mu/programcard/expanded/([^"]+)"'),
119             webpage, 'video id', default=None)
120         if not video_id:
121             video_id = self._search_regex(
122                 r'(urn(?:%3A|:)dr(?:%3A|:)mu(?:%3A|:)programcard(?:%3A|:)[\da-f]+)',
123                 webpage, 'urn', default=None)
124             if video_id:
125                 video_id = compat_urllib_parse_unquote(video_id)
126         _PROGRAMCARD_BASE = 'https://www.dr.dk/mu-online/api/1.4/programcard'
127         query = {'expanded': 'true'}
128         if video_id:
129             programcard_url = '%s/%s' % (_PROGRAMCARD_BASE, video_id)
130         else:
131             programcard_url = _PROGRAMCARD_BASE
132             page = self._parse_json(
133                 self._search_regex(
134                     r'data\s*=\s*({.+?})\s*(?:;|&lt;/script)', webpage,
135                     'data'), '1')['cache']['page']
136             page = page[list(page.keys())[0]]
137             item = try_get(
138                 page, (lambda x: x['item'], lambda x: x['entries'][0]['item']),
139                 dict)
140             video_id = item['customId'].split(':')[-1]
141             query['productionnumber'] = video_id
142         data = self._download_json(
143             programcard_url, video_id, 'Downloading video JSON', query=query)
144         title = str_or_none(data.get('Title')) or re.sub(
145             r'\s*\|\s*(?:TV\s*\|\s*DR|DRTV)$', '',
146             self._og_search_title(webpage))
147         description = self._og_search_description(
148             webpage, default=None) or data.get('Description')
149         timestamp = unified_timestamp(
150             data.get('PrimaryBroadcastStartTime') or data.get('SortDateTime'))
151         thumbnail = None
152         duration = None
153         restricted_to_denmark = False
154         formats = []
155         subtitles = {}
156         assets = []
157         primary_asset = data.get('PrimaryAsset')
158         if isinstance(primary_asset, dict):
159             assets.append(primary_asset)
160         secondary_assets = data.get('SecondaryAssets')
161         if isinstance(secondary_assets, list):
162             for secondary_asset in secondary_assets:
163                 if isinstance(secondary_asset, dict):
164                     assets.append(secondary_asset)
165         def hex_to_bytes(hex):
166             return binascii.a2b_hex(hex.encode('ascii'))
167         def decrypt_uri(e):
168             n = int(e[2:10], 16)
169             a = e[10 + n:]
170             data = bytes_to_intlist(hex_to_bytes(e[10:10 + n]))
171             key = bytes_to_intlist(hashlib.sha256(
172                 ('%s:sRBzYNXBzkKgnjj8pGtkACch' % a).encode('utf-8')).digest())
173             iv = bytes_to_intlist(hex_to_bytes(a))
174             decrypted = aes_cbc_decrypt(data, key, iv)
175             return intlist_to_bytes(
176                 decrypted[:-decrypted[-1]]).decode('utf-8').split('?')[0]
177         for asset in assets:
178             kind = asset.get('Kind')
179             if kind == 'Image':
180                 thumbnail = url_or_none(asset.get('Uri'))
181             elif kind in ('VideoResource', 'AudioResource'):
182                 duration = float_or_none(asset.get('DurationInMilliseconds'), 1000)
183                 restricted_to_denmark = asset.get('RestrictedToDenmark')
184                 asset_target = asset.get('Target')
185                 for link in asset.get('Links', []):
186                     uri = link.get('Uri')
187                     if not uri:
188                         encrypted_uri = link.get('EncryptedUri')
189                         if not encrypted_uri:
190                             continue
191                         try:
192                             uri = decrypt_uri(encrypted_uri)
193                         except Exception:
194                             self.report_warning(
195                                 'Unable to decrypt EncryptedUri', video_id)
196                             continue
197                     uri = url_or_none(uri)
198                     if not uri:
199                         continue
200                     target = link.get('Target')
201                     format_id = target or ''
202                     if asset_target in ('SpokenSubtitles', 'SignLanguage', 'VisuallyInterpreted'):
203                         preference = -1
204                         format_id += '-%s' % asset_target
205                     elif asset_target == 'Default':
206                         preference = 1
207 <a name="0"></a>                    else:
208                         preference = None
209                     if target == 'HDS':
210                         f4m_formats <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= self._extract_f4m_formats(
211                             uri + '?hdcore=3.3.0&amp;plugin=aasp-3.3.0.99.43',
212                             video_id, preference, f4m_id=format_id, fatal=False)
213                         if kind == 'AudioResource':
214                             for f in f4m_formats:
215                                 f['vcodec'] = 'none'
216                         formats.extend(</b></font>f4m_formats)
217                     elif target == 'HLS':
218                         formats.extend(self._extract_m3u8_formats(
219                             uri, video_id, 'mp4', entry_protocol='m3u8_native',
220                             preference=preference, m3u8_id=format_id,
221                             fatal=False))
222                     else:
223                         bitrate = link.get('Bitrate')
224                         if bitrate:
225                             format_id += '-%s' % bitrate
226                         formats.append({
227                             'url': uri,
228                             'format_id': format_id,
229                             'tbr': int_or_none(bitrate),
230                             'ext': link.get('FileFormat'),
231                             'vcodec': 'none' if kind == 'AudioResource' else None,
232                             'preference': preference,
233                         })
234             subtitles_list = asset.get('SubtitlesList') or asset.get('Subtitleslist')
235             if isinstance(subtitles_list, list):
236                 LANGS = {
237                     'Danish': 'da',
238                 }
239                 for subs in subtitles_list:
240                     if not isinstance(subs, dict):
241                         continue
242 <a name="1"></a>                    sub_uri = url_or_none(subs.get('Uri'))
243                     if not sub_uri:
244                         continue
245                     lang = subs<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.get('Language') or 'da'
246                     subtitles.setdefault(LANGS.get(lang, lang), []).append({
247                         'url': sub_uri,
248                         'ext': mimetype2ext(subs.get(</b></font>'MimeType')) or 'vtt'
249                     })
250         if not formats and restricted_to_denmark:
251             self.raise_geo_restricted(
252                 'Unfortunately, DR is not allowed to show this program outside Denmark.',
253                 countries=self._GEO_COUNTRIES)
254         self._sort_formats(formats)
255         return {
256             'id': video_id,
257             'title': title,
258             'description': description,
259             'thumbnail': thumbnail,
260             'timestamp': timestamp,
261             'duration': duration,
262             'formats': formats,
263             'subtitles': subtitles,
264             'series': str_or_none(data.get('SeriesTitle')),
265             'season': str_or_none(data.get('SeasonTitle')),
266             'season_number': int_or_none(data.get('SeasonNumber')),
267             'season_id': str_or_none(data.get('SeasonUrn')),
268             'episode': str_or_none(data.get('EpisodeTitle')),
269             'episode_number': int_or_none(data.get('EpisodeNumber')),
270             'release_year': int_or_none(data.get('ProductionYear')),
271         }
272 class DRTVLiveIE(InfoExtractor):
273     IE_NAME = 'drtv:live'
274     _VALID_URL = r'https?://(?:www\.)?dr\.dk/(?:tv|TV)/live/(?P&lt;id&gt;[\da-z-]+)'
275     _GEO_COUNTRIES = ['DK']
276     _TEST = {
277         'url': 'https://www.dr.dk/tv/live/dr1',
278         'info_dict': {
279             'id': 'dr1',
280             'ext': 'mp4',
281             'title': 're:^DR1 [0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$',
282         },
283         'params': {
284             'skip_download': True,
285         },
286     }
287     def _real_extract(self, url):
288         channel_id = self._match_id(url)
289         channel_data = self._download_json(
290             'https://www.dr.dk/mu-online/api/1.0/channel/' + channel_id,
291             channel_id)
292         title = self._live_title(channel_data['Title'])
293         formats = []
294         for streaming_server in channel_data.get('StreamingServers', []):
295             server = streaming_server.get('Server')
296             if not server:
297                 continue
298             link_type = streaming_server.get('LinkType')
299             for quality in streaming_server.get('Qualities', []):
300                 for stream in quality.get('Streams', []):
301                     stream_path = stream.get('Stream')
302                     if not stream_path:
303                         continue
304                     stream_url = update_url_query(
305                         '%s/%s' % (server, stream_path), {'b': ''})
306                     if link_type == 'HLS':
307                         formats.extend(self._extract_m3u8_formats(
308                             stream_url, channel_id, 'mp4',
309                             m3u8_id=link_type, fatal=False, live=True))
310                     elif link_type == 'HDS':
311                         formats.extend(self._extract_f4m_formats(update_url_query(
312                             '%s/%s' % (server, stream_path), {'hdcore': '3.7.0'}),
313                             channel_id, f4m_id=link_type, fatal=False))
314         self._sort_formats(formats)
315         return {
316             'id': channel_id,
317             'title': title,
318             'thumbnail': channel_data.get('PrimaryImageUri'),
319             'formats': formats,
320             'is_live': True,
321         }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
