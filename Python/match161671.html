<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for query.py &amp; debian_ip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for query.py &amp; debian_ip.py
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>query.py (4.972376%)<th>debian_ip.py (1.384083%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(424-426)<td><a href="#" name="0">(1545-1548)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(128-129)<td><a href="#" name="1">(1243-1244)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(17-28)<td><a href="#" name="2">(14-25)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>query.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import os
3 import time
4 import salt.utils.files
5 import salt.utils.fsutils
6 import salt.utils.network
7 from salt.modules.inspectlib import EnvLoader
8 from salt.modules.inspectlib.entities import Package, PackageCfgFile, PayloadFile
9 from salt.modules.inspectlib.exceptions import InspectorQueryException, SIException
10 log = logging.getLogger(</b></font>__name__)
11 class SysInfo:
12     def __init__(self, systype):
13         if systype.lower() == "solaris":
14             raise SIException("Platform {} not (yet) supported.".format(systype))
15     def _grain(self, grain):
16         return __grains__.get(grain, "N/A")
17     def _get_disk_size(self, device):
18         out = __salt__["cmd.run_all"]("df {}".format(device))
19         if out["retcode"]:
20             msg = "Disk size info error: {}".format(out["stderr"])
21             log.error(msg)
22             raise SIException(msg)
23         devpath, blocks, used, available, used_p, mountpoint = (
24             elm for elm in out["stdout"].split(os.linesep)[-1].split(" ") if elm
25         )
26         return {
27             "device": devpath,
28             "blocks": blocks,
29             "used": used,
30             "available": available,
31             "used (%)": used_p,
32             "mounted": mountpoint,
33         }
34     def _get_fs(self):
35         data = dict()
36         for dev, dev_data in salt.utils.fsutils._blkid().items():
37             dev = self._get_disk_size(dev)
38             device = dev.pop("device")
39             dev["type"] = dev_data["type"]
40             data[device] = dev
41         return data
42     def _get_mounts(self):
43         return salt.utils.fsutils._get_mounts()
44     def _get_cpu(self):
45         out = __salt__["cmd.run_all"]("lscpu")
46         salt.utils.fsutils._verify_run(out)
47         data = dict()
48         for descr, value in [
49             elm.split(":", 1) for elm in out["stdout"].split(os.linesep)
50         ]:
51             data[descr.strip()] = value.strip()
52         return data
53     def _get_mem(self):
54         out = __salt__["cmd.run_all"]("vmstat -s")
55         if out["retcode"]:
56             raise SIException("Memory info error: {}".format(out["stderr"]))
57         ret = dict()
58         for line in out["stdout"].split(os.linesep):
59             line = line.strip()
60             if not line:
61                 continue
62             size, descr = line.split(" ", 1)
63             if descr.startswith("K "):
64                 descr = descr[2:]
65                 size = size + "K"
66             ret[descr] = size
67         return ret
68     def _get_network(self):
69         data = dict()
70         data<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["interfaces"] = salt.utils.network.interfaces()
71         data["subnets"] = salt.utils.network.subnets(</b></font>)
72         return data
73     def _get_os(self):
74         return {
75             "name": self._grain("os"),
76             "family": self._grain("os_family"),
77             "arch": self._grain("osarch"),
78             "release": self._grain("osrelease"),
79         }
80 class Query(EnvLoader):
81     SCOPES = [
82         "changes",
83         "configuration",
84         "identity",
85         "system",
86         "software",
87         "services",
88         "payload",
89         "all",
90     ]
91     def __init__(self, scope, cachedir=None):
92         if scope and scope not in self.SCOPES:
93             raise InspectorQueryException(
94                 "Unknown scope: {}. Must be one of: {}".format(
95                     repr(scope), ", ".join(self.SCOPES)
96                 )
97             )
98         elif not scope:
99             raise InspectorQueryException(
100                 "Scope cannot be empty. Must be one of: {}".format(
101                     ", ".join(self.SCOPES)
102                 )
103             )
104         EnvLoader.__init__(self, cachedir=cachedir)
105         self.scope = "_" + scope
106         self.local_identity = dict()
107     def __call__(self, *args, **kwargs):
108         return getattr(self, self.scope)(*args, **kwargs)
109     def _changes(self, *args, **kwargs):
110         raise Exception("Not yet implemented")
111     def _configuration(self, *args, **kwargs):
112         data = dict()
113         self.db.open()
114         for pkg in self.db.get(Package):
115             configs = list()
116             for pkg_cfg in self.db.get(PackageCfgFile, eq={"pkgid": pkg.id}):
117                 configs.append(pkg_cfg.path)
118             data[pkg.name] = configs
119         if not data:
120             raise InspectorQueryException("No inspected configuration yet available.")
121         return data
122     def _get_local_users(self, disabled=None):
123         users = dict()
124         path = "/etc/passwd"
125         with salt.utils.files.fopen(path, "r") as fp_:
126             for line in fp_:
127                 line = line.strip()
128                 if ":" not in line:
129                     continue
130                 name, password, uid, gid, gecos, directory, shell = line.split(":")
131                 active = not (password == "*" or password.startswith("!"))
132                 if (
133                     (disabled is False and active)
134                     or (disabled is True and not active)
135                     or disabled is None
136                 ):
137                     users[name] = {
138                         "uid": uid,
139                         "git": gid,
140                         "info": gecos,
141                         "home": directory,
142                         "shell": shell,
143                         "disabled": not active,
144                     }
145         return users
146     def _get_local_groups(self):
147         groups = dict()
148         path = "/etc/group"
149         with salt.utils.files.fopen(path, "r") as fp_:
150             for line in fp_:
151                 line = line.strip()
152                 if ":" not in line:
153                     continue
154                 name, password, gid, users = line.split(":")
155                 groups[name] = {
156                     "gid": gid,
157                 }
158                 if users:
159                     groups[name]["users"] = users.split(",")
160         return groups
161     def _get_external_accounts(self, locals):
162         users = dict()
163         out = __salt__["cmd.run_all"]("passwd -S -a")
164         if out["retcode"]:
165             return users
166         status = {
167             "L": "Locked",
168             "NP": "No password",
169             "P": "Usable password",
170             "LK": "Locked",
171         }
172         for data in [
173             elm.strip().split(" ")
174             for elm in out["stdout"].split(os.linesep)
175             if elm.strip()
176         ]:
177             if len(data) &lt; 2:
178                 continue
179             name, login = data[:2]
180             if name not in locals:
181                 users[name] = {"login": login, "status": status.get(login, "N/A")}
182         return users
183     def _identity(self, *args, **kwargs):
184         LOCAL = "local accounts"
185         EXT = "external accounts"
186         data = dict()
187         data[LOCAL] = self._get_local_users(disabled=kwargs.get("disabled"))
188         data[EXT] = self._get_external_accounts(data[LOCAL].keys()) or "N/A"
189         data["local groups"] = self._get_local_groups()
190         return data
191     def _system(self, *args, **kwargs):
192         sysinfo = SysInfo(__grains__.get("kernel"))
193         data = dict()
194         data["cpu"] = sysinfo._get_cpu()
195         data["disks"] = sysinfo._get_fs()
196         data["mounts"] = sysinfo._get_mounts()
197         data["memory"] = sysinfo._get_mem()
198         data["network"] = sysinfo._get_network()
199         data["os"] = sysinfo._get_os()
200         return data
201     def _software(self, *args, **kwargs):
202         data = dict()
203         if "exclude" in kwargs:
204             excludes = kwargs["exclude"].split(",")
205         else:
206             excludes = list()
207         os_family = __grains__.get("os_family").lower()
208         if os_family == "suse":
209             LOCKS = "pkg.list_locks"
210             if "products" not in excludes:
211                 products = __salt__["pkg.list_products"]()
212                 if products:
213                     data["products"] = products
214         elif os_family == "redhat":
215             LOCKS = "pkg.get_locked_packages"
216         else:
217             LOCKS = None
218         if LOCKS and "locks" not in excludes:
219             locks = __salt__[LOCKS]()
220             if locks:
221                 data["locks"] = locks
222         if os_family == "suse":
223             PATTERNS = "pkg.list_installed_patterns"
224         elif os_family == "redhat":
225             PATTERNS = "pkg.group_list"
226         else:
227             PATTERNS = None
228         if PATTERNS and "patterns" not in excludes:
229             patterns = __salt__[PATTERNS]()
230             if patterns:
231                 data["patterns"] = patterns
232         if "packages" not in excludes:
233             data["packages"] = __salt__["pkg.list_pkgs"]()
234         if "repositories" not in excludes:
235             repos = __salt__["pkg.list_repos"]()
236             if repos:
237                 data["repositories"] = repos
238         return data
239     def _services(self, *args, **kwargs):
240         return {
241             "enabled": __salt__["service.get_enabled"](),
242             "disabled": __salt__["service.get_disabled"](),
243         }
244     def _id_resolv(self, iid, named=True, uid=True):
245         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not self.local_identity:
246             self.local_identity["users"] = self._get_local_users()
247             self.local_identity["groups"] = self._get_local_groups(</b></font>)
248         if not named:
249             return iid
250         for name, meta in self.local_identity[uid and "users" or "groups"].items():
251             if (uid and int(meta.get("uid", -1)) == iid) or (
252                 not uid and int(meta.get("gid", -1)) == iid
253             ):
254                 return name
255         return iid
256     def _payload(self, *args, **kwargs):
257         def _size_format(size, fmt):
258             if fmt is None:
259                 return size
260             fmt = fmt.lower()
261             if fmt == "b":
262                 return "{} Bytes".format(size)
263             elif fmt == "kb":
264                 return "{} Kb".format(round((float(size) / 0x400), 2))
265             elif fmt == "mb":
266                 return "{} Mb".format(round((float(size) / 0x400 / 0x400), 2))
267             elif fmt == "gb":
268                 return "{} Gb".format(round((float(size) / 0x400 / 0x400 / 0x400), 2))
269         filter = kwargs.get("filter")
270         offset = kwargs.get("offset", 0)
271         timeformat = kwargs.get("time", "tz")
272         if timeformat not in ["ticks", "tz"]:
273             raise InspectorQueryException(
274                 'Unknown "{}" value for parameter "time"'.format(timeformat)
275             )
276         tfmt = (
277             lambda param: timeformat == "tz"
278             and time.strftime("%b %d %Y %H:%M:%S", time.gmtime(param))
279             or int(param)
280         )
281         size_fmt = kwargs.get("size")
282         if size_fmt is not None and size_fmt.lower() not in ["b", "kb", "mb", "gb"]:
283             raise InspectorQueryException(
284                 'Unknown "{}" value for parameter "size". '
285                 "Should be either B, Kb, Mb or Gb".format(timeformat)
286             )
287         owners = kwargs.get("owners", "id")
288         if owners not in ["name", "id"]:
289             raise InspectorQueryException(
290                 'Unknown "{}" value for parameter "owners". '
291                 "Should be either name or id (default)".format(owners)
292             )
293         incl_type = [prm for prm in kwargs.get("type", "").lower().split(",") if prm]
294         if not incl_type:
295             incl_type.append("file")
296         for i_type in incl_type:
297             if i_type not in ["directory", "dir", "d", "file", "f", "link", "l"]:
298                 raise InspectorQueryException(
299                     'Unknown "{}" values for parameter "type". '
300                     "Should be comma separated one or more of "
301                     "dir, file and/or link.".format(", ".join(incl_type))
302                 )
303         self.db.open()
304         if "total" in args:
305             return {"total": len(self.db.get(PayloadFile))}
306         brief = kwargs.get("brief")
307         pld_files = list() if brief else dict()
308         for pld_data in self.db.get(PayloadFile)[
309             offset : offset + kwargs.get("max", 1000)
310         ]:
311             if brief:
312                 pld_files.append(pld_data.path)
313             else:
314                 pld_files[pld_data.path] = {
315                     "uid": self._id_resolv(pld_data.uid, named=(owners == "id")),
316                     "gid": self._id_resolv(
317                         pld_data.gid, named=(owners == "id"), uid=False
318                     ),
319                     "size": _size_format(pld_data.p_size, fmt=size_fmt),
320                     "mode": oct(pld_data.mode),
321                     "accessed": tfmt(pld_data.atime),
322                     "modified": tfmt(pld_data.mtime),
323                     "created": tfmt(pld_data.ctime),
324                 }
325         return pld_files
326     def _all(self, *args, **kwargs):
327         data = dict()
328         data["software"] = self._software(**kwargs)
329         data["system"] = self._system(**kwargs)
330         data["services"] = self._services(**kwargs)
331         try:
332             data["configuration"] = self._configuration(**kwargs)
333         except InspectorQueryException as ex:
334             data["configuration"] = "N/A"
335             log.error(ex)
336         data["payload"] = self._payload(**kwargs) or "N/A"
337         return data
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>debian_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import functools
2 import io
3 import logging
4 <a name="2"></a>import os
5 import os.path
6 import re
7 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import time
8 import jinja2
9 import jinja2.exceptions
10 import salt.utils.dns
11 import salt.utils.files
12 import salt.utils.odict
13 import salt.utils.stringutils
14 import salt.utils.templates
15 import salt.utils.validate.net
16 log = logging.getLogger(</b></font>__name__)
17 JINJA = jinja2.Environment(
18     loader=jinja2.FileSystemLoader(
19         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "debian_ip")
20     )
21 )
22 __virtualname__ = "ip"
23 def __virtual__():
24     if __grains__["os_family"] == "Debian":
25         return __virtualname__
26     return (False, "The debian_ip module could not be loaded: unsupported OS family")
27 _ETHTOOL_CONFIG_OPTS = {
28     "speed": "link-speed",
29     "duplex": "link-duplex",
30     "autoneg": "ethernet-autoneg",
31     "ethernet-port": "ethernet-port",
32     "wol": "ethernet-wol",
33     "driver-message-level": "driver-message-level",
34     "ethernet-pause-rx": "ethernet-pause-rx",
35     "ethernet-pause-tx": "ethernet-pause-tx",
36     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
37     "rx": "offload-rx",
38     "tx": "offload-tx",
39     "sg": "offload-sg",
40     "tso": "offload-tso",
41     "ufo": "offload-ufo",
42     "gso": "offload-gso",
43     "gro": "offload-gro",
44     "lro": "offload-lro",
45     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
46     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
47     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
48     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
49     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
50     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
51     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
52     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
53 }
54 _REV_ETHTOOL_CONFIG_OPTS = {
55     "link-speed": "speed",
56     "link-duplex": "duplex",
57     "ethernet-autoneg": "autoneg",
58     "ethernet-port": "ethernet-port",
59     "ethernet-wol": "wol",
60     "driver-message-level": "driver-message-level",
61     "ethernet-pause-rx": "ethernet-pause-rx",
62     "ethernet-pause-tx": "ethernet-pause-tx",
63     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
64     "offload-rx": "rx",
65     "offload-tx": "tx",
66     "offload-sg": "sg",
67     "offload-tso": "tso",
68     "offload-ufo": "ufo",
69     "offload-gso": "gso",
70     "offload-lro": "lro",
71     "offload-gro": "gro",
72     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
73     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
74     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
75     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
76     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
77     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
78     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
79     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
80 }
81 _DEB_CONFIG_PPPOE_OPTS = {
82     "user": "user",
83     "password": "password",
84     "provider": "provider",
85     "pppoe_iface": "pppoe_iface",
86     "noipdefault": "noipdefault",
87     "usepeerdns": "usepeerdns",
88     "defaultroute": "defaultroute",
89     "holdoff": "holdoff",
90     "maxfail": "maxfail",
91     "hide-password": "hide-password",
92     "lcp-echo-interval": "lcp-echo-interval",
93     "lcp-echo-failure": "lcp-echo-failure",
94     "connect": "connect",
95     "noauth": "noauth",
96     "persist": "persist",
97     "mtu": "mtu",
98     "noaccomp": "noaccomp",
99     "linkname": "linkname",
100 }
101 _DEB_ROUTES_FILE = "/etc/network/routes"
102 _DEB_NETWORK_FILE = "/etc/network/interfaces"
103 _DEB_NETWORK_DIR = "/etc/network/interfaces.d/"
104 _DEB_NETWORK_UP_DIR = "/etc/network/if-up.d/"
105 _DEB_NETWORK_DOWN_DIR = "/etc/network/if-down.d/"
106 _DEB_NETWORK_CONF_FILES = "/etc/modprobe.d/"
107 _DEB_NETWORKING_FILE = "/etc/default/networking"
108 _DEB_HOSTNAME_FILE = "/etc/hostname"
109 _DEB_RESOLV_FILE = "/etc/resolv.conf"
110 _DEB_PPP_DIR = "/etc/ppp/peers/"
111 _CONFIG_TRUE = ["yes", "on", "true", "1", True]
112 _CONFIG_FALSE = ["no", "off", "false", "0", False]
113 _IFACE_TYPES = [
114     "eth",
115     "bond",
116     "alias",
117     "clone",
118     "ipsec",
119     "dialup",
120     "bridge",
121     "slave",
122     "vlan",
123     "pppoe",
124     "source",
125 ]
126 def _error_msg_iface(iface, option, expected):
127     msg = "Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]"
128     return msg.format(iface, option, "|".join(str(e) for e in expected))
129 def _error_msg_routes(iface, option, expected):
130     msg = "Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]"
131     return msg.format(iface, option, expected)
132 def _log_default_iface(iface, opt, value):
133     log.info(
134         "Using default option -- Interface: %s Option: %s Value: %s", iface, opt, value
135     )
136 def _error_msg_network(option, expected):
137     msg = "Invalid network setting -- Setting: {0}, Expected: [{1}]"
138     return msg.format(option, "|".join(str(e) for e in expected))
139 def _log_default_network(opt, value):
140     log.info("Using existing setting -- Setting: %s Value: %s", opt, value)
141 def _raise_error_iface(iface, option, expected):
142     msg = _error_msg_iface(iface, option, expected)
143     log.error(msg)
144     raise AttributeError(msg)
145 def _raise_error_network(option, expected):
146     msg = _error_msg_network(option, expected)
147     log.error(msg)
148     raise AttributeError(msg)
149 def _raise_error_routes(iface, option, expected):
150     msg = _error_msg_routes(iface, option, expected)
151     log.error(msg)
152     raise AttributeError(msg)
153 def _read_file(path):
154     try:
155         with salt.utils.files.flopen(path, "rb") as contents:
156             return [
157                 salt.utils.stringutils.to_str(line) for line in contents.readlines()
158             ]
159     except OSError:
160         return ""
161 def _parse_resolve():
162     return salt.utils.dns.parse_resolv(_DEB_RESOLV_FILE)
163 def _parse_domainname():
164     return _parse_resolve().get("domain", "")
165 def _parse_searchdomain():
166     return _parse_resolve().get("search", "")
167 def _parse_hostname():
168     contents = _read_file(_DEB_HOSTNAME_FILE)
169     if contents:
170         return contents[0].split("\n")[0]
171     else:
172         return ""
173 def _parse_current_network_settings():
174     opts = salt.utils.odict.OrderedDict()
175     opts["networking"] = ""
176     if os.path.isfile(_DEB_NETWORKING_FILE):
177         with salt.utils.files.fopen(_DEB_NETWORKING_FILE) as contents:
178             for line in contents:
179                 salt.utils.stringutils.to_unicode(line)
180                 if line.startswith("#"):
181                     continue
182                 elif line.startswith("CONFIGURE_INTERFACES"):
183                     opts["networking"] = line.split("=", 1)[1].strip()
184     hostname = _parse_hostname()
185     domainname = _parse_domainname()
186     searchdomain = _parse_searchdomain()
187     opts["hostname"] = hostname
188     opts["domainname"] = domainname
189     opts["searchdomain"] = searchdomain
190     return opts
191 def __ipv4_quad(value):
192     return (salt.utils.validate.net.ipv4_addr(value), value, "dotted IPv4 address")
193 def __ipv6(value):
194     return (salt.utils.validate.net.ipv6_addr(value), value, "IPv6 address")
195 def __mac(value):
196     return (salt.utils.validate.net.mac(value), value, "MAC address")
197 def __anything(value):
198     return (True, value, None)
199 def __int(value):
200     valid, _value = False, value
201     try:
202         _value = int(value)
203         valid = True
204     except ValueError:
205         pass
206     return (valid, _value, "integer")
207 def __float(value):
208     valid, _value = False, value
209     try:
210         _value = float(value)
211         valid = True
212     except ValueError:
213         pass
214     return (valid, _value, "float")
215 def __ipv4_netmask(value):
216     valid, errmsg = False, "dotted quad or integer CIDR (0-&gt;32)"
217     valid, value, _ = __int(value)
218     if not (valid and 0 &lt;= value &lt;= 32):
219         valid = salt.utils.validate.net.netmask(value)
220     return (valid, value, errmsg)
221 def __ipv6_netmask(value):
222     valid, errmsg = False, "IPv6 netmask (0-&gt;128)"
223     valid, value, _ = __int(value)
224     valid = valid and 0 &lt;= value &lt;= 128
225     return (valid, value, errmsg)
226 def __within2(value, within=None, errmsg=None, dtype=None):
227     valid, _value = False, value
228     if dtype:
229         try:
230             _value = dtype(value)  # TODO: this is a bit loose when dtype is a class
231             valid = _value in within
232         except ValueError:
233             pass
234     else:
235         valid = _value in within
236     if errmsg is None:
237         if dtype:
238             typename = getattr(
239                 dtype,
240                 "__name__",
241                 hasattr(dtype, "__class__") and getattr(dtype.__class__, "name", dtype),
242             )
243             errmsg = "{} within '{}'".format(typename, within)
244         else:
245             errmsg = "within '{}'".format(within)
246     return (valid, _value, errmsg)
247 def __within(within=None, errmsg=None, dtype=None):
248     return functools.partial(__within2, within=within, errmsg=errmsg, dtype=dtype)
249 def __space_delimited_list(value):
250     if isinstance(value, str):
251         value = value.strip().split()
252     if hasattr(value, "__iter__") and value != []:
253         return (True, value, "space-delimited string")
254     else:
255         return (
256             False,
257             value,
258             "{} is not a valid space-delimited value.\n".format(value),
259         )
260 SALT_ATTR_TO_DEBIAN_ATTR_MAP = {
261     "dns": "dns-nameservers",
262     "search": "dns-search",
263     "hwaddr": "hwaddress",  # TODO: this limits bootp functionality
264     "ipaddr": "address",
265     "ipaddrs": "addresses",
266 }
267 DEBIAN_ATTR_TO_SALT_ATTR_MAP = {v: k for (k, v) in SALT_ATTR_TO_DEBIAN_ATTR_MAP.items()}
268 DEBIAN_ATTR_TO_SALT_ATTR_MAP["address"] = "address"
269 DEBIAN_ATTR_TO_SALT_ATTR_MAP["hwaddress"] = "hwaddress"
270 IPV4_VALID_PROTO = ["bootp", "dhcp", "static", "manual", "loopback", "ppp"]
271 IPV4_ATTR_MAP = {
272     "proto": __within(IPV4_VALID_PROTO, dtype=str),
273     "address": __ipv4_quad,
274     "addresses": __anything,
275     "netmask": __ipv4_netmask,
276     "broadcast": __ipv4_quad,
277     "metric": __int,
278     "gateway": __ipv4_quad,  # supports a colon-delimited list
279     "pointopoint": __ipv4_quad,
280     "hwaddress": __mac,
281     "mtu": __int,
282     "scope": __within(["global", "link", "host"], dtype=str),
283     "hostname": __anything,
284     "leasehours": __int,
285     "leasetime": __int,
286     "vendor": __anything,
287     "client": __anything,
288     "bootfile": __anything,
289     "server": __ipv4_quad,
290     "hwaddr": __mac,
291     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
292     "endpoint": __ipv4_quad,
293     "dstaddr": __ipv4_quad,
294     "local": __ipv4_quad,
295     "ttl": __int,
296     "slaves": __anything,
297     "provider": __anything,
298     "unit": __int,
299     "options": __anything,
300     "dns-nameservers": __space_delimited_list,
301     "dns-search": __space_delimited_list,
302     "vlan-raw-device": __anything,
303     "network": __anything,  # i don't know what this is
304     "test": __anything,  # TODO
305     "enable_ipv4": __anything,  # TODO
306     "enable_ipv6": __anything,  # TODO
307 }
308 IPV6_VALID_PROTO = ["auto", "loopback", "static", "manual", "dhcp", "v4tunnel", "6to4"]
309 IPV6_ATTR_MAP = {
310     "proto": __within(IPV6_VALID_PROTO),
311     "address": __ipv6,
312     "addresses": __anything,
313     "netmask": __ipv6_netmask,
314     "broadcast": __ipv6,
315     "gateway": __ipv6,  # supports a colon-delimited list
316     "hwaddress": __mac,
317     "mtu": __int,
318     "scope": __within(["global", "site", "link", "host"], dtype=str),
319     "privext": __within([0, 1, 2], dtype=int),
320     "dhcp": __within([0, 1], dtype=int),
321     "media": __anything,
322     "accept_ra": __within([0, 1, 2], dtype=int),
323     "autoconf": __within([0, 1], dtype=int),
324     "preferred-lifetime": __int,
325     "dad-attempts": __int,  # 0 to disable
326     "dad-interval": __float,
327     "slaves": __anything,
328     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
329     "endpoint": __ipv4_quad,
330     "local": __ipv4_quad,
331     "ttl": __int,
332     "dns-nameservers": __space_delimited_list,
333     "dns-search": __space_delimited_list,
334     "vlan-raw-device": __anything,
335     "test": __anything,  # TODO
336     "enable_ipv4": __anything,  # TODO
337     "enable_ipv6": __anything,  # TODO
338 }
339 WIRELESS_ATTR_MAP = {
340     "wireless-essid": __anything,
341     "wireless-mode": __anything,  # TODO
342     "wpa-ap-scan": __within([0, 1, 2], dtype=int),  # TODO
343     "wpa-conf": __anything,
344     "wpa-driver": __anything,
345     "wpa-group": __anything,
346     "wpa-key-mgmt": __anything,
347     "wpa-pairwise": __anything,
348     "wpa-psk": __anything,
349     "wpa-proto": __anything,  # partial(__within,
350     "wpa-roam": __anything,
351     "wpa-ssid": __anything,  # TODO
352 }
353 ATTRMAPS = {
354     "inet": [IPV4_ATTR_MAP, WIRELESS_ATTR_MAP],
355     "inet6": [IPV6_ATTR_MAP, WIRELESS_ATTR_MAP],
356 }
357 def _validate_interface_option(attr, value, addrfam="inet"):
358     valid, _value, errmsg = False, value, "Unknown validator"
359     attrmaps = ATTRMAPS.get(addrfam, [])
360     for attrmap in attrmaps:
361         if attr in attrmap:
362             validate_func = attrmap[attr]
363             (valid, _value, errmsg) = validate_func(value)
364             break
365     return (valid, _value, errmsg)
366 def _attrmaps_contain_attr(attr):
367     return attr in WIRELESS_ATTR_MAP or attr in IPV4_ATTR_MAP or attr in IPV6_ATTR_MAP
368 def _parse_interfaces(interface_files=None):
369     if interface_files is None:
370         interface_files = []
371         if os.path.exists(_DEB_NETWORK_DIR):
372             interface_files += [
373                 "{}/{}".format(_DEB_NETWORK_DIR, dir)
374                 for dir in os.listdir(_DEB_NETWORK_DIR)
375             ]
376         if os.path.isfile(_DEB_NETWORK_FILE):
377             interface_files.insert(0, _DEB_NETWORK_FILE)
378     adapters = salt.utils.odict.OrderedDict()
379     method = -1
380     for interface_file in interface_files:
381         with salt.utils.files.fopen(interface_file) as interfaces:
382             iface_dict = {}
383             for line in interfaces:
384                 line = salt.utils.stringutils.to_unicode(line)
385                 if line.lstrip().startswith("#") or line.isspace():
386                     continue
387                 if line.startswith("iface"):
388                     sline = line.split()
389                     if len(sline) != 4:
390                         msg = "Interface file malformed: {0}."
391                         msg = msg.format(sline)
392                         log.error(msg)
393                         raise AttributeError(msg)
394                     iface_name = sline[1]
395                     addrfam = sline[2]
396                     method = sline[3]
397                     if iface_name not in adapters:
398                         adapters[iface_name] = salt.utils.odict.OrderedDict()
399                     if "data" not in adapters[iface_name]:
400                         adapters[iface_name]["data"] = salt.utils.odict.OrderedDict()
401                     if addrfam not in adapters[iface_name]["data"]:
402                         adapters[iface_name]["data"][
403                             addrfam
404                         ] = salt.utils.odict.OrderedDict()
405                     iface_dict = adapters[iface_name]["data"][addrfam]
406                     iface_dict["addrfam"] = addrfam
407                     iface_dict["proto"] = method
408                     iface_dict["filename"] = interface_file
409                 elif line[0].isspace():
410                     sline = line.split()
411                     attr, valuestr = line.rstrip().split(None, 1)
412                     if _attrmaps_contain_attr(attr):
413                         if "-" in attr:
414                             attrname = attr.replace("-", "_")
415                         else:
416                             attrname = attr
417                         (valid, value, errmsg) = _validate_interface_option(
418                             attr, valuestr, addrfam
419                         )
420                         if attrname == "address" and "address" in iface_dict:
421                             if "addresses" not in iface_dict:
422                                 iface_dict["addresses"] = []
423                             iface_dict["addresses"].append(value)
424                         else:
425                             iface_dict[attrname] = value
426                     elif attr in _REV_ETHTOOL_CONFIG_OPTS:
427                         if "ethtool" not in iface_dict:
428                             iface_dict["ethtool"] = salt.utils.odict.OrderedDict()
429                         iface_dict["ethtool"][attr] = valuestr
430                     elif attr.startswith("bond"):
431                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
432                         if "bonding" not in iface_dict:
433                             iface_dict["bonding"] = salt.utils.odict.OrderedDict()
434                         iface_dict["bonding"][opt] = valuestr
435                     elif attr.startswith("bridge"):
436                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
437                         if "bridging" not in iface_dict:
438                             iface_dict["bridging"] = salt.utils.odict.OrderedDict()
439                         iface_dict["bridging"][opt] = valuestr
440                     elif attr in [
441                         "up",
442                         "pre-up",
443                         "post-up",
444                         "down",
445                         "pre-down",
446                         "post-down",
447                     ]:
448                         cmd = valuestr
449                         cmd_key = "{}_cmds".format(re.sub("-", "_", attr))
450                         if cmd_key not in iface_dict:
451                             iface_dict[cmd_key] = []
452                         iface_dict[cmd_key].append(cmd)
453                 elif line.startswith("auto"):
454                     for word in line.split()[1:]:
455                         if word not in adapters:
456                             adapters[word] = salt.utils.odict.OrderedDict()
457                         adapters[word]["enabled"] = True
458                 elif line.startswith("allow-hotplug"):
459                     for word in line.split()[1:]:
460                         if word not in adapters:
461                             adapters[word] = salt.utils.odict.OrderedDict()
462                         adapters[word]["hotplug"] = True
463                 elif line.startswith("source"):
464                     if "source" not in adapters:
465                         adapters["source"] = salt.utils.odict.OrderedDict()
466                     if "data" not in adapters["source"]:
467                         adapters["source"]["data"] = salt.utils.odict.OrderedDict()
468                         adapters["source"]["data"]["sources"] = []
469                     adapters["source"]["data"]["sources"].append(line.split()[1])
470     adapters = _filter_malformed_interfaces(adapters=adapters)
471     return adapters
472 def _filter_malformed_interfaces(*, adapters):
473     for iface_name in list(adapters):
474         if iface_name == "source":
475             continue
476         if "data" not in adapters[iface_name]:
477             msg = "Interface file malformed for interface: {}.".format(iface_name)
478             log.error(msg)
479             adapters.pop(iface_name)
480             continue
481         for opt in ["ethtool", "bonding", "bridging"]:
482             for inet in ["inet", "inet6"]:
483                 if inet in adapters[iface_name]["data"]:
484                     if opt in adapters[iface_name]["data"][inet]:
485                         opt_keys = sorted(
486                             adapters[iface_name]["data"][inet][opt].keys()
487                         )
488                         adapters[iface_name]["data"][inet][opt + "_keys"] = opt_keys
489     return adapters
490 def _parse_ethtool_opts(opts, iface):
491     config = {}
492     if "autoneg" in opts:
493         if opts["autoneg"] in _CONFIG_TRUE:
494             config.update({"autoneg": "on"})
495         elif opts["autoneg"] in _CONFIG_FALSE:
496             config.update({"autoneg": "off"})
497         else:
498             _raise_error_iface(iface, "autoneg", _CONFIG_TRUE + _CONFIG_FALSE)
499     if "duplex" in opts:
500         valid = ["full", "half"]
501         if opts["duplex"] in valid:
502             config.update({"duplex": opts["duplex"]})
503         else:
504             _raise_error_iface(iface, "duplex", valid)
505     if "speed" in opts:
506         valid = ["10", "100", "1000", "10000"]
507         if str(opts["speed"]) in valid:
508             config.update({"speed": opts["speed"]})
509         else:
510             _raise_error_iface(iface, opts["speed"], valid)
511     valid = _CONFIG_TRUE + _CONFIG_FALSE
512     for option in ("rx", "tx", "sg", "tso", "ufo", "gso", "gro", "lro"):
513         if option in opts:
514             if opts[option] in _CONFIG_TRUE:
515                 config.update({option: "on"})
516             elif opts[option] in _CONFIG_FALSE:
517                 config.update({option: "off"})
518             else:
519                 _raise_error_iface(iface, option, valid)
520     return config
521 def _parse_ethtool_pppoe_opts(opts, iface):
522     config = {}
523     for opt in _DEB_CONFIG_PPPOE_OPTS:
524         if opt in opts:
525             config[opt] = opts[opt]
526     if "provider" in opts and not opts["provider"]:
527         _raise_error_iface(iface, "provider", _CONFIG_TRUE + _CONFIG_FALSE)
528     valid = _CONFIG_TRUE + _CONFIG_FALSE
529     for option in (
530         "noipdefault",
531         "usepeerdns",
532         "defaultroute",
533         "hide-password",
534         "noauth",
535         "persist",
536         "noaccomp",
537     ):
538         if option in opts:
539             if opts[option] in _CONFIG_TRUE:
540                 config.update({option: "True"})
541             elif opts[option] in _CONFIG_FALSE:
542                 config.update({option: "False"})
543             else:
544                 _raise_error_iface(iface, option, valid)
545     return config
546 def _parse_settings_bond(opts, iface):
547     bond_def = {
548         "ad_select": "0",
549         "tx_queues": "16",
550         "miimon": "100",
551         "arp_interval": "250",
552         "downdelay": "200",
553         "lacp_rate": "0",
554         "max_bonds": "1",
555         "updelay": "0",
556         "use_carrier": "on",
557         "xmit_hash_policy": "layer2",
558     }
559     if opts["mode"] in ["balance-rr", "0"]:
560         log.info("Device: %s Bonding Mode: load balancing (round-robin)", iface)
561         return _parse_settings_bond_0(opts, iface, bond_def)
562     elif opts["mode"] in ["active-backup", "1"]:
563         log.info("Device: %s Bonding Mode: fault-tolerance (active-backup)", iface)
564         return _parse_settings_bond_1(opts, iface, bond_def)
565     elif opts["mode"] in ["balance-xor", "2"]:
566         log.info("Device: %s Bonding Mode: load balancing (xor)", iface)
567         return _parse_settings_bond_2(opts, iface, bond_def)
568     elif opts["mode"] in ["broadcast", "3"]:
569         log.info("Device: %s Bonding Mode: fault-tolerance (broadcast)", iface)
570         return _parse_settings_bond_3(opts, iface, bond_def)
571     elif opts["mode"] in ["802.3ad", "4"]:
572         log.info(
573             "Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation", iface
574         )
575         return _parse_settings_bond_4(opts, iface, bond_def)
576     elif opts["mode"] in ["balance-tlb", "5"]:
577         log.info("Device: %s Bonding Mode: transmit load balancing", iface)
578         return _parse_settings_bond_5(opts, iface, bond_def)
579     elif opts["mode"] in ["balance-alb", "6"]:
580         log.info("Device: %s Bonding Mode: adaptive load balancing", iface)
581         return _parse_settings_bond_6(opts, iface, bond_def)
582     else:
583         valid = [
584             "0",
585             "1",
586             "2",
587             "3",
588             "4",
589             "5",
590             "6",
591             "balance-rr",
592             "active-backup",
593             "balance-xor",
594             "broadcast",
595             "802.3ad",
596             "balance-tlb",
597             "balance-alb",
598         ]
599         _raise_error_iface(iface, "mode", valid)
600 def _parse_settings_bond_0(opts, iface, bond_def):
601     bond = {"mode": "0"}
602     valid = ["list of ips (up to 16)"]
603     if "arp_ip_target" in opts:
604         if isinstance(opts["arp_ip_target"], list):
605             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
606                 bond.update({"arp_ip_target": ""})
607                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
608                     if len(bond["arp_ip_target"]) &gt; 0:
609                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
610                     else:
611                         bond["arp_ip_target"] = ip
612             else:
613                 _raise_error_iface(iface, "arp_ip_target", valid)
614         else:
615             _raise_error_iface(iface, "arp_ip_target", valid)
616     else:
617         _raise_error_iface(iface, "arp_ip_target", valid)
618     if "arp_interval" in opts:
619         try:
620             int(opts["arp_interval"])
621             bond.update({"arp_interval": opts["arp_interval"]})
622         except ValueError:
623             _raise_error_iface(iface, "arp_interval", ["integer"])
624     else:
625         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
626         bond.update({"arp_interval": bond_def["arp_interval"]})
627     return bond
628 def _parse_settings_bond_1(opts, iface, bond_def):
629     bond = {"mode": "1"}
630     for binding in ["miimon", "downdelay", "updelay"]:
631         if binding in opts:
632             try:
633                 int(opts[binding])
634                 bond.update({binding: opts[binding]})
635             except ValueError:
636                 _raise_error_iface(iface, binding, ["integer"])
637         else:
638             _log_default_iface(iface, binding, bond_def[binding])
639             bond.update({binding: bond_def[binding]})
640     if "primary" in opts:
641         bond.update({"primary": opts["primary"]})
642     if not (__grains__["os"] == "Ubuntu" and __grains__["osrelease_info"][0] &gt;= 16):
643         if "use_carrier" in opts:
644             if opts["use_carrier"] in _CONFIG_TRUE:
645                 bond.update({"use_carrier": "1"})
646             elif opts["use_carrier"] in _CONFIG_FALSE:
647                 bond.update({"use_carrier": "0"})
648             else:
649                 valid = _CONFIG_TRUE + _CONFIG_FALSE
650                 _raise_error_iface(iface, "use_carrier", valid)
651         else:
652             _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
653             bond.update({"use_carrier": bond_def["use_carrier"]})
654     return bond
655 def _parse_settings_bond_2(opts, iface, bond_def):
656     bond = {"mode": "2"}
657     valid = ["list of ips (up to 16)"]
658     if "arp_ip_target" in opts:
659         if isinstance(opts["arp_ip_target"], list):
660             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
661                 bond.update({"arp_ip_target": ""})
662                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
663                     if len(bond["arp_ip_target"]) &gt; 0:
664                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
665                     else:
666                         bond["arp_ip_target"] = ip
667             else:
668                 _raise_error_iface(iface, "arp_ip_target", valid)
669         else:
670             _raise_error_iface(iface, "arp_ip_target", valid)
671     else:
672         _raise_error_iface(iface, "arp_ip_target", valid)
673     if "arp_interval" in opts:
674         try:
675             int(opts["arp_interval"])
676             bond.update({"arp_interval": opts["arp_interval"]})
677         except ValueError:
678             _raise_error_iface(iface, "arp_interval", ["integer"])
679     else:
680         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
681         bond.update({"arp_interval": bond_def["arp_interval"]})
682     if "hashing-algorithm" in opts:
683         valid = ["layer2", "layer2+3", "layer3+4"]
684         if opts["hashing-algorithm"] in valid:
685             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
686         else:
687             _raise_error_iface(iface, "hashing-algorithm", valid)
688     return bond
689 def _parse_settings_bond_3(opts, iface, bond_def):
690     bond = {"mode": "3"}
691     for binding in ["miimon", "downdelay", "updelay"]:
692         if binding in opts:
693             try:
694                 int(opts[binding])
695                 bond.update({binding: opts[binding]})
696             except ValueError:
697                 _raise_error_iface(iface, binding, ["integer"])
698         else:
699             _log_default_iface(iface, binding, bond_def[binding])
700             bond.update({binding: bond_def[binding]})
701     if "use_carrier" in opts:
702         if opts["use_carrier"] in _CONFIG_TRUE:
703             bond.update({"use_carrier": "1"})
704         elif opts["use_carrier"] in _CONFIG_FALSE:
705             bond.update({"use_carrier": "0"})
706         else:
707             valid = _CONFIG_TRUE + _CONFIG_FALSE
708             _raise_error_iface(iface, "use_carrier", valid)
709     else:
710         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
711         bond.update({"use_carrier": bond_def["use_carrier"]})
712     return bond
713 def _parse_settings_bond_4(opts, iface, bond_def):
714     bond = {"mode": "4"}
715     for binding in ["miimon", "downdelay", "updelay", "lacp_rate", "ad_select"]:
716         if binding in opts:
717             if binding == "lacp_rate":
718                 if opts[binding] == "fast":
719                     opts.update({binding: "1"})
720                 if opts[binding] == "slow":
721                     opts.update({binding: "0"})
722                 valid = ["fast", "1", "slow", "0"]
723             else:
724                 valid = ["integer"]
725             try:
726                 int(opts[binding])
727                 bond.update({binding: opts[binding]})
728             except ValueError:
729                 _raise_error_iface(iface, binding, valid)
730         else:
731             _log_default_iface(iface, binding, bond_def[binding])
732             bond.update({binding: bond_def[binding]})
733     if "use_carrier" in opts:
734         if opts["use_carrier"] in _CONFIG_TRUE:
735             bond.update({"use_carrier": "1"})
736         elif opts["use_carrier"] in _CONFIG_FALSE:
737             bond.update({"use_carrier": "0"})
738         else:
739             valid = _CONFIG_TRUE + _CONFIG_FALSE
740             _raise_error_iface(iface, "use_carrier", valid)
741     else:
742         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
743         bond.update({"use_carrier": bond_def["use_carrier"]})
744     if "hashing-algorithm" in opts:
745         valid = ["layer2", "layer2+3", "layer3+4"]
746         if opts["hashing-algorithm"] in valid:
747             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
748         else:
749             _raise_error_iface(iface, "hashing-algorithm", valid)
750     return bond
751 def _parse_settings_bond_5(opts, iface, bond_def):
752     bond = {"mode": "5"}
753     for binding in ["miimon", "downdelay", "updelay"]:
754         if binding in opts:
755             try:
756                 int(opts[binding])
757                 bond.update({binding: opts[binding]})
758             except ValueError:
759                 _raise_error_iface(iface, binding, ["integer"])
760         else:
761             _log_default_iface(iface, binding, bond_def[binding])
762             bond.update({binding: bond_def[binding]})
763     if "use_carrier" in opts:
764         if opts["use_carrier"] in _CONFIG_TRUE:
765             bond.update({"use_carrier": "1"})
766         elif opts["use_carrier"] in _CONFIG_FALSE:
767             bond.update({"use_carrier": "0"})
768         else:
769             valid = _CONFIG_TRUE + _CONFIG_FALSE
770             _raise_error_iface(iface, "use_carrier", valid)
771     else:
772         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
773         bond.update({"use_carrier": bond_def["use_carrier"]})
774     if "primary" in opts:
775         bond.update({"primary": opts["primary"]})
776     return bond
777 def _parse_settings_bond_6(opts, iface, bond_def):
778     bond = {"mode": "6"}
779     for binding in ["miimon", "downdelay", "updelay"]:
780         if binding in opts:
781             try:
782                 int(opts[binding])
783                 bond.update({binding: opts[binding]})
784             except ValueError:
785                 _raise_error_iface(iface, binding, ["integer"])
786         else:
787             _log_default_iface(iface, binding, bond_def[binding])
788             bond.update({binding: bond_def[binding]})
789     if "use_carrier" in opts:
790         if opts["use_carrier"] in _CONFIG_TRUE:
791             bond.update({"use_carrier": "1"})
792         elif opts["use_carrier"] in _CONFIG_FALSE:
793             bond.update({"use_carrier": "0"})
794         else:
795             valid = _CONFIG_TRUE + _CONFIG_FALSE
796             _raise_error_iface(iface, "use_carrier", valid)
797     else:
798         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
799         bond.update({"use_carrier": bond_def["use_carrier"]})
800     if "primary" in opts:
801         bond.update({"primary": opts["primary"]})
802     return bond
803 def _parse_bridge_opts(opts, iface):
804     config = {}
805     if "ports" in opts:
806         if isinstance(opts["ports"], list):
807             opts["ports"] = " ".join(opts["ports"])
808         config.update({"ports": opts["ports"]})
809     for opt in ["ageing", "fd", "gcint", "hello", "maxage"]:
810         if opt in opts:
811             try:
812                 float(opts[opt])
813                 config.update({opt: opts[opt]})
814             except ValueError:
815                 _raise_error_iface(iface, opt, ["float"])
816     for opt in ["bridgeprio", "maxwait"]:
817         if opt in opts:
818             if isinstance(opts[opt], int):
819                 config.update({opt: opts[opt]})
820             else:
821                 _raise_error_iface(iface, opt, ["integer"])
822     if "hw" in opts:
823         if re.match(
824             "[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", opts["hw"].lower()
825         ):
826             config.update({"hw": opts["hw"]})
827         else:
828             _raise_error_iface(iface, "hw", ["valid MAC address"])
829     for opt in ["pathcost", "portprio"]:
830         if opt in opts:
831             try:
832                 port, cost_or_prio = opts[opt].split()
833                 int(cost_or_prio)
834                 config.update({opt: "{} {}".format(port, cost_or_prio)})
835             except ValueError:
836                 _raise_error_iface(iface, opt, ["interface integer"])
837     if "stp" in opts:
838         if opts["stp"] in _CONFIG_TRUE:
839             config.update({"stp": "on"})
840         elif opts["stp"] in _CONFIG_FALSE:
841             config.update({"stp": "off"})
842         else:
843             _raise_error_iface(iface, "stp", _CONFIG_TRUE + _CONFIG_FALSE)
844     if "waitport" in opts:
845         if isinstance(opts["waitport"], int):
846             config.update({"waitport": opts["waitport"]})
847         else:
848             values = opts["waitport"].split()
849             waitport_time = values.pop(0)
850             if waitport_time.isdigit() and values:
851                 config.update(
852                     {"waitport": "{} {}".format(waitport_time, " ".join(values))}
853                 )
854             else:
855                 _raise_error_iface(iface, opt, ["integer [interfaces]"])
856     return config
857 def _parse_settings_eth(opts, iface_type, enabled, iface):
858     adapters = salt.utils.odict.OrderedDict()
859     adapters[iface] = salt.utils.odict.OrderedDict()
860     adapters[iface]["type"] = iface_type
861 <a name="1"></a>
862     adapters[iface]["data"] = salt.utils.odict.OrderedDict()
863     iface_data = adapters[iface]["data"]
864     iface_data<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["inet"] = salt.utils.odict.OrderedDict()
865     iface_data["inet6"] = salt.utils.odict.OrderedDict(</b></font>)
866     if enabled:
867         adapters[iface]["enabled"] = True
868     if opts.get("hotplug", False):
869         adapters[iface]["hotplug"] = True
870     if opts.get("enable_ipv6", None) and opts.get("iface_type", "") == "vlan":
871         iface_data["inet6"]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
872     for addrfam in ["inet", "inet6"]:
873         if iface_type not in ["bridge"]:
874             tmp_ethtool = _parse_ethtool_opts(opts, iface)
875             if tmp_ethtool:
876                 ethtool = {}
877                 for item in tmp_ethtool:
878                     ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item]
879                 iface_data[addrfam]["ethtool"] = ethtool
880                 iface_data[addrfam]["ethtool_keys"] = sorted(ethtool)
881         if iface_type == "bridge":
882             bridging = _parse_bridge_opts(opts, iface)
883             if bridging:
884                 iface_data[addrfam]["bridging"] = bridging
885                 iface_data[addrfam]["bridging_keys"] = sorted(bridging)
886                 iface_data[addrfam]["addrfam"] = addrfam
887         elif iface_type == "bond":
888             bonding = _parse_settings_bond(opts, iface)
889             if bonding:
890                 iface_data[addrfam]["bonding"] = bonding
891                 iface_data[addrfam]["bonding"]["slaves"] = opts["slaves"]
892                 iface_data[addrfam]["bonding_keys"] = sorted(bonding)
893                 iface_data[addrfam]["addrfam"] = addrfam
894         elif iface_type == "slave":
895             adapters[iface]["master"] = opts["master"]
896             opts["proto"] = "manual"
897             iface_data[addrfam]["master"] = adapters[iface]["master"]
898             iface_data[addrfam]["addrfam"] = addrfam
899         elif iface_type == "vlan":
900             iface_data[addrfam]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
901             iface_data[addrfam]["addrfam"] = addrfam
902         elif iface_type == "pppoe":
903             tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface)
904             if tmp_ethtool:
905                 for item in tmp_ethtool:
906                     adapters[iface]["data"][addrfam][
907                         _DEB_CONFIG_PPPOE_OPTS[item]
908                     ] = tmp_ethtool[item]
909             iface_data[addrfam]["addrfam"] = addrfam
910     opts.pop("mode", None)
911     for opt, val in opts.items():
912         inet = None
913         if opt.startswith("ipv4"):
914             opt = opt[4:]
915             inet = "inet"
916             iface_data["inet"]["addrfam"] = "inet"
917         elif opt.startswith("ipv6"):
918             iface_data["inet6"]["addrfam"] = "inet6"
919             opt = opt[4:]
920             inet = "inet6"
921         elif opt in [
922             "ipaddr",
923             "address",
924             "ipaddresses",
925             "addresses",
926             "gateway",
927             "proto",
928         ]:
929             iface_data["inet"]["addrfam"] = "inet"
930             inet = "inet"
931         _opt = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(opt, opt)
932         _debopt = _opt.replace("-", "_")
933         for addrfam in ["inet", "inet6"]:
934             (valid, value, errmsg) = _validate_interface_option(
935                 _opt, val, addrfam=addrfam
936             )
937             if not valid:
938                 continue
939             if inet is None and _debopt not in iface_data[addrfam]:
940                 iface_data[addrfam][_debopt] = value
941             elif inet == addrfam:
942                 iface_data[addrfam][_debopt] = value
943     for opt in [
944         "up_cmds",
945         "pre_up_cmds",
946         "post_up_cmds",
947         "down_cmds",
948         "pre_down_cmds",
949         "post_down_cmds",
950     ]:
951         if opt in opts:
952             iface_data["inet"][opt] = opts[opt]
953             iface_data["inet6"][opt] = opts[opt]
954     for (addrfam, opt) in [("inet", "enable_ipv4"), ("inet6", "enable_ipv6")]:
955         if opts.get(opt, None) is False:
956             iface_data.pop(addrfam)
957         elif iface_data[addrfam].get("addrfam", "") != addrfam:
958             iface_data.pop(addrfam)
959     return adapters
960 def _parse_settings_source(opts, iface_type, enabled, iface):
961     adapters = salt.utils.odict.OrderedDict()
962     adapters[iface] = salt.utils.odict.OrderedDict()
963     adapters[iface]["type"] = iface_type
964     adapters[iface]["data"] = salt.utils.odict.OrderedDict()
965     iface_data = adapters[iface]["data"]
966     iface_data["sources"] = [opts["source"]]
967     return adapters
968 def _parse_network_settings(opts, current):
969     opts = {k.lower(): v for (k, v) in opts.items()}
970     current = {k.lower(): v for (k, v) in current.items()}
971     result = {}
972     valid = _CONFIG_TRUE + _CONFIG_FALSE
973     if "enabled" not in opts:
974         try:
975             opts["networking"] = current["networking"]
976             _log_default_network("networking", current["networking"])
977         except ValueError:
978             _raise_error_network("networking", valid)
979     else:
980         opts["networking"] = opts["enabled"]
981     if opts["networking"] in valid:
982         if opts["networking"] in _CONFIG_TRUE:
983             result["networking"] = "yes"
984         elif opts["networking"] in _CONFIG_FALSE:
985             result["networking"] = "no"
986     else:
987         _raise_error_network("networking", valid)
988     if "hostname" not in opts:
989         try:
990             opts["hostname"] = current["hostname"]
991             _log_default_network("hostname", current["hostname"])
992         except ValueError:
993             _raise_error_network("hostname", ["server1.example.com"])
994     if opts["hostname"]:
995         result["hostname"] = opts["hostname"]
996     else:
997         _raise_error_network("hostname", ["server1.example.com"])
998     if "search" in opts:
999         result["search"] = opts["search"]
1000     return result
1001 def _parse_routes(iface, opts):
1002     opts = {k.lower(): v for (k, v) in opts.items()}
1003     result = {}
1004     if "routes" not in opts:
1005         _raise_error_routes(iface, "routes", "List of routes")
1006     for opt in opts:
1007         result[opt] = opts[opt]
1008     return result
1009 def _write_file(iface, data, folder, pattern):
1010     filename = os.path.join(folder, pattern.format(iface))
1011     if not os.path.exists(folder):
1012         msg = "{0} cannot be written. {1} does not exist"
1013         msg = msg.format(filename, folder)
1014         log.error(msg)
1015         raise AttributeError(msg)
1016     with salt.utils.files.flopen(filename, "w") as fout:
1017         fout.write(salt.utils.stringutils.to_str(data))
1018     return filename
1019 def _write_file_routes(iface, data, folder, pattern):
1020     iface = iface.replace(".", "_")
1021     filename = os.path.join(folder, pattern.format(iface))
1022     if not os.path.exists(folder):
1023         msg = "{0} cannot be written. {1} does not exist"
1024         msg = msg.format(filename, folder)
1025         log.error(msg)
1026         raise AttributeError(msg)
1027     with salt.utils.files.flopen(filename, "w") as fout:
1028         fout.write(salt.utils.stringutils.to_str(data))
1029     __salt__["file.set_mode"](filename, "0755")
1030     return filename
1031 def _write_file_network(data, filename, create=False):
1032     if not os.path.exists(filename) and not create:
1033         msg = "{0} cannot be written. {0} does not exist and create is setto False".format(
1034             filename
1035         )
1036         log.error(msg)
1037         raise AttributeError(msg)
1038     with salt.utils.files.flopen(filename, "w") as fout:
1039         fout.write(salt.utils.stringutils.to_str(data))
1040 def _read_temp(data):
1041     tout = io.StringIO()
1042     tout.write(data)
1043     tout.seek(0)
1044     output = tout.readlines()
1045     tout.close()
1046     return output
1047 def _read_temp_ifaces(iface, data):
1048     try:
1049         template = JINJA.get_template("debian_eth.jinja")
1050     except jinja2.exceptions.TemplateNotFound:
1051         log.error("Could not load template debian_eth.jinja")
1052         return ""
1053     ifcfg = template.render({"name": iface, "data": data})
1054     return [item + "\n" for item in ifcfg.split("\n")]
1055 def _write_file_ifaces(iface, data, **settings):
1056     try:
1057         eth_template = JINJA.get_template("debian_eth.jinja")
1058         source_template = JINJA.get_template("debian_source.jinja")
1059     except jinja2.exceptions.TemplateNotFound:
1060         log.error("Could not load template debian_eth.jinja")
1061         return ""
1062     adapters = _parse_interfaces()
1063     adapters[iface] = data
1064 <a name="0"></a>
1065     ifcfg = ""
1066     for adapter in adapters:
1067         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if "type" in adapters[adapter] and adapters[adapter]["type"] == "source":
1068             tmp = source_template.render({"name": adapter, "data": adapters[adapter]})
1069         else:
1070             tmp = eth_template.render(</b></font>{"name": adapter, "data": adapters[adapter]})
1071         ifcfg = ifcfg + tmp
1072         if adapter == iface:
1073             saved_ifcfg = tmp
1074     _SEPARATE_FILE = False
1075     if "filename" in settings:
1076         if not settings["filename"].startswith("/"):
1077             filename = "{}/{}".format(_DEB_NETWORK_DIR, settings["filename"])
1078         else:
1079             filename = settings["filename"]
1080         _SEPARATE_FILE = True
1081     else:
1082         if "filename" in adapters[adapter]["data"]:
1083             filename = adapters[adapter]["data"]
1084         else:
1085             filename = _DEB_NETWORK_FILE
1086     if not os.path.exists(os.path.dirname(filename)):
1087         msg = "{0} cannot be written."
1088         msg = msg.format(os.path.dirname(filename))
1089         log.error(msg)
1090         raise AttributeError(msg)
1091     with salt.utils.files.flopen(filename, "w") as fout:
1092         if _SEPARATE_FILE:
1093             fout.write(salt.utils.stringutils.to_str(saved_ifcfg))
1094         else:
1095             fout.write(salt.utils.stringutils.to_str(ifcfg))
1096     return saved_ifcfg.split("\n")
1097 def _write_file_ppp_ifaces(iface, data):
1098     try:
1099         template = JINJA.get_template("debian_ppp_eth.jinja")
1100     except jinja2.exceptions.TemplateNotFound:
1101         log.error("Could not load template debian_ppp_eth.jinja")
1102         return ""
1103     adapters = _parse_interfaces()
1104     adapters[iface] = data
1105     ifcfg = ""
1106     tmp = template.render({"data": adapters[iface]})
1107     ifcfg = tmp + ifcfg
1108     filename = _DEB_PPP_DIR + "/" + adapters[iface]["data"]["inet"]["provider"]
1109     if not os.path.exists(os.path.dirname(filename)):
1110         msg = "{0} cannot be written."
1111         msg = msg.format(os.path.dirname(filename))
1112         log.error(msg)
1113         raise AttributeError(msg)
1114     with salt.utils.files.fopen(filename, "w") as fout:
1115         fout.write(salt.utils.stringutils.to_str(ifcfg))
1116     return filename
1117 def build_bond(iface, **settings):
1118     deb_major = __grains__["osrelease"][:1]
1119     opts = _parse_settings_bond(settings, iface)
1120     try:
1121         template = JINJA.get_template("conf.jinja")
1122     except jinja2.exceptions.TemplateNotFound:
1123         log.error("Could not load template conf.jinja")
1124         return ""
1125     data = template.render({"name": iface, "bonding": opts})
1126     if "test" in settings and settings["test"]:
1127         return _read_temp(data)
1128     _write_file(iface, data, _DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1129     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1130     if deb_major == "5":
1131         for line_type in ("alias", "options"):
1132             cmd = [
1133                 "sed",
1134                 "-i",
1135                 "-e",
1136                 r"/^{}\s{}.*/d".format(line_type, iface),
1137                 "/etc/modprobe.conf",
1138             ]
1139             __salt__["cmd.run"](cmd, python_shell=False)
1140         __salt__["file.append"]("/etc/modprobe.conf", path)
1141     __salt__["kmod.load"]("bonding")
1142     __salt__["pkg.install"]("ifenslave")
1143     return _read_file(path)
1144 def build_interface(iface, iface_type, enabled, **settings):
1145     iface_type = iface_type.lower()
1146     if iface_type not in _IFACE_TYPES:
1147         _raise_error_iface(iface, iface_type, _IFACE_TYPES)
1148     if iface_type == "slave":
1149         settings["slave"] = "yes"
1150         if "master" not in settings:
1151             msg = "master is a required setting for slave interfaces"
1152             log.error(msg)
1153             raise AttributeError(msg)
1154     elif iface_type == "vlan":
1155         settings["vlan"] = "yes"
1156         __salt__["pkg.install"]("vlan")
1157     elif iface_type == "pppoe":
1158         settings["pppoe"] = "yes"
1159         if not __salt__["pkg.version"]("ppp"):
1160             inst = __salt__["pkg.install"]("ppp")
1161     elif iface_type == "bond":
1162         if "slaves" not in settings:
1163             msg = "slaves is a required setting for bond interfaces"
1164             log.error(msg)
1165             raise AttributeError(msg)
1166     elif iface_type == "bridge":
1167         if "ports" not in settings:
1168             msg = (
1169                 "ports is a required setting for bridge interfaces on Debian "
1170                 "or Ubuntu based systems"
1171             )
1172             log.error(msg)
1173             raise AttributeError(msg)
1174         __salt__["pkg.install"]("bridge-utils")
1175     if iface_type in ["eth", "bond", "bridge", "slave", "vlan", "pppoe"]:
1176         opts = _parse_settings_eth(settings, iface_type, enabled, iface)
1177     if iface_type in ["source"]:
1178         opts = _parse_settings_source(settings, iface_type, enabled, iface)
1179     if "test" in settings and settings["test"]:
1180         return _read_temp_ifaces(iface, opts[iface])
1181     ifcfg = _write_file_ifaces(iface, opts[iface], **settings)
1182     if iface_type == "pppoe":
1183         _write_file_ppp_ifaces(iface, opts[iface])
1184     return [item + "\n" for item in ifcfg]
1185 def build_routes(iface, **settings):
1186     opts = _parse_routes(iface, settings)
1187     try:
1188         template = JINJA.get_template("route_eth.jinja")
1189     except jinja2.exceptions.TemplateNotFound:
1190         log.error("Could not load template route_eth.jinja")
1191         return ""
1192     add_routecfg = template.render(route_type="add", routes=opts["routes"], iface=iface)
1193     del_routecfg = template.render(route_type="del", routes=opts["routes"], iface=iface)
1194     if "test" in settings and settings["test"]:
1195         return _read_temp(add_routecfg + del_routecfg)
1196     filename = _write_file_routes(iface, add_routecfg, _DEB_NETWORK_UP_DIR, "route-{0}")
1197     results = _read_file(filename)
1198     filename = _write_file_routes(
1199         iface, del_routecfg, _DEB_NETWORK_DOWN_DIR, "route-{0}"
1200     )
1201     results += _read_file(filename)
1202     return results
1203 def down(iface, iface_type):
1204     if iface_type not in ["slave", "source"]:
1205         return __salt__["cmd.run"](["ifdown", iface])
1206     return None
1207 def get_bond(iface):
1208     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1209     return _read_file(path)
1210 def get_interface(iface):
1211     adapters = _parse_interfaces()
1212     if iface in adapters:
1213         try:
1214             if iface == "source":
1215                 template = JINJA.get_template("debian_source.jinja")
1216             else:
1217                 template = JINJA.get_template("debian_eth.jinja")
1218         except jinja2.exceptions.TemplateNotFound:
1219             log.error("Could not load template debian_eth.jinja")
1220             return ""
1221         ifcfg = template.render({"name": iface, "data": adapters[iface]})
1222         return [item + "\n" for item in ifcfg.split("\n")]
1223     else:
1224         return []
1225 def up(iface, iface_type):  # pylint: disable=C0103
1226     if iface_type not in ("slave", "source"):
1227         return __salt__["cmd.run"](["ifup", iface])
1228     return None
1229 def get_network_settings():
1230     skip_etc_default_networking = (
1231         __grains__["osfullname"] == "Ubuntu"
1232         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1233     )
1234     if skip_etc_default_networking:
1235         settings = {}
1236         if __salt__["service.available"]("networking"):
1237             if __salt__["service.status"]("networking"):
1238                 settings["networking"] = "yes"
1239             else:
1240                 settings["networking"] = "no"
1241         else:
1242             settings["networking"] = "no"
1243         hostname = _parse_hostname()
1244         domainname = _parse_domainname()
1245         settings["hostname"] = hostname
1246         settings["domainname"] = domainname
1247     else:
1248         settings = _parse_current_network_settings()
1249     try:
1250         template = JINJA.get_template("display-network.jinja")
1251     except jinja2.exceptions.TemplateNotFound:
1252         log.error("Could not load template display-network.jinja")
1253         return ""
1254     network = template.render(settings)
1255     return _read_temp(network)
1256 def get_routes(iface):
1257     filename = os.path.join(_DEB_NETWORK_UP_DIR, "route-{}".format(iface))
1258     results = _read_file(filename)
1259     filename = os.path.join(_DEB_NETWORK_DOWN_DIR, "route-{}".format(iface))
1260     results += _read_file(filename)
1261     return results
1262 def apply_network_settings(**settings):
1263     if "require_reboot" not in settings:
1264         settings["require_reboot"] = False
1265     if "apply_hostname" not in settings:
1266         settings["apply_hostname"] = False
1267     hostname_res = True
1268     if settings["apply_hostname"] in _CONFIG_TRUE:
1269         if "hostname" in settings:
1270             hostname_res = __salt__["network.mod_hostname"](settings["hostname"])
1271         else:
1272             log.warning(
1273                 "The network state sls is trying to apply hostname "
1274                 "changes but no hostname is defined."
1275             )
1276             hostname_res = False
1277     res = True
1278     if settings["require_reboot"] in _CONFIG_TRUE:
1279         log.warning(
1280             "The network state sls is requiring a reboot of the system to "
1281             "properly apply network configuration."
1282         )
1283         res = True
1284     else:
1285         stop = __salt__["service.stop"]("networking")
1286         time.sleep(2)
1287         res = stop and __salt__["service.start"]("networking")
1288     return hostname_res and res
1289 def build_network_settings(**settings):
1290     changes = []
1291     current_network_settings = _parse_current_network_settings()
1292     opts = _parse_network_settings(settings, current_network_settings)
1293     skip_etc_default_networking = (
1294         __grains__["osfullname"] == "Ubuntu"
1295         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1296     )
1297     if skip_etc_default_networking:
1298         if opts["networking"] == "yes":
1299             service_cmd = "service.enable"
1300         else:
1301             service_cmd = "service.disable"
1302         if __salt__["service.available"]("NetworkManager"):
1303             __salt__[service_cmd]("NetworkManager")
1304         if __salt__["service.available"]("networking"):
1305             __salt__[service_cmd]("networking")
1306     else:
1307         try:
1308             template = JINJA.get_template("network.jinja")
1309         except jinja2.exceptions.TemplateNotFound:
1310             log.error("Could not load template network.jinja")
1311             return ""
1312         network = template.render(opts)
1313         if "test" in settings and settings["test"]:
1314             return _read_temp(network)
1315         _write_file_network(network, _DEB_NETWORKING_FILE, True)
1316     sline = opts["hostname"].split(".", 1)
1317     opts["hostname"] = sline[0]
1318     current_domainname = current_network_settings["domainname"]
1319     current_searchdomain = current_network_settings["searchdomain"]
1320     new_domain = False
1321     if len(sline) &gt; 1:
1322         new_domainname = sline[1]
1323         if new_domainname != current_domainname:
1324             domainname = new_domainname
1325             opts["domainname"] = new_domainname
1326             new_domain = True
1327         else:
1328             domainname = current_domainname
1329             opts["domainname"] = domainname
1330     else:
1331         domainname = current_domainname
1332         opts["domainname"] = domainname
1333     new_search = False
1334     if "search" in opts:
1335         new_searchdomain = opts["search"]
1336         if new_searchdomain != current_searchdomain:
1337             searchdomain = new_searchdomain
1338             opts["searchdomain"] = new_searchdomain
1339             new_search = True
1340         else:
1341             searchdomain = current_searchdomain
1342             opts["searchdomain"] = searchdomain
1343     else:
1344         searchdomain = current_searchdomain
1345         opts["searchdomain"] = searchdomain
1346     if new_domain or new_search:
1347         resolve = _parse_resolve()
1348         domain_prog = re.compile(r"domain\s+")
1349         search_prog = re.compile(r"search\s+")
1350         new_contents = []
1351         for item in _read_file(_DEB_RESOLV_FILE):
1352             if domain_prog.match(item):
1353                 item = "domain {}".format(domainname)
1354             elif search_prog.match(item):
1355                 item = "search {}".format(searchdomain)
1356             new_contents.append(item)
1357         if "domain" not in resolve:
1358             new_contents.insert(0, "domain {}".format(domainname))
1359         if "search" not in resolve:
1360             new_contents.insert("domain" in resolve, "search {}".format(searchdomain))
1361         new_resolv = "\n".join(new_contents)
1362         if not ("test" in settings and settings["test"]):
1363             _write_file_network(new_resolv, _DEB_RESOLV_FILE)
1364     try:
1365         template = JINJA.get_template("display-network.jinja")
1366     except jinja2.exceptions.TemplateNotFound:
1367         log.error("Could not load template display-network.jinja")
1368         return ""
1369     network = template.render(opts)
1370     changes.extend(_read_temp(network))
1371     return changes
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
