<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for query.py &amp; debian_ip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for query.py &amp; debian_ip.py
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>query.py (4.972376%)<th>debian_ip.py (1.384083%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(424-426)<td><a href="#" name="0">(1545-1548)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(128-129)<td><a href="#" name="1">(1243-1244)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(17-28)<td><a href="#" name="2">(14-25)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>query.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
2 import os
3 import time
4 import salt.utils.files
5 import salt.utils.fsutils
6 import salt.utils.network
7 from salt.modules.inspectlib import EnvLoader
8 from salt.modules.inspectlib.entities import Package, PackageCfgFile, PayloadFile
9 from salt.modules.inspectlib.exceptions import InspectorQueryException, SIException
10 log = logging.getLogger(</b></font>__name__)
11 class SysInfo:
12     def __init__(self, systype):
13         if systype.lower() == "solaris":
14             raise SIException("Platform {} not (yet) supported.".format(systype))
15     def _grain(self, grain):
16         return __grains__.get(grain, "N/A")
17     def _get_disk_size(self, device):
18         out = __salt__["cmd.run_all"]("df {}".format(device))
19         if out["retcode"]:
20             msg = "Disk size info error: {}".format(out["stderr"])
21             log.error(msg)
22             raise SIException(msg)
23         devpath, blocks, used, available, used_p, mountpoint = (
24             elm for elm in out["stdout"].split(os.linesep)[-1].split(" ") if elm
25         )
26         return {
27             "device": devpath,
28             "blocks": blocks,
29             "used": used,
30             "available": available,
31             "used (%)": used_p,
32             "mounted": mountpoint,
33         }
34     def _get_fs(self):
35         data = dict()
36         for dev, dev_data in salt.utils.fsutils._blkid().items():
37             dev = self._get_disk_size(dev)
38             device = dev.pop("device")
39             dev["type"] = dev_data["type"]
40             data[device] = dev
41         return data
42     def _get_mounts(self):
43         return salt.utils.fsutils._get_mounts()
44     def _get_cpu(self):
45         out = __salt__["cmd.run_all"]("lscpu")
46         salt.utils.fsutils._verify_run(out)
47         data = dict()
48         for descr, value in [
49             elm.split(":", 1) for elm in out["stdout"].split(os.linesep)
50         ]:
51             data[descr.strip()] = value.strip()
52         return data
53     def _get_mem(self):
54         out = __salt__["cmd.run_all"]("vmstat -s")
55         if out["retcode"]:
56             raise SIException("Memory info error: {}".format(out["stderr"]))
57         ret = dict()
58         for line in out["stdout"].split(os.linesep):
59             line = line.strip()
60             if not line:
61                 continue
62             size, descr = line.split(" ", 1)
63             if descr.startswith("K "):
64                 descr = descr[2:]
65                 size = size + "K"
66             ret[descr] = size
67         return ret
68     def _get_network(self):
69         data = dict()
70         data<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>["interfaces"] = salt.utils.network.interfaces()
71         data["subnets"] = salt.utils.network.subnets(</b></font>)
72         return data
73     def _get_os(self):
74         return {
75             "name": self._grain("os"),
76             "family": self._grain("os_family"),
77             "arch": self._grain("osarch"),
78             "release": self._grain("osrelease"),
79         }
80 class Query(EnvLoader):
81     SCOPES = [
82         "changes",
83         "configuration",
84         "identity",
85         "system",
86         "software",
87         "services",
88         "payload",
89         "all",
90     ]
91     def __init__(self, scope, cachedir=None):
92         if scope and scope not in self.SCOPES:
93             raise InspectorQueryException(
94                 "Unknown scope: {}. Must be one of: {}".format(
95                     repr(scope), ", ".join(self.SCOPES)
96                 )
97             )
98         elif not scope:
99             raise InspectorQueryException(
100                 "Scope cannot be empty. Must be one of: {}".format(
101                     ", ".join(self.SCOPES)
102                 )
103             )
104         EnvLoader.__init__(self, cachedir=cachedir)
105         self.scope = "_" + scope
106         self.local_identity = dict()
107     def __call__(self, *args, **kwargs):
108         return getattr(self, self.scope)(*args, **kwargs)
109     def _changes(self, *args, **kwargs):
110         raise Exception("Not yet implemented")
111     def _configuration(self, *args, **kwargs):
112         data = dict()
113         self.db.open()
114         for pkg in self.db.get(Package):
115             configs = list()
116             for pkg_cfg in self.db.get(PackageCfgFile, eq={"pkgid": pkg.id}):
117                 configs.append(pkg_cfg.path)
118             data[pkg.name] = configs
119         if not data:
120             raise InspectorQueryException("No inspected configuration yet available.")
121         return data
122     def _get_local_users(self, disabled=None):
123         users = dict()
124         path = "/etc/passwd"
125         with salt.utils.files.fopen(path, "r") as fp_:
126             for line in fp_:
127                 line = line.strip()
128                 if ":" not in line:
129                     continue
130                 name, password, uid, gid, gecos, directory, shell = line.split(":")
131                 active = not (password == "*" or password.startswith("!"))
132                 if (
133                     (disabled is False and active)
134                     or (disabled is True and not active)
135                     or disabled is None
136                 ):
137                     users[name] = {
138                         "uid": uid,
139                         "git": gid,
140                         "info": gecos,
141                         "home": directory,
142                         "shell": shell,
143                         "disabled": not active,
144                     }
145         return users
146     def _get_local_groups(self):
147         groups = dict()
148         path = "/etc/group"
149         with salt.utils.files.fopen(path, "r") as fp_:
150             for line in fp_:
151                 line = line.strip()
152                 if ":" not in line:
153                     continue
154                 name, password, gid, users = line.split(":")
155                 groups[name] = {
156                     "gid": gid,
157                 }
158                 if users:
159                     groups[name]["users"] = users.split(",")
160         return groups
161     def _get_external_accounts(self, locals):
162         users = dict()
163         out = __salt__["cmd.run_all"]("passwd -S -a")
164         if out["retcode"]:
165             return users
166         status = {
167             "L": "Locked",
168             "NP": "No password",
169             "P": "Usable password",
170             "LK": "Locked",
171         }
172         for data in [
173             elm.strip().split(" ")
174             for elm in out["stdout"].split(os.linesep)
175             if elm.strip()
176         ]:
177             if len(data) &lt; 2:
178                 continue
179             name, login = data[:2]
180             if name not in locals:
181                 users[name] = {"login": login, "status": status.get(login, "N/A")}
182         return users
183     def _identity(self, *args, **kwargs):
184         LOCAL = "local accounts"
185         EXT = "external accounts"
186         data = dict()
187         data[LOCAL] = self._get_local_users(disabled=kwargs.get("disabled"))
188         data[EXT] = self._get_external_accounts(data[LOCAL].keys()) or "N/A"
189         data["local groups"] = self._get_local_groups()
190         return data
191     def _system(self, *args, **kwargs):
192         sysinfo = SysInfo(__grains__.get("kernel"))
193         data = dict()
194         data["cpu"] = sysinfo._get_cpu()
195         data["disks"] = sysinfo._get_fs()
196         data["mounts"] = sysinfo._get_mounts()
197         data["memory"] = sysinfo._get_mem()
198         data["network"] = sysinfo._get_network()
199         data["os"] = sysinfo._get_os()
200         return data
201     def _software(self, *args, **kwargs):
202         data = dict()
203         if "exclude" in kwargs:
204             excludes = kwargs["exclude"].split(",")
205         else:
206             excludes = list()
207         os_family = __grains__.get("os_family").lower()
208         if os_family == "suse":
209             LOCKS = "pkg.list_locks"
210             if "products" not in excludes:
211                 products = __salt__["pkg.list_products"]()
212                 if products:
213                     data["products"] = products
214         elif os_family == "redhat":
215             LOCKS = "pkg.get_locked_packages"
216         else:
217             LOCKS = None
218         if LOCKS and "locks" not in excludes:
219             locks = __salt__[LOCKS]()
220             if locks:
221                 data["locks"] = locks
222         if os_family == "suse":
223             PATTERNS = "pkg.list_installed_patterns"
224         elif os_family == "redhat":
225             PATTERNS = "pkg.group_list"
226         else:
227             PATTERNS = None
228         if PATTERNS and "patterns" not in excludes:
229             patterns = __salt__[PATTERNS]()
230             if patterns:
231                 data["patterns"] = patterns
232         if "packages" not in excludes:
233             data["packages"] = __salt__["pkg.list_pkgs"]()
234         if "repositories" not in excludes:
235             repos = __salt__["pkg.list_repos"]()
236             if repos:
237                 data["repositories"] = repos
238         return data
239     def _services(self, *args, **kwargs):
240         return {
241             "enabled": __salt__["service.get_enabled"](),
242             "disabled": __salt__["service.get_disabled"](),
243         }
244     def _id_resolv(self, iid, named=True, uid=True):
245         <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>if not self.local_identity:
246             self.local_identity["users"] = self._get_local_users()
247             self.local_identity["groups"] = self._get_local_groups(</b></font>)
248         if not named:
249             return iid
250         for name, meta in self.local_identity[uid and "users" or "groups"].items():
251             if (uid and int(meta.get("uid", -1)) == iid) or (
252                 not uid and int(meta.get("gid", -1)) == iid
253             ):
254                 return name
255         return iid
256     def _payload(self, *args, **kwargs):
257         def _size_format(size, fmt):
258             if fmt is None:
259                 return size
260             fmt = fmt.lower()
261             if fmt == "b":
262                 return "{} Bytes".format(size)
263             elif fmt == "kb":
264                 return "{} Kb".format(round((float(size) / 0x400), 2))
265             elif fmt == "mb":
266                 return "{} Mb".format(round((float(size) / 0x400 / 0x400), 2))
267             elif fmt == "gb":
268                 return "{} Gb".format(round((float(size) / 0x400 / 0x400 / 0x400), 2))
269         filter = kwargs.get("filter")
270         offset = kwargs.get("offset", 0)
271         timeformat = kwargs.get("time", "tz")
272         if timeformat not in ["ticks", "tz"]:
273             raise InspectorQueryException(
274                 'Unknown "{}" value for parameter "time"'.format(timeformat)
275             )
276         tfmt = (
277             lambda param: timeformat == "tz"
278             and time.strftime("%b %d %Y %H:%M:%S", time.gmtime(param))
279             or int(param)
280         )
281         size_fmt = kwargs.get("size")
282         if size_fmt is not None and size_fmt.lower() not in ["b", "kb", "mb", "gb"]:
283             raise InspectorQueryException(
284                 'Unknown "{}" value for parameter "size". '
285                 "Should be either B, Kb, Mb or Gb".format(timeformat)
286             )
287         owners = kwargs.get("owners", "id")
288         if owners not in ["name", "id"]:
289             raise InspectorQueryException(
290                 'Unknown "{}" value for parameter "owners". '
291                 "Should be either name or id (default)".format(owners)
292             )
293         incl_type = [prm for prm in kwargs.get("type", "").lower().split(",") if prm]
294         if not incl_type:
295             incl_type.append("file")
296         for i_type in incl_type:
297             if i_type not in ["directory", "dir", "d", "file", "f", "link", "l"]:
298                 raise InspectorQueryException(
299                     'Unknown "{}" values for parameter "type". '
300                     "Should be comma separated one or more of "
301                     "dir, file and/or link.".format(", ".join(incl_type))
302                 )
303         self.db.open()
304         if "total" in args:
305             return {"total": len(self.db.get(PayloadFile))}
306         brief = kwargs.get("brief")
307         pld_files = list() if brief else dict()
308         for pld_data in self.db.get(PayloadFile)[
309             offset : offset + kwargs.get("max", 1000)
310         ]:
311             if brief:
312                 pld_files.append(pld_data.path)
313             else:
314                 pld_files[pld_data.path] = {
315                     "uid": self._id_resolv(pld_data.uid, named=(owners == "id")),
316                     "gid": self._id_resolv(
317                         pld_data.gid, named=(owners == "id"), uid=False
318                     ),
319                     "size": _size_format(pld_data.p_size, fmt=size_fmt),
320                     "mode": oct(pld_data.mode),
321                     "accessed": tfmt(pld_data.atime),
322                     "modified": tfmt(pld_data.mtime),
323                     "created": tfmt(pld_data.ctime),
324                 }
325         return pld_files
326     def _all(self, *args, **kwargs):
327         data = dict()
328         data["software"] = self._software(**kwargs)
329         data["system"] = self._system(**kwargs)
330         data["services"] = self._services(**kwargs)
331         try:
332             data["configuration"] = self._configuration(**kwargs)
333         except InspectorQueryException as ex:
334             data["configuration"] = "N/A"
335             log.error(ex)
336         data["payload"] = self._payload(**kwargs) or "N/A"
337         return data
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>debian_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import functools
2 import io
3 import logging
4 import os.path
5 import re
6 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import time
7 import jinja2
8 import jinja2.exceptions
9 import salt.utils.dns
10 import salt.utils.files
11 import salt.utils.odict
12 import salt.utils.stringutils
13 import salt.utils.templates
14 import salt.utils.validate.net
15 log = logging.getLogger(</b></font>__name__)
16 JINJA = jinja2.Environment(
17     loader=jinja2.FileSystemLoader(
18         os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, "debian_ip")
19     )
20 )
21 __virtualname__ = "ip"
22 def __virtual__():
23     if __grains__["os_family"] == "Debian":
24         return __virtualname__
25     return (False, "The debian_ip module could not be loaded: unsupported OS family")
26 _ETHTOOL_CONFIG_OPTS = {
27     "speed": "link-speed",
28     "duplex": "link-duplex",
29     "autoneg": "ethernet-autoneg",
30     "ethernet-port": "ethernet-port",
31     "wol": "ethernet-wol",
32     "driver-message-level": "driver-message-level",
33     "ethernet-pause-rx": "ethernet-pause-rx",
34     "ethernet-pause-tx": "ethernet-pause-tx",
35     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
36     "rx": "offload-rx",
37     "tx": "offload-tx",
38     "sg": "offload-sg",
39     "tso": "offload-tso",
40     "ufo": "offload-ufo",
41     "gso": "offload-gso",
42     "gro": "offload-gro",
43     "lro": "offload-lro",
44     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
45     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
46     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
47     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
48     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
49     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
50     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
51     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
52 }
53 _REV_ETHTOOL_CONFIG_OPTS = {
54     "link-speed": "speed",
55     "link-duplex": "duplex",
56     "ethernet-autoneg": "autoneg",
57     "ethernet-port": "ethernet-port",
58     "ethernet-wol": "wol",
59     "driver-message-level": "driver-message-level",
60     "ethernet-pause-rx": "ethernet-pause-rx",
61     "ethernet-pause-tx": "ethernet-pause-tx",
62     "ethernet-pause-autoneg": "ethernet-pause-autoneg",
63     "offload-rx": "rx",
64     "offload-tx": "tx",
65     "offload-sg": "sg",
66     "offload-tso": "tso",
67     "offload-ufo": "ufo",
68     "offload-gso": "gso",
69     "offload-lro": "lro",
70     "offload-gro": "gro",
71     "hardware-irq-coalesce-adaptive-rx": "hardware-irq-coalesce-adaptive-rx",
72     "hardware-irq-coalesce-adaptive-tx": "hardware-irq-coalesce-adaptive-tx",
73     "hardware-irq-coalesce-rx-usecs": "hardware-irq-coalesce-rx-usecs",
74     "hardware-irq-coalesce-rx-frames": "hardware-irq-coalesce-rx-frames",
75     "hardware-dma-ring-rx": "hardware-dma-ring-rx",
76     "hardware-dma-ring-rx-mini": "hardware-dma-ring-rx-mini",
77     "hardware-dma-ring-rx-jumbo": "hardware-dma-ring-rx-jumbo",
78     "hardware-dma-ring-tx": "hardware-dma-ring-tx",
79 }
80 _DEB_CONFIG_PPPOE_OPTS = {
81     "user": "user",
82     "password": "password",
83     "provider": "provider",
84     "pppoe_iface": "pppoe_iface",
85     "noipdefault": "noipdefault",
86     "usepeerdns": "usepeerdns",
87     "defaultroute": "defaultroute",
88     "holdoff": "holdoff",
89     "maxfail": "maxfail",
90     "hide-password": "hide-password",
91     "lcp-echo-interval": "lcp-echo-interval",
92     "lcp-echo-failure": "lcp-echo-failure",
93     "connect": "connect",
94     "noauth": "noauth",
95     "persist": "persist",
96     "mtu": "mtu",
97     "noaccomp": "noaccomp",
98     "linkname": "linkname",
99 }
100 _DEB_ROUTES_FILE = "/etc/network/routes"
101 _DEB_NETWORK_FILE = "/etc/network/interfaces"
102 _DEB_NETWORK_DIR = "/etc/network/interfaces.d/"
103 _DEB_NETWORK_UP_DIR = "/etc/network/if-up.d/"
104 _DEB_NETWORK_DOWN_DIR = "/etc/network/if-down.d/"
105 _DEB_NETWORK_CONF_FILES = "/etc/modprobe.d/"
106 _DEB_NETWORKING_FILE = "/etc/default/networking"
107 _DEB_HOSTNAME_FILE = "/etc/hostname"
108 _DEB_RESOLV_FILE = "/etc/resolv.conf"
109 _DEB_PPP_DIR = "/etc/ppp/peers/"
110 _CONFIG_TRUE = ["yes", "on", "true", "1", True]
111 _CONFIG_FALSE = ["no", "off", "false", "0", False]
112 _IFACE_TYPES = [
113     "eth",
114     "bond",
115     "alias",
116     "clone",
117     "ipsec",
118     "dialup",
119     "bridge",
120     "slave",
121     "vlan",
122     "pppoe",
123     "source",
124 ]
125 def _error_msg_iface(iface, option, expected):
126     msg = "Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]"
127     return msg.format(iface, option, "|".join(str(e) for e in expected))
128 def _error_msg_routes(iface, option, expected):
129     msg = "Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]"
130     return msg.format(iface, option, expected)
131 def _log_default_iface(iface, opt, value):
132     log.info(
133         "Using default option -- Interface: %s Option: %s Value: %s", iface, opt, value
134     )
135 def _error_msg_network(option, expected):
136     msg = "Invalid network setting -- Setting: {0}, Expected: [{1}]"
137     return msg.format(option, "|".join(str(e) for e in expected))
138 def _log_default_network(opt, value):
139     log.info("Using existing setting -- Setting: %s Value: %s", opt, value)
140 def _raise_error_iface(iface, option, expected):
141     msg = _error_msg_iface(iface, option, expected)
142     log.error(msg)
143     raise AttributeError(msg)
144 def _raise_error_network(option, expected):
145     msg = _error_msg_network(option, expected)
146     log.error(msg)
147     raise AttributeError(msg)
148 def _raise_error_routes(iface, option, expected):
149     msg = _error_msg_routes(iface, option, expected)
150     log.error(msg)
151     raise AttributeError(msg)
152 def _read_file(path):
153     try:
154         with salt.utils.files.flopen(path, "rb") as contents:
155             return [
156                 salt.utils.stringutils.to_str(line) for line in contents.readlines()
157             ]
158     except OSError:
159         return ""
160 def _parse_resolve():
161     return salt.utils.dns.parse_resolv(_DEB_RESOLV_FILE)
162 def _parse_domainname():
163     return _parse_resolve().get("domain", "")
164 def _parse_searchdomain():
165     return _parse_resolve().get("search", "")
166 def _parse_hostname():
167     contents = _read_file(_DEB_HOSTNAME_FILE)
168     if contents:
169         return contents[0].split("\n")[0]
170     else:
171         return ""
172 def _parse_current_network_settings():
173     opts = salt.utils.odict.OrderedDict()
174     opts["networking"] = ""
175     if os.path.isfile(_DEB_NETWORKING_FILE):
176         with salt.utils.files.fopen(_DEB_NETWORKING_FILE) as contents:
177             for line in contents:
178                 salt.utils.stringutils.to_unicode(line)
179                 if line.startswith("#"):
180                     continue
181                 elif line.startswith("CONFIGURE_INTERFACES"):
182                     opts["networking"] = line.split("=", 1)[1].strip()
183     hostname = _parse_hostname()
184     domainname = _parse_domainname()
185     searchdomain = _parse_searchdomain()
186     opts["hostname"] = hostname
187     opts["domainname"] = domainname
188     opts["searchdomain"] = searchdomain
189     return opts
190 def __ipv4_quad(value):
191     return (salt.utils.validate.net.ipv4_addr(value), value, "dotted IPv4 address")
192 def __ipv6(value):
193     return (salt.utils.validate.net.ipv6_addr(value), value, "IPv6 address")
194 def __mac(value):
195     return (salt.utils.validate.net.mac(value), value, "MAC address")
196 def __anything(value):
197     return (True, value, None)
198 def __int(value):
199     valid, _value = False, value
200     try:
201         _value = int(value)
202         valid = True
203     except ValueError:
204         pass
205     return (valid, _value, "integer")
206 def __float(value):
207     valid, _value = False, value
208     try:
209         _value = float(value)
210         valid = True
211     except ValueError:
212         pass
213     return (valid, _value, "float")
214 def __ipv4_netmask(value):
215     valid, errmsg = False, "dotted quad or integer CIDR (0-&gt;32)"
216     valid, value, _ = __int(value)
217     if not (valid and 0 &lt;= value &lt;= 32):
218         valid = salt.utils.validate.net.netmask(value)
219     return (valid, value, errmsg)
220 def __ipv6_netmask(value):
221     valid, errmsg = False, "IPv6 netmask (0-&gt;128)"
222     valid, value, _ = __int(value)
223     valid = valid and 0 &lt;= value &lt;= 128
224     return (valid, value, errmsg)
225 def __within2(value, within=None, errmsg=None, dtype=None):
226     valid, _value = False, value
227     if dtype:
228         try:
229             _value = dtype(value)  # TODO: this is a bit loose when dtype is a class
230             valid = _value in within
231         except ValueError:
232             pass
233     else:
234         valid = _value in within
235     if errmsg is None:
236         if dtype:
237             typename = getattr(
238                 dtype,
239                 "__name__",
240                 hasattr(dtype, "__class__") and getattr(dtype.__class__, "name", dtype),
241             )
242             errmsg = "{} within '{}'".format(typename, within)
243         else:
244             errmsg = "within '{}'".format(within)
245     return (valid, _value, errmsg)
246 def __within(within=None, errmsg=None, dtype=None):
247     return functools.partial(__within2, within=within, errmsg=errmsg, dtype=dtype)
248 def __space_delimited_list(value):
249     if isinstance(value, str):
250         value = value.strip().split()
251     if hasattr(value, "__iter__") and value != []:
252         return (True, value, "space-delimited string")
253     else:
254         return (
255             False,
256             value,
257             "{} is not a valid space-delimited value.\n".format(value),
258         )
259 SALT_ATTR_TO_DEBIAN_ATTR_MAP = {
260     "dns": "dns-nameservers",
261     "search": "dns-search",
262     "hwaddr": "hwaddress",  # TODO: this limits bootp functionality
263     "ipaddr": "address",
264     "ipaddrs": "addresses",
265 }
266 DEBIAN_ATTR_TO_SALT_ATTR_MAP = {v: k for (k, v) in SALT_ATTR_TO_DEBIAN_ATTR_MAP.items()}
267 DEBIAN_ATTR_TO_SALT_ATTR_MAP["address"] = "address"
268 DEBIAN_ATTR_TO_SALT_ATTR_MAP["hwaddress"] = "hwaddress"
269 IPV4_VALID_PROTO = ["bootp", "dhcp", "static", "manual", "loopback", "ppp"]
270 IPV4_ATTR_MAP = {
271     "proto": __within(IPV4_VALID_PROTO, dtype=str),
272     "address": __ipv4_quad,
273     "addresses": __anything,
274     "netmask": __ipv4_netmask,
275     "broadcast": __ipv4_quad,
276     "metric": __int,
277     "gateway": __ipv4_quad,  # supports a colon-delimited list
278     "pointopoint": __ipv4_quad,
279     "hwaddress": __mac,
280     "mtu": __int,
281     "scope": __within(["global", "link", "host"], dtype=str),
282     "hostname": __anything,
283     "leasehours": __int,
284     "leasetime": __int,
285     "vendor": __anything,
286     "client": __anything,
287     "bootfile": __anything,
288     "server": __ipv4_quad,
289     "hwaddr": __mac,
290     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
291     "endpoint": __ipv4_quad,
292     "dstaddr": __ipv4_quad,
293     "local": __ipv4_quad,
294     "ttl": __int,
295     "slaves": __anything,
296     "provider": __anything,
297     "unit": __int,
298     "options": __anything,
299     "dns-nameservers": __space_delimited_list,
300     "dns-search": __space_delimited_list,
301     "vlan-raw-device": __anything,
302     "network": __anything,  # i don't know what this is
303     "test": __anything,  # TODO
304     "enable_ipv4": __anything,  # TODO
305     "enable_ipv6": __anything,  # TODO
306 }
307 IPV6_VALID_PROTO = ["auto", "loopback", "static", "manual", "dhcp", "v4tunnel", "6to4"]
308 IPV6_ATTR_MAP = {
309     "proto": __within(IPV6_VALID_PROTO),
310     "address": __ipv6,
311     "addresses": __anything,
312     "netmask": __ipv6_netmask,
313     "broadcast": __ipv6,
314     "gateway": __ipv6,  # supports a colon-delimited list
315     "hwaddress": __mac,
316     "mtu": __int,
317     "scope": __within(["global", "site", "link", "host"], dtype=str),
318     "privext": __within([0, 1, 2], dtype=int),
319     "dhcp": __within([0, 1], dtype=int),
320     "media": __anything,
321     "accept_ra": __within([0, 1, 2], dtype=int),
322     "autoconf": __within([0, 1], dtype=int),
323     "preferred-lifetime": __int,
324     "dad-attempts": __int,  # 0 to disable
325     "dad-interval": __float,
326     "slaves": __anything,
327     "mode": __within(["gre", "GRE", "ipip", "IPIP", "802.3ad"], dtype=str),
328     "endpoint": __ipv4_quad,
329     "local": __ipv4_quad,
330     "ttl": __int,
331     "dns-nameservers": __space_delimited_list,
332     "dns-search": __space_delimited_list,
333     "vlan-raw-device": __anything,
334     "test": __anything,  # TODO
335     "enable_ipv4": __anything,  # TODO
336     "enable_ipv6": __anything,  # TODO
337 }
338 WIRELESS_ATTR_MAP = {
339     "wireless-essid": __anything,
340     "wireless-mode": __anything,  # TODO
341     "wpa-ap-scan": __within([0, 1, 2], dtype=int),  # TODO
342     "wpa-conf": __anything,
343     "wpa-driver": __anything,
344     "wpa-group": __anything,
345     "wpa-key-mgmt": __anything,
346     "wpa-pairwise": __anything,
347     "wpa-psk": __anything,
348     "wpa-proto": __anything,  # partial(__within,
349     "wpa-roam": __anything,
350     "wpa-ssid": __anything,  # TODO
351 }
352 ATTRMAPS = {
353     "inet": [IPV4_ATTR_MAP, WIRELESS_ATTR_MAP],
354     "inet6": [IPV6_ATTR_MAP, WIRELESS_ATTR_MAP],
355 }
356 def _validate_interface_option(attr, value, addrfam="inet"):
357     valid, _value, errmsg = False, value, "Unknown validator"
358     attrmaps = ATTRMAPS.get(addrfam, [])
359     for attrmap in attrmaps:
360         if attr in attrmap:
361             validate_func = attrmap[attr]
362             (valid, _value, errmsg) = validate_func(value)
363             break
364     return (valid, _value, errmsg)
365 def _attrmaps_contain_attr(attr):
366     return attr in WIRELESS_ATTR_MAP or attr in IPV4_ATTR_MAP or attr in IPV6_ATTR_MAP
367 def _parse_interfaces(interface_files=None):
368     if interface_files is None:
369         interface_files = []
370         if os.path.exists(_DEB_NETWORK_DIR):
371             interface_files += [
372                 "{}/{}".format(_DEB_NETWORK_DIR, dir)
373                 for dir in os.listdir(_DEB_NETWORK_DIR)
374             ]
375         if os.path.isfile(_DEB_NETWORK_FILE):
376             interface_files.insert(0, _DEB_NETWORK_FILE)
377     adapters = salt.utils.odict.OrderedDict()
378     method = -1
379     for interface_file in interface_files:
380         with salt.utils.files.fopen(interface_file) as interfaces:
381             iface_dict = {}
382             for line in interfaces:
383                 line = salt.utils.stringutils.to_unicode(line)
384                 if line.lstrip().startswith("#") or line.isspace():
385                     continue
386                 if line.startswith("iface"):
387                     sline = line.split()
388                     if len(sline) != 4:
389                         msg = "Interface file malformed: {0}."
390                         msg = msg.format(sline)
391                         log.error(msg)
392                         raise AttributeError(msg)
393                     iface_name = sline[1]
394                     addrfam = sline[2]
395                     method = sline[3]
396                     if iface_name not in adapters:
397                         adapters[iface_name] = salt.utils.odict.OrderedDict()
398                     if "data" not in adapters[iface_name]:
399                         adapters[iface_name]["data"] = salt.utils.odict.OrderedDict()
400                     if addrfam not in adapters[iface_name]["data"]:
401                         adapters[iface_name]["data"][
402                             addrfam
403                         ] = salt.utils.odict.OrderedDict()
404                     iface_dict = adapters[iface_name]["data"][addrfam]
405                     iface_dict["addrfam"] = addrfam
406                     iface_dict["proto"] = method
407                     iface_dict["filename"] = interface_file
408                 elif line[0].isspace():
409                     sline = line.split()
410                     attr, valuestr = line.rstrip().split(None, 1)
411                     if _attrmaps_contain_attr(attr):
412                         if "-" in attr:
413                             attrname = attr.replace("-", "_")
414                         else:
415                             attrname = attr
416                         (valid, value, errmsg) = _validate_interface_option(
417                             attr, valuestr, addrfam
418                         )
419                         if attrname == "address" and "address" in iface_dict:
420                             if "addresses" not in iface_dict:
421                                 iface_dict["addresses"] = []
422                             iface_dict["addresses"].append(value)
423                         else:
424                             iface_dict[attrname] = value
425                     elif attr in _REV_ETHTOOL_CONFIG_OPTS:
426                         if "ethtool" not in iface_dict:
427                             iface_dict["ethtool"] = salt.utils.odict.OrderedDict()
428                         iface_dict["ethtool"][attr] = valuestr
429                     elif attr.startswith("bond"):
430                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
431                         if "bonding" not in iface_dict:
432                             iface_dict["bonding"] = salt.utils.odict.OrderedDict()
433                         iface_dict["bonding"][opt] = valuestr
434                     elif attr.startswith("bridge"):
435                         opt = re.split(r"[_-]", attr, maxsplit=1)[1]
436                         if "bridging" not in iface_dict:
437                             iface_dict["bridging"] = salt.utils.odict.OrderedDict()
438                         iface_dict["bridging"][opt] = valuestr
439                     elif attr in [
440                         "up",
441                         "pre-up",
442                         "post-up",
443                         "down",
444                         "pre-down",
445                         "post-down",
446                     ]:
447                         cmd = valuestr
448                         cmd_key = "{}_cmds".format(re.sub("-", "_", attr))
449                         if cmd_key not in iface_dict:
450                             iface_dict[cmd_key] = []
451                         iface_dict[cmd_key].append(cmd)
452                 elif line.startswith("auto"):
453                     for word in line.split()[1:]:
454                         if word not in adapters:
455                             adapters[word] = salt.utils.odict.OrderedDict()
456                         adapters[word]["enabled"] = True
457                 elif line.startswith("allow-hotplug"):
458                     for word in line.split()[1:]:
459                         if word not in adapters:
460                             adapters[word] = salt.utils.odict.OrderedDict()
461                         adapters[word]["hotplug"] = True
462                 elif line.startswith("source"):
463                     if "source" not in adapters:
464                         adapters["source"] = salt.utils.odict.OrderedDict()
465                     if "data" not in adapters["source"]:
466                         adapters["source"]["data"] = salt.utils.odict.OrderedDict()
467                         adapters["source"]["data"]["sources"] = []
468                     adapters["source"]["data"]["sources"].append(line.split()[1])
469     adapters = _filter_malformed_interfaces(adapters=adapters)
470     return adapters
471 def _filter_malformed_interfaces(*, adapters):
472     for iface_name in list(adapters):
473         if iface_name == "source":
474             continue
475         if "data" not in adapters[iface_name]:
476             msg = "Interface file malformed for interface: {}.".format(iface_name)
477             log.error(msg)
478             adapters.pop(iface_name)
479             continue
480         for opt in ["ethtool", "bonding", "bridging"]:
481             for inet in ["inet", "inet6"]:
482                 if inet in adapters[iface_name]["data"]:
483                     if opt in adapters[iface_name]["data"][inet]:
484                         opt_keys = sorted(
485                             adapters[iface_name]["data"][inet][opt].keys()
486                         )
487                         adapters[iface_name]["data"][inet][opt + "_keys"] = opt_keys
488     return adapters
489 def _parse_ethtool_opts(opts, iface):
490     config = {}
491     if "autoneg" in opts:
492         if opts["autoneg"] in _CONFIG_TRUE:
493             config.update({"autoneg": "on"})
494         elif opts["autoneg"] in _CONFIG_FALSE:
495             config.update({"autoneg": "off"})
496         else:
497             _raise_error_iface(iface, "autoneg", _CONFIG_TRUE + _CONFIG_FALSE)
498     if "duplex" in opts:
499         valid = ["full", "half"]
500         if opts["duplex"] in valid:
501             config.update({"duplex": opts["duplex"]})
502         else:
503             _raise_error_iface(iface, "duplex", valid)
504     if "speed" in opts:
505         valid = ["10", "100", "1000", "10000"]
506         if str(opts["speed"]) in valid:
507             config.update({"speed": opts["speed"]})
508         else:
509             _raise_error_iface(iface, opts["speed"], valid)
510     valid = _CONFIG_TRUE + _CONFIG_FALSE
511     for option in ("rx", "tx", "sg", "tso", "ufo", "gso", "gro", "lro"):
512         if option in opts:
513             if opts[option] in _CONFIG_TRUE:
514                 config.update({option: "on"})
515             elif opts[option] in _CONFIG_FALSE:
516                 config.update({option: "off"})
517             else:
518                 _raise_error_iface(iface, option, valid)
519     return config
520 def _parse_ethtool_pppoe_opts(opts, iface):
521     config = {}
522     for opt in _DEB_CONFIG_PPPOE_OPTS:
523         if opt in opts:
524             config[opt] = opts[opt]
525     if "provider" in opts and not opts["provider"]:
526         _raise_error_iface(iface, "provider", _CONFIG_TRUE + _CONFIG_FALSE)
527     valid = _CONFIG_TRUE + _CONFIG_FALSE
528     for option in (
529         "noipdefault",
530         "usepeerdns",
531         "defaultroute",
532         "hide-password",
533         "noauth",
534         "persist",
535         "noaccomp",
536     ):
537         if option in opts:
538             if opts[option] in _CONFIG_TRUE:
539                 config.update({option: "True"})
540             elif opts[option] in _CONFIG_FALSE:
541                 config.update({option: "False"})
542             else:
543                 _raise_error_iface(iface, option, valid)
544     return config
545 def _parse_settings_bond(opts, iface):
546     bond_def = {
547         "ad_select": "0",
548         "tx_queues": "16",
549         "miimon": "100",
550         "arp_interval": "250",
551         "downdelay": "200",
552         "lacp_rate": "0",
553         "max_bonds": "1",
554         "updelay": "0",
555         "use_carrier": "on",
556         "xmit_hash_policy": "layer2",
557     }
558     if opts["mode"] in ["balance-rr", "0"]:
559         log.info("Device: %s Bonding Mode: load balancing (round-robin)", iface)
560         return _parse_settings_bond_0(opts, iface, bond_def)
561     elif opts["mode"] in ["active-backup", "1"]:
562         log.info("Device: %s Bonding Mode: fault-tolerance (active-backup)", iface)
563         return _parse_settings_bond_1(opts, iface, bond_def)
564     elif opts["mode"] in ["balance-xor", "2"]:
565         log.info("Device: %s Bonding Mode: load balancing (xor)", iface)
566         return _parse_settings_bond_2(opts, iface, bond_def)
567     elif opts["mode"] in ["broadcast", "3"]:
568         log.info("Device: %s Bonding Mode: fault-tolerance (broadcast)", iface)
569         return _parse_settings_bond_3(opts, iface, bond_def)
570     elif opts["mode"] in ["802.3ad", "4"]:
571         log.info(
572             "Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation", iface
573         )
574         return _parse_settings_bond_4(opts, iface, bond_def)
575     elif opts["mode"] in ["balance-tlb", "5"]:
576         log.info("Device: %s Bonding Mode: transmit load balancing", iface)
577         return _parse_settings_bond_5(opts, iface, bond_def)
578     elif opts["mode"] in ["balance-alb", "6"]:
579         log.info("Device: %s Bonding Mode: adaptive load balancing", iface)
580         return _parse_settings_bond_6(opts, iface, bond_def)
581     else:
582         valid = [
583             "0",
584             "1",
585             "2",
586             "3",
587             "4",
588             "5",
589             "6",
590             "balance-rr",
591             "active-backup",
592             "balance-xor",
593             "broadcast",
594             "802.3ad",
595             "balance-tlb",
596             "balance-alb",
597         ]
598         _raise_error_iface(iface, "mode", valid)
599 def _parse_settings_bond_0(opts, iface, bond_def):
600     bond = {"mode": "0"}
601     valid = ["list of ips (up to 16)"]
602     if "arp_ip_target" in opts:
603         if isinstance(opts["arp_ip_target"], list):
604             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
605                 bond.update({"arp_ip_target": ""})
606                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
607                     if len(bond["arp_ip_target"]) &gt; 0:
608                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
609                     else:
610                         bond["arp_ip_target"] = ip
611             else:
612                 _raise_error_iface(iface, "arp_ip_target", valid)
613         else:
614             _raise_error_iface(iface, "arp_ip_target", valid)
615     else:
616         _raise_error_iface(iface, "arp_ip_target", valid)
617     if "arp_interval" in opts:
618         try:
619             int(opts["arp_interval"])
620             bond.update({"arp_interval": opts["arp_interval"]})
621         except ValueError:
622             _raise_error_iface(iface, "arp_interval", ["integer"])
623     else:
624         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
625         bond.update({"arp_interval": bond_def["arp_interval"]})
626     return bond
627 def _parse_settings_bond_1(opts, iface, bond_def):
628     bond = {"mode": "1"}
629     for binding in ["miimon", "downdelay", "updelay"]:
630         if binding in opts:
631             try:
632                 int(opts[binding])
633                 bond.update({binding: opts[binding]})
634             except ValueError:
635                 _raise_error_iface(iface, binding, ["integer"])
636         else:
637             _log_default_iface(iface, binding, bond_def[binding])
638             bond.update({binding: bond_def[binding]})
639     if "primary" in opts:
640         bond.update({"primary": opts["primary"]})
641     if not (__grains__["os"] == "Ubuntu" and __grains__["osrelease_info"][0] &gt;= 16):
642         if "use_carrier" in opts:
643             if opts["use_carrier"] in _CONFIG_TRUE:
644                 bond.update({"use_carrier": "1"})
645             elif opts["use_carrier"] in _CONFIG_FALSE:
646                 bond.update({"use_carrier": "0"})
647             else:
648                 valid = _CONFIG_TRUE + _CONFIG_FALSE
649                 _raise_error_iface(iface, "use_carrier", valid)
650         else:
651             _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
652             bond.update({"use_carrier": bond_def["use_carrier"]})
653     return bond
654 def _parse_settings_bond_2(opts, iface, bond_def):
655     bond = {"mode": "2"}
656     valid = ["list of ips (up to 16)"]
657     if "arp_ip_target" in opts:
658         if isinstance(opts["arp_ip_target"], list):
659             if 1 &lt;= len(opts["arp_ip_target"]) &lt;= 16:
660                 bond.update({"arp_ip_target": ""})
661                 for ip in opts["arp_ip_target"]:  # pylint: disable=C0103
662                     if len(bond["arp_ip_target"]) &gt; 0:
663                         bond["arp_ip_target"] = bond["arp_ip_target"] + "," + ip
664                     else:
665                         bond["arp_ip_target"] = ip
666             else:
667                 _raise_error_iface(iface, "arp_ip_target", valid)
668         else:
669             _raise_error_iface(iface, "arp_ip_target", valid)
670     else:
671         _raise_error_iface(iface, "arp_ip_target", valid)
672     if "arp_interval" in opts:
673         try:
674             int(opts["arp_interval"])
675             bond.update({"arp_interval": opts["arp_interval"]})
676         except ValueError:
677             _raise_error_iface(iface, "arp_interval", ["integer"])
678     else:
679         _log_default_iface(iface, "arp_interval", bond_def["arp_interval"])
680         bond.update({"arp_interval": bond_def["arp_interval"]})
681     if "hashing-algorithm" in opts:
682         valid = ["layer2", "layer2+3", "layer3+4"]
683         if opts["hashing-algorithm"] in valid:
684             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
685         else:
686             _raise_error_iface(iface, "hashing-algorithm", valid)
687     return bond
688 def _parse_settings_bond_3(opts, iface, bond_def):
689     bond = {"mode": "3"}
690     for binding in ["miimon", "downdelay", "updelay"]:
691         if binding in opts:
692             try:
693                 int(opts[binding])
694                 bond.update({binding: opts[binding]})
695             except ValueError:
696                 _raise_error_iface(iface, binding, ["integer"])
697         else:
698             _log_default_iface(iface, binding, bond_def[binding])
699             bond.update({binding: bond_def[binding]})
700     if "use_carrier" in opts:
701         if opts["use_carrier"] in _CONFIG_TRUE:
702             bond.update({"use_carrier": "1"})
703         elif opts["use_carrier"] in _CONFIG_FALSE:
704             bond.update({"use_carrier": "0"})
705         else:
706             valid = _CONFIG_TRUE + _CONFIG_FALSE
707             _raise_error_iface(iface, "use_carrier", valid)
708     else:
709         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
710         bond.update({"use_carrier": bond_def["use_carrier"]})
711     return bond
712 def _parse_settings_bond_4(opts, iface, bond_def):
713     bond = {"mode": "4"}
714     for binding in ["miimon", "downdelay", "updelay", "lacp_rate", "ad_select"]:
715         if binding in opts:
716             if binding == "lacp_rate":
717                 if opts[binding] == "fast":
718                     opts.update({binding: "1"})
719                 if opts[binding] == "slow":
720                     opts.update({binding: "0"})
721                 valid = ["fast", "1", "slow", "0"]
722             else:
723                 valid = ["integer"]
724             try:
725                 int(opts[binding])
726                 bond.update({binding: opts[binding]})
727             except ValueError:
728                 _raise_error_iface(iface, binding, valid)
729         else:
730             _log_default_iface(iface, binding, bond_def[binding])
731             bond.update({binding: bond_def[binding]})
732     if "use_carrier" in opts:
733         if opts["use_carrier"] in _CONFIG_TRUE:
734             bond.update({"use_carrier": "1"})
735         elif opts["use_carrier"] in _CONFIG_FALSE:
736             bond.update({"use_carrier": "0"})
737         else:
738             valid = _CONFIG_TRUE + _CONFIG_FALSE
739             _raise_error_iface(iface, "use_carrier", valid)
740     else:
741         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
742         bond.update({"use_carrier": bond_def["use_carrier"]})
743     if "hashing-algorithm" in opts:
744         valid = ["layer2", "layer2+3", "layer3+4"]
745         if opts["hashing-algorithm"] in valid:
746             bond.update({"xmit_hash_policy": opts["hashing-algorithm"]})
747         else:
748             _raise_error_iface(iface, "hashing-algorithm", valid)
749     return bond
750 def _parse_settings_bond_5(opts, iface, bond_def):
751     bond = {"mode": "5"}
752     for binding in ["miimon", "downdelay", "updelay"]:
753         if binding in opts:
754             try:
755                 int(opts[binding])
756                 bond.update({binding: opts[binding]})
757             except ValueError:
758                 _raise_error_iface(iface, binding, ["integer"])
759         else:
760             _log_default_iface(iface, binding, bond_def[binding])
761             bond.update({binding: bond_def[binding]})
762     if "use_carrier" in opts:
763         if opts["use_carrier"] in _CONFIG_TRUE:
764             bond.update({"use_carrier": "1"})
765         elif opts["use_carrier"] in _CONFIG_FALSE:
766             bond.update({"use_carrier": "0"})
767         else:
768             valid = _CONFIG_TRUE + _CONFIG_FALSE
769             _raise_error_iface(iface, "use_carrier", valid)
770     else:
771         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
772         bond.update({"use_carrier": bond_def["use_carrier"]})
773     if "primary" in opts:
774         bond.update({"primary": opts["primary"]})
775     return bond
776 def _parse_settings_bond_6(opts, iface, bond_def):
777     bond = {"mode": "6"}
778     for binding in ["miimon", "downdelay", "updelay"]:
779         if binding in opts:
780             try:
781                 int(opts[binding])
782                 bond.update({binding: opts[binding]})
783             except ValueError:
784                 _raise_error_iface(iface, binding, ["integer"])
785         else:
786             _log_default_iface(iface, binding, bond_def[binding])
787             bond.update({binding: bond_def[binding]})
788     if "use_carrier" in opts:
789         if opts["use_carrier"] in _CONFIG_TRUE:
790             bond.update({"use_carrier": "1"})
791         elif opts["use_carrier"] in _CONFIG_FALSE:
792             bond.update({"use_carrier": "0"})
793         else:
794             valid = _CONFIG_TRUE + _CONFIG_FALSE
795             _raise_error_iface(iface, "use_carrier", valid)
796     else:
797         _log_default_iface(iface, "use_carrier", bond_def["use_carrier"])
798         bond.update({"use_carrier": bond_def["use_carrier"]})
799     if "primary" in opts:
800         bond.update({"primary": opts["primary"]})
801     return bond
802 def _parse_bridge_opts(opts, iface):
803     config = {}
804     if "ports" in opts:
805         if isinstance(opts["ports"], list):
806             opts["ports"] = " ".join(opts["ports"])
807         config.update({"ports": opts["ports"]})
808     for opt in ["ageing", "fd", "gcint", "hello", "maxage"]:
809         if opt in opts:
810             try:
811                 float(opts[opt])
812                 config.update({opt: opts[opt]})
813             except ValueError:
814                 _raise_error_iface(iface, opt, ["float"])
815     for opt in ["bridgeprio", "maxwait"]:
816         if opt in opts:
817             if isinstance(opts[opt], int):
818                 config.update({opt: opts[opt]})
819             else:
820                 _raise_error_iface(iface, opt, ["integer"])
821     if "hw" in opts:
822         if re.match(
823             "[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", opts["hw"].lower()
824         ):
825             config.update({"hw": opts["hw"]})
826         else:
827             _raise_error_iface(iface, "hw", ["valid MAC address"])
828     for opt in ["pathcost", "portprio"]:
829         if opt in opts:
830             try:
831                 port, cost_or_prio = opts[opt].split()
832                 int(cost_or_prio)
833                 config.update({opt: "{} {}".format(port, cost_or_prio)})
834             except ValueError:
835                 _raise_error_iface(iface, opt, ["interface integer"])
836     if "stp" in opts:
837         if opts["stp"] in _CONFIG_TRUE:
838             config.update({"stp": "on"})
839         elif opts["stp"] in _CONFIG_FALSE:
840             config.update({"stp": "off"})
841         else:
842             _raise_error_iface(iface, "stp", _CONFIG_TRUE + _CONFIG_FALSE)
843     if "waitport" in opts:
844         if isinstance(opts["waitport"], int):
845             config.update({"waitport": opts["waitport"]})
846         else:
847             values = opts["waitport"].split()
848             waitport_time = values.pop(0)
849             if waitport_time.isdigit() and values:
850                 config.update(
851                     {"waitport": "{} {}".format(waitport_time, " ".join(values))}
852                 )
853             else:
854                 _raise_error_iface(iface, opt, ["integer [interfaces]"])
855     return config
856 def _parse_settings_eth(opts, iface_type, enabled, iface):
857     adapters = salt.utils.odict.OrderedDict()
858     adapters[iface] = salt.utils.odict.OrderedDict()
859     adapters[iface]["type"] = iface_type
860     adapters[iface]["data"] = salt.utils.odict.OrderedDict()
861     iface_data = adapters[iface]["data"]
862     iface_data<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["inet"] = salt.utils.odict.OrderedDict()
863     iface_data["inet6"] = salt.utils.odict.OrderedDict(</b></font>)
864     if enabled:
865         adapters[iface]["enabled"] = True
866     if opts.get("hotplug", False):
867         adapters[iface]["hotplug"] = True
868     if opts.get("enable_ipv6", None) and opts.get("iface_type", "") == "vlan":
869         iface_data["inet6"]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
870     for addrfam in ["inet", "inet6"]:
871         if iface_type not in ["bridge"]:
872             tmp_ethtool = _parse_ethtool_opts(opts, iface)
873             if tmp_ethtool:
874                 ethtool = {}
875                 for item in tmp_ethtool:
876                     ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item]
877                 iface_data[addrfam]["ethtool"] = ethtool
878                 iface_data[addrfam]["ethtool_keys"] = sorted(ethtool)
879         if iface_type == "bridge":
880             bridging = _parse_bridge_opts(opts, iface)
881             if bridging:
882                 iface_data[addrfam]["bridging"] = bridging
883                 iface_data[addrfam]["bridging_keys"] = sorted(bridging)
884                 iface_data[addrfam]["addrfam"] = addrfam
885         elif iface_type == "bond":
886             bonding = _parse_settings_bond(opts, iface)
887             if bonding:
888                 iface_data[addrfam]["bonding"] = bonding
889                 iface_data[addrfam]["bonding"]["slaves"] = opts["slaves"]
890                 iface_data[addrfam]["bonding_keys"] = sorted(bonding)
891                 iface_data[addrfam]["addrfam"] = addrfam
892         elif iface_type == "slave":
893             adapters[iface]["master"] = opts["master"]
894             opts["proto"] = "manual"
895             iface_data[addrfam]["master"] = adapters[iface]["master"]
896             iface_data[addrfam]["addrfam"] = addrfam
897         elif iface_type == "vlan":
898             iface_data[addrfam]["vlan_raw_device"] = re.sub(r"\.\d*", "", iface)
899             iface_data[addrfam]["addrfam"] = addrfam
900         elif iface_type == "pppoe":
901             tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface)
902             if tmp_ethtool:
903                 for item in tmp_ethtool:
904                     adapters[iface]["data"][addrfam][
905                         _DEB_CONFIG_PPPOE_OPTS[item]
906                     ] = tmp_ethtool[item]
907             iface_data[addrfam]["addrfam"] = addrfam
908     opts.pop("mode", None)
909     for opt, val in opts.items():
910         inet = None
911         if opt.startswith("ipv4"):
912             opt = opt[4:]
913             inet = "inet"
914             iface_data["inet"]["addrfam"] = "inet"
915         elif opt.startswith("ipv6"):
916             iface_data["inet6"]["addrfam"] = "inet6"
917             opt = opt[4:]
918             inet = "inet6"
919         elif opt in [
920             "ipaddr",
921             "address",
922             "ipaddresses",
923             "addresses",
924             "gateway",
925             "proto",
926         ]:
927             iface_data["inet"]["addrfam"] = "inet"
928             inet = "inet"
929         _opt = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(opt, opt)
930         _debopt = _opt.replace("-", "_")
931         for addrfam in ["inet", "inet6"]:
932             (valid, value, errmsg) = _validate_interface_option(
933                 _opt, val, addrfam=addrfam
934             )
935             if not valid:
936                 continue
937             if inet is None and _debopt not in iface_data[addrfam]:
938                 iface_data[addrfam][_debopt] = value
939             elif inet == addrfam:
940                 iface_data[addrfam][_debopt] = value
941     for opt in [
942         "up_cmds",
943         "pre_up_cmds",
944         "post_up_cmds",
945         "down_cmds",
946         "pre_down_cmds",
947         "post_down_cmds",
948     ]:
949         if opt in opts:
950             iface_data["inet"][opt] = opts[opt]
951             iface_data["inet6"][opt] = opts[opt]
952     for (addrfam, opt) in [("inet", "enable_ipv4"), ("inet6", "enable_ipv6")]:
953         if opts.get(opt, None) is False:
954             iface_data.pop(addrfam)
955         elif iface_data[addrfam].get("addrfam", "") != addrfam:
956             iface_data.pop(addrfam)
957     return adapters
958 def _parse_settings_source(opts, iface_type, enabled, iface):
959     adapters = salt.utils.odict.OrderedDict()
960     adapters[iface] = salt.utils.odict.OrderedDict()
961     adapters[iface]["type"] = iface_type
962     adapters[iface]["data"] = salt.utils.odict.OrderedDict()
963     iface_data = adapters[iface]["data"]
964     iface_data["sources"] = [opts["source"]]
965     return adapters
966 def _parse_network_settings(opts, current):
967     opts = {k.lower(): v for (k, v) in opts.items()}
968     current = {k.lower(): v for (k, v) in current.items()}
969     result = {}
970     valid = _CONFIG_TRUE + _CONFIG_FALSE
971     if "enabled" not in opts:
972         try:
973             opts["networking"] = current["networking"]
974             _log_default_network("networking", current["networking"])
975         except ValueError:
976             _raise_error_network("networking", valid)
977     else:
978         opts["networking"] = opts["enabled"]
979     if opts["networking"] in valid:
980         if opts["networking"] in _CONFIG_TRUE:
981             result["networking"] = "yes"
982         elif opts["networking"] in _CONFIG_FALSE:
983             result["networking"] = "no"
984     else:
985         _raise_error_network("networking", valid)
986     if "hostname" not in opts:
987         try:
988             opts["hostname"] = current["hostname"]
989             _log_default_network("hostname", current["hostname"])
990         except ValueError:
991             _raise_error_network("hostname", ["server1.example.com"])
992     if opts["hostname"]:
993         result["hostname"] = opts["hostname"]
994     else:
995         _raise_error_network("hostname", ["server1.example.com"])
996     if "search" in opts:
997         result["search"] = opts["search"]
998     return result
999 def _parse_routes(iface, opts):
1000     opts = {k.lower(): v for (k, v) in opts.items()}
1001     result = {}
1002     if "routes" not in opts:
1003         _raise_error_routes(iface, "routes", "List of routes")
1004     for opt in opts:
1005         result[opt] = opts[opt]
1006     return result
1007 def _write_file(iface, data, folder, pattern):
1008     filename = os.path.join(folder, pattern.format(iface))
1009     if not os.path.exists(folder):
1010         msg = "{0} cannot be written. {1} does not exist"
1011         msg = msg.format(filename, folder)
1012         log.error(msg)
1013         raise AttributeError(msg)
1014     with salt.utils.files.flopen(filename, "w") as fout:
1015         fout.write(salt.utils.stringutils.to_str(data))
1016     return filename
1017 def _write_file_routes(iface, data, folder, pattern):
1018     iface = iface.replace(".", "_")
1019     filename = os.path.join(folder, pattern.format(iface))
1020     if not os.path.exists(folder):
1021         msg = "{0} cannot be written. {1} does not exist"
1022         msg = msg.format(filename, folder)
1023         log.error(msg)
1024         raise AttributeError(msg)
1025     with salt.utils.files.flopen(filename, "w") as fout:
1026         fout.write(salt.utils.stringutils.to_str(data))
1027     __salt__["file.set_mode"](filename, "0755")
1028     return filename
1029 def _write_file_network(data, filename, create=False):
1030     if not os.path.exists(filename) and not create:
1031         msg = "{0} cannot be written. {0} does not exist and create is setto False".format(
1032             filename
1033         )
1034         log.error(msg)
1035         raise AttributeError(msg)
1036     with salt.utils.files.flopen(filename, "w") as fout:
1037         fout.write(salt.utils.stringutils.to_str(data))
1038 def _read_temp(data):
1039     tout = io.StringIO()
1040     tout.write(data)
1041     tout.seek(0)
1042     output = tout.readlines()
1043     tout.close()
1044     return output
1045 def _read_temp_ifaces(iface, data):
1046     try:
1047         template = JINJA.get_template("debian_eth.jinja")
1048     except jinja2.exceptions.TemplateNotFound:
1049         log.error("Could not load template debian_eth.jinja")
1050         return ""
1051     ifcfg = template.render({"name": iface, "data": data})
1052     return [item + "\n" for item in ifcfg.split("\n")]
1053 def _write_file_ifaces(iface, data, **settings):
1054     try:
1055         eth_template = JINJA.get_template("debian_eth.jinja")
1056         source_template = JINJA.get_template("debian_source.jinja")
1057     except jinja2.exceptions.TemplateNotFound:
1058         log.error("Could not load template debian_eth.jinja")
1059         return ""
1060     adapters = _parse_interfaces()
1061     adapters[iface] = data
1062     ifcfg = ""
1063     for adapter in adapters:
1064         <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>if "type" in adapters[adapter] and adapters[adapter]["type"] == "source":
1065             tmp = source_template.render({"name": adapter, "data": adapters[adapter]})
1066         else:
1067             tmp = eth_template.render(</b></font>{"name": adapter, "data": adapters[adapter]})
1068         ifcfg = ifcfg + tmp
1069         if adapter == iface:
1070             saved_ifcfg = tmp
1071     _SEPARATE_FILE = False
1072     if "filename" in settings:
1073         if not settings["filename"].startswith("/"):
1074             filename = "{}/{}".format(_DEB_NETWORK_DIR, settings["filename"])
1075         else:
1076             filename = settings["filename"]
1077         _SEPARATE_FILE = True
1078     else:
1079         if "filename" in adapters[adapter]["data"]:
1080             filename = adapters[adapter]["data"]
1081         else:
1082             filename = _DEB_NETWORK_FILE
1083     if not os.path.exists(os.path.dirname(filename)):
1084         msg = "{0} cannot be written."
1085         msg = msg.format(os.path.dirname(filename))
1086         log.error(msg)
1087         raise AttributeError(msg)
1088     with salt.utils.files.flopen(filename, "w") as fout:
1089         if _SEPARATE_FILE:
1090             fout.write(salt.utils.stringutils.to_str(saved_ifcfg))
1091         else:
1092             fout.write(salt.utils.stringutils.to_str(ifcfg))
1093     return saved_ifcfg.split("\n")
1094 def _write_file_ppp_ifaces(iface, data):
1095     try:
1096         template = JINJA.get_template("debian_ppp_eth.jinja")
1097     except jinja2.exceptions.TemplateNotFound:
1098         log.error("Could not load template debian_ppp_eth.jinja")
1099         return ""
1100     adapters = _parse_interfaces()
1101     adapters[iface] = data
1102     ifcfg = ""
1103     tmp = template.render({"data": adapters[iface]})
1104     ifcfg = tmp + ifcfg
1105     filename = _DEB_PPP_DIR + "/" + adapters[iface]["data"]["inet"]["provider"]
1106     if not os.path.exists(os.path.dirname(filename)):
1107         msg = "{0} cannot be written."
1108         msg = msg.format(os.path.dirname(filename))
1109         log.error(msg)
1110         raise AttributeError(msg)
1111     with salt.utils.files.fopen(filename, "w") as fout:
1112         fout.write(salt.utils.stringutils.to_str(ifcfg))
1113     return filename
1114 def build_bond(iface, **settings):
1115     deb_major = __grains__["osrelease"][:1]
1116     opts = _parse_settings_bond(settings, iface)
1117     try:
1118         template = JINJA.get_template("conf.jinja")
1119     except jinja2.exceptions.TemplateNotFound:
1120         log.error("Could not load template conf.jinja")
1121         return ""
1122     data = template.render({"name": iface, "bonding": opts})
1123     if "test" in settings and settings["test"]:
1124         return _read_temp(data)
1125     _write_file(iface, data, _DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1126     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1127     if deb_major == "5":
1128         for line_type in ("alias", "options"):
1129             cmd = [
1130                 "sed",
1131                 "-i",
1132                 "-e",
1133                 r"/^{}\s{}.*/d".format(line_type, iface),
1134                 "/etc/modprobe.conf",
1135             ]
1136             __salt__["cmd.run"](cmd, python_shell=False)
1137         __salt__["file.append"]("/etc/modprobe.conf", path)
1138     __salt__["kmod.load"]("bonding")
1139     __salt__["pkg.install"]("ifenslave")
1140     return _read_file(path)
1141 def build_interface(iface, iface_type, enabled, **settings):
1142     iface_type = iface_type.lower()
1143     if iface_type not in _IFACE_TYPES:
1144         _raise_error_iface(iface, iface_type, _IFACE_TYPES)
1145     if iface_type == "slave":
1146         settings["slave"] = "yes"
1147         if "master" not in settings:
1148             msg = "master is a required setting for slave interfaces"
1149             log.error(msg)
1150             raise AttributeError(msg)
1151     elif iface_type == "vlan":
1152         settings["vlan"] = "yes"
1153         __salt__["pkg.install"]("vlan")
1154     elif iface_type == "pppoe":
1155         settings["pppoe"] = "yes"
1156         if not __salt__["pkg.version"]("ppp"):
1157             inst = __salt__["pkg.install"]("ppp")
1158     elif iface_type == "bond":
1159         if "slaves" not in settings:
1160             msg = "slaves is a required setting for bond interfaces"
1161             log.error(msg)
1162             raise AttributeError(msg)
1163     elif iface_type == "bridge":
1164         if "ports" not in settings:
1165             msg = (
1166                 "ports is a required setting for bridge interfaces on Debian "
1167                 "or Ubuntu based systems"
1168             )
1169             log.error(msg)
1170             raise AttributeError(msg)
1171         __salt__["pkg.install"]("bridge-utils")
1172     if iface_type in ["eth", "bond", "bridge", "slave", "vlan", "pppoe"]:
1173         opts = _parse_settings_eth(settings, iface_type, enabled, iface)
1174     if iface_type in ["source"]:
1175         opts = _parse_settings_source(settings, iface_type, enabled, iface)
1176     if "test" in settings and settings["test"]:
1177         return _read_temp_ifaces(iface, opts[iface])
1178     ifcfg = _write_file_ifaces(iface, opts[iface], **settings)
1179     if iface_type == "pppoe":
1180         _write_file_ppp_ifaces(iface, opts[iface])
1181     return [item + "\n" for item in ifcfg]
1182 def build_routes(iface, **settings):
1183     opts = _parse_routes(iface, settings)
1184     try:
1185         template = JINJA.get_template("route_eth.jinja")
1186     except jinja2.exceptions.TemplateNotFound:
1187         log.error("Could not load template route_eth.jinja")
1188         return ""
1189     add_routecfg = template.render(route_type="add", routes=opts["routes"], iface=iface)
1190     del_routecfg = template.render(route_type="del", routes=opts["routes"], iface=iface)
1191     if "test" in settings and settings["test"]:
1192         return _read_temp(add_routecfg + del_routecfg)
1193     filename = _write_file_routes(iface, add_routecfg, _DEB_NETWORK_UP_DIR, "route-{0}")
1194     results = _read_file(filename)
1195     filename = _write_file_routes(
1196         iface, del_routecfg, _DEB_NETWORK_DOWN_DIR, "route-{0}"
1197     )
1198     results += _read_file(filename)
1199     return results
1200 def down(iface, iface_type):
1201     if iface_type not in ["slave", "source"]:
1202         return __salt__["cmd.run"](["ifdown", iface])
1203     return None
1204 def get_bond(iface):
1205     path = os.path.join(_DEB_NETWORK_CONF_FILES, "{}.conf".format(iface))
1206     return _read_file(path)
1207 def get_interface(iface):
1208     adapters = _parse_interfaces()
1209     if iface in adapters:
1210         try:
1211             if iface == "source":
1212                 template = JINJA.get_template("debian_source.jinja")
1213             else:
1214                 template = JINJA.get_template("debian_eth.jinja")
1215         except jinja2.exceptions.TemplateNotFound:
1216             log.error("Could not load template debian_eth.jinja")
1217             return ""
1218         ifcfg = template.render({"name": iface, "data": adapters[iface]})
1219         return [item + "\n" for item in ifcfg.split("\n")]
1220     else:
1221         return []
1222 def up(iface, iface_type):  # pylint: disable=C0103
1223     if iface_type not in ("slave", "source"):
1224         return __salt__["cmd.run"](["ifup", iface])
1225     return None
1226 def get_network_settings():
1227     skip_etc_default_networking = (
1228         __grains__["osfullname"] == "Ubuntu"
1229         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1230     )
1231     if skip_etc_default_networking:
1232         settings = {}
1233         if __salt__["service.available"]("networking"):
1234             if __salt__["service.status"]("networking"):
1235                 settings["networking"] = "yes"
1236             else:
1237                 settings["networking"] = "no"
1238         else:
1239             settings["networking"] = "no"
1240         hostname = _parse_hostname()
1241         domainname = _parse_domainname()
1242         settings["hostname"] = hostname
1243         settings["domainname"] = domainname
1244     else:
1245         settings = _parse_current_network_settings()
1246     try:
1247         template = JINJA.get_template("display-network.jinja")
1248     except jinja2.exceptions.TemplateNotFound:
1249         log.error("Could not load template display-network.jinja")
1250         return ""
1251     network = template.render(settings)
1252     return _read_temp(network)
1253 def get_routes(iface):
1254     filename = os.path.join(_DEB_NETWORK_UP_DIR, "route-{}".format(iface))
1255     results = _read_file(filename)
1256     filename = os.path.join(_DEB_NETWORK_DOWN_DIR, "route-{}".format(iface))
1257     results += _read_file(filename)
1258     return results
1259 def apply_network_settings(**settings):
1260     if "require_reboot" not in settings:
1261         settings["require_reboot"] = False
1262     if "apply_hostname" not in settings:
1263         settings["apply_hostname"] = False
1264     hostname_res = True
1265     if settings["apply_hostname"] in _CONFIG_TRUE:
1266         if "hostname" in settings:
1267             hostname_res = __salt__["network.mod_hostname"](settings["hostname"])
1268         else:
1269             log.warning(
1270                 "The network state sls is trying to apply hostname "
1271                 "changes but no hostname is defined."
1272             )
1273             hostname_res = False
1274     res = True
1275     if settings["require_reboot"] in _CONFIG_TRUE:
1276         log.warning(
1277             "The network state sls is requiring a reboot of the system to "
1278             "properly apply network configuration."
1279         )
1280         res = True
1281     else:
1282         stop = __salt__["service.stop"]("networking")
1283         time.sleep(2)
1284         res = stop and __salt__["service.start"]("networking")
1285     return hostname_res and res
1286 def build_network_settings(**settings):
1287     changes = []
1288     current_network_settings = _parse_current_network_settings()
1289     opts = _parse_network_settings(settings, current_network_settings)
1290     skip_etc_default_networking = (
1291         __grains__["osfullname"] == "Ubuntu"
1292         and int(__grains__["osrelease"].split(".")[0]) &gt;= 12
1293     )
1294     if skip_etc_default_networking:
1295         if opts["networking"] == "yes":
1296             service_cmd = "service.enable"
1297         else:
1298             service_cmd = "service.disable"
1299         if __salt__["service.available"]("NetworkManager"):
1300             __salt__[service_cmd]("NetworkManager")
1301         if __salt__["service.available"]("networking"):
1302             __salt__[service_cmd]("networking")
1303     else:
1304         try:
1305             template = JINJA.get_template("network.jinja")
1306         except jinja2.exceptions.TemplateNotFound:
1307             log.error("Could not load template network.jinja")
1308             return ""
1309         network = template.render(opts)
1310         if "test" in settings and settings["test"]:
1311             return _read_temp(network)
1312         _write_file_network(network, _DEB_NETWORKING_FILE, True)
1313     sline = opts["hostname"].split(".", 1)
1314     opts["hostname"] = sline[0]
1315     current_domainname = current_network_settings["domainname"]
1316     current_searchdomain = current_network_settings["searchdomain"]
1317     new_domain = False
1318     if len(sline) &gt; 1:
1319         new_domainname = sline[1]
1320         if new_domainname != current_domainname:
1321             domainname = new_domainname
1322             opts["domainname"] = new_domainname
1323             new_domain = True
1324         else:
1325             domainname = current_domainname
1326             opts["domainname"] = domainname
1327     else:
1328         domainname = current_domainname
1329         opts["domainname"] = domainname
1330     new_search = False
1331     if "search" in opts:
1332         new_searchdomain = opts["search"]
1333         if new_searchdomain != current_searchdomain:
1334             searchdomain = new_searchdomain
1335             opts["searchdomain"] = new_searchdomain
1336             new_search = True
1337         else:
1338             searchdomain = current_searchdomain
1339             opts["searchdomain"] = searchdomain
1340     else:
1341         searchdomain = current_searchdomain
1342         opts["searchdomain"] = searchdomain
1343     if new_domain or new_search:
1344         resolve = _parse_resolve()
1345         domain_prog = re.compile(r"domain\s+")
1346         search_prog = re.compile(r"search\s+")
1347         new_contents = []
1348         for item in _read_file(_DEB_RESOLV_FILE):
1349             if domain_prog.match(item):
1350                 item = "domain {}".format(domainname)
1351             elif search_prog.match(item):
1352                 item = "search {}".format(searchdomain)
1353             new_contents.append(item)
1354         if "domain" not in resolve:
1355             new_contents.insert(0, "domain {}".format(domainname))
1356         if "search" not in resolve:
1357             new_contents.insert("domain" in resolve, "search {}".format(searchdomain))
1358         new_resolv = "\n".join(new_contents)
1359         if not ("test" in settings and settings["test"]):
1360             _write_file_network(new_resolv, _DEB_RESOLV_FILE)
1361     try:
1362         template = JINJA.get_template("display-network.jinja")
1363     except jinja2.exceptions.TemplateNotFound:
1364         log.error("Could not load template display-network.jinja")
1365         return ""
1366     network = template.render(opts)
1367     changes.extend(_read_temp(network))
1368     return changes
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
