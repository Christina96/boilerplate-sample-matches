<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for query.py & debian_ip.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for query.py & debian_ip.py
      </h3>
      <h1 align="center">
        2.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>query.py (4.972376%)<TH>debian_ip.py (1.384083%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match161671-0.html#0',2,'match161671-1.html#0',3)" NAME="0">(424-426)<TD><A HREF="javascript:ZweiFrames('match161671-0.html#0',2,'match161671-1.html#0',3)" NAME="0">(1545-1548)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match161671-0.html#1',2,'match161671-1.html#1',3)" NAME="1">(128-129)<TD><A HREF="javascript:ZweiFrames('match161671-0.html#1',2,'match161671-1.html#1',3)" NAME="1">(1243-1244)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match161671-0.html#2',2,'match161671-1.html#2',3)" NAME="2">(17-28)<TD><A HREF="javascript:ZweiFrames('match161671-0.html#2',2,'match161671-1.html#2',3)" NAME="2">(14-25)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>query.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#
# Copyright 2015 SUSE LLC
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
<A NAME="2"></A># limitations under the License.


<FONT color="#980517"><A HREF="javascript:ZweiFrames('match161671-1.html#2',3,'match161671-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import logging
import os
import time

import salt.utils.files
import salt.utils.fsutils
import salt.utils.network
from salt.modules.inspectlib import EnvLoader
from salt.modules.inspectlib.entities import Package, PackageCfgFile, PayloadFile
from salt.modules.inspectlib.exceptions import InspectorQueryException, SIException

log = logging.getLogger(</B></FONT>__name__)


class SysInfo:
    &quot;&quot;&quot;
    System information.
    &quot;&quot;&quot;

    def __init__(self, systype):
        if systype.lower() == &quot;solaris&quot;:
            raise SIException(&quot;Platform {} not (yet) supported.&quot;.format(systype))

    def _grain(self, grain):
        &quot;&quot;&quot;
        An alias for grains getter.
        &quot;&quot;&quot;
        return __grains__.get(grain, &quot;N/A&quot;)

    def _get_disk_size(self, device):
        &quot;&quot;&quot;
        Get a size of a disk.
        &quot;&quot;&quot;
        out = __salt__[&quot;cmd.run_all&quot;](&quot;df {}&quot;.format(device))
        if out[&quot;retcode&quot;]:
            msg = &quot;Disk size info error: {}&quot;.format(out[&quot;stderr&quot;])
            log.error(msg)
            raise SIException(msg)

        devpath, blocks, used, available, used_p, mountpoint = (
            elm for elm in out[&quot;stdout&quot;].split(os.linesep)[-1].split(&quot; &quot;) if elm
        )
        return {
            &quot;device&quot;: devpath,
            &quot;blocks&quot;: blocks,
            &quot;used&quot;: used,
            &quot;available&quot;: available,
            &quot;used (%)&quot;: used_p,
            &quot;mounted&quot;: mountpoint,
        }

    def _get_fs(self):
        &quot;&quot;&quot;
        Get available file systems and their types.
        &quot;&quot;&quot;

        data = dict()
        for dev, dev_data in salt.utils.fsutils._blkid().items():
            dev = self._get_disk_size(dev)
            device = dev.pop(&quot;device&quot;)
            dev[&quot;type&quot;] = dev_data[&quot;type&quot;]
            data[device] = dev

        return data

    def _get_mounts(self):
        &quot;&quot;&quot;
        Get mounted FS on the system.
        &quot;&quot;&quot;
        return salt.utils.fsutils._get_mounts()

    def _get_cpu(self):
        &quot;&quot;&quot;
        Get available CPU information.
        &quot;&quot;&quot;
        # CPU data in grains is OK-ish, but lscpu is still better in this case
        out = __salt__[&quot;cmd.run_all&quot;](&quot;lscpu&quot;)
        salt.utils.fsutils._verify_run(out)
        data = dict()
        for descr, value in [
            elm.split(&quot;:&quot;, 1) for elm in out[&quot;stdout&quot;].split(os.linesep)
        ]:
            data[descr.strip()] = value.strip()

        return data

    def _get_mem(self):
        &quot;&quot;&quot;
        Get memory.
        &quot;&quot;&quot;
        out = __salt__[&quot;cmd.run_all&quot;](&quot;vmstat -s&quot;)
        if out[&quot;retcode&quot;]:
            raise SIException(&quot;Memory info error: {}&quot;.format(out[&quot;stderr&quot;]))

        ret = dict()
        for line in out[&quot;stdout&quot;].split(os.linesep):
            line = line.strip()
            if not line:
                continue
            size, descr = line.split(&quot; &quot;, 1)
            if descr.startswith(&quot;K &quot;):
                descr = descr[2:]
                size = size + &quot;K&quot;
            ret[descr] = size
        return ret

    def _get_network(self):
        &quot;&quot;&quot;
<A NAME="1"></A>        Get network configuration.
        &quot;&quot;&quot;
        data = dict()
        data<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match161671-1.html#1',3,'match161671-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>[&quot;interfaces&quot;] = salt.utils.network.interfaces()
        data[&quot;subnets&quot;] = salt.utils.network.subnets(</B></FONT>)

        return data

    def _get_os(self):
        &quot;&quot;&quot;
        Get operating system summary
        &quot;&quot;&quot;
        return {
            &quot;name&quot;: self._grain(&quot;os&quot;),
            &quot;family&quot;: self._grain(&quot;os_family&quot;),
            &quot;arch&quot;: self._grain(&quot;osarch&quot;),
            &quot;release&quot;: self._grain(&quot;osrelease&quot;),
        }


class Query(EnvLoader):
    &quot;&quot;&quot;
    Query the system.
    This class is actually puts all Salt features together,
    so there would be no need to pick it from various places.
    &quot;&quot;&quot;

    # Configuration: config files
    # Identity: users/groups
    # Software: packages, patterns, repositories
    # Services
    # System: distro, RAM etc
    # Changes: all files that are managed and were changed from the original
    # all: include all scopes (scary!)
    # payload: files that are not managed

    SCOPES = [
        &quot;changes&quot;,
        &quot;configuration&quot;,
        &quot;identity&quot;,
        &quot;system&quot;,
        &quot;software&quot;,
        &quot;services&quot;,
        &quot;payload&quot;,
        &quot;all&quot;,
    ]

    def __init__(self, scope, cachedir=None):
        &quot;&quot;&quot;
        Constructor.

        :param scope:
        :return:
        &quot;&quot;&quot;
        if scope and scope not in self.SCOPES:
            raise InspectorQueryException(
                &quot;Unknown scope: {}. Must be one of: {}&quot;.format(
                    repr(scope), &quot;, &quot;.join(self.SCOPES)
                )
            )
        elif not scope:
            raise InspectorQueryException(
                &quot;Scope cannot be empty. Must be one of: {}&quot;.format(
                    &quot;, &quot;.join(self.SCOPES)
                )
            )
        EnvLoader.__init__(self, cachedir=cachedir)
        self.scope = &quot;_&quot; + scope
        self.local_identity = dict()

    def __call__(self, *args, **kwargs):
        &quot;&quot;&quot;
        Call the query with the defined scope.

        :param args:
        :param kwargs:
        :return:
        &quot;&quot;&quot;

        return getattr(self, self.scope)(*args, **kwargs)

    def _changes(self, *args, **kwargs):
        &quot;&quot;&quot;
        Returns all diffs to the configuration files.
        &quot;&quot;&quot;
        raise Exception(&quot;Not yet implemented&quot;)

    def _configuration(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return configuration files.
        &quot;&quot;&quot;

        data = dict()
        self.db.open()
        for pkg in self.db.get(Package):
            configs = list()
            for pkg_cfg in self.db.get(PackageCfgFile, eq={&quot;pkgid&quot;: pkg.id}):
                configs.append(pkg_cfg.path)
            data[pkg.name] = configs

        if not data:
            raise InspectorQueryException(&quot;No inspected configuration yet available.&quot;)

        return data

    def _get_local_users(self, disabled=None):
        &quot;&quot;&quot;
        Return all known local accounts to the system.
        &quot;&quot;&quot;
        users = dict()
        path = &quot;/etc/passwd&quot;
        with salt.utils.files.fopen(path, &quot;r&quot;) as fp_:
            for line in fp_:
                line = line.strip()
                if &quot;:&quot; not in line:
                    continue
                name, password, uid, gid, gecos, directory, shell = line.split(&quot;:&quot;)
                active = not (password == &quot;*&quot; or password.startswith(&quot;!&quot;))
                if (
                    (disabled is False and active)
                    or (disabled is True and not active)
                    or disabled is None
                ):
                    users[name] = {
                        &quot;uid&quot;: uid,
                        &quot;git&quot;: gid,
                        &quot;info&quot;: gecos,
                        &quot;home&quot;: directory,
                        &quot;shell&quot;: shell,
                        &quot;disabled&quot;: not active,
                    }

        return users

    def _get_local_groups(self):
        &quot;&quot;&quot;
        Return all known local groups to the system.
        &quot;&quot;&quot;
        groups = dict()
        path = &quot;/etc/group&quot;
        with salt.utils.files.fopen(path, &quot;r&quot;) as fp_:
            for line in fp_:
                line = line.strip()
                if &quot;:&quot; not in line:
                    continue
                name, password, gid, users = line.split(&quot;:&quot;)
                groups[name] = {
                    &quot;gid&quot;: gid,
                }

                if users:
                    groups[name][&quot;users&quot;] = users.split(&quot;,&quot;)

        return groups

    def _get_external_accounts(self, locals):
        &quot;&quot;&quot;
        Return all known accounts, excluding local accounts.
        &quot;&quot;&quot;
        users = dict()
        out = __salt__[&quot;cmd.run_all&quot;](&quot;passwd -S -a&quot;)
        if out[&quot;retcode&quot;]:
            # System does not supports all accounts descriptions, just skipping.
            return users
        status = {
            &quot;L&quot;: &quot;Locked&quot;,
            &quot;NP&quot;: &quot;No password&quot;,
            &quot;P&quot;: &quot;Usable password&quot;,
            &quot;LK&quot;: &quot;Locked&quot;,
        }
        for data in [
            elm.strip().split(&quot; &quot;)
            for elm in out[&quot;stdout&quot;].split(os.linesep)
            if elm.strip()
        ]:
            if len(data) &lt; 2:
                continue
            name, login = data[:2]
            if name not in locals:
                users[name] = {&quot;login&quot;: login, &quot;status&quot;: status.get(login, &quot;N/A&quot;)}

        return users

    def _identity(self, *args, **kwargs):
        &quot;&quot;&quot;
        Local users and groups.

        accounts
            Can be either 'local', 'remote' or 'all' (equal to &quot;local,remote&quot;).
            Remote accounts cannot be resolved on all systems, but only
            those, which supports 'passwd -S -a'.

        disabled
            True (or False, default) to return only disabled accounts.
        &quot;&quot;&quot;
        LOCAL = &quot;local accounts&quot;
        EXT = &quot;external accounts&quot;

        data = dict()
        data[LOCAL] = self._get_local_users(disabled=kwargs.get(&quot;disabled&quot;))
        data[EXT] = self._get_external_accounts(data[LOCAL].keys()) or &quot;N/A&quot;
        data[&quot;local groups&quot;] = self._get_local_groups()

        return data

    def _system(self, *args, **kwargs):
        &quot;&quot;&quot;
        This basically calls grains items and picks out only
        necessary information in a certain structure.

        :param args:
        :param kwargs:
        :return:
        &quot;&quot;&quot;
        sysinfo = SysInfo(__grains__.get(&quot;kernel&quot;))

        data = dict()
        data[&quot;cpu&quot;] = sysinfo._get_cpu()
        data[&quot;disks&quot;] = sysinfo._get_fs()
        data[&quot;mounts&quot;] = sysinfo._get_mounts()
        data[&quot;memory&quot;] = sysinfo._get_mem()
        data[&quot;network&quot;] = sysinfo._get_network()
        data[&quot;os&quot;] = sysinfo._get_os()

        return data

    def _software(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return installed software.
        &quot;&quot;&quot;
        data = dict()
        if &quot;exclude&quot; in kwargs:
            excludes = kwargs[&quot;exclude&quot;].split(&quot;,&quot;)
        else:
            excludes = list()

        os_family = __grains__.get(&quot;os_family&quot;).lower()

        # Get locks
        if os_family == &quot;suse&quot;:
            LOCKS = &quot;pkg.list_locks&quot;
            if &quot;products&quot; not in excludes:
                products = __salt__[&quot;pkg.list_products&quot;]()
                if products:
                    data[&quot;products&quot;] = products
        elif os_family == &quot;redhat&quot;:
            LOCKS = &quot;pkg.get_locked_packages&quot;
        else:
            LOCKS = None

        if LOCKS and &quot;locks&quot; not in excludes:
            locks = __salt__[LOCKS]()
            if locks:
                data[&quot;locks&quot;] = locks

        # Get patterns
        if os_family == &quot;suse&quot;:
            PATTERNS = &quot;pkg.list_installed_patterns&quot;
        elif os_family == &quot;redhat&quot;:
            PATTERNS = &quot;pkg.group_list&quot;
        else:
            PATTERNS = None

        if PATTERNS and &quot;patterns&quot; not in excludes:
            patterns = __salt__[PATTERNS]()
            if patterns:
                data[&quot;patterns&quot;] = patterns

        # Get packages
        if &quot;packages&quot; not in excludes:
            data[&quot;packages&quot;] = __salt__[&quot;pkg.list_pkgs&quot;]()

        # Get repositories
        if &quot;repositories&quot; not in excludes:
            repos = __salt__[&quot;pkg.list_repos&quot;]()
            if repos:
                data[&quot;repositories&quot;] = repos

        return data

    def _services(self, *args, **kwargs):
        &quot;&quot;&quot;
        Get list of enabled and disabled services on the particular system.
        &quot;&quot;&quot;
        return {
            &quot;enabled&quot;: __salt__[&quot;service.get_enabled&quot;](),
            &quot;disabled&quot;: __salt__[&quot;service.get_disabled&quot;](),
        }

    def _id_resolv(self, iid, named=True, uid=True):
        &quot;&quot;&quot;
        Resolve local users and groups.

        :param iid:
        :param named:
        :param uid:
<A NAME="0"></A>        :return:
        &quot;&quot;&quot;

        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match161671-1.html#0',3,'match161671-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>if not self.local_identity:
            self.local_identity[&quot;users&quot;] = self._get_local_users()
            self.local_identity[&quot;groups&quot;] = self._get_local_groups(</B></FONT>)

        if not named:
            return iid

        for name, meta in self.local_identity[uid and &quot;users&quot; or &quot;groups&quot;].items():
            if (uid and int(meta.get(&quot;uid&quot;, -1)) == iid) or (
                not uid and int(meta.get(&quot;gid&quot;, -1)) == iid
            ):
                return name

        return iid

    def _payload(self, *args, **kwargs):
        &quot;&quot;&quot;
        Find all unmanaged files. Returns maximum 1000 values.

        Parameters:

        * **filter**: Include only results which path starts from the filter string.
        * **time**: Display time in Unix ticks or format according to the configured TZ (default)
                    Values: ticks, tz (default)
        * **size**: Format size. Values: B, KB, MB, GB
        * **owners**: Resolve UID/GID to an actual names or leave them numeric (default).
                      Values: name (default), id
        * **type**: Comma-separated type of included payload: dir (or directory), link and/or file.
        * **brief**: Return just a list of matches, if True. Default: False
        * **offset**: Offset of the files
        * **max**: Maximum returned values. Default 1000.

        Options:

        * **total**: Return a total amount of found payload files
        &quot;&quot;&quot;

        def _size_format(size, fmt):
            if fmt is None:
                return size

            fmt = fmt.lower()
            if fmt == &quot;b&quot;:
                return &quot;{} Bytes&quot;.format(size)
            elif fmt == &quot;kb&quot;:
                return &quot;{} Kb&quot;.format(round((float(size) / 0x400), 2))
            elif fmt == &quot;mb&quot;:
                return &quot;{} Mb&quot;.format(round((float(size) / 0x400 / 0x400), 2))
            elif fmt == &quot;gb&quot;:
                return &quot;{} Gb&quot;.format(round((float(size) / 0x400 / 0x400 / 0x400), 2))

        filter = kwargs.get(&quot;filter&quot;)
        offset = kwargs.get(&quot;offset&quot;, 0)

        timeformat = kwargs.get(&quot;time&quot;, &quot;tz&quot;)
        if timeformat not in [&quot;ticks&quot;, &quot;tz&quot;]:
            raise InspectorQueryException(
                'Unknown &quot;{}&quot; value for parameter &quot;time&quot;'.format(timeformat)
            )
        tfmt = (
            lambda param: timeformat == &quot;tz&quot;
            and time.strftime(&quot;%b %d %Y %H:%M:%S&quot;, time.gmtime(param))
            or int(param)
        )

        size_fmt = kwargs.get(&quot;size&quot;)
        if size_fmt is not None and size_fmt.lower() not in [&quot;b&quot;, &quot;kb&quot;, &quot;mb&quot;, &quot;gb&quot;]:
            raise InspectorQueryException(
                'Unknown &quot;{}&quot; value for parameter &quot;size&quot;. '
                &quot;Should be either B, Kb, Mb or Gb&quot;.format(timeformat)
            )

        owners = kwargs.get(&quot;owners&quot;, &quot;id&quot;)
        if owners not in [&quot;name&quot;, &quot;id&quot;]:
            raise InspectorQueryException(
                'Unknown &quot;{}&quot; value for parameter &quot;owners&quot;. '
                &quot;Should be either name or id (default)&quot;.format(owners)
            )

        incl_type = [prm for prm in kwargs.get(&quot;type&quot;, &quot;&quot;).lower().split(&quot;,&quot;) if prm]
        if not incl_type:
            incl_type.append(&quot;file&quot;)

        for i_type in incl_type:
            if i_type not in [&quot;directory&quot;, &quot;dir&quot;, &quot;d&quot;, &quot;file&quot;, &quot;f&quot;, &quot;link&quot;, &quot;l&quot;]:
                raise InspectorQueryException(
                    'Unknown &quot;{}&quot; values for parameter &quot;type&quot;. '
                    &quot;Should be comma separated one or more of &quot;
                    &quot;dir, file and/or link.&quot;.format(&quot;, &quot;.join(incl_type))
                )
        self.db.open()

        if &quot;total&quot; in args:
            return {&quot;total&quot;: len(self.db.get(PayloadFile))}

        brief = kwargs.get(&quot;brief&quot;)
        pld_files = list() if brief else dict()
        for pld_data in self.db.get(PayloadFile)[
            offset : offset + kwargs.get(&quot;max&quot;, 1000)
        ]:
            if brief:
                pld_files.append(pld_data.path)
            else:
                pld_files[pld_data.path] = {
                    &quot;uid&quot;: self._id_resolv(pld_data.uid, named=(owners == &quot;id&quot;)),
                    &quot;gid&quot;: self._id_resolv(
                        pld_data.gid, named=(owners == &quot;id&quot;), uid=False
                    ),
                    &quot;size&quot;: _size_format(pld_data.p_size, fmt=size_fmt),
                    &quot;mode&quot;: oct(pld_data.mode),
                    &quot;accessed&quot;: tfmt(pld_data.atime),
                    &quot;modified&quot;: tfmt(pld_data.mtime),
                    &quot;created&quot;: tfmt(pld_data.ctime),
                }

        return pld_files

    def _all(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return all the summary of the particular system.
        &quot;&quot;&quot;
        data = dict()
        data[&quot;software&quot;] = self._software(**kwargs)
        data[&quot;system&quot;] = self._system(**kwargs)
        data[&quot;services&quot;] = self._services(**kwargs)
        try:
            data[&quot;configuration&quot;] = self._configuration(**kwargs)
        except InspectorQueryException as ex:
            data[&quot;configuration&quot;] = &quot;N/A&quot;
            log.error(ex)
        data[&quot;payload&quot;] = self._payload(**kwargs) or &quot;N/A&quot;

        return data
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>debian_ip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
The networking module for Debian-based distros

References:

* http://www.debian.org/doc/manuals/debian-reference/ch05.en.html
&quot;&quot;&quot;
import functools
import io
import logging
<A NAME="2"></A>import os
import os.path
import re
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match161671-0.html#2',2,'match161671-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import time

import jinja2
import jinja2.exceptions
import salt.utils.dns
import salt.utils.files
import salt.utils.odict
import salt.utils.stringutils
import salt.utils.templates
import salt.utils.validate.net

log = logging.getLogger(</B></FONT>__name__)

# Set up template environment
JINJA = jinja2.Environment(
    loader=jinja2.FileSystemLoader(
        os.path.join(salt.utils.templates.TEMPLATE_DIRNAME, &quot;debian_ip&quot;)
    )
)

# Define the module's virtual name
__virtualname__ = &quot;ip&quot;


def __virtual__():
    &quot;&quot;&quot;
    Confine this module to Debian-based distros
    &quot;&quot;&quot;
    if __grains__[&quot;os_family&quot;] == &quot;Debian&quot;:
        return __virtualname__
    return (False, &quot;The debian_ip module could not be loaded: unsupported OS family&quot;)


_ETHTOOL_CONFIG_OPTS = {
    &quot;speed&quot;: &quot;link-speed&quot;,
    &quot;duplex&quot;: &quot;link-duplex&quot;,
    &quot;autoneg&quot;: &quot;ethernet-autoneg&quot;,
    &quot;ethernet-port&quot;: &quot;ethernet-port&quot;,
    &quot;wol&quot;: &quot;ethernet-wol&quot;,
    &quot;driver-message-level&quot;: &quot;driver-message-level&quot;,
    &quot;ethernet-pause-rx&quot;: &quot;ethernet-pause-rx&quot;,
    &quot;ethernet-pause-tx&quot;: &quot;ethernet-pause-tx&quot;,
    &quot;ethernet-pause-autoneg&quot;: &quot;ethernet-pause-autoneg&quot;,
    &quot;rx&quot;: &quot;offload-rx&quot;,
    &quot;tx&quot;: &quot;offload-tx&quot;,
    &quot;sg&quot;: &quot;offload-sg&quot;,
    &quot;tso&quot;: &quot;offload-tso&quot;,
    &quot;ufo&quot;: &quot;offload-ufo&quot;,
    &quot;gso&quot;: &quot;offload-gso&quot;,
    &quot;gro&quot;: &quot;offload-gro&quot;,
    &quot;lro&quot;: &quot;offload-lro&quot;,
    &quot;hardware-irq-coalesce-adaptive-rx&quot;: &quot;hardware-irq-coalesce-adaptive-rx&quot;,
    &quot;hardware-irq-coalesce-adaptive-tx&quot;: &quot;hardware-irq-coalesce-adaptive-tx&quot;,
    &quot;hardware-irq-coalesce-rx-usecs&quot;: &quot;hardware-irq-coalesce-rx-usecs&quot;,
    &quot;hardware-irq-coalesce-rx-frames&quot;: &quot;hardware-irq-coalesce-rx-frames&quot;,
    &quot;hardware-dma-ring-rx&quot;: &quot;hardware-dma-ring-rx&quot;,
    &quot;hardware-dma-ring-rx-mini&quot;: &quot;hardware-dma-ring-rx-mini&quot;,
    &quot;hardware-dma-ring-rx-jumbo&quot;: &quot;hardware-dma-ring-rx-jumbo&quot;,
    &quot;hardware-dma-ring-tx&quot;: &quot;hardware-dma-ring-tx&quot;,
}

_REV_ETHTOOL_CONFIG_OPTS = {
    &quot;link-speed&quot;: &quot;speed&quot;,
    &quot;link-duplex&quot;: &quot;duplex&quot;,
    &quot;ethernet-autoneg&quot;: &quot;autoneg&quot;,
    &quot;ethernet-port&quot;: &quot;ethernet-port&quot;,
    &quot;ethernet-wol&quot;: &quot;wol&quot;,
    &quot;driver-message-level&quot;: &quot;driver-message-level&quot;,
    &quot;ethernet-pause-rx&quot;: &quot;ethernet-pause-rx&quot;,
    &quot;ethernet-pause-tx&quot;: &quot;ethernet-pause-tx&quot;,
    &quot;ethernet-pause-autoneg&quot;: &quot;ethernet-pause-autoneg&quot;,
    &quot;offload-rx&quot;: &quot;rx&quot;,
    &quot;offload-tx&quot;: &quot;tx&quot;,
    &quot;offload-sg&quot;: &quot;sg&quot;,
    &quot;offload-tso&quot;: &quot;tso&quot;,
    &quot;offload-ufo&quot;: &quot;ufo&quot;,
    &quot;offload-gso&quot;: &quot;gso&quot;,
    &quot;offload-lro&quot;: &quot;lro&quot;,
    &quot;offload-gro&quot;: &quot;gro&quot;,
    &quot;hardware-irq-coalesce-adaptive-rx&quot;: &quot;hardware-irq-coalesce-adaptive-rx&quot;,
    &quot;hardware-irq-coalesce-adaptive-tx&quot;: &quot;hardware-irq-coalesce-adaptive-tx&quot;,
    &quot;hardware-irq-coalesce-rx-usecs&quot;: &quot;hardware-irq-coalesce-rx-usecs&quot;,
    &quot;hardware-irq-coalesce-rx-frames&quot;: &quot;hardware-irq-coalesce-rx-frames&quot;,
    &quot;hardware-dma-ring-rx&quot;: &quot;hardware-dma-ring-rx&quot;,
    &quot;hardware-dma-ring-rx-mini&quot;: &quot;hardware-dma-ring-rx-mini&quot;,
    &quot;hardware-dma-ring-rx-jumbo&quot;: &quot;hardware-dma-ring-rx-jumbo&quot;,
    &quot;hardware-dma-ring-tx&quot;: &quot;hardware-dma-ring-tx&quot;,
}

_DEB_CONFIG_PPPOE_OPTS = {
    &quot;user&quot;: &quot;user&quot;,
    &quot;password&quot;: &quot;password&quot;,
    &quot;provider&quot;: &quot;provider&quot;,
    &quot;pppoe_iface&quot;: &quot;pppoe_iface&quot;,
    &quot;noipdefault&quot;: &quot;noipdefault&quot;,
    &quot;usepeerdns&quot;: &quot;usepeerdns&quot;,
    &quot;defaultroute&quot;: &quot;defaultroute&quot;,
    &quot;holdoff&quot;: &quot;holdoff&quot;,
    &quot;maxfail&quot;: &quot;maxfail&quot;,
    &quot;hide-password&quot;: &quot;hide-password&quot;,
    &quot;lcp-echo-interval&quot;: &quot;lcp-echo-interval&quot;,
    &quot;lcp-echo-failure&quot;: &quot;lcp-echo-failure&quot;,
    &quot;connect&quot;: &quot;connect&quot;,
    &quot;noauth&quot;: &quot;noauth&quot;,
    &quot;persist&quot;: &quot;persist&quot;,
    &quot;mtu&quot;: &quot;mtu&quot;,
    &quot;noaccomp&quot;: &quot;noaccomp&quot;,
    &quot;linkname&quot;: &quot;linkname&quot;,
}

_DEB_ROUTES_FILE = &quot;/etc/network/routes&quot;
_DEB_NETWORK_FILE = &quot;/etc/network/interfaces&quot;
_DEB_NETWORK_DIR = &quot;/etc/network/interfaces.d/&quot;
_DEB_NETWORK_UP_DIR = &quot;/etc/network/if-up.d/&quot;
_DEB_NETWORK_DOWN_DIR = &quot;/etc/network/if-down.d/&quot;
_DEB_NETWORK_CONF_FILES = &quot;/etc/modprobe.d/&quot;
_DEB_NETWORKING_FILE = &quot;/etc/default/networking&quot;
_DEB_HOSTNAME_FILE = &quot;/etc/hostname&quot;
_DEB_RESOLV_FILE = &quot;/etc/resolv.conf&quot;
_DEB_PPP_DIR = &quot;/etc/ppp/peers/&quot;

_CONFIG_TRUE = [&quot;yes&quot;, &quot;on&quot;, &quot;true&quot;, &quot;1&quot;, True]
_CONFIG_FALSE = [&quot;no&quot;, &quot;off&quot;, &quot;false&quot;, &quot;0&quot;, False]
_IFACE_TYPES = [
    &quot;eth&quot;,
    &quot;bond&quot;,
    &quot;alias&quot;,
    &quot;clone&quot;,
    &quot;ipsec&quot;,
    &quot;dialup&quot;,
    &quot;bridge&quot;,
    &quot;slave&quot;,
    &quot;vlan&quot;,
    &quot;pppoe&quot;,
    &quot;source&quot;,
]


def _error_msg_iface(iface, option, expected):
    &quot;&quot;&quot;
    Build an appropriate error message from a given option and
    a list of expected values.
    &quot;&quot;&quot;
    msg = &quot;Invalid option -- Interface: {0}, Option: {1}, Expected: [{2}]&quot;
    return msg.format(iface, option, &quot;|&quot;.join(str(e) for e in expected))


def _error_msg_routes(iface, option, expected):
    &quot;&quot;&quot;
    Build an appropriate error message from a given option and
    a list of expected values.
    &quot;&quot;&quot;
    msg = &quot;Invalid option -- Route interface: {0}, Option: {1}, Expected: [{2}]&quot;
    return msg.format(iface, option, expected)


def _log_default_iface(iface, opt, value):
    log.info(
        &quot;Using default option -- Interface: %s Option: %s Value: %s&quot;, iface, opt, value
    )


def _error_msg_network(option, expected):
    &quot;&quot;&quot;
    Build an appropriate error message from a given option and
    a list of expected values.
    &quot;&quot;&quot;
    msg = &quot;Invalid network setting -- Setting: {0}, Expected: [{1}]&quot;
    return msg.format(option, &quot;|&quot;.join(str(e) for e in expected))


def _log_default_network(opt, value):
    log.info(&quot;Using existing setting -- Setting: %s Value: %s&quot;, opt, value)


def _raise_error_iface(iface, option, expected):
    &quot;&quot;&quot;
    Log and raise an error with a logical formatted message.
    &quot;&quot;&quot;
    msg = _error_msg_iface(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)


def _raise_error_network(option, expected):
    &quot;&quot;&quot;
    Log and raise an error with a logical formatted message.
    &quot;&quot;&quot;
    msg = _error_msg_network(option, expected)
    log.error(msg)
    raise AttributeError(msg)


def _raise_error_routes(iface, option, expected):
    &quot;&quot;&quot;
    Log and raise an error with a logical formatted message.
    &quot;&quot;&quot;
    msg = _error_msg_routes(iface, option, expected)
    log.error(msg)
    raise AttributeError(msg)


def _read_file(path):
    &quot;&quot;&quot;
    Reads and returns the contents of a text file
    &quot;&quot;&quot;
    try:
        with salt.utils.files.flopen(path, &quot;rb&quot;) as contents:
            return [
                salt.utils.stringutils.to_str(line) for line in contents.readlines()
            ]
    except OSError:
        return &quot;&quot;


def _parse_resolve():
    &quot;&quot;&quot;
    Parse /etc/resolv.conf
    &quot;&quot;&quot;
    return salt.utils.dns.parse_resolv(_DEB_RESOLV_FILE)


def _parse_domainname():
    &quot;&quot;&quot;
    Parse /etc/resolv.conf and return domainname
    &quot;&quot;&quot;
    return _parse_resolve().get(&quot;domain&quot;, &quot;&quot;)


def _parse_searchdomain():
    &quot;&quot;&quot;
    Parse /etc/resolv.conf and return searchdomain
    &quot;&quot;&quot;
    return _parse_resolve().get(&quot;search&quot;, &quot;&quot;)


def _parse_hostname():
    &quot;&quot;&quot;
    Parse /etc/hostname and return hostname
    &quot;&quot;&quot;
    contents = _read_file(_DEB_HOSTNAME_FILE)
    if contents:
        return contents[0].split(&quot;\n&quot;)[0]
    else:
        return &quot;&quot;


def _parse_current_network_settings():
    &quot;&quot;&quot;
    Parse /etc/default/networking and return current configuration
    &quot;&quot;&quot;
    opts = salt.utils.odict.OrderedDict()
    opts[&quot;networking&quot;] = &quot;&quot;

    if os.path.isfile(_DEB_NETWORKING_FILE):
        with salt.utils.files.fopen(_DEB_NETWORKING_FILE) as contents:
            for line in contents:
                salt.utils.stringutils.to_unicode(line)
                if line.startswith(&quot;#&quot;):
                    continue
                elif line.startswith(&quot;CONFIGURE_INTERFACES&quot;):
                    opts[&quot;networking&quot;] = line.split(&quot;=&quot;, 1)[1].strip()

    hostname = _parse_hostname()
    domainname = _parse_domainname()
    searchdomain = _parse_searchdomain()

    opts[&quot;hostname&quot;] = hostname
    opts[&quot;domainname&quot;] = domainname
    opts[&quot;searchdomain&quot;] = searchdomain
    return opts


# def __validator_func(value):
#    return (valid: True/False, (transformed) value, error message)


def __ipv4_quad(value):
    &quot;&quot;&quot;validate an IPv4 address&quot;&quot;&quot;
    return (salt.utils.validate.net.ipv4_addr(value), value, &quot;dotted IPv4 address&quot;)


def __ipv6(value):
    &quot;&quot;&quot;validate an IPv6 address&quot;&quot;&quot;
    return (salt.utils.validate.net.ipv6_addr(value), value, &quot;IPv6 address&quot;)


def __mac(value):
    &quot;&quot;&quot;validate a mac address&quot;&quot;&quot;
    return (salt.utils.validate.net.mac(value), value, &quot;MAC address&quot;)


def __anything(value):
    return (True, value, None)


def __int(value):
    &quot;&quot;&quot;validate an integer&quot;&quot;&quot;
    valid, _value = False, value
    try:
        _value = int(value)
        valid = True
    except ValueError:
        pass
    return (valid, _value, &quot;integer&quot;)


def __float(value):
    &quot;&quot;&quot;validate a float&quot;&quot;&quot;
    valid, _value = False, value
    try:
        _value = float(value)
        valid = True
    except ValueError:
        pass
    return (valid, _value, &quot;float&quot;)


def __ipv4_netmask(value):
    &quot;&quot;&quot;validate an IPv4 dotted quad or integer CIDR netmask&quot;&quot;&quot;
    valid, errmsg = False, &quot;dotted quad or integer CIDR (0-&gt;32)&quot;
    valid, value, _ = __int(value)
    if not (valid and 0 &lt;= value &lt;= 32):
        valid = salt.utils.validate.net.netmask(value)
    return (valid, value, errmsg)


def __ipv6_netmask(value):
    &quot;&quot;&quot;validate an IPv6 integer netmask&quot;&quot;&quot;
    valid, errmsg = False, &quot;IPv6 netmask (0-&gt;128)&quot;
    valid, value, _ = __int(value)
    valid = valid and 0 &lt;= value &lt;= 128
    return (valid, value, errmsg)


def __within2(value, within=None, errmsg=None, dtype=None):
    &quot;&quot;&quot;validate that a value is in ``within`` and optionally a ``dtype``&quot;&quot;&quot;
    valid, _value = False, value
    if dtype:
        try:
            _value = dtype(value)  # TODO: this is a bit loose when dtype is a class
            valid = _value in within
        except ValueError:
            pass
    else:
        valid = _value in within
    if errmsg is None:
        if dtype:
            typename = getattr(
                dtype,
                &quot;__name__&quot;,
                hasattr(dtype, &quot;__class__&quot;) and getattr(dtype.__class__, &quot;name&quot;, dtype),
            )
            errmsg = &quot;{} within '{}'&quot;.format(typename, within)
        else:
            errmsg = &quot;within '{}'&quot;.format(within)
    return (valid, _value, errmsg)


def __within(within=None, errmsg=None, dtype=None):
    return functools.partial(__within2, within=within, errmsg=errmsg, dtype=dtype)


def __space_delimited_list(value):
    &quot;&quot;&quot;validate that a value contains one or more space-delimited values&quot;&quot;&quot;
    if isinstance(value, str):
        value = value.strip().split()

    if hasattr(value, &quot;__iter__&quot;) and value != []:
        return (True, value, &quot;space-delimited string&quot;)
    else:
        return (
            False,
            value,
            &quot;{} is not a valid space-delimited value.\n&quot;.format(value),
        )


SALT_ATTR_TO_DEBIAN_ATTR_MAP = {
    &quot;dns&quot;: &quot;dns-nameservers&quot;,
    &quot;search&quot;: &quot;dns-search&quot;,
    &quot;hwaddr&quot;: &quot;hwaddress&quot;,  # TODO: this limits bootp functionality
    &quot;ipaddr&quot;: &quot;address&quot;,
    &quot;ipaddrs&quot;: &quot;addresses&quot;,
}


DEBIAN_ATTR_TO_SALT_ATTR_MAP = {v: k for (k, v) in SALT_ATTR_TO_DEBIAN_ATTR_MAP.items()}

# TODO
DEBIAN_ATTR_TO_SALT_ATTR_MAP[&quot;address&quot;] = &quot;address&quot;
DEBIAN_ATTR_TO_SALT_ATTR_MAP[&quot;hwaddress&quot;] = &quot;hwaddress&quot;

IPV4_VALID_PROTO = [&quot;bootp&quot;, &quot;dhcp&quot;, &quot;static&quot;, &quot;manual&quot;, &quot;loopback&quot;, &quot;ppp&quot;]

IPV4_ATTR_MAP = {
    &quot;proto&quot;: __within(IPV4_VALID_PROTO, dtype=str),
    # ipv4 static &amp; manual
    &quot;address&quot;: __ipv4_quad,
    &quot;addresses&quot;: __anything,
    &quot;netmask&quot;: __ipv4_netmask,
    &quot;broadcast&quot;: __ipv4_quad,
    &quot;metric&quot;: __int,
    &quot;gateway&quot;: __ipv4_quad,  # supports a colon-delimited list
    &quot;pointopoint&quot;: __ipv4_quad,
    &quot;hwaddress&quot;: __mac,
    &quot;mtu&quot;: __int,
    &quot;scope&quot;: __within([&quot;global&quot;, &quot;link&quot;, &quot;host&quot;], dtype=str),
    # dhcp
    &quot;hostname&quot;: __anything,
    &quot;leasehours&quot;: __int,
    &quot;leasetime&quot;: __int,
    &quot;vendor&quot;: __anything,
    &quot;client&quot;: __anything,
    # bootp
    &quot;bootfile&quot;: __anything,
    &quot;server&quot;: __ipv4_quad,
    &quot;hwaddr&quot;: __mac,
    # tunnel
    &quot;mode&quot;: __within([&quot;gre&quot;, &quot;GRE&quot;, &quot;ipip&quot;, &quot;IPIP&quot;, &quot;802.3ad&quot;], dtype=str),
    &quot;endpoint&quot;: __ipv4_quad,
    &quot;dstaddr&quot;: __ipv4_quad,
    &quot;local&quot;: __ipv4_quad,
    &quot;ttl&quot;: __int,
    # bond
    &quot;slaves&quot;: __anything,
    # ppp
    &quot;provider&quot;: __anything,
    &quot;unit&quot;: __int,
    &quot;options&quot;: __anything,
    # resolvconf
    &quot;dns-nameservers&quot;: __space_delimited_list,
    &quot;dns-search&quot;: __space_delimited_list,
    #
    &quot;vlan-raw-device&quot;: __anything,
    #
    &quot;network&quot;: __anything,  # i don't know what this is
    &quot;test&quot;: __anything,  # TODO
    &quot;enable_ipv4&quot;: __anything,  # TODO
    &quot;enable_ipv6&quot;: __anything,  # TODO
}


IPV6_VALID_PROTO = [&quot;auto&quot;, &quot;loopback&quot;, &quot;static&quot;, &quot;manual&quot;, &quot;dhcp&quot;, &quot;v4tunnel&quot;, &quot;6to4&quot;]

IPV6_ATTR_MAP = {
    &quot;proto&quot;: __within(IPV6_VALID_PROTO),
    # ipv6 static &amp; manual
    &quot;address&quot;: __ipv6,
    &quot;addresses&quot;: __anything,
    &quot;netmask&quot;: __ipv6_netmask,
    &quot;broadcast&quot;: __ipv6,
    &quot;gateway&quot;: __ipv6,  # supports a colon-delimited list
    &quot;hwaddress&quot;: __mac,
    &quot;mtu&quot;: __int,
    &quot;scope&quot;: __within([&quot;global&quot;, &quot;site&quot;, &quot;link&quot;, &quot;host&quot;], dtype=str),
    # inet6 auto
    &quot;privext&quot;: __within([0, 1, 2], dtype=int),
    &quot;dhcp&quot;: __within([0, 1], dtype=int),
    # inet6 static &amp; manual &amp; dhcp
    &quot;media&quot;: __anything,
    &quot;accept_ra&quot;: __within([0, 1, 2], dtype=int),
    &quot;autoconf&quot;: __within([0, 1], dtype=int),
    &quot;preferred-lifetime&quot;: __int,
    &quot;dad-attempts&quot;: __int,  # 0 to disable
    &quot;dad-interval&quot;: __float,
    # bond
    &quot;slaves&quot;: __anything,
    # tunnel
    &quot;mode&quot;: __within([&quot;gre&quot;, &quot;GRE&quot;, &quot;ipip&quot;, &quot;IPIP&quot;, &quot;802.3ad&quot;], dtype=str),
    &quot;endpoint&quot;: __ipv4_quad,
    &quot;local&quot;: __ipv4_quad,
    &quot;ttl&quot;: __int,
    # resolvconf
    &quot;dns-nameservers&quot;: __space_delimited_list,
    &quot;dns-search&quot;: __space_delimited_list,
    #
    &quot;vlan-raw-device&quot;: __anything,
    &quot;test&quot;: __anything,  # TODO
    &quot;enable_ipv4&quot;: __anything,  # TODO
    &quot;enable_ipv6&quot;: __anything,  # TODO
}


WIRELESS_ATTR_MAP = {
    &quot;wireless-essid&quot;: __anything,
    &quot;wireless-mode&quot;: __anything,  # TODO
    &quot;wpa-ap-scan&quot;: __within([0, 1, 2], dtype=int),  # TODO
    &quot;wpa-conf&quot;: __anything,
    &quot;wpa-driver&quot;: __anything,
    &quot;wpa-group&quot;: __anything,
    &quot;wpa-key-mgmt&quot;: __anything,
    &quot;wpa-pairwise&quot;: __anything,
    &quot;wpa-psk&quot;: __anything,
    &quot;wpa-proto&quot;: __anything,  # partial(__within,
    &quot;wpa-roam&quot;: __anything,
    &quot;wpa-ssid&quot;: __anything,  # TODO
}

ATTRMAPS = {
    &quot;inet&quot;: [IPV4_ATTR_MAP, WIRELESS_ATTR_MAP],
    &quot;inet6&quot;: [IPV6_ATTR_MAP, WIRELESS_ATTR_MAP],
}


def _validate_interface_option(attr, value, addrfam=&quot;inet&quot;):
    &quot;&quot;&quot;lookup the validation function for a [addrfam][attr] and
    return the results

    :param attr: attribute name
    :param value: raw setting value
    :param addrfam: address family (inet, inet6,
    &quot;&quot;&quot;
    valid, _value, errmsg = False, value, &quot;Unknown validator&quot;
    attrmaps = ATTRMAPS.get(addrfam, [])
    for attrmap in attrmaps:
        if attr in attrmap:
            validate_func = attrmap[attr]
            (valid, _value, errmsg) = validate_func(value)
            break
    return (valid, _value, errmsg)


def _attrmaps_contain_attr(attr):
    return attr in WIRELESS_ATTR_MAP or attr in IPV4_ATTR_MAP or attr in IPV6_ATTR_MAP


def _parse_interfaces(interface_files=None):
    &quot;&quot;&quot;
    Parse /etc/network/interfaces and return current configured interfaces
    &quot;&quot;&quot;
    if interface_files is None:
        interface_files = []
        # Add this later.
        if os.path.exists(_DEB_NETWORK_DIR):
            interface_files += [
                &quot;{}/{}&quot;.format(_DEB_NETWORK_DIR, dir)
                for dir in os.listdir(_DEB_NETWORK_DIR)
            ]

        if os.path.isfile(_DEB_NETWORK_FILE):
            interface_files.insert(0, _DEB_NETWORK_FILE)

    adapters = salt.utils.odict.OrderedDict()
    method = -1

    for interface_file in interface_files:
        with salt.utils.files.fopen(interface_file) as interfaces:
            # This ensures iface_dict exists, but does not ensure we're not reading a new interface.
            iface_dict = {}
            for line in interfaces:
                line = salt.utils.stringutils.to_unicode(line)
                # Identify the clauses by the first word of each line.
                # Go to the next line if the current line is a comment
                # or all spaces.
                if line.lstrip().startswith(&quot;#&quot;) or line.isspace():
                    continue
                # Parse the iface clause
                if line.startswith(&quot;iface&quot;):
                    sline = line.split()

                    if len(sline) != 4:
                        msg = &quot;Interface file malformed: {0}.&quot;
                        msg = msg.format(sline)
                        log.error(msg)
                        raise AttributeError(msg)

                    iface_name = sline[1]
                    addrfam = sline[2]
                    method = sline[3]

                    # Create item in dict, if not already there
                    if iface_name not in adapters:
                        adapters[iface_name] = salt.utils.odict.OrderedDict()

                    # Create item in dict, if not already there
                    if &quot;data&quot; not in adapters[iface_name]:
                        adapters[iface_name][&quot;data&quot;] = salt.utils.odict.OrderedDict()

                    if addrfam not in adapters[iface_name][&quot;data&quot;]:
                        adapters[iface_name][&quot;data&quot;][
                            addrfam
                        ] = salt.utils.odict.OrderedDict()

                    iface_dict = adapters[iface_name][&quot;data&quot;][addrfam]

                    iface_dict[&quot;addrfam&quot;] = addrfam
                    iface_dict[&quot;proto&quot;] = method
                    iface_dict[&quot;filename&quot;] = interface_file

                # Parse the detail clauses.
                elif line[0].isspace():
                    sline = line.split()

                    # conf file attr: dns-nameservers
                    # salt states.network attr: dns

                    attr, valuestr = line.rstrip().split(None, 1)
                    if _attrmaps_contain_attr(attr):
                        if &quot;-&quot; in attr:
                            attrname = attr.replace(&quot;-&quot;, &quot;_&quot;)
                        else:
                            attrname = attr
                        (valid, value, errmsg) = _validate_interface_option(
                            attr, valuestr, addrfam
                        )
                        if attrname == &quot;address&quot; and &quot;address&quot; in iface_dict:
                            if &quot;addresses&quot; not in iface_dict:
                                iface_dict[&quot;addresses&quot;] = []
                            iface_dict[&quot;addresses&quot;].append(value)
                        else:
                            iface_dict[attrname] = value

                    elif attr in _REV_ETHTOOL_CONFIG_OPTS:
                        if &quot;ethtool&quot; not in iface_dict:
                            iface_dict[&quot;ethtool&quot;] = salt.utils.odict.OrderedDict()
                        iface_dict[&quot;ethtool&quot;][attr] = valuestr

                    elif attr.startswith(&quot;bond&quot;):
                        opt = re.split(r&quot;[_-]&quot;, attr, maxsplit=1)[1]
                        if &quot;bonding&quot; not in iface_dict:
                            iface_dict[&quot;bonding&quot;] = salt.utils.odict.OrderedDict()
                        iface_dict[&quot;bonding&quot;][opt] = valuestr

                    elif attr.startswith(&quot;bridge&quot;):
                        opt = re.split(r&quot;[_-]&quot;, attr, maxsplit=1)[1]
                        if &quot;bridging&quot; not in iface_dict:
                            iface_dict[&quot;bridging&quot;] = salt.utils.odict.OrderedDict()
                        iface_dict[&quot;bridging&quot;][opt] = valuestr

                    elif attr in [
                        &quot;up&quot;,
                        &quot;pre-up&quot;,
                        &quot;post-up&quot;,
                        &quot;down&quot;,
                        &quot;pre-down&quot;,
                        &quot;post-down&quot;,
                    ]:
                        cmd = valuestr
                        cmd_key = &quot;{}_cmds&quot;.format(re.sub(&quot;-&quot;, &quot;_&quot;, attr))
                        if cmd_key not in iface_dict:
                            iface_dict[cmd_key] = []
                        iface_dict[cmd_key].append(cmd)

                elif line.startswith(&quot;auto&quot;):
                    for word in line.split()[1:]:
                        if word not in adapters:
                            adapters[word] = salt.utils.odict.OrderedDict()
                        adapters[word][&quot;enabled&quot;] = True

                elif line.startswith(&quot;allow-hotplug&quot;):
                    for word in line.split()[1:]:
                        if word not in adapters:
                            adapters[word] = salt.utils.odict.OrderedDict()
                        adapters[word][&quot;hotplug&quot;] = True

                elif line.startswith(&quot;source&quot;):
                    if &quot;source&quot; not in adapters:
                        adapters[&quot;source&quot;] = salt.utils.odict.OrderedDict()

                    # Create item in dict, if not already there
                    if &quot;data&quot; not in adapters[&quot;source&quot;]:
                        adapters[&quot;source&quot;][&quot;data&quot;] = salt.utils.odict.OrderedDict()
                        adapters[&quot;source&quot;][&quot;data&quot;][&quot;sources&quot;] = []
                    adapters[&quot;source&quot;][&quot;data&quot;][&quot;sources&quot;].append(line.split()[1])

    adapters = _filter_malformed_interfaces(adapters=adapters)
    return adapters


def _filter_malformed_interfaces(*, adapters):
    # Return a sorted list of the keys for bond, bridge and ethtool options to
    # ensure a consistent order
    for iface_name in list(adapters):
        if iface_name == &quot;source&quot;:
            continue
        if &quot;data&quot; not in adapters[iface_name]:
            msg = &quot;Interface file malformed for interface: {}.&quot;.format(iface_name)
            log.error(msg)
            adapters.pop(iface_name)
            continue
        for opt in [&quot;ethtool&quot;, &quot;bonding&quot;, &quot;bridging&quot;]:
            for inet in [&quot;inet&quot;, &quot;inet6&quot;]:
                if inet in adapters[iface_name][&quot;data&quot;]:
                    if opt in adapters[iface_name][&quot;data&quot;][inet]:
                        opt_keys = sorted(
                            adapters[iface_name][&quot;data&quot;][inet][opt].keys()
                        )
                        adapters[iface_name][&quot;data&quot;][inet][opt + &quot;_keys&quot;] = opt_keys
    return adapters


def _parse_ethtool_opts(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for ETHTOOLS_OPTS
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    config = {}

    if &quot;autoneg&quot; in opts:
        if opts[&quot;autoneg&quot;] in _CONFIG_TRUE:
            config.update({&quot;autoneg&quot;: &quot;on&quot;})
        elif opts[&quot;autoneg&quot;] in _CONFIG_FALSE:
            config.update({&quot;autoneg&quot;: &quot;off&quot;})
        else:
            _raise_error_iface(iface, &quot;autoneg&quot;, _CONFIG_TRUE + _CONFIG_FALSE)

    if &quot;duplex&quot; in opts:
        valid = [&quot;full&quot;, &quot;half&quot;]
        if opts[&quot;duplex&quot;] in valid:
            config.update({&quot;duplex&quot;: opts[&quot;duplex&quot;]})
        else:
            _raise_error_iface(iface, &quot;duplex&quot;, valid)

    if &quot;speed&quot; in opts:
        valid = [&quot;10&quot;, &quot;100&quot;, &quot;1000&quot;, &quot;10000&quot;]
        if str(opts[&quot;speed&quot;]) in valid:
            config.update({&quot;speed&quot;: opts[&quot;speed&quot;]})
        else:
            _raise_error_iface(iface, opts[&quot;speed&quot;], valid)

    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for option in (&quot;rx&quot;, &quot;tx&quot;, &quot;sg&quot;, &quot;tso&quot;, &quot;ufo&quot;, &quot;gso&quot;, &quot;gro&quot;, &quot;lro&quot;):
        if option in opts:
            if opts[option] in _CONFIG_TRUE:
                config.update({option: &quot;on&quot;})
            elif opts[option] in _CONFIG_FALSE:
                config.update({option: &quot;off&quot;})
            else:
                _raise_error_iface(iface, option, valid)

    return config


def _parse_ethtool_pppoe_opts(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for ETHTOOLS_PPPOE_OPTS
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    config = {}

    for opt in _DEB_CONFIG_PPPOE_OPTS:
        if opt in opts:
            config[opt] = opts[opt]

    if &quot;provider&quot; in opts and not opts[&quot;provider&quot;]:
        _raise_error_iface(iface, &quot;provider&quot;, _CONFIG_TRUE + _CONFIG_FALSE)

    valid = _CONFIG_TRUE + _CONFIG_FALSE
    for option in (
        &quot;noipdefault&quot;,
        &quot;usepeerdns&quot;,
        &quot;defaultroute&quot;,
        &quot;hide-password&quot;,
        &quot;noauth&quot;,
        &quot;persist&quot;,
        &quot;noaccomp&quot;,
    ):
        if option in opts:
            if opts[option] in _CONFIG_TRUE:
                config.update({option: &quot;True&quot;})
            elif opts[option] in _CONFIG_FALSE:
                config.update({option: &quot;False&quot;})
            else:
                _raise_error_iface(iface, option, valid)

    return config


def _parse_settings_bond(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for requested
    operation. If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;

    bond_def = {
        # 803.ad aggregation selection logic
        # 0 for stable (default)
        # 1 for bandwidth
        # 2 for count
        &quot;ad_select&quot;: &quot;0&quot;,
        # Max number of transmit queues (default = 16)
        &quot;tx_queues&quot;: &quot;16&quot;,
        # Link monitoring in milliseconds. Most NICs support this
        &quot;miimon&quot;: &quot;100&quot;,
        # ARP interval in milliseconds
        &quot;arp_interval&quot;: &quot;250&quot;,
        # Delay before considering link down in milliseconds (miimon * 2)
        &quot;downdelay&quot;: &quot;200&quot;,
        # lacp_rate 0: Slow - every 30 seconds
        # lacp_rate 1: Fast - every 1 second
        &quot;lacp_rate&quot;: &quot;0&quot;,
        # Max bonds for this driver
        &quot;max_bonds&quot;: &quot;1&quot;,
        # Specifies the time, in milliseconds, to wait before
        # enabling a slave after a link recovery has been
        # detected. Only used with miimon.
        &quot;updelay&quot;: &quot;0&quot;,
        # Used with miimon.
        # On: driver sends mii
        # Off: ethtool sends mii
        &quot;use_carrier&quot;: &quot;on&quot;,
        # Default. Don't change unless you know what you are doing.
        &quot;xmit_hash_policy&quot;: &quot;layer2&quot;,
    }

    if opts[&quot;mode&quot;] in [&quot;balance-rr&quot;, &quot;0&quot;]:
        log.info(&quot;Device: %s Bonding Mode: load balancing (round-robin)&quot;, iface)
        return _parse_settings_bond_0(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;active-backup&quot;, &quot;1&quot;]:
        log.info(&quot;Device: %s Bonding Mode: fault-tolerance (active-backup)&quot;, iface)
        return _parse_settings_bond_1(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;balance-xor&quot;, &quot;2&quot;]:
        log.info(&quot;Device: %s Bonding Mode: load balancing (xor)&quot;, iface)
        return _parse_settings_bond_2(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;broadcast&quot;, &quot;3&quot;]:
        log.info(&quot;Device: %s Bonding Mode: fault-tolerance (broadcast)&quot;, iface)
        return _parse_settings_bond_3(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;802.3ad&quot;, &quot;4&quot;]:
        log.info(
            &quot;Device: %s Bonding Mode: IEEE 802.3ad Dynamic link aggregation&quot;, iface
        )
        return _parse_settings_bond_4(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;balance-tlb&quot;, &quot;5&quot;]:
        log.info(&quot;Device: %s Bonding Mode: transmit load balancing&quot;, iface)
        return _parse_settings_bond_5(opts, iface, bond_def)
    elif opts[&quot;mode&quot;] in [&quot;balance-alb&quot;, &quot;6&quot;]:
        log.info(&quot;Device: %s Bonding Mode: adaptive load balancing&quot;, iface)
        return _parse_settings_bond_6(opts, iface, bond_def)
    else:
        valid = [
            &quot;0&quot;,
            &quot;1&quot;,
            &quot;2&quot;,
            &quot;3&quot;,
            &quot;4&quot;,
            &quot;5&quot;,
            &quot;6&quot;,
            &quot;balance-rr&quot;,
            &quot;active-backup&quot;,
            &quot;balance-xor&quot;,
            &quot;broadcast&quot;,
            &quot;802.3ad&quot;,
            &quot;balance-tlb&quot;,
            &quot;balance-alb&quot;,
        ]
        _raise_error_iface(iface, &quot;mode&quot;, valid)


def _parse_settings_bond_0(opts, iface, bond_def):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond0.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;0&quot;}

    # ARP targets in n.n.n.n form
    valid = [&quot;list of ips (up to 16)&quot;]
    if &quot;arp_ip_target&quot; in opts:
        if isinstance(opts[&quot;arp_ip_target&quot;], list):
            if 1 &lt;= len(opts[&quot;arp_ip_target&quot;]) &lt;= 16:
                bond.update({&quot;arp_ip_target&quot;: &quot;&quot;})
                for ip in opts[&quot;arp_ip_target&quot;]:  # pylint: disable=C0103
                    if len(bond[&quot;arp_ip_target&quot;]) &gt; 0:
                        bond[&quot;arp_ip_target&quot;] = bond[&quot;arp_ip_target&quot;] + &quot;,&quot; + ip
                    else:
                        bond[&quot;arp_ip_target&quot;] = ip
            else:
                _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
        else:
            _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
    else:
        _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)

    if &quot;arp_interval&quot; in opts:
        try:
            int(opts[&quot;arp_interval&quot;])
            bond.update({&quot;arp_interval&quot;: opts[&quot;arp_interval&quot;]})
        except ValueError:
            _raise_error_iface(iface, &quot;arp_interval&quot;, [&quot;integer&quot;])
    else:
        _log_default_iface(iface, &quot;arp_interval&quot;, bond_def[&quot;arp_interval&quot;])
        bond.update({&quot;arp_interval&quot;: bond_def[&quot;arp_interval&quot;]})

    return bond


def _parse_settings_bond_1(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond1.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;1&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;primary&quot; in opts:
        bond.update({&quot;primary&quot;: opts[&quot;primary&quot;]})

    if not (__grains__[&quot;os&quot;] == &quot;Ubuntu&quot; and __grains__[&quot;osrelease_info&quot;][0] &gt;= 16):
        if &quot;use_carrier&quot; in opts:
            if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
                bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
            elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
                bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
            else:
                valid = _CONFIG_TRUE + _CONFIG_FALSE
                _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
        else:
            _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
            bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    return bond


def _parse_settings_bond_2(opts, iface, bond_def):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond2.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;

    bond = {&quot;mode&quot;: &quot;2&quot;}

    valid = [&quot;list of ips (up to 16)&quot;]
    if &quot;arp_ip_target&quot; in opts:
        if isinstance(opts[&quot;arp_ip_target&quot;], list):
            if 1 &lt;= len(opts[&quot;arp_ip_target&quot;]) &lt;= 16:
                bond.update({&quot;arp_ip_target&quot;: &quot;&quot;})
                for ip in opts[&quot;arp_ip_target&quot;]:  # pylint: disable=C0103
                    if len(bond[&quot;arp_ip_target&quot;]) &gt; 0:
                        bond[&quot;arp_ip_target&quot;] = bond[&quot;arp_ip_target&quot;] + &quot;,&quot; + ip
                    else:
                        bond[&quot;arp_ip_target&quot;] = ip
            else:
                _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
        else:
            _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)
    else:
        _raise_error_iface(iface, &quot;arp_ip_target&quot;, valid)

    if &quot;arp_interval&quot; in opts:
        try:
            int(opts[&quot;arp_interval&quot;])
            bond.update({&quot;arp_interval&quot;: opts[&quot;arp_interval&quot;]})
        except ValueError:
            _raise_error_iface(iface, &quot;arp_interval&quot;, [&quot;integer&quot;])
    else:
        _log_default_iface(iface, &quot;arp_interval&quot;, bond_def[&quot;arp_interval&quot;])
        bond.update({&quot;arp_interval&quot;: bond_def[&quot;arp_interval&quot;]})

    if &quot;hashing-algorithm&quot; in opts:
        valid = [&quot;layer2&quot;, &quot;layer2+3&quot;, &quot;layer3+4&quot;]
        if opts[&quot;hashing-algorithm&quot;] in valid:
            bond.update({&quot;xmit_hash_policy&quot;: opts[&quot;hashing-algorithm&quot;]})
        else:
            _raise_error_iface(iface, &quot;hashing-algorithm&quot;, valid)

    return bond


def _parse_settings_bond_3(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond3.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;3&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    return bond


def _parse_settings_bond_4(opts, iface, bond_def):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond4.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;

    bond = {&quot;mode&quot;: &quot;4&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;, &quot;lacp_rate&quot;, &quot;ad_select&quot;]:
        if binding in opts:
            if binding == &quot;lacp_rate&quot;:
                if opts[binding] == &quot;fast&quot;:
                    opts.update({binding: &quot;1&quot;})
                if opts[binding] == &quot;slow&quot;:
                    opts.update({binding: &quot;0&quot;})
                valid = [&quot;fast&quot;, &quot;1&quot;, &quot;slow&quot;, &quot;0&quot;]
            else:
                valid = [&quot;integer&quot;]
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, valid)
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    if &quot;hashing-algorithm&quot; in opts:
        valid = [&quot;layer2&quot;, &quot;layer2+3&quot;, &quot;layer3+4&quot;]
        if opts[&quot;hashing-algorithm&quot;] in valid:
            bond.update({&quot;xmit_hash_policy&quot;: opts[&quot;hashing-algorithm&quot;]})
        else:
            _raise_error_iface(iface, &quot;hashing-algorithm&quot;, valid)

    return bond


def _parse_settings_bond_5(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond5.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;5&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    if &quot;primary&quot; in opts:
        bond.update({&quot;primary&quot;: opts[&quot;primary&quot;]})

    return bond


def _parse_settings_bond_6(opts, iface, bond_def):

    &quot;&quot;&quot;
    Filters given options and outputs valid settings for bond6.
    If an option has a value that is not expected, this
    function will log what the Interface, Setting and what it was
    expecting.
    &quot;&quot;&quot;
    bond = {&quot;mode&quot;: &quot;6&quot;}

    for binding in [&quot;miimon&quot;, &quot;downdelay&quot;, &quot;updelay&quot;]:
        if binding in opts:
            try:
                int(opts[binding])
                bond.update({binding: opts[binding]})
            except ValueError:
                _raise_error_iface(iface, binding, [&quot;integer&quot;])
        else:
            _log_default_iface(iface, binding, bond_def[binding])
            bond.update({binding: bond_def[binding]})

    if &quot;use_carrier&quot; in opts:
        if opts[&quot;use_carrier&quot;] in _CONFIG_TRUE:
            bond.update({&quot;use_carrier&quot;: &quot;1&quot;})
        elif opts[&quot;use_carrier&quot;] in _CONFIG_FALSE:
            bond.update({&quot;use_carrier&quot;: &quot;0&quot;})
        else:
            valid = _CONFIG_TRUE + _CONFIG_FALSE
            _raise_error_iface(iface, &quot;use_carrier&quot;, valid)
    else:
        _log_default_iface(iface, &quot;use_carrier&quot;, bond_def[&quot;use_carrier&quot;])
        bond.update({&quot;use_carrier&quot;: bond_def[&quot;use_carrier&quot;]})

    if &quot;primary&quot; in opts:
        bond.update({&quot;primary&quot;: opts[&quot;primary&quot;]})

    return bond


def _parse_bridge_opts(opts, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for BRIDGING_OPTS
    If an option has a value that is not expected, this
    function will log the Interface, Setting and what was expected.
    &quot;&quot;&quot;
    config = {}

    if &quot;ports&quot; in opts:
        if isinstance(opts[&quot;ports&quot;], list):
            opts[&quot;ports&quot;] = &quot; &quot;.join(opts[&quot;ports&quot;])
        config.update({&quot;ports&quot;: opts[&quot;ports&quot;]})

    for opt in [&quot;ageing&quot;, &quot;fd&quot;, &quot;gcint&quot;, &quot;hello&quot;, &quot;maxage&quot;]:
        if opt in opts:
            try:
                float(opts[opt])
                config.update({opt: opts[opt]})
            except ValueError:
                _raise_error_iface(iface, opt, [&quot;float&quot;])

    for opt in [&quot;bridgeprio&quot;, &quot;maxwait&quot;]:
        if opt in opts:
            if isinstance(opts[opt], int):
                config.update({opt: opts[opt]})
            else:
                _raise_error_iface(iface, opt, [&quot;integer&quot;])

    if &quot;hw&quot; in opts:
        # match 12 hex digits with either : or - as separators between pairs
        if re.match(
            &quot;[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$&quot;, opts[&quot;hw&quot;].lower()
        ):
            config.update({&quot;hw&quot;: opts[&quot;hw&quot;]})
        else:
            _raise_error_iface(iface, &quot;hw&quot;, [&quot;valid MAC address&quot;])

    for opt in [&quot;pathcost&quot;, &quot;portprio&quot;]:
        if opt in opts:
            try:
                port, cost_or_prio = opts[opt].split()
                int(cost_or_prio)
                config.update({opt: &quot;{} {}&quot;.format(port, cost_or_prio)})
            except ValueError:
                _raise_error_iface(iface, opt, [&quot;interface integer&quot;])

    if &quot;stp&quot; in opts:
        if opts[&quot;stp&quot;] in _CONFIG_TRUE:
            config.update({&quot;stp&quot;: &quot;on&quot;})
        elif opts[&quot;stp&quot;] in _CONFIG_FALSE:
            config.update({&quot;stp&quot;: &quot;off&quot;})
        else:
            _raise_error_iface(iface, &quot;stp&quot;, _CONFIG_TRUE + _CONFIG_FALSE)

    if &quot;waitport&quot; in opts:
        if isinstance(opts[&quot;waitport&quot;], int):
            config.update({&quot;waitport&quot;: opts[&quot;waitport&quot;]})
        else:
            values = opts[&quot;waitport&quot;].split()
            waitport_time = values.pop(0)
            if waitport_time.isdigit() and values:
                config.update(
                    {&quot;waitport&quot;: &quot;{} {}&quot;.format(waitport_time, &quot; &quot;.join(values))}
                )
            else:
                _raise_error_iface(iface, opt, [&quot;integer [interfaces]&quot;])

    return config


def _parse_settings_eth(opts, iface_type, enabled, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for a
    network interface.
    &quot;&quot;&quot;
    adapters = salt.utils.odict.OrderedDict()
    adapters[iface] = salt.utils.odict.OrderedDict()

    adapters[iface][&quot;type&quot;] = iface_type
<A NAME="1"></A>
    adapters[iface][&quot;data&quot;] = salt.utils.odict.OrderedDict()
    iface_data = adapters[iface][&quot;data&quot;]
    iface_data<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match161671-0.html#1',2,'match161671-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;inet&quot;] = salt.utils.odict.OrderedDict()
    iface_data[&quot;inet6&quot;] = salt.utils.odict.OrderedDict(</B></FONT>)

    if enabled:
        adapters[iface][&quot;enabled&quot;] = True

    if opts.get(&quot;hotplug&quot;, False):
        adapters[iface][&quot;hotplug&quot;] = True

    if opts.get(&quot;enable_ipv6&quot;, None) and opts.get(&quot;iface_type&quot;, &quot;&quot;) == &quot;vlan&quot;:
        iface_data[&quot;inet6&quot;][&quot;vlan_raw_device&quot;] = re.sub(r&quot;\.\d*&quot;, &quot;&quot;, iface)

    for addrfam in [&quot;inet&quot;, &quot;inet6&quot;]:
        if iface_type not in [&quot;bridge&quot;]:
            tmp_ethtool = _parse_ethtool_opts(opts, iface)
            if tmp_ethtool:
                ethtool = {}
                for item in tmp_ethtool:
                    ethtool[_ETHTOOL_CONFIG_OPTS[item]] = tmp_ethtool[item]

                iface_data[addrfam][&quot;ethtool&quot;] = ethtool
                # return a list of sorted keys to ensure consistent order
                iface_data[addrfam][&quot;ethtool_keys&quot;] = sorted(ethtool)

        if iface_type == &quot;bridge&quot;:
            bridging = _parse_bridge_opts(opts, iface)
            if bridging:
                iface_data[addrfam][&quot;bridging&quot;] = bridging
                iface_data[addrfam][&quot;bridging_keys&quot;] = sorted(bridging)
                iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;bond&quot;:
            bonding = _parse_settings_bond(opts, iface)
            if bonding:
                iface_data[addrfam][&quot;bonding&quot;] = bonding
                iface_data[addrfam][&quot;bonding&quot;][&quot;slaves&quot;] = opts[&quot;slaves&quot;]
                iface_data[addrfam][&quot;bonding_keys&quot;] = sorted(bonding)
                iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;slave&quot;:
            adapters[iface][&quot;master&quot;] = opts[&quot;master&quot;]

            opts[&quot;proto&quot;] = &quot;manual&quot;
            iface_data[addrfam][&quot;master&quot;] = adapters[iface][&quot;master&quot;]
            iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;vlan&quot;:
            iface_data[addrfam][&quot;vlan_raw_device&quot;] = re.sub(r&quot;\.\d*&quot;, &quot;&quot;, iface)
            iface_data[addrfam][&quot;addrfam&quot;] = addrfam

        elif iface_type == &quot;pppoe&quot;:
            tmp_ethtool = _parse_ethtool_pppoe_opts(opts, iface)
            if tmp_ethtool:
                for item in tmp_ethtool:
                    adapters[iface][&quot;data&quot;][addrfam][
                        _DEB_CONFIG_PPPOE_OPTS[item]
                    ] = tmp_ethtool[item]
            iface_data[addrfam][&quot;addrfam&quot;] = addrfam

    opts.pop(&quot;mode&quot;, None)

    for opt, val in opts.items():
        inet = None
        if opt.startswith(&quot;ipv4&quot;):
            opt = opt[4:]
            inet = &quot;inet&quot;
            iface_data[&quot;inet&quot;][&quot;addrfam&quot;] = &quot;inet&quot;
        elif opt.startswith(&quot;ipv6&quot;):
            iface_data[&quot;inet6&quot;][&quot;addrfam&quot;] = &quot;inet6&quot;
            opt = opt[4:]
            inet = &quot;inet6&quot;
        elif opt in [
            &quot;ipaddr&quot;,
            &quot;address&quot;,
            &quot;ipaddresses&quot;,
            &quot;addresses&quot;,
            &quot;gateway&quot;,
            &quot;proto&quot;,
        ]:
            iface_data[&quot;inet&quot;][&quot;addrfam&quot;] = &quot;inet&quot;
            inet = &quot;inet&quot;

        _opt = SALT_ATTR_TO_DEBIAN_ATTR_MAP.get(opt, opt)
        _debopt = _opt.replace(&quot;-&quot;, &quot;_&quot;)

        for addrfam in [&quot;inet&quot;, &quot;inet6&quot;]:
            (valid, value, errmsg) = _validate_interface_option(
                _opt, val, addrfam=addrfam
            )
            if not valid:
                continue
            if inet is None and _debopt not in iface_data[addrfam]:
                iface_data[addrfam][_debopt] = value
            elif inet == addrfam:
                iface_data[addrfam][_debopt] = value

    for opt in [
        &quot;up_cmds&quot;,
        &quot;pre_up_cmds&quot;,
        &quot;post_up_cmds&quot;,
        &quot;down_cmds&quot;,
        &quot;pre_down_cmds&quot;,
        &quot;post_down_cmds&quot;,
    ]:
        if opt in opts:
            iface_data[&quot;inet&quot;][opt] = opts[opt]
            iface_data[&quot;inet6&quot;][opt] = opts[opt]

    # Remove incomplete/disabled inet blocks
    for (addrfam, opt) in [(&quot;inet&quot;, &quot;enable_ipv4&quot;), (&quot;inet6&quot;, &quot;enable_ipv6&quot;)]:
        if opts.get(opt, None) is False:
            iface_data.pop(addrfam)
        elif iface_data[addrfam].get(&quot;addrfam&quot;, &quot;&quot;) != addrfam:
            iface_data.pop(addrfam)

    return adapters


def _parse_settings_source(opts, iface_type, enabled, iface):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for a
    network interface.
    &quot;&quot;&quot;
    adapters = salt.utils.odict.OrderedDict()
    adapters[iface] = salt.utils.odict.OrderedDict()

    adapters[iface][&quot;type&quot;] = iface_type

    adapters[iface][&quot;data&quot;] = salt.utils.odict.OrderedDict()
    iface_data = adapters[iface][&quot;data&quot;]
    iface_data[&quot;sources&quot;] = [opts[&quot;source&quot;]]

    return adapters


def _parse_network_settings(opts, current):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for
    the global network settings file.
    &quot;&quot;&quot;
    # Normalize keys
    opts = {k.lower(): v for (k, v) in opts.items()}
    current = {k.lower(): v for (k, v) in current.items()}
    result = {}

    valid = _CONFIG_TRUE + _CONFIG_FALSE
    if &quot;enabled&quot; not in opts:
        try:
            opts[&quot;networking&quot;] = current[&quot;networking&quot;]
            _log_default_network(&quot;networking&quot;, current[&quot;networking&quot;])
        except ValueError:
            _raise_error_network(&quot;networking&quot;, valid)
    else:
        opts[&quot;networking&quot;] = opts[&quot;enabled&quot;]

    if opts[&quot;networking&quot;] in valid:
        if opts[&quot;networking&quot;] in _CONFIG_TRUE:
            result[&quot;networking&quot;] = &quot;yes&quot;
        elif opts[&quot;networking&quot;] in _CONFIG_FALSE:
            result[&quot;networking&quot;] = &quot;no&quot;
    else:
        _raise_error_network(&quot;networking&quot;, valid)

    if &quot;hostname&quot; not in opts:
        try:
            opts[&quot;hostname&quot;] = current[&quot;hostname&quot;]
            _log_default_network(&quot;hostname&quot;, current[&quot;hostname&quot;])
        except ValueError:
            _raise_error_network(&quot;hostname&quot;, [&quot;server1.example.com&quot;])

    if opts[&quot;hostname&quot;]:
        result[&quot;hostname&quot;] = opts[&quot;hostname&quot;]
    else:
        _raise_error_network(&quot;hostname&quot;, [&quot;server1.example.com&quot;])

    if &quot;search&quot; in opts:
        result[&quot;search&quot;] = opts[&quot;search&quot;]

    return result


def _parse_routes(iface, opts):
    &quot;&quot;&quot;
    Filters given options and outputs valid settings for
    the route settings file.
    &quot;&quot;&quot;
    # Normalize keys
    opts = {k.lower(): v for (k, v) in opts.items()}
    result = {}
    if &quot;routes&quot; not in opts:
        _raise_error_routes(iface, &quot;routes&quot;, &quot;List of routes&quot;)

    for opt in opts:
        result[opt] = opts[opt]

    return result


def _write_file(iface, data, folder, pattern):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    filename = os.path.join(folder, pattern.format(iface))
    if not os.path.exists(folder):
        msg = &quot;{0} cannot be written. {1} does not exist&quot;
        msg = msg.format(filename, folder)
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(data))
    return filename


def _write_file_routes(iface, data, folder, pattern):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    # ifup / ifdown is executing given folder via run-parts.
    # according to run-parts man-page, only filenames with this pattern are
    # executed: (^[a-zA-Z0-9_-]+$)

    # In order to make the routes file work for vlan interfaces
    # (default would have been in example /etc/network/if-up.d/route-bond0.12)
    # these dots in the iface name need to be replaced by underscores, so it
    # can be executed by run-parts
    iface = iface.replace(&quot;.&quot;, &quot;_&quot;)

    filename = os.path.join(folder, pattern.format(iface))
    if not os.path.exists(folder):
        msg = &quot;{0} cannot be written. {1} does not exist&quot;
        msg = msg.format(filename, folder)
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(data))

    __salt__[&quot;file.set_mode&quot;](filename, &quot;0755&quot;)
    return filename


def _write_file_network(data, filename, create=False):
    &quot;&quot;&quot;
    Writes a file to disk
    If file does not exist, only create if create
    argument is True
    &quot;&quot;&quot;
    if not os.path.exists(filename) and not create:
        msg = &quot;{0} cannot be written. {0} does not exist and create is setto False&quot;.format(
            filename
        )
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(data))


def _read_temp(data):
    &quot;&quot;&quot;
    Return what would be written to disk
    &quot;&quot;&quot;
    tout = io.StringIO()
    tout.write(data)
    tout.seek(0)
    output = tout.readlines()
    tout.close()

    return output


def _read_temp_ifaces(iface, data):
    &quot;&quot;&quot;
    Return what would be written to disk for interfaces
    &quot;&quot;&quot;
    try:
        template = JINJA.get_template(&quot;debian_eth.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template debian_eth.jinja&quot;)
        return &quot;&quot;

    ifcfg = template.render({&quot;name&quot;: iface, &quot;data&quot;: data})
    # Return as an array so the difflib works
    return [item + &quot;\n&quot; for item in ifcfg.split(&quot;\n&quot;)]


def _write_file_ifaces(iface, data, **settings):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    try:
        eth_template = JINJA.get_template(&quot;debian_eth.jinja&quot;)
        source_template = JINJA.get_template(&quot;debian_source.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template debian_eth.jinja&quot;)
        return &quot;&quot;

    # Read /etc/network/interfaces into a dict
    adapters = _parse_interfaces()
    # Apply supplied settings over on-disk settings
    adapters[iface] = data
<A NAME="0"></A>
    ifcfg = &quot;&quot;
    for adapter in adapters:
        <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match161671-0.html#0',2,'match161671-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if &quot;type&quot; in adapters[adapter] and adapters[adapter][&quot;type&quot;] == &quot;source&quot;:
            tmp = source_template.render({&quot;name&quot;: adapter, &quot;data&quot;: adapters[adapter]})
        else:
            tmp = eth_template.render(</B></FONT>{&quot;name&quot;: adapter, &quot;data&quot;: adapters[adapter]})
        ifcfg = ifcfg + tmp
        if adapter == iface:
            saved_ifcfg = tmp

    _SEPARATE_FILE = False
    if &quot;filename&quot; in settings:
        if not settings[&quot;filename&quot;].startswith(&quot;/&quot;):
            filename = &quot;{}/{}&quot;.format(_DEB_NETWORK_DIR, settings[&quot;filename&quot;])
        else:
            filename = settings[&quot;filename&quot;]
        _SEPARATE_FILE = True
    else:
        if &quot;filename&quot; in adapters[adapter][&quot;data&quot;]:
            filename = adapters[adapter][&quot;data&quot;]
        else:
            filename = _DEB_NETWORK_FILE

    if not os.path.exists(os.path.dirname(filename)):
        msg = &quot;{0} cannot be written.&quot;
        msg = msg.format(os.path.dirname(filename))
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.flopen(filename, &quot;w&quot;) as fout:
        if _SEPARATE_FILE:
            fout.write(salt.utils.stringutils.to_str(saved_ifcfg))
        else:
            fout.write(salt.utils.stringutils.to_str(ifcfg))

    # Return as an array so the difflib works
    return saved_ifcfg.split(&quot;\n&quot;)


def _write_file_ppp_ifaces(iface, data):
    &quot;&quot;&quot;
    Writes a file to disk
    &quot;&quot;&quot;
    try:
        template = JINJA.get_template(&quot;debian_ppp_eth.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template debian_ppp_eth.jinja&quot;)
        return &quot;&quot;

    adapters = _parse_interfaces()
    adapters[iface] = data

    ifcfg = &quot;&quot;
    tmp = template.render({&quot;data&quot;: adapters[iface]})
    ifcfg = tmp + ifcfg

    filename = _DEB_PPP_DIR + &quot;/&quot; + adapters[iface][&quot;data&quot;][&quot;inet&quot;][&quot;provider&quot;]
    if not os.path.exists(os.path.dirname(filename)):
        msg = &quot;{0} cannot be written.&quot;
        msg = msg.format(os.path.dirname(filename))
        log.error(msg)
        raise AttributeError(msg)
    with salt.utils.files.fopen(filename, &quot;w&quot;) as fout:
        fout.write(salt.utils.stringutils.to_str(ifcfg))

    # Return as an array so the difflib works
    return filename


def build_bond(iface, **settings):
    &quot;&quot;&quot;
    Create a bond script in /etc/modprobe.d with the passed settings
    and load the bonding kernel module.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_bond bond0 mode=balance-alb
    &quot;&quot;&quot;
    deb_major = __grains__[&quot;osrelease&quot;][:1]

    opts = _parse_settings_bond(settings, iface)
    try:
        template = JINJA.get_template(&quot;conf.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template conf.jinja&quot;)
        return &quot;&quot;
    data = template.render({&quot;name&quot;: iface, &quot;bonding&quot;: opts})

    if &quot;test&quot; in settings and settings[&quot;test&quot;]:
        return _read_temp(data)

    _write_file(iface, data, _DEB_NETWORK_CONF_FILES, &quot;{}.conf&quot;.format(iface))
    path = os.path.join(_DEB_NETWORK_CONF_FILES, &quot;{}.conf&quot;.format(iface))
    if deb_major == &quot;5&quot;:
        for line_type in (&quot;alias&quot;, &quot;options&quot;):
            cmd = [
                &quot;sed&quot;,
                &quot;-i&quot;,
                &quot;-e&quot;,
                r&quot;/^{}\s{}.*/d&quot;.format(line_type, iface),
                &quot;/etc/modprobe.conf&quot;,
            ]
            __salt__[&quot;cmd.run&quot;](cmd, python_shell=False)
        __salt__[&quot;file.append&quot;](&quot;/etc/modprobe.conf&quot;, path)

    # Load kernel module
    __salt__[&quot;kmod.load&quot;](&quot;bonding&quot;)

    # install ifenslave
    __salt__[&quot;pkg.install&quot;](&quot;ifenslave&quot;)

    return _read_file(path)


def build_interface(iface, iface_type, enabled, **settings):
    &quot;&quot;&quot;
    Build an interface script for a network interface.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_interface eth0 eth &lt;settings&gt;
    &quot;&quot;&quot;

    iface_type = iface_type.lower()

    if iface_type not in _IFACE_TYPES:
        _raise_error_iface(iface, iface_type, _IFACE_TYPES)

    if iface_type == &quot;slave&quot;:
        settings[&quot;slave&quot;] = &quot;yes&quot;
        if &quot;master&quot; not in settings:
            msg = &quot;master is a required setting for slave interfaces&quot;
            log.error(msg)
            raise AttributeError(msg)

    elif iface_type == &quot;vlan&quot;:
        settings[&quot;vlan&quot;] = &quot;yes&quot;
        __salt__[&quot;pkg.install&quot;](&quot;vlan&quot;)

    elif iface_type == &quot;pppoe&quot;:
        settings[&quot;pppoe&quot;] = &quot;yes&quot;
        if not __salt__[&quot;pkg.version&quot;](&quot;ppp&quot;):
            inst = __salt__[&quot;pkg.install&quot;](&quot;ppp&quot;)

    elif iface_type == &quot;bond&quot;:
        if &quot;slaves&quot; not in settings:
            msg = &quot;slaves is a required setting for bond interfaces&quot;
            log.error(msg)
            raise AttributeError(msg)

    elif iface_type == &quot;bridge&quot;:
        if &quot;ports&quot; not in settings:
            msg = (
                &quot;ports is a required setting for bridge interfaces on Debian &quot;
                &quot;or Ubuntu based systems&quot;
            )
            log.error(msg)
            raise AttributeError(msg)
        __salt__[&quot;pkg.install&quot;](&quot;bridge-utils&quot;)

    if iface_type in [&quot;eth&quot;, &quot;bond&quot;, &quot;bridge&quot;, &quot;slave&quot;, &quot;vlan&quot;, &quot;pppoe&quot;]:
        opts = _parse_settings_eth(settings, iface_type, enabled, iface)

    if iface_type in [&quot;source&quot;]:
        opts = _parse_settings_source(settings, iface_type, enabled, iface)

    if &quot;test&quot; in settings and settings[&quot;test&quot;]:
        return _read_temp_ifaces(iface, opts[iface])

    ifcfg = _write_file_ifaces(iface, opts[iface], **settings)

    if iface_type == &quot;pppoe&quot;:
        _write_file_ppp_ifaces(iface, opts[iface])

    # ensure lines in list end with newline, so difflib works
    return [item + &quot;\n&quot; for item in ifcfg]


def build_routes(iface, **settings):
    &quot;&quot;&quot;
    Add route scripts for a network interface using up commands.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_routes eth0 &lt;settings&gt;
    &quot;&quot;&quot;

    opts = _parse_routes(iface, settings)
    try:
        template = JINJA.get_template(&quot;route_eth.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template route_eth.jinja&quot;)
        return &quot;&quot;

    add_routecfg = template.render(route_type=&quot;add&quot;, routes=opts[&quot;routes&quot;], iface=iface)

    del_routecfg = template.render(route_type=&quot;del&quot;, routes=opts[&quot;routes&quot;], iface=iface)

    if &quot;test&quot; in settings and settings[&quot;test&quot;]:
        return _read_temp(add_routecfg + del_routecfg)

    filename = _write_file_routes(iface, add_routecfg, _DEB_NETWORK_UP_DIR, &quot;route-{0}&quot;)
    results = _read_file(filename)

    filename = _write_file_routes(
        iface, del_routecfg, _DEB_NETWORK_DOWN_DIR, &quot;route-{0}&quot;
    )
    results += _read_file(filename)

    return results


def down(iface, iface_type):
    &quot;&quot;&quot;
    Shutdown a network interface

    CLI Example:

    .. code-block:: bash

        salt '*' ip.down eth0 eth
    &quot;&quot;&quot;
    # Slave devices are controlled by the master.
    # Source 'interfaces' aren't brought down.
    if iface_type not in [&quot;slave&quot;, &quot;source&quot;]:
        return __salt__[&quot;cmd.run&quot;]([&quot;ifdown&quot;, iface])
    return None


def get_bond(iface):
    &quot;&quot;&quot;
    Return the content of a bond script

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_bond bond0
    &quot;&quot;&quot;
    path = os.path.join(_DEB_NETWORK_CONF_FILES, &quot;{}.conf&quot;.format(iface))
    return _read_file(path)


def get_interface(iface):
    &quot;&quot;&quot;
    Return the contents of an interface script

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_interface eth0
    &quot;&quot;&quot;

    adapters = _parse_interfaces()
    if iface in adapters:
        try:
            if iface == &quot;source&quot;:
                template = JINJA.get_template(&quot;debian_source.jinja&quot;)
            else:
                template = JINJA.get_template(&quot;debian_eth.jinja&quot;)
        except jinja2.exceptions.TemplateNotFound:
            log.error(&quot;Could not load template debian_eth.jinja&quot;)
            return &quot;&quot;

        ifcfg = template.render({&quot;name&quot;: iface, &quot;data&quot;: adapters[iface]})

        # ensure lines in list end with newline, so difflib works
        return [item + &quot;\n&quot; for item in ifcfg.split(&quot;\n&quot;)]
    else:
        return []


def up(iface, iface_type):  # pylint: disable=C0103
    &quot;&quot;&quot;
    Start up a network interface

    CLI Example:

    .. code-block:: bash

        salt '*' ip.up eth0 eth
    &quot;&quot;&quot;
    # Slave devices are controlled by the master.
    # Source 'interfaces' aren't brought up.
    if iface_type not in (&quot;slave&quot;, &quot;source&quot;):
        return __salt__[&quot;cmd.run&quot;]([&quot;ifup&quot;, iface])
    return None


def get_network_settings():
    &quot;&quot;&quot;
    Return the contents of the global network script.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_network_settings
    &quot;&quot;&quot;
    skip_etc_default_networking = (
        __grains__[&quot;osfullname&quot;] == &quot;Ubuntu&quot;
        and int(__grains__[&quot;osrelease&quot;].split(&quot;.&quot;)[0]) &gt;= 12
    )

    if skip_etc_default_networking:
        settings = {}
        if __salt__[&quot;service.available&quot;](&quot;networking&quot;):
            if __salt__[&quot;service.status&quot;](&quot;networking&quot;):
                settings[&quot;networking&quot;] = &quot;yes&quot;
            else:
                settings[&quot;networking&quot;] = &quot;no&quot;
        else:
            settings[&quot;networking&quot;] = &quot;no&quot;

        hostname = _parse_hostname()
        domainname = _parse_domainname()

        settings[&quot;hostname&quot;] = hostname
        settings[&quot;domainname&quot;] = domainname

    else:
        settings = _parse_current_network_settings()

    try:
        template = JINJA.get_template(&quot;display-network.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template display-network.jinja&quot;)
        return &quot;&quot;

    network = template.render(settings)
    return _read_temp(network)


def get_routes(iface):
    &quot;&quot;&quot;
    Return the routes for the interface

    CLI Example:

    .. code-block:: bash

        salt '*' ip.get_routes eth0
    &quot;&quot;&quot;

    filename = os.path.join(_DEB_NETWORK_UP_DIR, &quot;route-{}&quot;.format(iface))
    results = _read_file(filename)

    filename = os.path.join(_DEB_NETWORK_DOWN_DIR, &quot;route-{}&quot;.format(iface))
    results += _read_file(filename)

    return results


def apply_network_settings(**settings):
    &quot;&quot;&quot;
    Apply global network configuration.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.apply_network_settings
    &quot;&quot;&quot;
    if &quot;require_reboot&quot; not in settings:
        settings[&quot;require_reboot&quot;] = False

    if &quot;apply_hostname&quot; not in settings:
        settings[&quot;apply_hostname&quot;] = False

    hostname_res = True
    if settings[&quot;apply_hostname&quot;] in _CONFIG_TRUE:
        if &quot;hostname&quot; in settings:
            hostname_res = __salt__[&quot;network.mod_hostname&quot;](settings[&quot;hostname&quot;])
        else:
            log.warning(
                &quot;The network state sls is trying to apply hostname &quot;
                &quot;changes but no hostname is defined.&quot;
            )
            hostname_res = False

    res = True
    if settings[&quot;require_reboot&quot;] in _CONFIG_TRUE:
        log.warning(
            &quot;The network state sls is requiring a reboot of the system to &quot;
            &quot;properly apply network configuration.&quot;
        )
        res = True
    else:
        stop = __salt__[&quot;service.stop&quot;](&quot;networking&quot;)
        time.sleep(2)
        res = stop and __salt__[&quot;service.start&quot;](&quot;networking&quot;)

    return hostname_res and res


def build_network_settings(**settings):
    &quot;&quot;&quot;
    Build the global network script.

    CLI Example:

    .. code-block:: bash

        salt '*' ip.build_network_settings &lt;settings&gt;
    &quot;&quot;&quot;
    changes = []

    # Read current configuration and store default values
    current_network_settings = _parse_current_network_settings()

    # Build settings
    opts = _parse_network_settings(settings, current_network_settings)

    # Ubuntu has moved away from /etc/default/networking
    # beginning with the 12.04 release so we disable or enable
    # the networking related services on boot
    skip_etc_default_networking = (
        __grains__[&quot;osfullname&quot;] == &quot;Ubuntu&quot;
        and int(__grains__[&quot;osrelease&quot;].split(&quot;.&quot;)[0]) &gt;= 12
    )
    if skip_etc_default_networking:
        if opts[&quot;networking&quot;] == &quot;yes&quot;:
            service_cmd = &quot;service.enable&quot;
        else:
            service_cmd = &quot;service.disable&quot;

        if __salt__[&quot;service.available&quot;](&quot;NetworkManager&quot;):
            __salt__[service_cmd](&quot;NetworkManager&quot;)

        if __salt__[&quot;service.available&quot;](&quot;networking&quot;):
            __salt__[service_cmd](&quot;networking&quot;)
    else:
        try:
            template = JINJA.get_template(&quot;network.jinja&quot;)
        except jinja2.exceptions.TemplateNotFound:
            log.error(&quot;Could not load template network.jinja&quot;)
            return &quot;&quot;
        network = template.render(opts)

        if &quot;test&quot; in settings and settings[&quot;test&quot;]:
            return _read_temp(network)
        # Write settings
        _write_file_network(network, _DEB_NETWORKING_FILE, True)

    # Get hostname and domain from opts
    sline = opts[&quot;hostname&quot;].split(&quot;.&quot;, 1)
    opts[&quot;hostname&quot;] = sline[0]
    current_domainname = current_network_settings[&quot;domainname&quot;]
    current_searchdomain = current_network_settings[&quot;searchdomain&quot;]

    new_domain = False
    if len(sline) &gt; 1:
        new_domainname = sline[1]
        if new_domainname != current_domainname:
            domainname = new_domainname
            opts[&quot;domainname&quot;] = new_domainname
            new_domain = True
        else:
            domainname = current_domainname
            opts[&quot;domainname&quot;] = domainname
    else:
        domainname = current_domainname
        opts[&quot;domainname&quot;] = domainname

    new_search = False
    if &quot;search&quot; in opts:
        new_searchdomain = opts[&quot;search&quot;]
        if new_searchdomain != current_searchdomain:
            searchdomain = new_searchdomain
            opts[&quot;searchdomain&quot;] = new_searchdomain
            new_search = True
        else:
            searchdomain = current_searchdomain
            opts[&quot;searchdomain&quot;] = searchdomain
    else:
        searchdomain = current_searchdomain
        opts[&quot;searchdomain&quot;] = searchdomain

    # If the domain changes, then we should write the resolv.conf file.
    if new_domain or new_search:
        # Look for existing domain line and update if necessary
        resolve = _parse_resolve()
        domain_prog = re.compile(r&quot;domain\s+&quot;)
        search_prog = re.compile(r&quot;search\s+&quot;)
        new_contents = []

        for item in _read_file(_DEB_RESOLV_FILE):
            if domain_prog.match(item):
                item = &quot;domain {}&quot;.format(domainname)
            elif search_prog.match(item):
                item = &quot;search {}&quot;.format(searchdomain)
            new_contents.append(item)

        # A domain line didn't exist so we'll add one in
        # with the new domainname
        if &quot;domain&quot; not in resolve:
            new_contents.insert(0, &quot;domain {}&quot;.format(domainname))

        # A search line didn't exist so we'll add one in
        # with the new search domain
        if &quot;search&quot; not in resolve:
            new_contents.insert(&quot;domain&quot; in resolve, &quot;search {}&quot;.format(searchdomain))

        new_resolv = &quot;\n&quot;.join(new_contents)

        # Write /etc/resolv.conf
        if not (&quot;test&quot; in settings and settings[&quot;test&quot;]):
            _write_file_network(new_resolv, _DEB_RESOLV_FILE)

    #  used for returning the results back
    try:
        template = JINJA.get_template(&quot;display-network.jinja&quot;)
    except jinja2.exceptions.TemplateNotFound:
        log.error(&quot;Could not load template display-network.jinja&quot;)
        return &quot;&quot;
    network = template.render(opts)
    changes.extend(_read_temp(network))

    return changes
</PRE>
</div>
  </div>
</body>
</html>
