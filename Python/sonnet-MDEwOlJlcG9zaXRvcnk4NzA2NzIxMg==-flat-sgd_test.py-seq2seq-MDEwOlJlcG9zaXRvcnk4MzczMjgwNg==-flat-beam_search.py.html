
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 16.367265469061877%, Tokens: 12</h2>
        <div class="column">
            <h3>sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-sgd_test.py</h3>
            <pre><code>1  from sonnet.src.optimizers import optimizer_tests
2  from sonnet.src.optimizers import sgd
3  import tensorflow as tf
4  class SGDTest(optimizer_tests.OptimizerTestBase):
5    def make_optimizer(self, *args, **kwargs):
6      if "learning_rate" not in kwargs:
7        kwargs["learning_rate"] = 3.
8      return sgd.SGD(*args, **kwargs)
9    def testDense(self):
10      parameters = [tf.Variable([1., 2.]), tf.Variable([3., 4.])]
11      updates = [tf.constant([5., 5.]), tf.constant([3., 3.])]
12      optimizer = self.make_optimizer(learning_rate=3.)
13      optimizer.apply(updates, parameters)
14      self.assertAllClose([[-14., -13.], [-6., -5.]],
15                          [x.numpy() for x in parameters])
16    def testSparse(self):
17      if self.primary_device == "TPU":
18        self.skipTest("IndexedSlices not supported on TPU.")
19      parameters = [tf.Variable([[1.], [2.]]), tf.Variable([[3.], [4.]])]
20      updates = [
21          tf.IndexedSlices(
22              tf.constant([0.1], shape=[1, 1]), tf.constant([0]),
23              tf.constant([2, 1])),
24          tf.IndexedSlices(
<span onclick='openModal()' class='match'>25              tf.constant([0.01], shape=[1, 1]), tf.constant([1]),
26              tf.constant([2, 1]))
27      ]
28      optimizer = self.make_optimizer(learning_rate=3.)
29      optimizer.apply(updates, parameters)
30      self.assertAllClose([[1.0 - 3.0 * 0.1], [2.0]], parameters[0].numpy())
</span>31      self.assertAllClose([[3.0], [4.0 - 3.0 * 0.01]], parameters[1].numpy())
32    def testVariableLearningRate(self):
33      parameters = [tf.Variable([1., 2.]), tf.Variable([3., 4.])]
34      updates = [tf.constant([5., 5.]), tf.constant([3., 3.])]
35      learning_rate = tf.Variable(3.)
36      optimizer = self.make_optimizer(learning_rate=learning_rate)
37      optimizer.apply(updates, parameters)
38      self.assertAllClose([[-14., -13.], [-6., -5.]],
39                          [x.numpy() for x in parameters])
40      learning_rate.assign_sub(1.)
41      self.assertEqual(2., optimizer.learning_rate.numpy())
42      optimizer.apply(updates, parameters)
43      self.assertAllClose([[-24., -23.], [-12., -11.]],
44                          [x.numpy() for x in parameters])
45    def testLearningRateDTypeConversion(self):
46      parameters = [tf.Variable([1., 2.]), tf.Variable([3., 4.])]
47      updates = [tf.constant([5., 5.]), tf.constant([3., 3.])]
48      dtype = tf.int32 if self.primary_device == "TPU" else tf.int64
49      learning_rate = tf.Variable(3, dtype=dtype)
50      optimizer = self.make_optimizer(learning_rate=learning_rate)
51      optimizer.apply(updates, parameters)
52      self.assertAllClose([[-14., -13.], [-6., -5.]],
53                          [x.numpy() for x in parameters])
54  class ReferenceSGDTest(SGDTest):
55    def make_optimizer(self, *args, **kwargs):
56      if "learning_rate" not in kwargs:
57        kwargs["learning_rate"] = 3.
58      if hasattr(tf.keras.optimizers, "legacy"):
59        return optimizer_tests.WrappedTFOptimizer(
60            tf.keras.optimizers.legacy.SGD(**kwargs))
61      return optimizer_tests.WrappedTFOptimizer(tf.keras.optimizers.SGD(**kwargs))
62  if __name__ == "__main__":
63    tf.test.main()
</code></pre>
        </div>
        <div class="column">
            <h3>seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-beam_search.py</h3>
            <pre><code>1  from __future__ import absolute_import
2  from __future__ import division
3  from __future__ import print_function
4  from collections import namedtuple
5  import numpy as np
6  import tensorflow as tf
7  from tensorflow.python.util import nest  # pylint: disable=E0611
8  class BeamSearchState(
9      namedtuple("BeamSearchState", ["log_probs", "finished", "lengths"])):
10    pass
11  class BeamSearchStepOutput(
12      namedtuple("BeamSearchStepOutput",
13                 ["scores", "predicted_ids", "beam_parent_ids"])):
14    pass
15  class BeamSearchConfig(
16      namedtuple("BeamSearchConfig", [
17          "beam_width", "vocab_size", "eos_token", "length_penalty_weight",
18          "choose_successors_fn"
19      ])):
20    pass
21  def gather_tree_py(values, parents):
22    beam_length = values.shape[0]
23    num_beams = values.shape[1]
24    res = np.zeros_like(values)
25    res[-1, :] = values[-1, :]
26    for beam_id in range(num_beams):
27      parent = parents[-1][beam_id]
28      for level in reversed(range(beam_length - 1)):
29        res[level, beam_id] = values[level][parent]
30        parent = parents[level][parent]
31    return np.array(res).astype(values.dtype)
32  def gather_tree(values, parents):
33    res = tf.py_func(
34        func=gather_tree_py, inp=[values, parents], Tout=values.dtype)
35    res.set_shape(values.get_shape().as_list())
36    return res
37  def create_initial_beam_state(config):
38    return BeamSearchState(
39        log_probs=tf.zeros([config.beam_width]),
40        finished=tf.zeros(
41            [config.beam_width], dtype=tf.bool),
42        lengths=tf.zeros(
43            [config.beam_width], dtype=tf.int32))
44  def length_penalty(sequence_lengths, penalty_factor):
45    return tf.div((5. + tf.to_float(sequence_lengths))**penalty_factor, (5. + 1.)
46                  **penalty_factor)
47  def hyp_score(log_probs, sequence_lengths, config):
48    length_penality_ = length_penalty(
49        sequence_lengths=sequence_lengths,
50        penalty_factor=config.length_penalty_weight)
51    score = log_probs / length_penality_
52    return score
53  def choose_top_k(scores_flat, config):
54    next_beam_scores, word_indices = tf.nn.top_k(scores_flat, k=config.beam_width)
55    return next_beam_scores, word_indices
56  def nest_map(inputs, map_fn, name=None):
57    if nest.is_sequence(inputs):
58      inputs_flat = nest.flatten(inputs)
59      y_flat = [map_fn(_) for _ in inputs_flat]
60      outputs = nest.pack_sequence_as(inputs, y_flat)
61    else:
62      outputs = map_fn(inputs)
63    if name:
64      outputs = tf.identity(outputs, name=name)
65    return outputs
66  def mask_probs(probs, eos_token, finished):
67    vocab_size = tf.shape(probs)[1]
68    finished_mask = tf.expand_dims(tf.to_float(1. - tf.to_float(finished)), 1)
69    non_finished_examples = finished_mask * probs
70    finished_row = tf.one_hot(
71        eos_token,
72        vocab_size,
73        dtype=tf.float32,
74        on_value=0.,
75        off_value=tf.float32.min)
76    finished_examples = (1. - finished_mask) * finished_row
77    return finished_examples + non_finished_examples
78  def beam_search_step(time_, logits, beam_state, config):
79    prediction_lengths = beam_state.lengths
80    previously_finished = beam_state.finished
81    probs = tf.nn.log_softmax(logits)
82    probs = mask_probs(probs, config.eos_token, previously_finished)
83    total_probs = tf.expand_dims(beam_state.log_probs, 1) + probs
84    lengths_to_add = tf.one_hot([config.eos_token] * config.beam_width,
85                                config.vocab_size, 0, 1)
86    add_mask = (1 - tf.to_int32(previously_finished))
87    lengths_to_add = tf.expand_dims(add_mask, 1) * lengths_to_add
88    new_prediction_lengths = tf.expand_dims(prediction_lengths,
89                                            1) + lengths_to_add
90    scores = hyp_score(
91        log_probs=total_probs,
92        sequence_lengths=new_prediction_lengths,
93        config=config)
94    scores_flat = tf.reshape(scores, [-1])
95    scores_flat = tf.cond(
96        tf.convert_to_tensor(time_) > 0, lambda: scores_flat, lambda: scores[0])
97    next_beam_scores, word_indices = config.choose_successors_fn(scores_flat,
98                                                                 config)
99    next_beam_scores.set_shape([config.beam_width])
100    word_indices.set_shape([config.beam_width])
101    total_probs_flat = tf.reshape(total_probs, [-1], name="total_probs_flat")
102    next_beam_probs = tf.gather(total_probs_flat, word_indices)
103    next_beam_probs.set_shape([config.beam_width])
104    next_word_ids = tf.mod(word_indices, config.vocab_size)
105    next_beam_ids = tf.div(word_indices, config.vocab_size)
106    next_finished = tf.logical_or(
107        tf.gather(beam_state.finished, next_beam_ids),
108        tf.equal(next_word_ids, config.eos_token))
<span onclick='openModal()' class='match'>109    lengths_to_add = tf.to_int32(tf.not_equal(next_word_ids, config.eos_token))
110    lengths_to_add = (1 - tf.to_int32(next_finished)) * lengths_to_add
111    next_prediction_len = tf.gather(beam_state.lengths, next_beam_ids)
</span>112    next_prediction_len += lengths_to_add
113    next_state = BeamSearchState(
114        log_probs=next_beam_probs,
115        lengths=next_prediction_len,
116        finished=next_finished)
117    output = BeamSearchStepOutput(
118        scores=next_beam_scores,
119        predicted_ids=next_word_ids,
120        beam_parent_ids=next_beam_ids)
121    return output, next_state
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from sonnet-MDEwOlJlcG9zaXRvcnk4NzA2NzIxMg==-flat-sgd_test.py</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from seq2seq-MDEwOlJlcG9zaXRvcnk4MzczMjgwNg==-flat-beam_search.py</div>
                <div class="column column_space"><pre><code>25              tf.constant([0.01], shape=[1, 1]), tf.constant([1]),
26              tf.constant([2, 1]))
27      ]
28      optimizer = self.make_optimizer(learning_rate=3.)
29      optimizer.apply(updates, parameters)
30      self.assertAllClose([[1.0 - 3.0 * 0.1], [2.0]], parameters[0].numpy())
</pre></code></div>
                <div class="column column_space"><pre><code>109    lengths_to_add = tf.to_int32(tf.not_equal(next_word_ids, config.eos_token))
110    lengths_to_add = (1 - tf.to_int32(next_finished)) * lengths_to_add
111    next_prediction_len = tf.gather(beam_state.lengths, next_beam_ids)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    