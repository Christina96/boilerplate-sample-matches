<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_bluez_bluetooth.py &amp; test_archive_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_bluez_bluetooth.py &amp; test_archive_3.py
      </h3>
<h1 align="center">
        13.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_bluez_bluetooth.py (16.348774%)<th>test_archive_3.py (11.214953%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(182-186)<td><a href="#" name="0">(326-348)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(148-152)<td><a href="#" name="1">(254-276)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(136-140)<td><a href="#" name="2">(202-224)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(114-118)<td><a href="#" name="3">(150-172)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(92-96)<td><a href="#" name="4">(97-107)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bluez_bluetooth.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.modules.bluez_bluetooth as bluez
2 import salt.utils.validate.net
3 from salt.exceptions import CommandExecutionError
4 from tests.support.mixins import LoaderModuleMockMixin
5 from tests.support.mock import MagicMock, patch
6 from tests.support.unit import TestCase
7 class MockBluetooth:
8     def __init__(self):
9         pass
10     @staticmethod
11     def discover_devices(lookup_names):
12         return [["a", "b", "c"], ["d", "e", "f"]]
13 class BluezTestCase(TestCase, LoaderModuleMockMixin):
14     def setup_loader_modules(self):
15         return {bluez: {"bluetooth": MockBluetooth()}}
16     def test_version(self):
17         mock = MagicMock(return_value="5.7")
18         with patch.dict(bluez.__salt__, {"cmd.run": mock}):
19             self.assertDictEqual(
20                 bluez.version(),
21                 {"PyBluez": "&lt;= 0.18 (Unknown, but installed)", "Bluez": "5.7"},
22             )
23     def test_address_(self):
24         mock = MagicMock(return_value="hci : hci0")
25         with patch.dict(bluez.__salt__, {"cmd.run": mock}):
26             self.assertDictEqual(
27                 bluez.address_(),
28                 {"hci ": {"device": "hci ", "path": "/sys/class/bluetooth/hci "}},
29             )
30     def test_power(self):
31         mock = MagicMock(return_value={})
32         with patch.object(bluez, "address_", mock):
33             self.assertRaises(CommandExecutionError, bluez.power, "hci0", "on")
34         mock = MagicMock(return_value={"hci0": {"device": "hci0", "power": "on"}})
35         with patch.object(bluez, "address_", mock):
36             mock = MagicMock(return_value="")
37             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
38                 self.assertTrue(bluez.power("hci0", "on"))
39         mock = MagicMock(return_value={"hci0": {"device": "hci0", "power": "on"}})
40         with patch.object(bluez, "address_", mock):
41             mock = MagicMock(return_value="")
42             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
43                 self.assertFalse(bluez.power("hci0", "off"))
44     def test_discoverable(self):
45         mock = MagicMock(
46             side_effect=[
47                 {},
48                 {"hci0": {"device": "hci0", "power": "on"}},
49                 {"hci0": {"device": "hci0", "power": "on"}},
50 <a name="4"></a>            ]
51         )
52         with patch.object(bluez, "address_", mock):
53             self.assertRaises(CommandExecutionError, bluez<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.discoverable, "hci0")
54             mock = MagicMock(return_value="UP RUNNING ISCAN")
55             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
56                 self.assertTrue(bluez.</b></font>discoverable("hci0"))
57             mock = MagicMock(return_value="")
58             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
59                 self.assertFalse(bluez.discoverable("hci0"))
60     def test_noscan(self):
61         mock = MagicMock(
62             side_effect=[
63                 {},
64                 {"hci0": {"device": "hci0", "power": "on"}},
65                 {"hci0": {"device": "hci0", "power": "on"}},
66 <a name="3"></a>            ]
67         )
68         with patch.object(bluez, "address_", mock):
69             self.assertRaises(CommandExecutionError, bluez<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.noscan, "hci0")
70             mock = MagicMock(return_value="SCAN")
71             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
72                 self.assertFalse(bluez.</b></font>noscan("hci0"))
73             mock = MagicMock(return_value="")
74             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
75                 self.assertTrue(bluez.noscan("hci0"))
76     def test_scan(self):
77         self.assertListEqual(bluez.scan(), [{"a": "b"}, {"d": "e"}])
78     def test_block(self):
79             self.assertRaises(CommandExecutionError, bluez<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.block, "DE:AD:BE:EF:CA:ZE")
80             mock = MagicMock(return_value="")
81             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
82                 self.assertIsNone(bluez.</b></font>block("DE:AD:BE:EF:CA:FE"))
83     def test_unblock(self):
84             self.assertRaises(CommandExecutionError, bluez<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.block, "DE:AD:BE:EF:CA:ZE")
85             mock = MagicMock(return_value="")
86             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
87                 self.assertIsNone(bluez.</b></font>unblock("DE:AD:BE:EF:CA:FE"))
88     def test_pair(self):
89         mock = MagicMock(side_effect=[False, True, True])
90         with patch.object(salt.utils.validate.net, "mac", mock):
91             self.assertRaises(
92                 CommandExecutionError, bluez.pair, "DE:AD:BE:EF:CA:FE", "1234"
93             )
94             self.assertRaises(
95                 CommandExecutionError, bluez.pair, "DE:AD:BE:EF:CA:FE", "abcd"
96             )
97             mock = MagicMock(return_value={"device": "hci0"})
98             with patch.object(bluez, "address_", mock):
99                 mock = MagicMock(return_value="Ok")
100                 with patch.dict(bluez.__salt__, {"cmd.run": mock}):
101                     self.assertListEqual(
102                         bluez.pair("DE:AD:BE:EF:CA:FE", "1234"), ["Ok"]
103                     )
104     def test_unpair(self):
105             self.assertRaises(CommandExecutionError, bluez<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.unpair, "DE:AD:BE:EF:CA:FE")
106             mock = MagicMock(return_value="Ok")
107             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
108                 self.assertListEqual(bluez.</b></font>unpair("DE:AD:BE:EF:CA:FE"), ["Ok"])
109     def test_start(self):
110         mock = MagicMock(return_value="Ok")
111         with patch.dict(bluez.__salt__, {"service.start": mock}):
112             self.assertEqual(bluez.start(), "Ok")
113     def test_stop(self):
114         mock = MagicMock(return_value="Ok")
115         with patch.dict(bluez.__salt__, {"service.stop": mock}):
116             self.assertEqual(bluez.stop(), "Ok")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import os
2 import pytest
3 import salt.states.archive as archive
4 import salt.utils.platform
5 from tests.support.mock import MagicMock, patch
6 @pytest.fixture
7 def configure_loader_modules():
8     return {
9         archive: {
10             "__grains__": {"os": "FooOS!"},
11             "__opts__": {"cachedir": "/tmp", "test": False, "hash_type": "sha256"},
12             "__env__": "test",
13         }
14     }
15 def _isfile_side_effect(path):
16     if salt.utils.platform.is_windows():
17         path = path.lower()
18     d = {
19         "/tmp/foo.tar.gz": True,
20         "c:\\tmp\\foo.tar.gz": True,
21         "/private/tmp/foo.tar.gz": True,
22         "/tmp/out": False,
23         "\\tmp\\out": False,
24         "/usr/bin/tar": True,
25         "/bin/tar": True,
26         "/tmp/test_extracted_tar": False,
27         "c:\\tmp\\test_extracted_tar": False,
28         "/private/tmp/test_extracted_tar": False,
29     }
30     return d[path]
31 def test_extracted_tar():
32     if salt.utils.platform.is_windows():
33         source = "C:\\tmp\\foo.tar.gz"
34         tmp_dir = "C:\\tmp\\test_extracted_tar"
35     elif salt.utils.platform.is_darwin():
36         source = "/private/tmp/foo.tar.gz"
37         tmp_dir = "/private/tmp/test_extracted_tar"
38     else:
39         source = "/tmp/foo.tar.gz"
40         tmp_dir = "/tmp/test_extracted_tar"
41     test_tar_opts = [
42         "--no-anchored foo",
43         "v -p --opt",
44         "-v -p",
45         "--long-opt -z",
46         "z -v -weird-long-opt arg",
47     ]
48     ret_tar_opts = [
49         ["tar", "xv", "--no-anchored", "foo", "-f"],
50         ["tar", "xv", "-p", "--opt", "-f"],
51         ["tar", "xv", "-p", "-f"],
52         ["tar", "xv", "--long-opt", "-z", "-f"],
53         ["tar", "xvz", "-weird-long-opt", "arg", "-f"],
54     ]
55     mock_true = MagicMock(return_value=True)
56     mock_false = MagicMock(return_value=False)
57     ret = {
58         "stdout": ["cheese", "ham", "saltines"],
59         "stderr": "biscuits",
60         "retcode": "31337",
61         "pid": "1337",
62     }
63     mock_run = MagicMock(return_value=ret)
64     mock_source_list = MagicMock(return_value=(source, None))
65     state_single_mock = MagicMock(return_value={"local": {"result": True}})
66     list_mock = MagicMock(
67         return_value={
68             "dirs": [],
69 <a name="4"></a>            "files": ["cheese", "saltines"],
70             "links": ["ham"],
71             "top_level_dirs": [],
72             "top_level_files": [<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"cheese", "saltines"],
73             "top_level_links": ["ham"],
74         }
75     )
76     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
77     with patch.dict(
78         archive.__opts__,
79         {"test": False, "cachedir": tmp_dir, "hash_type": "sha256"},
80     ), patch.dict(
81         archive.</b></font>__salt__,
82         {
83             "file.directory_exists": mock_false,
84             "file.file_exists": mock_false,
85             "state.single": state_single_mock,
86             "file.makedirs": mock_true,
87             "cmd.run_all": mock_run,
88             "archive.list": list_mock,
89             "file.source_list": mock_source_list,
90         },
91     ), patch.dict(
92         archive.__states__, {"file.directory": mock_true}
93     ), patch.object(
94         os.path, "isfile", isfile_mock
95     ), patch(
96         "salt.utils.path.which", MagicMock(return_value=True)
97     ):
98         for test_opts, ret_opts in zip(test_tar_opts, ret_tar_opts):
99             archive.extracted(
100                 tmp_dir, source, options=test_opts, enforce_toplevel=False
101             )
102             ret_opts.append(source)
103             mock_run.assert_called_with(
104                 ret_opts, cwd=tmp_dir + os.sep, python_shell=False
105             )
106 def test_tar_gnutar():
107     gnutar = MagicMock(return_value="tar (GNU tar)")
108     source = "/tmp/foo.tar.gz"
109     mock_false = MagicMock(return_value=False)
110     mock_true = MagicMock(return_value=True)
111     state_single_mock = MagicMock(return_value={"local": {"result": True}})
112     run_all = MagicMock(
113         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
114     )
115 <a name="3"></a>    mock_source_list = MagicMock(return_value=(source, None))
116     list_mock = MagicMock(
117         return_value={
118             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
119             "files": ["stdout"],
120             "links": [],
121             "top_level_dirs": [],
122             "top_level_files": ["stdout"],
123             "top_level_links": [],
124         }
125     )
126     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
127     with patch.dict(
128         archive.__salt__,
129         {
130             "cmd.run": gnutar,
131             "file.directory_exists": mock_false,
132             "file.file_exists": mock_false,
133             "state.single": state_single_mock,
134             "file.makedirs": mock_true,
135             "cmd.run_all": run_all,
136             "archive.list": list_mock,
137             "file.source_list": mock_source_list,
138         },
139     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
140         os.path, "isfile", isfile_mock
141     ), patch(
142         "salt.utils.path.which", MagicMock(return_value=True)
143     ):
144         ret = archive.extracted(
145             os.path.join(os.sep + "tmp", "out"),
146             source,
147             options="xvzf",
148             enforce_toplevel=False,
149             keep=True,
150         )
151         assert ret["changes"]["extracted_files"] == ["stdout"]
152 def test_tar_bsdtar():
153     bsdtar = MagicMock(return_value="tar (bsdtar)")
154     source = "/tmp/foo.tar.gz"
155     mock_false = MagicMock(return_value=False)
156     mock_true = MagicMock(return_value=True)
157     state_single_mock = MagicMock(return_value={"local": {"result": True}})
158     run_all = MagicMock(
159         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
160     )
161 <a name="2"></a>    mock_source_list = MagicMock(return_value=(source, None))
162     list_mock = MagicMock(
163         return_value={
164             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
165             "files": ["stderr"],
166             "links": [],
167             "top_level_dirs": [],
168             "top_level_files": ["stderr"],
169             "top_level_links": [],
170         }
171     )
172     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
173     with patch.dict(
174         archive.__salt__,
175         {
176             "cmd.run": bsdtar,
177             "file.directory_exists": mock_false,
178             "file.file_exists": mock_false,
179             "state.single": state_single_mock,
180             "file.makedirs": mock_true,
181             "cmd.run_all": run_all,
182             "archive.list": list_mock,
183             "file.source_list": mock_source_list,
184         },
185     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
186         os.path, "isfile", isfile_mock
187     ), patch(
188         "salt.utils.path.which", MagicMock(return_value=True)
189     ):
190         ret = archive.extracted(
191             os.path.join(os.sep + "tmp", "out"),
192             source,
193             options="xvzf",
194             enforce_toplevel=False,
195             keep=True,
196         )
197         assert ret["changes"]["extracted_files"] == ["stderr"]
198 def test_tar_bsdtar_with_trim_output():
199     bsdtar = MagicMock(return_value="tar (bsdtar)")
200     source = "/tmp/foo.tar.gz"
201     mock_false = MagicMock(return_value=False)
202     mock_true = MagicMock(return_value=True)
203     state_single_mock = MagicMock(return_value={"local": {"result": True}})
204     run_all = MagicMock(
205         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
206     )
207 <a name="1"></a>    mock_source_list = MagicMock(return_value=(source, None))
208     list_mock = MagicMock(
209         return_value={
210             <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
211             "files": ["stderr"],
212             "links": [],
213             "top_level_dirs": [],
214             "top_level_files": ["stderr"],
215             "top_level_links": [],
216         }
217     )
218     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
219     with patch.dict(
220         archive.__salt__,
221         {
222             "cmd.run": bsdtar,
223             "file.directory_exists": mock_false,
224             "file.file_exists": mock_false,
225             "state.single": state_single_mock,
226             "file.makedirs": mock_true,
227             "cmd.run_all": run_all,
228             "archive.list": list_mock,
229             "file.source_list": mock_source_list,
230         },
231     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
232         os.path, "isfile", isfile_mock
233     ), patch(
234         "salt.utils.path.which", MagicMock(return_value=True)
235     ):
236         ret = archive.extracted(
237             os.path.join(os.sep + "tmp", "out"),
238             source,
239             options="xvzf",
240             enforce_toplevel=False,
241             keep_source=True,
242             trim_output=1,
243         )
244         assert ret["changes"]["extracted_files"] == ["stderr"]
245         assert ret["comment"].endswith("Output was trimmed to 1 number of lines")
246 def test_extracted_when_if_missing_path_exists():
247     name = if_missing = "/tmp/foo"
248     source = "salt://foo.bar.tar"
249     with patch.object(os.path, "exists", MagicMock(return_value=True)):
250         ret = archive.extracted(name, source=source, if_missing=if_missing)
251         assert ret["result"], ret
252         assert ret["comment"] == "Path {} exists".format(if_missing)
253 def test_clean_parent_conflict():
254     gnutar = MagicMock(return_value="tar (GNU tar)")
255     source = "/tmp/foo.tar.gz"
256     ret_comment = "Only one of 'clean' and 'clean_parent' can be set to True"
257     mock_false = MagicMock(return_value=False)
258     mock_true = MagicMock(return_value=True)
259     state_single_mock = MagicMock(return_value={"local": {"result": True}})
260     run_all = MagicMock(
261         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
262     )
263 <a name="0"></a>    mock_source_list = MagicMock(return_value=(source, None))
264     list_mock = MagicMock(
265         return_value={
266             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
267             "files": ["stdout"],
268             "links": [],
269             "top_level_dirs": [],
270             "top_level_files": ["stdout"],
271             "top_level_links": [],
272         }
273     )
274     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
275     with patch.dict(
276         archive.__salt__,
277         {
278             "cmd.run": gnutar,
279             "file.directory_exists": mock_false,
280             "file.file_exists": mock_false,
281             "state.single": state_single_mock,
282             "file.makedirs": mock_true,
283             "cmd.run_all": run_all,
284             "archive.list": list_mock,
285             "file.source_list": mock_source_list,
286         },
287     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
288         os.path, "isfile", isfile_mock
289     ), patch(
290         "salt.utils.path.which", MagicMock(return_value=True)
291     ):
292         ret = archive.extracted(
293             os.path.join(os.sep + "tmp", "out"),
294             source,
295             options="xvzf",
296             enforce_toplevel=False,
297             clean=True,
298             clean_parent=True,
299             keep=True,
300         )
301         assert ret["result"] is False
302         assert ret["changes"] == {}
303         assert ret["comment"] == ret_comment
304 def test_skip_files_list_verify_conflict():
305     gnutar = MagicMock(return_value="tar (GNU tar)")
306     source = "/tmp/foo.tar.gz"
307     ret_comment = (
308         'Only one of "skip_files_list_verify" and "skip_verify" can be set to True'
309     )
310     mock_false = MagicMock(return_value=False)
311     mock_true = MagicMock(return_value=True)
312     state_single_mock = MagicMock(return_value={"local": {"result": True}})
313     run_all = MagicMock(
314         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
315     )
316     mock_source_list = MagicMock(return_value=(source, None))
317     list_mock = MagicMock(
318         return_value={
319             "dirs": [],
320             "files": ["stdout"],
321             "links": [],
322             "top_level_dirs": [],
323             "top_level_files": ["stdout"],
324             "top_level_links": [],
325         }
326     )
327     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
328     with patch.dict(
329         archive.__salt__,
330         {
331             "cmd.run": gnutar,
332             "file.directory_exists": mock_false,
333             "file.file_exists": mock_false,
334             "state.single": state_single_mock,
335             "file.makedirs": mock_true,
336             "cmd.run_all": run_all,
337             "archive.list": list_mock,
338             "file.source_list": mock_source_list,
339         },
340     ), patch.dict(archive.__states__, {"file.directory": mock_true}), patch.object(
341         os.path, "isfile", isfile_mock
342     ), patch(
343         "salt.utils.path.which", MagicMock(return_value=True)
344     ):
345         ret = archive.extracted(
346             os.path.join(os.sep + "tmp", "out"),
347             source,
348             options="xvzf",
349             enforce_toplevel=False,
350             clean=True,
351             skip_files_list_verify=True,
352             skip_verify=True,
353             keep=True,
354         )
355         assert ret["result"] is False
356         assert ret["changes"] == {}
357         assert ret["comment"] == ret_comment
358 def test_skip_files_list_verify_success():
359     if salt.utils.platform.is_windows():
360         source = "C:\\tmp\\foo.tar.gz"
361         tmp_dir = "C:\\tmp\\test_extracted_tar"
362     elif salt.utils.platform.is_darwin():
363         source = "/private/tmp/foo.tar.gz"
364         tmp_dir = "/private/tmp/test_extracted_tar"
365     else:
366         source = "/tmp/foo.tar.gz"
367         tmp_dir = "/tmp/test_extracted_tar"
368     expected_comment = (
369         "Archive {} existing source sum is the same as the "
370         "expected one and skip_files_list_verify argument "
371         "was set to True. Extraction is not needed".format(source)
372     )
373     expected_ret = {
374         "name": tmp_dir,
375         "result": True,
376         "changes": {},
377         "comment": expected_comment,
378     }
379     mock_true = MagicMock(return_value=True)
380     mock_false = MagicMock(return_value=False)
381     mock_cached = MagicMock(return_value="{}/{}".format(tmp_dir, source))
382     source_sum = {"hsum": "testhash", "hash_type": "sha256"}
383     mock_hash = MagicMock(return_value=source_sum)
384     mock_source_list = MagicMock(return_value=(source, None))
385     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
386     with patch("salt.states.archive._read_cached_checksum", mock_hash):
387         with patch.dict(
388             archive.__opts__,
389             {"test": False, "cachedir": tmp_dir, "hash_type": "sha256"},
390         ), patch.dict(
391             archive.__salt__,
392             {
393                 "file.directory_exists": mock_false,
394                 "file.get_source_sum": mock_hash,
395                 "file.check_hash": mock_true,
396                 "cp.is_cached": mock_cached,
397                 "file.source_list": mock_source_list,
398             },
399         ), patch.object(
400             os.path, "isfile", isfile_mock
401         ):
402             ret = archive.extracted(
403                 tmp_dir,
404                 source,
405                 source_hash="testhash",
406                 skip_files_list_verify=True,
407                 enforce_toplevel=False,
408             )
409             assert ret == expected_ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
