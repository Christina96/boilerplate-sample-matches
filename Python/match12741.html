<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_bluez_bluetooth.py &amp; test_archive_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_bluez_bluetooth.py &amp; test_archive_3.py
      </h3>
<h1 align="center">
        13.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_bluez_bluetooth.py (16.348774%)<th>test_archive_3.py (11.214953%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(182-186)<td><a href="#" name="0">(326-348)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(148-152)<td><a href="#" name="1">(254-276)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(136-140)<td><a href="#" name="2">(202-224)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(114-118)<td><a href="#" name="3">(150-172)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(92-96)<td><a href="#" name="4">(97-107)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bluez_bluetooth.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import salt.modules.bluez_bluetooth as bluez
import salt.utils.validate.net
from salt.exceptions import CommandExecutionError
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase
class MockBluetooth:
    def __init__(self):
        pass
    @staticmethod
    def discover_devices(lookup_names):
        return [["a", "b", "c"], ["d", "e", "f"]]
class BluezTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        return {bluez: {"bluetooth": MockBluetooth()}}
    def test_version(self):
        mock = MagicMock(return_value="5.7")
        with patch.dict(bluez.__salt__, {"cmd.run": mock}):
            self.assertDictEqual(
                bluez.version(),
                {"PyBluez": "&lt;= 0.18 (Unknown, but installed)", "Bluez": "5.7"},
            )
    def test_address_(self):
        mock = MagicMock(return_value="hci : hci0")
        with patch.dict(bluez.__salt__, {"cmd.run": mock}):
            self.assertDictEqual(
                bluez.address_(),
                {"hci ": {"device": "hci ", "path": "/sys/class/bluetooth/hci "}},
            )
    def test_power(self):
        mock = MagicMock(return_value={})
        with patch.object(bluez, "address_", mock):
            self.assertRaises(CommandExecutionError, bluez.power, "hci0", "on")
        mock = MagicMock(return_value={"hci0": {"device": "hci0", "power": "on"}})
        with patch.object(bluez, "address_", mock):
            mock = MagicMock(return_value="")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertTrue(bluez.power("hci0", "on"))
        mock = MagicMock(return_value={"hci0": {"device": "hci0", "power": "on"}})
        with patch.object(bluez, "address_", mock):
            mock = MagicMock(return_value="")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertFalse(bluez.power("hci0", "off"))
    def test_discoverable(self):
        mock = MagicMock(
            side_effect=[
                {},
                {"hci0": {"device": "hci0", "power": "on"}},
                {"hci0": {"device": "hci0", "power": "on"}},
<a name="4"></a>            ]
        )
        with patch.object(bluez, "address_", mock):
            self.assertRaises(CommandExecutionError, bluez<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.discoverable, "hci0")
            mock = MagicMock(return_value="UP RUNNING ISCAN")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertTrue(bluez.</b></font>discoverable("hci0"))
            mock = MagicMock(return_value="")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertFalse(bluez.discoverable("hci0"))
    def test_noscan(self):
        mock = MagicMock(
            side_effect=[
                {},
                {"hci0": {"device": "hci0", "power": "on"}},
                {"hci0": {"device": "hci0", "power": "on"}},
<a name="3"></a>            ]
        )
        with patch.object(bluez, "address_", mock):
            self.assertRaises(CommandExecutionError, bluez<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.noscan, "hci0")
            mock = MagicMock(return_value="SCAN")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertFalse(bluez.</b></font>noscan("hci0"))
            mock = MagicMock(return_value="")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertTrue(bluez.noscan("hci0"))
    def test_scan(self):
        self.assertListEqual(bluez.scan(), [{"a": "b"}, {"d": "e"}])
    def test_block(self):
            self.assertRaises(CommandExecutionError, bluez<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.block, "DE:AD:BE:EF:CA:ZE")
            mock = MagicMock(return_value="")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertIsNone(bluez.</b></font>block("DE:AD:BE:EF:CA:FE"))
    def test_unblock(self):
            self.assertRaises(CommandExecutionError, bluez<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.block, "DE:AD:BE:EF:CA:ZE")
            mock = MagicMock(return_value="")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertIsNone(bluez.</b></font>unblock("DE:AD:BE:EF:CA:FE"))
    def test_pair(self):
        mock = MagicMock(side_effect=[False, True, True])
        with patch.object(salt.utils.validate.net, "mac", mock):
            self.assertRaises(
                CommandExecutionError, bluez.pair, "DE:AD:BE:EF:CA:FE", "1234"
            )
            self.assertRaises(
                CommandExecutionError, bluez.pair, "DE:AD:BE:EF:CA:FE", "abcd"
            )
            mock = MagicMock(return_value={"device": "hci0"})
            with patch.object(bluez, "address_", mock):
                mock = MagicMock(return_value="Ok")
                with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                    self.assertListEqual(
                        bluez.pair("DE:AD:BE:EF:CA:FE", "1234"), ["Ok"]
                    )
    def test_unpair(self):
            self.assertRaises(CommandExecutionError, bluez<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.unpair, "DE:AD:BE:EF:CA:FE")
            mock = MagicMock(return_value="Ok")
            with patch.dict(bluez.__salt__, {"cmd.run": mock}):
                self.assertListEqual(bluez.</b></font>unpair("DE:AD:BE:EF:CA:FE"), ["Ok"])
    def test_start(self):
        mock = MagicMock(return_value="Ok")
        with patch.dict(bluez.__salt__, {"service.start": mock}):
            self.assertEqual(bluez.start(), "Ok")
    def test_stop(self):
        mock = MagicMock(return_value="Ok")
        with patch.dict(bluez.__salt__, {"service.stop": mock}):
            self.assertEqual(bluez.stop(), "Ok")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import os
import pytest
import salt.states.archive as archive
import salt.utils.platform
from tests.support.mock import MagicMock, patch
@pytest.fixture
def configure_loader_modules():
    return {
        archive: {
            "__grains__": {"os": "FooOS!"},
            "__opts__": {"cachedir": "/tmp", "test": False, "hash_type": "sha256"},
            "__env__": "test",
        }
    }
def _isfile_side_effect(path):
    if salt.utils.platform.is_windows():
        path = path.lower()
    d = {
        "/tmp/foo.tar.gz": True,
        "c:\\tmp\\foo.tar.gz": True,
        "/private/tmp/foo.tar.gz": True,
        "/tmp/out": False,
        "\\tmp\\out": False,
        "/usr/bin/tar": True,
        "/bin/tar": True,
        "/tmp/test_extracted_tar": False,
        "c:\\tmp\\test_extracted_tar": False,
        "/private/tmp/test_extracted_tar": False,
    }
    return d[path]
def test_extracted_tar():
    if salt.utils.platform.is_windows():
        source = "C:\\tmp\\foo.tar.gz"
        tmp_dir = "C:\\tmp\\test_extracted_tar"
    elif salt.utils.platform.is_darwin():
        source = "/private/tmp/foo.tar.gz"
        tmp_dir = "/private/tmp/test_extracted_tar"
    else:
        source = "/tmp/foo.tar.gz"
        tmp_dir = "/tmp/test_extracted_tar"
    test_tar_opts = [
        "--no-anchored foo",
        "v -p --opt",
        "-v -p",
        "--long-opt -z",
        "z -v -weird-long-opt arg",
    ]
    ret_tar_opts = [
        ["tar", "xv", "--no-anchored", "foo", "-f"],
        ["tar", "xv", "-p", "--opt", "-f"],
        ["tar", "xv", "-p", "-f"],
        ["tar", "xv", "--long-opt", "-z", "-f"],
        ["tar", "xvz", "-weird-long-opt", "arg", "-f"],
    ]
    mock_true = MagicMock(return_value=True)
    mock_false = MagicMock(return_value=False)
    ret = {
        "stdout": ["cheese", "ham", "saltines"],
        "stderr": "biscuits",
        "retcode": "31337",
        "pid": "1337",
    }
    mock_run = MagicMock(return_value=ret)
    mock_source_list = MagicMock(return_value=(source, None))
    state_single_mock = MagicMock(return_value={"local": {"result": True}})
    list_mock = MagicMock(
        return_value={
            "dirs": [],
<a name="4"></a>            "files": ["cheese", "saltines"],
            "links": ["ham"],
            "top_level_dirs": [],
            "top_level_files": [<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"cheese", "saltines"],
            "top_level_links": ["ham"],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)
    with patch.dict(
        archive.__opts__,
        {"test": False, "cachedir": tmp_dir, "hash_type": "sha256"},
    ), patch.dict(
        archive.</b></font>__salt__,
        {
            "file.directory_exists": mock_false,
            "file.file_exists": mock_false,
            "state.single": state_single_mock,
            "file.makedirs": mock_true,
            "cmd.run_all": mock_run,
            "archive.list": list_mock,
            "file.source_list": mock_source_list,
        },
    ), patch.dict(
        archive.__states__, {"file.directory": mock_true}
    ), patch.object(
        os.path, "isfile", isfile_mock
    ), patch(
        "salt.utils.path.which", MagicMock(return_value=True)
    ):
        for test_opts, ret_opts in zip(test_tar_opts, ret_tar_opts):
            archive.extracted(
                tmp_dir, source, options=test_opts, enforce_toplevel=False
            )
            ret_opts.append(source)
            mock_run.assert_called_with(
                ret_opts, cwd=tmp_dir + os.sep, python_shell=False
            )
def test_tar_gnutar():
    gnutar = MagicMock(return_value="tar (GNU tar)")
    source = "/tmp/foo.tar.gz"
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={"local": {"result": True}})
    run_all = MagicMock(
        return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
    )
<a name="3"></a>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
            "files": ["stdout"],
            "links": [],
            "top_level_dirs": [],
            "top_level_files": ["stdout"],
            "top_level_links": [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)
    with patch.dict(
        archive.__salt__,
        {
            "cmd.run": gnutar,
            "file.directory_exists": mock_false,
            "file.file_exists": mock_false,
            "state.single": state_single_mock,
            "file.makedirs": mock_true,
            "cmd.run_all": run_all,
            "archive.list": list_mock,
            "file.source_list": mock_source_list,
        },
    ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
        os.path, "isfile", isfile_mock
    ), patch(
        "salt.utils.path.which", MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + "tmp", "out"),
            source,
            options="xvzf",
            enforce_toplevel=False,
            keep=True,
        )
        assert ret["changes"]["extracted_files"] == ["stdout"]
def test_tar_bsdtar():
    bsdtar = MagicMock(return_value="tar (bsdtar)")
    source = "/tmp/foo.tar.gz"
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={"local": {"result": True}})
    run_all = MagicMock(
        return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
    )
<a name="2"></a>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
            "files": ["stderr"],
            "links": [],
            "top_level_dirs": [],
            "top_level_files": ["stderr"],
            "top_level_links": [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)
    with patch.dict(
        archive.__salt__,
        {
            "cmd.run": bsdtar,
            "file.directory_exists": mock_false,
            "file.file_exists": mock_false,
            "state.single": state_single_mock,
            "file.makedirs": mock_true,
            "cmd.run_all": run_all,
            "archive.list": list_mock,
            "file.source_list": mock_source_list,
        },
    ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
        os.path, "isfile", isfile_mock
    ), patch(
        "salt.utils.path.which", MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + "tmp", "out"),
            source,
            options="xvzf",
            enforce_toplevel=False,
            keep=True,
        )
        assert ret["changes"]["extracted_files"] == ["stderr"]
def test_tar_bsdtar_with_trim_output():
    bsdtar = MagicMock(return_value="tar (bsdtar)")
    source = "/tmp/foo.tar.gz"
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={"local": {"result": True}})
    run_all = MagicMock(
        return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
    )
<a name="1"></a>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
            "files": ["stderr"],
            "links": [],
            "top_level_dirs": [],
            "top_level_files": ["stderr"],
            "top_level_links": [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)
    with patch.dict(
        archive.__salt__,
        {
            "cmd.run": bsdtar,
            "file.directory_exists": mock_false,
            "file.file_exists": mock_false,
            "state.single": state_single_mock,
            "file.makedirs": mock_true,
            "cmd.run_all": run_all,
            "archive.list": list_mock,
            "file.source_list": mock_source_list,
        },
    ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
        os.path, "isfile", isfile_mock
    ), patch(
        "salt.utils.path.which", MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + "tmp", "out"),
            source,
            options="xvzf",
            enforce_toplevel=False,
            keep_source=True,
            trim_output=1,
        )
        assert ret["changes"]["extracted_files"] == ["stderr"]
        assert ret["comment"].endswith("Output was trimmed to 1 number of lines")
def test_extracted_when_if_missing_path_exists():
    name = if_missing = "/tmp/foo"
    source = "salt://foo.bar.tar"
    with patch.object(os.path, "exists", MagicMock(return_value=True)):
        ret = archive.extracted(name, source=source, if_missing=if_missing)
        assert ret["result"], ret
        assert ret["comment"] == "Path {} exists".format(if_missing)
def test_clean_parent_conflict():
    gnutar = MagicMock(return_value="tar (GNU tar)")
    source = "/tmp/foo.tar.gz"
    ret_comment = "Only one of 'clean' and 'clean_parent' can be set to True"
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={"local": {"result": True}})
    run_all = MagicMock(
        return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
    )
<a name="0"></a>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
            "files": ["stdout"],
            "links": [],
            "top_level_dirs": [],
            "top_level_files": ["stdout"],
            "top_level_links": [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)
    with patch.dict(
        archive.__salt__,
        {
            "cmd.run": gnutar,
            "file.directory_exists": mock_false,
            "file.file_exists": mock_false,
            "state.single": state_single_mock,
            "file.makedirs": mock_true,
            "cmd.run_all": run_all,
            "archive.list": list_mock,
            "file.source_list": mock_source_list,
        },
    ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
        os.path, "isfile", isfile_mock
    ), patch(
        "salt.utils.path.which", MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + "tmp", "out"),
            source,
            options="xvzf",
            enforce_toplevel=False,
            clean=True,
            clean_parent=True,
            keep=True,
        )
        assert ret["result"] is False
        assert ret["changes"] == {}
        assert ret["comment"] == ret_comment
def test_skip_files_list_verify_conflict():
    gnutar = MagicMock(return_value="tar (GNU tar)")
    source = "/tmp/foo.tar.gz"
    ret_comment = (
        'Only one of "skip_files_list_verify" and "skip_verify" can be set to True'
    )
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={"local": {"result": True}})
    run_all = MagicMock(
        return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
    )
    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            "dirs": [],
            "files": ["stdout"],
            "links": [],
            "top_level_dirs": [],
            "top_level_files": ["stdout"],
            "top_level_links": [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)
    with patch.dict(
        archive.__salt__,
        {
            "cmd.run": gnutar,
            "file.directory_exists": mock_false,
            "file.file_exists": mock_false,
            "state.single": state_single_mock,
            "file.makedirs": mock_true,
            "cmd.run_all": run_all,
            "archive.list": list_mock,
            "file.source_list": mock_source_list,
        },
    ), patch.dict(archive.__states__, {"file.directory": mock_true}), patch.object(
        os.path, "isfile", isfile_mock
    ), patch(
        "salt.utils.path.which", MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + "tmp", "out"),
            source,
            options="xvzf",
            enforce_toplevel=False,
            clean=True,
            skip_files_list_verify=True,
            skip_verify=True,
            keep=True,
        )
        assert ret["result"] is False
        assert ret["changes"] == {}
        assert ret["comment"] == ret_comment
def test_skip_files_list_verify_success():
    if salt.utils.platform.is_windows():
        source = "C:\\tmp\\foo.tar.gz"
        tmp_dir = "C:\\tmp\\test_extracted_tar"
    elif salt.utils.platform.is_darwin():
        source = "/private/tmp/foo.tar.gz"
        tmp_dir = "/private/tmp/test_extracted_tar"
    else:
        source = "/tmp/foo.tar.gz"
        tmp_dir = "/tmp/test_extracted_tar"
    expected_comment = (
        "Archive {} existing source sum is the same as the "
        "expected one and skip_files_list_verify argument "
        "was set to True. Extraction is not needed".format(source)
    )
    expected_ret = {
        "name": tmp_dir,
        "result": True,
        "changes": {},
        "comment": expected_comment,
    }
    mock_true = MagicMock(return_value=True)
    mock_false = MagicMock(return_value=False)
    mock_cached = MagicMock(return_value="{}/{}".format(tmp_dir, source))
    source_sum = {"hsum": "testhash", "hash_type": "sha256"}
    mock_hash = MagicMock(return_value=source_sum)
    mock_source_list = MagicMock(return_value=(source, None))
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)
    with patch("salt.states.archive._read_cached_checksum", mock_hash):
        with patch.dict(
            archive.__opts__,
            {"test": False, "cachedir": tmp_dir, "hash_type": "sha256"},
        ), patch.dict(
            archive.__salt__,
            {
                "file.directory_exists": mock_false,
                "file.get_source_sum": mock_hash,
                "file.check_hash": mock_true,
                "cp.is_cached": mock_cached,
                "file.source_list": mock_source_list,
            },
        ), patch.object(
            os.path, "isfile", isfile_mock
        ):
            ret = archive.extracted(
                tmp_dir,
                source,
                source_hash="testhash",
                skip_files_list_verify=True,
                enforce_toplevel=False,
            )
            assert ret == expected_ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
