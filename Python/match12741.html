<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_bluez_bluetooth.py & test_archive_3.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_bluez_bluetooth.py & test_archive_3.py
      </h3>
      <h1 align="center">
        13.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_bluez_bluetooth.py (16.348774%)<TH>test_archive_3.py (11.214953%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match12741-0.html#0',2,'match12741-1.html#0',3)" NAME="0">(182-186)<TD><A HREF="javascript:ZweiFrames('match12741-0.html#0',2,'match12741-1.html#0',3)" NAME="0">(326-348)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match12741-0.html#1',2,'match12741-1.html#1',3)" NAME="1">(148-152)<TD><A HREF="javascript:ZweiFrames('match12741-0.html#1',2,'match12741-1.html#1',3)" NAME="1">(254-276)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match12741-0.html#2',2,'match12741-1.html#2',3)" NAME="2">(136-140)<TD><A HREF="javascript:ZweiFrames('match12741-0.html#2',2,'match12741-1.html#2',3)" NAME="2">(202-224)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match12741-0.html#3',2,'match12741-1.html#3',3)" NAME="3">(114-118)<TD><A HREF="javascript:ZweiFrames('match12741-0.html#3',2,'match12741-1.html#3',3)" NAME="3">(150-172)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match12741-0.html#4',2,'match12741-1.html#4',3)" NAME="4">(92-96)<TD><A HREF="javascript:ZweiFrames('match12741-0.html#4',2,'match12741-1.html#4',3)" NAME="4">(97-107)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bluez_bluetooth.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Rahul Handay &lt;rahulha@saltstack.com&gt;
&quot;&quot;&quot;


import salt.modules.bluez_bluetooth as bluez
import salt.utils.validate.net
from salt.exceptions import CommandExecutionError
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import MagicMock, patch
from tests.support.unit import TestCase


class MockBluetooth:
    &quot;&quot;&quot;
    Mock class for bluetooth
    &quot;&quot;&quot;

    def __init__(self):
        pass

    @staticmethod
    def discover_devices(lookup_names):
        &quot;&quot;&quot;
        Mock method to return all Discoverable devices
        &quot;&quot;&quot;
        return [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]]


class BluezTestCase(TestCase, LoaderModuleMockMixin):
    &quot;&quot;&quot;
    Test cases for salt.modules.bluez
    &quot;&quot;&quot;

    def setup_loader_modules(self):
        return {bluez: {&quot;bluetooth&quot;: MockBluetooth()}}

    def test_version(self):
        &quot;&quot;&quot;
        Test if return bluetooth version
        &quot;&quot;&quot;
        mock = MagicMock(return_value=&quot;5.7&quot;)
        with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
            self.assertDictEqual(
                bluez.version(),
                {&quot;PyBluez&quot;: &quot;&lt;= 0.18 (Unknown, but installed)&quot;, &quot;Bluez&quot;: &quot;5.7&quot;},
            )

    def test_address_(self):
        &quot;&quot;&quot;
        Test of getting address of bluetooth adapter
        &quot;&quot;&quot;
        mock = MagicMock(return_value=&quot;hci : hci0&quot;)
        with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
            self.assertDictEqual(
                bluez.address_(),
                {&quot;hci &quot;: {&quot;device&quot;: &quot;hci &quot;, &quot;path&quot;: &quot;/sys/class/bluetooth/hci &quot;}},
            )

    def test_power(self):
        &quot;&quot;&quot;
        Test of getting address of bluetooth adapter
        &quot;&quot;&quot;
        mock = MagicMock(return_value={})
        with patch.object(bluez, &quot;address_&quot;, mock):
            self.assertRaises(CommandExecutionError, bluez.power, &quot;hci0&quot;, &quot;on&quot;)

        mock = MagicMock(return_value={&quot;hci0&quot;: {&quot;device&quot;: &quot;hci0&quot;, &quot;power&quot;: &quot;on&quot;}})
        with patch.object(bluez, &quot;address_&quot;, mock):
            mock = MagicMock(return_value=&quot;&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertTrue(bluez.power(&quot;hci0&quot;, &quot;on&quot;))

        mock = MagicMock(return_value={&quot;hci0&quot;: {&quot;device&quot;: &quot;hci0&quot;, &quot;power&quot;: &quot;on&quot;}})
        with patch.object(bluez, &quot;address_&quot;, mock):
            mock = MagicMock(return_value=&quot;&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertFalse(bluez.power(&quot;hci0&quot;, &quot;off&quot;))

    def test_discoverable(self):
        &quot;&quot;&quot;
        Test of enabling bluetooth device
        &quot;&quot;&quot;
        mock = MagicMock(
            side_effect=[
                {},
                {&quot;hci0&quot;: {&quot;device&quot;: &quot;hci0&quot;, &quot;power&quot;: &quot;on&quot;}},
                {&quot;hci0&quot;: {&quot;device&quot;: &quot;hci0&quot;, &quot;power&quot;: &quot;on&quot;}},
<A NAME="4"></A>            ]
        )
        with patch.object(bluez, &quot;address_&quot;, mock):
            self.assertRaises(CommandExecutionError, bluez<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match12741-1.html#4',3,'match12741-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.discoverable, &quot;hci0&quot;)

            mock = MagicMock(return_value=&quot;UP RUNNING ISCAN&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertTrue(bluez.</B></FONT>discoverable(&quot;hci0&quot;))

            mock = MagicMock(return_value=&quot;&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertFalse(bluez.discoverable(&quot;hci0&quot;))

    def test_noscan(self):
        &quot;&quot;&quot;
        Test of turning off of scanning modes
        &quot;&quot;&quot;
        mock = MagicMock(
            side_effect=[
                {},
                {&quot;hci0&quot;: {&quot;device&quot;: &quot;hci0&quot;, &quot;power&quot;: &quot;on&quot;}},
                {&quot;hci0&quot;: {&quot;device&quot;: &quot;hci0&quot;, &quot;power&quot;: &quot;on&quot;}},
<A NAME="3"></A>            ]
        )
        with patch.object(bluez, &quot;address_&quot;, mock):
            self.assertRaises(CommandExecutionError, bluez<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match12741-1.html#3',3,'match12741-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.noscan, &quot;hci0&quot;)

            mock = MagicMock(return_value=&quot;SCAN&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertFalse(bluez.</B></FONT>noscan(&quot;hci0&quot;))

            mock = MagicMock(return_value=&quot;&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertTrue(bluez.noscan(&quot;hci0&quot;))

    def test_scan(self):
        &quot;&quot;&quot;
        Test of scanning of bluetooth devices
        &quot;&quot;&quot;
        self.assertListEqual(bluez.scan(), [{&quot;a&quot;: &quot;b&quot;}, {&quot;d&quot;: &quot;e&quot;}])

    def test_block(self):
        &quot;&quot;&quot;
        Test of blocking specific bluetooth device
<A NAME="2"></A>        &quot;&quot;&quot;
        mock = MagicMock(side_effect=[False, True])
        with patch.object(salt.utils.validate.net, &quot;mac&quot;, mock):
            self.assertRaises(CommandExecutionError, bluez<FONT color="#980517"><A HREF="javascript:ZweiFrames('match12741-1.html#2',3,'match12741-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.block, &quot;DE:AD:BE:EF:CA:ZE&quot;)

            mock = MagicMock(return_value=&quot;&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertIsNone(bluez.</B></FONT>block(&quot;DE:AD:BE:EF:CA:FE&quot;))

    def test_unblock(self):
        &quot;&quot;&quot;
        Test to unblock specific bluetooth device
<A NAME="1"></A>        &quot;&quot;&quot;
        mock = MagicMock(side_effect=[False, True])
        with patch.object(salt.utils.validate.net, &quot;mac&quot;, mock):
            self.assertRaises(CommandExecutionError, bluez<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match12741-1.html#1',3,'match12741-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.block, &quot;DE:AD:BE:EF:CA:ZE&quot;)

            mock = MagicMock(return_value=&quot;&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertIsNone(bluez.</B></FONT>unblock(&quot;DE:AD:BE:EF:CA:FE&quot;))

    def test_pair(self):
        &quot;&quot;&quot;
        Test to pair bluetooth adapter with a device
        &quot;&quot;&quot;
        mock = MagicMock(side_effect=[False, True, True])
        with patch.object(salt.utils.validate.net, &quot;mac&quot;, mock):
            self.assertRaises(
                CommandExecutionError, bluez.pair, &quot;DE:AD:BE:EF:CA:FE&quot;, &quot;1234&quot;
            )

            self.assertRaises(
                CommandExecutionError, bluez.pair, &quot;DE:AD:BE:EF:CA:FE&quot;, &quot;abcd&quot;
            )

            mock = MagicMock(return_value={&quot;device&quot;: &quot;hci0&quot;})
            with patch.object(bluez, &quot;address_&quot;, mock):
                mock = MagicMock(return_value=&quot;Ok&quot;)
                with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                    self.assertListEqual(
                        bluez.pair(&quot;DE:AD:BE:EF:CA:FE&quot;, &quot;1234&quot;), [&quot;Ok&quot;]
                    )

    def test_unpair(self):
        &quot;&quot;&quot;
        Test to unpair bluetooth adaptor with a device
<A NAME="0"></A>        &quot;&quot;&quot;
        mock = MagicMock(side_effect=[False, True])
        with patch.object(salt.utils.validate.net, &quot;mac&quot;, mock):
            self.assertRaises(CommandExecutionError, bluez<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match12741-1.html#0',3,'match12741-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.unpair, &quot;DE:AD:BE:EF:CA:FE&quot;)

            mock = MagicMock(return_value=&quot;Ok&quot;)
            with patch.dict(bluez.__salt__, {&quot;cmd.run&quot;: mock}):
                self.assertListEqual(bluez.</B></FONT>unpair(&quot;DE:AD:BE:EF:CA:FE&quot;), [&quot;Ok&quot;])

    def test_start(self):
        &quot;&quot;&quot;
        Test to start bluetooth service
        &quot;&quot;&quot;
        mock = MagicMock(return_value=&quot;Ok&quot;)
        with patch.dict(bluez.__salt__, {&quot;service.start&quot;: mock}):
            self.assertEqual(bluez.start(), &quot;Ok&quot;)

    def test_stop(self):
        &quot;&quot;&quot;
        Test to stop bluetooth service
        &quot;&quot;&quot;
        mock = MagicMock(return_value=&quot;Ok&quot;)
        with patch.dict(bluez.__salt__, {&quot;service.stop&quot;: mock}):
            self.assertEqual(bluez.stop(), &quot;Ok&quot;)
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
    :codeauthor: Alexander Schwartz &lt;alexander.schwartz@gmx.net&gt;
&quot;&quot;&quot;


import os

import pytest
import salt.states.archive as archive
import salt.utils.platform
from tests.support.mock import MagicMock, patch


@pytest.fixture
def configure_loader_modules():
    return {
        archive: {
            &quot;__grains__&quot;: {&quot;os&quot;: &quot;FooOS!&quot;},
            &quot;__opts__&quot;: {&quot;cachedir&quot;: &quot;/tmp&quot;, &quot;test&quot;: False, &quot;hash_type&quot;: &quot;sha256&quot;},
            &quot;__env__&quot;: &quot;test&quot;,
        }
    }


def _isfile_side_effect(path):
    &quot;&quot;&quot;
    MagicMock side_effect for os.path.isfile(). We don't want to use dict.get
    here because we want the test to fail if there's a path we haven't
    accounted for, so that we can add it.

    NOTE: This may fall over on some platforms if /usr/bin/tar does not exist.
    If so, just add an entry in the dictionary for the path being used for tar.
    &quot;&quot;&quot;
    if salt.utils.platform.is_windows():
        path = path.lower()
    d = {
        &quot;/tmp/foo.tar.gz&quot;: True,
        &quot;c:\\tmp\\foo.tar.gz&quot;: True,
        &quot;/private/tmp/foo.tar.gz&quot;: True,
        &quot;/tmp/out&quot;: False,
        &quot;\\tmp\\out&quot;: False,
        &quot;/usr/bin/tar&quot;: True,
        &quot;/bin/tar&quot;: True,
        &quot;/tmp/test_extracted_tar&quot;: False,
        &quot;c:\\tmp\\test_extracted_tar&quot;: False,
        &quot;/private/tmp/test_extracted_tar&quot;: False,
    }
    return d[path]


def test_extracted_tar():
    &quot;&quot;&quot;
    archive.extracted tar options
    &quot;&quot;&quot;

    if salt.utils.platform.is_windows():
        source = &quot;C:\\tmp\\foo.tar.gz&quot;
        tmp_dir = &quot;C:\\tmp\\test_extracted_tar&quot;
    elif salt.utils.platform.is_darwin():
        source = &quot;/private/tmp/foo.tar.gz&quot;
        tmp_dir = &quot;/private/tmp/test_extracted_tar&quot;
    else:
        source = &quot;/tmp/foo.tar.gz&quot;
        tmp_dir = &quot;/tmp/test_extracted_tar&quot;
    test_tar_opts = [
        &quot;--no-anchored foo&quot;,
        &quot;v -p --opt&quot;,
        &quot;-v -p&quot;,
        &quot;--long-opt -z&quot;,
        &quot;z -v -weird-long-opt arg&quot;,
    ]
    ret_tar_opts = [
        [&quot;tar&quot;, &quot;xv&quot;, &quot;--no-anchored&quot;, &quot;foo&quot;, &quot;-f&quot;],
        [&quot;tar&quot;, &quot;xv&quot;, &quot;-p&quot;, &quot;--opt&quot;, &quot;-f&quot;],
        [&quot;tar&quot;, &quot;xv&quot;, &quot;-p&quot;, &quot;-f&quot;],
        [&quot;tar&quot;, &quot;xv&quot;, &quot;--long-opt&quot;, &quot;-z&quot;, &quot;-f&quot;],
        [&quot;tar&quot;, &quot;xvz&quot;, &quot;-weird-long-opt&quot;, &quot;arg&quot;, &quot;-f&quot;],
    ]

    mock_true = MagicMock(return_value=True)
    mock_false = MagicMock(return_value=False)
    ret = {
        &quot;stdout&quot;: [&quot;cheese&quot;, &quot;ham&quot;, &quot;saltines&quot;],
        &quot;stderr&quot;: &quot;biscuits&quot;,
        &quot;retcode&quot;: &quot;31337&quot;,
        &quot;pid&quot;: &quot;1337&quot;,
    }
    mock_run = MagicMock(return_value=ret)
    mock_source_list = MagicMock(return_value=(source, None))
    state_single_mock = MagicMock(return_value={&quot;local&quot;: {&quot;result&quot;: True}})
    list_mock = MagicMock(
        return_value={
            &quot;dirs&quot;: [],
<A NAME="4"></A>            &quot;files&quot;: [&quot;cheese&quot;, &quot;saltines&quot;],
            &quot;links&quot;: [&quot;ham&quot;],
            &quot;top_level_dirs&quot;: [],
            &quot;top_level_files&quot;: [<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12741-0.html#4',2,'match12741-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;cheese&quot;, &quot;saltines&quot;],
            &quot;top_level_links&quot;: [&quot;ham&quot;],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)

    with patch.dict(
        archive.__opts__,
        {&quot;test&quot;: False, &quot;cachedir&quot;: tmp_dir, &quot;hash_type&quot;: &quot;sha256&quot;},
    ), patch.dict(
        archive.</B></FONT>__salt__,
        {
            &quot;file.directory_exists&quot;: mock_false,
            &quot;file.file_exists&quot;: mock_false,
            &quot;state.single&quot;: state_single_mock,
            &quot;file.makedirs&quot;: mock_true,
            &quot;cmd.run_all&quot;: mock_run,
            &quot;archive.list&quot;: list_mock,
            &quot;file.source_list&quot;: mock_source_list,
        },
    ), patch.dict(
        archive.__states__, {&quot;file.directory&quot;: mock_true}
    ), patch.object(
        os.path, &quot;isfile&quot;, isfile_mock
    ), patch(
        &quot;salt.utils.path.which&quot;, MagicMock(return_value=True)
    ):

        for test_opts, ret_opts in zip(test_tar_opts, ret_tar_opts):
            archive.extracted(
                tmp_dir, source, options=test_opts, enforce_toplevel=False
            )
            ret_opts.append(source)
            mock_run.assert_called_with(
                ret_opts, cwd=tmp_dir + os.sep, python_shell=False
            )


def test_tar_gnutar():
    &quot;&quot;&quot;
    Tests the call of extraction with gnutar
    &quot;&quot;&quot;
    gnutar = MagicMock(return_value=&quot;tar (GNU tar)&quot;)
    source = &quot;/tmp/foo.tar.gz&quot;
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={&quot;local&quot;: {&quot;result&quot;: True}})
    run_all = MagicMock(
        return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;stdout&quot;, &quot;stderr&quot;: &quot;stderr&quot;}
    )
<A NAME="3"></A>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12741-0.html#3',2,'match12741-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;dirs&quot;: [],
            &quot;files&quot;: [&quot;stdout&quot;],
            &quot;links&quot;: [],
            &quot;top_level_dirs&quot;: [],
            &quot;top_level_files&quot;: [&quot;stdout&quot;],
            &quot;top_level_links&quot;: [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)

    with patch.dict(
        archive.__salt__,
        {
            &quot;cmd.run&quot;: gnutar,
            &quot;file.directory_exists&quot;: mock_false,
            &quot;file.file_exists&quot;: mock_false,
            &quot;state.single&quot;: state_single_mock,
            &quot;file.makedirs&quot;: mock_true,
            &quot;cmd.run_all&quot;: run_all,
            &quot;archive.list&quot;: list_mock,
            &quot;file.source_list&quot;: mock_source_list,
        },
    ), patch.dict(archive.</B></FONT>__states__, {&quot;file.directory&quot;: mock_true}), patch.object(
        os.path, &quot;isfile&quot;, isfile_mock
    ), patch(
        &quot;salt.utils.path.which&quot;, MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + &quot;tmp&quot;, &quot;out&quot;),
            source,
            options=&quot;xvzf&quot;,
            enforce_toplevel=False,
            keep=True,
        )
        assert ret[&quot;changes&quot;][&quot;extracted_files&quot;] == [&quot;stdout&quot;]


def test_tar_bsdtar():
    &quot;&quot;&quot;
    Tests the call of extraction with bsdtar
    &quot;&quot;&quot;
    bsdtar = MagicMock(return_value=&quot;tar (bsdtar)&quot;)
    source = &quot;/tmp/foo.tar.gz&quot;
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={&quot;local&quot;: {&quot;result&quot;: True}})
    run_all = MagicMock(
        return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;stdout&quot;, &quot;stderr&quot;: &quot;stderr&quot;}
    )
<A NAME="2"></A>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12741-0.html#2',2,'match12741-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;dirs&quot;: [],
            &quot;files&quot;: [&quot;stderr&quot;],
            &quot;links&quot;: [],
            &quot;top_level_dirs&quot;: [],
            &quot;top_level_files&quot;: [&quot;stderr&quot;],
            &quot;top_level_links&quot;: [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)

    with patch.dict(
        archive.__salt__,
        {
            &quot;cmd.run&quot;: bsdtar,
            &quot;file.directory_exists&quot;: mock_false,
            &quot;file.file_exists&quot;: mock_false,
            &quot;state.single&quot;: state_single_mock,
            &quot;file.makedirs&quot;: mock_true,
            &quot;cmd.run_all&quot;: run_all,
            &quot;archive.list&quot;: list_mock,
            &quot;file.source_list&quot;: mock_source_list,
        },
    ), patch.dict(archive.</B></FONT>__states__, {&quot;file.directory&quot;: mock_true}), patch.object(
        os.path, &quot;isfile&quot;, isfile_mock
    ), patch(
        &quot;salt.utils.path.which&quot;, MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + &quot;tmp&quot;, &quot;out&quot;),
            source,
            options=&quot;xvzf&quot;,
            enforce_toplevel=False,
            keep=True,
        )
        assert ret[&quot;changes&quot;][&quot;extracted_files&quot;] == [&quot;stderr&quot;]


def test_tar_bsdtar_with_trim_output():
    &quot;&quot;&quot;
    Tests the call of extraction with bsdtar with trim_output
    &quot;&quot;&quot;
    bsdtar = MagicMock(return_value=&quot;tar (bsdtar)&quot;)
    source = &quot;/tmp/foo.tar.gz&quot;
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={&quot;local&quot;: {&quot;result&quot;: True}})
    run_all = MagicMock(
        return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;stdout&quot;, &quot;stderr&quot;: &quot;stderr&quot;}
    )
<A NAME="1"></A>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12741-0.html#1',2,'match12741-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;dirs&quot;: [],
            &quot;files&quot;: [&quot;stderr&quot;],
            &quot;links&quot;: [],
            &quot;top_level_dirs&quot;: [],
            &quot;top_level_files&quot;: [&quot;stderr&quot;],
            &quot;top_level_links&quot;: [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)

    with patch.dict(
        archive.__salt__,
        {
            &quot;cmd.run&quot;: bsdtar,
            &quot;file.directory_exists&quot;: mock_false,
            &quot;file.file_exists&quot;: mock_false,
            &quot;state.single&quot;: state_single_mock,
            &quot;file.makedirs&quot;: mock_true,
            &quot;cmd.run_all&quot;: run_all,
            &quot;archive.list&quot;: list_mock,
            &quot;file.source_list&quot;: mock_source_list,
        },
    ), patch.dict(archive.</B></FONT>__states__, {&quot;file.directory&quot;: mock_true}), patch.object(
        os.path, &quot;isfile&quot;, isfile_mock
    ), patch(
        &quot;salt.utils.path.which&quot;, MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + &quot;tmp&quot;, &quot;out&quot;),
            source,
            options=&quot;xvzf&quot;,
            enforce_toplevel=False,
            keep_source=True,
            trim_output=1,
        )
        assert ret[&quot;changes&quot;][&quot;extracted_files&quot;] == [&quot;stderr&quot;]
        assert ret[&quot;comment&quot;].endswith(&quot;Output was trimmed to 1 number of lines&quot;)


def test_extracted_when_if_missing_path_exists():
    &quot;&quot;&quot;
    When if_missing exists, we should exit without making any changes.

    NOTE: We're not mocking the __salt__ dunder because if we actually run
    any functions from that dunder, we're doing something wrong. So, in
    those cases we'll just let it raise a KeyError and cause the test to
    fail.
    &quot;&quot;&quot;
    name = if_missing = &quot;/tmp/foo&quot;
    source = &quot;salt://foo.bar.tar&quot;
    with patch.object(os.path, &quot;exists&quot;, MagicMock(return_value=True)):
        ret = archive.extracted(name, source=source, if_missing=if_missing)
        assert ret[&quot;result&quot;], ret
        assert ret[&quot;comment&quot;] == &quot;Path {} exists&quot;.format(if_missing)


def test_clean_parent_conflict():
    &quot;&quot;&quot;
    Tests the call of extraction with gnutar with both clean_parent plus clean set to True
    &quot;&quot;&quot;
    gnutar = MagicMock(return_value=&quot;tar (GNU tar)&quot;)
    source = &quot;/tmp/foo.tar.gz&quot;
    ret_comment = &quot;Only one of 'clean' and 'clean_parent' can be set to True&quot;
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={&quot;local&quot;: {&quot;result&quot;: True}})
    run_all = MagicMock(
        return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;stdout&quot;, &quot;stderr&quot;: &quot;stderr&quot;}
    )
<A NAME="0"></A>    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12741-0.html#0',2,'match12741-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;dirs&quot;: [],
            &quot;files&quot;: [&quot;stdout&quot;],
            &quot;links&quot;: [],
            &quot;top_level_dirs&quot;: [],
            &quot;top_level_files&quot;: [&quot;stdout&quot;],
            &quot;top_level_links&quot;: [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)

    with patch.dict(
        archive.__salt__,
        {
            &quot;cmd.run&quot;: gnutar,
            &quot;file.directory_exists&quot;: mock_false,
            &quot;file.file_exists&quot;: mock_false,
            &quot;state.single&quot;: state_single_mock,
            &quot;file.makedirs&quot;: mock_true,
            &quot;cmd.run_all&quot;: run_all,
            &quot;archive.list&quot;: list_mock,
            &quot;file.source_list&quot;: mock_source_list,
        },
    ), patch.dict(archive.</B></FONT>__states__, {&quot;file.directory&quot;: mock_true}), patch.object(
        os.path, &quot;isfile&quot;, isfile_mock
    ), patch(
        &quot;salt.utils.path.which&quot;, MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + &quot;tmp&quot;, &quot;out&quot;),
            source,
            options=&quot;xvzf&quot;,
            enforce_toplevel=False,
            clean=True,
            clean_parent=True,
            keep=True,
        )
        assert ret[&quot;result&quot;] is False
        assert ret[&quot;changes&quot;] == {}
        assert ret[&quot;comment&quot;] == ret_comment


def test_skip_files_list_verify_conflict():
    &quot;&quot;&quot;
    Tests the call of extraction with both skip_files_list_verify and skip_verify set to True
    &quot;&quot;&quot;
    gnutar = MagicMock(return_value=&quot;tar (GNU tar)&quot;)
    source = &quot;/tmp/foo.tar.gz&quot;
    ret_comment = (
        'Only one of &quot;skip_files_list_verify&quot; and &quot;skip_verify&quot; can be set to True'
    )
    mock_false = MagicMock(return_value=False)
    mock_true = MagicMock(return_value=True)
    state_single_mock = MagicMock(return_value={&quot;local&quot;: {&quot;result&quot;: True}})
    run_all = MagicMock(
        return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;stdout&quot;, &quot;stderr&quot;: &quot;stderr&quot;}
    )
    mock_source_list = MagicMock(return_value=(source, None))
    list_mock = MagicMock(
        return_value={
            &quot;dirs&quot;: [],
            &quot;files&quot;: [&quot;stdout&quot;],
            &quot;links&quot;: [],
            &quot;top_level_dirs&quot;: [],
            &quot;top_level_files&quot;: [&quot;stdout&quot;],
            &quot;top_level_links&quot;: [],
        }
    )
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)

    with patch.dict(
        archive.__salt__,
        {
            &quot;cmd.run&quot;: gnutar,
            &quot;file.directory_exists&quot;: mock_false,
            &quot;file.file_exists&quot;: mock_false,
            &quot;state.single&quot;: state_single_mock,
            &quot;file.makedirs&quot;: mock_true,
            &quot;cmd.run_all&quot;: run_all,
            &quot;archive.list&quot;: list_mock,
            &quot;file.source_list&quot;: mock_source_list,
        },
    ), patch.dict(archive.__states__, {&quot;file.directory&quot;: mock_true}), patch.object(
        os.path, &quot;isfile&quot;, isfile_mock
    ), patch(
        &quot;salt.utils.path.which&quot;, MagicMock(return_value=True)
    ):
        ret = archive.extracted(
            os.path.join(os.sep + &quot;tmp&quot;, &quot;out&quot;),
            source,
            options=&quot;xvzf&quot;,
            enforce_toplevel=False,
            clean=True,
            skip_files_list_verify=True,
            skip_verify=True,
            keep=True,
        )
        assert ret[&quot;result&quot;] is False
        assert ret[&quot;changes&quot;] == {}
        assert ret[&quot;comment&quot;] == ret_comment


def test_skip_files_list_verify_success():
    &quot;&quot;&quot;
    Test that if the local and expected source hash are the same we won't do anything.
    &quot;&quot;&quot;

    if salt.utils.platform.is_windows():
        source = &quot;C:\\tmp\\foo.tar.gz&quot;
        tmp_dir = &quot;C:\\tmp\\test_extracted_tar&quot;
    elif salt.utils.platform.is_darwin():
        source = &quot;/private/tmp/foo.tar.gz&quot;
        tmp_dir = &quot;/private/tmp/test_extracted_tar&quot;
    else:
        source = &quot;/tmp/foo.tar.gz&quot;
        tmp_dir = &quot;/tmp/test_extracted_tar&quot;

    expected_comment = (
        &quot;Archive {} existing source sum is the same as the &quot;
        &quot;expected one and skip_files_list_verify argument &quot;
        &quot;was set to True. Extraction is not needed&quot;.format(source)
    )
    expected_ret = {
        &quot;name&quot;: tmp_dir,
        &quot;result&quot;: True,
        &quot;changes&quot;: {},
        &quot;comment&quot;: expected_comment,
    }
    mock_true = MagicMock(return_value=True)
    mock_false = MagicMock(return_value=False)
    mock_cached = MagicMock(return_value=&quot;{}/{}&quot;.format(tmp_dir, source))
    source_sum = {&quot;hsum&quot;: &quot;testhash&quot;, &quot;hash_type&quot;: &quot;sha256&quot;}
    mock_hash = MagicMock(return_value=source_sum)
    mock_source_list = MagicMock(return_value=(source, None))
    isfile_mock = MagicMock(side_effect=_isfile_side_effect)

    with patch(&quot;salt.states.archive._read_cached_checksum&quot;, mock_hash):
        with patch.dict(
            archive.__opts__,
            {&quot;test&quot;: False, &quot;cachedir&quot;: tmp_dir, &quot;hash_type&quot;: &quot;sha256&quot;},
        ), patch.dict(
            archive.__salt__,
            {
                &quot;file.directory_exists&quot;: mock_false,
                &quot;file.get_source_sum&quot;: mock_hash,
                &quot;file.check_hash&quot;: mock_true,
                &quot;cp.is_cached&quot;: mock_cached,
                &quot;file.source_list&quot;: mock_source_list,
            },
        ), patch.object(
            os.path, &quot;isfile&quot;, isfile_mock
        ):

            ret = archive.extracted(
                tmp_dir,
                source,
                source_hash=&quot;testhash&quot;,
                skip_files_list_verify=True,
                enforce_toplevel=False,
            )
            assert ret == expected_ret
</PRE>
</div>
  </div>
</body>
</html>
