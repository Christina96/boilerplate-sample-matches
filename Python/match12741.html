<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_bluez_bluetooth.py &amp; test_archive_3.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_bluez_bluetooth.py &amp; test_archive_3.py
      </h3>
<h1 align="center">
        13.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_bluez_bluetooth.py (16.348774%)<th>test_archive_3.py (11.214953%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(182-186)<td><a href="#" name="0">(326-348)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(148-152)<td><a href="#" name="1">(254-276)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(136-140)<td><a href="#" name="2">(202-224)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(114-118)<td><a href="#" name="3">(150-172)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(92-96)<td><a href="#" name="4">(97-107)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_bluez_bluetooth.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.modules.bluez_bluetooth as bluez
2 import salt.utils.validate.net
3 from salt.exceptions import CommandExecutionError
4 from tests.support.mixins import LoaderModuleMockMixin
5 from tests.support.mock import MagicMock, patch
6 from tests.support.unit import TestCase
7 class MockBluetooth:
8     def __init__(self):
9         pass
10     @staticmethod
11     def discover_devices(lookup_names):
12         return [["a", "b", "c"], ["d", "e", "f"]]
13 class BluezTestCase(TestCase, LoaderModuleMockMixin):
14     def setup_loader_modules(self):
15         return {bluez: {"bluetooth": MockBluetooth()}}
16     def test_version(self):
17         mock = MagicMock(return_value="5.7")
18         with patch.dict(bluez.__salt__, {"cmd.run": mock}):
19             self.assertDictEqual(
20                 bluez.version(),
21                 {"PyBluez": "&lt;= 0.18 (Unknown, but installed)", "Bluez": "5.7"},
22             )
23     def test_address_(self):
24         mock = MagicMock(return_value="hci : hci0")
25         with patch.dict(bluez.__salt__, {"cmd.run": mock}):
26             self.assertDictEqual(
27                 bluez.address_(),
28                 {"hci ": {"device": "hci ", "path": "/sys/class/bluetooth/hci "}},
29             )
30     def test_power(self):
31         mock = MagicMock(return_value={})
32         with patch.object(bluez, "address_", mock):
33             self.assertRaises(CommandExecutionError, bluez.power, "hci0", "on")
34         mock = MagicMock(return_value={"hci0": {"device": "hci0", "power": "on"}})
35         with patch.object(bluez, "address_", mock):
36             mock = MagicMock(return_value="")
37             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
38                 self.assertTrue(bluez.power("hci0", "on"))
39         mock = MagicMock(return_value={"hci0": {"device": "hci0", "power": "on"}})
40         with patch.object(bluez, "address_", mock):
41             mock = MagicMock(return_value="")
42             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
43                 self.assertFalse(bluez.power("hci0", "off"))
44     def test_discoverable(self):
45         mock = MagicMock(
46             side_effect=[
47                 {},
48                 {"hci0": {"device": "hci0", "power": "on"}},
49                 {"hci0": {"device": "hci0", "power": "on"}},
50         )
51         with patch.object(bluez, "address_", mock):
52             self.assertRaises(CommandExecutionError, bluez<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.discoverable, "hci0")
53             mock = MagicMock(return_value="UP RUNNING ISCAN")
54             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
55                 self.assertTrue(bluez.</b></font>discoverable("hci0"))
56             mock = MagicMock(return_value="")
57             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
58                 self.assertFalse(bluez.discoverable("hci0"))
59     def test_noscan(self):
60         mock = MagicMock(
61             side_effect=[
62                 {},
63                 {"hci0": {"device": "hci0", "power": "on"}},
64                 {"hci0": {"device": "hci0", "power": "on"}},
65         )
66         with patch.object(bluez, "address_", mock):
67             self.assertRaises(CommandExecutionError, bluez<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.noscan, "hci0")
68             mock = MagicMock(return_value="SCAN")
69             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
70                 self.assertFalse(bluez.</b></font>noscan("hci0"))
71             mock = MagicMock(return_value="")
72             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
73                 self.assertTrue(bluez.noscan("hci0"))
74     def test_scan(self):
75         self.assertListEqual(bluez.scan(), [{"a": "b"}, {"d": "e"}])
76     def test_block(self):
77         """
78             self.assertRaises(CommandExecutionError, bluez<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.block, "DE:AD:BE:EF:CA:ZE")
79             mock = MagicMock(return_value="")
80             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
81                 self.assertIsNone(bluez.</b></font>block("DE:AD:BE:EF:CA:FE"))
82     def test_unblock(self):
83         """
84         Test to unblock specific bluetooth device
85         mock = MagicMock(side_effect=[False, True])
86         with patch.object(salt.utils.validate.net, "mac", mock):
87             self.assertRaises(CommandExecutionError, bluez<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.block, "DE:AD:BE:EF:CA:ZE")
88             mock = MagicMock(return_value="")
89             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
90                 self.assertIsNone(bluez.</b></font>unblock("DE:AD:BE:EF:CA:FE"))
91     def test_pair(self):
92         """
93         Test to pair bluetooth adapter with a device
94         """
95         mock = MagicMock(side_effect=[False, True, True])
96         with patch.object(salt.utils.validate.net, "mac", mock):
97             self.assertRaises(
98                 CommandExecutionError, bluez.pair, "DE:AD:BE:EF:CA:FE", "1234"
99             )
100             self.assertRaises(
101                 CommandExecutionError, bluez.pair, "DE:AD:BE:EF:CA:FE", "abcd"
102             )
103             mock = MagicMock(return_value={"device": "hci0"})
104             with patch.object(bluez, "address_", mock):
105                 mock = MagicMock(return_value="Ok")
106                 with patch.dict(bluez.__salt__, {"cmd.run": mock}):
107                     self.assertListEqual(
108                         bluez.pair("DE:AD:BE:EF:CA:FE", "1234"), ["Ok"]
109                     )
110     def test_unpair(self):
111         """
112         Test to unpair bluetooth adaptor with a device
113         mock = MagicMock(side_effect=[False, True])
114         with patch.object(salt.utils.validate.net, "mac", mock):
115             self.assertRaises(CommandExecutionError, bluez<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.unpair, "DE:AD:BE:EF:CA:FE")
116             mock = MagicMock(return_value="Ok")
117             with patch.dict(bluez.__salt__, {"cmd.run": mock}):
118                 self.assertListEqual(bluez.</b></font>unpair("DE:AD:BE:EF:CA:FE"), ["Ok"])
119     def test_start(self):
120         """
121         Test to start bluetooth service
122         """
123         mock = MagicMock(return_value="Ok")
124         with patch.dict(bluez.__salt__, {"service.start": mock}):
125             self.assertEqual(bluez.start(), "Ok")
126     def test_stop(self):
127         """
128         Test to stop bluetooth service
129         """
130         mock = MagicMock(return_value="Ok")
131         with patch.dict(bluez.__salt__, {"service.stop": mock}):
132             self.assertEqual(bluez.stop(), "Ok")
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_archive_3.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2     :codeauthor: Alexander Schwartz &lt;alexander.schwartz@gmx.net&gt;
3 """
4 import os
5 import pytest
6 import salt.states.archive as archive
7 import salt.utils.platform
8 from tests.support.mock import MagicMock, patch
9 @pytest.fixture
10 def configure_loader_modules():
11     return {
12         archive: {
13             "__grains__": {"os": "FooOS!"},
14             "__opts__": {"cachedir": "/tmp", "test": False, "hash_type": "sha256"},
15             "__env__": "test",
16         }
17     }
18 def _isfile_side_effect(path):
19     """
20     MagicMock side_effect for os.path.isfile(). We don't want to use dict.get
21     here because we want the test to fail if there's a path we haven't
22     accounted for, so that we can add it.
23     NOTE: This may fall over on some platforms if /usr/bin/tar does not exist.
24     If so, just add an entry in the dictionary for the path being used for tar.
25     """
26     if salt.utils.platform.is_windows():
27         path = path.lower()
28     d = {
29         "/tmp/foo.tar.gz": True,
30         "c:\\tmp\\foo.tar.gz": True,
31         "/private/tmp/foo.tar.gz": True,
32         "/tmp/out": False,
33         "\\tmp\\out": False,
34         "/usr/bin/tar": True,
35         "/bin/tar": True,
36         "/tmp/test_extracted_tar": False,
37         "c:\\tmp\\test_extracted_tar": False,
38         "/private/tmp/test_extracted_tar": False,
39     }
40     return d[path]
41 def test_extracted_tar():
42     """
43     archive.extracted tar options
44     """
45     if salt.utils.platform.is_windows():
46         source = "C:\\tmp\\foo.tar.gz"
47         tmp_dir = "C:\\tmp\\test_extracted_tar"
48     elif salt.utils.platform.is_darwin():
49         source = "/private/tmp/foo.tar.gz"
50         tmp_dir = "/private/tmp/test_extracted_tar"
51     else:
52         source = "/tmp/foo.tar.gz"
53         tmp_dir = "/tmp/test_extracted_tar"
54     test_tar_opts = [
55         "--no-anchored foo",
56         "v -p --opt",
57         "-v -p",
58         "--long-opt -z",
59         "z -v -weird-long-opt arg",
60     ]
61     ret_tar_opts = [
62         ["tar", "xv", "--no-anchored", "foo", "-f"],
63         ["tar", "xv", "-p", "--opt", "-f"],
64         ["tar", "xv", "-p", "-f"],
65         ["tar", "xv", "--long-opt", "-z", "-f"],
66         ["tar", "xvz", "-weird-long-opt", "arg", "-f"],
67     ]
68     mock_true = MagicMock(return_value=True)
69     mock_false = MagicMock(return_value=False)
70     ret = {
71         "stdout": ["cheese", "ham", "saltines"],
72         "stderr": "biscuits",
73         "retcode": "31337",
74         "pid": "1337",
75     }
76     mock_run = MagicMock(return_value=ret)
77     mock_source_list = MagicMock(return_value=(source, None))
78     state_single_mock = MagicMock(return_value={"local": {"result": True}})
79     list_mock = MagicMock(
80         return_value={
81             "dirs": [],
82             "links": ["ham"],
83             "top_level_dirs": [],
84             "top_level_files": [<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"cheese", "saltines"],
85             "top_level_links": ["ham"],
86         }
87     )
88     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
89     with patch.dict(
90         archive.__opts__,
91         {"test": False, "cachedir": tmp_dir, "hash_type": "sha256"},
92     ), patch.dict(
93         archive.</b></font>__salt__,
94         {
95             "file.directory_exists": mock_false,
96             "file.file_exists": mock_false,
97             "state.single": state_single_mock,
98             "file.makedirs": mock_true,
99             "cmd.run_all": mock_run,
100             "archive.list": list_mock,
101             "file.source_list": mock_source_list,
102         },
103     ), patch.dict(
104         archive.__states__, {"file.directory": mock_true}
105     ), patch.object(
106         os.path, "isfile", isfile_mock
107     ), patch(
108         "salt.utils.path.which", MagicMock(return_value=True)
109     ):
110         for test_opts, ret_opts in zip(test_tar_opts, ret_tar_opts):
111             archive.extracted(
112                 tmp_dir, source, options=test_opts, enforce_toplevel=False
113             )
114             ret_opts.append(source)
115             mock_run.assert_called_with(
116                 ret_opts, cwd=tmp_dir + os.sep, python_shell=False
117             )
118 def test_tar_gnutar():
119     """
120     Tests the call of extraction with gnutar
121     """
122     gnutar = MagicMock(return_value="tar (GNU tar)")
123     source = "/tmp/foo.tar.gz"
124     mock_false = MagicMock(return_value=False)
125     mock_true = MagicMock(return_value=True)
126     state_single_mock = MagicMock(return_value={"local": {"result": True}})
127     run_all = MagicMock(
128         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
129     )
130     list_mock = MagicMock(
131         return_value={
132             <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
133             "files": ["stdout"],
134             "links": [],
135             "top_level_dirs": [],
136             "top_level_files": ["stdout"],
137             "top_level_links": [],
138         }
139     )
140     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
141     with patch.dict(
142         archive.__salt__,
143         {
144             "cmd.run": gnutar,
145             "file.directory_exists": mock_false,
146             "file.file_exists": mock_false,
147             "state.single": state_single_mock,
148             "file.makedirs": mock_true,
149             "cmd.run_all": run_all,
150             "archive.list": list_mock,
151             "file.source_list": mock_source_list,
152         },
153     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
154         os.path, "isfile", isfile_mock
155     ), patch(
156         "salt.utils.path.which", MagicMock(return_value=True)
157     ):
158         ret = archive.extracted(
159             os.path.join(os.sep + "tmp", "out"),
160             source,
161             options="xvzf",
162             enforce_toplevel=False,
163             keep=True,
164         )
165         assert ret["changes"]["extracted_files"] == ["stdout"]
166 def test_tar_bsdtar():
167     """
168     Tests the call of extraction with bsdtar
169     """
170     bsdtar = MagicMock(return_value="tar (bsdtar)")
171     source = "/tmp/foo.tar.gz"
172     mock_false = MagicMock(return_value=False)
173     mock_true = MagicMock(return_value=True)
174     state_single_mock = MagicMock(return_value={"local": {"result": True}})
175     run_all = MagicMock(
176         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
177     )
178     list_mock = MagicMock(
179         return_value={
180             <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
181             "files": ["stderr"],
182             "links": [],
183             "top_level_dirs": [],
184             "top_level_files": ["stderr"],
185             "top_level_links": [],
186         }
187     )
188     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
189     with patch.dict(
190         archive.__salt__,
191         {
192             "cmd.run": bsdtar,
193             "file.directory_exists": mock_false,
194             "file.file_exists": mock_false,
195             "state.single": state_single_mock,
196             "file.makedirs": mock_true,
197             "cmd.run_all": run_all,
198             "archive.list": list_mock,
199             "file.source_list": mock_source_list,
200         },
201     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
202         os.path, "isfile", isfile_mock
203     ), patch(
204         "salt.utils.path.which", MagicMock(return_value=True)
205     ):
206         ret = archive.extracted(
207             os.path.join(os.sep + "tmp", "out"),
208             source,
209             options="xvzf",
210             enforce_toplevel=False,
211             keep=True,
212         )
213         assert ret["changes"]["extracted_files"] == ["stderr"]
214 def test_tar_bsdtar_with_trim_output():
215     """
216     Tests the call of extraction with bsdtar with trim_output
217     """
218     bsdtar = MagicMock(return_value="tar (bsdtar)")
219     source = "/tmp/foo.tar.gz"
220     mock_false = MagicMock(return_value=False)
221     mock_true = MagicMock(return_value=True)
222     state_single_mock = MagicMock(return_value={"local": {"result": True}})
223     run_all = MagicMock(
224         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
225     )
226     list_mock = MagicMock(
227         return_value={
228             <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
229             "files": ["stderr"],
230             "links": [],
231             "top_level_dirs": [],
232             "top_level_files": ["stderr"],
233             "top_level_links": [],
234         }
235     )
236     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
237     with patch.dict(
238         archive.__salt__,
239         {
240             "cmd.run": bsdtar,
241             "file.directory_exists": mock_false,
242             "file.file_exists": mock_false,
243             "state.single": state_single_mock,
244             "file.makedirs": mock_true,
245             "cmd.run_all": run_all,
246             "archive.list": list_mock,
247             "file.source_list": mock_source_list,
248         },
249     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
250         os.path, "isfile", isfile_mock
251     ), patch(
252         "salt.utils.path.which", MagicMock(return_value=True)
253     ):
254         ret = archive.extracted(
255             os.path.join(os.sep + "tmp", "out"),
256             source,
257             options="xvzf",
258             enforce_toplevel=False,
259             keep_source=True,
260             trim_output=1,
261         )
262         assert ret["changes"]["extracted_files"] == ["stderr"]
263         assert ret["comment"].endswith("Output was trimmed to 1 number of lines")
264 def test_extracted_when_if_missing_path_exists():
265     """
266     When if_missing exists, we should exit without making any changes.
267     NOTE: We're not mocking the __salt__ dunder because if we actually run
268     any functions from that dunder, we're doing something wrong. So, in
269     those cases we'll just let it raise a KeyError and cause the test to
270     fail.
271     """
272     name = if_missing = "/tmp/foo"
273     source = "salt://foo.bar.tar"
274     with patch.object(os.path, "exists", MagicMock(return_value=True)):
275         ret = archive.extracted(name, source=source, if_missing=if_missing)
276         assert ret["result"], ret
277         assert ret["comment"] == "Path {} exists".format(if_missing)
278 def test_clean_parent_conflict():
279     """
280     Tests the call of extraction with gnutar with both clean_parent plus clean set to True
281     """
282     gnutar = MagicMock(return_value="tar (GNU tar)")
283     source = "/tmp/foo.tar.gz"
284     ret_comment = "Only one of 'clean' and 'clean_parent' can be set to True"
285     mock_false = MagicMock(return_value=False)
286     mock_true = MagicMock(return_value=True)
287     state_single_mock = MagicMock(return_value={"local": {"result": True}})
288     run_all = MagicMock(
289         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
290     )
291     list_mock = MagicMock(
292         return_value={
293             <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"dirs": [],
294             "files": ["stdout"],
295             "links": [],
296             "top_level_dirs": [],
297             "top_level_files": ["stdout"],
298             "top_level_links": [],
299         }
300     )
301     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
302     with patch.dict(
303         archive.__salt__,
304         {
305             "cmd.run": gnutar,
306             "file.directory_exists": mock_false,
307             "file.file_exists": mock_false,
308             "state.single": state_single_mock,
309             "file.makedirs": mock_true,
310             "cmd.run_all": run_all,
311             "archive.list": list_mock,
312             "file.source_list": mock_source_list,
313         },
314     ), patch.dict(archive.</b></font>__states__, {"file.directory": mock_true}), patch.object(
315         os.path, "isfile", isfile_mock
316     ), patch(
317         "salt.utils.path.which", MagicMock(return_value=True)
318     ):
319         ret = archive.extracted(
320             os.path.join(os.sep + "tmp", "out"),
321             source,
322             options="xvzf",
323             enforce_toplevel=False,
324             clean=True,
325             clean_parent=True,
326             keep=True,
327         )
328         assert ret["result"] is False
329         assert ret["changes"] == {}
330         assert ret["comment"] == ret_comment
331 def test_skip_files_list_verify_conflict():
332     """
333     Tests the call of extraction with both skip_files_list_verify and skip_verify set to True
334     """
335     gnutar = MagicMock(return_value="tar (GNU tar)")
336     source = "/tmp/foo.tar.gz"
337     ret_comment = (
338         'Only one of "skip_files_list_verify" and "skip_verify" can be set to True'
339     )
340     mock_false = MagicMock(return_value=False)
341     mock_true = MagicMock(return_value=True)
342     state_single_mock = MagicMock(return_value={"local": {"result": True}})
343     run_all = MagicMock(
344         return_value={"retcode": 0, "stdout": "stdout", "stderr": "stderr"}
345     )
346     mock_source_list = MagicMock(return_value=(source, None))
347     list_mock = MagicMock(
348         return_value={
349             "dirs": [],
350             "files": ["stdout"],
351             "links": [],
352             "top_level_dirs": [],
353             "top_level_files": ["stdout"],
354             "top_level_links": [],
355         }
356     )
357     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
358     with patch.dict(
359         archive.__salt__,
360         {
361             "cmd.run": gnutar,
362             "file.directory_exists": mock_false,
363             "file.file_exists": mock_false,
364             "state.single": state_single_mock,
365             "file.makedirs": mock_true,
366             "cmd.run_all": run_all,
367             "archive.list": list_mock,
368             "file.source_list": mock_source_list,
369         },
370     ), patch.dict(archive.__states__, {"file.directory": mock_true}), patch.object(
371         os.path, "isfile", isfile_mock
372     ), patch(
373         "salt.utils.path.which", MagicMock(return_value=True)
374     ):
375         ret = archive.extracted(
376             os.path.join(os.sep + "tmp", "out"),
377             source,
378             options="xvzf",
379             enforce_toplevel=False,
380             clean=True,
381             skip_files_list_verify=True,
382             skip_verify=True,
383             keep=True,
384         )
385         assert ret["result"] is False
386         assert ret["changes"] == {}
387         assert ret["comment"] == ret_comment
388 def test_skip_files_list_verify_success():
389     """
390     Test that if the local and expected source hash are the same we won't do anything.
391     """
392     if salt.utils.platform.is_windows():
393         source = "C:\\tmp\\foo.tar.gz"
394         tmp_dir = "C:\\tmp\\test_extracted_tar"
395     elif salt.utils.platform.is_darwin():
396         source = "/private/tmp/foo.tar.gz"
397         tmp_dir = "/private/tmp/test_extracted_tar"
398     else:
399         source = "/tmp/foo.tar.gz"
400         tmp_dir = "/tmp/test_extracted_tar"
401     expected_comment = (
402         "Archive {} existing source sum is the same as the "
403         "expected one and skip_files_list_verify argument "
404         "was set to True. Extraction is not needed".format(source)
405     )
406     expected_ret = {
407         "name": tmp_dir,
408         "result": True,
409         "changes": {},
410         "comment": expected_comment,
411     }
412     mock_true = MagicMock(return_value=True)
413     mock_false = MagicMock(return_value=False)
414     mock_cached = MagicMock(return_value="{}/{}".format(tmp_dir, source))
415     source_sum = {"hsum": "testhash", "hash_type": "sha256"}
416     mock_hash = MagicMock(return_value=source_sum)
417     mock_source_list = MagicMock(return_value=(source, None))
418     isfile_mock = MagicMock(side_effect=_isfile_side_effect)
419     with patch("salt.states.archive._read_cached_checksum", mock_hash):
420         with patch.dict(
421             archive.__opts__,
422             {"test": False, "cachedir": tmp_dir, "hash_type": "sha256"},
423         ), patch.dict(
424             archive.__salt__,
425             {
426                 "file.directory_exists": mock_false,
427                 "file.get_source_sum": mock_hash,
428                 "file.check_hash": mock_true,
429                 "cp.is_cached": mock_cached,
430                 "file.source_list": mock_source_list,
431             },
432         ), patch.object(
433             os.path, "isfile", isfile_mock
434         ):
435             ret = archive.extracted(
436                 tmp_dir,
437                 source,
438                 source_hash="testhash",
439                 skip_files_list_verify=True,
440                 enforce_toplevel=False,
441             )
442             assert ret == expected_ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
