<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for systemd_service.py &amp; gpg_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for systemd_service.py &amp; gpg_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>systemd_service.py (2.1399176%)<th>gpg_1.py (1.9047619%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(21-35)<td><a href="#" name="0">(14-29)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1398-1444)<td><a href="#" name="1">(1182-1194)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>systemd_service.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Provides the service module for systemd

.. versionadded:: 0.10.0

.. important::
    If you feel that Salt should be using this module to manage services on a
    minion, and it is using a different module (or gives an error similar to
    *'service.start' is not available*), see :ref:`here
    &lt;module-provider-override&gt;`.

.. important::
    This is an implementation of virtual 'service' module. As such, you must
    call it under the name 'service' and NOT 'systemd'. You can see that also
    in the examples below.
"""

<a name="0"></a>import errno
import fnmatch
import glob
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
import os
import re
import shlex

import salt.utils.files
import salt.utils.itertools
import salt.utils.path
import salt.utils.stringutils
import salt.utils.systemd
from salt.exceptions import CommandExecutionError

log = logging.getLogger(__name__)

__func_alias__ =</b></font> {
    "reload_": "reload",
    "unmask_": "unmask",
}

SYSTEM_CONFIG_PATHS = ("/lib/systemd/system", "/usr/lib/systemd/system")
LOCAL_CONFIG_PATH = "/etc/systemd/system"
INITSCRIPT_PATH = "/etc/init.d"
VALID_UNIT_TYPES = (
    "service",
    "socket",
    "device",
    "mount",
    "automount",
    "swap",
    "target",
    "path",
    "timer",
)

# Define the module's virtual name
__virtualname__ = "service"

# Disable check for string substitution
# pylint: disable=E1321


def __virtual__():
    """
    Only work on systems that have been booted with systemd
    """
    is_linux = __grains__.get("kernel") == "Linux"
    is_booted = salt.utils.systemd.booted(__context__)
    is_offline = salt.utils.systemd.offline(__context__)
    if is_linux and (is_booted or is_offline):
        return __virtualname__
    return (
        False,
        "The systemd execution module failed to load: only available on Linux "
        "systems which have been booted with systemd.",
    )


def _root(path, root):
    """
    Relocate an absolute path to a new root directory.
    """
    if root:
        return os.path.join(root, os.path.relpath(path, os.path.sep))
    else:
        return path


def _canonical_unit_name(name):
    """
    Build a canonical unit name treating unit names without one
    of the valid suffixes as a service.
    """
    if not isinstance(name, str):
        name = str(name)
    if any(name.endswith(suffix) for suffix in VALID_UNIT_TYPES):
        return name
    return "%s.service" % name


def _check_available(name):
    """
    Returns boolean telling whether or not the named service is available
    """
    if offline():
        raise CommandExecutionError(
            "Cannot run in offline mode. Failed to get information on unit '%s'" % name
        )

    _status = _systemctl_status(name)
    sd_version = salt.utils.systemd.version(__context__)
    if sd_version is not None and sd_version &gt;= 231:
        # systemd 231 changed the output of "systemctl status" for unknown
        # services, and also made it return an exit status of 4. If we are on
        # a new enough version, check the retcode, otherwise fall back to
        # parsing the "systemctl status" output.
        # See: https://github.com/systemd/systemd/pull/3385
        # Also: https://github.com/systemd/systemd/commit/3dced37
        return 0 &lt;= _status["retcode"] &lt; 4

    out = _status["stdout"].lower()
    if "could not be found" in out:
        # Catch cases where the systemd version is &lt; 231 but the return code
        # and output changes have been backported (e.g. RHEL 7.3).
        return False

    for line in salt.utils.itertools.split(out, "\n"):
        match = re.match(r"\s+loaded:\s+(\S+)", line)
        if match:
            ret = match.group(1) != "not-found"
            break
    else:
        raise CommandExecutionError("Failed to get information on unit '%s'" % name)
    return ret


def _check_for_unit_changes(name):
    """
    Check for modified/updated unit files, and run a daemon-reload if any are
    found.
    """
    contextkey = "systemd._check_for_unit_changes.{}".format(name)
    if contextkey not in __context__:
        if _untracked_custom_unit_found(name) or _unit_file_changed(name):
            systemctl_reload()
        # Set context key to avoid repeating this check
        __context__[contextkey] = True


def _check_unmask(name, unmask, unmask_runtime, root=None):
    """
    Common code for conditionally removing masks before making changes to a
    service's state.
    """
    if unmask:
        unmask_(name, runtime=False, root=root)
    if unmask_runtime:
        unmask_(name, runtime=True, root=root)


def _clear_context():
    """
    Remove context
    """
    # Using list() here because modifying a dictionary during iteration will
    # raise a RuntimeError.
    for key in list(__context__):
        try:
            if key.startswith("systemd._systemctl_status."):
                __context__.pop(key)
        except AttributeError:
            continue


def _default_runlevel():
    """
    Try to figure out the default runlevel.  It is kept in
    /etc/init/rc-sysinit.conf, but can be overridden with entries
    in /etc/inittab, or via the kernel command-line at boot
    """
    # Try to get the "main" default.  If this fails, throw up our
    # hands and just guess "2", because things are horribly broken
    try:
        with salt.utils.files.fopen("/etc/init/rc-sysinit.conf") as fp_:
            for line in fp_:
                line = salt.utils.stringutils.to_unicode(line)
                if line.startswith("env DEFAULT_RUNLEVEL"):
                    runlevel = line.split("=")[-1].strip()
    except Exception:  # pylint: disable=broad-except
        return "2"

    # Look for an optional "legacy" override in /etc/inittab
    try:
        with salt.utils.files.fopen("/etc/inittab") as fp_:
            for line in fp_:
                line = salt.utils.stringutils.to_unicode(line)
                if not line.startswith("#") and "initdefault" in line:
                    runlevel = line.split(":")[1]
    except Exception:  # pylint: disable=broad-except
        pass

    # The default runlevel can also be set via the kernel command-line.
    try:
        valid_strings = {"0", "1", "2", "3", "4", "5", "6", "s", "S", "-s", "single"}
        with salt.utils.files.fopen("/proc/cmdline") as fp_:
            for line in fp_:
                line = salt.utils.stringutils.to_unicode(line)
                for arg in line.strip().split():
                    if arg in valid_strings:
                        runlevel = arg
                        break
    except Exception:  # pylint: disable=broad-except
        pass

    return runlevel


def _get_systemd_services(root):
    """
    Use os.listdir() to get all the unit files
    """
    ret = set()
    for path in SYSTEM_CONFIG_PATHS + (LOCAL_CONFIG_PATH,):
        # Make sure user has access to the path, and if the path is a
        # link it's likely that another entry in SYSTEM_CONFIG_PATHS
        # or LOCAL_CONFIG_PATH points to it, so we can ignore it.
        path = _root(path, root)
        if os.access(path, os.R_OK) and not os.path.islink(path):
            for fullname in os.listdir(path):
                try:
                    unit_name, unit_type = fullname.rsplit(".", 1)
                except ValueError:
                    continue
                if unit_type in VALID_UNIT_TYPES:
                    ret.add(unit_name if unit_type == "service" else fullname)
    return ret


def _get_sysv_services(root, systemd_services=None):
    """
    Use os.listdir() and os.access() to get all the initscripts
    """
    initscript_path = _root(INITSCRIPT_PATH, root)
    try:
        sysv_services = os.listdir(initscript_path)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            pass
        elif exc.errno == errno.EACCES:
            log.error(
                "Unable to check sysvinit scripts, permission denied to %s",
                initscript_path,
            )
        else:
            log.error(
                "Error %d encountered trying to check sysvinit scripts: %s",
                exc.errno,
                exc.strerror,
            )
        return []

    if systemd_services is None:
        systemd_services = _get_systemd_services(root)

    ret = []
    for sysv_service in sysv_services:
        if os.access(os.path.join(initscript_path, sysv_service), os.X_OK):
            if sysv_service in systemd_services:
                log.debug(
                    "sysvinit script '%s' found, but systemd unit "
                    "'%s.service' already exists",
                    sysv_service,
                    sysv_service,
                )
                continue
            ret.append(sysv_service)
    return ret


def _get_service_exec():
    """
    Returns the path to the sysv service manager (either update-rc.d or
    chkconfig)
    """
    contextkey = "systemd._get_service_exec"
    if contextkey not in __context__:
        executables = ("update-rc.d", "chkconfig")
        for executable in executables:
            service_exec = salt.utils.path.which(executable)
            if service_exec is not None:
                break
        else:
            raise CommandExecutionError(
                "Unable to find sysv service manager (tried {})".format(
                    ", ".join(executables)
                )
            )
        __context__[contextkey] = service_exec
    return __context__[contextkey]


def _runlevel():
    """
    Return the current runlevel
    """
    contextkey = "systemd._runlevel"
    if contextkey in __context__:
        return __context__[contextkey]
    out = __salt__["cmd.run"]("runlevel", python_shell=False, ignore_retcode=True)
    try:
        ret = out.split()[1]
    except IndexError:
        # The runlevel is unknown, return the default
        ret = _default_runlevel()
    __context__[contextkey] = ret
    return ret


def _strip_scope(msg):
    """
    Strip unnecessary message about running the command with --scope from
    stderr so that we can raise an exception with the remaining stderr text.
    """
    ret = []
    for line in msg.splitlines():
        if not line.endswith(".scope"):
            ret.append(line)
    return "\n".join(ret).strip()


def _systemctl_cmd(action, name=None, systemd_scope=False, no_block=False, root=None):
    """
    Build a systemctl command line. Treat unit names without one
    of the valid suffixes as a service.
    """
    ret = []
    if (
        systemd_scope
        and salt.utils.systemd.has_scope(__context__)
        and __salt__["config.get"]("systemd.scope", True)
    ):
        ret.extend(["systemd-run", "--scope"])
    ret.append("systemctl")
    if no_block:
        ret.append("--no-block")
    if root:
        ret.extend(["--root", root])
    if isinstance(action, str):
        action = shlex.split(action)
    ret.extend(action)
    if name is not None:
        ret.append(_canonical_unit_name(name))
    if "status" in ret:
        ret.extend(["-n", "0"])
    return ret


def _systemctl_status(name):
    """
    Helper function which leverages __context__ to keep from running 'systemctl
    status' more than once.
    """
    contextkey = "systemd._systemctl_status.%s" % name
    if contextkey in __context__:
        return __context__[contextkey]
    __context__[contextkey] = __salt__["cmd.run_all"](
        _systemctl_cmd("status", name),
        python_shell=False,
        redirect_stderr=True,
        ignore_retcode=True,
    )
    return __context__[contextkey]


def _sysv_enabled(name, root):
    """
    A System-V style service is assumed disabled if the "startup" symlink
    (starts with "S") to its script is found in /etc/init.d in the current
    runlevel.
    """
    # Find exact match (disambiguate matches like "S01anacron" for cron)
    rc = _root("/etc/rc{}.d/S*{}".format(_runlevel(), name), root)
    for match in glob.glob(rc):
        if re.match(r"S\d{,2}%s" % name, os.path.basename(match)):
            return True
    return False


def _untracked_custom_unit_found(name, root=None):
    """
    If the passed service name is not available, but a unit file exist in
    /etc/systemd/system, return True. Otherwise, return False.
    """
    system = _root("/etc/systemd/system", root)
    unit_path = os.path.join(system, _canonical_unit_name(name))
    return os.access(unit_path, os.R_OK) and not _check_available(name)


def _unit_file_changed(name):
    """
    Returns True if systemctl reports that the unit file has changed, otherwise
    returns False.
    """
    status = _systemctl_status(name)["stdout"].lower()
    return "'systemctl daemon-reload'" in status


def systemctl_reload():
    """
    .. versionadded:: 0.15.0

    Reloads systemctl, an action needed whenever unit files are updated.

    CLI Example:

    .. code-block:: bash

        salt '*' service.systemctl_reload
    """
    out = __salt__["cmd.run_all"](
        _systemctl_cmd("--system daemon-reload"),
        python_shell=False,
        redirect_stderr=True,
    )
    if out["retcode"] != 0:
        raise CommandExecutionError(
            "Problem performing systemctl daemon-reload: %s" % out["stdout"]
        )
    _clear_context()
    return True


def get_running():
    """
    Return a list of all running services, so far as systemd is concerned

    CLI Example:

    .. code-block:: bash

        salt '*' service.get_running
    """
    ret = set()
    # Get running systemd units
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager"),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            comps = line.strip().split()
            fullname = comps[0]
            if len(comps) &gt; 3:
                active_state = comps[3]
        except ValueError as exc:
            log.error(exc)
            continue
        else:
            if active_state != "running":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)

    return sorted(ret)


def get_enabled(root=None):
    """
    Return a list of all enabled services

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.get_enabled
    """
    ret = set()
    # Get enabled systemd units. Can't use --state=enabled here because it's
    # not present until systemd 216.
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            fullname, unit_state = line.strip().split()[:2]
        except ValueError:
            continue
        else:
            # Arch Linux adds a third column, which we want to ignore
            if unit_state.split()[0] != "enabled":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)

    # Add in any sysvinit services that are enabled
    ret.update({x for x in _get_sysv_services(root) if _sysv_enabled(x, root)})
    return sorted(ret)


def get_disabled(root=None):
    """
    Return a list of all disabled services

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.get_disabled
    """
    ret = set()
    # Get disabled systemd units. Can't use --state=disabled here because it's
    # not present until systemd 216.
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            fullname, unit_state = line.strip().split()[:2]
        except ValueError:
            continue
        else:
            # Arch Linux adds a third column, which we want to ignore
            if unit_state.split()[0] != "disabled":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)

    # Add in any sysvinit services that are disabled
    ret.update({x for x in _get_sysv_services(root) if not _sysv_enabled(x, root)})
    return sorted(ret)


def get_static(root=None):
    """
    .. versionadded:: 2015.8.5

    Return a list of all static services

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.get_static
    """
    ret = set()
    # Get static systemd units. Can't use --state=static here because it's
    # not present until systemd 216.
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            fullname, unit_state = line.strip().split()[:2]
        except ValueError:
            continue
        else:
            if unit_state != "static":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)

    # sysvinit services cannot be static
    return sorted(ret)


def get_all(root=None):
    """
    Return a list of all available services

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.get_all
    """
    ret = _get_systemd_services(root)
    ret.update(set(_get_sysv_services(root, systemd_services=ret)))
    return sorted(ret)


def available(name):
    """
    .. versionadded:: 0.10.4

    Check that the given service is available taking into account template
    units.

    CLI Example:

    .. code-block:: bash

        salt '*' service.available sshd
    """
    _check_for_unit_changes(name)
    return _check_available(name)


def missing(name):
    """
    .. versionadded:: 2014.1.0

    The inverse of :py:func:`service.available
    &lt;salt.modules.systemd.available&gt;`. Returns ``True`` if the specified
    service is not available, otherwise returns ``False``.

    CLI Example:

    .. code-block:: bash

        salt '*' service.missing sshd
    """
    return not available(name)


def unmask_(name, runtime=False, root=None):
    """
    .. versionadded:: 2015.5.0
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Unmask the specified service with systemd

    runtime : False
        Set to ``True`` to unmask this service only until the next reboot

        .. versionadded:: 2017.7.0
            In previous versions, this function would remove whichever mask was
            identified by running ``systemctl is-enabled`` on the service.
            However, since it is possible to both have both indefinite and
            runtime masks on a service simultaneously, this function now
            removes a runtime mask only when this argument is set to ``True``,
            and otherwise removes an indefinite mask.

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.unmask foo
        salt '*' service.unmask foo runtime=True
    """
    _check_for_unit_changes(name)
    if not masked(name, runtime, root=root):
        log.debug("Service '%s' is not %smasked", name, "runtime-" if runtime else "")
        return True

    cmd = "unmask --runtime" if runtime else "unmask"
    out = __salt__["cmd.run_all"](
        _systemctl_cmd(cmd, name, systemd_scope=True, root=root),
        python_shell=False,
        redirect_stderr=True,
    )

    if out["retcode"] != 0:
        raise CommandExecutionError("Failed to unmask service '%s'" % name)

    return True


def mask(name, runtime=False, root=None):
    """
    .. versionadded:: 2015.5.0
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Mask the specified service with systemd

    runtime : False
        Set to ``True`` to mask this service only until the next reboot

        .. versionadded:: 2015.8.5

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.mask foo
        salt '*' service.mask foo runtime=True
    """
    _check_for_unit_changes(name)

    cmd = "mask --runtime" if runtime else "mask"
    out = __salt__["cmd.run_all"](
        _systemctl_cmd(cmd, name, systemd_scope=True, root=root),
        python_shell=False,
        redirect_stderr=True,
    )

    if out["retcode"] != 0:
        raise CommandExecutionError(
            "Failed to mask service '%s'" % name, info=out["stdout"]
        )

    return True


def masked(name, runtime=False, root=None):
    """
    .. versionadded:: 2015.8.0
    .. versionchanged:: 2015.8.5
        The return data for this function has changed. If the service is
        masked, the return value will now be the output of the ``systemctl
        is-enabled`` command (so that a persistent mask can be distinguished
        from a runtime mask). If the service is not masked, then ``False`` will
        be returned.
    .. versionchanged:: 2017.7.0
        This function now returns a boolean telling the user whether a mask
        specified by the new ``runtime`` argument is set. If ``runtime`` is
        ``False``, this function will return ``True`` if an indefinite mask is
        set for the named service (otherwise ``False`` will be returned). If
        ``runtime`` is ``False``, this function will return ``True`` if a
        runtime mask is set, otherwise ``False``.

    Check whether or not a service is masked

    runtime : False
        Set to ``True`` to check for a runtime mask

        .. versionadded:: 2017.7.0
            In previous versions, this function would simply return the output
            of ``systemctl is-enabled`` when the service was found to be
            masked. However, since it is possible to both have both indefinite
            and runtime masks on a service simultaneously, this function now
            only checks for runtime masks if this argument is set to ``True``.
            Otherwise, it will check for an indefinite mask.

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Examples:

    .. code-block:: bash

        salt '*' service.masked foo
        salt '*' service.masked foo runtime=True
    """
    _check_for_unit_changes(name)
    root_dir = _root("/run" if runtime else "/etc", root)
    link_path = os.path.join(root_dir, "systemd", "system", _canonical_unit_name(name))
    try:
        return os.readlink(link_path) == "/dev/null"
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            log.trace(
                "Path %s does not exist. This is normal if service '%s' is "
                "not masked or does not exist.",
                link_path,
                name,
            )
        elif exc.errno == errno.EINVAL:
            log.error(
                "Failed to check mask status for service %s. Path %s is a "
                "file, not a symlink. This could be caused by changes in "
                "systemd and is probably a bug in Salt. Please report this "
                "to the developers.",
                name,
                link_path,
            )
        return False


def start(name, no_block=False, unmask=False, unmask_runtime=False):
    """
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Start the specified service with systemd

    no_block : False
        Set to ``True`` to start the service using ``--no-block``.

        .. versionadded:: 2017.7.0

    unmask : False
        Set to ``True`` to remove an indefinite mask before attempting to start
        the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            starting. This behavior is no longer the default.

    unmask_runtime : False
        Set to ``True`` to remove a runtime mask before attempting to start the
        service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            starting. This behavior is no longer the default.

    CLI Example:

    .. code-block:: bash

        salt '*' service.start &lt;service name&gt;
    """
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("start", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )

    if ret["retcode"] != 0:
        # Instead of returning a bool, raise an exception so that we can
        # include the error message in the return data. This helps give more
        # information to the user in instances where the service is masked.
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True


def stop(name, no_block=False):
    """
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Stop the specified service with systemd

    no_block : False
        Set to ``True`` to start the service using ``--no-block``.

        .. versionadded:: 2017.7.0

    CLI Example:

    .. code-block:: bash

        salt '*' service.stop &lt;service name&gt;
    """
    _check_for_unit_changes(name)
    # Using cmd.run_all instead of cmd.retcode here to make unit tests easier
    return (
        __salt__["cmd.run_all"](
            _systemctl_cmd("stop", name, systemd_scope=True, no_block=no_block),
            python_shell=False,
        )["retcode"]
        == 0
    )


def restart(name, no_block=False, unmask=False, unmask_runtime=False):
    """
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Restart the specified service with systemd

    no_block : False
        Set to ``True`` to start the service using ``--no-block``.

        .. versionadded:: 2017.7.0

    unmask : False
        Set to ``True`` to remove an indefinite mask before attempting to
        restart the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            restarting. This behavior is no longer the default.

    unmask_runtime : False
        Set to ``True`` to remove a runtime mask before attempting to restart
        the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            restarting. This behavior is no longer the default.

    CLI Example:

    .. code-block:: bash

        salt '*' service.restart &lt;service name&gt;
    """
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("restart", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )

    if ret["retcode"] != 0:
        # Instead of returning a bool, raise an exception so that we can
        # include the error message in the return data. This helps give more
        # information to the user in instances where the service is masked.
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True


def reload_(name, no_block=False, unmask=False, unmask_runtime=False):
    """
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Reload the specified service with systemd

    no_block : False
        Set to ``True`` to reload the service using ``--no-block``.

        .. versionadded:: 2017.7.0

    unmask : False
        Set to ``True`` to remove an indefinite mask before attempting to
        reload the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            reloading. This behavior is no longer the default.

    unmask_runtime : False
        Set to ``True`` to remove a runtime mask before attempting to reload
        the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            reloading. This behavior is no longer the default.

    CLI Example:

    .. code-block:: bash

        salt '*' service.reload &lt;service name&gt;
    """
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("reload", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )

    if ret["retcode"] != 0:
        # Instead of returning a bool, raise an exception so that we can
        # include the error message in the return data. This helps give more
        # information to the user in instances where the service is masked.
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True


def force_reload(name, no_block=True, unmask=False, unmask_runtime=False):
    """
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    .. versionadded:: 0.12.0

    Force-reload the specified service with systemd

    no_block : False
        Set to ``True`` to start the service using ``--no-block``.

        .. versionadded:: 2017.7.0

    unmask : False
        Set to ``True`` to remove an indefinite mask before attempting to
        force-reload the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            force-reloading. This behavior is no longer the default.

    unmask_runtime : False
        Set to ``True`` to remove a runtime mask before attempting to
        force-reload the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            force-reloading. This behavior is no longer the default.

    CLI Example:

    .. code-block:: bash

        salt '*' service.force_reload &lt;service name&gt;
    """
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("force-reload", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )

    if ret["retcode"] != 0:
        # Instead of returning a bool, raise an exception so that we can
        # include the error message in the return data. This helps give more
        # information to the user in instances where the service is masked.
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True


# The unused sig argument is required to maintain consistency with the API
# established by Salt's service management states.
def status(name, sig=None):  # pylint: disable=unused-argument
    """
    Return the status for a service via systemd.
    If the name contains globbing, a dict mapping service name to True/False
    values is returned.

    .. versionchanged:: 2018.3.0
        The service name can now be a glob (e.g. ``salt*``)

    Args:
        name (str): The name of the service to check
        sig (str): Not implemented

    Returns:
        bool: True if running, False otherwise
        dict: Maps service name to True if running, False otherwise

    CLI Example:

    .. code-block:: bash

        salt '*' service.status &lt;service name&gt; [service signature]
    """
    contains_globbing = bool(re.search(r"\*|\?|\[.+\]", name))
    if contains_globbing:
        services = fnmatch.filter(get_all(), name)
    else:
        services = [name]
    results = {}
    for service in services:
        _check_for_unit_changes(service)
        results[service] = (
            __salt__["cmd.retcode"](
                _systemctl_cmd("is-active", service),
                python_shell=False,
                ignore_retcode=True,
            )
            == 0
        )
    if contains_globbing:
        return results
    return results[name]


# **kwargs is required to maintain consistency with the API established by
# Salt's service management states.
def enable(
    name, no_block=False, unmask=False, unmask_runtime=False, root=None, **kwargs
):  # pylint: disable=unused-argument
    """
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Enable the named service to start when the system boots

    no_block : False
        Set to ``True`` to start the service using ``--no-block``.

        .. versionadded:: 2017.7.0

    unmask : False
        Set to ``True`` to remove an indefinite mask before attempting to
        enable the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            enabling. This behavior is no longer the default.

    unmask_runtime : False
        Set to ``True`` to remove a runtime mask before attempting to enable
        the service.

        .. versionadded:: 2017.7.0
            In previous releases, Salt would simply unmask a service before
            enabling. This behavior is no longer the default.

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.enable &lt;service name&gt;
    """
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime, root)
    if name in _get_sysv_services(root):
        cmd = []
        if salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
            "systemd.scope", True
        ):
            cmd.extend(["systemd-run", "--scope"])
        service_exec = _get_service_exec()
        if service_exec.endswith("/update-rc.d"):
            cmd.extend([service_exec, "-f", name, "defaults", "99"])
        elif service_exec.endswith("/chkconfig"):
            cmd.extend([service_exec, name, "on"])
        return (
            __salt__["cmd.retcode"](cmd, python_shell=False, ignore_retcode=True) == 0
        )
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd(
            "enable", name, systemd_scope=True, no_block=no_block, root=root
        ),
        python_shell=False,
        ignore_retcode=True,
    )

    if ret["retcode"] != 0:
        # Instead of returning a bool, raise an exception so that we can
        # include the error message in the return data. This helps give more
        # information to the user in instances where the service is masked.
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True


# The unused kwargs argument is required to maintain consistency with the API
# established by Salt's service management states.
def disable(
    name, no_block=False, root=None, **kwargs
):  # pylint: disable=unused-argument
    """
    .. versionchanged:: 2015.8.12,2016.3.3,2016.11.0
        On minions running systemd&gt;=205, `systemd-run(1)`_ is now used to
        isolate commands run by this function from the ``salt-minion`` daemon's
        control group. This is done to avoid a race condition in cases where
        the ``salt-minion`` service is restarted while a service is being
        modified. If desired, usage of `systemd-run(1)`_ can be suppressed by
        setting a :mod:`config option &lt;salt.modules.config.get&gt;` called
        ``systemd.scope``, with a value of ``False`` (no quotes).

    .. _`systemd-run(1)`: https://www.freedesktop.org/software/systemd/man/systemd-run.html

    Disable the named service to not start when the system boots

    no_block : False
        Set to ``True`` to start the service using ``--no-block``.

        .. versionadded:: 2017.7.0

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.disable &lt;service name&gt;
    """
    _check_for_unit_changes(name)
    if name in _get_sysv_services(root):
        cmd = []
        if salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
            "systemd.scope", True
        ):
            cmd.extend(["systemd-run", "--scope"])
        service_exec = _get_service_exec()
        if service_exec.endswith("/update-rc.d"):
            cmd.extend([service_exec, "-f", name, "remove"])
        elif service_exec.endswith("/chkconfig"):
            cmd.extend([service_exec, name, "off"])
        return (
            __salt__["cmd.retcode"](cmd, python_shell=False, ignore_retcode=True) == 0
        )
    # Using cmd.run_all instead of cmd.retcode here to make unit tests easier
    return (
        __salt__["cmd.run_all"](
            _systemctl_cmd(
                "disable", name, systemd_scope=True, no_block=no_block, root=root
            ),
            python_shell=False,
            ignore_retcode=True,
        )["retcode"]
        == 0
    )


# The unused kwargs argument is required to maintain consistency with the API
# established by Salt's service management states.
def enabled(name, root=None, **kwargs):  # pylint: disable=unused-argument
    """
    Return if the named service is enabled to start on boot

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.enabled &lt;service name&gt;
    """
    # Try 'systemctl is-enabled' first, then look for a symlink created by
    # systemctl (older systemd releases did not support using is-enabled to
    # check templated services), and lastly check for a sysvinit service.
    if (
        __salt__["cmd.retcode"](
            _systemctl_cmd("is-enabled", name, root=root),
            python_shell=False,
            ignore_retcode=True,
        )
        == 0
    ):
        return True
    elif "@" in name:
        # On older systemd releases, templated services could not be checked
        # with ``systemctl is-enabled``. As a fallback, look for the symlinks
        # created by systemctl when enabling templated services.
        local_config_path = _root(LOCAL_CONFIG_PATH, "/")
        cmd = [
            "find",
            local_config_path,
            "-name",
            name,
            "-type",
            "l",
            "-print",
            "-quit",
        ]
        # If the find command returns any matches, there will be output and the
        # string will be non-empty.
        if bool(__salt__["cmd.run"](cmd, python_shell=False)):
            return True
    elif name in _get_sysv_services(root):
        return _sysv_enabled(name, root)

    return False


def disabled(name, root=None):
    """
    Return if the named service is disabled from starting on boot

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.disabled &lt;service name&gt;
    """
    return not enabled(name, root=root)


def show(name, root=None):
    """
    .. versionadded:: 2014.7.0

    Show properties of one or more units/jobs or the manager

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.show &lt;service name&gt;
    """
    ret = {}
    out = __salt__["cmd.run"](
        _systemctl_cmd("show", name, root=root), python_shell=False
    )
    for line in salt.utils.itertools.split(out, "\n"):
        comps = line.split("=")
        name = comps[0]
        value = "=".join(comps[1:])
        if value.startswith("{"):
            value = value.replace("{", "").replace("}", "")
            ret[name] = {}
            for item in value.split(" ; "):
                comps = item.split("=")
                ret[name][comps[0].strip()] = comps[1].strip()
        elif name in ("Before", "After", "Wants"):
            ret[name] = value.split()
        else:
            ret[name] = value

    return ret


def execs(root=None):
    """
    .. versionadded:: 2014.7.0

    Return a list of all files specified as ``ExecStart`` for all services.

    root
        Enable/disable/mask unit files in the specified root directory

    CLI Example:

    .. code-block:: bash

        salt '*' service.execs
    """
    ret = {}
    for service in get_all(root=root):
        data = show(service, root=root)
<a name="1"></a>        if "ExecStart" not in data:
            continue
        ret[service] = data["ExecStart"]["path"]
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret


def firstboot(
    locale=None,
    locale_message=None,
    keymap=None,
    timezone=None,
    hostname=None,
    machine_id=None,
    root=None,
):
    """
    .. versionadded:: 3001

    Call systemd-firstboot to configure basic settings of the system

    locale
        Set primary locale (LANG=)

    locale_message
        Set message locale (LC_MESSAGES=)

    keymap
        Set keymap

    timezone
        Set timezone

    hostname
        Set host name

    machine_id
        Set machine ID

    root
        Operate on an alternative filesystem root

    CLI Example:

    .. code-block:: bash

        salt '*' service.firstboot keymap=jp locale=en_US.UTF-8

    """
    cmd = ["systemd-firstboot"]
    parameters =</b></font> [
        ("locale", locale),
        ("locale-message", locale_message),
        ("keymap", keymap),
        ("timezone", timezone),
        ("hostname", hostname),
        ("machine-ID", machine_id),
        ("root", root),
    ]
    for parameter, value in parameters:
        if value:
            cmd.extend(["--{}".format(parameter), str(value)])

    out = __salt__["cmd.run_all"](cmd)

    if out["retcode"] != 0:
        raise CommandExecutionError("systemd-firstboot error: {}".format(out["stderr"]))

    return True


def offline():
    """
    .. versionadded:: 3004

    Check if systemd is working in offline mode, where is not possible
    to talk with PID 1.

    CLI Example:

    .. code-block:: bash

        salt '*' service.offline

    """

    return salt.utils.systemd.offline(__context__)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>gpg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
Manage a GPG keychains, add keys, create keys, retrieve keys from keyservers.
Sign, encrypt and sign plus encrypt text and files.

.. versionadded:: 2015.5.0

.. note::

    The ``python-gnupg`` library and ``gpg`` binary are required to be
    installed.
<a name="0"></a>
"""

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import functools
import logging
import os
import re
import time

import salt.utils.files
import salt.utils.path
import salt.utils.stringutils
from salt.exceptions import SaltInvocationError
from salt.utils.versions import LooseVersion as _LooseVersion

log = logging.getLogger(__name__)

# Define the module's virtual name
__virtualname__ =</b></font> "gpg"

LETTER_TRUST_DICT = {
    "e": "Expired",
    "q": "Unknown",
    "n": "Not Trusted",
    "f": "Fully Trusted",
    "m": "Marginally Trusted",
    "u": "Ultimately Trusted",
    "-": "Unknown",
}

NUM_TRUST_DICT = {
    "expired": "1",
    "unknown": "2",
    "not_trusted": "3",
    "marginally": "4",
    "fully": "5",
    "ultimately": "6",
}

INV_NUM_TRUST_DICT = {
    "1": "Expired",
    "2": "Unknown",
    "3": "Not Trusted",
    "4": "Marginally",
    "5": "Fully Trusted",
    "6": "Ultimately Trusted",
}

VERIFY_TRUST_LEVELS = {
    "0": "Undefined",
    "1": "Never",
    "2": "Marginal",
    "3": "Fully",
    "4": "Ultimate",
}

GPG_1_3_1 = False
try:
    import gnupg

    HAS_GPG_BINDINGS = True
    GPG_1_3_1 = _LooseVersion(gnupg.__version__) &gt;= _LooseVersion("1.3.1")
except ImportError:
    HAS_GPG_BINDINGS = False


def _gpg():
    """
    Returns the path to the gpg binary
    """
    # Get the path to the gpg binary.
    return salt.utils.path.which("gpg")


def __virtual__():
    """
    Makes sure that python-gnupg and gpg are available.
    """
    if not _gpg():
        return (
            False,
            "The gpg execution module cannot be loaded: gpg binary is not in the path.",
        )

    return (
        __virtualname__
        if HAS_GPG_BINDINGS
        else (
            False,
            "The gpg execution module cannot be loaded; the gnupg python module is not"
            " installed.",
        )
    )


def _get_user_info(user=None):
    """
    Wrapper for user.info Salt function
    """
    if not user:
        # Get user Salt running as
        user = __salt__["config.option"]("user")

    userinfo = __salt__["user.info"](user)

    if not userinfo:
        if user == "salt":
            # Special case with `salt` user:
            # if it doesn't exist then fall back to user Salt running as
            userinfo = _get_user_info()
        else:
            raise SaltInvocationError("User {} does not exist".format(user))

    return userinfo


def _get_user_gnupghome(user):
    """
    Return default GnuPG home directory path for a user
    """
    if user == "salt":
        gnupghome = os.path.join(__salt__["config.get"]("config_dir"), "gpgkeys")
    else:
        gnupghome = os.path.join(_get_user_info(user)["home"], ".gnupg")

    return gnupghome


def _restore_ownership(func):
    @functools.wraps(func)
    def func_wrapper(*args, **kwargs):
        """
        Wrap gpg function calls to fix permissions
        """
        user = kwargs.get("user")
        gnupghome = kwargs.get("gnupghome")

        if not gnupghome:
            gnupghome = _get_user_gnupghome(user)

        userinfo = _get_user_info(user)
        run_user = _get_user_info()

        if userinfo["uid"] != run_user["uid"] and os.path.exists(gnupghome):
            # Given user is different from one who runs Salt process,
            # need to fix ownership permissions for GnuPG home dir
            group = __salt__["file.gid_to_group"](run_user["gid"])
            for path in [gnupghome] + __salt__["file.find"](gnupghome):
                __salt__["file.chown"](path, run_user["name"], group)

        # Filter special kwargs
        for key in list(kwargs):
            if key.startswith("__"):
                del kwargs[key]

        ret = func(*args, **kwargs)

        if userinfo["uid"] != run_user["uid"]:
            group = __salt__["file.gid_to_group"](userinfo["gid"])
            for path in [gnupghome] + __salt__["file.find"](gnupghome):
                __salt__["file.chown"](path, user, group)

        return ret

    return func_wrapper


def _create_gpg(user=None, gnupghome=None):
    """
    Create the GPG object
    """
    if not gnupghome:
        gnupghome = _get_user_gnupghome(user)

    if GPG_1_3_1:
        gpg = gnupg.GPG(homedir=gnupghome)  # pylint: disable=unexpected-keyword-arg
    else:
        gpg = gnupg.GPG(gnupghome=gnupghome)

    return gpg


def _list_keys(user=None, gnupghome=None, secret=False):
    """
    Helper function for Listing keys
    """
    gpg = _create_gpg(user, gnupghome)
    _keys = gpg.list_keys(secret)
    return _keys


def _search_keys(text, keyserver, user=None):
    """
    Helper function for searching keys from keyserver
    """
    gpg = _create_gpg(user)
    if keyserver:
        _keys = gpg.search_keys(text, keyserver)
    else:
        _keys = gpg.search_keys(text)
    return _keys


def search_keys(text, keyserver=None, user=None):
    """
    Search keys from keyserver

    text
        Text to search the keyserver for, e.g. email address, keyID or fingerprint.

    keyserver
        Keyserver to use for searching for GPG keys, defaults to pgp.mit.edu.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.search_keys user@example.com

        salt '*' gpg.search_keys user@example.com keyserver=keyserver.ubuntu.com

        salt '*' gpg.search_keys user@example.com keyserver=keyserver.ubuntu.com user=username

    """
    if GPG_1_3_1:
        raise SaltInvocationError(
            "The search_keys function is not support with this version of python-gnupg."
        )
    else:
        if not keyserver:
            keyserver = "pgp.mit.edu"

        _keys = []
        for _key in _search_keys(text, keyserver, user):
            tmp = {"keyid": _key["keyid"], "uids": _key["uids"]}

            expires = _key.get("expires", None)
            date = _key.get("date", None)
            length = _key.get("length", None)

            if expires:
                tmp["expires"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["expires"]))
                )
            if date:
                tmp["created"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["date"]))
                )
            if length:
                tmp["keyLength"] = _key["length"]
            _keys.append(tmp)
        return _keys


def list_keys(user=None, gnupghome=None):
    """
    List keys in GPG keychain

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.list_keys

    """
    _keys = []
    for _key in _list_keys(user, gnupghome):
        tmp = {
            "keyid": _key["keyid"],
            "fingerprint": _key["fingerprint"],
            "uids": _key["uids"],
        }

        expires = _key.get("expires", None)
        date = _key.get("date", None)
        length = _key.get("length", None)
        owner_trust = _key.get("ownertrust", None)
        trust = _key.get("trust", None)

        if expires:
            tmp["expires"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["expires"]))
            )
        if date:
            tmp["created"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["date"]))
            )
        if length:
            tmp["keyLength"] = _key["length"]
        if owner_trust:
            tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
        if trust:
            tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
        _keys.append(tmp)
    return _keys


def list_secret_keys(user=None, gnupghome=None):
    """
    List secret keys in GPG keychain

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.list_secret_keys

    """
    _keys = []
    for _key in _list_keys(user, gnupghome, secret=True):
        tmp = {
            "keyid": _key["keyid"],
            "fingerprint": _key["fingerprint"],
            "uids": _key["uids"],
        }

        expires = _key.get("expires", None)
        date = _key.get("date", None)
        length = _key.get("length", None)
        owner_trust = _key.get("ownertrust", None)
        trust = _key.get("trust", None)

        if expires:
            tmp["expires"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["expires"]))
            )
        if date:
            tmp["created"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["date"]))
            )
        if length:
            tmp["keyLength"] = _key["length"]
        if owner_trust:
            tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
        if trust:
            tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
        _keys.append(tmp)
    return _keys


@_restore_ownership
def create_key(
    key_type="RSA",
    key_length=1024,
    name_real="Autogenerated Key",
    name_comment="Generated by SaltStack",
    name_email=None,
    subkey_type=None,
    subkey_length=None,
    expire_date=None,
    use_passphrase=False,
    user=None,
    gnupghome=None,
):
    """
    Create a key in the GPG keychain

    .. note::

        GPG key generation requires *a lot* of entropy and randomness.
        Difficult to do over a remote connection, consider having
        another process available which is generating randomness for
        the machine.  Also especially difficult on virtual machines,
        consider the `rng-tools
        &lt;http://www.gnu.org/software/hurd/user/tlecarrour/rng-tools.html&gt;`_
        package.

        The create_key process takes awhile so increasing the timeout
        may be necessary, e.g. -t 15.

    key_type
        The type of the primary key to generate. It must be capable of signing.
        'RSA' or 'DSA'.

    key_length
        The length of the primary key in bits.

    name_real
        The real name of the user identity which is represented by the key.

    name_comment
        A comment to attach to the user id.

    name_email
        An email address for the user.

    subkey_type
        The type of the secondary key to generate.

    subkey_length
        The length of the secondary key in bits.

    expire_date
        The expiration date for the primary and any secondary key.
        You can specify an ISO date, A number of days/weeks/months/years,
        an epoch value, or 0 for a non-expiring key.

    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt -t 15 '*' gpg.create_key

    """
    ret = {"res": True, "fingerprint": "", "message": ""}

    create_params = {
        "key_type": key_type,
        "key_length": key_length,
        "name_real": name_real,
        "name_comment": name_comment,
    }

    gpg = _create_gpg(user, gnupghome)

    if name_email:
        create_params["name_email"] = name_email

    if subkey_type:
        create_params["subkey_type"] = subkey_type

    if subkey_length:
        create_params["subkey_length"] = subkey_length

    if expire_date:
        create_params["expire_date"] = expire_date

    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            ret["res"] = False
            ret["message"] = "gpg_passphrase not available in pillar."
            return ret
        else:
            create_params["passphrase"] = gpg_passphrase
    else:
        create_params["no_protection"] = True

    input_data = gpg.gen_key_input(**create_params)

    # This includes "%no-protection" in the input file for
    # passphraseless key generation in GnuPG &gt;= 2.1 when the
    # python-gnupg library doesn't do that.
    if "No-Protection: True" in input_data:
        temp_data = input_data.splitlines()
        temp_data.remove("No-Protection: True")
        temp_data.insert(temp_data.index("%commit"), "%no-protection")
        input_data = "\n".join(temp_data) + "\n"

    key = gpg.gen_key(input_data)
    if key.fingerprint:
        ret["fingerprint"] = key.fingerprint
        ret["message"] = "GPG key pair successfully generated."
    else:
        ret["res"] = False
        ret["message"] = "Unable to generate GPG key pair."
    return ret


def delete_key(
    keyid=None,
    fingerprint=None,
    delete_secret=False,
    user=None,
    gnupghome=None,
    use_passphrase=True,
):
    """
    Get a key from the GPG keychain

    keyid
        The keyid of the key to be deleted.

    fingerprint
        The fingerprint of the key to be deleted.

    delete_secret
        Whether to delete a corresponding secret key prior to deleting the public key.
        Secret keys must be deleted before deleting any corresponding public keys.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.

        .. versionadded:: 3003

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.delete_key keyid=3FAD9F1E

        salt '*' gpg.delete_key fingerprint=53C96788253E58416D20BCD352952C84C3252192

        salt '*' gpg.delete_key keyid=3FAD9F1E user=username

        salt '*' gpg.delete_key keyid=3FAD9F1E user=username delete_secret=True

    """
    ret = {"res": True, "message": ""}

    if fingerprint and keyid:
        ret["res"] = False
        ret["message"] = "Only specify one argument, fingerprint or keyid"
        return ret

    if not fingerprint and not keyid:
        ret["res"] = False
        ret["message"] = "Required argument, fingerprint or keyid"
        return ret

    gpg = _create_gpg(user, gnupghome)
    key = get_key(keyid, fingerprint, user)

    def __delete_key(fingerprint, secret, use_passphrase):
        if use_passphrase:
            gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
            if not gpg_passphrase:
                ret["res"] = False
                ret["message"] = "gpg_passphrase not available in pillar."
                return ret
            else:
                out = gpg.delete_keys(fingerprint, secret, passphrase=gpg_passphrase)
        else:
            out = gpg.delete_keys(fingerprint, secret, expect_passphrase=False)
        return out

    if key:
        fingerprint = key["fingerprint"]
        skey = get_secret_key(keyid, fingerprint, user)
        if skey:
            if not delete_secret:
                ret["res"] = False
                ret[
                    "message"
                ] = "Secret key exists, delete first or pass delete_secret=True."
                return ret
            else:
                if str(__delete_key(fingerprint, True, use_passphrase)) == "ok":
                    # Delete the secret key
                    ret["message"] = "Secret key for {} deleted\n".format(fingerprint)

        # Delete the public key
        if str(__delete_key(fingerprint, False, use_passphrase)) == "ok":
            ret["message"] += "Public key for {} deleted".format(fingerprint)
        ret["res"] = True
        return ret
    else:
        ret["res"] = False
        ret["message"] = "Key not available in keychain."
        return ret


def get_key(keyid=None, fingerprint=None, user=None, gnupghome=None):
    """
    Get a key from the GPG keychain

    keyid
        The key ID (short or long) of the key to be retrieved.

    fingerprint
        The fingerprint of the key to be retrieved.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.get_key keyid=3FAD9F1E

        salt '*' gpg.get_key fingerprint=53C96788253E58416D20BCD352952C84C3252192

        salt '*' gpg.get_key keyid=3FAD9F1E user=username

    """
    tmp = {}
    for _key in _list_keys(user, gnupghome):
        if (
            _key["fingerprint"] == fingerprint
            or _key["keyid"] == keyid
            or _key["keyid"][8:] == keyid
        ):
            tmp["keyid"] = _key["keyid"]
            tmp["fingerprint"] = _key["fingerprint"]
            tmp["uids"] = _key["uids"]

            expires = _key.get("expires", None)
            date = _key.get("date", None)
            length = _key.get("length", None)
            owner_trust = _key.get("ownertrust", None)
            trust = _key.get("trust", None)

            if expires:
                tmp["expires"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["expires"]))
                )
            if date:
                tmp["created"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["date"]))
                )
            if length:
                tmp["keyLength"] = _key["length"]
            if owner_trust:
                tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
            if trust:
                tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
    if not tmp:
        return False
    else:
        return tmp


def get_secret_key(keyid=None, fingerprint=None, user=None, gnupghome=None):
    """
    Get a key from the GPG keychain

    keyid
        The key ID (short or long) of the key to be retrieved.

    fingerprint
        The fingerprint of the key to be retrieved.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.get_secret_key keyid=3FAD9F1E

        salt '*' gpg.get_secret_key fingerprint=53C96788253E58416D20BCD352952C84C3252192

        salt '*' gpg.get_secret_key keyid=3FAD9F1E user=username

    """
    tmp = {}
    for _key in _list_keys(user, gnupghome, secret=True):
        if (
            _key["fingerprint"] == fingerprint
            or _key["keyid"] == keyid
            or _key["keyid"][8:] == keyid
        ):
            tmp["keyid"] = _key["keyid"]
            tmp["fingerprint"] = _key["fingerprint"]
            tmp["uids"] = _key["uids"]

            expires = _key.get("expires", None)
            date = _key.get("date", None)
            length = _key.get("length", None)
            owner_trust = _key.get("ownertrust", None)
            trust = _key.get("trust", None)

            if expires:
                tmp["expires"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["expires"]))
                )
            if date:
                tmp["created"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["date"]))
                )
            if length:
                tmp["keyLength"] = _key["length"]
            if owner_trust:
                tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
            if trust:
                tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
    if not tmp:
        return False
    else:
        return tmp


@_restore_ownership
def import_key(text=None, filename=None, user=None, gnupghome=None):
    r"""
    Import a key from text or file

    text
        The text containing to import.

    filename
        The filename containing the key to import.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.import_key text='-----BEGIN PGP PUBLIC KEY BLOCK-----\n ... -----END PGP PUBLIC KEY BLOCK-----'
        salt '*' gpg.import_key filename='/path/to/public-key-file'

    """
    ret = {"res": True, "message": ""}

    gpg = _create_gpg(user, gnupghome)

    if not text and not filename:
        raise SaltInvocationError("filename or text must be passed.")

    if filename:
        try:
            with salt.utils.files.flopen(filename, "rb") as _fp:
                text = salt.utils.stringutils.to_unicode(_fp.read())
        except OSError:
            raise SaltInvocationError("filename does not exist.")

    imported_data = gpg.import_keys(text)

    if GPG_1_3_1:
        counts = imported_data.counts
        if counts.get("imported") or counts.get("imported_rsa"):
            ret["message"] = "Successfully imported key(s)."
        elif counts.get("unchanged"):
            ret["message"] = "Key(s) already exist in keychain."
        elif counts.get("not_imported"):
            ret["res"] = False
            ret["message"] = "Unable to import key."
        elif not counts.get("count"):
            ret["res"] = False
            ret["message"] = "Unable to import key."
    else:
        if imported_data.imported or imported_data.imported_rsa:
            ret["message"] = "Successfully imported key(s)."
        elif imported_data.unchanged:
            ret["message"] = "Key(s) already exist in keychain."
        elif imported_data.not_imported:
            ret["res"] = False
            ret["message"] = "Unable to import key."
        elif not imported_data.count:
            ret["res"] = False
            ret["message"] = "Unable to import key."
    return ret


def export_key(
    keyids=None, secret=False, user=None, gnupghome=None, use_passphrase=False
):
    """
    Export a key from the GPG keychain

    keyids
        The key ID(s) of the key(s) to be exported. Can be specified as a comma
        separated string or a list. Anything which GnuPG itself accepts to
        identify a key - for example, the key ID or the fingerprint could be
        used.

    secret
        Export the secret key identified by the ``keyids`` information passed.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.

        .. versionadded:: 3003

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.export_key keyids=3FAD9F1E

        salt '*' gpg.export_key keyids=3FAD9F1E secret=True

        salt '*' gpg.export_key keyids="['3FAD9F1E','3FBD8F1E']" user=username

    """
    gpg = _create_gpg(user, gnupghome)

    if isinstance(keyids, str):
        keyids = keyids.split(",")

    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            raise SaltInvocationError("gpg_passphrase not available in pillar.")
        ret = gpg.export_keys(keyids, secret, passphrase=gpg_passphrase)
    else:
        ret = gpg.export_keys(keyids, secret, expect_passphrase=False)
    return ret


@_restore_ownership
def receive_keys(keyserver=None, keys=None, user=None, gnupghome=None):
    """
    Receive key(s) from keyserver and add them to keychain

    keyserver
        Keyserver to use for searching for GPG keys, defaults to pgp.mit.edu

    keys
        The keyID(s) to retrieve from the keyserver.  Can be specified as a comma
        separated string or a list.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.receive_keys keys='3FAD9F1E'

        salt '*' gpg.receive_keys keys="['3FAD9F1E','3FBD9F2E']"

        salt '*' gpg.receive_keys keys=3FAD9F1E user=username

    """
    ret = {"res": True, "changes": {}, "message": []}

    gpg = _create_gpg(user, gnupghome)

    if not keyserver:
        keyserver = "pgp.mit.edu"

    if isinstance(keys, str):
        keys = keys.split(",")

    recv_data = gpg.recv_keys(keyserver, *keys)
    for result in recv_data.results:
        if "ok" in result:
            if result["ok"] == "1":
                ret["message"].append(
                    "Key {} added to keychain".format(result["fingerprint"])
                )
            elif result["ok"] == "0":
                ret["message"].append(
                    "Key {} already exists in keychain".format(result["fingerprint"])
                )
        elif "problem" in result:
            ret["message"].append("Unable to add key to keychain")
    return ret


def trust_key(keyid=None, fingerprint=None, trust_level=None, user=None):
    """
    Set the trust level for a key in GPG keychain

    keyid
        The keyid of the key to set the trust level for.

    fingerprint
        The fingerprint of the key to set the trust level for.

    trust_level
        The trust level to set for the specified key, must be one
        of the following:
        expired, unknown, not_trusted, marginally, fully, ultimately

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.trust_key keyid='3FAD9F1E' trust_level='marginally'
        salt '*' gpg.trust_key fingerprint='53C96788253E58416D20BCD352952C84C3252192' trust_level='not_trusted'
        salt '*' gpg.trust_key keys=3FAD9F1E trust_level='ultimately' user='username'

    """
    ret = {"res": True, "message": ""}

    _VALID_TRUST_LEVELS = [
        "expired",
        "unknown",
        "not_trusted",
        "marginally",
        "fully",
        "ultimately",
    ]

    if fingerprint and keyid:
        ret["res"] = False
        ret["message"] = "Only specify one argument, fingerprint or keyid"
        return ret

    if not fingerprint:
        if keyid:
            key = get_key(keyid, user=user)
            if key:
                if "fingerprint" not in key:
                    ret["res"] = False
                    ret["message"] = "Fingerprint not found for keyid {}".format(keyid)
                    return ret
                fingerprint = key["fingerprint"]
            else:
                ret["res"] = False
                ret["message"] = "KeyID {} not in GPG keychain".format(keyid)
                return ret
        else:
            ret["res"] = False
            ret["message"] = "Required argument, fingerprint or keyid"
            return ret

    if trust_level not in _VALID_TRUST_LEVELS:
        return "ERROR: Valid trust levels - {}".format(",".join(_VALID_TRUST_LEVELS))

    stdin = "{}:{}\n".format(fingerprint, NUM_TRUST_DICT[trust_level])
    cmd = [_gpg(), "--import-ownertrust"]
    _user = user

    if user == "salt":
        homeDir = os.path.join(__salt__["config.get"]("config_dir"), "gpgkeys")
        cmd.extend(["--homedir", homeDir])
        _user = "root"
    res = __salt__["cmd.run_all"](cmd, stdin=stdin, runas=_user, python_shell=False)

    if not res["retcode"] == 0:
        ret["res"] = False
        ret["message"] = res["stderr"]
    else:
        if res["stderr"]:
            _match = re.findall(r"\d", res["stderr"])
            if len(_match) == 2:
                ret["fingerprint"] = fingerprint
                ret["message"] = "Changing ownership trust from {} to {}.".format(
                    INV_NUM_TRUST_DICT[_match[0]], INV_NUM_TRUST_DICT[_match[1]]
                )
            else:
                ret["fingerprint"] = fingerprint
                ret["message"] = "Setting ownership trust to {}.".format(
                    INV_NUM_TRUST_DICT[_match[0]]
                )
        else:
            ret["message"] = res["stderr"]
    return ret


def sign(
    user=None,
    keyid=None,
    text=None,
    filename=None,
    output=None,
    use_passphrase=False,
    gnupghome=None,
):
    """
    Sign message or file

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    keyid
        The keyid of the key to set the trust level for, defaults to
        first key in the secret keyring.

    text
        The text to sign.

    filename
        The filename to sign.

    output
        The filename where the signed file will be written, default is standard out.

    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.sign text='Hello there.  How are you?'

        salt '*' gpg.sign filename='/path/to/important.file'

        salt '*' gpg.sign filename='/path/to/important.file' use_passphrase=True

    """
    gpg = _create_gpg(user, gnupghome)
    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            raise SaltInvocationError("gpg_passphrase not available in pillar.")
    else:
        gpg_passphrase = None

    # Check for at least one secret key to sign with

    gnupg_version = _LooseVersion(gnupg.__version__)
    if text:
        if gnupg_version &gt;= _LooseVersion("1.3.1"):
            signed_data = gpg.sign(text, default_key=keyid, passphrase=gpg_passphrase)
        else:
            signed_data = gpg.sign(text, keyid=keyid, passphrase=gpg_passphrase)
    elif filename:
        with salt.utils.files.flopen(filename, "rb") as _fp:
            if gnupg_version &gt;= _LooseVersion("1.3.1"):
                signed_data = gpg.sign(
                    text, default_key=keyid, passphrase=gpg_passphrase
                )
            else:
                signed_data = gpg.sign_file(_fp, keyid=keyid, passphrase=gpg_passphrase)
        if output:
            with salt.utils.files.flopen(output, "wb") as fout:
                fout.write(salt.utils.stringutils.to_bytes(signed_data.data))
    else:
        raise SaltInvocationError("filename or text must be passed.")

    return signed_data.data


def verify(
    text=None, user=None, filename=None, gnupghome=None, signature=None, trustmodel=None
):
    """
    Verify a message or file

    text
        The text to verify.

    filename
        The filename to verify.

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    signature
        Specify the filename of a detached signature.

        .. versionadded:: 2018.3.0

    trustmodel
        Explicitly define the used trust model. One of:
          - pgp
          - classic
          - tofu
          - tofu+pgp
          - direct
          - always
          - auto

        .. versionadded:: 2019.2.0

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.verify text='Hello there.  How are you?'
        salt '*' gpg.verify filename='/path/to/important.file'
        salt '*' gpg.verify filename='/path/to/important.file' use_passphrase=True
        salt '*' gpg.verify filename='/path/to/important.file' trustmodel=direct

    """
    gpg = _create_gpg(user)
    trustmodels = ("pgp", "classic", "tofu", "tofu+pgp", "direct", "always", "auto")

    if trustmodel and trustmodel not in trustmodels:
        msg = "Invalid trustmodel defined: {}. Use one of: {}".format(
            trustmodel, ", ".join(trustmodels)
        )
        log.warning(msg)
        return {"res": False, "message": msg}

    extra_args = []

    if trustmodel:
        extra_args.extend(["--trust-model", trustmodel])

    if text:
        verified = gpg.verify(text, extra_args=extra_args)
    elif filename:
        if signature:
            # need to call with fopen instead of flopen due to:
            # https://bitbucket.org/vinay.sajip/python-gnupg/issues/76/verify_file-closes-passed-file-handle
            with salt.utils.files.fopen(signature, "rb") as _fp:
                verified = gpg.verify_file(_fp, filename, extra_args=extra_args)
        else:
            with salt.utils.files.flopen(filename, "rb") as _fp:
                verified = gpg.verify_file(_fp, extra_args=extra_args)
    else:
        raise SaltInvocationError("filename or text must be passed.")

    ret = {}
    if verified.trust_level is not None:
        ret["res"] = True
        ret["username"] = verified.username
        ret["key_id"] = verified.key_id
        ret["trust_level"] = VERIFY_TRUST_LEVELS[str(verified.trust_level)]
        ret["message"] = "The signature is verified."
<a name="1"></a>    else:
        ret["res"] = False
        ret["message"] = "The signature could not be verified."
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret


def encrypt(
    user=None,
    recipients=None,
    text=None,
    filename=None,
    output=None,
    sign=None,
    use_passphrase=False,
    gnupghome=None,
    bare=</b></font>False,
):
    """
    Encrypt a message or file

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    recipients
        The fingerprints for those recipient whom the data is being encrypted for.

    text
        The text to encrypt.

    filename
        The filename to encrypt.

    output
        The filename where the signed file will be written, default is standard out.

    sign
        Whether to sign, in addition to encrypt, the data. ``True`` to use
        default key or fingerprint to specify a different key to sign with.

    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    bare
        If ``True``, return the (armored) encrypted block as a string without
        the standard comment/res dict.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.encrypt text='Hello there.  How are you?' recipients=recipient@example.com

        salt '*' gpg.encrypt filename='/path/to/important.file' recipients=recipient@example.com

        salt '*' gpg.encrypt filename='/path/to/important.file' use_passphrase=True \\
                             recipients=recipient@example.com

    """
    ret = {"res": True, "comment": ""}
    gpg = _create_gpg(user, gnupghome)

    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            raise SaltInvocationError("gpg_passphrase not available in pillar.")
        gpg_passphrase = gpg_passphrase["gpg_passphrase"]
    else:
        gpg_passphrase = None

    if text:
        result = gpg.encrypt(text, recipients, passphrase=gpg_passphrase)
    elif filename:
        if GPG_1_3_1:
            # This version does not allow us to encrypt using the
            # file stream # have to read in the contents and encrypt.
            with salt.utils.files.flopen(filename, "rb") as _fp:
                _contents = salt.utils.stringutils.to_unicode(_fp.read())
            result = gpg.encrypt(
                _contents, recipients, passphrase=gpg_passphrase, output=output
            )
        else:
            # This version allows encrypting the file stream
            with salt.utils.files.flopen(filename, "rb") as _fp:
                if output:
                    result = gpg.encrypt_file(
                        _fp,
                        recipients,
                        passphrase=gpg_passphrase,
                        output=output,
                        sign=sign,
                    )
                else:
                    result = gpg.encrypt_file(
                        _fp, recipients, passphrase=gpg_passphrase, sign=sign
                    )
    else:
        raise SaltInvocationError("filename or text must be passed.")

    if result.ok:
        if not bare:
            if output:
                ret["comment"] = "Encrypted data has been written to {}".format(output)
            else:
                ret["comment"] = result.data
        else:
            ret = result.data
    else:
        if not bare:
            ret["res"] = False
            ret["comment"] = "{}.\nPlease check the salt-minion log.".format(
                result.status
            )
        else:
            ret = False
        log.error(result.stderr)
    return ret


def decrypt(
    user=None,
    text=None,
    filename=None,
    output=None,
    use_passphrase=False,
    gnupghome=None,
    bare=False,
):
    """
    Decrypt a message or file

    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.

    text
        The encrypted text to decrypt.

    filename
        The encrypted filename to decrypt.

    output
        The filename where the decrypted data will be written, default is standard out.

    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.

    gnupghome
        Specify the location where GPG keyring and related files are stored.

    bare
        If ``True``, return the (armored) decrypted block as a string without the
        standard comment/res dict.

    CLI Example:

    .. code-block:: bash

        salt '*' gpg.decrypt filename='/path/to/important.file.gpg'

        salt '*' gpg.decrypt filename='/path/to/important.file.gpg' use_passphrase=True

    """
    ret = {"res": True, "comment": ""}
    gpg = _create_gpg(user, gnupghome)
    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            raise SaltInvocationError("gpg_passphrase not available in pillar.")
        gpg_passphrase = gpg_passphrase["gpg_passphrase"]
    else:
        gpg_passphrase = None

    if text:
        result = gpg.decrypt(text, passphrase=gpg_passphrase)
    elif filename:
        with salt.utils.files.flopen(filename, "rb") as _fp:
            if output:
                result = gpg.decrypt_file(_fp, passphrase=gpg_passphrase, output=output)
            else:
                result = gpg.decrypt_file(_fp, passphrase=gpg_passphrase)
    else:
        raise SaltInvocationError("filename or text must be passed.")

    if result.ok:
        if not bare:
            if output:
                ret["comment"] = "Decrypted data has been written to {}".format(output)
            else:
                ret["comment"] = result.data
        else:
            ret = result.data
    else:
        if not bare:
            ret["res"] = False
            ret["comment"] = "{}.\nPlease check the salt-minion log.".format(
                result.status
            )
        else:
            ret = False

        log.error(result.stderr)

    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
