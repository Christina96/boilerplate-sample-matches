<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for systemd_service.py &amp; gpg_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for systemd_service.py &amp; gpg_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>systemd_service.py (2.1399176%)<th>gpg_1.py (1.9047619%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(21-35)<td><a href="#" name="0">(14-29)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1398-1444)<td><a href="#" name="1">(1182-1194)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>systemd_service.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<a name="0"></a>import errno
import fnmatch
import glob
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
import os
import re
import shlex
import salt.utils.files
import salt.utils.itertools
import salt.utils.path
import salt.utils.stringutils
import salt.utils.systemd
from salt.exceptions import CommandExecutionError
log = logging.getLogger(__name__)
__func_alias__ =</b></font> {
    "reload_": "reload",
    "unmask_": "unmask",
}
SYSTEM_CONFIG_PATHS = ("/lib/systemd/system", "/usr/lib/systemd/system")
LOCAL_CONFIG_PATH = "/etc/systemd/system"
INITSCRIPT_PATH = "/etc/init.d"
VALID_UNIT_TYPES = (
    "service",
    "socket",
    "device",
    "mount",
    "automount",
    "swap",
    "target",
    "path",
    "timer",
)
__virtualname__ = "service"
def __virtual__():
    is_linux = __grains__.get("kernel") == "Linux"
    is_booted = salt.utils.systemd.booted(__context__)
    is_offline = salt.utils.systemd.offline(__context__)
    if is_linux and (is_booted or is_offline):
        return __virtualname__
    return (
        False,
        "The systemd execution module failed to load: only available on Linux "
        "systems which have been booted with systemd.",
    )
def _root(path, root):
    if root:
        return os.path.join(root, os.path.relpath(path, os.path.sep))
    else:
        return path
def _canonical_unit_name(name):
    if not isinstance(name, str):
        name = str(name)
    if any(name.endswith(suffix) for suffix in VALID_UNIT_TYPES):
        return name
    return "%s.service" % name
def _check_available(name):
    if offline():
        raise CommandExecutionError(
            "Cannot run in offline mode. Failed to get information on unit '%s'" % name
        )
    _status = _systemctl_status(name)
    sd_version = salt.utils.systemd.version(__context__)
    if sd_version is not None and sd_version &gt;= 231:
        return 0 &lt;= _status["retcode"] &lt; 4
    out = _status["stdout"].lower()
    if "could not be found" in out:
        return False
    for line in salt.utils.itertools.split(out, "\n"):
        match = re.match(r"\s+loaded:\s+(\S+)", line)
        if match:
            ret = match.group(1) != "not-found"
            break
    else:
        raise CommandExecutionError("Failed to get information on unit '%s'" % name)
    return ret
def _check_for_unit_changes(name):
    contextkey = "systemd._check_for_unit_changes.{}".format(name)
    if contextkey not in __context__:
        if _untracked_custom_unit_found(name) or _unit_file_changed(name):
            systemctl_reload()
        __context__[contextkey] = True
def _check_unmask(name, unmask, unmask_runtime, root=None):
    if unmask:
        unmask_(name, runtime=False, root=root)
    if unmask_runtime:
        unmask_(name, runtime=True, root=root)
def _clear_context():
    for key in list(__context__):
        try:
            if key.startswith("systemd._systemctl_status."):
                __context__.pop(key)
        except AttributeError:
            continue
def _default_runlevel():
    try:
        with salt.utils.files.fopen("/etc/init/rc-sysinit.conf") as fp_:
            for line in fp_:
                line = salt.utils.stringutils.to_unicode(line)
                if line.startswith("env DEFAULT_RUNLEVEL"):
                    runlevel = line.split("=")[-1].strip()
    except Exception:  # pylint: disable=broad-except
        return "2"
    try:
        with salt.utils.files.fopen("/etc/inittab") as fp_:
            for line in fp_:
                line = salt.utils.stringutils.to_unicode(line)
                if not line.startswith("#") and "initdefault" in line:
                    runlevel = line.split(":")[1]
    except Exception:  # pylint: disable=broad-except
        pass
    try:
        valid_strings = {"0", "1", "2", "3", "4", "5", "6", "s", "S", "-s", "single"}
        with salt.utils.files.fopen("/proc/cmdline") as fp_:
            for line in fp_:
                line = salt.utils.stringutils.to_unicode(line)
                for arg in line.strip().split():
                    if arg in valid_strings:
                        runlevel = arg
                        break
    except Exception:  # pylint: disable=broad-except
        pass
    return runlevel
def _get_systemd_services(root):
    ret = set()
    for path in SYSTEM_CONFIG_PATHS + (LOCAL_CONFIG_PATH,):
        path = _root(path, root)
        if os.access(path, os.R_OK) and not os.path.islink(path):
            for fullname in os.listdir(path):
                try:
                    unit_name, unit_type = fullname.rsplit(".", 1)
                except ValueError:
                    continue
                if unit_type in VALID_UNIT_TYPES:
                    ret.add(unit_name if unit_type == "service" else fullname)
    return ret
def _get_sysv_services(root, systemd_services=None):
    initscript_path = _root(INITSCRIPT_PATH, root)
    try:
        sysv_services = os.listdir(initscript_path)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            pass
        elif exc.errno == errno.EACCES:
            log.error(
                "Unable to check sysvinit scripts, permission denied to %s",
                initscript_path,
            )
        else:
            log.error(
                "Error %d encountered trying to check sysvinit scripts: %s",
                exc.errno,
                exc.strerror,
            )
        return []
    if systemd_services is None:
        systemd_services = _get_systemd_services(root)
    ret = []
    for sysv_service in sysv_services:
        if os.access(os.path.join(initscript_path, sysv_service), os.X_OK):
            if sysv_service in systemd_services:
                log.debug(
                    "sysvinit script '%s' found, but systemd unit "
                    "'%s.service' already exists",
                    sysv_service,
                    sysv_service,
                )
                continue
            ret.append(sysv_service)
    return ret
def _get_service_exec():
    contextkey = "systemd._get_service_exec"
    if contextkey not in __context__:
        executables = ("update-rc.d", "chkconfig")
        for executable in executables:
            service_exec = salt.utils.path.which(executable)
            if service_exec is not None:
                break
        else:
            raise CommandExecutionError(
                "Unable to find sysv service manager (tried {})".format(
                    ", ".join(executables)
                )
            )
        __context__[contextkey] = service_exec
    return __context__[contextkey]
def _runlevel():
    contextkey = "systemd._runlevel"
    if contextkey in __context__:
        return __context__[contextkey]
    out = __salt__["cmd.run"]("runlevel", python_shell=False, ignore_retcode=True)
    try:
        ret = out.split()[1]
    except IndexError:
        ret = _default_runlevel()
    __context__[contextkey] = ret
    return ret
def _strip_scope(msg):
    ret = []
    for line in msg.splitlines():
        if not line.endswith(".scope"):
            ret.append(line)
    return "\n".join(ret).strip()
def _systemctl_cmd(action, name=None, systemd_scope=False, no_block=False, root=None):
    ret = []
    if (
        systemd_scope
        and salt.utils.systemd.has_scope(__context__)
        and __salt__["config.get"]("systemd.scope", True)
    ):
        ret.extend(["systemd-run", "--scope"])
    ret.append("systemctl")
    if no_block:
        ret.append("--no-block")
    if root:
        ret.extend(["--root", root])
    if isinstance(action, str):
        action = shlex.split(action)
    ret.extend(action)
    if name is not None:
        ret.append(_canonical_unit_name(name))
    if "status" in ret:
        ret.extend(["-n", "0"])
    return ret
def _systemctl_status(name):
    contextkey = "systemd._systemctl_status.%s" % name
    if contextkey in __context__:
        return __context__[contextkey]
    __context__[contextkey] = __salt__["cmd.run_all"](
        _systemctl_cmd("status", name),
        python_shell=False,
        redirect_stderr=True,
        ignore_retcode=True,
    )
    return __context__[contextkey]
def _sysv_enabled(name, root):
    rc = _root("/etc/rc{}.d/S*{}".format(_runlevel(), name), root)
    for match in glob.glob(rc):
        if re.match(r"S\d{,2}%s" % name, os.path.basename(match)):
            return True
    return False
def _untracked_custom_unit_found(name, root=None):
    system = _root("/etc/systemd/system", root)
    unit_path = os.path.join(system, _canonical_unit_name(name))
    return os.access(unit_path, os.R_OK) and not _check_available(name)
def _unit_file_changed(name):
    status = _systemctl_status(name)["stdout"].lower()
    return "'systemctl daemon-reload'" in status
def systemctl_reload():
    out = __salt__["cmd.run_all"](
        _systemctl_cmd("--system daemon-reload"),
        python_shell=False,
        redirect_stderr=True,
    )
    if out["retcode"] != 0:
        raise CommandExecutionError(
            "Problem performing systemctl daemon-reload: %s" % out["stdout"]
        )
    _clear_context()
    return True
def get_running():
    ret = set()
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager"),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            comps = line.strip().split()
            fullname = comps[0]
            if len(comps) &gt; 3:
                active_state = comps[3]
        except ValueError as exc:
            log.error(exc)
            continue
        else:
            if active_state != "running":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)
    return sorted(ret)
def get_enabled(root=None):
    ret = set()
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            fullname, unit_state = line.strip().split()[:2]
        except ValueError:
            continue
        else:
            if unit_state.split()[0] != "enabled":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)
    ret.update({x for x in _get_sysv_services(root) if _sysv_enabled(x, root)})
    return sorted(ret)
def get_disabled(root=None):
    ret = set()
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            fullname, unit_state = line.strip().split()[:2]
        except ValueError:
            continue
        else:
            if unit_state.split()[0] != "disabled":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)
    ret.update({x for x in _get_sysv_services(root) if not _sysv_enabled(x, root)})
    return sorted(ret)
def get_static(root=None):
    ret = set()
    out = __salt__["cmd.run"](
        _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
        python_shell=False,
        ignore_retcode=True,
    )
    for line in salt.utils.itertools.split(out, "\n"):
        try:
            fullname, unit_state = line.strip().split()[:2]
        except ValueError:
            continue
        else:
            if unit_state != "static":
                continue
        try:
            unit_name, unit_type = fullname.rsplit(".", 1)
        except ValueError:
            continue
        if unit_type in VALID_UNIT_TYPES:
            ret.add(unit_name if unit_type == "service" else fullname)
    return sorted(ret)
def get_all(root=None):
    ret = _get_systemd_services(root)
    ret.update(set(_get_sysv_services(root, systemd_services=ret)))
    return sorted(ret)
def available(name):
    _check_for_unit_changes(name)
    return _check_available(name)
def missing(name):
    return not available(name)
def unmask_(name, runtime=False, root=None):
    _check_for_unit_changes(name)
    if not masked(name, runtime, root=root):
        log.debug("Service '%s' is not %smasked", name, "runtime-" if runtime else "")
        return True
    cmd = "unmask --runtime" if runtime else "unmask"
    out = __salt__["cmd.run_all"](
        _systemctl_cmd(cmd, name, systemd_scope=True, root=root),
        python_shell=False,
        redirect_stderr=True,
    )
    if out["retcode"] != 0:
        raise CommandExecutionError("Failed to unmask service '%s'" % name)
    return True
def mask(name, runtime=False, root=None):
    _check_for_unit_changes(name)
    cmd = "mask --runtime" if runtime else "mask"
    out = __salt__["cmd.run_all"](
        _systemctl_cmd(cmd, name, systemd_scope=True, root=root),
        python_shell=False,
        redirect_stderr=True,
    )
    if out["retcode"] != 0:
        raise CommandExecutionError(
            "Failed to mask service '%s'" % name, info=out["stdout"]
        )
    return True
def masked(name, runtime=False, root=None):
    _check_for_unit_changes(name)
    root_dir = _root("/run" if runtime else "/etc", root)
    link_path = os.path.join(root_dir, "systemd", "system", _canonical_unit_name(name))
    try:
        return os.readlink(link_path) == "/dev/null"
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            log.trace(
                "Path %s does not exist. This is normal if service '%s' is "
                "not masked or does not exist.",
                link_path,
                name,
            )
        elif exc.errno == errno.EINVAL:
            log.error(
                "Failed to check mask status for service %s. Path %s is a "
                "file, not a symlink. This could be caused by changes in "
                "systemd and is probably a bug in Salt. Please report this "
                "to the developers.",
                name,
                link_path,
            )
        return False
def start(name, no_block=False, unmask=False, unmask_runtime=False):
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("start", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )
    if ret["retcode"] != 0:
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True
def stop(name, no_block=False):
    _check_for_unit_changes(name)
    return (
        __salt__["cmd.run_all"](
            _systemctl_cmd("stop", name, systemd_scope=True, no_block=no_block),
            python_shell=False,
        )["retcode"]
        == 0
    )
def restart(name, no_block=False, unmask=False, unmask_runtime=False):
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("restart", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )
    if ret["retcode"] != 0:
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True
def reload_(name, no_block=False, unmask=False, unmask_runtime=False):
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("reload", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )
    if ret["retcode"] != 0:
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True
def force_reload(name, no_block=True, unmask=False, unmask_runtime=False):
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime)
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd("force-reload", name, systemd_scope=True, no_block=no_block),
        python_shell=False,
    )
    if ret["retcode"] != 0:
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True
def status(name, sig=None):  # pylint: disable=unused-argument
    contains_globbing = bool(re.search(r"\*|\?|\[.+\]", name))
    if contains_globbing:
        services = fnmatch.filter(get_all(), name)
    else:
        services = [name]
    results = {}
    for service in services:
        _check_for_unit_changes(service)
        results[service] = (
            __salt__["cmd.retcode"](
                _systemctl_cmd("is-active", service),
                python_shell=False,
                ignore_retcode=True,
            )
            == 0
        )
    if contains_globbing:
        return results
    return results[name]
def enable(
    name, no_block=False, unmask=False, unmask_runtime=False, root=None, **kwargs
):  # pylint: disable=unused-argument
    _check_for_unit_changes(name)
    _check_unmask(name, unmask, unmask_runtime, root)
    if name in _get_sysv_services(root):
        cmd = []
        if salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
            "systemd.scope", True
        ):
            cmd.extend(["systemd-run", "--scope"])
        service_exec = _get_service_exec()
        if service_exec.endswith("/update-rc.d"):
            cmd.extend([service_exec, "-f", name, "defaults", "99"])
        elif service_exec.endswith("/chkconfig"):
            cmd.extend([service_exec, name, "on"])
        return (
            __salt__["cmd.retcode"](cmd, python_shell=False, ignore_retcode=True) == 0
        )
    ret = __salt__["cmd.run_all"](
        _systemctl_cmd(
            "enable", name, systemd_scope=True, no_block=no_block, root=root
        ),
        python_shell=False,
        ignore_retcode=True,
    )
    if ret["retcode"] != 0:
        raise CommandExecutionError(_strip_scope(ret["stderr"]))
    return True
def disable(
    name, no_block=False, root=None, **kwargs
):  # pylint: disable=unused-argument
    _check_for_unit_changes(name)
    if name in _get_sysv_services(root):
        cmd = []
        if salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
            "systemd.scope", True
        ):
            cmd.extend(["systemd-run", "--scope"])
        service_exec = _get_service_exec()
        if service_exec.endswith("/update-rc.d"):
            cmd.extend([service_exec, "-f", name, "remove"])
        elif service_exec.endswith("/chkconfig"):
            cmd.extend([service_exec, name, "off"])
        return (
            __salt__["cmd.retcode"](cmd, python_shell=False, ignore_retcode=True) == 0
        )
    return (
        __salt__["cmd.run_all"](
            _systemctl_cmd(
                "disable", name, systemd_scope=True, no_block=no_block, root=root
            ),
            python_shell=False,
            ignore_retcode=True,
        )["retcode"]
        == 0
    )
def enabled(name, root=None, **kwargs):  # pylint: disable=unused-argument
    if (
        __salt__["cmd.retcode"](
            _systemctl_cmd("is-enabled", name, root=root),
            python_shell=False,
            ignore_retcode=True,
        )
        == 0
    ):
        return True
    elif "@" in name:
        local_config_path = _root(LOCAL_CONFIG_PATH, "/")
        cmd = [
            "find",
            local_config_path,
            "-name",
            name,
            "-type",
            "l",
            "-print",
            "-quit",
        ]
        if bool(__salt__["cmd.run"](cmd, python_shell=False)):
            return True
    elif name in _get_sysv_services(root):
        return _sysv_enabled(name, root)
    return False
def disabled(name, root=None):
    return not enabled(name, root=root)
def show(name, root=None):
    ret = {}
    out = __salt__["cmd.run"](
        _systemctl_cmd("show", name, root=root), python_shell=False
    )
    for line in salt.utils.itertools.split(out, "\n"):
        comps = line.split("=")
        name = comps[0]
        value = "=".join(comps[1:])
        if value.startswith("{"):
            value = value.replace("{", "").replace("}", "")
            ret[name] = {}
            for item in value.split(" ; "):
                comps = item.split("=")
                ret[name][comps[0].strip()] = comps[1].strip()
        elif name in ("Before", "After", "Wants"):
            ret[name] = value.split()
        else:
            ret[name] = value
    return ret
def execs(root=None):
    ret = {}
    for service in get_all(root=root):
        data = show(service, root=root)
<a name="1"></a>        if "ExecStart" not in data:
            continue
        ret[service] = data["ExecStart"]["path"]
    <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
def firstboot(
    locale=None,
    locale_message=None,
    keymap=None,
    timezone=None,
    hostname=None,
    machine_id=None,
    root=None,
):
    cmd = ["systemd-firstboot"]
    parameters =</b></font> [
        ("locale", locale),
        ("locale-message", locale_message),
        ("keymap", keymap),
        ("timezone", timezone),
        ("hostname", hostname),
        ("machine-ID", machine_id),
        ("root", root),
    ]
    for parameter, value in parameters:
        if value:
            cmd.extend(["--{}".format(parameter), str(value)])
    out = __salt__["cmd.run_all"](cmd)
    if out["retcode"] != 0:
        raise CommandExecutionError("systemd-firstboot error: {}".format(out["stderr"]))
    return True
def offline():
    return salt.utils.systemd.offline(__context__)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>gpg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import functools
import logging
import os
import re
import time
import salt.utils.files
import salt.utils.path
import salt.utils.stringutils
from salt.exceptions import SaltInvocationError
from salt.utils.versions import LooseVersion as _LooseVersion
log = logging.getLogger(__name__)
__virtualname__ =</b></font> "gpg"
LETTER_TRUST_DICT = {
    "e": "Expired",
    "q": "Unknown",
    "n": "Not Trusted",
    "f": "Fully Trusted",
    "m": "Marginally Trusted",
    "u": "Ultimately Trusted",
    "-": "Unknown",
}
NUM_TRUST_DICT = {
    "expired": "1",
    "unknown": "2",
    "not_trusted": "3",
    "marginally": "4",
    "fully": "5",
    "ultimately": "6",
}
INV_NUM_TRUST_DICT = {
    "1": "Expired",
    "2": "Unknown",
    "3": "Not Trusted",
    "4": "Marginally",
    "5": "Fully Trusted",
    "6": "Ultimately Trusted",
}
VERIFY_TRUST_LEVELS = {
    "0": "Undefined",
    "1": "Never",
    "2": "Marginal",
    "3": "Fully",
    "4": "Ultimate",
}
GPG_1_3_1 = False
try:
    import gnupg
    HAS_GPG_BINDINGS = True
    GPG_1_3_1 = _LooseVersion(gnupg.__version__) &gt;= _LooseVersion("1.3.1")
except ImportError:
    HAS_GPG_BINDINGS = False
def _gpg():
    return salt.utils.path.which("gpg")
def __virtual__():
    if not _gpg():
        return (
            False,
            "The gpg execution module cannot be loaded: gpg binary is not in the path.",
        )
    return (
        __virtualname__
        if HAS_GPG_BINDINGS
        else (
            False,
            "The gpg execution module cannot be loaded; the gnupg python module is not"
            " installed.",
        )
    )
def _get_user_info(user=None):
    if not user:
        user = __salt__["config.option"]("user")
    userinfo = __salt__["user.info"](user)
    if not userinfo:
        if user == "salt":
            userinfo = _get_user_info()
        else:
            raise SaltInvocationError("User {} does not exist".format(user))
    return userinfo
def _get_user_gnupghome(user):
    if user == "salt":
        gnupghome = os.path.join(__salt__["config.get"]("config_dir"), "gpgkeys")
    else:
        gnupghome = os.path.join(_get_user_info(user)["home"], ".gnupg")
    return gnupghome
def _restore_ownership(func):
    @functools.wraps(func)
    def func_wrapper(*args, **kwargs):
        user = kwargs.get("user")
        gnupghome = kwargs.get("gnupghome")
        if not gnupghome:
            gnupghome = _get_user_gnupghome(user)
        userinfo = _get_user_info(user)
        run_user = _get_user_info()
        if userinfo["uid"] != run_user["uid"] and os.path.exists(gnupghome):
            group = __salt__["file.gid_to_group"](run_user["gid"])
            for path in [gnupghome] + __salt__["file.find"](gnupghome):
                __salt__["file.chown"](path, run_user["name"], group)
        for key in list(kwargs):
            if key.startswith("__"):
                del kwargs[key]
        ret = func(*args, **kwargs)
        if userinfo["uid"] != run_user["uid"]:
            group = __salt__["file.gid_to_group"](userinfo["gid"])
            for path in [gnupghome] + __salt__["file.find"](gnupghome):
                __salt__["file.chown"](path, user, group)
        return ret
    return func_wrapper
def _create_gpg(user=None, gnupghome=None):
    if not gnupghome:
        gnupghome = _get_user_gnupghome(user)
    if GPG_1_3_1:
        gpg = gnupg.GPG(homedir=gnupghome)  # pylint: disable=unexpected-keyword-arg
    else:
        gpg = gnupg.GPG(gnupghome=gnupghome)
    return gpg
def _list_keys(user=None, gnupghome=None, secret=False):
    gpg = _create_gpg(user, gnupghome)
    _keys = gpg.list_keys(secret)
    return _keys
def _search_keys(text, keyserver, user=None):
    gpg = _create_gpg(user)
    if keyserver:
        _keys = gpg.search_keys(text, keyserver)
    else:
        _keys = gpg.search_keys(text)
    return _keys
def search_keys(text, keyserver=None, user=None):
    if GPG_1_3_1:
        raise SaltInvocationError(
            "The search_keys function is not support with this version of python-gnupg."
        )
    else:
        if not keyserver:
            keyserver = "pgp.mit.edu"
        _keys = []
        for _key in _search_keys(text, keyserver, user):
            tmp = {"keyid": _key["keyid"], "uids": _key["uids"]}
            expires = _key.get("expires", None)
            date = _key.get("date", None)
            length = _key.get("length", None)
            if expires:
                tmp["expires"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["expires"]))
                )
            if date:
                tmp["created"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["date"]))
                )
            if length:
                tmp["keyLength"] = _key["length"]
            _keys.append(tmp)
        return _keys
def list_keys(user=None, gnupghome=None):
    _keys = []
    for _key in _list_keys(user, gnupghome):
        tmp = {
            "keyid": _key["keyid"],
            "fingerprint": _key["fingerprint"],
            "uids": _key["uids"],
        }
        expires = _key.get("expires", None)
        date = _key.get("date", None)
        length = _key.get("length", None)
        owner_trust = _key.get("ownertrust", None)
        trust = _key.get("trust", None)
        if expires:
            tmp["expires"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["expires"]))
            )
        if date:
            tmp["created"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["date"]))
            )
        if length:
            tmp["keyLength"] = _key["length"]
        if owner_trust:
            tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
        if trust:
            tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
        _keys.append(tmp)
    return _keys
def list_secret_keys(user=None, gnupghome=None):
    _keys = []
    for _key in _list_keys(user, gnupghome, secret=True):
        tmp = {
            "keyid": _key["keyid"],
            "fingerprint": _key["fingerprint"],
            "uids": _key["uids"],
        }
        expires = _key.get("expires", None)
        date = _key.get("date", None)
        length = _key.get("length", None)
        owner_trust = _key.get("ownertrust", None)
        trust = _key.get("trust", None)
        if expires:
            tmp["expires"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["expires"]))
            )
        if date:
            tmp["created"] = time.strftime(
                "%Y-%m-%d", time.localtime(float(_key["date"]))
            )
        if length:
            tmp["keyLength"] = _key["length"]
        if owner_trust:
            tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
        if trust:
            tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
        _keys.append(tmp)
    return _keys
@_restore_ownership
def create_key(
    key_type="RSA",
    key_length=1024,
    name_real="Autogenerated Key",
    name_comment="Generated by SaltStack",
    name_email=None,
    subkey_type=None,
    subkey_length=None,
    expire_date=None,
    use_passphrase=False,
    user=None,
    gnupghome=None,
):
    ret = {"res": True, "fingerprint": "", "message": ""}
    create_params = {
        "key_type": key_type,
        "key_length": key_length,
        "name_real": name_real,
        "name_comment": name_comment,
    }
    gpg = _create_gpg(user, gnupghome)
    if name_email:
        create_params["name_email"] = name_email
    if subkey_type:
        create_params["subkey_type"] = subkey_type
    if subkey_length:
        create_params["subkey_length"] = subkey_length
    if expire_date:
        create_params["expire_date"] = expire_date
    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            ret["res"] = False
            ret["message"] = "gpg_passphrase not available in pillar."
            return ret
        else:
            create_params["passphrase"] = gpg_passphrase
    else:
        create_params["no_protection"] = True
    input_data = gpg.gen_key_input(**create_params)
    if "No-Protection: True" in input_data:
        temp_data = input_data.splitlines()
        temp_data.remove("No-Protection: True")
        temp_data.insert(temp_data.index("%commit"), "%no-protection")
        input_data = "\n".join(temp_data) + "\n"
    key = gpg.gen_key(input_data)
    if key.fingerprint:
        ret["fingerprint"] = key.fingerprint
        ret["message"] = "GPG key pair successfully generated."
    else:
        ret["res"] = False
        ret["message"] = "Unable to generate GPG key pair."
    return ret
def delete_key(
    keyid=None,
    fingerprint=None,
    delete_secret=False,
    user=None,
    gnupghome=None,
    use_passphrase=True,
):
    ret = {"res": True, "message": ""}
    if fingerprint and keyid:
        ret["res"] = False
        ret["message"] = "Only specify one argument, fingerprint or keyid"
        return ret
    if not fingerprint and not keyid:
        ret["res"] = False
        ret["message"] = "Required argument, fingerprint or keyid"
        return ret
    gpg = _create_gpg(user, gnupghome)
    key = get_key(keyid, fingerprint, user)
    def __delete_key(fingerprint, secret, use_passphrase):
        if use_passphrase:
            gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
            if not gpg_passphrase:
                ret["res"] = False
                ret["message"] = "gpg_passphrase not available in pillar."
                return ret
            else:
                out = gpg.delete_keys(fingerprint, secret, passphrase=gpg_passphrase)
        else:
            out = gpg.delete_keys(fingerprint, secret, expect_passphrase=False)
        return out
    if key:
        fingerprint = key["fingerprint"]
        skey = get_secret_key(keyid, fingerprint, user)
        if skey:
            if not delete_secret:
                ret["res"] = False
                ret[
                    "message"
                ] = "Secret key exists, delete first or pass delete_secret=True."
                return ret
            else:
                if str(__delete_key(fingerprint, True, use_passphrase)) == "ok":
                    ret["message"] = "Secret key for {} deleted\n".format(fingerprint)
        if str(__delete_key(fingerprint, False, use_passphrase)) == "ok":
            ret["message"] += "Public key for {} deleted".format(fingerprint)
        ret["res"] = True
        return ret
    else:
        ret["res"] = False
        ret["message"] = "Key not available in keychain."
        return ret
def get_key(keyid=None, fingerprint=None, user=None, gnupghome=None):
    tmp = {}
    for _key in _list_keys(user, gnupghome):
        if (
            _key["fingerprint"] == fingerprint
            or _key["keyid"] == keyid
            or _key["keyid"][8:] == keyid
        ):
            tmp["keyid"] = _key["keyid"]
            tmp["fingerprint"] = _key["fingerprint"]
            tmp["uids"] = _key["uids"]
            expires = _key.get("expires", None)
            date = _key.get("date", None)
            length = _key.get("length", None)
            owner_trust = _key.get("ownertrust", None)
            trust = _key.get("trust", None)
            if expires:
                tmp["expires"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["expires"]))
                )
            if date:
                tmp["created"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["date"]))
                )
            if length:
                tmp["keyLength"] = _key["length"]
            if owner_trust:
                tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
            if trust:
                tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
    if not tmp:
        return False
    else:
        return tmp
def get_secret_key(keyid=None, fingerprint=None, user=None, gnupghome=None):
    tmp = {}
    for _key in _list_keys(user, gnupghome, secret=True):
        if (
            _key["fingerprint"] == fingerprint
            or _key["keyid"] == keyid
            or _key["keyid"][8:] == keyid
        ):
            tmp["keyid"] = _key["keyid"]
            tmp["fingerprint"] = _key["fingerprint"]
            tmp["uids"] = _key["uids"]
            expires = _key.get("expires", None)
            date = _key.get("date", None)
            length = _key.get("length", None)
            owner_trust = _key.get("ownertrust", None)
            trust = _key.get("trust", None)
            if expires:
                tmp["expires"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["expires"]))
                )
            if date:
                tmp["created"] = time.strftime(
                    "%Y-%m-%d", time.localtime(float(_key["date"]))
                )
            if length:
                tmp["keyLength"] = _key["length"]
            if owner_trust:
                tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
            if trust:
                tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
    if not tmp:
        return False
    else:
        return tmp
@_restore_ownership
def import_key(text=None, filename=None, user=None, gnupghome=None):
    r"""
    Import a key from text or file
    text
        The text containing to import.
    filename
        The filename containing the key to import.
    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.
    gnupghome
        Specify the location where GPG keyring and related files are stored.
    CLI Example:
    .. code-block:: bash
        salt '*' gpg.import_key text='-----BEGIN PGP PUBLIC KEY BLOCK-----\n ... -----END PGP PUBLIC KEY BLOCK-----'
        salt '*' gpg.import_key filename='/path/to/public-key-file'
    Export a key from the GPG keychain
    keyids
        The key ID(s) of the key(s) to be exported. Can be specified as a comma
        separated string or a list. Anything which GnuPG itself accepts to
        identify a key - for example, the key ID or the fingerprint could be
        used.
    secret
        Export the secret key identified by the ``keyids`` information passed.
    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.
    gnupghome
        Specify the location where GPG keyring and related files are stored.
    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.
        .. versionadded:: 3003
    CLI Example:
    .. code-block:: bash
        salt '*' gpg.export_key keyids=3FAD9F1E
        salt '*' gpg.export_key keyids=3FAD9F1E secret=True
        salt '*' gpg.export_key keyids="['3FAD9F1E','3FBD8F1E']" user=username
    Receive key(s) from keyserver and add them to keychain
    keyserver
        Keyserver to use for searching for GPG keys, defaults to pgp.mit.edu
    keys
        The keyID(s) to retrieve from the keyserver.  Can be specified as a comma
        separated string or a list.
    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.
    gnupghome
        Specify the location where GPG keyring and related files are stored.
    CLI Example:
    .. code-block:: bash
        salt '*' gpg.receive_keys keys='3FAD9F1E'
        salt '*' gpg.receive_keys keys="['3FAD9F1E','3FBD9F2E']"
        salt '*' gpg.receive_keys keys=3FAD9F1E user=username
    Set the trust level for a key in GPG keychain
    keyid
        The keyid of the key to set the trust level for.
    fingerprint
        The fingerprint of the key to set the trust level for.
    trust_level
        The trust level to set for the specified key, must be one
        of the following:
        expired, unknown, not_trusted, marginally, fully, ultimately
    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.
    CLI Example:
    .. code-block:: bash
        salt '*' gpg.trust_key keyid='3FAD9F1E' trust_level='marginally'
        salt '*' gpg.trust_key fingerprint='53C96788253E58416D20BCD352952C84C3252192' trust_level='not_trusted'
        salt '*' gpg.trust_key keys=3FAD9F1E trust_level='ultimately' user='username'
    Sign message or file
    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.
    keyid
        The keyid of the key to set the trust level for, defaults to
        first key in the secret keyring.
    text
        The text to sign.
    filename
        The filename to sign.
    output
        The filename where the signed file will be written, default is standard out.
    use_passphrase
        Whether to use a passphrase with the signing key. Passphrase is received
        from Pillar.
    gnupghome
        Specify the location where GPG keyring and related files are stored.
    CLI Example:
    .. code-block:: bash
        salt '*' gpg.sign text='Hello there.  How are you?'
        salt '*' gpg.sign filename='/path/to/important.file'
        salt '*' gpg.sign filename='/path/to/important.file' use_passphrase=True
    Verify a message or file
    text
        The text to verify.
    filename
        The filename to verify.
    user
        Which user's keychain to access, defaults to user Salt is running as.
        Passing the user as ``salt`` will set the GnuPG home directory to the
        ``/etc/salt/gpgkeys``.
    gnupghome
        Specify the location where GPG keyring and related files are stored.
    signature
        Specify the filename of a detached signature.
        .. versionadded:: 2018.3.0
    trustmodel
        Explicitly define the used trust model. One of:
          - pgp
          - classic
          - tofu
          - tofu+pgp
          - direct
          - always
          - auto
        .. versionadded:: 2019.2.0
    CLI Example:
    .. code-block:: bash
        salt '*' gpg.verify text='Hello there.  How are you?'
        salt '*' gpg.verify filename='/path/to/important.file'
        salt '*' gpg.verify filename='/path/to/important.file' use_passphrase=True
        salt '*' gpg.verify filename='/path/to/important.file' trustmodel=direct
    <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
def encrypt(
    user=None,
    recipients=None,
    text=None,
    filename=None,
    output=None,
    sign=None,
    use_passphrase=False,
    gnupghome=None,
    bare=</b></font>False,
):
    ret = {"res": True, "comment": ""}
    gpg = _create_gpg(user, gnupghome)
    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            raise SaltInvocationError("gpg_passphrase not available in pillar.")
        gpg_passphrase = gpg_passphrase["gpg_passphrase"]
    else:
        gpg_passphrase = None
    if text:
        result = gpg.encrypt(text, recipients, passphrase=gpg_passphrase)
    elif filename:
        if GPG_1_3_1:
            with salt.utils.files.flopen(filename, "rb") as _fp:
                _contents = salt.utils.stringutils.to_unicode(_fp.read())
            result = gpg.encrypt(
                _contents, recipients, passphrase=gpg_passphrase, output=output
            )
        else:
            with salt.utils.files.flopen(filename, "rb") as _fp:
                if output:
                    result = gpg.encrypt_file(
                        _fp,
                        recipients,
                        passphrase=gpg_passphrase,
                        output=output,
                        sign=sign,
                    )
                else:
                    result = gpg.encrypt_file(
                        _fp, recipients, passphrase=gpg_passphrase, sign=sign
                    )
    else:
        raise SaltInvocationError("filename or text must be passed.")
    if result.ok:
        if not bare:
            if output:
                ret["comment"] = "Encrypted data has been written to {}".format(output)
            else:
                ret["comment"] = result.data
        else:
            ret = result.data
    else:
        if not bare:
            ret["res"] = False
            ret["comment"] = "{}.\nPlease check the salt-minion log.".format(
                result.status
            )
        else:
            ret = False
        log.error(result.stderr)
    return ret
def decrypt(
    user=None,
    text=None,
    filename=None,
    output=None,
    use_passphrase=False,
    gnupghome=None,
    bare=False,
):
    ret = {"res": True, "comment": ""}
    gpg = _create_gpg(user, gnupghome)
    if use_passphrase:
        gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
        if not gpg_passphrase:
            raise SaltInvocationError("gpg_passphrase not available in pillar.")
        gpg_passphrase = gpg_passphrase["gpg_passphrase"]
    else:
        gpg_passphrase = None
    if text:
        result = gpg.decrypt(text, passphrase=gpg_passphrase)
    elif filename:
        with salt.utils.files.flopen(filename, "rb") as _fp:
            if output:
                result = gpg.decrypt_file(_fp, passphrase=gpg_passphrase, output=output)
            else:
                result = gpg.decrypt_file(_fp, passphrase=gpg_passphrase)
    else:
        raise SaltInvocationError("filename or text must be passed.")
    if result.ok:
        if not bare:
            if output:
                ret["comment"] = "Decrypted data has been written to {}".format(output)
            else:
                ret["comment"] = result.data
        else:
            ret = result.data
    else:
        if not bare:
            ret["res"] = False
            ret["comment"] = "{}.\nPlease check the salt-minion log.".format(
                result.status
            )
        else:
            ret = False
        log.error(result.stderr)
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
