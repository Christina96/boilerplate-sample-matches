<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for systemd_service.py &amp; gpg_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for systemd_service.py &amp; gpg_1.py
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>systemd_service.py (2.1399176%)<th>gpg_1.py (1.9047619%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(21-35)<td><a href="#" name="0">(14-29)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1398-1444)<td><a href="#" name="1">(1182-1194)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>systemd_service.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import fnmatch
2 import glob
3 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import logging
4 import os
5 import re
6 import shlex
7 import salt.utils.files
8 import salt.utils.itertools
9 import salt.utils.path
10 import salt.utils.stringutils
11 import salt.utils.systemd
12 from salt.exceptions import CommandExecutionError
13 log = logging.getLogger(__name__)
14 __func_alias__ =</b></font> {
15     "reload_": "reload",
16     "unmask_": "unmask",
17 }
18 SYSTEM_CONFIG_PATHS = ("/lib/systemd/system", "/usr/lib/systemd/system")
19 LOCAL_CONFIG_PATH = "/etc/systemd/system"
20 INITSCRIPT_PATH = "/etc/init.d"
21 VALID_UNIT_TYPES = (
22     "service",
23     "socket",
24     "device",
25     "mount",
26     "automount",
27     "swap",
28     "target",
29     "path",
30     "timer",
31 )
32 __virtualname__ = "service"
33 def __virtual__():
34     is_linux = __grains__.get("kernel") == "Linux"
35     is_booted = salt.utils.systemd.booted(__context__)
36     is_offline = salt.utils.systemd.offline(__context__)
37     if is_linux and (is_booted or is_offline):
38         return __virtualname__
39     return (
40         False,
41         "The systemd execution module failed to load: only available on Linux "
42         "systems which have been booted with systemd.",
43     )
44 def _root(path, root):
45     if root:
46         return os.path.join(root, os.path.relpath(path, os.path.sep))
47     else:
48         return path
49 def _canonical_unit_name(name):
50     if not isinstance(name, str):
51         name = str(name)
52     if any(name.endswith(suffix) for suffix in VALID_UNIT_TYPES):
53         return name
54     return "%s.service" % name
55 def _check_available(name):
56     if offline():
57         raise CommandExecutionError(
58             "Cannot run in offline mode. Failed to get information on unit '%s'" % name
59         )
60     _status = _systemctl_status(name)
61     sd_version = salt.utils.systemd.version(__context__)
62     if sd_version is not None and sd_version &gt;= 231:
63         return 0 &lt;= _status["retcode"] &lt; 4
64     out = _status["stdout"].lower()
65     if "could not be found" in out:
66         return False
67     for line in salt.utils.itertools.split(out, "\n"):
68         match = re.match(r"\s+loaded:\s+(\S+)", line)
69         if match:
70             ret = match.group(1) != "not-found"
71             break
72     else:
73         raise CommandExecutionError("Failed to get information on unit '%s'" % name)
74     return ret
75 def _check_for_unit_changes(name):
76     contextkey = "systemd._check_for_unit_changes.{}".format(name)
77     if contextkey not in __context__:
78         if _untracked_custom_unit_found(name) or _unit_file_changed(name):
79             systemctl_reload()
80         __context__[contextkey] = True
81 def _check_unmask(name, unmask, unmask_runtime, root=None):
82     if unmask:
83         unmask_(name, runtime=False, root=root)
84     if unmask_runtime:
85         unmask_(name, runtime=True, root=root)
86 def _clear_context():
87     for key in list(__context__):
88         try:
89             if key.startswith("systemd._systemctl_status."):
90                 __context__.pop(key)
91         except AttributeError:
92             continue
93 def _default_runlevel():
94     try:
95         with salt.utils.files.fopen("/etc/init/rc-sysinit.conf") as fp_:
96             for line in fp_:
97                 line = salt.utils.stringutils.to_unicode(line)
98                 if line.startswith("env DEFAULT_RUNLEVEL"):
99                     runlevel = line.split("=")[-1].strip()
100     except Exception:  # pylint: disable=broad-except
101         return "2"
102     try:
103         with salt.utils.files.fopen("/etc/inittab") as fp_:
104             for line in fp_:
105                 line = salt.utils.stringutils.to_unicode(line)
106                 if not line.startswith("#") and "initdefault" in line:
107                     runlevel = line.split(":")[1]
108     except Exception:  # pylint: disable=broad-except
109         pass
110     try:
111         valid_strings = {"0", "1", "2", "3", "4", "5", "6", "s", "S", "-s", "single"}
112         with salt.utils.files.fopen("/proc/cmdline") as fp_:
113             for line in fp_:
114                 line = salt.utils.stringutils.to_unicode(line)
115                 for arg in line.strip().split():
116                     if arg in valid_strings:
117                         runlevel = arg
118                         break
119     except Exception:  # pylint: disable=broad-except
120         pass
121     return runlevel
122 def _get_systemd_services(root):
123     ret = set()
124     for path in SYSTEM_CONFIG_PATHS + (LOCAL_CONFIG_PATH,):
125         path = _root(path, root)
126         if os.access(path, os.R_OK) and not os.path.islink(path):
127             for fullname in os.listdir(path):
128                 try:
129                     unit_name, unit_type = fullname.rsplit(".", 1)
130                 except ValueError:
131                     continue
132                 if unit_type in VALID_UNIT_TYPES:
133                     ret.add(unit_name if unit_type == "service" else fullname)
134     return ret
135 def _get_sysv_services(root, systemd_services=None):
136     initscript_path = _root(INITSCRIPT_PATH, root)
137     try:
138         sysv_services = os.listdir(initscript_path)
139     except OSError as exc:
140         if exc.errno == errno.ENOENT:
141             pass
142         elif exc.errno == errno.EACCES:
143             log.error(
144                 "Unable to check sysvinit scripts, permission denied to %s",
145                 initscript_path,
146             )
147         else:
148             log.error(
149                 "Error %d encountered trying to check sysvinit scripts: %s",
150                 exc.errno,
151                 exc.strerror,
152             )
153         return []
154     if systemd_services is None:
155         systemd_services = _get_systemd_services(root)
156     ret = []
157     for sysv_service in sysv_services:
158         if os.access(os.path.join(initscript_path, sysv_service), os.X_OK):
159             if sysv_service in systemd_services:
160                 log.debug(
161                     "sysvinit script '%s' found, but systemd unit "
162                     "'%s.service' already exists",
163                     sysv_service,
164                     sysv_service,
165                 )
166                 continue
167             ret.append(sysv_service)
168     return ret
169 def _get_service_exec():
170     contextkey = "systemd._get_service_exec"
171     if contextkey not in __context__:
172         executables = ("update-rc.d", "chkconfig")
173         for executable in executables:
174             service_exec = salt.utils.path.which(executable)
175             if service_exec is not None:
176                 break
177         else:
178             raise CommandExecutionError(
179                 "Unable to find sysv service manager (tried {})".format(
180                     ", ".join(executables)
181                 )
182             )
183         __context__[contextkey] = service_exec
184     return __context__[contextkey]
185 def _runlevel():
186     contextkey = "systemd._runlevel"
187     if contextkey in __context__:
188         return __context__[contextkey]
189     out = __salt__["cmd.run"]("runlevel", python_shell=False, ignore_retcode=True)
190     try:
191         ret = out.split()[1]
192     except IndexError:
193         ret = _default_runlevel()
194     __context__[contextkey] = ret
195     return ret
196 def _strip_scope(msg):
197     ret = []
198     for line in msg.splitlines():
199         if not line.endswith(".scope"):
200             ret.append(line)
201     return "\n".join(ret).strip()
202 def _systemctl_cmd(action, name=None, systemd_scope=False, no_block=False, root=None):
203     ret = []
204     if (
205         systemd_scope
206         and salt.utils.systemd.has_scope(__context__)
207         and __salt__["config.get"]("systemd.scope", True)
208     ):
209         ret.extend(["systemd-run", "--scope"])
210     ret.append("systemctl")
211     if no_block:
212         ret.append("--no-block")
213     if root:
214         ret.extend(["--root", root])
215     if isinstance(action, str):
216         action = shlex.split(action)
217     ret.extend(action)
218     if name is not None:
219         ret.append(_canonical_unit_name(name))
220     if "status" in ret:
221         ret.extend(["-n", "0"])
222     return ret
223 def _systemctl_status(name):
224     contextkey = "systemd._systemctl_status.%s" % name
225     if contextkey in __context__:
226         return __context__[contextkey]
227     __context__[contextkey] = __salt__["cmd.run_all"](
228         _systemctl_cmd("status", name),
229         python_shell=False,
230         redirect_stderr=True,
231         ignore_retcode=True,
232     )
233     return __context__[contextkey]
234 def _sysv_enabled(name, root):
235     rc = _root("/etc/rc{}.d/S*{}".format(_runlevel(), name), root)
236     for match in glob.glob(rc):
237         if re.match(r"S\d{,2}%s" % name, os.path.basename(match)):
238             return True
239     return False
240 def _untracked_custom_unit_found(name, root=None):
241     system = _root("/etc/systemd/system", root)
242     unit_path = os.path.join(system, _canonical_unit_name(name))
243     return os.access(unit_path, os.R_OK) and not _check_available(name)
244 def _unit_file_changed(name):
245     status = _systemctl_status(name)["stdout"].lower()
246     return "'systemctl daemon-reload'" in status
247 def systemctl_reload():
248     out = __salt__["cmd.run_all"](
249         _systemctl_cmd("--system daemon-reload"),
250         python_shell=False,
251         redirect_stderr=True,
252     )
253     if out["retcode"] != 0:
254         raise CommandExecutionError(
255             "Problem performing systemctl daemon-reload: %s" % out["stdout"]
256         )
257     _clear_context()
258     return True
259 def get_running():
260     ret = set()
261     out = __salt__["cmd.run"](
262         _systemctl_cmd("--full --no-legend --no-pager"),
263         python_shell=False,
264         ignore_retcode=True,
265     )
266     for line in salt.utils.itertools.split(out, "\n"):
267         try:
268             comps = line.strip().split()
269             fullname = comps[0]
270             if len(comps) &gt; 3:
271                 active_state = comps[3]
272         except ValueError as exc:
273             log.error(exc)
274             continue
275         else:
276             if active_state != "running":
277                 continue
278         try:
279             unit_name, unit_type = fullname.rsplit(".", 1)
280         except ValueError:
281             continue
282         if unit_type in VALID_UNIT_TYPES:
283             ret.add(unit_name if unit_type == "service" else fullname)
284     return sorted(ret)
285 def get_enabled(root=None):
286     ret = set()
287     out = __salt__["cmd.run"](
288         _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
289         python_shell=False,
290         ignore_retcode=True,
291     )
292     for line in salt.utils.itertools.split(out, "\n"):
293         try:
294             fullname, unit_state = line.strip().split()[:2]
295         except ValueError:
296             continue
297         else:
298             if unit_state.split()[0] != "enabled":
299                 continue
300         try:
301             unit_name, unit_type = fullname.rsplit(".", 1)
302         except ValueError:
303             continue
304         if unit_type in VALID_UNIT_TYPES:
305             ret.add(unit_name if unit_type == "service" else fullname)
306     ret.update({x for x in _get_sysv_services(root) if _sysv_enabled(x, root)})
307     return sorted(ret)
308 def get_disabled(root=None):
309     ret = set()
310     out = __salt__["cmd.run"](
311         _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
312         python_shell=False,
313         ignore_retcode=True,
314     )
315     for line in salt.utils.itertools.split(out, "\n"):
316         try:
317             fullname, unit_state = line.strip().split()[:2]
318         except ValueError:
319             continue
320         else:
321             if unit_state.split()[0] != "disabled":
322                 continue
323         try:
324             unit_name, unit_type = fullname.rsplit(".", 1)
325         except ValueError:
326             continue
327         if unit_type in VALID_UNIT_TYPES:
328             ret.add(unit_name if unit_type == "service" else fullname)
329     ret.update({x for x in _get_sysv_services(root) if not _sysv_enabled(x, root)})
330     return sorted(ret)
331 def get_static(root=None):
332     ret = set()
333     out = __salt__["cmd.run"](
334         _systemctl_cmd("--full --no-legend --no-pager list-unit-files", root=root),
335         python_shell=False,
336         ignore_retcode=True,
337     )
338     for line in salt.utils.itertools.split(out, "\n"):
339         try:
340             fullname, unit_state = line.strip().split()[:2]
341         except ValueError:
342             continue
343         else:
344             if unit_state != "static":
345                 continue
346         try:
347             unit_name, unit_type = fullname.rsplit(".", 1)
348         except ValueError:
349             continue
350         if unit_type in VALID_UNIT_TYPES:
351             ret.add(unit_name if unit_type == "service" else fullname)
352     return sorted(ret)
353 def get_all(root=None):
354     ret = _get_systemd_services(root)
355     ret.update(set(_get_sysv_services(root, systemd_services=ret)))
356     return sorted(ret)
357 def available(name):
358     _check_for_unit_changes(name)
359     return _check_available(name)
360 def missing(name):
361     return not available(name)
362 def unmask_(name, runtime=False, root=None):
363     _check_for_unit_changes(name)
364     if not masked(name, runtime, root=root):
365         log.debug("Service '%s' is not %smasked", name, "runtime-" if runtime else "")
366         return True
367     cmd = "unmask --runtime" if runtime else "unmask"
368     out = __salt__["cmd.run_all"](
369         _systemctl_cmd(cmd, name, systemd_scope=True, root=root),
370         python_shell=False,
371         redirect_stderr=True,
372     )
373     if out["retcode"] != 0:
374         raise CommandExecutionError("Failed to unmask service '%s'" % name)
375     return True
376 def mask(name, runtime=False, root=None):
377     _check_for_unit_changes(name)
378     cmd = "mask --runtime" if runtime else "mask"
379     out = __salt__["cmd.run_all"](
380         _systemctl_cmd(cmd, name, systemd_scope=True, root=root),
381         python_shell=False,
382         redirect_stderr=True,
383     )
384     if out["retcode"] != 0:
385         raise CommandExecutionError(
386             "Failed to mask service '%s'" % name, info=out["stdout"]
387         )
388     return True
389 def masked(name, runtime=False, root=None):
390     _check_for_unit_changes(name)
391     root_dir = _root("/run" if runtime else "/etc", root)
392     link_path = os.path.join(root_dir, "systemd", "system", _canonical_unit_name(name))
393     try:
394         return os.readlink(link_path) == "/dev/null"
395     except OSError as exc:
396         if exc.errno == errno.ENOENT:
397             log.trace(
398                 "Path %s does not exist. This is normal if service '%s' is "
399                 "not masked or does not exist.",
400                 link_path,
401                 name,
402             )
403         elif exc.errno == errno.EINVAL:
404             log.error(
405                 "Failed to check mask status for service %s. Path %s is a "
406                 "file, not a symlink. This could be caused by changes in "
407                 "systemd and is probably a bug in Salt. Please report this "
408                 "to the developers.",
409                 name,
410                 link_path,
411             )
412         return False
413 def start(name, no_block=False, unmask=False, unmask_runtime=False):
414     _check_for_unit_changes(name)
415     _check_unmask(name, unmask, unmask_runtime)
416     ret = __salt__["cmd.run_all"](
417         _systemctl_cmd("start", name, systemd_scope=True, no_block=no_block),
418         python_shell=False,
419     )
420     if ret["retcode"] != 0:
421         raise CommandExecutionError(_strip_scope(ret["stderr"]))
422     return True
423 def stop(name, no_block=False):
424     _check_for_unit_changes(name)
425     return (
426         __salt__["cmd.run_all"](
427             _systemctl_cmd("stop", name, systemd_scope=True, no_block=no_block),
428             python_shell=False,
429         )["retcode"]
430         == 0
431     )
432 def restart(name, no_block=False, unmask=False, unmask_runtime=False):
433     _check_for_unit_changes(name)
434     _check_unmask(name, unmask, unmask_runtime)
435     ret = __salt__["cmd.run_all"](
436         _systemctl_cmd("restart", name, systemd_scope=True, no_block=no_block),
437         python_shell=False,
438     )
439     if ret["retcode"] != 0:
440         raise CommandExecutionError(_strip_scope(ret["stderr"]))
441     return True
442 def reload_(name, no_block=False, unmask=False, unmask_runtime=False):
443     _check_for_unit_changes(name)
444     _check_unmask(name, unmask, unmask_runtime)
445     ret = __salt__["cmd.run_all"](
446         _systemctl_cmd("reload", name, systemd_scope=True, no_block=no_block),
447         python_shell=False,
448     )
449     if ret["retcode"] != 0:
450         raise CommandExecutionError(_strip_scope(ret["stderr"]))
451     return True
452 def force_reload(name, no_block=True, unmask=False, unmask_runtime=False):
453     _check_for_unit_changes(name)
454     _check_unmask(name, unmask, unmask_runtime)
455     ret = __salt__["cmd.run_all"](
456         _systemctl_cmd("force-reload", name, systemd_scope=True, no_block=no_block),
457         python_shell=False,
458     )
459     if ret["retcode"] != 0:
460         raise CommandExecutionError(_strip_scope(ret["stderr"]))
461     return True
462 def status(name, sig=None):  # pylint: disable=unused-argument
463     contains_globbing = bool(re.search(r"\*|\?|\[.+\]", name))
464     if contains_globbing:
465         services = fnmatch.filter(get_all(), name)
466     else:
467         services = [name]
468     results = {}
469     for service in services:
470         _check_for_unit_changes(service)
471         results[service] = (
472             __salt__["cmd.retcode"](
473                 _systemctl_cmd("is-active", service),
474                 python_shell=False,
475                 ignore_retcode=True,
476             )
477             == 0
478         )
479     if contains_globbing:
480         return results
481     return results[name]
482 def enable(
483     name, no_block=False, unmask=False, unmask_runtime=False, root=None, **kwargs
484 ):  # pylint: disable=unused-argument
485     _check_for_unit_changes(name)
486     _check_unmask(name, unmask, unmask_runtime, root)
487     if name in _get_sysv_services(root):
488         cmd = []
489         if salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
490             "systemd.scope", True
491         ):
492             cmd.extend(["systemd-run", "--scope"])
493         service_exec = _get_service_exec()
494         if service_exec.endswith("/update-rc.d"):
495             cmd.extend([service_exec, "-f", name, "defaults", "99"])
496         elif service_exec.endswith("/chkconfig"):
497             cmd.extend([service_exec, name, "on"])
498         return (
499             __salt__["cmd.retcode"](cmd, python_shell=False, ignore_retcode=True) == 0
500         )
501     ret = __salt__["cmd.run_all"](
502         _systemctl_cmd(
503             "enable", name, systemd_scope=True, no_block=no_block, root=root
504         ),
505         python_shell=False,
506         ignore_retcode=True,
507     )
508     if ret["retcode"] != 0:
509         raise CommandExecutionError(_strip_scope(ret["stderr"]))
510     return True
511 def disable(
512     name, no_block=False, root=None, **kwargs
513 ):  # pylint: disable=unused-argument
514     _check_for_unit_changes(name)
515     if name in _get_sysv_services(root):
516         cmd = []
517         if salt.utils.systemd.has_scope(__context__) and __salt__["config.get"](
518             "systemd.scope", True
519         ):
520             cmd.extend(["systemd-run", "--scope"])
521         service_exec = _get_service_exec()
522         if service_exec.endswith("/update-rc.d"):
523             cmd.extend([service_exec, "-f", name, "remove"])
524         elif service_exec.endswith("/chkconfig"):
525             cmd.extend([service_exec, name, "off"])
526         return (
527             __salt__["cmd.retcode"](cmd, python_shell=False, ignore_retcode=True) == 0
528         )
529     return (
530         __salt__["cmd.run_all"](
531             _systemctl_cmd(
532                 "disable", name, systemd_scope=True, no_block=no_block, root=root
533             ),
534             python_shell=False,
535             ignore_retcode=True,
536         )["retcode"]
537         == 0
538     )
539 def enabled(name, root=None, **kwargs):  # pylint: disable=unused-argument
540     if (
541         __salt__["cmd.retcode"](
542             _systemctl_cmd("is-enabled", name, root=root),
543             python_shell=False,
544             ignore_retcode=True,
545         )
546         == 0
547     ):
548         return True
549     elif "@" in name:
550         local_config_path = _root(LOCAL_CONFIG_PATH, "/")
551         cmd = [
552             "find",
553             local_config_path,
554             "-name",
555             name,
556             "-type",
557             "l",
558             "-print",
559             "-quit",
560         ]
561         if bool(__salt__["cmd.run"](cmd, python_shell=False)):
562             return True
563     elif name in _get_sysv_services(root):
564         return _sysv_enabled(name, root)
565     return False
566 def disabled(name, root=None):
567     return not enabled(name, root=root)
568 def show(name, root=None):
569     ret = {}
570     out = __salt__["cmd.run"](
571         _systemctl_cmd("show", name, root=root), python_shell=False
572     )
573     for line in salt.utils.itertools.split(out, "\n"):
574         comps = line.split("=")
575         name = comps[0]
576         value = "=".join(comps[1:])
577         if value.startswith("{"):
578             value = value.replace("{", "").replace("}", "")
579             ret[name] = {}
580             for item in value.split(" ; "):
581                 comps = item.split("=")
582                 ret[name][comps[0].strip()] = comps[1].strip()
583         elif name in ("Before", "After", "Wants"):
584             ret[name] = value.split()
585         else:
586             ret[name] = value
587     return ret
588 def execs(root=None):
589     ret = {}
590     for service in get_all(root=root):
591         data = show(service, root=root)
592             continue
593         ret[service] = data["ExecStart"]["path"]
594     <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>return ret
595 def firstboot(
596     locale=None,
597     locale_message=None,
598     keymap=None,
599     timezone=None,
600     hostname=None,
601     machine_id=None,
602     root=None,
603 ):
604     cmd = ["systemd-firstboot"]
605     parameters =</b></font> [
606         ("locale", locale),
607         ("locale-message", locale_message),
608         ("keymap", keymap),
609         ("timezone", timezone),
610         ("hostname", hostname),
611         ("machine-ID", machine_id),
612         ("root", root),
613     ]
614     for parameter, value in parameters:
615         if value:
616             cmd.extend(["--{}".format(parameter), str(value)])
617     out = __salt__["cmd.run_all"](cmd)
618     if out["retcode"] != 0:
619         raise CommandExecutionError("systemd-firstboot error: {}".format(out["stderr"]))
620     return True
621 def offline():
622     return salt.utils.systemd.offline(__context__)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>gpg_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import functools
2 import logging
3 import os
4 import re
5 import time
6 import salt.utils.files
7 import salt.utils.path
8 import salt.utils.stringutils
9 from salt.exceptions import SaltInvocationError
10 from salt.utils.versions import LooseVersion as _LooseVersion
11 log = logging.getLogger(__name__)
12 __virtualname__ =</b></font> "gpg"
13 LETTER_TRUST_DICT = {
14     "e": "Expired",
15     "q": "Unknown",
16     "n": "Not Trusted",
17     "f": "Fully Trusted",
18     "m": "Marginally Trusted",
19     "u": "Ultimately Trusted",
20     "-": "Unknown",
21 }
22 NUM_TRUST_DICT = {
23     "expired": "1",
24     "unknown": "2",
25     "not_trusted": "3",
26     "marginally": "4",
27     "fully": "5",
28     "ultimately": "6",
29 }
30 INV_NUM_TRUST_DICT = {
31     "1": "Expired",
32     "2": "Unknown",
33     "3": "Not Trusted",
34     "4": "Marginally",
35     "5": "Fully Trusted",
36     "6": "Ultimately Trusted",
37 }
38 VERIFY_TRUST_LEVELS = {
39     "0": "Undefined",
40     "1": "Never",
41     "2": "Marginal",
42     "3": "Fully",
43     "4": "Ultimate",
44 }
45 GPG_1_3_1 = False
46 try:
47     import gnupg
48     HAS_GPG_BINDINGS = True
49     GPG_1_3_1 = _LooseVersion(gnupg.__version__) &gt;= _LooseVersion("1.3.1")
50 except ImportError:
51     HAS_GPG_BINDINGS = False
52 def _gpg():
53     return salt.utils.path.which("gpg")
54 def __virtual__():
55     if not _gpg():
56         return (
57             False,
58             "The gpg execution module cannot be loaded: gpg binary is not in the path.",
59         )
60     return (
61         __virtualname__
62         if HAS_GPG_BINDINGS
63         else (
64             False,
65             "The gpg execution module cannot be loaded; the gnupg python module is not"
66             " installed.",
67         )
68     )
69 def _get_user_info(user=None):
70     if not user:
71         user = __salt__["config.option"]("user")
72     userinfo = __salt__["user.info"](user)
73     if not userinfo:
74         if user == "salt":
75             userinfo = _get_user_info()
76         else:
77             raise SaltInvocationError("User {} does not exist".format(user))
78     return userinfo
79 def _get_user_gnupghome(user):
80     if user == "salt":
81         gnupghome = os.path.join(__salt__["config.get"]("config_dir"), "gpgkeys")
82     else:
83         gnupghome = os.path.join(_get_user_info(user)["home"], ".gnupg")
84     return gnupghome
85 def _restore_ownership(func):
86     @functools.wraps(func)
87     def func_wrapper(*args, **kwargs):
88         user = kwargs.get("user")
89         gnupghome = kwargs.get("gnupghome")
90         if not gnupghome:
91             gnupghome = _get_user_gnupghome(user)
92         userinfo = _get_user_info(user)
93         run_user = _get_user_info()
94         if userinfo["uid"] != run_user["uid"] and os.path.exists(gnupghome):
95             group = __salt__["file.gid_to_group"](run_user["gid"])
96             for path in [gnupghome] + __salt__["file.find"](gnupghome):
97                 __salt__["file.chown"](path, run_user["name"], group)
98         for key in list(kwargs):
99             if key.startswith("__"):
100                 del kwargs[key]
101         ret = func(*args, **kwargs)
102         if userinfo["uid"] != run_user["uid"]:
103             group = __salt__["file.gid_to_group"](userinfo["gid"])
104             for path in [gnupghome] + __salt__["file.find"](gnupghome):
105                 __salt__["file.chown"](path, user, group)
106         return ret
107     return func_wrapper
108 def _create_gpg(user=None, gnupghome=None):
109     if not gnupghome:
110         gnupghome = _get_user_gnupghome(user)
111     if GPG_1_3_1:
112         gpg = gnupg.GPG(homedir=gnupghome)  # pylint: disable=unexpected-keyword-arg
113     else:
114         gpg = gnupg.GPG(gnupghome=gnupghome)
115     return gpg
116 def _list_keys(user=None, gnupghome=None, secret=False):
117     gpg = _create_gpg(user, gnupghome)
118     _keys = gpg.list_keys(secret)
119     return _keys
120 def _search_keys(text, keyserver, user=None):
121     gpg = _create_gpg(user)
122     if keyserver:
123         _keys = gpg.search_keys(text, keyserver)
124     else:
125         _keys = gpg.search_keys(text)
126     return _keys
127 def search_keys(text, keyserver=None, user=None):
128     if GPG_1_3_1:
129         raise SaltInvocationError(
130             "The search_keys function is not support with this version of python-gnupg."
131         )
132     else:
133         if not keyserver:
134             keyserver = "pgp.mit.edu"
135         _keys = []
136         for _key in _search_keys(text, keyserver, user):
137             tmp = {"keyid": _key["keyid"], "uids": _key["uids"]}
138             expires = _key.get("expires", None)
139             date = _key.get("date", None)
140             length = _key.get("length", None)
141             if expires:
142                 tmp["expires"] = time.strftime(
143                     "%Y-%m-%d", time.localtime(float(_key["expires"]))
144                 )
145             if date:
146                 tmp["created"] = time.strftime(
147                     "%Y-%m-%d", time.localtime(float(_key["date"]))
148                 )
149             if length:
150                 tmp["keyLength"] = _key["length"]
151             _keys.append(tmp)
152         return _keys
153 def list_keys(user=None, gnupghome=None):
154     _keys = []
155     for _key in _list_keys(user, gnupghome):
156         tmp = {
157             "keyid": _key["keyid"],
158             "fingerprint": _key["fingerprint"],
159             "uids": _key["uids"],
160         }
161         expires = _key.get("expires", None)
162         date = _key.get("date", None)
163         length = _key.get("length", None)
164         owner_trust = _key.get("ownertrust", None)
165         trust = _key.get("trust", None)
166         if expires:
167             tmp["expires"] = time.strftime(
168                 "%Y-%m-%d", time.localtime(float(_key["expires"]))
169             )
170         if date:
171             tmp["created"] = time.strftime(
172                 "%Y-%m-%d", time.localtime(float(_key["date"]))
173             )
174         if length:
175             tmp["keyLength"] = _key["length"]
176         if owner_trust:
177             tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
178         if trust:
179             tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
180         _keys.append(tmp)
181     return _keys
182 def list_secret_keys(user=None, gnupghome=None):
183     _keys = []
184     for _key in _list_keys(user, gnupghome, secret=True):
185         tmp = {
186             "keyid": _key["keyid"],
187             "fingerprint": _key["fingerprint"],
188             "uids": _key["uids"],
189         }
190         expires = _key.get("expires", None)
191         date = _key.get("date", None)
192         length = _key.get("length", None)
193         owner_trust = _key.get("ownertrust", None)
194         trust = _key.get("trust", None)
195         if expires:
196             tmp["expires"] = time.strftime(
197                 "%Y-%m-%d", time.localtime(float(_key["expires"]))
198             )
199         if date:
200             tmp["created"] = time.strftime(
201                 "%Y-%m-%d", time.localtime(float(_key["date"]))
202             )
203         if length:
204             tmp["keyLength"] = _key["length"]
205         if owner_trust:
206             tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
207         if trust:
208             tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
209         _keys.append(tmp)
210     return _keys
211 @_restore_ownership
212 def create_key(
213     key_type="RSA",
214     key_length=1024,
215     name_real="Autogenerated Key",
216     name_comment="Generated by SaltStack",
217     name_email=None,
218     subkey_type=None,
219     subkey_length=None,
220     expire_date=None,
221     use_passphrase=False,
222     user=None,
223     gnupghome=None,
224 ):
225     ret = {"res": True, "fingerprint": "", "message": ""}
226     create_params = {
227         "key_type": key_type,
228         "key_length": key_length,
229         "name_real": name_real,
230         "name_comment": name_comment,
231     }
232     gpg = _create_gpg(user, gnupghome)
233     if name_email:
234         create_params["name_email"] = name_email
235     if subkey_type:
236         create_params["subkey_type"] = subkey_type
237     if subkey_length:
238         create_params["subkey_length"] = subkey_length
239     if expire_date:
240         create_params["expire_date"] = expire_date
241     if use_passphrase:
242         gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
243         if not gpg_passphrase:
244             ret["res"] = False
245             ret["message"] = "gpg_passphrase not available in pillar."
246             return ret
247         else:
248             create_params["passphrase"] = gpg_passphrase
249     else:
250         create_params["no_protection"] = True
251     input_data = gpg.gen_key_input(**create_params)
252     if "No-Protection: True" in input_data:
253         temp_data = input_data.splitlines()
254         temp_data.remove("No-Protection: True")
255         temp_data.insert(temp_data.index("%commit"), "%no-protection")
256         input_data = "\n".join(temp_data) + "\n"
257     key = gpg.gen_key(input_data)
258     if key.fingerprint:
259         ret["fingerprint"] = key.fingerprint
260         ret["message"] = "GPG key pair successfully generated."
261     else:
262         ret["res"] = False
263         ret["message"] = "Unable to generate GPG key pair."
264     return ret
265 def delete_key(
266     keyid=None,
267     fingerprint=None,
268     delete_secret=False,
269     user=None,
270     gnupghome=None,
271     use_passphrase=True,
272 ):
273     ret = {"res": True, "message": ""}
274     if fingerprint and keyid:
275         ret["res"] = False
276         ret["message"] = "Only specify one argument, fingerprint or keyid"
277         return ret
278     if not fingerprint and not keyid:
279         ret["res"] = False
280         ret["message"] = "Required argument, fingerprint or keyid"
281         return ret
282     gpg = _create_gpg(user, gnupghome)
283     key = get_key(keyid, fingerprint, user)
284     def __delete_key(fingerprint, secret, use_passphrase):
285         if use_passphrase:
286             gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
287             if not gpg_passphrase:
288                 ret["res"] = False
289                 ret["message"] = "gpg_passphrase not available in pillar."
290                 return ret
291             else:
292                 out = gpg.delete_keys(fingerprint, secret, passphrase=gpg_passphrase)
293         else:
294             out = gpg.delete_keys(fingerprint, secret, expect_passphrase=False)
295         return out
296     if key:
297         fingerprint = key["fingerprint"]
298         skey = get_secret_key(keyid, fingerprint, user)
299         if skey:
300             if not delete_secret:
301                 ret["res"] = False
302                 ret[
303                     "message"
304                 ] = "Secret key exists, delete first or pass delete_secret=True."
305                 return ret
306             else:
307                 if str(__delete_key(fingerprint, True, use_passphrase)) == "ok":
308                     ret["message"] = "Secret key for {} deleted\n".format(fingerprint)
309         if str(__delete_key(fingerprint, False, use_passphrase)) == "ok":
310             ret["message"] += "Public key for {} deleted".format(fingerprint)
311         ret["res"] = True
312         return ret
313     else:
314         ret["res"] = False
315         ret["message"] = "Key not available in keychain."
316         return ret
317 def get_key(keyid=None, fingerprint=None, user=None, gnupghome=None):
318     tmp = {}
319     for _key in _list_keys(user, gnupghome):
320         if (
321             _key["fingerprint"] == fingerprint
322             or _key["keyid"] == keyid
323             or _key["keyid"][8:] == keyid
324         ):
325             tmp["keyid"] = _key["keyid"]
326             tmp["fingerprint"] = _key["fingerprint"]
327             tmp["uids"] = _key["uids"]
328             expires = _key.get("expires", None)
329             date = _key.get("date", None)
330             length = _key.get("length", None)
331             owner_trust = _key.get("ownertrust", None)
332             trust = _key.get("trust", None)
333             if expires:
334                 tmp["expires"] = time.strftime(
335                     "%Y-%m-%d", time.localtime(float(_key["expires"]))
336                 )
337             if date:
338                 tmp["created"] = time.strftime(
339                     "%Y-%m-%d", time.localtime(float(_key["date"]))
340                 )
341             if length:
342                 tmp["keyLength"] = _key["length"]
343             if owner_trust:
344                 tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
345             if trust:
346                 tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
347     if not tmp:
348         return False
349     else:
350         return tmp
351 def get_secret_key(keyid=None, fingerprint=None, user=None, gnupghome=None):
352     tmp = {}
353     for _key in _list_keys(user, gnupghome, secret=True):
354         if (
355             _key["fingerprint"] == fingerprint
356             or _key["keyid"] == keyid
357             or _key["keyid"][8:] == keyid
358         ):
359             tmp["keyid"] = _key["keyid"]
360             tmp["fingerprint"] = _key["fingerprint"]
361             tmp["uids"] = _key["uids"]
362             expires = _key.get("expires", None)
363             date = _key.get("date", None)
364             length = _key.get("length", None)
365             owner_trust = _key.get("ownertrust", None)
366             trust = _key.get("trust", None)
367             if expires:
368                 tmp["expires"] = time.strftime(
369                     "%Y-%m-%d", time.localtime(float(_key["expires"]))
370                 )
371             if date:
372                 tmp["created"] = time.strftime(
373                     "%Y-%m-%d", time.localtime(float(_key["date"]))
374                 )
375             if length:
376                 tmp["keyLength"] = _key["length"]
377             if owner_trust:
378                 tmp["ownerTrust"] = LETTER_TRUST_DICT[_key["ownertrust"]]
379             if trust:
380                 tmp["trust"] = LETTER_TRUST_DICT[_key["trust"]]
381     if not tmp:
382         return False
383     else:
384         return tmp
385 @_restore_ownership
386 def import_key(text=None, filename=None, user=None, gnupghome=None):
387     r"""
388     Import a key from text or file
389     text
390         The text containing to import.
391     filename
392         The filename containing the key to import.
393     user
394         Which user's keychain to access, defaults to user Salt is running as.
395         Passing the user as ``salt`` will set the GnuPG home directory to the
396         ``/etc/salt/gpgkeys``.
397     gnupghome
398         Specify the location where GPG keyring and related files are stored.
399     CLI Example:
400     .. code-block:: bash
401         salt '*' gpg.import_key text='-----BEGIN PGP PUBLIC KEY BLOCK-----\n ... -----END PGP PUBLIC KEY BLOCK-----'
402         salt '*' gpg.import_key filename='/path/to/public-key-file'
403     Export a key from the GPG keychain
404     keyids
405         The key ID(s) of the key(s) to be exported. Can be specified as a comma
406         separated string or a list. Anything which GnuPG itself accepts to
407         identify a key - for example, the key ID or the fingerprint could be
408         used.
409     secret
410         Export the secret key identified by the ``keyids`` information passed.
411     user
412         Which user's keychain to access, defaults to user Salt is running as.
413         Passing the user as ``salt`` will set the GnuPG home directory to the
414         ``/etc/salt/gpgkeys``.
415     gnupghome
416         Specify the location where GPG keyring and related files are stored.
417     use_passphrase
418         Whether to use a passphrase with the signing key. Passphrase is received
419         from Pillar.
420         .. versionadded:: 3003
421     CLI Example:
422     .. code-block:: bash
423         salt '*' gpg.export_key keyids=3FAD9F1E
424         salt '*' gpg.export_key keyids=3FAD9F1E secret=True
425         salt '*' gpg.export_key keyids="['3FAD9F1E','3FBD8F1E']" user=username
426     Receive key(s) from keyserver and add them to keychain
427     keyserver
428         Keyserver to use for searching for GPG keys, defaults to pgp.mit.edu
429     keys
430         The keyID(s) to retrieve from the keyserver.  Can be specified as a comma
431         separated string or a list.
432     user
433         Which user's keychain to access, defaults to user Salt is running as.
434         Passing the user as ``salt`` will set the GnuPG home directory to the
435         ``/etc/salt/gpgkeys``.
436     gnupghome
437         Specify the location where GPG keyring and related files are stored.
438     CLI Example:
439     .. code-block:: bash
440         salt '*' gpg.receive_keys keys='3FAD9F1E'
441         salt '*' gpg.receive_keys keys="['3FAD9F1E','3FBD9F2E']"
442         salt '*' gpg.receive_keys keys=3FAD9F1E user=username
443     Set the trust level for a key in GPG keychain
444     keyid
445         The keyid of the key to set the trust level for.
446     fingerprint
447         The fingerprint of the key to set the trust level for.
448     trust_level
449         The trust level to set for the specified key, must be one
450         of the following:
451         expired, unknown, not_trusted, marginally, fully, ultimately
452     user
453         Which user's keychain to access, defaults to user Salt is running as.
454         Passing the user as ``salt`` will set the GnuPG home directory to the
455         ``/etc/salt/gpgkeys``.
456     CLI Example:
457     .. code-block:: bash
458         salt '*' gpg.trust_key keyid='3FAD9F1E' trust_level='marginally'
459         salt '*' gpg.trust_key fingerprint='53C96788253E58416D20BCD352952C84C3252192' trust_level='not_trusted'
460         salt '*' gpg.trust_key keys=3FAD9F1E trust_level='ultimately' user='username'
461     Sign message or file
462     user
463         Which user's keychain to access, defaults to user Salt is running as.
464         Passing the user as ``salt`` will set the GnuPG home directory to the
465         ``/etc/salt/gpgkeys``.
466     keyid
467         The keyid of the key to set the trust level for, defaults to
468         first key in the secret keyring.
469     text
470         The text to sign.
471     filename
472         The filename to sign.
473     output
474         The filename where the signed file will be written, default is standard out.
475     use_passphrase
476         Whether to use a passphrase with the signing key. Passphrase is received
477         from Pillar.
478     gnupghome
479         Specify the location where GPG keyring and related files are stored.
480     CLI Example:
481     .. code-block:: bash
482         salt '*' gpg.sign text='Hello there.  How are you?'
483         salt '*' gpg.sign filename='/path/to/important.file'
484         salt '*' gpg.sign filename='/path/to/important.file' use_passphrase=True
485     Verify a message or file
486     text
487         The text to verify.
488     filename
489         The filename to verify.
490     user
491         Which user's keychain to access, defaults to user Salt is running as.
492         Passing the user as ``salt`` will set the GnuPG home directory to the
493         ``/etc/salt/gpgkeys``.
494     gnupghome
495         Specify the location where GPG keyring and related files are stored.
496     signature
497         Specify the filename of a detached signature.
498         .. versionadded:: 2018.3.0
499     trustmodel
500         Explicitly define the used trust model. One of:
501           - pgp
502           - classic
503           - tofu
504           - tofu+pgp
505           - direct
506           - always
507           - auto
508         .. versionadded:: 2019.2.0
509     CLI Example:
510     .. code-block:: bash
511         salt '*' gpg.verify text='Hello there.  How are you?'
512         salt '*' gpg.verify filename='/path/to/important.file'
513         salt '*' gpg.verify filename='/path/to/important.file' use_passphrase=True
514         salt '*' gpg.verify filename='/path/to/important.file' trustmodel=direct
515     """
516     <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>return ret
517 def encrypt(
518     user=None,
519     recipients=None,
520     text=None,
521     filename=None,
522     output=None,
523     sign=None,
524     use_passphrase=False,
525     gnupghome=None,
526     bare=</b></font>False,
527 ):
528     """
529     Encrypt a message or file
530     user
531         Which user's keychain to access, defaults to user Salt is running as.
532         Passing the user as ``salt`` will set the GnuPG home directory to the
533         ``/etc/salt/gpgkeys``.
534     recipients
535         The fingerprints for those recipient whom the data is being encrypted for.
536     text
537         The text to encrypt.
538     filename
539         The filename to encrypt.
540     output
541         The filename where the signed file will be written, default is standard out.
542     sign
543         Whether to sign, in addition to encrypt, the data. ``True`` to use
544         default key or fingerprint to specify a different key to sign with.
545     use_passphrase
546         Whether to use a passphrase with the signing key. Passphrase is received
547         from Pillar.
548     gnupghome
549         Specify the location where GPG keyring and related files are stored.
550     bare
551         If ``True``, return the (armored) encrypted block as a string without
552         the standard comment/res dict.
553     CLI Example:
554     .. code-block:: bash
555         salt '*' gpg.encrypt text='Hello there.  How are you?' recipients=recipient@example.com
556         salt '*' gpg.encrypt filename='/path/to/important.file' recipients=recipient@example.com
557         salt '*' gpg.encrypt filename='/path/to/important.file' use_passphrase=True \\
558                              recipients=recipient@example.com
559     """
560     ret = {"res": True, "comment": ""}
561     gpg = _create_gpg(user, gnupghome)
562     if use_passphrase:
563         gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
564         if not gpg_passphrase:
565             raise SaltInvocationError("gpg_passphrase not available in pillar.")
566         gpg_passphrase = gpg_passphrase["gpg_passphrase"]
567     else:
568         gpg_passphrase = None
569     if text:
570         result = gpg.encrypt(text, recipients, passphrase=gpg_passphrase)
571     elif filename:
572         if GPG_1_3_1:
573             with salt.utils.files.flopen(filename, "rb") as _fp:
574                 _contents = salt.utils.stringutils.to_unicode(_fp.read())
575             result = gpg.encrypt(
576                 _contents, recipients, passphrase=gpg_passphrase, output=output
577             )
578         else:
579             with salt.utils.files.flopen(filename, "rb") as _fp:
580                 if output:
581                     result = gpg.encrypt_file(
582                         _fp,
583                         recipients,
584                         passphrase=gpg_passphrase,
585                         output=output,
586                         sign=sign,
587                     )
588                 else:
589                     result = gpg.encrypt_file(
590                         _fp, recipients, passphrase=gpg_passphrase, sign=sign
591                     )
592     else:
593         raise SaltInvocationError("filename or text must be passed.")
594     if result.ok:
595         if not bare:
596             if output:
597                 ret["comment"] = "Encrypted data has been written to {}".format(output)
598             else:
599                 ret["comment"] = result.data
600         else:
601             ret = result.data
602     else:
603         if not bare:
604             ret["res"] = False
605             ret["comment"] = "{}.\nPlease check the salt-minion log.".format(
606                 result.status
607             )
608         else:
609             ret = False
610         log.error(result.stderr)
611     return ret
612 def decrypt(
613     user=None,
614     text=None,
615     filename=None,
616     output=None,
617     use_passphrase=False,
618     gnupghome=None,
619     bare=False,
620 ):
621     """
622     Decrypt a message or file
623     user
624         Which user's keychain to access, defaults to user Salt is running as.
625         Passing the user as ``salt`` will set the GnuPG home directory to the
626         ``/etc/salt/gpgkeys``.
627     text
628         The encrypted text to decrypt.
629     filename
630         The encrypted filename to decrypt.
631     output
632         The filename where the decrypted data will be written, default is standard out.
633     use_passphrase
634         Whether to use a passphrase with the signing key. Passphrase is received
635         from Pillar.
636     gnupghome
637         Specify the location where GPG keyring and related files are stored.
638     bare
639         If ``True``, return the (armored) decrypted block as a string without the
640         standard comment/res dict.
641     CLI Example:
642     .. code-block:: bash
643         salt '*' gpg.decrypt filename='/path/to/important.file.gpg'
644         salt '*' gpg.decrypt filename='/path/to/important.file.gpg' use_passphrase=True
645     """
646     ret = {"res": True, "comment": ""}
647     gpg = _create_gpg(user, gnupghome)
648     if use_passphrase:
649         gpg_passphrase = __salt__["pillar.get"]("gpg_passphrase")
650         if not gpg_passphrase:
651             raise SaltInvocationError("gpg_passphrase not available in pillar.")
652         gpg_passphrase = gpg_passphrase["gpg_passphrase"]
653     else:
654         gpg_passphrase = None
655     if text:
656         result = gpg.decrypt(text, passphrase=gpg_passphrase)
657     elif filename:
658         with salt.utils.files.flopen(filename, "rb") as _fp:
659             if output:
660                 result = gpg.decrypt_file(_fp, passphrase=gpg_passphrase, output=output)
661             else:
662                 result = gpg.decrypt_file(_fp, passphrase=gpg_passphrase)
663     else:
664         raise SaltInvocationError("filename or text must be passed.")
665     if result.ok:
666         if not bare:
667             if output:
668                 ret["comment"] = "Decrypted data has been written to {}".format(output)
669             else:
670                 ret["comment"] = result.data
671         else:
672             ret = result.data
673     else:
674         if not bare:
675             ret["res"] = False
676             ret["comment"] = "{}.\nPlease check the salt-minion log.".format(
677                 result.status
678             )
679         else:
680             ret = False
681         log.error(result.stderr)
682     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
