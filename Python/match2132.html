<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_disjoint_paths.py & test_product.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_disjoint_paths.py & test_product.py
      </h3>
      <h1 align="center">
        9.3%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_disjoint_paths.py (15.17094%)<TH>test_product.py (6.7748094%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2132-0.html#0',2,'match2132-1.html#0',3)" NAME="0">(48-66)<TD><A HREF="javascript:ZweiFrames('match2132-0.html#0',2,'match2132-1.html#0',3)" NAME="0">(379-396)</A><TD ALIGN=center><FONT COLOR="#ff0000">20</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2132-0.html#1',2,'match2132-1.html#1',3)" NAME="1">(235-242)<TD><A HREF="javascript:ZweiFrames('match2132-0.html#1',2,'match2132-1.html#1',3)" NAME="1">(205-210)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2132-0.html#2',2,'match2132-1.html#2',3)" NAME="2">(227-234)<TD><A HREF="javascript:ZweiFrames('match2132-0.html#2',2,'match2132-1.html#2',3)" NAME="2">(119-126)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match2132-0.html#3',2,'match2132-1.html#3',3)" NAME="3">(202-207)<TD><A HREF="javascript:ZweiFrames('match2132-0.html#3',2,'match2132-1.html#3',3)" NAME="3">(411-416)</A><TD ALIGN=center><FONT COLOR="#a50000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match2132-0.html#4',2,'match2132-1.html#4',3)" NAME="4">(195-201)<TD><A HREF="javascript:ZweiFrames('match2132-0.html#4',2,'match2132-1.html#4',3)" NAME="4">(281-286)</A><TD ALIGN=center><FONT COLOR="#990000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_disjoint_paths.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest

import networkx as nx
from networkx.algorithms import flow
from networkx.utils import pairwise

flow_funcs = [
    flow.boykov_kolmogorov,
    flow.edmonds_karp,
    flow.dinitz,
    flow.preflow_push,
    flow.shortest_augmenting_path,
]


def is_path(G, path):
    return all(v in G[u] for u, v in pairwise(path))


def are_edge_disjoint_paths(G, paths):
    if not paths:
        return False
    for path in paths:
        assert is_path(G, path)
    paths_edges = [list(pairwise(p)) for p in paths]
    num_of_edges = sum(len(e) for e in paths_edges)
    num_unique_edges = len(set.union(*[set(es) for es in paths_edges]))
    if num_of_edges == num_unique_edges:
        return True
    return False


def are_node_disjoint_paths(G, paths):
    if not paths:
        return False
    for path in paths:
        assert is_path(G, path)
    # first and last nodes are source and target
    st = {paths[0][0], paths[0][-1]}
    num_of_nodes = len([n for path in paths for n in path if n not in st])
    num_unique_nodes = len({n for path in paths for n in path if n not in st})
    if num_of_nodes == num_unique_nodes:
        return True
    return False
<A NAME="0"></A>

def test_graph_from_pr_2053():
    G = nx.Graph<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2132-1.html#0',3,'match2132-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>()
    G.add_edges_from(
        [
            (&quot;A&quot;, &quot;B&quot;),
            (&quot;A&quot;, &quot;D&quot;),
            (&quot;A&quot;, &quot;F&quot;),
            (&quot;A&quot;, &quot;G&quot;),
            (&quot;B&quot;, &quot;C&quot;),
            (&quot;B&quot;, &quot;D&quot;),
            (&quot;B&quot;, &quot;G&quot;),
            (&quot;C&quot;, &quot;D&quot;),
            (&quot;C&quot;, &quot;E&quot;),
            (&quot;C&quot;, &quot;Z&quot;),
            (&quot;D&quot;, &quot;E&quot;),
            (&quot;D&quot;, &quot;F&quot;),
            (&quot;E&quot;, &quot;F&quot;),
            (&quot;E&quot;, &quot;Z&quot;),
            (&quot;F&quot;, &quot;Z&quot;),
            (&quot;G&quot;</B></FONT>, &quot;Z&quot;),
        ]
    )
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge disjoint paths
        edge_paths = list(nx.edge_disjoint_paths(G, &quot;A&quot;, &quot;Z&quot;, **kwargs))
        assert are_edge_disjoint_paths(G, edge_paths), errmsg
        assert nx.edge_connectivity(G, &quot;A&quot;, &quot;Z&quot;) == len(edge_paths), errmsg
        # node disjoint paths
        node_paths = list(nx.node_disjoint_paths(G, &quot;A&quot;, &quot;Z&quot;, **kwargs))
        assert are_node_disjoint_paths(G, node_paths), errmsg
        assert nx.node_connectivity(G, &quot;A&quot;, &quot;Z&quot;) == len(node_paths), errmsg


def test_florentine_families():
    G = nx.florentine_families_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge disjoint paths
        edge_dpaths = list(nx.edge_disjoint_paths(G, &quot;Medici&quot;, &quot;Strozzi&quot;, **kwargs))
        assert are_edge_disjoint_paths(G, edge_dpaths), errmsg
        assert nx.edge_connectivity(G, &quot;Medici&quot;, &quot;Strozzi&quot;) == len(edge_dpaths), errmsg
        # node disjoint paths
        node_dpaths = list(nx.node_disjoint_paths(G, &quot;Medici&quot;, &quot;Strozzi&quot;, **kwargs))
        assert are_node_disjoint_paths(G, node_dpaths), errmsg
        assert nx.node_connectivity(G, &quot;Medici&quot;, &quot;Strozzi&quot;) == len(node_dpaths), errmsg


def test_karate():
    G = nx.karate_club_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge disjoint paths
        edge_dpaths = list(nx.edge_disjoint_paths(G, 0, 33, **kwargs))
        assert are_edge_disjoint_paths(G, edge_dpaths), errmsg
        assert nx.edge_connectivity(G, 0, 33) == len(edge_dpaths), errmsg
        # node disjoint paths
        node_dpaths = list(nx.node_disjoint_paths(G, 0, 33, **kwargs))
        assert are_node_disjoint_paths(G, node_dpaths), errmsg
        assert nx.node_connectivity(G, 0, 33) == len(node_dpaths), errmsg


def test_petersen_disjoint_paths():
    G = nx.petersen_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge disjoint paths
        edge_dpaths = list(nx.edge_disjoint_paths(G, 0, 6, **kwargs))
        assert are_edge_disjoint_paths(G, edge_dpaths), errmsg
        assert 3 == len(edge_dpaths), errmsg
        # node disjoint paths
        node_dpaths = list(nx.node_disjoint_paths(G, 0, 6, **kwargs))
        assert are_node_disjoint_paths(G, node_dpaths), errmsg
        assert 3 == len(node_dpaths), errmsg


def test_octahedral_disjoint_paths():
    G = nx.octahedral_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge disjoint paths
        edge_dpaths = list(nx.edge_disjoint_paths(G, 0, 5, **kwargs))
        assert are_edge_disjoint_paths(G, edge_dpaths), errmsg
        assert 4 == len(edge_dpaths), errmsg
        # node disjoint paths
        node_dpaths = list(nx.node_disjoint_paths(G, 0, 5, **kwargs))
        assert are_node_disjoint_paths(G, node_dpaths), errmsg
        assert 4 == len(node_dpaths), errmsg


def test_icosahedral_disjoint_paths():
    G = nx.icosahedral_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        # edge disjoint paths
        edge_dpaths = list(nx.edge_disjoint_paths(G, 0, 6, **kwargs))
        assert are_edge_disjoint_paths(G, edge_dpaths), errmsg
        assert 5 == len(edge_dpaths), errmsg
        # node disjoint paths
        node_dpaths = list(nx.node_disjoint_paths(G, 0, 6, **kwargs))
        assert are_node_disjoint_paths(G, node_dpaths), errmsg
        assert 5 == len(node_dpaths), errmsg


def test_cutoff_disjoint_paths():
    G = nx.icosahedral_graph()
    for flow_func in flow_funcs:
        kwargs = dict(flow_func=flow_func)
        errmsg = f&quot;Assertion failed in function: {flow_func.__name__}&quot;
        for cutoff in [2, 4]:
            kwargs[&quot;cutoff&quot;] = cutoff
            # edge disjoint paths
            edge_dpaths = list(nx.edge_disjoint_paths(G, 0, 6, **kwargs))
            assert are_edge_disjoint_paths(G, edge_dpaths), errmsg
            assert cutoff == len(edge_dpaths), errmsg
            # node disjoint paths
            node_dpaths = list(nx.node_disjoint_paths(G, 0, 6, **kwargs))
            assert are_node_disjoint_paths(G, node_dpaths), errmsg
            assert cutoff == len(node_dpaths), errmsg


def test_missing_source_edge_paths():
    with pytest.raises(nx.NetworkXError):
        G = nx.path_graph(4)
        list(nx.edge_disjoint_paths(G, 10, 1))


def test_missing_source_node_paths():
    with pytest.raises(nx.NetworkXError):
        G = nx.path_graph(4)
        list(nx.node_disjoint_paths(G, 10, 1))


def test_missing_target_edge_paths():
    with pytest.raises(nx.NetworkXError):
        G = nx.path_graph(4)
        list(nx.edge_disjoint_paths(G, 1, 10))


<A NAME="4"></A>def test_missing_target_node_paths():
    with pytest.raises(nx.NetworkXError):
        G = nx.path_graph(4)
        list(nx.node_disjoint_paths(G<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match2132-1.html#4',3,'match2132-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>, 1, 10))


def test_not_weakly_connected_edges():
<A NAME="3"></A>    with pytest.raises(nx.NetworkXNoPath):
        G = nx.DiGraph()
        nx.add_path(G, [1</B></FONT>, 2, 3])
        nx<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match2132-1.html#3',3,'match2132-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.add_path(G, [4, 5])
        list(nx.edge_disjoint_paths(G, 1, 5))


def test_not_weakly_connected_nodes():
    with pytest.raises(nx.</B></FONT>NetworkXNoPath):
        G = nx.DiGraph()
        nx.add_path(G, [1, 2, 3])
        nx.add_path(G, [4, 5])
        list(nx.node_disjoint_paths(G, 1, 5))


def test_not_connected_edges():
    with pytest.raises(nx.NetworkXNoPath):
        G = nx.Graph()
        nx.add_path(G, [1, 2, 3])
        nx.add_path(G, [4, 5])
        list(nx.edge_disjoint_paths(G, 1, 5))


def test_not_connected_nodes():
    with pytest.raises(nx.NetworkXNoPath):
<A NAME="2"></A>        G = nx.Graph()
        nx.add_path(G, [1, 2, 3])
        nx.add_path(G, [4, 5])
        list(nx.node_disjoint_paths(G<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2132-1.html#2',3,'match2132-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>, 1, 5))


def test_isolated_edges():
    with pytest.raises(nx.NetworkXNoPath):
<A NAME="1"></A>        G = nx.Graph()
        G.add_node(1)
        nx.add_path(</B></FONT>G, [4, 5])
        list(nx.edge_disjoint_paths(G<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2132-1.html#1',3,'match2132-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>, 1, 5))


def test_isolated_nodes():
    with pytest.raises(nx.NetworkXNoPath):
        G = nx.Graph()
        G.add_node(1)
        nx.add_path(</B></FONT>G, [4, 5])
        list(nx.node_disjoint_paths(G, 1, 5))


def test_invalid_auxiliary():
    with pytest.raises(nx.NetworkXError):
        G = nx.complete_graph(5)
        list(nx.node_disjoint_paths(G, 0, 3, auxiliary=G))
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_product.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import pytest
import networkx as nx
from networkx.utils import edges_equal


def test_tensor_product_raises():
    with pytest.raises(nx.NetworkXError):
        P = nx.tensor_product(nx.DiGraph(), nx.Graph())


def test_tensor_product_null():
    null = nx.null_graph()
    empty10 = nx.empty_graph(10)
    K3 = nx.complete_graph(3)
    K10 = nx.complete_graph(10)
    P3 = nx.path_graph(3)
    P10 = nx.path_graph(10)
    # null graph
    G = nx.tensor_product(null, null)
    assert nx.is_isomorphic(G, null)
    # null_graph X anything = null_graph and v.v.
    G = nx.tensor_product(null, empty10)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(null, K3)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(null, K10)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(null, P3)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(null, P10)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(empty10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(K3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(K10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(P3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.tensor_product(P10, null)
    assert nx.is_isomorphic(G, null)


def test_tensor_product_size():
    P5 = nx.path_graph(5)
    K3 = nx.complete_graph(3)
    K5 = nx.complete_graph(5)

    G = nx.tensor_product(P5, K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.tensor_product(K3, K5)
    assert nx.number_of_nodes(G) == 3 * 5


def test_tensor_product_combinations():
    # basic smoke test, more realistic tests would be useful
    P5 = nx.path_graph(5)
    K3 = nx.complete_graph(3)
    G = nx.tensor_product(P5, K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.tensor_product(P5, nx.MultiGraph(K3))
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.tensor_product(nx.MultiGraph(P5), K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.tensor_product(nx.MultiGraph(P5), nx.MultiGraph(K3))
    assert nx.number_of_nodes(G) == 5 * 3

    G = nx.tensor_product(nx.DiGraph(P5), nx.DiGraph(K3))
    assert nx.number_of_nodes(G) == 5 * 3


def test_tensor_product_classic_result():
    K2 = nx.complete_graph(2)
    G = nx.petersen_graph()
    G = nx.tensor_product(G, K2)
    assert nx.is_isomorphic(G, nx.desargues_graph())

    G = nx.cycle_graph(5)
    G = nx.tensor_product(G, K2)
    assert nx.is_isomorphic(G, nx.cycle_graph(10))

    G = nx.tetrahedral_graph()
    G = nx.tensor_product(G, K2)
    assert nx.is_isomorphic(G, nx.cubical_graph())


def test_tensor_product_random():
    G = nx.erdos_renyi_graph(10, 2 / 10.0)
    H = nx.erdos_renyi_graph(10, 2 / 10.0)
    GH = nx.tensor_product(G, H)

    for (u_G, u_H) in GH.nodes():
        for (v_G, v_H) in GH.nodes():
            if H.has_edge(u_H, v_H) and G.has_edge(u_G, v_G):
                assert GH.has_edge((u_G, u_H), (v_G, v_H))
            else:
                assert not GH.has_edge((u_G, u_H), (v_G, v_H))


def test_cartesian_product_multigraph():
    G = nx.MultiGraph()
    G.add_edge(1, 2, key=0)
    G.add_edge(1, 2, key=1)
    H = nx.MultiGraph()
    H.add_edge(3, 4, key=0)
    H.add_edge(3, 4, key=1)
    GH = nx.cartesian_product(G, H)
    assert set(GH) == {(1, 3), (2, 3), (2, 4), (1, 4)}
    assert {(frozenset([u, v]), k) for u, v, k in GH.edges(keys=True)} == {
        (frozenset([u, v]), k)
        for u, v, k in [
            ((1, 3), (2, 3), 0),
            ((1, 3), (2, 3), 1),
            ((1, 3), (1, 4), 0),
            ((1, 3), (1, 4), 1),
<A NAME="2"></A>            ((2, 3), (2, 4), 0),
            ((2, 3), (2, 4), 1),
            ((2, 4), (1, 4), 0),
            ((2, 4), (1<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2132-0.html#2',2,'match2132-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>, 4), 1),
        ]
    }


def test_cartesian_product_raises():
    with pytest.raises(nx.NetworkXError):
        P = nx.cartesian_product(nx.DiGraph(), nx.Graph(</B></FONT>))


def test_cartesian_product_null():
    null = nx.null_graph()
    empty10 = nx.empty_graph(10)
    K3 = nx.complete_graph(3)
    K10 = nx.complete_graph(10)
    P3 = nx.path_graph(3)
    P10 = nx.path_graph(10)
    # null graph
    G = nx.cartesian_product(null, null)
    assert nx.is_isomorphic(G, null)
    # null_graph X anything = null_graph and v.v.
    G = nx.cartesian_product(null, empty10)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(null, K3)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(null, K10)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(null, P3)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(null, P10)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(empty10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(K3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(K10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(P3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.cartesian_product(P10, null)
    assert nx.is_isomorphic(G, null)


def test_cartesian_product_size():
    # order(GXH)=order(G)*order(H)
    K5 = nx.complete_graph(5)
    P5 = nx.path_graph(5)
    K3 = nx.complete_graph(3)
    G = nx.cartesian_product(P5, K3)
    assert nx.number_of_nodes(G) == 5 * 3
    assert nx.number_of_edges(G) == nx.number_of_edges(P5) * nx.number_of_nodes(
        K3
    ) + nx.number_of_edges(K3) * nx.number_of_nodes(P5)
    G = nx.cartesian_product(K3, K5)
    assert nx.number_of_nodes(G) == 3 * 5
    assert nx.number_of_edges(G) == nx.number_of_edges(K5) * nx.number_of_nodes(
        K3
    ) + nx.number_of_edges(K3) * nx.number_of_nodes(K5)


def test_cartesian_product_classic():
    # test some classic product graphs
    P2 = nx.path_graph(2)
    P3 = nx.path_graph(3)
    # cube = 2-path X 2-path
    G = nx.cartesian_product(P2, P2)
    G = nx.cartesian_product(P2, G)
    assert nx.is_isomorphic(G, nx.cubical_graph())

    # 3x3 grid
    G = nx.cartesian_product(P3, P3)
    assert nx.is_isomorphic(G, nx.grid_2d_graph(3, 3))


def test_cartesian_product_random():
    G = nx.erdos_renyi_graph(10, 2 / 10.0)
    H = nx.erdos_renyi_graph(10, 2 / 10.0)
    GH = nx.cartesian_product(G, H)

    for (u_G, u_H) in GH.nodes():
        for (v_G, v_H) in GH.nodes():
            if (u_G == v_G and H.has_edge(u_H, v_H)) or (
                u_H == v_H and G.has_edge(u_G, v_G)
<A NAME="1"></A>            ):
                assert GH.has_edge((u_G, u_H), (v_G, v_H))
            else:
                assert not GH.has_edge((u_G, u_H), (v_G,<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2132-0.html#1',2,'match2132-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B> v_H))


def test_lexicographic_product_raises():
    with pytest.raises(nx.NetworkXError):
        P = nx.lexicographic_product(nx.DiGraph(), nx.Graph(</B></FONT>))


def test_lexicographic_product_null():
    null = nx.null_graph()
    empty10 = nx.empty_graph(10)
    K3 = nx.complete_graph(3)
    K10 = nx.complete_graph(10)
    P3 = nx.path_graph(3)
    P10 = nx.path_graph(10)
    # null graph
    G = nx.lexicographic_product(null, null)
    assert nx.is_isomorphic(G, null)
    # null_graph X anything = null_graph and v.v.
    G = nx.lexicographic_product(null, empty10)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(null, K3)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(null, K10)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(null, P3)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(null, P10)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(empty10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(K3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(K10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(P3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.lexicographic_product(P10, null)
    assert nx.is_isomorphic(G, null)


def test_lexicographic_product_size():
    K5 = nx.complete_graph(5)
    P5 = nx.path_graph(5)
    K3 = nx.complete_graph(3)
    G = nx.lexicographic_product(P5, K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.lexicographic_product(K3, K5)
    assert nx.number_of_nodes(G) == 3 * 5


def test_lexicographic_product_combinations():
    P5 = nx.path_graph(5)
    K3 = nx.complete_graph(3)
    G = nx.lexicographic_product(P5, K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.lexicographic_product(nx.MultiGraph(P5), K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.lexicographic_product(P5, nx.MultiGraph(K3))
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.lexicographic_product(nx.MultiGraph(P5), nx.MultiGraph(K3))
    assert nx.number_of_nodes(G) == 5 * 3

    # No classic easily found classic results for lexicographic product


def test_lexicographic_product_random():
    G = nx.erdos_renyi_graph(10, 2 / 10.0)
    H = nx.erdos_renyi_graph(10, 2 / 10.0)
    GH = nx.lexicographic_product(G, H)

    for (u_G, u_H) in GH.nodes():
        for (v_G, v_H) in GH.nodes():
<A NAME="4"></A>            if G.has_edge(u_G, v_G) or (u_G == v_G and H.has_edge(u_H, v_H)):
                assert GH.has_edge((u_G, u_H), (v_G, v_H))
            else:
                assert not GH.has_edge((u_G, u_H), (v_G,<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2132-0.html#4',2,'match2132-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B> v_H))


def test_strong_product_raises():
    with pytest.raises(nx.NetworkXError):
        P = nx.strong_product(nx.DiGraph(), nx.</B></FONT>Graph())


def test_strong_product_null():
    null = nx.null_graph()
    empty10 = nx.empty_graph(10)
    K3 = nx.complete_graph(3)
    K10 = nx.complete_graph(10)
    P3 = nx.path_graph(3)
    P10 = nx.path_graph(10)
    # null graph
    G = nx.strong_product(null, null)
    assert nx.is_isomorphic(G, null)
    # null_graph X anything = null_graph and v.v.
    G = nx.strong_product(null, empty10)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(null, K3)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(null, K10)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(null, P3)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(null, P10)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(empty10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(K3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(K10, null)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(P3, null)
    assert nx.is_isomorphic(G, null)
    G = nx.strong_product(P10, null)
    assert nx.is_isomorphic(G, null)


def test_strong_product_size():
    K5 = nx.complete_graph(5)
    P5 = nx.path_graph(5)
    K3 = nx.complete_graph(3)
    G = nx.strong_product(P5, K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.strong_product(K3, K5)
    assert nx.number_of_nodes(G) == 3 * 5


def test_strong_product_combinations():
    P5 = nx.path_graph(5)
    K3 = nx.complete_graph(3)
    G = nx.strong_product(P5, K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.strong_product(nx.MultiGraph(P5), K3)
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.strong_product(P5, nx.MultiGraph(K3))
    assert nx.number_of_nodes(G) == 5 * 3
    G = nx.strong_product(nx.MultiGraph(P5), nx.MultiGraph(K3))
    assert nx.number_of_nodes(G) == 5 * 3

    # No classic easily found classic results for strong product


def test_strong_product_random():
    G = nx.erdos_renyi_graph(10, 2 / 10.0)
    H = nx.erdos_renyi_graph(10, 2 / 10.0)
    GH = nx.strong_product(G, H)

    for (u_G, u_H) in GH.nodes():
        for (v_G, v_H) in GH.nodes():
            if (
                (u_G == v_G and H.has_edge(u_H, v_H))
                or (u_H == v_H and G.has_edge(u_G, v_G))
                or (G.has_edge(u_G, v_G) and H.has_edge(u_H, v_H))
            ):
                assert GH.has_edge((u_G, u_H), (v_G, v_H))
            else:
                assert not GH.has_edge((u_G, u_H), (v_G, v_H))


def test_graph_power_raises():
    with pytest.raises(nx.NetworkXNotImplemented):
        nx.power(nx.MultiDiGraph(), 2)


def test_graph_power():
    # wikipedia example for graph power
    G = nx.cycle_graph(7)
    G.add_edge(6, 7)
    G.add_edge(7, 8)
    G.add_edge(8, 9)
    G.add_edge(9, 2)
<A NAME="0"></A>    H = nx.power(G, 2)

    assert edges_equal(
        list<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2132-0.html#0',2,'match2132-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>(H.edges()),
        [
            (0, 1),
            (0, 2),
            (0, 5),
            (0, 6),
            (0, 7),
            (1, 9),
            (1, 2),
            (1, 3),
            (1, 6),
            (2, 3),
            (2, 4),
            (2, 8),
            (2, 9),
            (3, 4),
            (3, 5),
            (3</B></FONT>, 9),
            (4, 5),
            (4, 6),
            (5, 6),
            (5, 7),
            (6, 7),
            (6, 8),
            (7, 8),
            (7, 9),
            (8, 9),
        ],
    )
<A NAME="3"></A>

def test_graph_power_negative():
    with pytest<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2132-0.html#3',2,'match2132-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.raises(ValueError):
        nx.power(nx.Graph(), -1)


def test_rooted_product_raises():
    with pytest.raises(nx.</B></FONT>NetworkXError):
        nx.rooted_product(nx.Graph(), nx.path_graph(2), 10)


def test_rooted_product():
    G = nx.cycle_graph(5)
    H = nx.Graph()
    H.add_edges_from([(&quot;a&quot;, &quot;b&quot;), (&quot;b&quot;, &quot;c&quot;), (&quot;b&quot;, &quot;d&quot;)])
    R = nx.rooted_product(G, H, &quot;a&quot;)
    assert len(R) == len(G) * len(H)
    assert R.size() == G.size() + len(G) * H.size()
</PRE>
</div>
  </div>
</body>
</html>
