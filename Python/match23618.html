<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for boto3_route53_1.py & boto_s3_bucket_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for boto3_route53_1.py & boto_s3_bucket_1.py
      </h3>
      <h1 align="center">
        9.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>boto3_route53_1.py (9.731233%)<TH>boto_s3_bucket_1.py (8.84583%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#0',2,'match23618-1.html#0',3)" NAME="0">(63-79)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#0',2,'match23618-1.html#0',3)" NAME="0">(68-88)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#1',2,'match23618-1.html#1',3)" NAME="1">(302-317)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#1',2,'match23618-1.html#1',3)" NAME="1">(119-134)</A><TD ALIGN=center><FONT COLOR="#d20000">14</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#2',2,'match23618-1.html#2',3)" NAME="2">(383-389)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#2',2,'match23618-1.html#2',3)" NAME="2">(797-799)</A><TD ALIGN=center><FONT COLOR="#c30000">13</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#3',2,'match23618-1.html#3',3)" NAME="3">(272-301)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#3',2,'match23618-1.html#3',3)" NAME="3">(349-369)</A><TD ALIGN=center><FONT COLOR="#c30000">13</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#4',2,'match23618-1.html#4',3)" NAME="4">(758-764)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#4',2,'match23618-1.html#4',3)" NAME="4">(497-501)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#5',2,'match23618-1.html#5',3)" NAME="5">(632-638)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#5',2,'match23618-1.html#5',3)" NAME="5">(450-454)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#6',2,'match23618-1.html#6',3)" NAME="6">(525-538)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#6',2,'match23618-1.html#6',3)" NAME="6">(509-523)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match23618-0.html#7',2,'match23618-1.html#7',3)" NAME="7">(79-89)<TD><A HREF="javascript:ZweiFrames('match23618-0.html#7',2,'match23618-1.html#7',3)" NAME="7">(88-96)</A><TD ALIGN=center><FONT COLOR="#b40000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_route53_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Execution module for Amazon Route53 written against Boto 3

.. versionadded:: 2017.7.0

:configuration: This module accepts explicit route53 credentials but can also
    utilize IAM roles assigned to the instance through Instance Profiles.
    Dynamic credentials are then automatically obtained from AWS API and no
    further configuration is necessary. More Information available at:

    .. code-block:: yaml

        http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html

    If IAM roles are not used you need to specify them either in a pillar or
    in the minion's config file:

    .. code-block:: yaml

        route53.keyid: GKTADJGHEIQSXMKKRBJ08H
        route53.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    A region may also be specified in the configuration:

    .. code-block:: yaml

        route53.region: us-east-1

    It's also possible to specify key, keyid and region via a profile, either
    as a passed in dict, or as a string to pull from pillars or minion config:

    .. code-block:: yaml

        myprofile:
          keyid: GKTADJGHEIQSXMKKRBJ08H
          key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
          region: us-east-1

    Note that Route53 essentially ignores all (valid) settings for 'region',
    since there is only one Endpoint (in us-east-1 if you care) and any (valid)
    region setting will just send you there.  It is entirely safe to set it to
    None as well.

:depends: boto3
&quot;&quot;&quot;

# keep lint from choking on _get_conn and _cache_id
# pylint: disable=E0602,W0106


import logging
import re
import time

import salt.utils.compat
import salt.utils.versions
from salt.exceptions import CommandExecutionError, SaltInvocationError

log = logging.getLogger(__name__)
<A NAME="0"></A>
try:
    # pylint: disable=unused-import
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match23618-1.html#0',3,'match23618-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>import boto3

    # pylint: enable=unused-import
    from botocore.exceptions import ClientError

    logging.getLogger(&quot;boto3&quot;).setLevel(logging.CRITICAL)
    HAS_BOTO3 = True
except ImportError:
    HAS_BOTO3 = False


def __virtual__():
    &quot;&quot;&quot;
<A NAME="7"></A>    Only load if boto libraries exist and if boto libraries are greater than
    a given version.
    &quot;&quot;&quot;
    return salt.utils.versions.check_boto_reqs(</B></FONT><FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match23618-1.html#7',3,'match23618-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>)


def __init__(opts):
    if HAS_BOTO3:
        __utils__[&quot;boto3.assign_funcs&quot;](__name__, &quot;route53&quot;)


def _collect_results(func, item, args, marker=&quot;Marker&quot;, nextmarker=&quot;NextMarker&quot;):
    ret = []
    Marker =</B></FONT> args.get(marker, &quot;&quot;)
    tries = 10
    while Marker is not None:
        try:
            r = func(**args)
        except ClientError as e:
            if tries and e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                # Rate limited - retry
                log.debug(&quot;Throttled by AWS API.&quot;)
                time.sleep(3)
                tries -= 1
                continue
            log.error(&quot;Could not collect results from %s(): %s&quot;, func, e)
            return []
        i = r.get(item, []) if item else r
        i.pop(&quot;ResponseMetadata&quot;, None) if isinstance(i, dict) else None
        ret += i if isinstance(i, list) else [i]
        Marker = r.get(nextmarker)
        args.update({marker: Marker})
    return ret


def _wait_for_sync(change, conn, tries=10, sleep=20):
    for retry in range(1, tries + 1):
        log.info(&quot;Getting route53 status (attempt %s)&quot;, retry)
        status = &quot;wait&quot;
        try:
            status = conn.get_change(Id=change)[&quot;ChangeInfo&quot;][&quot;Status&quot;]
        except ClientError as e:
            if e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                log.debug(&quot;Throttled by AWS API.&quot;)
            else:
                raise
        if status == &quot;INSYNC&quot;:
            return True
        time.sleep(sleep)
    log.error(&quot;Timed out waiting for Route53 INSYNC status.&quot;)
    return False


def find_hosted_zone(
    Id=None,
    Name=None,
    PrivateZone=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Find a hosted zone with the given characteristics.

    Id
        The unique Zone Identifier for the Hosted Zone.  Exclusive with Name.

    Name
        The domain name associated with the Hosted Zone.  Exclusive with Id.
        Note this has the potential to match more then one hosted zone (e.g. a public and a private
        if both exist) which will raise an error unless PrivateZone has also been passed in order
        split the different.

    PrivateZone
        Boolean - Set to True if searching for a private hosted zone.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.find_hosted_zone Name=salt.org. \
                profile='{&quot;region&quot;: &quot;us-east-1&quot;, &quot;keyid&quot;: &quot;A12345678AB&quot;, &quot;key&quot;: &quot;xblahblahblah&quot;}'
    &quot;&quot;&quot;
    if not _exactly_one((Id, Name)):
        raise SaltInvocationError(&quot;Exactly one of either Id or Name is required.&quot;)
    if PrivateZone is not None and not isinstance(PrivateZone, bool):
        raise SaltInvocationError(
            &quot;If set, PrivateZone must be a bool (e.g. True / False).&quot;
        )
    if Id:
        ret = get_hosted_zone(Id, region=region, key=key, keyid=keyid, profile=profile)
    else:
        ret = get_hosted_zones_by_domain(
            Name, region=region, key=key, keyid=keyid, profile=profile
        )
    if PrivateZone is not None:
        ret = [
            m for m in ret if m[&quot;HostedZone&quot;][&quot;Config&quot;][&quot;PrivateZone&quot;] is PrivateZone
        ]
    if len(ret) &gt; 1:
        log.error(
            &quot;Request matched more than one Hosted Zone (%s). Refine your &quot;
            &quot;criteria and try again.&quot;,
            [z[&quot;HostedZone&quot;][&quot;Id&quot;] for z in ret],
        )
        ret = []
    return ret


def get_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Return detailed info about the given zone.

    Id
        The unique Zone Identifier for the Hosted Zone.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.get_hosted_zone Z1234567690 \
                profile='{&quot;region&quot;: &quot;us-east-1&quot;, &quot;keyid&quot;: &quot;A12345678AB&quot;, &quot;key&quot;: &quot;xblahblahblah&quot;}'
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    args = {&quot;Id&quot;: Id}
    return _collect_results(conn.get_hosted_zone, None, args)


def get_hosted_zones_by_domain(Name, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Find any zones with the given domain name and return detailed info about them.
    Note that this can return multiple Route53 zones, since a domain name can be used in
    both public and private zones.

    Name
        The domain name associated with the Hosted Zone(s).

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.get_hosted_zones_by_domain salt.org. \
                profile='{&quot;region&quot;: &quot;us-east-1&quot;, &quot;keyid&quot;: &quot;A12345678AB&quot;, &quot;key&quot;: &quot;xblahblahblah&quot;}'
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    zones = [
        z
        for z in _collect_results(conn.list_hosted_zones, &quot;HostedZones&quot;, {})
        if z[&quot;Name&quot;] == _aws_encode(Name)
    ]
    ret = []
    for z in zones:
        ret += get_hosted_zone(
            Id=z[&quot;Id&quot;], region=region, key=key, keyid=keyid, profile=profile
        )
    return ret
<A NAME="3"></A>

def list_hosted_zones(
    DelegationSetId<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match23618-1.html#3',3,'match23618-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=None, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Return detailed info about all zones in the bound account.

    DelegationSetId
        If you're using reusable delegation sets and you want to list all of the hosted zones that
        are associated with a reusable delegation set, specify the ID of that delegation set.

    region
        Region to connect to.

    key
        Secret key to be used.

    keyid
        Access key to be used.

    profile
        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.describe_hosted_zones \
                profile='{&quot;region&quot;: &quot;us-east-1&quot;, &quot;keyid&quot;: &quot;A12345678AB&quot;, &quot;key&quot;: &quot;xblahblahblah&quot;}'
<A NAME="1"></A>    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    args = {&quot;DelegationSetId&quot;</B></FONT>: DelegationSetId} if DelegationSetId else {}
    return _collect_results(conn<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match23618-1.html#1',3,'match23618-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.list_hosted_zones, &quot;HostedZones&quot;, args)


def create_hosted_zone(
    Name,
    VPCId=None,
    VPCName=None,
    VPCRegion=None,
    CallerReference=None,
    Comment=&quot;&quot;,
    PrivateZone=False,
    DelegationSetId=None,
    region=None,
    key=None,
    keyid=None,
    profile=</B></FONT>None,
):
    &quot;&quot;&quot;
    Create a new Route53 Hosted Zone. Returns a Python data structure with information about the
    newly created Hosted Zone.

    Name
        The name of the domain. This should be a fully-specified domain, and should terminate with
        a period. This is the name you have registered with your DNS registrar. It is also the name
        you will delegate from your registrar to the Amazon Route 53 delegation servers returned in
        response to this request.

    VPCId
        When creating a private hosted zone, either the VPC ID or VPC Name to associate with is
        required.  Exclusive with VPCName.  Ignored if passed for a non-private zone.

    VPCName
        When creating a private hosted zone, either the VPC ID or VPC Name to associate with is
        required.  Exclusive with VPCId.  Ignored if passed for a non-private zone.

    VPCRegion
        When creating a private hosted zone, the region of the associated VPC is required.  If not
        provided, an effort will be made to determine it from VPCId or VPCName, if possible.  If
        this fails, you'll need to provide an explicit value for this option.  Ignored if passed for
        a non-private zone.

    CallerReference
        A unique string that identifies the request and that allows create_hosted_zone() calls to be
        retried without the risk of executing the operation twice.  This is a required parameter
        when creating new Hosted Zones.  Maximum length of 128.

    Comment
        Any comments you want to include about the hosted zone.

    PrivateZone
        Boolean - Set to True if creating a private hosted zone.

    DelegationSetId
        If you want to associate a reusable delegation set with this hosted zone, the ID that Amazon
        Route 53 assigned to the reusable delegation set when you created it.  Note that XXX TODO
        create_delegation_set() is not yet implemented, so you'd need to manually create any
        delegation sets before utilizing this.

    region
        Region endpoint to connect to.

    key
        AWS key to bind with.

    keyid
        AWS keyid to bind with.

    profile
        Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.create_hosted_zone example.org.
    &quot;&quot;&quot;
    if not Name.endswith(&quot;.&quot;):
        raise SaltInvocationError(
<A NAME="2"></A>            &quot;Domain must be fully-qualified, complete with trailing period.&quot;
        )
    Name = _aws_encode(Name)
    conn <FONT color="#980517"><A HREF="javascript:ZweiFrames('match23618-1.html#2',3,'match23618-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    deets = find_hosted_zone(
        Name=Name,
        PrivateZone=PrivateZone,
        region=region,
        key=key,
        keyid=</B></FONT>keyid,
        profile=profile,
    )
    if deets:
        log.info(
            &quot;Route 53 hosted zone %s already exists. You may want to pass &quot;
            &quot;e.g. 'PrivateZone=True' or similar...&quot;,
            Name,
        )
        return None
    args = {
        &quot;Name&quot;: Name,
        &quot;CallerReference&quot;: CallerReference,
        &quot;HostedZoneConfig&quot;: {&quot;Comment&quot;: Comment, &quot;PrivateZone&quot;: PrivateZone},
    }
    args.update({&quot;DelegationSetId&quot;: DelegationSetId}) if DelegationSetId else None
    if PrivateZone:
        if not _exactly_one((VPCName, VPCId)):
            raise SaltInvocationError(
                &quot;Either VPCName or VPCId is required when creating a private zone.&quot;
            )
        vpcs = __salt__[&quot;boto_vpc.describe_vpcs&quot;](
            vpc_id=VPCId,
            name=VPCName,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get(&quot;vpcs&quot;, [])
        if VPCRegion and vpcs:
            vpcs = [v for v in vpcs if v[&quot;region&quot;] == VPCRegion]
        if not vpcs:
            log.error(
                &quot;Private zone requested but no VPC matching given criteria found.&quot;
            )
            return None
        if len(vpcs) &gt; 1:
            log.error(
                &quot;Private zone requested but multiple VPCs matching given &quot;
                &quot;criteria found: %s.&quot;,
                [v[&quot;id&quot;] for v in vpcs],
            )
            return None
        vpc = vpcs[0]
        if VPCName:
            VPCId = vpc[&quot;id&quot;]
        if not VPCRegion:
            VPCRegion = vpc[&quot;region&quot;]
        args.update({&quot;VPC&quot;: {&quot;VPCId&quot;: VPCId, &quot;VPCRegion&quot;: VPCRegion}})
    else:
        if any((VPCId, VPCName, VPCRegion)):
            log.info(
                &quot;Options VPCId, VPCName, and VPCRegion are ignored when creating &quot;
                &quot;non-private zones.&quot;
            )
    tries = 10
    while tries:
        try:
            r = conn.create_hosted_zone(**args)
            r.pop(&quot;ResponseMetadata&quot;, None)
            if _wait_for_sync(r[&quot;ChangeInfo&quot;][&quot;Id&quot;], conn):
                return [r]
            return []
        except ClientError as e:
            if tries and e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                log.debug(&quot;Throttled by AWS API.&quot;)
                time.sleep(3)
                tries -= 1
                continue
            log.error(&quot;Failed to create hosted zone %s: %s&quot;, Name, e)
            return []
    return []


def update_hosted_zone_comment(
    Id=None,
    Name=None,
    Comment=None,
    PrivateZone=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Update the comment on an existing Route 53 hosted zone.

    Id
        The unique Zone Identifier for the Hosted Zone.

    Name
        The domain name associated with the Hosted Zone(s).

    Comment
        Any comments you want to include about the hosted zone.

    PrivateZone
        Boolean - Set to True if changing a private hosted zone.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.update_hosted_zone_comment Name=example.org. \
                Comment=&quot;This is an example comment for an example zone&quot;
    &quot;&quot;&quot;
    if not _exactly_one((Id, Name)):
        raise SaltInvocationError(&quot;Exactly one of either Id or Name is required.&quot;)
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    if Name:
        args = {
            &quot;Name&quot;: Name,
            &quot;PrivateZone&quot;: PrivateZone,
            &quot;region&quot;: region,
            &quot;key&quot;: key,
            &quot;keyid&quot;: keyid,
            &quot;profile&quot;: profile,
        }
        zone = find_hosted_zone(**args)
        if not zone:
            log.error(&quot;Couldn't resolve domain name %s to a hosted zone ID.&quot;, Name)
            return []
        Id = zone[0][&quot;HostedZone&quot;][&quot;Id&quot;]
    tries = 10
    while tries:
        try:
            r = conn.update_hosted_zone_comment(Id=Id, Comment=Comment)
            r.pop(&quot;ResponseMetadata&quot;, None)
            return [r]
        except ClientError as e:
            if tries and e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                log.debug(&quot;Throttled by AWS API.&quot;)
                time.sleep(3)
<A NAME="6"></A>                tries -= 1
                continue
            log.error(&quot;Failed to update comment on hosted zone %s: %s&quot;, Name or Id, e)
    r<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match23618-1.html#6',3,'match23618-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>eturn []


def associate_vpc_with_hosted_zone(
    HostedZoneId=None,
    Name=None,
    VPCId=None,
    VPCName=None,
    VPCRegion=None,
    Comment=None,
    region=None,
    key=None,
    keyid=None,
    profile=</B></FONT>None,
):
    &quot;&quot;&quot;
    Associates an Amazon VPC with a private hosted zone.

    To perform the association, the VPC and the private hosted zone must already exist. You can't
    convert a public hosted zone into a private hosted zone.  If you want to associate a VPC from
    one AWS account with a zone from a another, the AWS account owning the hosted zone must first
    submit a CreateVPCAssociationAuthorization (using create_vpc_association_authorization() or by
    other means, such as the AWS console).  With that done, the account owning the VPC can then call
    associate_vpc_with_hosted_zone() to create the association.

    Note that if both sides happen to be within the same account, associate_vpc_with_hosted_zone()
    is enough on its own, and there is no need for the CreateVPCAssociationAuthorization step.

    Also note that looking up hosted zones by name (e.g. using the Name parameter) only works
    within a single account - if you're associating a VPC to a zone in a different account, as
    outlined above, you unfortunately MUST use the HostedZoneId parameter exclusively.

    HostedZoneId
        The unique Zone Identifier for the Hosted Zone.

    Name
        The domain name associated with the Hosted Zone(s).

    VPCId
        When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
        required.  Exclusive with VPCName.

    VPCName
        When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
        required.  Exclusive with VPCId.

    VPCRegion
        When working with a private hosted zone, the region of the associated VPC is required.  If
        not provided, an effort will be made to determine it from VPCId or VPCName, if possible.  If
        this fails, you'll need to provide an explicit value for VPCRegion.

    Comment
        Any comments you want to include about the change being made.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.associate_vpc_with_hosted_zone \
                    Name=example.org. VPCName=myVPC \
                    VPCRegion=us-east-1 Comment=&quot;Whoo-hoo!  I added another VPC.&quot;

    &quot;&quot;&quot;
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            &quot;Exactly one of either HostedZoneId or Name is required.&quot;
        )
    if not _exactly_one((VPCId, VPCName)):
        raise SaltInvocationError(&quot;Exactly one of either VPCId or VPCName is required.&quot;)
    if Name:
        # {'PrivateZone': True} because you can only associate VPCs with private hosted zones.
        args = {
            &quot;Name&quot;: Name,
            &quot;PrivateZone&quot;: True,
            &quot;region&quot;: region,
            &quot;key&quot;: key,
            &quot;keyid&quot;: keyid,
            &quot;profile&quot;: profile,
        }
        zone = find_hosted_zone(**args)
        if not zone:
            log.error(
                &quot;Couldn't resolve domain name %s to a private hosted zone ID.&quot;, Name
            )
            return False
        HostedZoneId = zone[0][&quot;HostedZone&quot;][&quot;Id&quot;]
    vpcs = __salt__[&quot;boto_vpc.describe_vpcs&quot;](
        vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
    ).get(&quot;vpcs&quot;, [])
    if VPCRegion and vpcs:
        vpcs = [v for v in vpcs if v[&quot;region&quot;] == VPCRegion]
    if not vpcs:
        log.error(&quot;No VPC matching the given criteria found.&quot;)
        return False
    if len(vpcs) &gt; 1:
        log.error(
            &quot;Multiple VPCs matching the given criteria found: %s.&quot;,
            &quot;, &quot;.join([v[&quot;id&quot;] for v in vpcs]),
        )
        return False
    vpc = vpcs[0]
    if VPCName:
        VPCId = vpc[&quot;id&quot;]
    if not VPCRegion:
<A NAME="5"></A>        VPCRegion = vpc[&quot;region&quot;]
    args = {
        &quot;HostedZoneId&quot;: HostedZoneId,
        &quot;VPC&quot;: {<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match23618-1.html#5',3,'match23618-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;VPCId&quot;: VPCId, &quot;VPCRegion&quot;: VPCRegion},
    }
    args.update({&quot;Comment&quot;: Comment}) if Comment is not None else None

    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    tries = 10
    while</B></FONT> tries:
        try:
            r = conn.associate_vpc_with_hosted_zone(**args)
            return _wait_for_sync(r[&quot;ChangeInfo&quot;][&quot;Id&quot;], conn)
        except ClientError as e:
            if e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;ConflictingDomainExists&quot;:
                log.debug(&quot;VPC Association already exists.&quot;)
                # return True since the current state is the desired one
                return True
            if tries and e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                log.debug(&quot;Throttled by AWS API.&quot;)
                time.sleep(3)
                tries -= 1
                continue
            log.error(
                &quot;Failed to associate VPC %s with hosted zone %s: %s&quot;,
                VPCName or VPCId,
                Name or HostedZoneId,
                e,
            )
    return False


def disassociate_vpc_from_hosted_zone(
    HostedZoneId=None,
    Name=None,
    VPCId=None,
    VPCName=None,
    VPCRegion=None,
    Comment=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Disassociates an Amazon VPC from a private hosted zone.

    You can't disassociate the last VPC from a private hosted zone.  You also can't convert a
    private hosted zone into a public hosted zone.

    Note that looking up hosted zones by name (e.g. using the Name parameter) only works XXX FACTCHECK
    within a single AWS account - if you're disassociating a VPC in one account from a hosted zone
    in a different account you unfortunately MUST use the HostedZoneId parameter exclusively. XXX FIXME DOCU

    HostedZoneId
        The unique Zone Identifier for the Hosted Zone.

    Name
        The domain name associated with the Hosted Zone(s).

    VPCId
        When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
        required.  Exclusive with VPCName.

    VPCName
        When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
        required.  Exclusive with VPCId.

    VPCRegion
        When working with a private hosted zone, the region of the associated VPC is required.  If
        not provided, an effort will be made to determine it from VPCId or VPCName, if possible.  If
        this fails, you'll need to provide an explicit value for VPCRegion.

    Comment
        Any comments you want to include about the change being made.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.disassociate_vpc_from_hosted_zone \
                    Name=example.org. VPCName=myVPC \
                    VPCRegion=us-east-1 Comment=&quot;Whoops!  Don't wanna talk to this-here zone no more.&quot;

    &quot;&quot;&quot;
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            &quot;Exactly one of either HostedZoneId or Name is required.&quot;
        )
    if not _exactly_one((VPCId, VPCName)):
        raise SaltInvocationError(&quot;Exactly one of either VPCId or VPCName is required.&quot;)
    if Name:
        # {'PrivateZone': True} because you can only associate VPCs with private hosted zones.
        args = {
            &quot;Name&quot;: Name,
            &quot;PrivateZone&quot;: True,
            &quot;region&quot;: region,
            &quot;key&quot;: key,
            &quot;keyid&quot;: keyid,
            &quot;profile&quot;: profile,
        }
        zone = find_hosted_zone(**args)
        if not zone:
            log.error(
                &quot;Couldn't resolve domain name %s to a private hosted zone ID.&quot;, Name
            )
            return False
        HostedZoneId = zone[0][&quot;HostedZone&quot;][&quot;Id&quot;]
    vpcs = __salt__[&quot;boto_vpc.describe_vpcs&quot;](
        vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
    ).get(&quot;vpcs&quot;, [])
    if VPCRegion and vpcs:
        vpcs = [v for v in vpcs if v[&quot;region&quot;] == VPCRegion]
    if not vpcs:
        log.error(&quot;No VPC matching the given criteria found.&quot;)
        return False
    if len(vpcs) &gt; 1:
        log.error(
            &quot;Multiple VPCs matching the given criteria found: %s.&quot;,
            &quot;, &quot;.join([v[&quot;id&quot;] for v in vpcs]),
        )
        return False
    vpc = vpcs[0]
    if VPCName:
        VPCId = vpc[&quot;id&quot;]
    if not VPCRegion:
<A NAME="4"></A>        VPCRegion = vpc[&quot;region&quot;]
    args = {
        &quot;HostedZoneId&quot;: HostedZoneId,
        &quot;VPC&quot;: {<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match23618-1.html#4',3,'match23618-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>&quot;VPCId&quot;: VPCId, &quot;VPCRegion&quot;: VPCRegion},
    }
    args.update({&quot;Comment&quot;: Comment}) if Comment is not None else None

    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    tries = 10
    while</B></FONT> tries:
        try:
            r = conn.disassociate_vpc_from_hosted_zone(**args)
            return _wait_for_sync(r[&quot;ChangeInfo&quot;][&quot;Id&quot;], conn)
        except ClientError as e:
            if e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;VPCAssociationNotFound&quot;:
                log.debug(&quot;No VPC Association exists.&quot;)
                # return True since the current state is the desired one
                return True
            if tries and e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                log.debug(&quot;Throttled by AWS API.&quot;)
                time.sleep(3)
                tries -= 1
                continue
            log.error(
                &quot;Failed to associate VPC %s with hosted zone %s: %s&quot;,
                VPCName or VPCId,
                Name or HostedZoneId,
                e,
            )
    return False


# def create_vpc_association_authorization(*args, **kwargs):
#    '''
#    unimplemented
#    '''
#    pass


# def delete_vpc_association_authorization(*args, **kwargs):
#    '''
#    unimplemented
#    '''
#    pass


# def list_vpc_association_authorizations(*args, **kwargs):
#    '''
#    unimplemented
#    '''
#    pass


def delete_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Delete a Route53 hosted zone.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.delete_hosted_zone Z1234567890
    &quot;&quot;&quot;
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        r = conn.delete_hosted_zone(Id=Id)
        return _wait_for_sync(r[&quot;ChangeInfo&quot;][&quot;Id&quot;], conn)
    except ClientError as e:
        log.error(&quot;Failed to delete hosted zone %s: %s&quot;, Id, e)
    return False


def delete_hosted_zone_by_domain(
    Name, PrivateZone=None, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Delete a Route53 hosted zone by domain name, and PrivateZone status if provided.

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.delete_hosted_zone_by_domain example.org.
    &quot;&quot;&quot;
    args = {
        &quot;Name&quot;: Name,
        &quot;PrivateZone&quot;: PrivateZone,
        &quot;region&quot;: region,
        &quot;key&quot;: key,
        &quot;keyid&quot;: keyid,
        &quot;profile&quot;: profile,
    }
    # Be extra pedantic in the service of safety - if public/private is not provided and the domain
    # name resolves to both, fail and require them to declare it explicitly.
    zone = find_hosted_zone(**args)
    if not zone:
        log.error(&quot;Couldn't resolve domain name %s to a hosted zone ID.&quot;, Name)
        return False
    Id = zone[0][&quot;HostedZone&quot;][&quot;Id&quot;]
    return delete_hosted_zone(
        Id=Id, region=region, key=key, keyid=keyid, profile=profile
    )


def _aws_encode(x):
    &quot;&quot;&quot;
    An implementation of the encoding required to support AWS's domain name
    rules defined here__:

    .. __: http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html

    While AWS's documentation specifies individual ASCII characters which need
    to be encoded, we instead just try to force the string to one of
    escaped unicode or idna depending on whether there are non-ASCII characters
    present.

    This means that we support things like ドメイン.テスト as a domain name string.

    More information about IDNA encoding in python is found here__:

    .. __: https://pypi.org/project/idna

    &quot;&quot;&quot;
    ret = None
    try:
        x.encode(&quot;ascii&quot;)
        ret = re.sub(rb&quot;\\x([a-f0-8]{2})&quot;, _hexReplace, x.encode(&quot;unicode_escape&quot;))
    except UnicodeEncodeError:
        ret = x.encode(&quot;idna&quot;)
    except Exception as e:  # pylint: disable=broad-except
        log.error(
            &quot;Couldn't encode %s using either 'unicode_escape' or 'idna' codecs&quot;, x
        )
        raise CommandExecutionError(e)
    log.debug(&quot;AWS-encoded result for %s: %s&quot;, x, ret)
    return ret.decode(&quot;utf-8&quot;)


def _aws_encode_changebatch(o):
    &quot;&quot;&quot;
    helper method to process a change batch &amp; encode the bits which need encoding.
    &quot;&quot;&quot;
    change_idx = 0
    while change_idx &lt; len(o[&quot;Changes&quot;]):
        o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;][&quot;Name&quot;] = _aws_encode(
            o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;][&quot;Name&quot;]
        )
        if &quot;ResourceRecords&quot; in o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;]:
            rr_idx = 0
            while rr_idx &lt; len(
                o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;][&quot;ResourceRecords&quot;]
            ):
                o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;][&quot;ResourceRecords&quot;][
                    rr_idx
                ][&quot;Value&quot;] = _aws_encode(
                    o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;][&quot;ResourceRecords&quot;][
                        rr_idx
                    ][&quot;Value&quot;]
                )
                rr_idx += 1
        if &quot;AliasTarget&quot; in o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;]:
            o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;][&quot;AliasTarget&quot;][
                &quot;DNSName&quot;
            ] = _aws_encode(
                o[&quot;Changes&quot;][change_idx][&quot;ResourceRecordSet&quot;][&quot;AliasTarget&quot;][&quot;DNSName&quot;]
            )
        change_idx += 1
    return o


def _aws_decode(x):
    &quot;&quot;&quot;
    An implementation of the decoding required to support AWS's domain name
    rules defined here__:

    .. __: http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html

    The important part is this:

        If the domain name includes any characters other than a to z, 0 to 9, - (hyphen),
        or _ (underscore), Route 53 API actions return the characters as escape codes.
        This is true whether you specify the characters as characters or as escape
        codes when you create the entity.
        The Route 53 console displays the characters as characters, not as escape codes.&quot;

        For a list of ASCII characters the corresponding octal codes, do an internet search on &quot;ascii table&quot;.

    We look for the existence of any escape codes which give us a clue that
    we're received an escaped unicode string; or we assume it's idna encoded
    and then decode as necessary.
    &quot;&quot;&quot;
    if &quot;\\&quot; in x:
        return x.decode(&quot;unicode_escape&quot;)

    if type(x) == bytes:
        return x.decode(&quot;idna&quot;)

    return x


def _hexReplace(x):
    &quot;&quot;&quot;
    Converts a hex code to a base 16 int then the octal of it, minus the leading
    zero.

    This is necessary because x.encode('unicode_escape') automatically assumes
    you want a hex string, which AWS will accept but doesn't result in what
    you really want unless it's an octal escape sequence
    &quot;&quot;&quot;
    c = int(x.group(1), 16)
    return &quot;\\&quot; + str(oct(c))[1:]


def get_resource_records(
    HostedZoneId=None,
    Name=None,
    StartRecordName=None,
    StartRecordType=None,
    PrivateZone=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Get all resource records from a given zone matching the provided StartRecordName (if given) or all
    records in the zone (if not), optionally filtered by a specific StartRecordType.  This will return
    any and all RRs matching, regardless of their special AWS flavors (weighted, geolocation, alias,
    etc.) so your code should be prepared for potentially large numbers of records back from this
    function - for example, if you've created a complex geolocation mapping with lots of entries all
    over the world providing the same server name to many different regional clients.

    If you want EXACTLY ONE record to operate on, you'll need to implement any logic required to
    pick the specific RR you care about from those returned.

    Note that if you pass in Name without providing a value for PrivateZone (either True or
    False), CommandExecutionError can be raised in the case of both public and private zones
    matching the domain. XXX FIXME DOCU

    CLI Example:

    .. code-block:: bash

        salt myminion boto3_route53.get_records test.example.org example.org A
    &quot;&quot;&quot;
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            &quot;Exactly one of either HostedZoneId or Name must be provided.&quot;
        )
    if Name:
        args = {
            &quot;Name&quot;: Name,
            &quot;region&quot;: region,
            &quot;key&quot;: key,
            &quot;keyid&quot;: keyid,
            &quot;profile&quot;: profile,
        }
        args.update({&quot;PrivateZone&quot;: PrivateZone}) if PrivateZone is not None else None
        zone = find_hosted_zone(**args)
        if not zone:
            log.error(&quot;Couldn't resolve domain name %s to a hosted zone ID.&quot;, Name)
            return []
        HostedZoneId = zone[0][&quot;HostedZone&quot;][&quot;Id&quot;]

    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    ret = []
    next_rr_name = StartRecordName
    next_rr_type = StartRecordType
    next_rr_id = None
    done = False
    while True:
        if done:
            return ret
        args = {&quot;HostedZoneId&quot;: HostedZoneId}
        args.update(
            {&quot;StartRecordName&quot;: _aws_encode(next_rr_name)}
        ) if next_rr_name else None
        # Grrr, can't specify type unless name is set...  We'll do this via filtering later instead
        args.update(
            {&quot;StartRecordType&quot;: next_rr_type}
        ) if next_rr_name and next_rr_type else None
        args.update({&quot;StartRecordIdentifier&quot;: next_rr_id}) if next_rr_id else None
        try:
            r = conn.list_resource_record_sets(**args)
            rrs = r[&quot;ResourceRecordSets&quot;]
            next_rr_name = r.get(&quot;NextRecordName&quot;)
            next_rr_type = r.get(&quot;NextRecordType&quot;)
            next_rr_id = r.get(&quot;NextRecordIdentifier&quot;)
            for rr in rrs:
                rr[&quot;Name&quot;] = _aws_decode(rr[&quot;Name&quot;])
                # now iterate over the ResourceRecords and replace any encoded
                # value strings with the decoded versions
                if &quot;ResourceRecords&quot; in rr:
                    x = 0
                    while x &lt; len(rr[&quot;ResourceRecords&quot;]):
                        if &quot;Value&quot; in rr[&quot;ResourceRecords&quot;][x]:
                            rr[&quot;ResourceRecords&quot;][x][&quot;Value&quot;] = _aws_decode(
                                rr[&quot;ResourceRecords&quot;][x][&quot;Value&quot;]
                            )
                        x += 1
                # or if we are an AliasTarget then decode the DNSName
                if &quot;AliasTarget&quot; in rr:
                    rr[&quot;AliasTarget&quot;][&quot;DNSName&quot;] = _aws_decode(
                        rr[&quot;AliasTarget&quot;][&quot;DNSName&quot;]
                    )
                if StartRecordName and rr[&quot;Name&quot;] != StartRecordName:
                    done = True
                    break
                if StartRecordType and rr[&quot;Type&quot;] != StartRecordType:
                    if StartRecordName:
                        done = True
                        break
                    else:
                        # We're filtering by type alone, and there might be more later, so...
                        continue
                ret += [rr]
            if not next_rr_name:
                done = True
        except ClientError as e:
            # Try forever on a simple thing like this...
            if e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                log.debug(&quot;Throttled by AWS API.&quot;)
                time.sleep(3)
                continue
            raise


def change_resource_record_sets(
    HostedZoneId=None,
    Name=None,
    PrivateZone=None,
    ChangeBatch=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    See the `AWS Route53 API docs`__ as well as the `Boto3 documentation`__ for all the details...

    .. __: https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html
    .. __: http://boto3.readthedocs.io/en/latest/reference/services/route53.html#Route53.Client.change_resource_record_sets

    The syntax for a ChangeBatch parameter is as follows, but note that the permutations of allowed
    parameters and combinations thereof are quite varied, so perusal of the above linked docs is
    highly recommended for any non-trival configurations.

    .. code-block:: text

        {
            &quot;Comment&quot;: &quot;string&quot;,
            &quot;Changes&quot;: [
                {
                    &quot;Action&quot;: &quot;CREATE&quot;|&quot;DELETE&quot;|&quot;UPSERT&quot;,
                    &quot;ResourceRecordSet&quot;: {
                        &quot;Name&quot;: &quot;string&quot;,
                        &quot;Type&quot;: &quot;SOA&quot;|&quot;A&quot;|&quot;TXT&quot;|&quot;NS&quot;|&quot;CNAME&quot;|&quot;MX&quot;|&quot;NAPTR&quot;|&quot;PTR&quot;|&quot;SRV&quot;|&quot;SPF&quot;|&quot;AAAA&quot;,
                        &quot;SetIdentifier&quot;: &quot;string&quot;,
                        &quot;Weight&quot;: 123,
                        &quot;Region&quot;: &quot;us-east-1&quot;|&quot;us-east-2&quot;|&quot;us-west-1&quot;|&quot;us-west-2&quot;|&quot;ca-central-1&quot;|&quot;eu-west-1&quot;|&quot;eu-west-2&quot;|&quot;eu-central-1&quot;|&quot;ap-southeast-1&quot;|&quot;ap-southeast-2&quot;|&quot;ap-northeast-1&quot;|&quot;ap-northeast-2&quot;|&quot;sa-east-1&quot;|&quot;cn-north-1&quot;|&quot;ap-south-1&quot;,
                        &quot;GeoLocation&quot;: {
                            &quot;ContinentCode&quot;: &quot;string&quot;,
                            &quot;CountryCode&quot;: &quot;string&quot;,
                            &quot;SubdivisionCode&quot;: &quot;string&quot;
                        },
                        &quot;Failover&quot;: &quot;PRIMARY&quot;|&quot;SECONDARY&quot;,
                        &quot;TTL&quot;: 123,
                        &quot;ResourceRecords&quot;: [
                            {
                                &quot;Value&quot;: &quot;string&quot;
                            },
                        ],
                        &quot;AliasTarget&quot;: {
                            &quot;HostedZoneId&quot;: &quot;string&quot;,
                            &quot;DNSName&quot;: &quot;string&quot;,
                            &quot;EvaluateTargetHealth&quot;: True|False
                        },
                        &quot;HealthCheckId&quot;: &quot;string&quot;,
                        &quot;TrafficPolicyInstanceId&quot;: &quot;string&quot;
                    }
                },
            ]
        }

    CLI Example:

    .. code-block:: bash

        foo='{
               &quot;Name&quot;: &quot;my-cname.example.org.&quot;,
               &quot;TTL&quot;: 600,
               &quot;Type&quot;: &quot;CNAME&quot;,
               &quot;ResourceRecords&quot;: [
                 {
                   &quot;Value&quot;: &quot;my-host.example.org&quot;
                 }
               ]
             }'
        foo=`echo $foo`  # Remove newlines
        salt myminion boto3_route53.change_resource_record_sets DomainName=example.org. \
                keyid=A1234567890ABCDEF123 key=xblahblahblah \
                ChangeBatch=&quot;{'Changes': [{'Action': 'UPSERT', 'ResourceRecordSet': $foo}]}&quot;
    &quot;&quot;&quot;
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            &quot;Exactly one of either HostZoneId or Name must be provided.&quot;
        )
    if Name:
        args = {
            &quot;Name&quot;: Name,
            &quot;region&quot;: region,
            &quot;key&quot;: key,
            &quot;keyid&quot;: keyid,
            &quot;profile&quot;: profile,
        }
        args.update({&quot;PrivateZone&quot;: PrivateZone}) if PrivateZone is not None else None
        zone = find_hosted_zone(**args)
        if not zone:
            log.error(&quot;Couldn't resolve domain name %s to a hosted zone ID.&quot;, Name)
            return []
        HostedZoneId = zone[0][&quot;HostedZone&quot;][&quot;Id&quot;]

    args = {
        &quot;HostedZoneId&quot;: HostedZoneId,
        &quot;ChangeBatch&quot;: _aws_encode_changebatch(ChangeBatch),
    }

    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    tries = 20  # A bit more headroom
    while tries:
        try:
            r = conn.change_resource_record_sets(**args)
            return _wait_for_sync(
                r[&quot;ChangeInfo&quot;][&quot;Id&quot;], conn, 30
            )  # And a little extra time here
        except ClientError as e:
            if tries and e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;Throttling&quot;:
                log.debug(&quot;Throttled by AWS API.&quot;)
                time.sleep(3)
                tries -= 1
                continue
            log.error(
                &quot;Failed to apply requested changes to the hosted zone %s: %s&quot;,
                (Name or HostedZoneId),
                str(e),
            )
            raise e
    return False
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_s3_bucket_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
Connection module for Amazon S3 Buckets

.. versionadded:: 2016.3.0

:depends:
    - boto
    - boto3

The dependencies listed above can be installed via package or pip.

:configuration: This module accepts explicit Lambda credentials but can also
    utilize IAM roles assigned to the instance through Instance Profiles.
    Dynamic credentials are then automatically obtained from AWS API and no
    further configuration is necessary. More Information available at:

    .. code-block:: text

        http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html

    If IAM roles are not used you need to specify them either in a pillar or
    in the minion's config file:

    .. code-block:: yaml

        s3.keyid: GKTADJGHEIQSXMKKRBJ08H
        s3.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs

    A region may also be specified in the configuration:

    .. code-block:: yaml

        s3.region: us-east-1

    If a region is not specified, the default is us-east-1.

    It's also possible to specify key, keyid and region via a profile, either
    as a passed in dict, or as a string to pull from pillars or minion config:

    .. code-block:: yaml

        myprofile:
            keyid: GKTADJGHEIQSXMKKRBJ08H
            key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
            region: us-east-1

&quot;&quot;&quot;
# keep lint from choking on _get_conn and _cache_id
# pylint: disable=E0602
#  disable complaints about perfectly valid non-assignment code
# pylint: disable=W0106


import logging

import salt.utils.compat
import salt.utils.json
import salt.utils.versions
from salt.exceptions import SaltInvocationError

log = logging.getLogger(__name__)


# pylint: disable=import-error
<A NAME="0"></A>try:
    # pylint: disable=unused-import
    import boto
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#0',2,'match23618-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>import boto3

    # pylint: enable=unused-import
    from botocore.exceptions import ClientError

    logging.getLogger(&quot;boto3&quot;).setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
# pylint: enable=import-error


def __virtual__():
    &quot;&quot;&quot;
    Only load if boto libraries exist and if boto libraries are greater than
    a given version.
    &quot;&quot;&quot;
<A NAME="7"></A>    # the boto_lambda execution module relies on the connect_to_region() method
    # which was added in boto 2.8.0
    # https://github.com/boto/boto/commit/33ac26b416fbb48a60602542b4ce15dcc7029f12
    return salt.utils.versions.check_boto_reqs(</B></FONT>boto3_ver=<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#7',2,'match23618-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;1.2.1&quot;)


def __init__(opts):
    if HAS_BOTO:
        __utils__[&quot;boto3.assign_funcs&quot;](__name__, &quot;s3&quot;)


def exists(Bucket, region=None, key=None, keyid=None, profile=</B></FONT>None):
    &quot;&quot;&quot;
    Given a bucket name, check to see if the given bucket exists.

    Returns True if the given bucket exists and returns False if the given
    bucket does not exist.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.exists mybucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        buckets = conn.head_bucket(Bucket=Bucket)
        return {&quot;exists&quot;: True}
    except ClientError as e:
<A NAME="1"></A>        if e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;404&quot;:
            return {&quot;exists&quot;: False}
        err = __utils__[&quot;boto3.get_error&quot;](e)
        return {<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#1',2,'match23618-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;error&quot;: err}


def create(
    Bucket,
    ACL=None,
    LocationConstraint=None,
    GrantFullControl=None,
    GrantRead=None,
    GrantReadACP=None,
    GrantWrite=None,
    GrantWriteACP=None,
    region=None,
    key=None,
    keyid=None,
    profile=</B></FONT>None,
):
    &quot;&quot;&quot;
    Given a valid config, create an S3 Bucket.

    Returns {created: true} if the bucket was created and returns
    {created: False} if the bucket was not created.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.create my_bucket \\
                         GrantFullControl='emailaddress=example@example.com' \\
                         GrantRead='uri=&quot;http://acs.amazonaws.com/groups/global/AllUsers&quot;' \\
                         GrantReadACP='emailaddress=&quot;exampl@example.com&quot;,id=&quot;2345678909876432&quot;' \\
                         LocationConstraint=us-west-1

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        kwargs = {}
        for arg in (
            &quot;ACL&quot;,
            &quot;GrantFullControl&quot;,
            &quot;GrantRead&quot;,
            &quot;GrantReadACP&quot;,
            &quot;GrantWrite&quot;,
            &quot;GrantWriteACP&quot;,
        ):
            if locals()[arg] is not None:
                kwargs[arg] = str(locals()[arg])
        if LocationConstraint:
            kwargs[&quot;CreateBucketConfiguration&quot;] = {
                &quot;LocationConstraint&quot;: LocationConstraint
            }
        location = conn.create_bucket(Bucket=Bucket, **kwargs)
        conn.get_waiter(&quot;bucket_exists&quot;).wait(Bucket=Bucket)
        if location:
            log.info(
                &quot;The newly created bucket name is located at %s&quot;, location[&quot;Location&quot;]
            )

            return {&quot;created&quot;: True, &quot;name&quot;: Bucket, &quot;Location&quot;: location[&quot;Location&quot;]}
        else:
            log.warning(&quot;Bucket was not created&quot;)
            return {&quot;created&quot;: False}
    except ClientError as e:
        return {&quot;created&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete(
    Bucket,
    MFA=None,
    RequestPayer=None,
    Force=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Given a bucket name, delete it, optionally emptying it first.

    Returns {deleted: true} if the bucket was deleted and returns
    {deleted: false} if the bucket was not deleted.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete mybucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if Force:
            empty(
                Bucket,
                MFA=MFA,
                RequestPayer=RequestPayer,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        conn.delete_bucket(Bucket=Bucket)
        return {&quot;deleted&quot;: True}
    except ClientError as e:
        return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete_objects(
    Bucket,
    Delete,
    MFA=None,
    RequestPayer=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Delete objects in a given S3 bucket.

    Returns {deleted: true} if all objects were deleted
    and {deleted: false, failed: [key, ...]} otherwise

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete_objects mybucket '{Objects: [Key: myobject]}'

    &quot;&quot;&quot;

    if isinstance(Delete, str):
        Delete = salt.utils.json.loads(Delete)
    if not isinstance(Delete, dict):
        raise SaltInvocationError(&quot;Malformed Delete request.&quot;)
    if &quot;Objects&quot; not in Delete:
        raise SaltInvocationError(&quot;Malformed Delete request.&quot;)

    failed = []
    objs = Delete[&quot;Objects&quot;]
    for i in range(0, len(objs), 1000):
        chunk = objs[i : i + 1000]
        subset = {&quot;Objects&quot;: chunk, &quot;Quiet&quot;: True}
        try:
            args = {&quot;Bucket&quot;: Bucket}
            args.update({&quot;MFA&quot;: MFA}) if MFA else None
            args.update({&quot;RequestPayer&quot;: RequestPayer}) if RequestPayer else None
            args.update({&quot;Delete&quot;: subset})
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            ret = conn.delete_objects(**args)
            failed += ret.get(&quot;Errors&quot;, [])
        except ClientError as e:
            return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}

    if failed:
        return {&quot;deleted&quot;: False, &quot;failed&quot;: failed}
    else:
        return {&quot;deleted&quot;: True}


def describe(Bucket, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Given a bucket name describe its properties.

    Returns a dictionary of interesting properties.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.describe mybucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        result = {}
        conn_dict = {
            &quot;ACL&quot;: conn.get_bucket_acl,
            &quot;CORS&quot;: conn.get_bucket_cors,
            &quot;LifecycleConfiguration&quot;: conn.get_bucket_lifecycle_configuration,
            &quot;Location&quot;: conn.get_bucket_location,
            &quot;Logging&quot;: conn.get_bucket_logging,
            &quot;NotificationConfiguration&quot;: conn.get_bucket_notification_configuration,
            &quot;Policy&quot;: conn.get_bucket_policy,
            &quot;Replication&quot;: conn.get_bucket_replication,
            &quot;RequestPayment&quot;: conn.get_bucket_request_payment,
            &quot;Versioning&quot;: conn.get_bucket_versioning,
            &quot;Website&quot;: conn.get_bucket_website,
        }

        for key, query in conn_dict.items():
            try:
                data = query(Bucket=Bucket)
            except ClientError as e:
                if e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) in (
                    &quot;NoSuchLifecycleConfiguration&quot;,
                    &quot;NoSuchCORSConfiguration&quot;,
                    &quot;NoSuchBucketPolicy&quot;,
                    &quot;NoSuchWebsiteConfiguration&quot;,
                    &quot;ReplicationConfigurationNotFoundError&quot;,
                    &quot;NoSuchTagSet&quot;,
                ):
                    continue
                raise
            if &quot;ResponseMetadata&quot; in data:
                del data[&quot;ResponseMetadata&quot;]
            result[key] = data

        tags = {}
        try:
            data = conn.get_bucket_tagging(Bucket=Bucket)
            for tagdef in data.get(&quot;TagSet&quot;):
                tags[tagdef.get(&quot;Key&quot;)] = tagdef.get(&quot;Value&quot;)
        except ClientError as e:
            if not e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;NoSuchTagSet&quot;:
                raise
        if tags:
            result[&quot;Tagging&quot;] = tags
        return {&quot;bucket&quot;: result}
    except ClientError as e:
        err = __utils__[&quot;boto3.get_error&quot;](e)
        if e.response.get(&quot;Error&quot;, {}).get(&quot;Code&quot;) == &quot;NoSuchBucket&quot;:
            return {&quot;bucket&quot;: None}
        return {&quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}
<A NAME="3"></A>

def empty(
    Bucket, MFA=None, RequestPayer<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#3',2,'match23618-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>=None, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Delete all objects in a given S3 bucket.

    Returns {deleted: true} if all objects were deleted
    and {deleted: false, failed: [key, ...]} otherwise

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.empty mybucket

    &quot;&quot;&quot;

    stuff = list_object_versions(
        Bucket, region=region, key=key, keyid=keyid, profile=profile
    )
    Delete = {}
    Delete[</B></FONT>&quot;Objects&quot;] = [
        {&quot;Key&quot;: v[&quot;Key&quot;], &quot;VersionId&quot;: v[&quot;VersionId&quot;]}
        for v in stuff.get(&quot;Versions&quot;, [])
    ]
    Delete[&quot;Objects&quot;] += [
        {&quot;Key&quot;: v[&quot;Key&quot;], &quot;VersionId&quot;: v[&quot;VersionId&quot;]}
        for v in stuff.get(&quot;DeleteMarkers&quot;, [])
    ]
    if Delete[&quot;Objects&quot;]:
        ret = delete_objects(
            Bucket,
            Delete,
            MFA=MFA,
            RequestPayer=RequestPayer,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        failed = ret.get(&quot;failed&quot;, [])
        if failed:
            return {&quot;deleted&quot;: False, &quot;failed&quot;: ret[failed]}
    return {&quot;deleted&quot;: True}


def list(region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    List all buckets owned by the authenticated sender of the request.

    Returns list of buckets

    CLI Example:

    .. code-block:: yaml

        Owner: {...}
        Buckets:
          - {...}
          - {...}

    &quot;&quot;&quot;
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        buckets = conn.list_buckets()
        if not bool(buckets.get(&quot;Buckets&quot;)):
            log.warning(&quot;No buckets found&quot;)
        if &quot;ResponseMetadata&quot; in buckets:
            del buckets[&quot;ResponseMetadata&quot;]
        return buckets
    except ClientError as e:
        return {&quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def list_object_versions(
    Bucket,
    Delimiter=None,
    EncodingType=None,
    Prefix=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    List objects in a given S3 bucket.

    Returns a list of objects.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.list_object_versions mybucket

    &quot;&quot;&quot;

    try:
        Versions = []
<A NAME="5"></A>        DeleteMarkers = []
        args = {&quot;Bucket&quot;: Bucket}
        args.update({&quot;Delimiter&quot;: Delimiter}) if Delimiter else None
        args.update({<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#5',2,'match23618-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;EncodingType&quot;: EncodingType}) if Delimiter else None
        args.update({&quot;Prefix&quot;: Prefix}) if Prefix else None
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        IsTruncated = True
        while</B></FONT> IsTruncated:
            ret = conn.list_object_versions(**args)
            IsTruncated = ret.get(&quot;IsTruncated&quot;, False)
            if IsTruncated in (&quot;True&quot;, &quot;true&quot;, True):
                args[&quot;KeyMarker&quot;] = ret[&quot;NextKeyMarker&quot;]
                args[&quot;VersionIdMarker&quot;] = ret[&quot;NextVersionIdMarker&quot;]
            Versions += ret.get(&quot;Versions&quot;, [])
            DeleteMarkers += ret.get(&quot;DeleteMarkers&quot;, [])
        return {&quot;Versions&quot;: Versions, &quot;DeleteMarkers&quot;: DeleteMarkers}
    except ClientError as e:
        return {&quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def list_objects(
    Bucket,
    Delimiter=None,
    EncodingType=None,
    Prefix=None,
    FetchOwner=False,
    StartAfter=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    List objects in a given S3 bucket.

    Returns a list of objects.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.list_objects mybucket

    &quot;&quot;&quot;

    try:
        Contents = []
<A NAME="4"></A>        args = {&quot;Bucket&quot;: Bucket, &quot;FetchOwner&quot;: FetchOwner}
        args.update({&quot;Delimiter&quot;: Delimiter}) if Delimiter else None
        args.update({&quot;EncodingType&quot;: EncodingType}) if Delimiter else None
        args.update({<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#4',2,'match23618-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>&quot;Prefix&quot;: Prefix}) if Prefix else None
        args.update({&quot;StartAfter&quot;: StartAfter}) if StartAfter else None
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        IsTruncated = True
        while</B></FONT> IsTruncated:
            ret = conn.list_objects_v2(**args)
            IsTruncated = ret.get(&quot;IsTruncated&quot;, False)
            if IsTruncated in (&quot;True&quot;, &quot;true&quot;, True):
                args[&quot;ContinuationToken&quot;] = ret[&quot;NextContinuationToken&quot;]
<A NAME="6"></A>            Contents += ret.get(&quot;Contents&quot;, [])
        return {&quot;Contents&quot;: Contents}
    except ClientError as e:
        return {&quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#6',2,'match23618-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>e)}


def put_acl(
    Bucket,
    ACL=None,
    AccessControlPolicy=None,
    GrantFullControl=None,
    GrantRead=None,
    GrantReadACP=None,
    GrantWrite=None,
    GrantWriteACP=None,
    region=None,
    key=None,
    keyid=</B></FONT>None,
    profile=None,
):
    &quot;&quot;&quot;
    Given a valid config, update the ACL for a bucket.

    Returns {updated: true} if the ACL was updated and returns
    {updated: False} if the ACL was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_acl my_bucket 'public' \\
                         GrantFullControl='emailaddress=example@example.com' \\
                         GrantRead='uri=&quot;http://acs.amazonaws.com/groups/global/AllUsers&quot;' \\
                         GrantReadACP='emailaddress=&quot;exampl@example.com&quot;,id=&quot;2345678909876432&quot;'

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        kwargs = {}
        if AccessControlPolicy is not None:
            if isinstance(AccessControlPolicy, str):
                AccessControlPolicy = salt.utils.json.loads(AccessControlPolicy)
            kwargs[&quot;AccessControlPolicy&quot;] = AccessControlPolicy
        for arg in (
            &quot;ACL&quot;,
            &quot;GrantFullControl&quot;,
            &quot;GrantRead&quot;,
            &quot;GrantReadACP&quot;,
            &quot;GrantWrite&quot;,
            &quot;GrantWriteACP&quot;,
        ):
            if locals()[arg] is not None:
                kwargs[arg] = str(locals()[arg])
        conn.put_bucket_acl(Bucket=Bucket, **kwargs)
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_cors(Bucket, CORSRules, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Given a valid config, update the CORS rules for a bucket.

    Returns {updated: true} if CORS was updated and returns
    {updated: False} if CORS was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_cors my_bucket '[{\\
              &quot;AllowedHeaders&quot;:[],\\
              &quot;AllowedMethods&quot;:[&quot;GET&quot;],\\
              &quot;AllowedOrigins&quot;:[&quot;*&quot;],\\
              &quot;ExposeHeaders&quot;:[],\\
              &quot;MaxAgeSeconds&quot;:123,\\
        }]'

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if CORSRules is not None and isinstance(CORSRules, str):
            CORSRules = salt.utils.json.loads(CORSRules)
        conn.put_bucket_cors(Bucket=Bucket, CORSConfiguration={&quot;CORSRules&quot;: CORSRules})
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_lifecycle_configuration(
    Bucket, Rules, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Given a valid config, update the Lifecycle rules for a bucket.

    Returns {updated: true} if Lifecycle was updated and returns
    {updated: False} if Lifecycle was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_lifecycle_configuration my_bucket '[{\\
              &quot;Expiration&quot;: {...},\\
              &quot;ID&quot;: &quot;idstring&quot;,\\
              &quot;Prefix&quot;: &quot;prefixstring&quot;,\\
              &quot;Status&quot;: &quot;enabled&quot;,\\
              &quot;Transitions&quot;: [{...},],\\
              &quot;NoncurrentVersionTransitions&quot;: [{...},],\\
              &quot;NoncurrentVersionExpiration&quot;: {...},\\
        }]'

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if Rules is not None and isinstance(Rules, str):
            Rules = salt.utils.json.loads(Rules)
        conn.put_bucket_lifecycle_configuration(
            Bucket=Bucket, LifecycleConfiguration={&quot;Rules&quot;: Rules}
        )
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_logging(
    Bucket,
    TargetBucket=None,
    TargetPrefix=None,
    TargetGrants=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Given a valid config, update the logging parameters for a bucket.

    Returns {updated: true} if parameters were updated and returns
    {updated: False} if parameters were not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_logging my_bucket log_bucket '[{...}]' prefix

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        logstate = {}
        targets = {
            &quot;TargetBucket&quot;: TargetBucket,
            &quot;TargetGrants&quot;: TargetGrants,
            &quot;TargetPrefix&quot;: TargetPrefix,
        }
        for key, val in targets.items():
            if val is not None:
                logstate[key] = val
        if logstate:
            logstatus = {&quot;LoggingEnabled&quot;: logstate}
        else:
            logstatus = {}
        if TargetGrants is not None and isinstance(TargetGrants, str):
            TargetGrants = salt.utils.json.loads(TargetGrants)
        conn.put_bucket_logging(Bucket=Bucket, BucketLoggingStatus=logstatus)
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_notification_configuration(
    Bucket,
    TopicConfigurations=None,
    QueueConfigurations=None,
    LambdaFunctionConfigurations=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Given a valid config, update the notification parameters for a bucket.

    Returns {updated: true} if parameters were updated and returns
    {updated: False} if parameters were not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_notification_configuration my_bucket
                [{...}] \\
                [{...}] \\
                [{...}]

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if TopicConfigurations is None:
            TopicConfigurations = []
        elif isinstance(TopicConfigurations, str):
            TopicConfigurations = salt.utils.json.loads(TopicConfigurations)
        if QueueConfigurations is None:
            QueueConfigurations = []
        elif isinstance(QueueConfigurations, str):
            QueueConfigurations = salt.utils.json.loads(QueueConfigurations)
        if LambdaFunctionConfigurations is None:
            LambdaFunctionConfigurations = []
        elif isinstance(LambdaFunctionConfigurations, str):
            LambdaFunctionConfigurations = salt.utils.json.loads(
                LambdaFunctionConfigurations
            )
        # TODO allow the user to use simple names &amp; substitute ARNs for those names
        conn.put_bucket_notification_configuration(
            Bucket=Bucket,
            NotificationConfiguration={
                &quot;TopicConfigurations&quot;: TopicConfigurations,
                &quot;QueueConfigurations&quot;: QueueConfigurations,
                &quot;LambdaFunctionConfigurations&quot;: LambdaFunctionConfigurations,
            },
        )
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_policy(Bucket, Policy, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Given a valid config, update the policy for a bucket.

    Returns {updated: true} if policy was updated and returns
    {updated: False} if policy was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_policy my_bucket {...}

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if Policy is None:
            Policy = &quot;{}&quot;
        elif not isinstance(Policy, str):
            Policy = salt.utils.json.dumps(Policy)
        conn.put_bucket_policy(Bucket=Bucket, Policy=Policy)
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
    if name.startswith(&quot;arn:aws:iam:&quot;):
        return name

    account_id = __salt__[&quot;boto_iam.get_account_id&quot;](
        region=region, key=key, keyid=keyid, profile=profile
    )
    if profile and &quot;region&quot; in profile:
        region = profile[&quot;region&quot;]
    if region is None:
        region = &quot;us-east-1&quot;
    return &quot;arn:aws:iam::{}:role/{}&quot;.format(account_id, name)


def put_replication(
    Bucket, Role, Rules, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Given a valid config, update the replication configuration for a bucket.

    Returns {updated: true} if replication configuration was updated and returns
    {updated: False} if replication configuration was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_replication my_bucket my_role [...]

<A NAME="2"></A>    &quot;&quot;&quot;

    try:
        conn <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match23618-0.html#2',2,'match23618-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        Role = _get_role_arn(
            name=Role, region=region, key=key, keyid=keyid, profile=</B></FONT>profile
        )
        if Rules is None:
            Rules = []
        elif isinstance(Rules, str):
            Rules = salt.utils.json.loads(Rules)
        conn.put_bucket_replication(
            Bucket=Bucket, ReplicationConfiguration={&quot;Role&quot;: Role, &quot;Rules&quot;: Rules}
        )
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_request_payment(Bucket, Payer, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Given a valid config, update the request payment configuration for a bucket.

    Returns {updated: true} if request payment configuration was updated and returns
    {updated: False} if request payment configuration was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_request_payment my_bucket Requester

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.put_bucket_request_payment(
            Bucket=Bucket, RequestPaymentConfiguration={&quot;Payer&quot;: Payer}
        )
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_tagging(Bucket, region=None, key=None, keyid=None, profile=None, **kwargs):
    &quot;&quot;&quot;
    Given a valid config, update the tags for a bucket.

    Returns {updated: true} if tags were updated and returns
    {updated: False} if tags were not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_tagging my_bucket my_role [...]

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        tagslist = []
        for k, v in kwargs.items():
            if str(k).startswith(&quot;__&quot;):
                continue
            tagslist.append({&quot;Key&quot;: str(k), &quot;Value&quot;: str(v)})
        conn.put_bucket_tagging(Bucket=Bucket, Tagging={&quot;TagSet&quot;: tagslist})
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_versioning(
    Bucket,
    Status,
    MFADelete=None,
    MFA=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Given a valid config, update the versioning configuration for a bucket.

    Returns {updated: true} if versioning configuration was updated and returns
    {updated: False} if versioning configuration was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_versioning my_bucket Enabled

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        VersioningConfiguration = {&quot;Status&quot;: Status}
        if MFADelete is not None:
            VersioningConfiguration[&quot;MFADelete&quot;] = MFADelete
        kwargs = {}
        if MFA is not None:
            kwargs[&quot;MFA&quot;] = MFA
        conn.put_bucket_versioning(
            Bucket=Bucket, VersioningConfiguration=VersioningConfiguration, **kwargs
        )
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def put_website(
    Bucket,
    ErrorDocument=None,
    IndexDocument=None,
    RedirectAllRequestsTo=None,
    RoutingRules=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    &quot;&quot;&quot;
    Given a valid config, update the website configuration for a bucket.

    Returns {updated: true} if website configuration was updated and returns
    {updated: False} if website configuration was not updated.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.put_website my_bucket IndexDocument='{&quot;Suffix&quot;:&quot;index.html&quot;}'

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        WebsiteConfiguration = {}
        for key in (
            &quot;ErrorDocument&quot;,
            &quot;IndexDocument&quot;,
            &quot;RedirectAllRequestsTo&quot;,
            &quot;RoutingRules&quot;,
        ):
            val = locals()[key]
            if val is not None:
                if isinstance(val, str):
                    WebsiteConfiguration[key] = salt.utils.json.loads(val)
                else:
                    WebsiteConfiguration[key] = val
        conn.put_bucket_website(
            Bucket=Bucket, WebsiteConfiguration=WebsiteConfiguration
        )
        return {&quot;updated&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;updated&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete_cors(Bucket, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Delete the CORS configuration for the given bucket

    Returns {deleted: true} if CORS was deleted and returns
    {deleted: False} if CORS was not deleted.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete_cors my_bucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_cors(Bucket=Bucket)
        return {&quot;deleted&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete_lifecycle_configuration(
    Bucket, region=None, key=None, keyid=None, profile=None
):
    &quot;&quot;&quot;
    Delete the lifecycle configuration for the given bucket

    Returns {deleted: true} if Lifecycle was deleted and returns
    {deleted: False} if Lifecycle was not deleted.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete_lifecycle_configuration my_bucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_lifecycle(Bucket=Bucket)
        return {&quot;deleted&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete_policy(Bucket, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Delete the policy from the given bucket

    Returns {deleted: true} if policy was deleted and returns
    {deleted: False} if policy was not deleted.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete_policy my_bucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_policy(Bucket=Bucket)
        return {&quot;deleted&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete_replication(Bucket, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Delete the replication config from the given bucket

    Returns {deleted: true} if replication configuration was deleted and returns
    {deleted: False} if replication configuration was not deleted.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete_replication my_bucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_replication(Bucket=Bucket)
        return {&quot;deleted&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete_tagging(Bucket, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Delete the tags from the given bucket

    Returns {deleted: true} if tags were deleted and returns
    {deleted: False} if tags were not deleted.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete_tagging my_bucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_tagging(Bucket=Bucket)
        return {&quot;deleted&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}


def delete_website(Bucket, region=None, key=None, keyid=None, profile=None):
    &quot;&quot;&quot;
    Remove the website configuration from the given bucket

    Returns {deleted: true} if website configuration was deleted and returns
    {deleted: False} if website configuration was not deleted.

    CLI Example:

    .. code-block:: bash

        salt myminion boto_s3_bucket.delete_website my_bucket

    &quot;&quot;&quot;

    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_website(Bucket=Bucket)
        return {&quot;deleted&quot;: True, &quot;name&quot;: Bucket}
    except ClientError as e:
        return {&quot;deleted&quot;: False, &quot;error&quot;: __utils__[&quot;boto3.get_error&quot;](e)}
</PRE>
</div>
  </div>
</body>
</html>
