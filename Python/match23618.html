<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto3_route53_1.py &amp; boto_s3_bucket_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto3_route53_1.py &amp; boto_s3_bucket_1.py
      </h3>
<h1 align="center">
        9.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto3_route53_1.py (9.731233%)<th>boto_s3_bucket_1.py (8.84583%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-79)<td><a href="#" name="0">(68-88)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(302-317)<td><a href="#" name="1">(119-134)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(383-389)<td><a href="#" name="2">(797-799)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(272-301)<td><a href="#" name="3">(349-369)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(758-764)<td><a href="#" name="4">(497-501)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(632-638)<td><a href="#" name="5">(450-454)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(525-538)<td><a href="#" name="6">(509-523)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(79-89)<td><a href="#" name="7">(88-96)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_route53_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import re
3 import time
4 import salt.utils.compat
5 import salt.utils.versions
6 from salt.exceptions import CommandExecutionError, SaltInvocationError
7 log = logging.getLogger(__name__)
8 <a name="0"></a>
9 try:
10     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import boto3
11     from botocore.exceptions import ClientError
12     logging.getLogger("boto3").setLevel(logging.CRITICAL)
13     HAS_BOTO3 = True
14 except ImportError:
15     HAS_BOTO3 = False
16 def __virtual__():
17     return salt.utils.versions.check_boto_reqs(</b></font><font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>)
18 def __init__(opts):
19     if HAS_BOTO3:
20         __utils__["boto3.assign_funcs"](__name__, "route53")
21 def _collect_results(func, item, args, marker="Marker", nextmarker="NextMarker"):
22     ret = []
23     Marker =</b></font> args.get(marker, "")
24     tries = 10
25     while Marker is not None:
26         try:
27             r = func(**args)
28         except ClientError as e:
29             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
30                 log.debug("Throttled by AWS API.")
31                 time.sleep(3)
32                 tries -= 1
33                 continue
34             log.error("Could not collect results from %s(): %s", func, e)
35             return []
36         i = r.get(item, []) if item else r
37         i.pop("ResponseMetadata", None) if isinstance(i, dict) else None
38         ret += i if isinstance(i, list) else [i]
39         Marker = r.get(nextmarker)
40         args.update({marker: Marker})
41     return ret
42 def _wait_for_sync(change, conn, tries=10, sleep=20):
43     for retry in range(1, tries + 1):
44         log.info("Getting route53 status (attempt %s)", retry)
45         status = "wait"
46         try:
47             status = conn.get_change(Id=change)["ChangeInfo"]["Status"]
48         except ClientError as e:
49             if e.response.get("Error", {}).get("Code") == "Throttling":
50                 log.debug("Throttled by AWS API.")
51             else:
52                 raise
53         if status == "INSYNC":
54             return True
55         time.sleep(sleep)
56     log.error("Timed out waiting for Route53 INSYNC status.")
57     return False
58 def find_hosted_zone(
59     Id=None,
60     Name=None,
61     PrivateZone=None,
62     region=None,
63     key=None,
64     keyid=None,
65     profile=None,
66 ):
67     if not _exactly_one((Id, Name)):
68         raise SaltInvocationError("Exactly one of either Id or Name is required.")
69     if PrivateZone is not None and not isinstance(PrivateZone, bool):
70         raise SaltInvocationError(
71             "If set, PrivateZone must be a bool (e.g. True / False)."
72         )
73     if Id:
74         ret = get_hosted_zone(Id, region=region, key=key, keyid=keyid, profile=profile)
75     else:
76         ret = get_hosted_zones_by_domain(
77             Name, region=region, key=key, keyid=keyid, profile=profile
78         )
79     if PrivateZone is not None:
80         ret = [
81             m for m in ret if m["HostedZone"]["Config"]["PrivateZone"] is PrivateZone
82         ]
83     if len(ret) &gt; 1:
84         log.error(
85             "Request matched more than one Hosted Zone (%s). Refine your "
86             "criteria and try again.",
87             [z["HostedZone"]["Id"] for z in ret],
88         )
89         ret = []
90     return ret
91 def get_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
92     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
93     args = {"Id": Id}
94     return _collect_results(conn.get_hosted_zone, None, args)
95 def get_hosted_zones_by_domain(Name, region=None, key=None, keyid=None, profile=None):
96     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
97     zones = [
98         z
99         for z in _collect_results(conn.list_hosted_zones, "HostedZones", {})
100         if z["Name"] == _aws_encode(Name)
101     ]
102     ret = []
103     for z in zones:
104         ret += get_hosted_zone(
105             Id=z["Id"], region=region, key=key, keyid=keyid, profile=profile
106         )
107     return ret
108 <a name="3"></a>
109 def list_hosted_zones(
110     DelegationSetId<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, region=None, key=None, keyid=None, profile=None
111 ):
112     args = {"DelegationSetId"</b></font>: DelegationSetId} if DelegationSetId else {}
113     return _collect_results(conn<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.list_hosted_zones, "HostedZones", args)
114 def create_hosted_zone(
115     Name,
116     VPCId=None,
117     VPCName=None,
118     VPCRegion=None,
119     CallerReference=None,
120     Comment="",
121     PrivateZone=False,
122     DelegationSetId=None,
123     region=None,
124     key=None,
125     keyid=None,
126     profile=</b></font>None,
127 ):
128     if not Name.endswith("."):
129         raise SaltInvocationError(
130 <a name="2"></a>            "Domain must be fully-qualified, complete with trailing period."
131         )
132     Name = _aws_encode(Name)
133     conn <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
134     deets = find_hosted_zone(
135         Name=Name,
136         PrivateZone=PrivateZone,
137         region=region,
138         key=key,
139         keyid=</b></font>keyid,
140         profile=profile,
141     )
142     if deets:
143         log.info(
144             "Route 53 hosted zone %s already exists. You may want to pass "
145             "e.g. 'PrivateZone=True' or similar...",
146             Name,
147         )
148         return None
149     args = {
150         "Name": Name,
151         "CallerReference": CallerReference,
152         "HostedZoneConfig": {"Comment": Comment, "PrivateZone": PrivateZone},
153     }
154     args.update({"DelegationSetId": DelegationSetId}) if DelegationSetId else None
155     if PrivateZone:
156         if not _exactly_one((VPCName, VPCId)):
157             raise SaltInvocationError(
158                 "Either VPCName or VPCId is required when creating a private zone."
159             )
160         vpcs = __salt__["boto_vpc.describe_vpcs"](
161             vpc_id=VPCId,
162             name=VPCName,
163             region=region,
164             key=key,
165             keyid=keyid,
166             profile=profile,
167         ).get("vpcs", [])
168         if VPCRegion and vpcs:
169             vpcs = [v for v in vpcs if v["region"] == VPCRegion]
170         if not vpcs:
171             log.error(
172                 "Private zone requested but no VPC matching given criteria found."
173             )
174             return None
175         if len(vpcs) &gt; 1:
176             log.error(
177                 "Private zone requested but multiple VPCs matching given "
178                 "criteria found: %s.",
179                 [v["id"] for v in vpcs],
180             )
181             return None
182         vpc = vpcs[0]
183         if VPCName:
184             VPCId = vpc["id"]
185         if not VPCRegion:
186             VPCRegion = vpc["region"]
187         args.update({"VPC": {"VPCId": VPCId, "VPCRegion": VPCRegion}})
188     else:
189         if any((VPCId, VPCName, VPCRegion)):
190             log.info(
191                 "Options VPCId, VPCName, and VPCRegion are ignored when creating "
192                 "non-private zones."
193             )
194     tries = 10
195     while tries:
196         try:
197             r = conn.create_hosted_zone(**args)
198             r.pop("ResponseMetadata", None)
199             if _wait_for_sync(r["ChangeInfo"]["Id"], conn):
200                 return [r]
201             return []
202         except ClientError as e:
203             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
204                 log.debug("Throttled by AWS API.")
205                 time.sleep(3)
206                 tries -= 1
207                 continue
208             log.error("Failed to create hosted zone %s: %s", Name, e)
209             return []
210     return []
211 def update_hosted_zone_comment(
212     Id=None,
213     Name=None,
214     Comment=None,
215     PrivateZone=None,
216     region=None,
217     key=None,
218     keyid=None,
219     profile=None,
220 ):
221     if not _exactly_one((Id, Name)):
222         raise SaltInvocationError("Exactly one of either Id or Name is required.")
223     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
224     if Name:
225         args = {
226             "Name": Name,
227             "PrivateZone": PrivateZone,
228             "region": region,
229             "key": key,
230             "keyid": keyid,
231             "profile": profile,
232         }
233         zone = find_hosted_zone(**args)
234         if not zone:
235             log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
236             return []
237         Id = zone[0]["HostedZone"]["Id"]
238     tries = 10
239     while tries:
240         try:
241             r = conn.update_hosted_zone_comment(Id=Id, Comment=Comment)
242             r.pop("ResponseMetadata", None)
243             return [r]
244         except ClientError as e:
245             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
246                 log.debug("Throttled by AWS API.")
247                 time.sleep(3)
248 <a name="6"></a>                tries -= 1
249                 continue
250             log.error("Failed to update comment on hosted zone %s: %s", Name or Id, e)
251     r<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn []
252 def associate_vpc_with_hosted_zone(
253     HostedZoneId=None,
254     Name=None,
255     VPCId=None,
256     VPCName=None,
257     VPCRegion=None,
258     Comment=None,
259     region=None,
260     key=None,
261     keyid=None,
262     profile=</b></font>None,
263 ):
264     if not _exactly_one((HostedZoneId, Name)):
265         raise SaltInvocationError(
266             "Exactly one of either HostedZoneId or Name is required."
267         )
268     if not _exactly_one((VPCId, VPCName)):
269         raise SaltInvocationError("Exactly one of either VPCId or VPCName is required.")
270     if Name:
271         args = {
272             "Name": Name,
273             "PrivateZone": True,
274             "region": region,
275             "key": key,
276             "keyid": keyid,
277             "profile": profile,
278         }
279         zone = find_hosted_zone(**args)
280         if not zone:
281             log.error(
282                 "Couldn't resolve domain name %s to a private hosted zone ID.", Name
283             )
284             return False
285         HostedZoneId = zone[0]["HostedZone"]["Id"]
286     vpcs = __salt__["boto_vpc.describe_vpcs"](
287         vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
288     ).get("vpcs", [])
289     if VPCRegion and vpcs:
290         vpcs = [v for v in vpcs if v["region"] == VPCRegion]
291     if not vpcs:
292         log.error("No VPC matching the given criteria found.")
293         return False
294     if len(vpcs) &gt; 1:
295         log.error(
296             "Multiple VPCs matching the given criteria found: %s.",
297             ", ".join([v["id"] for v in vpcs]),
298         )
299         return False
300     vpc = vpcs[0]
301     if VPCName:
302         VPCId = vpc["id"]
303     if not VPCRegion:
304 <a name="5"></a>        VPCRegion = vpc["region"]
305     args = {
306         "HostedZoneId": HostedZoneId,
307         "VPC": {<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"VPCId": VPCId, "VPCRegion": VPCRegion},
308     }
309     args.update({"Comment": Comment}) if Comment is not None else None
310     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
311     tries = 10
312     while</b></font> tries:
313         try:
314             r = conn.associate_vpc_with_hosted_zone(**args)
315             return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
316         except ClientError as e:
317             if e.response.get("Error", {}).get("Code") == "ConflictingDomainExists":
318                 log.debug("VPC Association already exists.")
319                 return True
320             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
321                 log.debug("Throttled by AWS API.")
322                 time.sleep(3)
323                 tries -= 1
324                 continue
325             log.error(
326                 "Failed to associate VPC %s with hosted zone %s: %s",
327                 VPCName or VPCId,
328                 Name or HostedZoneId,
329                 e,
330             )
331     return False
332 def disassociate_vpc_from_hosted_zone(
333     HostedZoneId=None,
334     Name=None,
335     VPCId=None,
336     VPCName=None,
337     VPCRegion=None,
338     Comment=None,
339     region=None,
340     key=None,
341     keyid=None,
342     profile=None,
343 ):
344     if not _exactly_one((HostedZoneId, Name)):
345         raise SaltInvocationError(
346             "Exactly one of either HostedZoneId or Name is required."
347         )
348     if not _exactly_one((VPCId, VPCName)):
349         raise SaltInvocationError("Exactly one of either VPCId or VPCName is required.")
350     if Name:
351         args = {
352             "Name": Name,
353             "PrivateZone": True,
354             "region": region,
355             "key": key,
356             "keyid": keyid,
357             "profile": profile,
358         }
359         zone = find_hosted_zone(**args)
360         if not zone:
361             log.error(
362                 "Couldn't resolve domain name %s to a private hosted zone ID.", Name
363             )
364             return False
365         HostedZoneId = zone[0]["HostedZone"]["Id"]
366     vpcs = __salt__["boto_vpc.describe_vpcs"](
367         vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
368     ).get("vpcs", [])
369     if VPCRegion and vpcs:
370         vpcs = [v for v in vpcs if v["region"] == VPCRegion]
371     if not vpcs:
372         log.error("No VPC matching the given criteria found.")
373         return False
374     if len(vpcs) &gt; 1:
375         log.error(
376             "Multiple VPCs matching the given criteria found: %s.",
377             ", ".join([v["id"] for v in vpcs]),
378         )
379         return False
380     vpc = vpcs[0]
381     if VPCName:
382         VPCId = vpc["id"]
383     if not VPCRegion:
384 <a name="4"></a>        VPCRegion = vpc["region"]
385     args = {
386         "HostedZoneId": HostedZoneId,
387         "VPC": {<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"VPCId": VPCId, "VPCRegion": VPCRegion},
388     }
389     args.update({"Comment": Comment}) if Comment is not None else None
390     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
391     tries = 10
392     while</b></font> tries:
393         try:
394             r = conn.disassociate_vpc_from_hosted_zone(**args)
395             return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
396         except ClientError as e:
397             if e.response.get("Error", {}).get("Code") == "VPCAssociationNotFound":
398                 log.debug("No VPC Association exists.")
399                 return True
400             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
401                 log.debug("Throttled by AWS API.")
402                 time.sleep(3)
403                 tries -= 1
404                 continue
405             log.error(
406                 "Failed to associate VPC %s with hosted zone %s: %s",
407                 VPCName or VPCId,
408                 Name or HostedZoneId,
409                 e,
410             )
411     return False
412 def delete_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
413     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
414     try:
415         r = conn.delete_hosted_zone(Id=Id)
416         return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
417     except ClientError as e:
418         log.error("Failed to delete hosted zone %s: %s", Id, e)
419     return False
420 def delete_hosted_zone_by_domain(
421     Name, PrivateZone=None, region=None, key=None, keyid=None, profile=None
422 ):
423     args = {
424         "Name": Name,
425         "PrivateZone": PrivateZone,
426         "region": region,
427         "key": key,
428         "keyid": keyid,
429         "profile": profile,
430     }
431     zone = find_hosted_zone(**args)
432     if not zone:
433         log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
434         return False
435     Id = zone[0]["HostedZone"]["Id"]
436     return delete_hosted_zone(
437         Id=Id, region=region, key=key, keyid=keyid, profile=profile
438     )
439 def _aws_encode(x):
440     ret = None
441     try:
442         x.encode("ascii")
443         ret = re.sub(rb"\\x([a-f0-8]{2})", _hexReplace, x.encode("unicode_escape"))
444     except UnicodeEncodeError:
445         ret = x.encode("idna")
446     except Exception as e:  # pylint: disable=broad-except
447         log.error(
448             "Couldn't encode %s using either 'unicode_escape' or 'idna' codecs", x
449         )
450         raise CommandExecutionError(e)
451     log.debug("AWS-encoded result for %s: %s", x, ret)
452     return ret.decode("utf-8")
453 def _aws_encode_changebatch(o):
454     change_idx = 0
455     while change_idx &lt; len(o["Changes"]):
456         o["Changes"][change_idx]["ResourceRecordSet"]["Name"] = _aws_encode(
457             o["Changes"][change_idx]["ResourceRecordSet"]["Name"]
458         )
459         if "ResourceRecords" in o["Changes"][change_idx]["ResourceRecordSet"]:
460             rr_idx = 0
461             while rr_idx &lt; len(
462                 o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"]
463             ):
464                 o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"][
465                     rr_idx
466                 ]["Value"] = _aws_encode(
467                     o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"][
468                         rr_idx
469                     ]["Value"]
470                 )
471                 rr_idx += 1
472         if "AliasTarget" in o["Changes"][change_idx]["ResourceRecordSet"]:
473             o["Changes"][change_idx]["ResourceRecordSet"]["AliasTarget"][
474                 "DNSName"
475             ] = _aws_encode(
476                 o["Changes"][change_idx]["ResourceRecordSet"]["AliasTarget"]["DNSName"]
477             )
478         change_idx += 1
479     return o
480 def _aws_decode(x):
481     if "\\" in x:
482         return x.decode("unicode_escape")
483     if type(x) == bytes:
484         return x.decode("idna")
485     return x
486 def _hexReplace(x):
487     c = int(x.group(1), 16)
488     return "\\" + str(oct(c))[1:]
489 def get_resource_records(
490     HostedZoneId=None,
491     Name=None,
492     StartRecordName=None,
493     StartRecordType=None,
494     PrivateZone=None,
495     region=None,
496     key=None,
497     keyid=None,
498     profile=None,
499 ):
500     if not _exactly_one((HostedZoneId, Name)):
501         raise SaltInvocationError(
502             "Exactly one of either HostedZoneId or Name must be provided."
503         )
504     if Name:
505         args = {
506             "Name": Name,
507             "region": region,
508             "key": key,
509             "keyid": keyid,
510             "profile": profile,
511         }
512         args.update({"PrivateZone": PrivateZone}) if PrivateZone is not None else None
513         zone = find_hosted_zone(**args)
514         if not zone:
515             log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
516             return []
517         HostedZoneId = zone[0]["HostedZone"]["Id"]
518     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
519     ret = []
520     next_rr_name = StartRecordName
521     next_rr_type = StartRecordType
522     next_rr_id = None
523     done = False
524     while True:
525         if done:
526             return ret
527         args = {"HostedZoneId": HostedZoneId}
528         args.update(
529             {"StartRecordName": _aws_encode(next_rr_name)}
530         ) if next_rr_name else None
531         args.update(
532             {"StartRecordType": next_rr_type}
533         ) if next_rr_name and next_rr_type else None
534         args.update({"StartRecordIdentifier": next_rr_id}) if next_rr_id else None
535         try:
536             r = conn.list_resource_record_sets(**args)
537             rrs = r["ResourceRecordSets"]
538             next_rr_name = r.get("NextRecordName")
539             next_rr_type = r.get("NextRecordType")
540             next_rr_id = r.get("NextRecordIdentifier")
541             for rr in rrs:
542                 rr["Name"] = _aws_decode(rr["Name"])
543                 if "ResourceRecords" in rr:
544                     x = 0
545                     while x &lt; len(rr["ResourceRecords"]):
546                         if "Value" in rr["ResourceRecords"][x]:
547                             rr["ResourceRecords"][x]["Value"] = _aws_decode(
548                                 rr["ResourceRecords"][x]["Value"]
549                             )
550                         x += 1
551                 if "AliasTarget" in rr:
552                     rr["AliasTarget"]["DNSName"] = _aws_decode(
553                         rr["AliasTarget"]["DNSName"]
554                     )
555                 if StartRecordName and rr["Name"] != StartRecordName:
556                     done = True
557                     break
558                 if StartRecordType and rr["Type"] != StartRecordType:
559                     if StartRecordName:
560                         done = True
561                         break
562                     else:
563                         continue
564                 ret += [rr]
565             if not next_rr_name:
566                 done = True
567         except ClientError as e:
568             if e.response.get("Error", {}).get("Code") == "Throttling":
569                 log.debug("Throttled by AWS API.")
570                 time.sleep(3)
571                 continue
572             raise
573 def change_resource_record_sets(
574     HostedZoneId=None,
575     Name=None,
576     PrivateZone=None,
577     ChangeBatch=None,
578     region=None,
579     key=None,
580     keyid=None,
581     profile=None,
582 ):
583     if not _exactly_one((HostedZoneId, Name)):
584         raise SaltInvocationError(
585             "Exactly one of either HostZoneId or Name must be provided."
586         )
587     if Name:
588         args = {
589             "Name": Name,
590             "region": region,
591             "key": key,
592             "keyid": keyid,
593             "profile": profile,
594         }
595         args.update({"PrivateZone": PrivateZone}) if PrivateZone is not None else None
596         zone = find_hosted_zone(**args)
597         if not zone:
598             log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
599             return []
600         HostedZoneId = zone[0]["HostedZone"]["Id"]
601     args = {
602         "HostedZoneId": HostedZoneId,
603         "ChangeBatch": _aws_encode_changebatch(ChangeBatch),
604     }
605     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
606     tries = 20  # A bit more headroom
607     while tries:
608         try:
609             r = conn.change_resource_record_sets(**args)
610             return _wait_for_sync(
611                 r["ChangeInfo"]["Id"], conn, 30
612             )  # And a little extra time here
613         except ClientError as e:
614             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
615                 log.debug("Throttled by AWS API.")
616                 time.sleep(3)
617                 tries -= 1
618                 continue
619             log.error(
620                 "Failed to apply requested changes to the hosted zone %s: %s",
621                 (Name or HostedZoneId),
622                 str(e),
623             )
624             raise e
625     return False
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_s3_bucket_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.utils.compat
3 import salt.utils.json
4 import salt.utils.versions
5 from salt.exceptions import SaltInvocationError
6 log = logging.getLogger(__name__)
7 <a name="0"></a>try:
8     import boto
9     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import boto3
10     from botocore.exceptions import ClientError
11     logging.getLogger("boto3").setLevel(logging.CRITICAL)
12     HAS_BOTO = True
13 except ImportError:
14     HAS_BOTO = False
15 def __virtual__():
16     return salt.utils.versions.check_boto_reqs(</b></font>boto3_ver=<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"1.2.1")
17 def __init__(opts):
18     if HAS_BOTO:
19         __utils__["boto3.assign_funcs"](__name__, "s3")
20 def exists(Bucket, region=None, key=None, keyid=None, profile=</b></font>None):
21     try:
22         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
23         buckets = conn.head_bucket(Bucket=Bucket)
24         return {"exists": True}
25     except ClientError as e:
26 <a name="1"></a>        if e.response.get("Error", {}).get("Code") == "404":
27             return {"exists": False}
28         err = __utils__["boto3.get_error"](e)
29         return {<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"error": err}
30 def create(
31     Bucket,
32     ACL=None,
33     LocationConstraint=None,
34     GrantFullControl=None,
35     GrantRead=None,
36     GrantReadACP=None,
37     GrantWrite=None,
38     GrantWriteACP=None,
39     region=None,
40     key=None,
41     keyid=None,
42     profile=</b></font>None,
43 ):
44     try:
45         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
46         kwargs = {}
47         for arg in (
48             "ACL",
49             "GrantFullControl",
50             "GrantRead",
51             "GrantReadACP",
52             "GrantWrite",
53             "GrantWriteACP",
54         ):
55             if locals()[arg] is not None:
56                 kwargs[arg] = str(locals()[arg])
57         if LocationConstraint:
58             kwargs["CreateBucketConfiguration"] = {
59                 "LocationConstraint": LocationConstraint
60             }
61         location = conn.create_bucket(Bucket=Bucket, **kwargs)
62         conn.get_waiter("bucket_exists").wait(Bucket=Bucket)
63         if location:
64             log.info(
65                 "The newly created bucket name is located at %s", location["Location"]
66             )
67             return {"created": True, "name": Bucket, "Location": location["Location"]}
68         else:
69             log.warning("Bucket was not created")
70             return {"created": False}
71     except ClientError as e:
72         return {"created": False, "error": __utils__["boto3.get_error"](e)}
73 def delete(
74     Bucket,
75     MFA=None,
76     RequestPayer=None,
77     Force=False,
78     region=None,
79     key=None,
80     keyid=None,
81     profile=None,
82 ):
83     try:
84         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
85         if Force:
86             empty(
87                 Bucket,
88                 MFA=MFA,
89                 RequestPayer=RequestPayer,
90                 region=region,
91                 key=key,
92                 keyid=keyid,
93                 profile=profile,
94             )
95         conn.delete_bucket(Bucket=Bucket)
96         return {"deleted": True}
97     except ClientError as e:
98         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
99 def delete_objects(
100     Bucket,
101     Delete,
102     MFA=None,
103     RequestPayer=None,
104     region=None,
105     key=None,
106     keyid=None,
107     profile=None,
108 ):
109     if isinstance(Delete, str):
110         Delete = salt.utils.json.loads(Delete)
111     if not isinstance(Delete, dict):
112         raise SaltInvocationError("Malformed Delete request.")
113     if "Objects" not in Delete:
114         raise SaltInvocationError("Malformed Delete request.")
115     failed = []
116     objs = Delete["Objects"]
117     for i in range(0, len(objs), 1000):
118         chunk = objs[i : i + 1000]
119         subset = {"Objects": chunk, "Quiet": True}
120         try:
121             args = {"Bucket": Bucket}
122             args.update({"MFA": MFA}) if MFA else None
123             args.update({"RequestPayer": RequestPayer}) if RequestPayer else None
124             args.update({"Delete": subset})
125             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
126             ret = conn.delete_objects(**args)
127             failed += ret.get("Errors", [])
128         except ClientError as e:
129             return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
130     if failed:
131         return {"deleted": False, "failed": failed}
132     else:
133         return {"deleted": True}
134 def describe(Bucket, region=None, key=None, keyid=None, profile=None):
135     try:
136         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
137         result = {}
138         conn_dict = {
139             "ACL": conn.get_bucket_acl,
140             "CORS": conn.get_bucket_cors,
141             "LifecycleConfiguration": conn.get_bucket_lifecycle_configuration,
142             "Location": conn.get_bucket_location,
143             "Logging": conn.get_bucket_logging,
144             "NotificationConfiguration": conn.get_bucket_notification_configuration,
145             "Policy": conn.get_bucket_policy,
146             "Replication": conn.get_bucket_replication,
147             "RequestPayment": conn.get_bucket_request_payment,
148             "Versioning": conn.get_bucket_versioning,
149             "Website": conn.get_bucket_website,
150         }
151         for key, query in conn_dict.items():
152             try:
153                 data = query(Bucket=Bucket)
154             except ClientError as e:
155                 if e.response.get("Error", {}).get("Code") in (
156                     "NoSuchLifecycleConfiguration",
157                     "NoSuchCORSConfiguration",
158                     "NoSuchBucketPolicy",
159                     "NoSuchWebsiteConfiguration",
160                     "ReplicationConfigurationNotFoundError",
161                     "NoSuchTagSet",
162                 ):
163                     continue
164                 raise
165             if "ResponseMetadata" in data:
166                 del data["ResponseMetadata"]
167             result[key] = data
168         tags = {}
169         try:
170             data = conn.get_bucket_tagging(Bucket=Bucket)
171             for tagdef in data.get("TagSet"):
172                 tags[tagdef.get("Key")] = tagdef.get("Value")
173         except ClientError as e:
174             if not e.response.get("Error", {}).get("Code") == "NoSuchTagSet":
175                 raise
176         if tags:
177             result["Tagging"] = tags
178         return {"bucket": result}
179     except ClientError as e:
180         err = __utils__["boto3.get_error"](e)
181         if e.response.get("Error", {}).get("Code") == "NoSuchBucket":
182             return {"bucket": None}
183         return {"error": __utils__["boto3.get_error"](e)}
184 <a name="3"></a>
185 def empty(
186     Bucket, MFA=None, RequestPayer<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, region=None, key=None, keyid=None, profile=None
187 ):
188     stuff = list_object_versions(
189         Bucket, region=region, key=key, keyid=keyid, profile=profile
190     )
191     Delete = {}
192     Delete[</b></font>"Objects"] = [
193         {"Key": v["Key"], "VersionId": v["VersionId"]}
194         for v in stuff.get("Versions", [])
195     ]
196     Delete["Objects"] += [
197         {"Key": v["Key"], "VersionId": v["VersionId"]}
198         for v in stuff.get("DeleteMarkers", [])
199     ]
200     if Delete["Objects"]:
201         ret = delete_objects(
202             Bucket,
203             Delete,
204             MFA=MFA,
205             RequestPayer=RequestPayer,
206             region=region,
207             key=key,
208             keyid=keyid,
209             profile=profile,
210         )
211         failed = ret.get("failed", [])
212         if failed:
213             return {"deleted": False, "failed": ret[failed]}
214     return {"deleted": True}
215 def list(region=None, key=None, keyid=None, profile=None):
216     try:
217         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
218         buckets = conn.list_buckets()
219         if not bool(buckets.get("Buckets")):
220             log.warning("No buckets found")
221         if "ResponseMetadata" in buckets:
222             del buckets["ResponseMetadata"]
223         return buckets
224     except ClientError as e:
225         return {"error": __utils__["boto3.get_error"](e)}
226 def list_object_versions(
227     Bucket,
228     Delimiter=None,
229     EncodingType=None,
230     Prefix=None,
231     region=None,
232     key=None,
233     keyid=None,
234     profile=None,
235 ):
236     try:
237         Versions = []
238 <a name="5"></a>        DeleteMarkers = []
239         args = {"Bucket": Bucket}
240         args.update({"Delimiter": Delimiter}) if Delimiter else None
241         args.update({<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"EncodingType": EncodingType}) if Delimiter else None
242         args.update({"Prefix": Prefix}) if Prefix else None
243         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
244         IsTruncated = True
245         while</b></font> IsTruncated:
246             ret = conn.list_object_versions(**args)
247             IsTruncated = ret.get("IsTruncated", False)
248             if IsTruncated in ("True", "true", True):
249                 args["KeyMarker"] = ret["NextKeyMarker"]
250                 args["VersionIdMarker"] = ret["NextVersionIdMarker"]
251             Versions += ret.get("Versions", [])
252             DeleteMarkers += ret.get("DeleteMarkers", [])
253         return {"Versions": Versions, "DeleteMarkers": DeleteMarkers}
254     except ClientError as e:
255         return {"error": __utils__["boto3.get_error"](e)}
256 def list_objects(
257     Bucket,
258     Delimiter=None,
259     EncodingType=None,
260     Prefix=None,
261     FetchOwner=False,
262     StartAfter=None,
263     region=None,
264     key=None,
265     keyid=None,
266     profile=None,
267 ):
268     try:
269         Contents = []
270 <a name="4"></a>        args = {"Bucket": Bucket, "FetchOwner": FetchOwner}
271         args.update({"Delimiter": Delimiter}) if Delimiter else None
272         args.update({"EncodingType": EncodingType}) if Delimiter else None
273         args.update({<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"Prefix": Prefix}) if Prefix else None
274         args.update({"StartAfter": StartAfter}) if StartAfter else None
275         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
276         IsTruncated = True
277         while</b></font> IsTruncated:
278             ret = conn.list_objects_v2(**args)
279             IsTruncated = ret.get("IsTruncated", False)
280             if IsTruncated in ("True", "true", True):
281                 args["ContinuationToken"] = ret["NextContinuationToken"]
282 <a name="6"></a>            Contents += ret.get("Contents", [])
283         return {"Contents": Contents}
284     except ClientError as e:
285         return {"error": __utils__["boto3.get_error"](<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>e)}
286 def put_acl(
287     Bucket,
288     ACL=None,
289     AccessControlPolicy=None,
290     GrantFullControl=None,
291     GrantRead=None,
292     GrantReadACP=None,
293     GrantWrite=None,
294     GrantWriteACP=None,
295     region=None,
296     key=None,
297     keyid=</b></font>None,
298     profile=None,
299 ):
300     try:
301         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
302         kwargs = {}
303         if AccessControlPolicy is not None:
304             if isinstance(AccessControlPolicy, str):
305                 AccessControlPolicy = salt.utils.json.loads(AccessControlPolicy)
306             kwargs["AccessControlPolicy"] = AccessControlPolicy
307         for arg in (
308             "ACL",
309             "GrantFullControl",
310             "GrantRead",
311             "GrantReadACP",
312             "GrantWrite",
313             "GrantWriteACP",
314         ):
315             if locals()[arg] is not None:
316                 kwargs[arg] = str(locals()[arg])
317         conn.put_bucket_acl(Bucket=Bucket, **kwargs)
318         return {"updated": True, "name": Bucket}
319     except ClientError as e:
320         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
321 def put_cors(Bucket, CORSRules, region=None, key=None, keyid=None, profile=None):
322     try:
323         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
324         if CORSRules is not None and isinstance(CORSRules, str):
325             CORSRules = salt.utils.json.loads(CORSRules)
326         conn.put_bucket_cors(Bucket=Bucket, CORSConfiguration={"CORSRules": CORSRules})
327         return {"updated": True, "name": Bucket}
328     except ClientError as e:
329         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
330 def put_lifecycle_configuration(
331     Bucket, Rules, region=None, key=None, keyid=None, profile=None
332 ):
333     try:
334         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
335         if Rules is not None and isinstance(Rules, str):
336             Rules = salt.utils.json.loads(Rules)
337         conn.put_bucket_lifecycle_configuration(
338             Bucket=Bucket, LifecycleConfiguration={"Rules": Rules}
339         )
340         return {"updated": True, "name": Bucket}
341     except ClientError as e:
342         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
343 def put_logging(
344     Bucket,
345     TargetBucket=None,
346     TargetPrefix=None,
347     TargetGrants=None,
348     region=None,
349     key=None,
350     keyid=None,
351     profile=None,
352 ):
353     try:
354         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
355         logstate = {}
356         targets = {
357             "TargetBucket": TargetBucket,
358             "TargetGrants": TargetGrants,
359             "TargetPrefix": TargetPrefix,
360         }
361         for key, val in targets.items():
362             if val is not None:
363                 logstate[key] = val
364         if logstate:
365             logstatus = {"LoggingEnabled": logstate}
366         else:
367             logstatus = {}
368         if TargetGrants is not None and isinstance(TargetGrants, str):
369             TargetGrants = salt.utils.json.loads(TargetGrants)
370         conn.put_bucket_logging(Bucket=Bucket, BucketLoggingStatus=logstatus)
371         return {"updated": True, "name": Bucket}
372     except ClientError as e:
373         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
374 def put_notification_configuration(
375     Bucket,
376     TopicConfigurations=None,
377     QueueConfigurations=None,
378     LambdaFunctionConfigurations=None,
379     region=None,
380     key=None,
381     keyid=None,
382     profile=None,
383 ):
384     try:
385         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
386         if TopicConfigurations is None:
387             TopicConfigurations = []
388         elif isinstance(TopicConfigurations, str):
389             TopicConfigurations = salt.utils.json.loads(TopicConfigurations)
390         if QueueConfigurations is None:
391             QueueConfigurations = []
392         elif isinstance(QueueConfigurations, str):
393             QueueConfigurations = salt.utils.json.loads(QueueConfigurations)
394         if LambdaFunctionConfigurations is None:
395             LambdaFunctionConfigurations = []
396         elif isinstance(LambdaFunctionConfigurations, str):
397             LambdaFunctionConfigurations = salt.utils.json.loads(
398                 LambdaFunctionConfigurations
399             )
400         conn.put_bucket_notification_configuration(
401             Bucket=Bucket,
402             NotificationConfiguration={
403                 "TopicConfigurations": TopicConfigurations,
404                 "QueueConfigurations": QueueConfigurations,
405                 "LambdaFunctionConfigurations": LambdaFunctionConfigurations,
406             },
407         )
408         return {"updated": True, "name": Bucket}
409     except ClientError as e:
410         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
411 def put_policy(Bucket, Policy, region=None, key=None, keyid=None, profile=None):
412     try:
413         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
414         if Policy is None:
415             Policy = "{}"
416         elif not isinstance(Policy, str):
417             Policy = salt.utils.json.dumps(Policy)
418         conn.put_bucket_policy(Bucket=Bucket, Policy=Policy)
419         return {"updated": True, "name": Bucket}
420     except ClientError as e:
421         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
422 def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
423     if name.startswith("arn:aws:iam:"):
424         return name
425     account_id = __salt__["boto_iam.get_account_id"](
426         region=region, key=key, keyid=keyid, profile=profile
427     )
428     if profile and "region" in profile:
429         region = profile["region"]
430     if region is None:
431         region = "us-east-1"
432     return "arn:aws:iam::{}:role/{}".format(account_id, name)
433 def put_replication(
434     Bucket, Role, Rules, region=None, key=None, keyid=None, profile=None
435 ):
436         conn <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
437         Role = _get_role_arn(
438             name=Role, region=region, key=key, keyid=keyid, profile=</b></font>profile
439         )
440         if Rules is None:
441             Rules = []
442         elif isinstance(Rules, str):
443             Rules = salt.utils.json.loads(Rules)
444         conn.put_bucket_replication(
445             Bucket=Bucket, ReplicationConfiguration={"Role": Role, "Rules": Rules}
446         )
447         return {"updated": True, "name": Bucket}
448     except ClientError as e:
449         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
450 def put_request_payment(Bucket, Payer, region=None, key=None, keyid=None, profile=None):
451     try:
452         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
453         conn.put_bucket_request_payment(
454             Bucket=Bucket, RequestPaymentConfiguration={"Payer": Payer}
455         )
456         return {"updated": True, "name": Bucket}
457     except ClientError as e:
458         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
459 def put_tagging(Bucket, region=None, key=None, keyid=None, profile=None, **kwargs):
460     try:
461         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
462         tagslist = []
463         for k, v in kwargs.items():
464             if str(k).startswith("__"):
465                 continue
466             tagslist.append({"Key": str(k), "Value": str(v)})
467         conn.put_bucket_tagging(Bucket=Bucket, Tagging={"TagSet": tagslist})
468         return {"updated": True, "name": Bucket}
469     except ClientError as e:
470         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
471 def put_versioning(
472     Bucket,
473     Status,
474     MFADelete=None,
475     MFA=None,
476     region=None,
477     key=None,
478     keyid=None,
479     profile=None,
480 ):
481     try:
482         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
483         VersioningConfiguration = {"Status": Status}
484         if MFADelete is not None:
485             VersioningConfiguration["MFADelete"] = MFADelete
486         kwargs = {}
487         if MFA is not None:
488             kwargs["MFA"] = MFA
489         conn.put_bucket_versioning(
490             Bucket=Bucket, VersioningConfiguration=VersioningConfiguration, **kwargs
491         )
492         return {"updated": True, "name": Bucket}
493     except ClientError as e:
494         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
495 def put_website(
496     Bucket,
497     ErrorDocument=None,
498     IndexDocument=None,
499     RedirectAllRequestsTo=None,
500     RoutingRules=None,
501     region=None,
502     key=None,
503     keyid=None,
504     profile=None,
505 ):
506     try:
507         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
508         WebsiteConfiguration = {}
509         for key in (
510             "ErrorDocument",
511             "IndexDocument",
512             "RedirectAllRequestsTo",
513             "RoutingRules",
514         ):
515             val = locals()[key]
516             if val is not None:
517                 if isinstance(val, str):
518                     WebsiteConfiguration[key] = salt.utils.json.loads(val)
519                 else:
520                     WebsiteConfiguration[key] = val
521         conn.put_bucket_website(
522             Bucket=Bucket, WebsiteConfiguration=WebsiteConfiguration
523         )
524         return {"updated": True, "name": Bucket}
525     except ClientError as e:
526         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
527 def delete_cors(Bucket, region=None, key=None, keyid=None, profile=None):
528     try:
529         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
530         conn.delete_bucket_cors(Bucket=Bucket)
531         return {"deleted": True, "name": Bucket}
532     except ClientError as e:
533         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
534 def delete_lifecycle_configuration(
535     Bucket, region=None, key=None, keyid=None, profile=None
536 ):
537     try:
538         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
539         conn.delete_bucket_lifecycle(Bucket=Bucket)
540         return {"deleted": True, "name": Bucket}
541     except ClientError as e:
542         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
543 def delete_policy(Bucket, region=None, key=None, keyid=None, profile=None):
544     try:
545         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
546         conn.delete_bucket_policy(Bucket=Bucket)
547         return {"deleted": True, "name": Bucket}
548     except ClientError as e:
549         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
550 def delete_replication(Bucket, region=None, key=None, keyid=None, profile=None):
551     try:
552         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
553         conn.delete_bucket_replication(Bucket=Bucket)
554         return {"deleted": True, "name": Bucket}
555     except ClientError as e:
556         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
557 def delete_tagging(Bucket, region=None, key=None, keyid=None, profile=None):
558     try:
559         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
560         conn.delete_bucket_tagging(Bucket=Bucket)
561         return {"deleted": True, "name": Bucket}
562     except ClientError as e:
563         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
564 def delete_website(Bucket, region=None, key=None, keyid=None, profile=None):
565     try:
566         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
567         conn.delete_bucket_website(Bucket=Bucket)
568         return {"deleted": True, "name": Bucket}
569     except ClientError as e:
570         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
