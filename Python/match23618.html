<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto3_route53_1.py &amp; boto_s3_bucket_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto3_route53_1.py &amp; boto_s3_bucket_1.py
      </h3>
<h1 align="center">
        9.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto3_route53_1.py (9.731233%)<th>boto_s3_bucket_1.py (8.84583%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-79)<td><a href="#" name="0">(68-88)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(302-317)<td><a href="#" name="1">(119-134)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(383-389)<td><a href="#" name="2">(797-799)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(272-301)<td><a href="#" name="3">(349-369)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(758-764)<td><a href="#" name="4">(497-501)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(632-638)<td><a href="#" name="5">(450-454)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(525-538)<td><a href="#" name="6">(509-523)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(79-89)<td><a href="#" name="7">(88-96)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_route53_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import re
import time
import salt.utils.compat
import salt.utils.versions
from salt.exceptions import CommandExecutionError, SaltInvocationError
log = logging.getLogger(__name__)
<a name="0"></a>
try:
    <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import boto3
    from botocore.exceptions import ClientError
    logging.getLogger("boto3").setLevel(logging.CRITICAL)
    HAS_BOTO3 = True
except ImportError:
    HAS_BOTO3 = False
def __virtual__():
    return salt.utils.versions.check_boto_reqs(</b></font><font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>)
def __init__(opts):
    if HAS_BOTO3:
        __utils__["boto3.assign_funcs"](__name__, "route53")
def _collect_results(func, item, args, marker="Marker", nextmarker="NextMarker"):
    ret = []
    Marker =</b></font> args.get(marker, "")
    tries = 10
    while Marker is not None:
        try:
            r = func(**args)
        except ClientError as e:
            if tries and e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
                time.sleep(3)
                tries -= 1
                continue
            log.error("Could not collect results from %s(): %s", func, e)
            return []
        i = r.get(item, []) if item else r
        i.pop("ResponseMetadata", None) if isinstance(i, dict) else None
        ret += i if isinstance(i, list) else [i]
        Marker = r.get(nextmarker)
        args.update({marker: Marker})
    return ret
def _wait_for_sync(change, conn, tries=10, sleep=20):
    for retry in range(1, tries + 1):
        log.info("Getting route53 status (attempt %s)", retry)
        status = "wait"
        try:
            status = conn.get_change(Id=change)["ChangeInfo"]["Status"]
        except ClientError as e:
            if e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
            else:
                raise
        if status == "INSYNC":
            return True
        time.sleep(sleep)
    log.error("Timed out waiting for Route53 INSYNC status.")
    return False
def find_hosted_zone(
    Id=None,
    Name=None,
    PrivateZone=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((Id, Name)):
        raise SaltInvocationError("Exactly one of either Id or Name is required.")
    if PrivateZone is not None and not isinstance(PrivateZone, bool):
        raise SaltInvocationError(
            "If set, PrivateZone must be a bool (e.g. True / False)."
        )
    if Id:
        ret = get_hosted_zone(Id, region=region, key=key, keyid=keyid, profile=profile)
    else:
        ret = get_hosted_zones_by_domain(
            Name, region=region, key=key, keyid=keyid, profile=profile
        )
    if PrivateZone is not None:
        ret = [
            m for m in ret if m["HostedZone"]["Config"]["PrivateZone"] is PrivateZone
        ]
    if len(ret) &gt; 1:
        log.error(
            "Request matched more than one Hosted Zone (%s). Refine your "
            "criteria and try again.",
            [z["HostedZone"]["Id"] for z in ret],
        )
        ret = []
    return ret
def get_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    args = {"Id": Id}
    return _collect_results(conn.get_hosted_zone, None, args)
def get_hosted_zones_by_domain(Name, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    zones = [
        z
        for z in _collect_results(conn.list_hosted_zones, "HostedZones", {})
        if z["Name"] == _aws_encode(Name)
    ]
    ret = []
    for z in zones:
        ret += get_hosted_zone(
            Id=z["Id"], region=region, key=key, keyid=keyid, profile=profile
        )
    return ret
<a name="3"></a>
def list_hosted_zones(
    DelegationSetId<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, region=None, key=None, keyid=None, profile=None
):
    args = {"DelegationSetId"</b></font>: DelegationSetId} if DelegationSetId else {}
    return _collect_results(conn<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.list_hosted_zones, "HostedZones", args)
def create_hosted_zone(
    Name,
    VPCId=None,
    VPCName=None,
    VPCRegion=None,
    CallerReference=None,
    Comment="",
    PrivateZone=False,
    DelegationSetId=None,
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
):
    if not Name.endswith("."):
        raise SaltInvocationError(
<a name="2"></a>            "Domain must be fully-qualified, complete with trailing period."
        )
    Name = _aws_encode(Name)
    conn <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    deets = find_hosted_zone(
        Name=Name,
        PrivateZone=PrivateZone,
        region=region,
        key=key,
        keyid=</b></font>keyid,
        profile=profile,
    )
    if deets:
        log.info(
            "Route 53 hosted zone %s already exists. You may want to pass "
            "e.g. 'PrivateZone=True' or similar...",
            Name,
        )
        return None
    args = {
        "Name": Name,
        "CallerReference": CallerReference,
        "HostedZoneConfig": {"Comment": Comment, "PrivateZone": PrivateZone},
    }
    args.update({"DelegationSetId": DelegationSetId}) if DelegationSetId else None
    if PrivateZone:
        if not _exactly_one((VPCName, VPCId)):
            raise SaltInvocationError(
                "Either VPCName or VPCId is required when creating a private zone."
            )
        vpcs = __salt__["boto_vpc.describe_vpcs"](
            vpc_id=VPCId,
            name=VPCName,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        ).get("vpcs", [])
        if VPCRegion and vpcs:
            vpcs = [v for v in vpcs if v["region"] == VPCRegion]
        if not vpcs:
            log.error(
                "Private zone requested but no VPC matching given criteria found."
            )
            return None
        if len(vpcs) &gt; 1:
            log.error(
                "Private zone requested but multiple VPCs matching given "
                "criteria found: %s.",
                [v["id"] for v in vpcs],
            )
            return None
        vpc = vpcs[0]
        if VPCName:
            VPCId = vpc["id"]
        if not VPCRegion:
            VPCRegion = vpc["region"]
        args.update({"VPC": {"VPCId": VPCId, "VPCRegion": VPCRegion}})
    else:
        if any((VPCId, VPCName, VPCRegion)):
            log.info(
                "Options VPCId, VPCName, and VPCRegion are ignored when creating "
                "non-private zones."
            )
    tries = 10
    while tries:
        try:
            r = conn.create_hosted_zone(**args)
            r.pop("ResponseMetadata", None)
            if _wait_for_sync(r["ChangeInfo"]["Id"], conn):
                return [r]
            return []
        except ClientError as e:
            if tries and e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
                time.sleep(3)
                tries -= 1
                continue
            log.error("Failed to create hosted zone %s: %s", Name, e)
            return []
    return []
def update_hosted_zone_comment(
    Id=None,
    Name=None,
    Comment=None,
    PrivateZone=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((Id, Name)):
        raise SaltInvocationError("Exactly one of either Id or Name is required.")
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    if Name:
        args = {
            "Name": Name,
            "PrivateZone": PrivateZone,
            "region": region,
            "key": key,
            "keyid": keyid,
            "profile": profile,
        }
        zone = find_hosted_zone(**args)
        if not zone:
            log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
            return []
        Id = zone[0]["HostedZone"]["Id"]
    tries = 10
    while tries:
        try:
            r = conn.update_hosted_zone_comment(Id=Id, Comment=Comment)
            r.pop("ResponseMetadata", None)
            return [r]
        except ClientError as e:
            if tries and e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
                time.sleep(3)
<a name="6"></a>                tries -= 1
                continue
            log.error("Failed to update comment on hosted zone %s: %s", Name or Id, e)
    r<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn []
def associate_vpc_with_hosted_zone(
    HostedZoneId=None,
    Name=None,
    VPCId=None,
    VPCName=None,
    VPCRegion=None,
    Comment=None,
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
):
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            "Exactly one of either HostedZoneId or Name is required."
        )
    if not _exactly_one((VPCId, VPCName)):
        raise SaltInvocationError("Exactly one of either VPCId or VPCName is required.")
    if Name:
        args = {
            "Name": Name,
            "PrivateZone": True,
            "region": region,
            "key": key,
            "keyid": keyid,
            "profile": profile,
        }
        zone = find_hosted_zone(**args)
        if not zone:
            log.error(
                "Couldn't resolve domain name %s to a private hosted zone ID.", Name
            )
            return False
        HostedZoneId = zone[0]["HostedZone"]["Id"]
    vpcs = __salt__["boto_vpc.describe_vpcs"](
        vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
    ).get("vpcs", [])
    if VPCRegion and vpcs:
        vpcs = [v for v in vpcs if v["region"] == VPCRegion]
    if not vpcs:
        log.error("No VPC matching the given criteria found.")
        return False
    if len(vpcs) &gt; 1:
        log.error(
            "Multiple VPCs matching the given criteria found: %s.",
            ", ".join([v["id"] for v in vpcs]),
        )
        return False
    vpc = vpcs[0]
    if VPCName:
        VPCId = vpc["id"]
    if not VPCRegion:
<a name="5"></a>        VPCRegion = vpc["region"]
    args = {
        "HostedZoneId": HostedZoneId,
        "VPC": {<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"VPCId": VPCId, "VPCRegion": VPCRegion},
    }
    args.update({"Comment": Comment}) if Comment is not None else None
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    tries = 10
    while</b></font> tries:
        try:
            r = conn.associate_vpc_with_hosted_zone(**args)
            return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
        except ClientError as e:
            if e.response.get("Error", {}).get("Code") == "ConflictingDomainExists":
                log.debug("VPC Association already exists.")
                return True
            if tries and e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
                time.sleep(3)
                tries -= 1
                continue
            log.error(
                "Failed to associate VPC %s with hosted zone %s: %s",
                VPCName or VPCId,
                Name or HostedZoneId,
                e,
            )
    return False
def disassociate_vpc_from_hosted_zone(
    HostedZoneId=None,
    Name=None,
    VPCId=None,
    VPCName=None,
    VPCRegion=None,
    Comment=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            "Exactly one of either HostedZoneId or Name is required."
        )
    if not _exactly_one((VPCId, VPCName)):
        raise SaltInvocationError("Exactly one of either VPCId or VPCName is required.")
    if Name:
        args = {
            "Name": Name,
            "PrivateZone": True,
            "region": region,
            "key": key,
            "keyid": keyid,
            "profile": profile,
        }
        zone = find_hosted_zone(**args)
        if not zone:
            log.error(
                "Couldn't resolve domain name %s to a private hosted zone ID.", Name
            )
            return False
        HostedZoneId = zone[0]["HostedZone"]["Id"]
    vpcs = __salt__["boto_vpc.describe_vpcs"](
        vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
    ).get("vpcs", [])
    if VPCRegion and vpcs:
        vpcs = [v for v in vpcs if v["region"] == VPCRegion]
    if not vpcs:
        log.error("No VPC matching the given criteria found.")
        return False
    if len(vpcs) &gt; 1:
        log.error(
            "Multiple VPCs matching the given criteria found: %s.",
            ", ".join([v["id"] for v in vpcs]),
        )
        return False
    vpc = vpcs[0]
    if VPCName:
        VPCId = vpc["id"]
    if not VPCRegion:
<a name="4"></a>        VPCRegion = vpc["region"]
    args = {
        "HostedZoneId": HostedZoneId,
        "VPC": {<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"VPCId": VPCId, "VPCRegion": VPCRegion},
    }
    args.update({"Comment": Comment}) if Comment is not None else None
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    tries = 10
    while</b></font> tries:
        try:
            r = conn.disassociate_vpc_from_hosted_zone(**args)
            return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
        except ClientError as e:
            if e.response.get("Error", {}).get("Code") == "VPCAssociationNotFound":
                log.debug("No VPC Association exists.")
                return True
            if tries and e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
                time.sleep(3)
                tries -= 1
                continue
            log.error(
                "Failed to associate VPC %s with hosted zone %s: %s",
                VPCName or VPCId,
                Name or HostedZoneId,
                e,
            )
    return False
def delete_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    try:
        r = conn.delete_hosted_zone(Id=Id)
        return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
    except ClientError as e:
        log.error("Failed to delete hosted zone %s: %s", Id, e)
    return False
def delete_hosted_zone_by_domain(
    Name, PrivateZone=None, region=None, key=None, keyid=None, profile=None
):
    args = {
        "Name": Name,
        "PrivateZone": PrivateZone,
        "region": region,
        "key": key,
        "keyid": keyid,
        "profile": profile,
    }
    zone = find_hosted_zone(**args)
    if not zone:
        log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
        return False
    Id = zone[0]["HostedZone"]["Id"]
    return delete_hosted_zone(
        Id=Id, region=region, key=key, keyid=keyid, profile=profile
    )
def _aws_encode(x):
    ret = None
    try:
        x.encode("ascii")
        ret = re.sub(rb"\\x([a-f0-8]{2})", _hexReplace, x.encode("unicode_escape"))
    except UnicodeEncodeError:
        ret = x.encode("idna")
    except Exception as e:  # pylint: disable=broad-except
        log.error(
            "Couldn't encode %s using either 'unicode_escape' or 'idna' codecs", x
        )
        raise CommandExecutionError(e)
    log.debug("AWS-encoded result for %s: %s", x, ret)
    return ret.decode("utf-8")
def _aws_encode_changebatch(o):
    change_idx = 0
    while change_idx &lt; len(o["Changes"]):
        o["Changes"][change_idx]["ResourceRecordSet"]["Name"] = _aws_encode(
            o["Changes"][change_idx]["ResourceRecordSet"]["Name"]
        )
        if "ResourceRecords" in o["Changes"][change_idx]["ResourceRecordSet"]:
            rr_idx = 0
            while rr_idx &lt; len(
                o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"]
            ):
                o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"][
                    rr_idx
                ]["Value"] = _aws_encode(
                    o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"][
                        rr_idx
                    ]["Value"]
                )
                rr_idx += 1
        if "AliasTarget" in o["Changes"][change_idx]["ResourceRecordSet"]:
            o["Changes"][change_idx]["ResourceRecordSet"]["AliasTarget"][
                "DNSName"
            ] = _aws_encode(
                o["Changes"][change_idx]["ResourceRecordSet"]["AliasTarget"]["DNSName"]
            )
        change_idx += 1
    return o
def _aws_decode(x):
    if "\\" in x:
        return x.decode("unicode_escape")
    if type(x) == bytes:
        return x.decode("idna")
    return x
def _hexReplace(x):
    c = int(x.group(1), 16)
    return "\\" + str(oct(c))[1:]
def get_resource_records(
    HostedZoneId=None,
    Name=None,
    StartRecordName=None,
    StartRecordType=None,
    PrivateZone=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            "Exactly one of either HostedZoneId or Name must be provided."
        )
    if Name:
        args = {
            "Name": Name,
            "region": region,
            "key": key,
            "keyid": keyid,
            "profile": profile,
        }
        args.update({"PrivateZone": PrivateZone}) if PrivateZone is not None else None
        zone = find_hosted_zone(**args)
        if not zone:
            log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
            return []
        HostedZoneId = zone[0]["HostedZone"]["Id"]
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    ret = []
    next_rr_name = StartRecordName
    next_rr_type = StartRecordType
    next_rr_id = None
    done = False
    while True:
        if done:
            return ret
        args = {"HostedZoneId": HostedZoneId}
        args.update(
            {"StartRecordName": _aws_encode(next_rr_name)}
        ) if next_rr_name else None
        args.update(
            {"StartRecordType": next_rr_type}
        ) if next_rr_name and next_rr_type else None
        args.update({"StartRecordIdentifier": next_rr_id}) if next_rr_id else None
        try:
            r = conn.list_resource_record_sets(**args)
            rrs = r["ResourceRecordSets"]
            next_rr_name = r.get("NextRecordName")
            next_rr_type = r.get("NextRecordType")
            next_rr_id = r.get("NextRecordIdentifier")
            for rr in rrs:
                rr["Name"] = _aws_decode(rr["Name"])
                if "ResourceRecords" in rr:
                    x = 0
                    while x &lt; len(rr["ResourceRecords"]):
                        if "Value" in rr["ResourceRecords"][x]:
                            rr["ResourceRecords"][x]["Value"] = _aws_decode(
                                rr["ResourceRecords"][x]["Value"]
                            )
                        x += 1
                if "AliasTarget" in rr:
                    rr["AliasTarget"]["DNSName"] = _aws_decode(
                        rr["AliasTarget"]["DNSName"]
                    )
                if StartRecordName and rr["Name"] != StartRecordName:
                    done = True
                    break
                if StartRecordType and rr["Type"] != StartRecordType:
                    if StartRecordName:
                        done = True
                        break
                    else:
                        continue
                ret += [rr]
            if not next_rr_name:
                done = True
        except ClientError as e:
            if e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
                time.sleep(3)
                continue
            raise
def change_resource_record_sets(
    HostedZoneId=None,
    Name=None,
    PrivateZone=None,
    ChangeBatch=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if not _exactly_one((HostedZoneId, Name)):
        raise SaltInvocationError(
            "Exactly one of either HostZoneId or Name must be provided."
        )
    if Name:
        args = {
            "Name": Name,
            "region": region,
            "key": key,
            "keyid": keyid,
            "profile": profile,
        }
        args.update({"PrivateZone": PrivateZone}) if PrivateZone is not None else None
        zone = find_hosted_zone(**args)
        if not zone:
            log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
            return []
        HostedZoneId = zone[0]["HostedZone"]["Id"]
    args = {
        "HostedZoneId": HostedZoneId,
        "ChangeBatch": _aws_encode_changebatch(ChangeBatch),
    }
    conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
    tries = 20  # A bit more headroom
    while tries:
        try:
            r = conn.change_resource_record_sets(**args)
            return _wait_for_sync(
                r["ChangeInfo"]["Id"], conn, 30
            )  # And a little extra time here
        except ClientError as e:
            if tries and e.response.get("Error", {}).get("Code") == "Throttling":
                log.debug("Throttled by AWS API.")
                time.sleep(3)
                tries -= 1
                continue
            log.error(
                "Failed to apply requested changes to the hosted zone %s: %s",
                (Name or HostedZoneId),
                str(e),
            )
            raise e
    return False
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_s3_bucket_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import logging
import salt.utils.compat
import salt.utils.json
import salt.utils.versions
from salt.exceptions import SaltInvocationError
log = logging.getLogger(__name__)
<a name="0"></a>try:
    import boto
    <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import boto3
    from botocore.exceptions import ClientError
    logging.getLogger("boto3").setLevel(logging.CRITICAL)
    HAS_BOTO = True
except ImportError:
    HAS_BOTO = False
def __virtual__():
    return salt.utils.versions.check_boto_reqs(</b></font>boto3_ver=<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"1.2.1")
def __init__(opts):
    if HAS_BOTO:
        __utils__["boto3.assign_funcs"](__name__, "s3")
def exists(Bucket, region=None, key=None, keyid=None, profile=</b></font>None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        buckets = conn.head_bucket(Bucket=Bucket)
        return {"exists": True}
    except ClientError as e:
<a name="1"></a>        if e.response.get("Error", {}).get("Code") == "404":
            return {"exists": False}
        err = __utils__["boto3.get_error"](e)
        return {<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"error": err}
def create(
    Bucket,
    ACL=None,
    LocationConstraint=None,
    GrantFullControl=None,
    GrantRead=None,
    GrantReadACP=None,
    GrantWrite=None,
    GrantWriteACP=None,
    region=None,
    key=None,
    keyid=None,
    profile=</b></font>None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        kwargs = {}
        for arg in (
            "ACL",
            "GrantFullControl",
            "GrantRead",
            "GrantReadACP",
            "GrantWrite",
            "GrantWriteACP",
        ):
            if locals()[arg] is not None:
                kwargs[arg] = str(locals()[arg])
        if LocationConstraint:
            kwargs["CreateBucketConfiguration"] = {
                "LocationConstraint": LocationConstraint
            }
        location = conn.create_bucket(Bucket=Bucket, **kwargs)
        conn.get_waiter("bucket_exists").wait(Bucket=Bucket)
        if location:
            log.info(
                "The newly created bucket name is located at %s", location["Location"]
            )
            return {"created": True, "name": Bucket, "Location": location["Location"]}
        else:
            log.warning("Bucket was not created")
            return {"created": False}
    except ClientError as e:
        return {"created": False, "error": __utils__["boto3.get_error"](e)}
def delete(
    Bucket,
    MFA=None,
    RequestPayer=None,
    Force=False,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if Force:
            empty(
                Bucket,
                MFA=MFA,
                RequestPayer=RequestPayer,
                region=region,
                key=key,
                keyid=keyid,
                profile=profile,
            )
        conn.delete_bucket(Bucket=Bucket)
        return {"deleted": True}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def delete_objects(
    Bucket,
    Delete,
    MFA=None,
    RequestPayer=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    if isinstance(Delete, str):
        Delete = salt.utils.json.loads(Delete)
    if not isinstance(Delete, dict):
        raise SaltInvocationError("Malformed Delete request.")
    if "Objects" not in Delete:
        raise SaltInvocationError("Malformed Delete request.")
    failed = []
    objs = Delete["Objects"]
    for i in range(0, len(objs), 1000):
        chunk = objs[i : i + 1000]
        subset = {"Objects": chunk, "Quiet": True}
        try:
            args = {"Bucket": Bucket}
            args.update({"MFA": MFA}) if MFA else None
            args.update({"RequestPayer": RequestPayer}) if RequestPayer else None
            args.update({"Delete": subset})
            conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
            ret = conn.delete_objects(**args)
            failed += ret.get("Errors", [])
        except ClientError as e:
            return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
    if failed:
        return {"deleted": False, "failed": failed}
    else:
        return {"deleted": True}
def describe(Bucket, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        result = {}
        conn_dict = {
            "ACL": conn.get_bucket_acl,
            "CORS": conn.get_bucket_cors,
            "LifecycleConfiguration": conn.get_bucket_lifecycle_configuration,
            "Location": conn.get_bucket_location,
            "Logging": conn.get_bucket_logging,
            "NotificationConfiguration": conn.get_bucket_notification_configuration,
            "Policy": conn.get_bucket_policy,
            "Replication": conn.get_bucket_replication,
            "RequestPayment": conn.get_bucket_request_payment,
            "Versioning": conn.get_bucket_versioning,
            "Website": conn.get_bucket_website,
        }
        for key, query in conn_dict.items():
            try:
                data = query(Bucket=Bucket)
            except ClientError as e:
                if e.response.get("Error", {}).get("Code") in (
                    "NoSuchLifecycleConfiguration",
                    "NoSuchCORSConfiguration",
                    "NoSuchBucketPolicy",
                    "NoSuchWebsiteConfiguration",
                    "ReplicationConfigurationNotFoundError",
                    "NoSuchTagSet",
                ):
                    continue
                raise
            if "ResponseMetadata" in data:
                del data["ResponseMetadata"]
            result[key] = data
        tags = {}
        try:
            data = conn.get_bucket_tagging(Bucket=Bucket)
            for tagdef in data.get("TagSet"):
                tags[tagdef.get("Key")] = tagdef.get("Value")
        except ClientError as e:
            if not e.response.get("Error", {}).get("Code") == "NoSuchTagSet":
                raise
        if tags:
            result["Tagging"] = tags
        return {"bucket": result}
    except ClientError as e:
        err = __utils__["boto3.get_error"](e)
        if e.response.get("Error", {}).get("Code") == "NoSuchBucket":
            return {"bucket": None}
        return {"error": __utils__["boto3.get_error"](e)}
<a name="3"></a>
def empty(
    Bucket, MFA=None, RequestPayer<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, region=None, key=None, keyid=None, profile=None
):
    stuff = list_object_versions(
        Bucket, region=region, key=key, keyid=keyid, profile=profile
    )
    Delete = {}
    Delete[</b></font>"Objects"] = [
        {"Key": v["Key"], "VersionId": v["VersionId"]}
        for v in stuff.get("Versions", [])
    ]
    Delete["Objects"] += [
        {"Key": v["Key"], "VersionId": v["VersionId"]}
        for v in stuff.get("DeleteMarkers", [])
    ]
    if Delete["Objects"]:
        ret = delete_objects(
            Bucket,
            Delete,
            MFA=MFA,
            RequestPayer=RequestPayer,
            region=region,
            key=key,
            keyid=keyid,
            profile=profile,
        )
        failed = ret.get("failed", [])
        if failed:
            return {"deleted": False, "failed": ret[failed]}
    return {"deleted": True}
def list(region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        buckets = conn.list_buckets()
        if not bool(buckets.get("Buckets")):
            log.warning("No buckets found")
        if "ResponseMetadata" in buckets:
            del buckets["ResponseMetadata"]
        return buckets
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def list_object_versions(
    Bucket,
    Delimiter=None,
    EncodingType=None,
    Prefix=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        Versions = []
<a name="5"></a>        DeleteMarkers = []
        args = {"Bucket": Bucket}
        args.update({"Delimiter": Delimiter}) if Delimiter else None
        args.update({<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"EncodingType": EncodingType}) if Delimiter else None
        args.update({"Prefix": Prefix}) if Prefix else None
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        IsTruncated = True
        while</b></font> IsTruncated:
            ret = conn.list_object_versions(**args)
            IsTruncated = ret.get("IsTruncated", False)
            if IsTruncated in ("True", "true", True):
                args["KeyMarker"] = ret["NextKeyMarker"]
                args["VersionIdMarker"] = ret["NextVersionIdMarker"]
            Versions += ret.get("Versions", [])
            DeleteMarkers += ret.get("DeleteMarkers", [])
        return {"Versions": Versions, "DeleteMarkers": DeleteMarkers}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](e)}
def list_objects(
    Bucket,
    Delimiter=None,
    EncodingType=None,
    Prefix=None,
    FetchOwner=False,
    StartAfter=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        Contents = []
<a name="4"></a>        args = {"Bucket": Bucket, "FetchOwner": FetchOwner}
        args.update({"Delimiter": Delimiter}) if Delimiter else None
        args.update({"EncodingType": EncodingType}) if Delimiter else None
        args.update({<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"Prefix": Prefix}) if Prefix else None
        args.update({"StartAfter": StartAfter}) if StartAfter else None
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        IsTruncated = True
        while</b></font> IsTruncated:
            ret = conn.list_objects_v2(**args)
            IsTruncated = ret.get("IsTruncated", False)
            if IsTruncated in ("True", "true", True):
                args["ContinuationToken"] = ret["NextContinuationToken"]
<a name="6"></a>            Contents += ret.get("Contents", [])
        return {"Contents": Contents}
    except ClientError as e:
        return {"error": __utils__["boto3.get_error"](<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>e)}
def put_acl(
    Bucket,
    ACL=None,
    AccessControlPolicy=None,
    GrantFullControl=None,
    GrantRead=None,
    GrantReadACP=None,
    GrantWrite=None,
    GrantWriteACP=None,
    region=None,
    key=None,
    keyid=</b></font>None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        kwargs = {}
        if AccessControlPolicy is not None:
            if isinstance(AccessControlPolicy, str):
                AccessControlPolicy = salt.utils.json.loads(AccessControlPolicy)
            kwargs["AccessControlPolicy"] = AccessControlPolicy
        for arg in (
            "ACL",
            "GrantFullControl",
            "GrantRead",
            "GrantReadACP",
            "GrantWrite",
            "GrantWriteACP",
        ):
            if locals()[arg] is not None:
                kwargs[arg] = str(locals()[arg])
        conn.put_bucket_acl(Bucket=Bucket, **kwargs)
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_cors(Bucket, CORSRules, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if CORSRules is not None and isinstance(CORSRules, str):
            CORSRules = salt.utils.json.loads(CORSRules)
        conn.put_bucket_cors(Bucket=Bucket, CORSConfiguration={"CORSRules": CORSRules})
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_lifecycle_configuration(
    Bucket, Rules, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if Rules is not None and isinstance(Rules, str):
            Rules = salt.utils.json.loads(Rules)
        conn.put_bucket_lifecycle_configuration(
            Bucket=Bucket, LifecycleConfiguration={"Rules": Rules}
        )
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_logging(
    Bucket,
    TargetBucket=None,
    TargetPrefix=None,
    TargetGrants=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        logstate = {}
        targets = {
            "TargetBucket": TargetBucket,
            "TargetGrants": TargetGrants,
            "TargetPrefix": TargetPrefix,
        }
        for key, val in targets.items():
            if val is not None:
                logstate[key] = val
        if logstate:
            logstatus = {"LoggingEnabled": logstate}
        else:
            logstatus = {}
        if TargetGrants is not None and isinstance(TargetGrants, str):
            TargetGrants = salt.utils.json.loads(TargetGrants)
        conn.put_bucket_logging(Bucket=Bucket, BucketLoggingStatus=logstatus)
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_notification_configuration(
    Bucket,
    TopicConfigurations=None,
    QueueConfigurations=None,
    LambdaFunctionConfigurations=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if TopicConfigurations is None:
            TopicConfigurations = []
        elif isinstance(TopicConfigurations, str):
            TopicConfigurations = salt.utils.json.loads(TopicConfigurations)
        if QueueConfigurations is None:
            QueueConfigurations = []
        elif isinstance(QueueConfigurations, str):
            QueueConfigurations = salt.utils.json.loads(QueueConfigurations)
        if LambdaFunctionConfigurations is None:
            LambdaFunctionConfigurations = []
        elif isinstance(LambdaFunctionConfigurations, str):
            LambdaFunctionConfigurations = salt.utils.json.loads(
                LambdaFunctionConfigurations
            )
        conn.put_bucket_notification_configuration(
            Bucket=Bucket,
            NotificationConfiguration={
                "TopicConfigurations": TopicConfigurations,
                "QueueConfigurations": QueueConfigurations,
                "LambdaFunctionConfigurations": LambdaFunctionConfigurations,
            },
        )
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_policy(Bucket, Policy, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        if Policy is None:
            Policy = "{}"
        elif not isinstance(Policy, str):
            Policy = salt.utils.json.dumps(Policy)
        conn.put_bucket_policy(Bucket=Bucket, Policy=Policy)
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
    if name.startswith("arn:aws:iam:"):
        return name
    account_id = __salt__["boto_iam.get_account_id"](
        region=region, key=key, keyid=keyid, profile=profile
    )
    if profile and "region" in profile:
        region = profile["region"]
    if region is None:
        region = "us-east-1"
    return "arn:aws:iam::{}:role/{}".format(account_id, name)
def put_replication(
    Bucket, Role, Rules, region=None, key=None, keyid=None, profile=None
):
        conn <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        Role = _get_role_arn(
            name=Role, region=region, key=key, keyid=keyid, profile=</b></font>profile
        )
        if Rules is None:
            Rules = []
        elif isinstance(Rules, str):
            Rules = salt.utils.json.loads(Rules)
        conn.put_bucket_replication(
            Bucket=Bucket, ReplicationConfiguration={"Role": Role, "Rules": Rules}
        )
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_request_payment(Bucket, Payer, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.put_bucket_request_payment(
            Bucket=Bucket, RequestPaymentConfiguration={"Payer": Payer}
        )
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_tagging(Bucket, region=None, key=None, keyid=None, profile=None, **kwargs):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        tagslist = []
        for k, v in kwargs.items():
            if str(k).startswith("__"):
                continue
            tagslist.append({"Key": str(k), "Value": str(v)})
        conn.put_bucket_tagging(Bucket=Bucket, Tagging={"TagSet": tagslist})
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_versioning(
    Bucket,
    Status,
    MFADelete=None,
    MFA=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        VersioningConfiguration = {"Status": Status}
        if MFADelete is not None:
            VersioningConfiguration["MFADelete"] = MFADelete
        kwargs = {}
        if MFA is not None:
            kwargs["MFA"] = MFA
        conn.put_bucket_versioning(
            Bucket=Bucket, VersioningConfiguration=VersioningConfiguration, **kwargs
        )
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def put_website(
    Bucket,
    ErrorDocument=None,
    IndexDocument=None,
    RedirectAllRequestsTo=None,
    RoutingRules=None,
    region=None,
    key=None,
    keyid=None,
    profile=None,
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        WebsiteConfiguration = {}
        for key in (
            "ErrorDocument",
            "IndexDocument",
            "RedirectAllRequestsTo",
            "RoutingRules",
        ):
            val = locals()[key]
            if val is not None:
                if isinstance(val, str):
                    WebsiteConfiguration[key] = salt.utils.json.loads(val)
                else:
                    WebsiteConfiguration[key] = val
        conn.put_bucket_website(
            Bucket=Bucket, WebsiteConfiguration=WebsiteConfiguration
        )
        return {"updated": True, "name": Bucket}
    except ClientError as e:
        return {"updated": False, "error": __utils__["boto3.get_error"](e)}
def delete_cors(Bucket, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_cors(Bucket=Bucket)
        return {"deleted": True, "name": Bucket}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def delete_lifecycle_configuration(
    Bucket, region=None, key=None, keyid=None, profile=None
):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_lifecycle(Bucket=Bucket)
        return {"deleted": True, "name": Bucket}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def delete_policy(Bucket, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_policy(Bucket=Bucket)
        return {"deleted": True, "name": Bucket}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def delete_replication(Bucket, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_replication(Bucket=Bucket)
        return {"deleted": True, "name": Bucket}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def delete_tagging(Bucket, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_tagging(Bucket=Bucket)
        return {"deleted": True, "name": Bucket}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
def delete_website(Bucket, region=None, key=None, keyid=None, profile=None):
    try:
        conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
        conn.delete_bucket_website(Bucket=Bucket)
        return {"deleted": True, "name": Bucket}
    except ClientError as e:
        return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
