<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for boto3_route53_1.py &amp; boto_s3_bucket_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for boto3_route53_1.py &amp; boto_s3_bucket_1.py
      </h3>
<h1 align="center">
        9.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>boto3_route53_1.py (9.731233%)<th>boto_s3_bucket_1.py (8.84583%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(63-79)<td><a href="#" name="0">(68-88)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(302-317)<td><a href="#" name="1">(119-134)</a><td align="center"><font color="#d20000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(383-389)<td><a href="#" name="2">(797-799)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(272-301)<td><a href="#" name="3">(349-369)</a><td align="center"><font color="#c30000">13</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(758-764)<td><a href="#" name="4">(497-501)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(632-638)<td><a href="#" name="5">(450-454)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(525-538)<td><a href="#" name="6">(509-523)</a><td align="center"><font color="#b40000">12</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(79-89)<td><a href="#" name="7">(88-96)</a><td align="center"><font color="#b40000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto3_route53_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import re
3 import time
4 import salt.utils.compat
5 import salt.utils.versions
6 from salt.exceptions import CommandExecutionError, SaltInvocationError
7 log = logging.getLogger(__name__)
8 try:
9     <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>import boto3
10     from botocore.exceptions import ClientError
11     logging.getLogger("boto3").setLevel(logging.CRITICAL)
12     HAS_BOTO3 = True
13 except ImportError:
14     HAS_BOTO3 = False
15 def __virtual__():
16     return salt.utils.versions.check_boto_reqs(</b></font><font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>)
17 def __init__(opts):
18     if HAS_BOTO3:
19         __utils__["boto3.assign_funcs"](__name__, "route53")
20 def _collect_results(func, item, args, marker="Marker", nextmarker="NextMarker"):
21     ret = []
22     Marker =</b></font> args.get(marker, "")
23     tries = 10
24     while Marker is not None:
25         try:
26             r = func(**args)
27         except ClientError as e:
28             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
29                 log.debug("Throttled by AWS API.")
30                 time.sleep(3)
31                 tries -= 1
32                 continue
33             log.error("Could not collect results from %s(): %s", func, e)
34             return []
35         i = r.get(item, []) if item else r
36         i.pop("ResponseMetadata", None) if isinstance(i, dict) else None
37         ret += i if isinstance(i, list) else [i]
38         Marker = r.get(nextmarker)
39         args.update({marker: Marker})
40     return ret
41 def _wait_for_sync(change, conn, tries=10, sleep=20):
42     for retry in range(1, tries + 1):
43         log.info("Getting route53 status (attempt %s)", retry)
44         status = "wait"
45         try:
46             status = conn.get_change(Id=change)["ChangeInfo"]["Status"]
47         except ClientError as e:
48             if e.response.get("Error", {}).get("Code") == "Throttling":
49                 log.debug("Throttled by AWS API.")
50             else:
51                 raise
52         if status == "INSYNC":
53             return True
54         time.sleep(sleep)
55     log.error("Timed out waiting for Route53 INSYNC status.")
56     return False
57 def find_hosted_zone(
58     Id=None,
59     Name=None,
60     PrivateZone=None,
61     region=None,
62     key=None,
63     keyid=None,
64     profile=None,
65 ):
66     if not _exactly_one((Id, Name)):
67         raise SaltInvocationError("Exactly one of either Id or Name is required.")
68     if PrivateZone is not None and not isinstance(PrivateZone, bool):
69         raise SaltInvocationError(
70             "If set, PrivateZone must be a bool (e.g. True / False)."
71         )
72     if Id:
73         ret = get_hosted_zone(Id, region=region, key=key, keyid=keyid, profile=profile)
74     else:
75         ret = get_hosted_zones_by_domain(
76             Name, region=region, key=key, keyid=keyid, profile=profile
77         )
78     if PrivateZone is not None:
79         ret = [
80             m for m in ret if m["HostedZone"]["Config"]["PrivateZone"] is PrivateZone
81         ]
82     if len(ret) &gt; 1:
83         log.error(
84             "Request matched more than one Hosted Zone (%s). Refine your "
85             "criteria and try again.",
86             [z["HostedZone"]["Id"] for z in ret],
87         )
88         ret = []
89     return ret
90 def get_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
91     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
92     args = {"Id": Id}
93     return _collect_results(conn.get_hosted_zone, None, args)
94 def get_hosted_zones_by_domain(Name, region=None, key=None, keyid=None, profile=None):
95     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
96     zones = [
97         z
98         for z in _collect_results(conn.list_hosted_zones, "HostedZones", {})
99         if z["Name"] == _aws_encode(Name)
100     ]
101     ret = []
102     for z in zones:
103         ret += get_hosted_zone(
104             Id=z["Id"], region=region, key=key, keyid=keyid, profile=profile
105         )
106     return ret
107 def list_hosted_zones(
108     DelegationSetId<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=None, region=None, key=None, keyid=None, profile=None
109 ):
110     """
111     args = {"DelegationSetId"</b></font>: DelegationSetId} if DelegationSetId else {}
112     return _collect_results(conn<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.list_hosted_zones, "HostedZones", args)
113 def create_hosted_zone(
114     Name,
115     VPCId=None,
116     VPCName=None,
117     VPCRegion=None,
118     CallerReference=None,
119     Comment="",
120     PrivateZone=False,
121     DelegationSetId=None,
122     region=None,
123     key=None,
124     keyid=None,
125     profile=</b></font>None,
126 ):
127     """
128     Create a new Route53 Hosted Zone. Returns a Python data structure with information about the
129     newly created Hosted Zone.
130     Name
131         The name of the domain. This should be a fully-specified domain, and should terminate with
132         a period. This is the name you have registered with your DNS registrar. It is also the name
133         you will delegate from your registrar to the Amazon Route 53 delegation servers returned in
134         response to this request.
135     VPCId
136         When creating a private hosted zone, either the VPC ID or VPC Name to associate with is
137         required.  Exclusive with VPCName.  Ignored if passed for a non-private zone.
138     VPCName
139         When creating a private hosted zone, either the VPC ID or VPC Name to associate with is
140         required.  Exclusive with VPCId.  Ignored if passed for a non-private zone.
141     VPCRegion
142         When creating a private hosted zone, the region of the associated VPC is required.  If not
143         provided, an effort will be made to determine it from VPCId or VPCName, if possible.  If
144         this fails, you'll need to provide an explicit value for this option.  Ignored if passed for
145         a non-private zone.
146     CallerReference
147         A unique string that identifies the request and that allows create_hosted_zone() calls to be
148         retried without the risk of executing the operation twice.  This is a required parameter
149         when creating new Hosted Zones.  Maximum length of 128.
150     Comment
151         Any comments you want to include about the hosted zone.
152     PrivateZone
153         Boolean - Set to True if creating a private hosted zone.
154     DelegationSetId
155         If you want to associate a reusable delegation set with this hosted zone, the ID that Amazon
156         Route 53 assigned to the reusable delegation set when you created it.  Note that XXX TODO
157         create_delegation_set() is not yet implemented, so you'd need to manually create any
158         delegation sets before utilizing this.
159     region
160         Region endpoint to connect to.
161     key
162         AWS key to bind with.
163     keyid
164         AWS keyid to bind with.
165     profile
166         Dict, or pillar key pointing to a dict, containing AWS region/key/keyid.
167     CLI Example:
168     .. code-block:: bash
169         salt myminion boto3_route53.create_hosted_zone example.org.
170     """
171     if not Name.endswith("."):
172         raise SaltInvocationError(
173         )
174     Name = _aws_encode(Name)
175     conn <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
176     deets = find_hosted_zone(
177         Name=Name,
178         PrivateZone=PrivateZone,
179         region=region,
180         key=key,
181         keyid=</b></font>keyid,
182         profile=profile,
183     )
184     if deets:
185         log.info(
186             "Route 53 hosted zone %s already exists. You may want to pass "
187             "e.g. 'PrivateZone=True' or similar...",
188             Name,
189         )
190         return None
191     args = {
192         "Name": Name,
193         "CallerReference": CallerReference,
194         "HostedZoneConfig": {"Comment": Comment, "PrivateZone": PrivateZone},
195     }
196     args.update({"DelegationSetId": DelegationSetId}) if DelegationSetId else None
197     if PrivateZone:
198         if not _exactly_one((VPCName, VPCId)):
199             raise SaltInvocationError(
200                 "Either VPCName or VPCId is required when creating a private zone."
201             )
202         vpcs = __salt__["boto_vpc.describe_vpcs"](
203             vpc_id=VPCId,
204             name=VPCName,
205             region=region,
206             key=key,
207             keyid=keyid,
208             profile=profile,
209         ).get("vpcs", [])
210         if VPCRegion and vpcs:
211             vpcs = [v for v in vpcs if v["region"] == VPCRegion]
212         if not vpcs:
213             log.error(
214                 "Private zone requested but no VPC matching given criteria found."
215             )
216             return None
217         if len(vpcs) &gt; 1:
218             log.error(
219                 "Private zone requested but multiple VPCs matching given "
220                 "criteria found: %s.",
221                 [v["id"] for v in vpcs],
222             )
223             return None
224         vpc = vpcs[0]
225         if VPCName:
226             VPCId = vpc["id"]
227         if not VPCRegion:
228             VPCRegion = vpc["region"]
229         args.update({"VPC": {"VPCId": VPCId, "VPCRegion": VPCRegion}})
230     else:
231         if any((VPCId, VPCName, VPCRegion)):
232             log.info(
233                 "Options VPCId, VPCName, and VPCRegion are ignored when creating "
234                 "non-private zones."
235             )
236     tries = 10
237     while tries:
238         try:
239             r = conn.create_hosted_zone(**args)
240             r.pop("ResponseMetadata", None)
241             if _wait_for_sync(r["ChangeInfo"]["Id"], conn):
242                 return [r]
243             return []
244         except ClientError as e:
245             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
246                 log.debug("Throttled by AWS API.")
247                 time.sleep(3)
248                 tries -= 1
249                 continue
250             log.error("Failed to create hosted zone %s: %s", Name, e)
251             return []
252     return []
253 def update_hosted_zone_comment(
254     Id=None,
255     Name=None,
256     Comment=None,
257     PrivateZone=None,
258     region=None,
259     key=None,
260     keyid=None,
261     profile=None,
262 ):
263     """
264     Update the comment on an existing Route 53 hosted zone.
265     Id
266         The unique Zone Identifier for the Hosted Zone.
267     Name
268         The domain name associated with the Hosted Zone(s).
269     Comment
270         Any comments you want to include about the hosted zone.
271     PrivateZone
272         Boolean - Set to True if changing a private hosted zone.
273     CLI Example:
274     .. code-block:: bash
275         salt myminion boto3_route53.update_hosted_zone_comment Name=example.org. \
276                 Comment="This is an example comment for an example zone"
277     """
278     if not _exactly_one((Id, Name)):
279         raise SaltInvocationError("Exactly one of either Id or Name is required.")
280     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
281     if Name:
282         args = {
283             "Name": Name,
284             "PrivateZone": PrivateZone,
285             "region": region,
286             "key": key,
287             "keyid": keyid,
288             "profile": profile,
289         }
290         zone = find_hosted_zone(**args)
291         if not zone:
292             log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
293             return []
294         Id = zone[0]["HostedZone"]["Id"]
295     tries = 10
296     while tries:
297         try:
298             r = conn.update_hosted_zone_comment(Id=Id, Comment=Comment)
299             r.pop("ResponseMetadata", None)
300             return [r]
301         except ClientError as e:
302             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
303                 log.debug("Throttled by AWS API.")
304                 time.sleep(3)
305                 continue
306             log.error("Failed to update comment on hosted zone %s: %s", Name or Id, e)
307     r<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>eturn []
308 def associate_vpc_with_hosted_zone(
309     HostedZoneId=None,
310     Name=None,
311     VPCId=None,
312     VPCName=None,
313     VPCRegion=None,
314     Comment=None,
315     region=None,
316     key=None,
317     keyid=None,
318     profile=</b></font>None,
319 ):
320     """
321     Associates an Amazon VPC with a private hosted zone.
322     To perform the association, the VPC and the private hosted zone must already exist. You can't
323     convert a public hosted zone into a private hosted zone.  If you want to associate a VPC from
324     one AWS account with a zone from a another, the AWS account owning the hosted zone must first
325     submit a CreateVPCAssociationAuthorization (using create_vpc_association_authorization() or by
326     other means, such as the AWS console).  With that done, the account owning the VPC can then call
327     associate_vpc_with_hosted_zone() to create the association.
328     Note that if both sides happen to be within the same account, associate_vpc_with_hosted_zone()
329     is enough on its own, and there is no need for the CreateVPCAssociationAuthorization step.
330     Also note that looking up hosted zones by name (e.g. using the Name parameter) only works
331     within a single account - if you're associating a VPC to a zone in a different account, as
332     outlined above, you unfortunately MUST use the HostedZoneId parameter exclusively.
333     HostedZoneId
334         The unique Zone Identifier for the Hosted Zone.
335     Name
336         The domain name associated with the Hosted Zone(s).
337     VPCId
338         When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
339         required.  Exclusive with VPCName.
340     VPCName
341         When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
342         required.  Exclusive with VPCId.
343     VPCRegion
344         When working with a private hosted zone, the region of the associated VPC is required.  If
345         not provided, an effort will be made to determine it from VPCId or VPCName, if possible.  If
346         this fails, you'll need to provide an explicit value for VPCRegion.
347     Comment
348         Any comments you want to include about the change being made.
349     CLI Example:
350     .. code-block:: bash
351         salt myminion boto3_route53.associate_vpc_with_hosted_zone \
352                     Name=example.org. VPCName=myVPC \
353                     VPCRegion=us-east-1 Comment="Whoo-hoo!  I added another VPC."
354     """
355     if not _exactly_one((HostedZoneId, Name)):
356         raise SaltInvocationError(
357             "Exactly one of either HostedZoneId or Name is required."
358         )
359     if not _exactly_one((VPCId, VPCName)):
360         raise SaltInvocationError("Exactly one of either VPCId or VPCName is required.")
361     if Name:
362         args = {
363             "Name": Name,
364             "PrivateZone": True,
365             "region": region,
366             "key": key,
367             "keyid": keyid,
368             "profile": profile,
369         }
370         zone = find_hosted_zone(**args)
371         if not zone:
372             log.error(
373                 "Couldn't resolve domain name %s to a private hosted zone ID.", Name
374             )
375             return False
376         HostedZoneId = zone[0]["HostedZone"]["Id"]
377     vpcs = __salt__["boto_vpc.describe_vpcs"](
378         vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
379     ).get("vpcs", [])
380     if VPCRegion and vpcs:
381         vpcs = [v for v in vpcs if v["region"] == VPCRegion]
382     if not vpcs:
383         log.error("No VPC matching the given criteria found.")
384         return False
385     if len(vpcs) &gt; 1:
386         log.error(
387             "Multiple VPCs matching the given criteria found: %s.",
388             ", ".join([v["id"] for v in vpcs]),
389         )
390         return False
391     vpc = vpcs[0]
392     if VPCName:
393         VPCId = vpc["id"]
394     if not VPCRegion:
395     args = {
396         "HostedZoneId": HostedZoneId,
397         "VPC": {<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"VPCId": VPCId, "VPCRegion": VPCRegion},
398     }
399     args.update({"Comment": Comment}) if Comment is not None else None
400     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
401     tries = 10
402     while</b></font> tries:
403         try:
404             r = conn.associate_vpc_with_hosted_zone(**args)
405             return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
406         except ClientError as e:
407             if e.response.get("Error", {}).get("Code") == "ConflictingDomainExists":
408                 log.debug("VPC Association already exists.")
409                 return True
410             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
411                 log.debug("Throttled by AWS API.")
412                 time.sleep(3)
413                 tries -= 1
414                 continue
415             log.error(
416                 "Failed to associate VPC %s with hosted zone %s: %s",
417                 VPCName or VPCId,
418                 Name or HostedZoneId,
419                 e,
420             )
421     return False
422 def disassociate_vpc_from_hosted_zone(
423     HostedZoneId=None,
424     Name=None,
425     VPCId=None,
426     VPCName=None,
427     VPCRegion=None,
428     Comment=None,
429     region=None,
430     key=None,
431     keyid=None,
432     profile=None,
433 ):
434     """
435     Disassociates an Amazon VPC from a private hosted zone.
436     You can't disassociate the last VPC from a private hosted zone.  You also can't convert a
437     private hosted zone into a public hosted zone.
438     Note that looking up hosted zones by name (e.g. using the Name parameter) only works XXX FACTCHECK
439     within a single AWS account - if you're disassociating a VPC in one account from a hosted zone
440     in a different account you unfortunately MUST use the HostedZoneId parameter exclusively. XXX FIXME DOCU
441     HostedZoneId
442         The unique Zone Identifier for the Hosted Zone.
443     Name
444         The domain name associated with the Hosted Zone(s).
445     VPCId
446         When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
447         required.  Exclusive with VPCName.
448     VPCName
449         When working with a private hosted zone, either the VPC ID or VPC Name to associate with is
450         required.  Exclusive with VPCId.
451     VPCRegion
452         When working with a private hosted zone, the region of the associated VPC is required.  If
453         not provided, an effort will be made to determine it from VPCId or VPCName, if possible.  If
454         this fails, you'll need to provide an explicit value for VPCRegion.
455     Comment
456         Any comments you want to include about the change being made.
457     CLI Example:
458     .. code-block:: bash
459         salt myminion boto3_route53.disassociate_vpc_from_hosted_zone \
460                     Name=example.org. VPCName=myVPC \
461                     VPCRegion=us-east-1 Comment="Whoops!  Don't wanna talk to this-here zone no more."
462     """
463     if not _exactly_one((HostedZoneId, Name)):
464         raise SaltInvocationError(
465             "Exactly one of either HostedZoneId or Name is required."
466         )
467     if not _exactly_one((VPCId, VPCName)):
468         raise SaltInvocationError("Exactly one of either VPCId or VPCName is required.")
469     if Name:
470         args = {
471             "Name": Name,
472             "PrivateZone": True,
473             "region": region,
474             "key": key,
475             "keyid": keyid,
476             "profile": profile,
477         }
478         zone = find_hosted_zone(**args)
479         if not zone:
480             log.error(
481                 "Couldn't resolve domain name %s to a private hosted zone ID.", Name
482             )
483             return False
484         HostedZoneId = zone[0]["HostedZone"]["Id"]
485     vpcs = __salt__["boto_vpc.describe_vpcs"](
486         vpc_id=VPCId, name=VPCName, region=region, key=key, keyid=keyid, profile=profile
487     ).get("vpcs", [])
488     if VPCRegion and vpcs:
489         vpcs = [v for v in vpcs if v["region"] == VPCRegion]
490     if not vpcs:
491         log.error("No VPC matching the given criteria found.")
492         return False
493     if len(vpcs) &gt; 1:
494         log.error(
495             "Multiple VPCs matching the given criteria found: %s.",
496             ", ".join([v["id"] for v in vpcs]),
497         )
498         return False
499     vpc = vpcs[0]
500     if VPCName:
501         VPCId = vpc["id"]
502     if not VPCRegion:
503     args = {
504         "HostedZoneId": HostedZoneId,
505         "VPC": {<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"VPCId": VPCId, "VPCRegion": VPCRegion},
506     }
507     args.update({"Comment": Comment}) if Comment is not None else None
508     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
509     tries = 10
510     while</b></font> tries:
511         try:
512             r = conn.disassociate_vpc_from_hosted_zone(**args)
513             return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
514         except ClientError as e:
515             if e.response.get("Error", {}).get("Code") == "VPCAssociationNotFound":
516                 log.debug("No VPC Association exists.")
517                 return True
518             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
519                 log.debug("Throttled by AWS API.")
520                 time.sleep(3)
521                 tries -= 1
522                 continue
523             log.error(
524                 "Failed to associate VPC %s with hosted zone %s: %s",
525                 VPCName or VPCId,
526                 Name or HostedZoneId,
527                 e,
528             )
529     return False
530 def delete_hosted_zone(Id, region=None, key=None, keyid=None, profile=None):
531     """
532     Delete a Route53 hosted zone.
533     CLI Example:
534     .. code-block:: bash
535         salt myminion boto3_route53.delete_hosted_zone Z1234567890
536     """
537     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
538     try:
539         r = conn.delete_hosted_zone(Id=Id)
540         return _wait_for_sync(r["ChangeInfo"]["Id"], conn)
541     except ClientError as e:
542         log.error("Failed to delete hosted zone %s: %s", Id, e)
543     return False
544 def delete_hosted_zone_by_domain(
545     Name, PrivateZone=None, region=None, key=None, keyid=None, profile=None
546 ):
547     """
548     Delete a Route53 hosted zone by domain name, and PrivateZone status if provided.
549     CLI Example:
550     .. code-block:: bash
551         salt myminion boto3_route53.delete_hosted_zone_by_domain example.org.
552     """
553     args = {
554         "Name": Name,
555         "PrivateZone": PrivateZone,
556         "region": region,
557         "key": key,
558         "keyid": keyid,
559         "profile": profile,
560     }
561     zone = find_hosted_zone(**args)
562     if not zone:
563         log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
564         return False
565     Id = zone[0]["HostedZone"]["Id"]
566     return delete_hosted_zone(
567         Id=Id, region=region, key=key, keyid=keyid, profile=profile
568     )
569 def _aws_encode(x):
570     """
571     An implementation of the encoding required to support AWS's domain name
572     rules defined here__:
573     .. __: http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html
574     While AWS's documentation specifies individual ASCII characters which need
575     to be encoded, we instead just try to force the string to one of
576     escaped unicode or idna depending on whether there are non-ASCII characters
577     present.
578     This means that we support things like ドメイン.テスト as a domain name string.
579     More information about IDNA encoding in python is found here__:
580     .. __: https://pypi.org/project/idna
581     """
582     ret = None
583     try:
584         x.encode("ascii")
585         ret = re.sub(rb"\\x([a-f0-8]{2})", _hexReplace, x.encode("unicode_escape"))
586     except UnicodeEncodeError:
587         ret = x.encode("idna")
588     except Exception as e:  # pylint: disable=broad-except
589         log.error(
590             "Couldn't encode %s using either 'unicode_escape' or 'idna' codecs", x
591         )
592         raise CommandExecutionError(e)
593     log.debug("AWS-encoded result for %s: %s", x, ret)
594     return ret.decode("utf-8")
595 def _aws_encode_changebatch(o):
596     """
597     helper method to process a change batch &amp; encode the bits which need encoding.
598     """
599     change_idx = 0
600     while change_idx &lt; len(o["Changes"]):
601         o["Changes"][change_idx]["ResourceRecordSet"]["Name"] = _aws_encode(
602             o["Changes"][change_idx]["ResourceRecordSet"]["Name"]
603         )
604         if "ResourceRecords" in o["Changes"][change_idx]["ResourceRecordSet"]:
605             rr_idx = 0
606             while rr_idx &lt; len(
607                 o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"]
608             ):
609                 o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"][
610                     rr_idx
611                 ]["Value"] = _aws_encode(
612                     o["Changes"][change_idx]["ResourceRecordSet"]["ResourceRecords"][
613                         rr_idx
614                     ]["Value"]
615                 )
616                 rr_idx += 1
617         if "AliasTarget" in o["Changes"][change_idx]["ResourceRecordSet"]:
618             o["Changes"][change_idx]["ResourceRecordSet"]["AliasTarget"][
619                 "DNSName"
620             ] = _aws_encode(
621                 o["Changes"][change_idx]["ResourceRecordSet"]["AliasTarget"]["DNSName"]
622             )
623         change_idx += 1
624     return o
625 def _aws_decode(x):
626     """
627     An implementation of the decoding required to support AWS's domain name
628     rules defined here__:
629     .. __: http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DomainNameFormat.html
630     The important part is this:
631         If the domain name includes any characters other than a to z, 0 to 9, - (hyphen),
632         or _ (underscore), Route 53 API actions return the characters as escape codes.
633         This is true whether you specify the characters as characters or as escape
634         codes when you create the entity.
635         The Route 53 console displays the characters as characters, not as escape codes."
636         For a list of ASCII characters the corresponding octal codes, do an internet search on "ascii table".
637     We look for the existence of any escape codes which give us a clue that
638     we're received an escaped unicode string; or we assume it's idna encoded
639     and then decode as necessary.
640     """
641     if "\\" in x:
642         return x.decode("unicode_escape")
643     if type(x) == bytes:
644         return x.decode("idna")
645     return x
646 def _hexReplace(x):
647     """
648     Converts a hex code to a base 16 int then the octal of it, minus the leading
649     zero.
650     This is necessary because x.encode('unicode_escape') automatically assumes
651     you want a hex string, which AWS will accept but doesn't result in what
652     you really want unless it's an octal escape sequence
653     """
654     c = int(x.group(1), 16)
655     return "\\" + str(oct(c))[1:]
656 def get_resource_records(
657     HostedZoneId=None,
658     Name=None,
659     StartRecordName=None,
660     StartRecordType=None,
661     PrivateZone=None,
662     region=None,
663     key=None,
664     keyid=None,
665     profile=None,
666 ):
667     """
668     Get all resource records from a given zone matching the provided StartRecordName (if given) or all
669     records in the zone (if not), optionally filtered by a specific StartRecordType.  This will return
670     any and all RRs matching, regardless of their special AWS flavors (weighted, geolocation, alias,
671     etc.) so your code should be prepared for potentially large numbers of records back from this
672     function - for example, if you've created a complex geolocation mapping with lots of entries all
673     over the world providing the same server name to many different regional clients.
674     If you want EXACTLY ONE record to operate on, you'll need to implement any logic required to
675     pick the specific RR you care about from those returned.
676     Note that if you pass in Name without providing a value for PrivateZone (either True or
677     False), CommandExecutionError can be raised in the case of both public and private zones
678     matching the domain. XXX FIXME DOCU
679     CLI Example:
680     .. code-block:: bash
681         salt myminion boto3_route53.get_records test.example.org example.org A
682     """
683     if not _exactly_one((HostedZoneId, Name)):
684         raise SaltInvocationError(
685             "Exactly one of either HostedZoneId or Name must be provided."
686         )
687     if Name:
688         args = {
689             "Name": Name,
690             "region": region,
691             "key": key,
692             "keyid": keyid,
693             "profile": profile,
694         }
695         args.update({"PrivateZone": PrivateZone}) if PrivateZone is not None else None
696         zone = find_hosted_zone(**args)
697         if not zone:
698             log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
699             return []
700         HostedZoneId = zone[0]["HostedZone"]["Id"]
701     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
702     ret = []
703     next_rr_name = StartRecordName
704     next_rr_type = StartRecordType
705     next_rr_id = None
706     done = False
707     while True:
708         if done:
709             return ret
710         args = {"HostedZoneId": HostedZoneId}
711         args.update(
712             {"StartRecordName": _aws_encode(next_rr_name)}
713         ) if next_rr_name else None
714         args.update(
715             {"StartRecordType": next_rr_type}
716         ) if next_rr_name and next_rr_type else None
717         args.update({"StartRecordIdentifier": next_rr_id}) if next_rr_id else None
718         try:
719             r = conn.list_resource_record_sets(**args)
720             rrs = r["ResourceRecordSets"]
721             next_rr_name = r.get("NextRecordName")
722             next_rr_type = r.get("NextRecordType")
723             next_rr_id = r.get("NextRecordIdentifier")
724             for rr in rrs:
725                 rr["Name"] = _aws_decode(rr["Name"])
726                 if "ResourceRecords" in rr:
727                     x = 0
728                     while x &lt; len(rr["ResourceRecords"]):
729                         if "Value" in rr["ResourceRecords"][x]:
730                             rr["ResourceRecords"][x]["Value"] = _aws_decode(
731                                 rr["ResourceRecords"][x]["Value"]
732                             )
733                         x += 1
734                 if "AliasTarget" in rr:
735                     rr["AliasTarget"]["DNSName"] = _aws_decode(
736                         rr["AliasTarget"]["DNSName"]
737                     )
738                 if StartRecordName and rr["Name"] != StartRecordName:
739                     done = True
740                     break
741                 if StartRecordType and rr["Type"] != StartRecordType:
742                     if StartRecordName:
743                         done = True
744                         break
745                     else:
746                         continue
747                 ret += [rr]
748             if not next_rr_name:
749                 done = True
750         except ClientError as e:
751             if e.response.get("Error", {}).get("Code") == "Throttling":
752                 log.debug("Throttled by AWS API.")
753                 time.sleep(3)
754                 continue
755             raise
756 def change_resource_record_sets(
757     HostedZoneId=None,
758     Name=None,
759     PrivateZone=None,
760     ChangeBatch=None,
761     region=None,
762     key=None,
763     keyid=None,
764     profile=None,
765 ):
766     """
767     See the `AWS Route53 API docs`__ as well as the `Boto3 documentation`__ for all the details...
768     .. __: https://docs.aws.amazon.com/Route53/latest/APIReference/API_ChangeResourceRecordSets.html
769     .. __: http://boto3.readthedocs.io/en/latest/reference/services/route53.html#Route53.Client.change_resource_record_sets
770     The syntax for a ChangeBatch parameter is as follows, but note that the permutations of allowed
771     parameters and combinations thereof are quite varied, so perusal of the above linked docs is
772     highly recommended for any non-trival configurations.
773     .. code-block:: text
774         {
775             "Comment": "string",
776             "Changes": [
777                 {
778                     "Action": "CREATE"|"DELETE"|"UPSERT",
779                     "ResourceRecordSet": {
780                         "Name": "string",
781                         "Type": "SOA"|"A"|"TXT"|"NS"|"CNAME"|"MX"|"NAPTR"|"PTR"|"SRV"|"SPF"|"AAAA",
782                         "SetIdentifier": "string",
783                         "Weight": 123,
784                         "Region": "us-east-1"|"us-east-2"|"us-west-1"|"us-west-2"|"ca-central-1"|"eu-west-1"|"eu-west-2"|"eu-central-1"|"ap-southeast-1"|"ap-southeast-2"|"ap-northeast-1"|"ap-northeast-2"|"sa-east-1"|"cn-north-1"|"ap-south-1",
785                         "GeoLocation": {
786                             "ContinentCode": "string",
787                             "CountryCode": "string",
788                             "SubdivisionCode": "string"
789                         },
790                         "Failover": "PRIMARY"|"SECONDARY",
791                         "TTL": 123,
792                         "ResourceRecords": [
793                             {
794                                 "Value": "string"
795                             },
796                         ],
797                         "AliasTarget": {
798                             "HostedZoneId": "string",
799                             "DNSName": "string",
800                             "EvaluateTargetHealth": True|False
801                         },
802                         "HealthCheckId": "string",
803                         "TrafficPolicyInstanceId": "string"
804                     }
805                 },
806             ]
807         }
808     CLI Example:
809     .. code-block:: bash
810         foo='{
811                "Name": "my-cname.example.org.",
812                "TTL": 600,
813                "Type": "CNAME",
814                "ResourceRecords": [
815                  {
816                    "Value": "my-host.example.org"
817                  }
818                ]
819              }'
820         foo=`echo $foo`  # Remove newlines
821         salt myminion boto3_route53.change_resource_record_sets DomainName=example.org. \
822                 keyid=A1234567890ABCDEF123 key=xblahblahblah \
823                 ChangeBatch="{'Changes': [{'Action': 'UPSERT', 'ResourceRecordSet': $foo}]}"
824     """
825     if not _exactly_one((HostedZoneId, Name)):
826         raise SaltInvocationError(
827             "Exactly one of either HostZoneId or Name must be provided."
828         )
829     if Name:
830         args = {
831             "Name": Name,
832             "region": region,
833             "key": key,
834             "keyid": keyid,
835             "profile": profile,
836         }
837         args.update({"PrivateZone": PrivateZone}) if PrivateZone is not None else None
838         zone = find_hosted_zone(**args)
839         if not zone:
840             log.error("Couldn't resolve domain name %s to a hosted zone ID.", Name)
841             return []
842         HostedZoneId = zone[0]["HostedZone"]["Id"]
843     args = {
844         "HostedZoneId": HostedZoneId,
845         "ChangeBatch": _aws_encode_changebatch(ChangeBatch),
846     }
847     conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
848     tries = 20  # A bit more headroom
849     while tries:
850         try:
851             r = conn.change_resource_record_sets(**args)
852             return _wait_for_sync(
853                 r["ChangeInfo"]["Id"], conn, 30
854             )  # And a little extra time here
855         except ClientError as e:
856             if tries and e.response.get("Error", {}).get("Code") == "Throttling":
857                 log.debug("Throttled by AWS API.")
858                 time.sleep(3)
859                 tries -= 1
860                 continue
861             log.error(
862                 "Failed to apply requested changes to the hosted zone %s: %s",
863                 (Name or HostedZoneId),
864                 str(e),
865             )
866             raise e
867     return False
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>boto_s3_bucket_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 Connection module for Amazon S3 Buckets
3 .. versionadded:: 2016.3.0
4 :depends:
5     - boto
6     - boto3
7 The dependencies listed above can be installed via package or pip.
8 :configuration: This module accepts explicit Lambda credentials but can also
9     utilize IAM roles assigned to the instance through Instance Profiles.
10     Dynamic credentials are then automatically obtained from AWS API and no
11     further configuration is necessary. More Information available at:
12     .. code-block:: text
13         http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html
14     If IAM roles are not used you need to specify them either in a pillar or
15     in the minion's config file:
16     .. code-block:: yaml
17         s3.keyid: GKTADJGHEIQSXMKKRBJ08H
18         s3.key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
19     A region may also be specified in the configuration:
20     .. code-block:: yaml
21         s3.region: us-east-1
22     If a region is not specified, the default is us-east-1.
23     It's also possible to specify key, keyid and region via a profile, either
24     as a passed in dict, or as a string to pull from pillars or minion config:
25     .. code-block:: yaml
26         myprofile:
27             keyid: GKTADJGHEIQSXMKKRBJ08H
28             key: askdjghsdfjkghWupUjasdflkdfklgjsdfjajkghs
29             region: us-east-1
30 """
31 import logging
32 import salt.utils.compat
33 import salt.utils.json
34 import salt.utils.versions
35 from salt.exceptions import SaltInvocationError
36 log = logging.getLogger(__name__)
37     import boto
38     <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>import boto3
39     from botocore.exceptions import ClientError
40     logging.getLogger("boto3").setLevel(logging.CRITICAL)
41     HAS_BOTO = True
42 except ImportError:
43     HAS_BOTO = False
44 def __virtual__():
45     """
46     Only load if boto libraries exist and if boto libraries are greater than
47     a given version.
48     """
49     return salt.utils.versions.check_boto_reqs(</b></font>boto3_ver=<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"1.2.1")
50 def __init__(opts):
51     if HAS_BOTO:
52         __utils__["boto3.assign_funcs"](__name__, "s3")
53 def exists(Bucket, region=None, key=None, keyid=None, profile=</b></font>None):
54     """
55     Given a bucket name, check to see if the given bucket exists.
56     Returns True if the given bucket exists and returns False if the given
57     bucket does not exist.
58     CLI Example:
59     .. code-block:: bash
60         salt myminion boto_s3_bucket.exists mybucket
61     """
62     try:
63         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
64         buckets = conn.head_bucket(Bucket=Bucket)
65         return {"exists": True}
66     except ClientError as e:
67             return {"exists": False}
68         err = __utils__["boto3.get_error"](e)
69         return {<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"error": err}
70 def create(
71     Bucket,
72     ACL=None,
73     LocationConstraint=None,
74     GrantFullControl=None,
75     GrantRead=None,
76     GrantReadACP=None,
77     GrantWrite=None,
78     GrantWriteACP=None,
79     region=None,
80     key=None,
81     keyid=None,
82     profile=</b></font>None,
83 ):
84     """
85     Given a valid config, create an S3 Bucket.
86     Returns {created: true} if the bucket was created and returns
87     {created: False} if the bucket was not created.
88     CLI Example:
89     .. code-block:: bash
90         salt myminion boto_s3_bucket.create my_bucket \\
91                          GrantFullControl='emailaddress=example@example.com' \\
92                          GrantRead='uri="http://acs.amazonaws.com/groups/global/AllUsers"' \\
93                          GrantReadACP='emailaddress="exampl@example.com",id="2345678909876432"' \\
94                          LocationConstraint=us-west-1
95     """
96     try:
97         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
98         kwargs = {}
99         for arg in (
100             "ACL",
101             "GrantFullControl",
102             "GrantRead",
103             "GrantReadACP",
104             "GrantWrite",
105             "GrantWriteACP",
106         ):
107             if locals()[arg] is not None:
108                 kwargs[arg] = str(locals()[arg])
109         if LocationConstraint:
110             kwargs["CreateBucketConfiguration"] = {
111                 "LocationConstraint": LocationConstraint
112             }
113         location = conn.create_bucket(Bucket=Bucket, **kwargs)
114         conn.get_waiter("bucket_exists").wait(Bucket=Bucket)
115         if location:
116             log.info(
117                 "The newly created bucket name is located at %s", location["Location"]
118             )
119             return {"created": True, "name": Bucket, "Location": location["Location"]}
120         else:
121             log.warning("Bucket was not created")
122             return {"created": False}
123     except ClientError as e:
124         return {"created": False, "error": __utils__["boto3.get_error"](e)}
125 def delete(
126     Bucket,
127     MFA=None,
128     RequestPayer=None,
129     Force=False,
130     region=None,
131     key=None,
132     keyid=None,
133     profile=None,
134 ):
135     """
136     Given a bucket name, delete it, optionally emptying it first.
137     Returns {deleted: true} if the bucket was deleted and returns
138     {deleted: false} if the bucket was not deleted.
139     CLI Example:
140     .. code-block:: bash
141         salt myminion boto_s3_bucket.delete mybucket
142     """
143     try:
144         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
145         if Force:
146             empty(
147                 Bucket,
148                 MFA=MFA,
149                 RequestPayer=RequestPayer,
150                 region=region,
151                 key=key,
152                 keyid=keyid,
153                 profile=profile,
154             )
155         conn.delete_bucket(Bucket=Bucket)
156         return {"deleted": True}
157     except ClientError as e:
158         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
159 def delete_objects(
160     Bucket,
161     Delete,
162     MFA=None,
163     RequestPayer=None,
164     region=None,
165     key=None,
166     keyid=None,
167     profile=None,
168 ):
169     """
170     Delete objects in a given S3 bucket.
171     Returns {deleted: true} if all objects were deleted
172     and {deleted: false, failed: [key, ...]} otherwise
173     CLI Example:
174     .. code-block:: bash
175         salt myminion boto_s3_bucket.delete_objects mybucket '{Objects: [Key: myobject]}'
176     """
177     if isinstance(Delete, str):
178         Delete = salt.utils.json.loads(Delete)
179     if not isinstance(Delete, dict):
180         raise SaltInvocationError("Malformed Delete request.")
181     if "Objects" not in Delete:
182         raise SaltInvocationError("Malformed Delete request.")
183     failed = []
184     objs = Delete["Objects"]
185     for i in range(0, len(objs), 1000):
186         chunk = objs[i : i + 1000]
187         subset = {"Objects": chunk, "Quiet": True}
188         try:
189             args = {"Bucket": Bucket}
190             args.update({"MFA": MFA}) if MFA else None
191             args.update({"RequestPayer": RequestPayer}) if RequestPayer else None
192             args.update({"Delete": subset})
193             conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
194             ret = conn.delete_objects(**args)
195             failed += ret.get("Errors", [])
196         except ClientError as e:
197             return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
198     if failed:
199         return {"deleted": False, "failed": failed}
200     else:
201         return {"deleted": True}
202 def describe(Bucket, region=None, key=None, keyid=None, profile=None):
203     """
204     Given a bucket name describe its properties.
205     Returns a dictionary of interesting properties.
206     CLI Example:
207     .. code-block:: bash
208         salt myminion boto_s3_bucket.describe mybucket
209     """
210     try:
211         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
212         result = {}
213         conn_dict = {
214             "ACL": conn.get_bucket_acl,
215             "CORS": conn.get_bucket_cors,
216             "LifecycleConfiguration": conn.get_bucket_lifecycle_configuration,
217             "Location": conn.get_bucket_location,
218             "Logging": conn.get_bucket_logging,
219             "NotificationConfiguration": conn.get_bucket_notification_configuration,
220             "Policy": conn.get_bucket_policy,
221             "Replication": conn.get_bucket_replication,
222             "RequestPayment": conn.get_bucket_request_payment,
223             "Versioning": conn.get_bucket_versioning,
224             "Website": conn.get_bucket_website,
225         }
226         for key, query in conn_dict.items():
227             try:
228                 data = query(Bucket=Bucket)
229             except ClientError as e:
230                 if e.response.get("Error", {}).get("Code") in (
231                     "NoSuchLifecycleConfiguration",
232                     "NoSuchCORSConfiguration",
233                     "NoSuchBucketPolicy",
234                     "NoSuchWebsiteConfiguration",
235                     "ReplicationConfigurationNotFoundError",
236                     "NoSuchTagSet",
237                 ):
238                     continue
239                 raise
240             if "ResponseMetadata" in data:
241                 del data["ResponseMetadata"]
242             result[key] = data
243         tags = {}
244         try:
245             data = conn.get_bucket_tagging(Bucket=Bucket)
246             for tagdef in data.get("TagSet"):
247                 tags[tagdef.get("Key")] = tagdef.get("Value")
248         except ClientError as e:
249             if not e.response.get("Error", {}).get("Code") == "NoSuchTagSet":
250                 raise
251         if tags:
252             result["Tagging"] = tags
253         return {"bucket": result}
254     except ClientError as e:
255         err = __utils__["boto3.get_error"](e)
256         if e.response.get("Error", {}).get("Code") == "NoSuchBucket":
257             return {"bucket": None}
258         return {"error": __utils__["boto3.get_error"](e)}
259 def empty(
260     Bucket, MFA=None, RequestPayer<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>=None, region=None, key=None, keyid=None, profile=None
261 ):
262     """
263     Delete all objects in a given S3 bucket.
264     Returns {deleted: true} if all objects were deleted
265     and {deleted: false, failed: [key, ...]} otherwise
266     CLI Example:
267     .. code-block:: bash
268         salt myminion boto_s3_bucket.empty mybucket
269     """
270     stuff = list_object_versions(
271         Bucket, region=region, key=key, keyid=keyid, profile=profile
272     )
273     Delete = {}
274     Delete[</b></font>"Objects"] = [
275         {"Key": v["Key"], "VersionId": v["VersionId"]}
276         for v in stuff.get("Versions", [])
277     ]
278     Delete["Objects"] += [
279         {"Key": v["Key"], "VersionId": v["VersionId"]}
280         for v in stuff.get("DeleteMarkers", [])
281     ]
282     if Delete["Objects"]:
283         ret = delete_objects(
284             Bucket,
285             Delete,
286             MFA=MFA,
287             RequestPayer=RequestPayer,
288             region=region,
289             key=key,
290             keyid=keyid,
291             profile=profile,
292         )
293         failed = ret.get("failed", [])
294         if failed:
295             return {"deleted": False, "failed": ret[failed]}
296     return {"deleted": True}
297 def list(region=None, key=None, keyid=None, profile=None):
298     """
299     List all buckets owned by the authenticated sender of the request.
300     Returns list of buckets
301     CLI Example:
302     .. code-block:: yaml
303         Owner: {...}
304         Buckets:
305           - {...}
306           - {...}
307     """
308     try:
309         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
310         buckets = conn.list_buckets()
311         if not bool(buckets.get("Buckets")):
312             log.warning("No buckets found")
313         if "ResponseMetadata" in buckets:
314             del buckets["ResponseMetadata"]
315         return buckets
316     except ClientError as e:
317         return {"error": __utils__["boto3.get_error"](e)}
318 def list_object_versions(
319     Bucket,
320     Delimiter=None,
321     EncodingType=None,
322     Prefix=None,
323     region=None,
324     key=None,
325     keyid=None,
326     profile=None,
327 ):
328     """
329     List objects in a given S3 bucket.
330     Returns a list of objects.
331     CLI Example:
332     .. code-block:: bash
333         salt myminion boto_s3_bucket.list_object_versions mybucket
334     """
335     try:
336         Versions = []
337         args = {"Bucket": Bucket}
338         args.update({"Delimiter": Delimiter}) if Delimiter else None
339         args.update({<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"EncodingType": EncodingType}) if Delimiter else None
340         args.update({"Prefix": Prefix}) if Prefix else None
341         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
342         IsTruncated = True
343         while</b></font> IsTruncated:
344             ret = conn.list_object_versions(**args)
345             IsTruncated = ret.get("IsTruncated", False)
346             if IsTruncated in ("True", "true", True):
347                 args["KeyMarker"] = ret["NextKeyMarker"]
348                 args["VersionIdMarker"] = ret["NextVersionIdMarker"]
349             Versions += ret.get("Versions", [])
350             DeleteMarkers += ret.get("DeleteMarkers", [])
351         return {"Versions": Versions, "DeleteMarkers": DeleteMarkers}
352     except ClientError as e:
353         return {"error": __utils__["boto3.get_error"](e)}
354 def list_objects(
355     Bucket,
356     Delimiter=None,
357     EncodingType=None,
358     Prefix=None,
359     FetchOwner=False,
360     StartAfter=None,
361     region=None,
362     key=None,
363     keyid=None,
364     profile=None,
365 ):
366     """
367     List objects in a given S3 bucket.
368     Returns a list of objects.
369     CLI Example:
370     .. code-block:: bash
371         salt myminion boto_s3_bucket.list_objects mybucket
372     """
373     try:
374         Contents = []
375         args.update({"Delimiter": Delimiter}) if Delimiter else None
376         args.update({"EncodingType": EncodingType}) if Delimiter else None
377         args.update({<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>"Prefix": Prefix}) if Prefix else None
378         args.update({"StartAfter": StartAfter}) if StartAfter else None
379         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
380         IsTruncated = True
381         while</b></font> IsTruncated:
382             ret = conn.list_objects_v2(**args)
383             IsTruncated = ret.get("IsTruncated", False)
384             if IsTruncated in ("True", "true", True):
385                 args["ContinuationToken"] = ret["NextContinuationToken"]
386         return {"Contents": Contents}
387     except ClientError as e:
388         return {"error": __utils__["boto3.get_error"](<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>e)}
389 def put_acl(
390     Bucket,
391     ACL=None,
392     AccessControlPolicy=None,
393     GrantFullControl=None,
394     GrantRead=None,
395     GrantReadACP=None,
396     GrantWrite=None,
397     GrantWriteACP=None,
398     region=None,
399     key=None,
400     keyid=</b></font>None,
401     profile=None,
402 ):
403     """
404     Given a valid config, update the ACL for a bucket.
405     Returns {updated: true} if the ACL was updated and returns
406     {updated: False} if the ACL was not updated.
407     CLI Example:
408     .. code-block:: bash
409         salt myminion boto_s3_bucket.put_acl my_bucket 'public' \\
410                          GrantFullControl='emailaddress=example@example.com' \\
411                          GrantRead='uri="http://acs.amazonaws.com/groups/global/AllUsers"' \\
412                          GrantReadACP='emailaddress="exampl@example.com",id="2345678909876432"'
413     """
414     try:
415         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
416         kwargs = {}
417         if AccessControlPolicy is not None:
418             if isinstance(AccessControlPolicy, str):
419                 AccessControlPolicy = salt.utils.json.loads(AccessControlPolicy)
420             kwargs["AccessControlPolicy"] = AccessControlPolicy
421         for arg in (
422             "ACL",
423             "GrantFullControl",
424             "GrantRead",
425             "GrantReadACP",
426             "GrantWrite",
427             "GrantWriteACP",
428         ):
429             if locals()[arg] is not None:
430                 kwargs[arg] = str(locals()[arg])
431         conn.put_bucket_acl(Bucket=Bucket, **kwargs)
432         return {"updated": True, "name": Bucket}
433     except ClientError as e:
434         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
435 def put_cors(Bucket, CORSRules, region=None, key=None, keyid=None, profile=None):
436     """
437     Given a valid config, update the CORS rules for a bucket.
438     Returns {updated: true} if CORS was updated and returns
439     {updated: False} if CORS was not updated.
440     CLI Example:
441     .. code-block:: bash
442         salt myminion boto_s3_bucket.put_cors my_bucket '[{\\
443               "AllowedHeaders":[],\\
444               "AllowedMethods":["GET"],\\
445               "AllowedOrigins":["*"],\\
446               "ExposeHeaders":[],\\
447               "MaxAgeSeconds":123,\\
448         }]'
449     """
450     try:
451         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
452         if CORSRules is not None and isinstance(CORSRules, str):
453             CORSRules = salt.utils.json.loads(CORSRules)
454         conn.put_bucket_cors(Bucket=Bucket, CORSConfiguration={"CORSRules": CORSRules})
455         return {"updated": True, "name": Bucket}
456     except ClientError as e:
457         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
458 def put_lifecycle_configuration(
459     Bucket, Rules, region=None, key=None, keyid=None, profile=None
460 ):
461     """
462     Given a valid config, update the Lifecycle rules for a bucket.
463     Returns {updated: true} if Lifecycle was updated and returns
464     {updated: False} if Lifecycle was not updated.
465     CLI Example:
466     .. code-block:: bash
467         salt myminion boto_s3_bucket.put_lifecycle_configuration my_bucket '[{\\
468               "Expiration": {...},\\
469               "ID": "idstring",\\
470               "Prefix": "prefixstring",\\
471               "Status": "enabled",\\
472               "Transitions": [{...},],\\
473               "NoncurrentVersionTransitions": [{...},],\\
474               "NoncurrentVersionExpiration": {...},\\
475         }]'
476     """
477     try:
478         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
479         if Rules is not None and isinstance(Rules, str):
480             Rules = salt.utils.json.loads(Rules)
481         conn.put_bucket_lifecycle_configuration(
482             Bucket=Bucket, LifecycleConfiguration={"Rules": Rules}
483         )
484         return {"updated": True, "name": Bucket}
485     except ClientError as e:
486         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
487 def put_logging(
488     Bucket,
489     TargetBucket=None,
490     TargetPrefix=None,
491     TargetGrants=None,
492     region=None,
493     key=None,
494     keyid=None,
495     profile=None,
496 ):
497     """
498     Given a valid config, update the logging parameters for a bucket.
499     Returns {updated: true} if parameters were updated and returns
500     {updated: False} if parameters were not updated.
501     CLI Example:
502     .. code-block:: bash
503         salt myminion boto_s3_bucket.put_logging my_bucket log_bucket '[{...}]' prefix
504     """
505     try:
506         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
507         logstate = {}
508         targets = {
509             "TargetBucket": TargetBucket,
510             "TargetGrants": TargetGrants,
511             "TargetPrefix": TargetPrefix,
512         }
513         for key, val in targets.items():
514             if val is not None:
515                 logstate[key] = val
516         if logstate:
517             logstatus = {"LoggingEnabled": logstate}
518         else:
519             logstatus = {}
520         if TargetGrants is not None and isinstance(TargetGrants, str):
521             TargetGrants = salt.utils.json.loads(TargetGrants)
522         conn.put_bucket_logging(Bucket=Bucket, BucketLoggingStatus=logstatus)
523         return {"updated": True, "name": Bucket}
524     except ClientError as e:
525         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
526 def put_notification_configuration(
527     Bucket,
528     TopicConfigurations=None,
529     QueueConfigurations=None,
530     LambdaFunctionConfigurations=None,
531     region=None,
532     key=None,
533     keyid=None,
534     profile=None,
535 ):
536     """
537     Given a valid config, update the notification parameters for a bucket.
538     Returns {updated: true} if parameters were updated and returns
539     {updated: False} if parameters were not updated.
540     CLI Example:
541     .. code-block:: bash
542         salt myminion boto_s3_bucket.put_notification_configuration my_bucket
543                 [{...}] \\
544                 [{...}] \\
545                 [{...}]
546     """
547     try:
548         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
549         if TopicConfigurations is None:
550             TopicConfigurations = []
551         elif isinstance(TopicConfigurations, str):
552             TopicConfigurations = salt.utils.json.loads(TopicConfigurations)
553         if QueueConfigurations is None:
554             QueueConfigurations = []
555         elif isinstance(QueueConfigurations, str):
556             QueueConfigurations = salt.utils.json.loads(QueueConfigurations)
557         if LambdaFunctionConfigurations is None:
558             LambdaFunctionConfigurations = []
559         elif isinstance(LambdaFunctionConfigurations, str):
560             LambdaFunctionConfigurations = salt.utils.json.loads(
561                 LambdaFunctionConfigurations
562             )
563         conn.put_bucket_notification_configuration(
564             Bucket=Bucket,
565             NotificationConfiguration={
566                 "TopicConfigurations": TopicConfigurations,
567                 "QueueConfigurations": QueueConfigurations,
568                 "LambdaFunctionConfigurations": LambdaFunctionConfigurations,
569             },
570         )
571         return {"updated": True, "name": Bucket}
572     except ClientError as e:
573         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
574 def put_policy(Bucket, Policy, region=None, key=None, keyid=None, profile=None):
575     """
576     Given a valid config, update the policy for a bucket.
577     Returns {updated: true} if policy was updated and returns
578     {updated: False} if policy was not updated.
579     CLI Example:
580     .. code-block:: bash
581         salt myminion boto_s3_bucket.put_policy my_bucket {...}
582     """
583     try:
584         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
585         if Policy is None:
586             Policy = "{}"
587         elif not isinstance(Policy, str):
588             Policy = salt.utils.json.dumps(Policy)
589         conn.put_bucket_policy(Bucket=Bucket, Policy=Policy)
590         return {"updated": True, "name": Bucket}
591     except ClientError as e:
592         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
593 def _get_role_arn(name, region=None, key=None, keyid=None, profile=None):
594     if name.startswith("arn:aws:iam:"):
595         return name
596     account_id = __salt__["boto_iam.get_account_id"](
597         region=region, key=key, keyid=keyid, profile=profile
598     )
599     if profile and "region" in profile:
600         region = profile["region"]
601     if region is None:
602         region = "us-east-1"
603     return "arn:aws:iam::{}:role/{}".format(account_id, name)
604 def put_replication(
605     Bucket, Role, Rules, region=None, key=None, keyid=None, profile=None
606 ):
607     """
608     Given a valid config, update the replication configuration for a bucket.
609     Returns {updated: true} if replication configuration was updated and returns
610     {updated: False} if replication configuration was not updated.
611     CLI Example:
612     .. code-block:: bash
613         salt myminion boto_s3_bucket.put_replication my_bucket my_role [...]
614     try:
615         conn <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= _get_conn(region=region, key=key, keyid=keyid, profile=profile)
616         Role = _get_role_arn(
617             name=Role, region=region, key=key, keyid=keyid, profile=</b></font>profile
618         )
619         if Rules is None:
620             Rules = []
621         elif isinstance(Rules, str):
622             Rules = salt.utils.json.loads(Rules)
623         conn.put_bucket_replication(
624             Bucket=Bucket, ReplicationConfiguration={"Role": Role, "Rules": Rules}
625         )
626         return {"updated": True, "name": Bucket}
627     except ClientError as e:
628         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
629 def put_request_payment(Bucket, Payer, region=None, key=None, keyid=None, profile=None):
630     """
631     Given a valid config, update the request payment configuration for a bucket.
632     Returns {updated: true} if request payment configuration was updated and returns
633     {updated: False} if request payment configuration was not updated.
634     CLI Example:
635     .. code-block:: bash
636         salt myminion boto_s3_bucket.put_request_payment my_bucket Requester
637     """
638     try:
639         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
640         conn.put_bucket_request_payment(
641             Bucket=Bucket, RequestPaymentConfiguration={"Payer": Payer}
642         )
643         return {"updated": True, "name": Bucket}
644     except ClientError as e:
645         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
646 def put_tagging(Bucket, region=None, key=None, keyid=None, profile=None, **kwargs):
647     """
648     Given a valid config, update the tags for a bucket.
649     Returns {updated: true} if tags were updated and returns
650     {updated: False} if tags were not updated.
651     CLI Example:
652     .. code-block:: bash
653         salt myminion boto_s3_bucket.put_tagging my_bucket my_role [...]
654     """
655     try:
656         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
657         tagslist = []
658         for k, v in kwargs.items():
659             if str(k).startswith("__"):
660                 continue
661             tagslist.append({"Key": str(k), "Value": str(v)})
662         conn.put_bucket_tagging(Bucket=Bucket, Tagging={"TagSet": tagslist})
663         return {"updated": True, "name": Bucket}
664     except ClientError as e:
665         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
666 def put_versioning(
667     Bucket,
668     Status,
669     MFADelete=None,
670     MFA=None,
671     region=None,
672     key=None,
673     keyid=None,
674     profile=None,
675 ):
676     """
677     Given a valid config, update the versioning configuration for a bucket.
678     Returns {updated: true} if versioning configuration was updated and returns
679     {updated: False} if versioning configuration was not updated.
680     CLI Example:
681     .. code-block:: bash
682         salt myminion boto_s3_bucket.put_versioning my_bucket Enabled
683     """
684     try:
685         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
686         VersioningConfiguration = {"Status": Status}
687         if MFADelete is not None:
688             VersioningConfiguration["MFADelete"] = MFADelete
689         kwargs = {}
690         if MFA is not None:
691             kwargs["MFA"] = MFA
692         conn.put_bucket_versioning(
693             Bucket=Bucket, VersioningConfiguration=VersioningConfiguration, **kwargs
694         )
695         return {"updated": True, "name": Bucket}
696     except ClientError as e:
697         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
698 def put_website(
699     Bucket,
700     ErrorDocument=None,
701     IndexDocument=None,
702     RedirectAllRequestsTo=None,
703     RoutingRules=None,
704     region=None,
705     key=None,
706     keyid=None,
707     profile=None,
708 ):
709     """
710     Given a valid config, update the website configuration for a bucket.
711     Returns {updated: true} if website configuration was updated and returns
712     {updated: False} if website configuration was not updated.
713     CLI Example:
714     .. code-block:: bash
715         salt myminion boto_s3_bucket.put_website my_bucket IndexDocument='{"Suffix":"index.html"}'
716     """
717     try:
718         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
719         WebsiteConfiguration = {}
720         for key in (
721             "ErrorDocument",
722             "IndexDocument",
723             "RedirectAllRequestsTo",
724             "RoutingRules",
725         ):
726             val = locals()[key]
727             if val is not None:
728                 if isinstance(val, str):
729                     WebsiteConfiguration[key] = salt.utils.json.loads(val)
730                 else:
731                     WebsiteConfiguration[key] = val
732         conn.put_bucket_website(
733             Bucket=Bucket, WebsiteConfiguration=WebsiteConfiguration
734         )
735         return {"updated": True, "name": Bucket}
736     except ClientError as e:
737         return {"updated": False, "error": __utils__["boto3.get_error"](e)}
738 def delete_cors(Bucket, region=None, key=None, keyid=None, profile=None):
739     """
740     Delete the CORS configuration for the given bucket
741     Returns {deleted: true} if CORS was deleted and returns
742     {deleted: False} if CORS was not deleted.
743     CLI Example:
744     .. code-block:: bash
745         salt myminion boto_s3_bucket.delete_cors my_bucket
746     """
747     try:
748         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
749         conn.delete_bucket_cors(Bucket=Bucket)
750         return {"deleted": True, "name": Bucket}
751     except ClientError as e:
752         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
753 def delete_lifecycle_configuration(
754     Bucket, region=None, key=None, keyid=None, profile=None
755 ):
756     """
757     Delete the lifecycle configuration for the given bucket
758     Returns {deleted: true} if Lifecycle was deleted and returns
759     {deleted: False} if Lifecycle was not deleted.
760     CLI Example:
761     .. code-block:: bash
762         salt myminion boto_s3_bucket.delete_lifecycle_configuration my_bucket
763     """
764     try:
765         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
766         conn.delete_bucket_lifecycle(Bucket=Bucket)
767         return {"deleted": True, "name": Bucket}
768     except ClientError as e:
769         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
770 def delete_policy(Bucket, region=None, key=None, keyid=None, profile=None):
771     """
772     Delete the policy from the given bucket
773     Returns {deleted: true} if policy was deleted and returns
774     {deleted: False} if policy was not deleted.
775     CLI Example:
776     .. code-block:: bash
777         salt myminion boto_s3_bucket.delete_policy my_bucket
778     """
779     try:
780         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
781         conn.delete_bucket_policy(Bucket=Bucket)
782         return {"deleted": True, "name": Bucket}
783     except ClientError as e:
784         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
785 def delete_replication(Bucket, region=None, key=None, keyid=None, profile=None):
786     """
787     Delete the replication config from the given bucket
788     Returns {deleted: true} if replication configuration was deleted and returns
789     {deleted: False} if replication configuration was not deleted.
790     CLI Example:
791     .. code-block:: bash
792         salt myminion boto_s3_bucket.delete_replication my_bucket
793     """
794     try:
795         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
796         conn.delete_bucket_replication(Bucket=Bucket)
797         return {"deleted": True, "name": Bucket}
798     except ClientError as e:
799         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
800 def delete_tagging(Bucket, region=None, key=None, keyid=None, profile=None):
801     """
802     Delete the tags from the given bucket
803     Returns {deleted: true} if tags were deleted and returns
804     {deleted: False} if tags were not deleted.
805     CLI Example:
806     .. code-block:: bash
807         salt myminion boto_s3_bucket.delete_tagging my_bucket
808     """
809     try:
810         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
811         conn.delete_bucket_tagging(Bucket=Bucket)
812         return {"deleted": True, "name": Bucket}
813     except ClientError as e:
814         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
815 def delete_website(Bucket, region=None, key=None, keyid=None, profile=None):
816     """
817     Remove the website configuration from the given bucket
818     Returns {deleted: true} if website configuration was deleted and returns
819     {deleted: False} if website configuration was not deleted.
820     CLI Example:
821     .. code-block:: bash
822         salt myminion boto_s3_bucket.delete_website my_bucket
823     """
824     try:
825         conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)
826         conn.delete_bucket_website(Bucket=Bucket)
827         return {"deleted": True, "name": Bucket}
828     except ClientError as e:
829         return {"deleted": False, "error": __utils__["boto3.get_error"](e)}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
