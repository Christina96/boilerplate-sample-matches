<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_gml.py &amp; plot_subgraphs.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_gml.py &amp; plot_subgraphs.py
      </h3>
<h1 align="center">
        2.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_gml.py (1.8205462%)<th>plot_subgraphs.py (5.62249%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(260-265)<td><a href="#" name="0">(53-59)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_gml.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
from ast import literal_eval
import codecs
from contextlib import contextmanager
import io
import math
import pytest
import networkx as nx
from networkx.readwrite.gml import literal_stringizer, literal_destringizer
import os
import tempfile
from textwrap import dedent
class TestGraph:
    @classmethod
    def setup_class(cls):
        cls.simple_data = """Creator "me"
Version "xx"
graph [
 comment "This is a sample graph"
 directed 1
 IsPlanar 1
 pos  [ x 0 y 1 ]
 node [
   id 1
   label "Node 1"
   pos [ x 1 y 1 ]
 ]
 node [
    id 2
    pos [ x 1 y 2 ]
    label "Node 2"
    ]
  node [
    id 3
    label "Node 3"
    pos [ x 1 y 3 ]
  ]
  edge [
    source 1
    target 2
    label "Edge from node 1 to node 2"
    color [line "blue" thickness 3]
  ]
  edge [
    source 2
    target 3
    label "Edge from node 2 to node 3"
  ]
  edge [
    source 3
    target 1
    label "Edge from node 3 to node 1"
  ]
]
        nx.parse_gml(cytoscape_example)
    def test_parse_gml(self):
        G = nx.parse_gml(self.simple_data, label="label")
        assert sorted(G.nodes()) == ["Node 1", "Node 2", "Node 3"]
        assert [e for e in sorted(G.edges())] == [
            ("Node 1", "Node 2"),
            ("Node 2", "Node 3"),
            ("Node 3", "Node 1"),
        ]
        assert [e for e in sorted(G.edges(data=True))] == [
            (
                "Node 1",
                "Node 2",
                {
                    "color": {"line": "blue", "thickness": 3},
                    "label": "Edge from node 1 to node 2",
                },
            ),
            ("Node 2", "Node 3", {"label": "Edge from node 2 to node 3"}),
            ("Node 3", "Node 1", {"label": "Edge from node 3 to node 1"}),
        ]
    def test_read_gml(self):
        (fd, fname) = tempfile.mkstemp()
        fh = open(fname, "w")
        fh.write(self.simple_data)
        fh.close()
        Gin = nx.read_gml(fname, label="label")
        G = nx.parse_gml(self.simple_data, label="label")
        assert sorted(G.nodes(data=True)) == sorted(Gin.nodes(data=True))
        assert sorted(G.edges(data=True)) == sorted(Gin.edges(data=True))
        os.close(fd)
        os.unlink(fname)
    def test_labels_are_strings(self):
        answer = """graph [
  node [
    id 0
    label "1203"
  ]
]"""
        G = nx.Graph()
        G.add_node(1203)
        data = "\n".join(nx.generate_gml(G, stringizer=literal_stringizer))
        assert data == answer
    def test_relabel_duplicate(self):
        data = """
graph
[
        label   ""
        directed        1
        node
        [
                id      0
                label   "same"
        ]
        node
        [
                id      1
                label   "same"
        ]
]
        G<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.add_node(node)
        fobj = tempfile.NamedTemporaryFile()
        nx.write_gml(G, fobj)
        fobj.seek(0)
        data = fobj.read().strip(</b></font>).decode("ascii")
        answer = """graph [
  node [
    id 0
    label "node&amp;#169;"
  ]
]"""
        assert data == answer
    def test_float_label(self):
        node = 1.0
        G = nx.Graph()
        G.add_node(node)
        fobj = tempfile.NamedTemporaryFile()
        nx.write_gml(G, fobj)
        fobj.seek(0)
        data = fobj.read().strip().decode("ascii")
        answer = """graph [
  node [
    id 0
    label "1.0"
  ]
]"""
        assert data == answer
    def test_special_float_label(self):
        special_floats = [float("nan"), float("+inf"), float("-inf")]
        try:
            import numpy as np
            special_floats += [np.nan, np.inf, np.inf * -1]
        except ImportError:
            special_floats += special_floats
        G = nx.cycle_graph(len(special_floats))
        attrs = dict(enumerate(special_floats))
        nx.set_node_attributes(G, attrs, "nodefloat")
        edges = list(G.edges)
        attrs = {edges[i]: value for i, value in enumerate(special_floats)}
        nx.set_edge_attributes(G, attrs, "edgefloat")
        fobj = tempfile.NamedTemporaryFile()
        nx.write_gml(G, fobj)
        fobj.seek(0)
        data = fobj.read().strip().decode("ascii")
        answer = """graph [
  node [
    id 0
    label "0"
    nodefloat NAN
  ]
  node [
    id 1
    label "1"
    nodefloat +INF
  ]
  node [
    id 2
    label "2"
    nodefloat -INF
  ]
  node [
    id 3
    label "3"
    nodefloat NAN
  ]
  node [
    id 4
    label "4"
    nodefloat +INF
  ]
  node [
    id 5
    label "5"
    nodefloat -INF
  ]
  edge [
    source 0
    target 1
    edgefloat NAN
  ]
  edge [
    source 0
    target 5
    edgefloat +INF
  ]
  edge [
    source 1
    target 2
    edgefloat -INF
  ]
  edge [
    source 2
    target 3
    edgefloat NAN
  ]
  edge [
    source 3
    target 4
    edgefloat +INF
  ]
  edge [
    source 4
    target 5
    edgefloat -INF
  ]
]"""
        assert data == answer
        fobj.seek(0)
        graph = nx.read_gml(fobj)
        for indx, value in enumerate(special_floats):
            node_value = graph.nodes[str(indx)]["nodefloat"]
            if math.isnan(value):
                assert math.isnan(node_value)
            else:
                assert node_value == value
            edge = edges[indx]
            string_edge = (str(edge[0]), str(edge[1]))
            edge_value = graph.edges[string_edge]["edgefloat"]
            if math.isnan(value):
                assert math.isnan(edge_value)
            else:
                assert edge_value == value
    def test_name(self):
        G = nx.parse_gml('graph [ name "x" node [ id 0 label "x" ] ]')
        assert "x" == G.graph["name"]
        G = nx.parse_gml('graph [ node [ id 0 label "x" ] ]')
        assert "" == G.name
        assert "name" not in G.graph
    def test_graph_types(self):
        for directed in [None, False, True]:
            for multigraph in [None, False, True]:
                gml = "graph ["
                if directed is not None:
                    gml += " directed " + str(int(directed))
                if multigraph is not None:
                    gml += " multigraph " + str(int(multigraph))
                gml += ' node [ id 0 label "0" ]'
                gml += " edge [ source 0 target 0 ]"
                gml += " ]"
                G = nx.parse_gml(gml)
                assert bool(directed) == G.is_directed()
                assert bool(multigraph) == G.is_multigraph()
                gml = "graph [\n"
                if directed is True:
                    gml += "  directed 1\n"
                if multigraph is True:
                    gml += "  multigraph 1\n"
                gml += """  node [
    id 0
    label "0"
  ]
  edge [
    source 0
    target 0
  name "&amp;#38;&amp;#34;&amp;#15;&amp;#17476;&amp;#38;"""
            + alnu
            + """;&amp;#38;unknown;"
]"""
        )
        assert answer == gml
    def test_exceptions(self):
        pytest.raises(ValueError, literal_destringizer, "(")
        pytest.raises(ValueError, literal_destringizer, "frozenset([1, 2, 3])")
        pytest.raises(ValueError, literal_destringizer, literal_destringizer)
        pytest.raises(ValueError, literal_stringizer, frozenset([1, 2, 3]))
        pytest.raises(ValueError, literal_stringizer, literal_stringizer)
        with tempfile.TemporaryFile() as f:
            f.write(codecs.BOM_UTF8 + b"graph[]")
            f.seek(0)
            pytest.raises(nx.NetworkXError, nx.read_gml, f)
        def assert_parse_error(gml):
            pytest.raises(nx.NetworkXError, nx.parse_gml, gml)
        assert_parse_error(["graph [\n\n", "]"])
        assert_parse_error("")
        assert_parse_error('Creator ""')
        assert_parse_error("0")
        assert_parse_error("graph ]")
        assert_parse_error("graph [ 1 ]")
        assert_parse_error("graph [ 1.E+2 ]")
        assert_parse_error('graph [ "A" ]')
        assert_parse_error("graph [ ] graph ]")
        assert_parse_error("graph [ ] graph [ ]")
        assert_parse_error("graph [ data [1, 2, 3] ]")
        assert_parse_error("graph [ node [ ] ]")
        assert_parse_error("graph [ node [ id 0 ] ]")
        nx.parse_gml('graph [ node [ id "a" ] ]', label="id")
        assert_parse_error("graph [ node [ id 0 label 0 ] node [ id 0 label 1 ] ]")
        assert_parse_error("graph [ node [ id 0 label 0 ] node [ id 1 label 0 ] ]")
        assert_parse_error("graph [ node [ id 0 label 0 ] edge [ ] ]")
        assert_parse_error("graph [ node [ id 0 label 0 ] edge [ source 0 ] ]")
        nx.parse_gml("graph [edge [ source 0 target 0 ] node [ id 0 label 0 ] ]")
        assert_parse_error("graph [ node [ id 0 label 0 ] edge [ source 1 target 0 ] ]")
        assert_parse_error("graph [ node [ id 0 label 0 ] edge [ source 0 target 1 ] ]")
        assert_parse_error(
            "graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] "
            "edge [ source 0 target 1 ] edge [ source 1 target 0 ] ]"
        )
        nx.parse_gml(
            "graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] "
            "edge [ source 0 target 1 ] edge [ source 1 target 0 ] "
            "directed 1 ]"
        )
        nx.parse_gml(
            "graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] "
            "edge [ source 0 target 1 ] edge [ source 0 target 1 ]"
            "multigraph 1 ]"
        )
        nx.parse_gml(
            "graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] "
            "edge [ source 0 target 1 key 0 ] edge [ source 0 target 1 ]"
            "multigraph 1 ]"
        )
        assert_parse_error(
            "graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] "
            "edge [ source 0 target 1 key 0 ] edge [ source 0 target 1 key 0 ]"
            "multigraph 1 ]"
        )
        nx.parse_gml(
            "graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] "
            "edge [ source 0 target 1 key 0 ] edge [ source 1 target 0 key 0 ]"
            "directed 1 multigraph 1 ]"
        )
        nx.parse_gml("graph [edge [ source a target a ] node [ id a label b ] ]")
        nx.parse_gml(
            "graph [ node [ id n42 label 0 ] node [ id x43 label 1 ]"
            "edge [ source n42 target x43 key 0 ]"
            "edge [ source x43 target n42 key 0 ]"
            "directed 1 multigraph 1 ]"
        )
        assert_parse_error(
            "graph [edge [ source u'u\4200' target u'u\4200' ] "
            + "node [ id u'u\4200' label b ] ]"
        )
        def assert_generate_error(*args, **kwargs):
            pytest.raises(
                nx.NetworkXError, lambda: list(nx.generate_gml(*args, **kwargs))
            )
        G = nx.Graph()
        G.graph[3] = 3
        assert_generate_error(G)
        G = nx.Graph()
        G.graph["3"] = 3
        assert_generate_error(G)
        G = nx.Graph()
        G.graph["data"] = frozenset([1, 2, 3])
        assert_generate_error(G, stringizer=literal_stringizer)
        G = nx.Graph()
        G.graph["data"] = []
        assert_generate_error(G)
        assert_generate_error(G, stringizer=len)
    def test_label_kwarg(self):
        G = nx.parse_gml(self.simple_data, label="id")
        assert sorted(G.nodes) == [1, 2, 3]
        labels = [G.nodes[n]["label"] for n in sorted(G.nodes)]
        assert labels == ["Node 1", "Node 2", "Node 3"]
        G = nx.parse_gml(self.simple_data, label=None)
        assert sorted(G.nodes) == [1, 2, 3]
        labels = [G.nodes[n]["label"] for n in sorted(G.nodes)]
        assert labels == ["Node 1", "Node 2", "Node 3"]
    def test_outofrange_integers(self):
        G = nx.Graph()
        numbers = {
            "toosmall": (-(2 ** 31)) - 1,
            "small": -(2 ** 31),
            "med1": -4,
            "med2": 0,
            "med3": 17,
            "big": (2 ** 31) - 1,
            "toobig": 2 ** 31,
        }
        G.add_node("Node", **numbers)
        fd, fname = tempfile.mkstemp()
        try:
            nx.write_gml(G, fname)
            G2 = nx.read_gml(fname)
            for attr, value in G2.nodes["Node"].items():
                if attr == "toosmall" or attr == "toobig":
                    assert type(value) == str
                else:
                    assert type(value) == int
        finally:
            os.close(fd)
            os.unlink(fname)
@contextmanager
def byte_file():
    _file_handle = io.BytesIO()
    yield _file_handle
    _file_handle.seek(0)
class TestPropertyLists:
    def test_writing_graph_with_multi_element_property_list(self):
        g = nx.Graph()
        g.add_node("n1", properties=["element", 0, 1, 2.5, True, False])
        with byte_file() as f:
            nx.write_gml(g, f)
        result = f.read().decode()
        assert result == dedent(
        )
    def test_writing_graph_with_one_element_property_list(self):
        g = nx.Graph()
        g.add_node("n1", properties=["element"])
        with byte_file() as f:
            nx.write_gml(g, f)
        result = f.read().decode()
        assert result == dedent(
        )
    def test_reading_graph_with_list_property(self):
        with byte_file() as f:
            f.write(
                dedent(
                ).encode("ascii")
            )
            f.seek(0)
            graph = nx.read_gml(f)
        assert graph.nodes(data=True)["n1"] == {"properties": ["element", 0, 1, 2.5]}
    def test_reading_graph_with_single_element_list_property(self):
        with byte_file() as f:
            f.write(
                dedent(
                ).encode("ascii")
            )
            f.seek(0)
            graph = nx.read_gml(f)
        assert graph.nodes(data=True)["n1"] == {"properties": ["element"]}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>plot_subgraphs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import networkx as nx
import matplotlib.pyplot as plt
def graph_partitioning(G, plotting=True):
    supported_nodes = {n for n, d in G.nodes(data="node_type") if d == "supported"}
    unsupported_nodes = {n for n, d in G.nodes(data="node_type") if d == "unsupported"}
    H = G.copy()
    H.remove_edges_from(
        (n, nbr, d)
        for n, nbrs in G.adj.items()
        if n in supported_nodes
        for nbr, d in nbrs.items()
        if nbr in unsupported_nodes
    )
    H.remove_edges_from(
        (n, nbr, d)
        for n, nbrs in G.adj.items()
        if n in unsupported_nodes
        for nbr, d in nbrs.items()
        if nbr in supported_nodes
    )
    G_minus_H = nx.DiGraph()
    G_minus_H.add_edges_from(set(G.edges) - set(H.edges))
    if plotting:
        _node_colors = [c for _, c in H.nodes(data="node_color")]
        _pos = nx.spring_layout(H)
<a name="0"></a>        plt.figure(figsize=(8, 8))
        nx.draw_networkx_edges(H, _pos, alpha=0.3, edge_color="k")
        nx.draw_networkx_nodes(H, _pos, node_color=_node_colors)
        nx<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.draw_networkx_labels(H, _pos, font_size=14)
        plt.axis("off")
        plt.title("The stripped graph with the edges removed.")
        plt.show()
        _pos = nx.spring_layout(G_minus_H)
        plt.figure(</b></font>figsize=(8, 8))
        ncl = [G.nodes[n]["node_color"] for n in G_minus_H.nodes]
        nx.draw_networkx_edges(G_minus_H, _pos, alpha=0.3, edge_color="k")
        nx.draw_networkx_nodes(G_minus_H, _pos, node_color=ncl)
        nx.draw_networkx_labels(G_minus_H, _pos, font_size=14)
        plt.axis("off")
        plt.title("The removed edges.")
        plt.show()
    subgraphs = [
        H.subgraph(c).copy() for c in nx.connected_components(H.to_undirected())
    ]
    return subgraphs, G_minus_H
G_ex = nx.DiGraph()
G_ex.add_nodes_from(["In"], node_type="input", node_color="b")
G_ex.add_nodes_from(["A", "C", "E", "F"], node_type="supported", node_color="g")
G_ex.add_nodes_from(["B", "D"], node_type="unsupported", node_color="r")
G_ex.add_nodes_from(["Out"], node_type="output", node_color="m")
G_ex.add_edges_from(
    [
        ("In", "A"),
        ("A", "B"),
        ("B", "C"),
        ("B", "D"),
        ("D", "E"),
        ("C", "F"),
        ("E", "F"),
        ("F", "Out"),
    ]
)
node_color_list = [nc for _, nc in G_ex.nodes(data="node_color")]
pos = nx.spectral_layout(G_ex)
plt.figure(figsize=(8, 8))
nx.draw_networkx_edges(G_ex, pos, alpha=0.3, edge_color="k")
nx.draw_networkx_nodes(G_ex, pos, alpha=0.8, node_color=node_color_list)
nx.draw_networkx_labels(G_ex, pos, font_size=14)
plt.axis("off")
plt.title("The original graph.")
plt.show()
subgraphs_of_G_ex, removed_edges = graph_partitioning(G_ex, plotting=True)
for subgraph in subgraphs_of_G_ex:
    _pos = nx.spring_layout(subgraph)
    plt.figure(figsize=(8, 8))
    nx.draw_networkx_edges(subgraph, _pos, alpha=0.3, edge_color="k")
    node_color_list_c = [nc for _, nc in subgraph.nodes(data="node_color")]
    nx.draw_networkx_nodes(subgraph, _pos, node_color=node_color_list_c)
    nx.draw_networkx_labels(subgraph, _pos, font_size=14)
    plt.axis("off")
    plt.title("One of the subgraphs.")
    plt.show()
G_ex_r = nx.DiGraph()
for subgraph in subgraphs_of_G_ex:
    G_ex_r = nx.compose(G_ex_r, subgraph)
G_ex_r.add_edges_from(removed_edges.edges())
assert nx.is_isomorphic(G_ex, G_ex_r)
node_color_list = [nc for _, nc in G_ex_r.nodes(data="node_color")]
pos = nx.spectral_layout(G_ex_r)
plt.figure(figsize=(8, 8))
nx.draw_networkx_edges(G_ex_r, pos, alpha=0.3, edge_color="k")
nx.draw_networkx_nodes(G_ex_r, pos, alpha=0.8, node_color=node_color_list)
nx.draw_networkx_labels(G_ex_r, pos, font_size=14)
plt.axis("off")
plt.title("The reconstructed graph.")
plt.show()
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
