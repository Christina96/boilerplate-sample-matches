<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_gml.py & plot_subgraphs.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_gml.py & plot_subgraphs.py
      </h3>
      <h1 align="center">
        2.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_gml.py (1.8205462%)<TH>plot_subgraphs.py (5.62249%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match10155-0.html#0',2,'match10155-1.html#0',3)" NAME="0">(260-265)<TD><A HREF="javascript:ZweiFrames('match10155-0.html#0',2,'match10155-1.html#0',3)" NAME="0">(53-59)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_gml.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
from ast import literal_eval
import codecs
from contextlib import contextmanager
import io
import math
import pytest
import networkx as nx
from networkx.readwrite.gml import literal_stringizer, literal_destringizer
import os
import tempfile
from textwrap import dedent


class TestGraph:
    @classmethod
    def setup_class(cls):
        cls.simple_data = &quot;&quot;&quot;Creator &quot;me&quot;
Version &quot;xx&quot;
graph [
 comment &quot;This is a sample graph&quot;
 directed 1
 IsPlanar 1
 pos  [ x 0 y 1 ]
 node [
   id 1
   label &quot;Node 1&quot;
   pos [ x 1 y 1 ]
 ]
 node [
    id 2
    pos [ x 1 y 2 ]
    label &quot;Node 2&quot;
    ]
  node [
    id 3
    label &quot;Node 3&quot;
    pos [ x 1 y 3 ]
  ]
  edge [
    source 1
    target 2
    label &quot;Edge from node 1 to node 2&quot;
    color [line &quot;blue&quot; thickness 3]

  ]
  edge [
    source 2
    target 3
    label &quot;Edge from node 2 to node 3&quot;
  ]
  edge [
    source 3
    target 1
    label &quot;Edge from node 3 to node 1&quot;
  ]
]
&quot;&quot;&quot;

    def test_parse_gml_cytoscape_bug(self):
        # example from issue #321, originally #324 in trac
        cytoscape_example = &quot;&quot;&quot;
Creator &quot;Cytoscape&quot;
Version 1.0
graph   [
    node    [
        root_index  -3
        id  -3
        graphics    [
            x   -96.0
            y   -67.0
            w   40.0
            h   40.0
            fill    &quot;#ff9999&quot;
            type    &quot;ellipse&quot;
            outline &quot;#666666&quot;
            outline_width   1.5
        ]
        label   &quot;node2&quot;
    ]
    node    [
        root_index  -2
        id  -2
        graphics    [
            x   63.0
            y   37.0
            w   40.0
            h   40.0
            fill    &quot;#ff9999&quot;
            type    &quot;ellipse&quot;
            outline &quot;#666666&quot;
            outline_width   1.5
        ]
        label   &quot;node1&quot;
    ]
    node    [
        root_index  -1
        id  -1
        graphics    [
            x   -31.0
            y   -17.0
            w   40.0
            h   40.0
            fill    &quot;#ff9999&quot;
            type    &quot;ellipse&quot;
            outline &quot;#666666&quot;
            outline_width   1.5
        ]
        label   &quot;node0&quot;
    ]
    edge    [
        root_index  -2
        target  -2
        source  -1
        graphics    [
            width   1.5
            fill    &quot;#0000ff&quot;
            type    &quot;line&quot;
            Line    [
            ]
            source_arrow    0
            target_arrow    3
        ]
        label   &quot;DirectedEdge&quot;
    ]
    edge    [
        root_index  -1
        target  -1
        source  -3
        graphics    [
            width   1.5
            fill    &quot;#0000ff&quot;
            type    &quot;line&quot;
            Line    [
            ]
            source_arrow    0
            target_arrow    3
        ]
        label   &quot;DirectedEdge&quot;
    ]
]
&quot;&quot;&quot;
        nx.parse_gml(cytoscape_example)

    def test_parse_gml(self):
        G = nx.parse_gml(self.simple_data, label=&quot;label&quot;)
        assert sorted(G.nodes()) == [&quot;Node 1&quot;, &quot;Node 2&quot;, &quot;Node 3&quot;]
        assert [e for e in sorted(G.edges())] == [
            (&quot;Node 1&quot;, &quot;Node 2&quot;),
            (&quot;Node 2&quot;, &quot;Node 3&quot;),
            (&quot;Node 3&quot;, &quot;Node 1&quot;),
        ]

        assert [e for e in sorted(G.edges(data=True))] == [
            (
                &quot;Node 1&quot;,
                &quot;Node 2&quot;,
                {
                    &quot;color&quot;: {&quot;line&quot;: &quot;blue&quot;, &quot;thickness&quot;: 3},
                    &quot;label&quot;: &quot;Edge from node 1 to node 2&quot;,
                },
            ),
            (&quot;Node 2&quot;, &quot;Node 3&quot;, {&quot;label&quot;: &quot;Edge from node 2 to node 3&quot;}),
            (&quot;Node 3&quot;, &quot;Node 1&quot;, {&quot;label&quot;: &quot;Edge from node 3 to node 1&quot;}),
        ]

    def test_read_gml(self):
        (fd, fname) = tempfile.mkstemp()
        fh = open(fname, &quot;w&quot;)
        fh.write(self.simple_data)
        fh.close()
        Gin = nx.read_gml(fname, label=&quot;label&quot;)
        G = nx.parse_gml(self.simple_data, label=&quot;label&quot;)
        assert sorted(G.nodes(data=True)) == sorted(Gin.nodes(data=True))
        assert sorted(G.edges(data=True)) == sorted(Gin.edges(data=True))
        os.close(fd)
        os.unlink(fname)

    def test_labels_are_strings(self):
        # GML requires labels to be strings (i.e., in quotes)
        answer = &quot;&quot;&quot;graph [
  node [
    id 0
    label &quot;1203&quot;
  ]
]&quot;&quot;&quot;
        G = nx.Graph()
        G.add_node(1203)
        data = &quot;\n&quot;.join(nx.generate_gml(G, stringizer=literal_stringizer))
        assert data == answer

    def test_relabel_duplicate(self):
        data = &quot;&quot;&quot;
graph
[
        label   &quot;&quot;
        directed        1
        node
        [
                id      0
                label   &quot;same&quot;
        ]
        node
        [
                id      1
                label   &quot;same&quot;
        ]
]
&quot;&quot;&quot;
        fh = io.BytesIO(data.encode(&quot;UTF-8&quot;))
        fh.seek(0)
        pytest.raises(nx.NetworkXError, nx.read_gml, fh, label=&quot;label&quot;)

    def test_tuplelabels(self):
        # https://github.com/networkx/networkx/pull/1048
        # Writing tuple labels to GML failed.
        G = nx.OrderedGraph()
        G.add_edge((0, 1), (1, 0))
        data = &quot;\n&quot;.join(nx.generate_gml(G, stringizer=literal_stringizer))
        answer = &quot;&quot;&quot;graph [
  node [
    id 0
    label &quot;(0,1)&quot;
  ]
  node [
    id 1
    label &quot;(1,0)&quot;
  ]
  edge [
    source 0
    target 1
  ]
]&quot;&quot;&quot;
        assert data == answer

    def test_quotes(self):
        # https://github.com/networkx/networkx/issues/1061
        # Encoding quotes as HTML entities.
        G = nx.path_graph(1)
        G.name = &quot;path_graph(1)&quot;
        attr = 'This is &quot;quoted&quot; and this is a copyright: ' + chr(169)
        G.nodes[0][&quot;demo&quot;] = attr
        fobj = tempfile.NamedTemporaryFile()
        nx.write_gml(G, fobj)
        fobj.seek(0)
        # Should be bytes in 2.x and 3.x
        data = fobj.read().strip().decode(&quot;ascii&quot;)
        answer = &quot;&quot;&quot;graph [
  name &quot;path_graph(1)&quot;
  node [
    id 0
    label &quot;0&quot;
    demo &quot;This is &amp;#34;quoted&amp;#34; and this is a copyright: &amp;#169;&quot;
  ]
]&quot;&quot;&quot;
        assert data == answer

<A NAME="0"></A>    def test_unicode_node(self):
        node = &quot;node&quot; + chr(169)
        G = nx.Graph()
        G<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match10155-1.html#0',3,'match10155-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.add_node(node)
        fobj = tempfile.NamedTemporaryFile()
        nx.write_gml(G, fobj)
        fobj.seek(0)
        # Should be bytes in 2.x and 3.x
        data = fobj.read().strip(</B></FONT>).decode(&quot;ascii&quot;)
        answer = &quot;&quot;&quot;graph [
  node [
    id 0
    label &quot;node&amp;#169;&quot;
  ]
]&quot;&quot;&quot;
        assert data == answer

    def test_float_label(self):
        node = 1.0
        G = nx.Graph()
        G.add_node(node)
        fobj = tempfile.NamedTemporaryFile()
        nx.write_gml(G, fobj)
        fobj.seek(0)
        # Should be bytes in 2.x and 3.x
        data = fobj.read().strip().decode(&quot;ascii&quot;)
        answer = &quot;&quot;&quot;graph [
  node [
    id 0
    label &quot;1.0&quot;
  ]
]&quot;&quot;&quot;
        assert data == answer

    def test_special_float_label(self):
        special_floats = [float(&quot;nan&quot;), float(&quot;+inf&quot;), float(&quot;-inf&quot;)]
        try:
            import numpy as np

            special_floats += [np.nan, np.inf, np.inf * -1]
        except ImportError:
            special_floats += special_floats

        G = nx.cycle_graph(len(special_floats))
        attrs = dict(enumerate(special_floats))
        nx.set_node_attributes(G, attrs, &quot;nodefloat&quot;)
        edges = list(G.edges)
        attrs = {edges[i]: value for i, value in enumerate(special_floats)}
        nx.set_edge_attributes(G, attrs, &quot;edgefloat&quot;)

        fobj = tempfile.NamedTemporaryFile()
        nx.write_gml(G, fobj)
        fobj.seek(0)
        # Should be bytes in 2.x and 3.x
        data = fobj.read().strip().decode(&quot;ascii&quot;)
        answer = &quot;&quot;&quot;graph [
  node [
    id 0
    label &quot;0&quot;
    nodefloat NAN
  ]
  node [
    id 1
    label &quot;1&quot;
    nodefloat +INF
  ]
  node [
    id 2
    label &quot;2&quot;
    nodefloat -INF
  ]
  node [
    id 3
    label &quot;3&quot;
    nodefloat NAN
  ]
  node [
    id 4
    label &quot;4&quot;
    nodefloat +INF
  ]
  node [
    id 5
    label &quot;5&quot;
    nodefloat -INF
  ]
  edge [
    source 0
    target 1
    edgefloat NAN
  ]
  edge [
    source 0
    target 5
    edgefloat +INF
  ]
  edge [
    source 1
    target 2
    edgefloat -INF
  ]
  edge [
    source 2
    target 3
    edgefloat NAN
  ]
  edge [
    source 3
    target 4
    edgefloat +INF
  ]
  edge [
    source 4
    target 5
    edgefloat -INF
  ]
]&quot;&quot;&quot;
        assert data == answer

        fobj.seek(0)
        graph = nx.read_gml(fobj)
        for indx, value in enumerate(special_floats):
            node_value = graph.nodes[str(indx)][&quot;nodefloat&quot;]
            if math.isnan(value):
                assert math.isnan(node_value)
            else:
                assert node_value == value

            edge = edges[indx]
            string_edge = (str(edge[0]), str(edge[1]))
            edge_value = graph.edges[string_edge][&quot;edgefloat&quot;]
            if math.isnan(value):
                assert math.isnan(edge_value)
            else:
                assert edge_value == value

    def test_name(self):
        G = nx.parse_gml('graph [ name &quot;x&quot; node [ id 0 label &quot;x&quot; ] ]')
        assert &quot;x&quot; == G.graph[&quot;name&quot;]
        G = nx.parse_gml('graph [ node [ id 0 label &quot;x&quot; ] ]')
        assert &quot;&quot; == G.name
        assert &quot;name&quot; not in G.graph

    def test_graph_types(self):
        for directed in [None, False, True]:
            for multigraph in [None, False, True]:
                gml = &quot;graph [&quot;
                if directed is not None:
                    gml += &quot; directed &quot; + str(int(directed))
                if multigraph is not None:
                    gml += &quot; multigraph &quot; + str(int(multigraph))
                gml += ' node [ id 0 label &quot;0&quot; ]'
                gml += &quot; edge [ source 0 target 0 ]&quot;
                gml += &quot; ]&quot;
                G = nx.parse_gml(gml)
                assert bool(directed) == G.is_directed()
                assert bool(multigraph) == G.is_multigraph()
                gml = &quot;graph [\n&quot;
                if directed is True:
                    gml += &quot;  directed 1\n&quot;
                if multigraph is True:
                    gml += &quot;  multigraph 1\n&quot;
                gml += &quot;&quot;&quot;  node [
    id 0
    label &quot;0&quot;
  ]
  edge [
    source 0
    target 0
&quot;&quot;&quot;
                if multigraph:
                    gml += &quot;    key 0\n&quot;
                gml += &quot;  ]\n]&quot;
                assert gml == &quot;\n&quot;.join(nx.generate_gml(G))

    def test_data_types(self):
        data = [
            True,
            False,
            10 ** 20,
            -2e33,
            &quot;'&quot;,
            '&quot;&amp;&amp;amp;&amp;&amp;#34;&quot;',
            [{(b&quot;\xfd&quot;,): &quot;\x7f&quot;, chr(0x4444): (1, 2)}, (2, &quot;3&quot;)],
        ]
        data.append(chr(0x14444))
        data.append(literal_eval(&quot;{2.3j, 1 - 2.3j, ()}&quot;))
        G = nx.Graph()
        G.name = data
        G.graph[&quot;data&quot;] = data
        G.add_node(0, int=-1, data=dict(data=data))
        G.add_edge(0, 0, float=-2.5, data=data)
        gml = &quot;\n&quot;.join(nx.generate_gml(G, stringizer=literal_stringizer))
        G = nx.parse_gml(gml, destringizer=literal_destringizer)
        assert data == G.name
        assert {&quot;name&quot;: data, &quot;data&quot;: data} == G.graph
        assert list(G.nodes(data=True)) == [(0, dict(int=-1, data=dict(data=data)))]
        assert list(G.edges(data=True)) == [(0, 0, dict(float=-2.5, data=data))]
        G = nx.Graph()
        G.graph[&quot;data&quot;] = &quot;frozenset([1, 2, 3])&quot;
        G = nx.parse_gml(nx.generate_gml(G), destringizer=literal_eval)
        assert G.graph[&quot;data&quot;] == &quot;frozenset([1, 2, 3])&quot;

    def test_escape_unescape(self):
        gml = &quot;&quot;&quot;graph [
  name &quot;&amp;amp;&amp;#34;&amp;#xf;&amp;#x4444;&amp;#1234567890;&amp;#x1234567890abcdef;&amp;unknown;&quot;
]&quot;&quot;&quot;
        G = nx.parse_gml(gml)
        assert (
            '&amp;&quot;\x0f' + chr(0x4444) + &quot;&amp;#1234567890;&amp;#x1234567890abcdef;&amp;unknown;&quot;
            == G.name
        )
        gml = &quot;\n&quot;.join(nx.generate_gml(G))
        alnu = &quot;#1234567890;&amp;#38;#x1234567890abcdef&quot;
        answer = (
            &quot;&quot;&quot;graph [
  name &quot;&amp;#38;&amp;#34;&amp;#15;&amp;#17476;&amp;#38;&quot;&quot;&quot;
            + alnu
            + &quot;&quot;&quot;;&amp;#38;unknown;&quot;
]&quot;&quot;&quot;
        )
        assert answer == gml

    def test_exceptions(self):
        pytest.raises(ValueError, literal_destringizer, &quot;(&quot;)
        pytest.raises(ValueError, literal_destringizer, &quot;frozenset([1, 2, 3])&quot;)
        pytest.raises(ValueError, literal_destringizer, literal_destringizer)
        pytest.raises(ValueError, literal_stringizer, frozenset([1, 2, 3]))
        pytest.raises(ValueError, literal_stringizer, literal_stringizer)
        with tempfile.TemporaryFile() as f:
            f.write(codecs.BOM_UTF8 + b&quot;graph[]&quot;)
            f.seek(0)
            pytest.raises(nx.NetworkXError, nx.read_gml, f)

        def assert_parse_error(gml):
            pytest.raises(nx.NetworkXError, nx.parse_gml, gml)

        assert_parse_error([&quot;graph [\n\n&quot;, &quot;]&quot;])
        assert_parse_error(&quot;&quot;)
        assert_parse_error('Creator &quot;&quot;')
        assert_parse_error(&quot;0&quot;)
        assert_parse_error(&quot;graph ]&quot;)
        assert_parse_error(&quot;graph [ 1 ]&quot;)
        assert_parse_error(&quot;graph [ 1.E+2 ]&quot;)
        assert_parse_error('graph [ &quot;A&quot; ]')
        assert_parse_error(&quot;graph [ ] graph ]&quot;)
        assert_parse_error(&quot;graph [ ] graph [ ]&quot;)
        assert_parse_error(&quot;graph [ data [1, 2, 3] ]&quot;)
        assert_parse_error(&quot;graph [ node [ ] ]&quot;)
        assert_parse_error(&quot;graph [ node [ id 0 ] ]&quot;)
        nx.parse_gml('graph [ node [ id &quot;a&quot; ] ]', label=&quot;id&quot;)
        assert_parse_error(&quot;graph [ node [ id 0 label 0 ] node [ id 0 label 1 ] ]&quot;)
        assert_parse_error(&quot;graph [ node [ id 0 label 0 ] node [ id 1 label 0 ] ]&quot;)
        assert_parse_error(&quot;graph [ node [ id 0 label 0 ] edge [ ] ]&quot;)
        assert_parse_error(&quot;graph [ node [ id 0 label 0 ] edge [ source 0 ] ]&quot;)
        nx.parse_gml(&quot;graph [edge [ source 0 target 0 ] node [ id 0 label 0 ] ]&quot;)
        assert_parse_error(&quot;graph [ node [ id 0 label 0 ] edge [ source 1 target 0 ] ]&quot;)
        assert_parse_error(&quot;graph [ node [ id 0 label 0 ] edge [ source 0 target 1 ] ]&quot;)
        assert_parse_error(
            &quot;graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] &quot;
            &quot;edge [ source 0 target 1 ] edge [ source 1 target 0 ] ]&quot;
        )
        nx.parse_gml(
            &quot;graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] &quot;
            &quot;edge [ source 0 target 1 ] edge [ source 1 target 0 ] &quot;
            &quot;directed 1 ]&quot;
        )
        nx.parse_gml(
            &quot;graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] &quot;
            &quot;edge [ source 0 target 1 ] edge [ source 0 target 1 ]&quot;
            &quot;multigraph 1 ]&quot;
        )
        nx.parse_gml(
            &quot;graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] &quot;
            &quot;edge [ source 0 target 1 key 0 ] edge [ source 0 target 1 ]&quot;
            &quot;multigraph 1 ]&quot;
        )
        assert_parse_error(
            &quot;graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] &quot;
            &quot;edge [ source 0 target 1 key 0 ] edge [ source 0 target 1 key 0 ]&quot;
            &quot;multigraph 1 ]&quot;
        )
        nx.parse_gml(
            &quot;graph [ node [ id 0 label 0 ] node [ id 1 label 1 ] &quot;
            &quot;edge [ source 0 target 1 key 0 ] edge [ source 1 target 0 key 0 ]&quot;
            &quot;directed 1 multigraph 1 ]&quot;
        )

        # Tests for string convertable alphanumeric id and label values
        nx.parse_gml(&quot;graph [edge [ source a target a ] node [ id a label b ] ]&quot;)
        nx.parse_gml(
            &quot;graph [ node [ id n42 label 0 ] node [ id x43 label 1 ]&quot;
            &quot;edge [ source n42 target x43 key 0 ]&quot;
            &quot;edge [ source x43 target n42 key 0 ]&quot;
            &quot;directed 1 multigraph 1 ]&quot;
        )
        assert_parse_error(
            &quot;graph [edge [ source u'u\4200' target u'u\4200' ] &quot;
            + &quot;node [ id u'u\4200' label b ] ]&quot;
        )

        def assert_generate_error(*args, **kwargs):
            pytest.raises(
                nx.NetworkXError, lambda: list(nx.generate_gml(*args, **kwargs))
            )

        G = nx.Graph()
        G.graph[3] = 3
        assert_generate_error(G)
        G = nx.Graph()
        G.graph[&quot;3&quot;] = 3
        assert_generate_error(G)
        G = nx.Graph()
        G.graph[&quot;data&quot;] = frozenset([1, 2, 3])
        assert_generate_error(G, stringizer=literal_stringizer)
        G = nx.Graph()
        G.graph[&quot;data&quot;] = []
        assert_generate_error(G)
        assert_generate_error(G, stringizer=len)

    def test_label_kwarg(self):
        G = nx.parse_gml(self.simple_data, label=&quot;id&quot;)
        assert sorted(G.nodes) == [1, 2, 3]
        labels = [G.nodes[n][&quot;label&quot;] for n in sorted(G.nodes)]
        assert labels == [&quot;Node 1&quot;, &quot;Node 2&quot;, &quot;Node 3&quot;]

        G = nx.parse_gml(self.simple_data, label=None)
        assert sorted(G.nodes) == [1, 2, 3]
        labels = [G.nodes[n][&quot;label&quot;] for n in sorted(G.nodes)]
        assert labels == [&quot;Node 1&quot;, &quot;Node 2&quot;, &quot;Node 3&quot;]

    def test_outofrange_integers(self):
        # GML restricts integers to 32 signed bits.
        # Check that we honor this restriction on export
        G = nx.Graph()
        # Test export for numbers that barely fit or don't fit into 32 bits,
        # and 3 numbers in the middle
        numbers = {
            &quot;toosmall&quot;: (-(2 ** 31)) - 1,
            &quot;small&quot;: -(2 ** 31),
            &quot;med1&quot;: -4,
            &quot;med2&quot;: 0,
            &quot;med3&quot;: 17,
            &quot;big&quot;: (2 ** 31) - 1,
            &quot;toobig&quot;: 2 ** 31,
        }
        G.add_node(&quot;Node&quot;, **numbers)

        fd, fname = tempfile.mkstemp()
        try:
            nx.write_gml(G, fname)
            # Check that the export wrote the nonfitting numbers as strings
            G2 = nx.read_gml(fname)
            for attr, value in G2.nodes[&quot;Node&quot;].items():
                if attr == &quot;toosmall&quot; or attr == &quot;toobig&quot;:
                    assert type(value) == str
                else:
                    assert type(value) == int
        finally:
            os.close(fd)
            os.unlink(fname)


@contextmanager
def byte_file():
    _file_handle = io.BytesIO()
    yield _file_handle
    _file_handle.seek(0)


class TestPropertyLists:
    def test_writing_graph_with_multi_element_property_list(self):
        g = nx.Graph()
        g.add_node(&quot;n1&quot;, properties=[&quot;element&quot;, 0, 1, 2.5, True, False])
        with byte_file() as f:
            nx.write_gml(g, f)
        result = f.read().decode()

        assert result == dedent(
            &quot;&quot;&quot;\
            graph [
              node [
                id 0
                label &quot;n1&quot;
                properties &quot;element&quot;
                properties 0
                properties 1
                properties 2.5
                properties 1
                properties 0
              ]
            ]
        &quot;&quot;&quot;
        )

    def test_writing_graph_with_one_element_property_list(self):
        g = nx.Graph()
        g.add_node(&quot;n1&quot;, properties=[&quot;element&quot;])
        with byte_file() as f:
            nx.write_gml(g, f)
        result = f.read().decode()

        assert result == dedent(
            &quot;&quot;&quot;\
            graph [
              node [
                id 0
                label &quot;n1&quot;
                properties &quot;_networkx_list_start&quot;
                properties &quot;element&quot;
              ]
            ]
        &quot;&quot;&quot;
        )

    def test_reading_graph_with_list_property(self):
        with byte_file() as f:
            f.write(
                dedent(
                    &quot;&quot;&quot;
              graph [
                node [
                  id 0
                  label &quot;n1&quot;
                  properties &quot;element&quot;
                  properties 0
                  properties 1
                  properties 2.5
                ]
              ]
            &quot;&quot;&quot;
                ).encode(&quot;ascii&quot;)
            )
            f.seek(0)
            graph = nx.read_gml(f)
        assert graph.nodes(data=True)[&quot;n1&quot;] == {&quot;properties&quot;: [&quot;element&quot;, 0, 1, 2.5]}

    def test_reading_graph_with_single_element_list_property(self):
        with byte_file() as f:
            f.write(
                dedent(
                    &quot;&quot;&quot;
              graph [
                node [
                  id 0
                  label &quot;n1&quot;
                  properties &quot;_networkx_list_start&quot;
                  properties &quot;element&quot;
                ]
              ]
            &quot;&quot;&quot;
                ).encode(&quot;ascii&quot;)
            )
            f.seek(0)
            graph = nx.read_gml(f)
        assert graph.nodes(data=True)[&quot;n1&quot;] == {&quot;properties&quot;: [&quot;element&quot;]}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>plot_subgraphs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
=========
Subgraphs
=========
Example of partitioning a directed graph with nodes labeled as
supported and unsupported nodes into a list of subgraphs
that contain only entirely supported or entirely unsupported nodes.
Adopted from 
https://github.com/lobpcg/python_examples/blob/master/networkx_example.py
&quot;&quot;&quot;

import networkx as nx
import matplotlib.pyplot as plt


def graph_partitioning(G, plotting=True):
    &quot;&quot;&quot;Partition a directed graph into a list of subgraphs that contain
    only entirely supported or entirely unsupported nodes.
    &quot;&quot;&quot;
    # Categorize nodes by their node_type attribute
    supported_nodes = {n for n, d in G.nodes(data=&quot;node_type&quot;) if d == &quot;supported&quot;}
    unsupported_nodes = {n for n, d in G.nodes(data=&quot;node_type&quot;) if d == &quot;unsupported&quot;}

    # Make a copy of the graph.
    H = G.copy()
    # Remove all edges connecting supported and unsupported nodes.
    H.remove_edges_from(
        (n, nbr, d)
        for n, nbrs in G.adj.items()
        if n in supported_nodes
        for nbr, d in nbrs.items()
        if nbr in unsupported_nodes
    )
    H.remove_edges_from(
        (n, nbr, d)
        for n, nbrs in G.adj.items()
        if n in unsupported_nodes
        for nbr, d in nbrs.items()
        if nbr in supported_nodes
    )

    # Collect all removed edges for reconstruction.
    G_minus_H = nx.DiGraph()
    G_minus_H.add_edges_from(set(G.edges) - set(H.edges))

    if plotting:
        # Plot the stripped graph with the edges removed.
        _node_colors = [c for _, c in H.nodes(data=&quot;node_color&quot;)]
        _pos = nx.spring_layout(H)
<A NAME="0"></A>        plt.figure(figsize=(8, 8))
        nx.draw_networkx_edges(H, _pos, alpha=0.3, edge_color=&quot;k&quot;)
        nx.draw_networkx_nodes(H, _pos, node_color=_node_colors)
        nx<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match10155-0.html#0',2,'match10155-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.draw_networkx_labels(H, _pos, font_size=14)
        plt.axis(&quot;off&quot;)
        plt.title(&quot;The stripped graph with the edges removed.&quot;)
        plt.show()
        # Plot the the edges removed.
        _pos = nx.spring_layout(G_minus_H)
        plt.figure(</B></FONT>figsize=(8, 8))
        ncl = [G.nodes[n][&quot;node_color&quot;] for n in G_minus_H.nodes]
        nx.draw_networkx_edges(G_minus_H, _pos, alpha=0.3, edge_color=&quot;k&quot;)
        nx.draw_networkx_nodes(G_minus_H, _pos, node_color=ncl)
        nx.draw_networkx_labels(G_minus_H, _pos, font_size=14)
        plt.axis(&quot;off&quot;)
        plt.title(&quot;The removed edges.&quot;)
        plt.show()

    # Find the connected components in the stripped undirected graph.
    # And use the sets, specifying the components, to partition
    # the original directed graph into a list of directed subgraphs
    # that contain only entirely supported or entirely unsupported nodes.
    subgraphs = [
        H.subgraph(c).copy() for c in nx.connected_components(H.to_undirected())
    ]

    return subgraphs, G_minus_H


###############################################################################
# Create an example directed graph.
# ---------------------------------
#
# This directed graph has one input node labeled `in` and plotted in blue color
# and one output node labeled `out` and plotted in magenta color.
# The other six nodes are classified as four `supported` plotted in green color
# and two `unsupported` plotted in red color. The goal is computing a list
# of subgraphs that contain only entirely `supported` or `unsupported` nodes.
G_ex = nx.DiGraph()
G_ex.add_nodes_from([&quot;In&quot;], node_type=&quot;input&quot;, node_color=&quot;b&quot;)
G_ex.add_nodes_from([&quot;A&quot;, &quot;C&quot;, &quot;E&quot;, &quot;F&quot;], node_type=&quot;supported&quot;, node_color=&quot;g&quot;)
G_ex.add_nodes_from([&quot;B&quot;, &quot;D&quot;], node_type=&quot;unsupported&quot;, node_color=&quot;r&quot;)
G_ex.add_nodes_from([&quot;Out&quot;], node_type=&quot;output&quot;, node_color=&quot;m&quot;)
G_ex.add_edges_from(
    [
        (&quot;In&quot;, &quot;A&quot;),
        (&quot;A&quot;, &quot;B&quot;),
        (&quot;B&quot;, &quot;C&quot;),
        (&quot;B&quot;, &quot;D&quot;),
        (&quot;D&quot;, &quot;E&quot;),
        (&quot;C&quot;, &quot;F&quot;),
        (&quot;E&quot;, &quot;F&quot;),
        (&quot;F&quot;, &quot;Out&quot;),
    ]
)

###############################################################################
# Plot the original graph.
# ------------------------
#
node_color_list = [nc for _, nc in G_ex.nodes(data=&quot;node_color&quot;)]
pos = nx.spectral_layout(G_ex)
plt.figure(figsize=(8, 8))
nx.draw_networkx_edges(G_ex, pos, alpha=0.3, edge_color=&quot;k&quot;)
nx.draw_networkx_nodes(G_ex, pos, alpha=0.8, node_color=node_color_list)
nx.draw_networkx_labels(G_ex, pos, font_size=14)
plt.axis(&quot;off&quot;)
plt.title(&quot;The original graph.&quot;)
plt.show()

###############################################################################
# Calculate the subgraphs with plotting all results of intemediate steps.
# -----------------------------------------------------------------------
#
subgraphs_of_G_ex, removed_edges = graph_partitioning(G_ex, plotting=True)

###############################################################################
# Plot the results: every subgraph in the list.
# ---------------------------------------------
#
for subgraph in subgraphs_of_G_ex:
    _pos = nx.spring_layout(subgraph)
    plt.figure(figsize=(8, 8))
    nx.draw_networkx_edges(subgraph, _pos, alpha=0.3, edge_color=&quot;k&quot;)
    node_color_list_c = [nc for _, nc in subgraph.nodes(data=&quot;node_color&quot;)]
    nx.draw_networkx_nodes(subgraph, _pos, node_color=node_color_list_c)
    nx.draw_networkx_labels(subgraph, _pos, font_size=14)
    plt.axis(&quot;off&quot;)
    plt.title(&quot;One of the subgraphs.&quot;)
    plt.show()

###############################################################################
# Put the graph back from the list of subgraphs
# ---------------------------------------------
#
G_ex_r = nx.DiGraph()
# Composing all subgraphs.
for subgraph in subgraphs_of_G_ex:
    G_ex_r = nx.compose(G_ex_r, subgraph)
# Adding the previously stored edges.
G_ex_r.add_edges_from(removed_edges.edges())

###############################################################################
# Check that the original graph and the reconstructed graphs are isomorphic.
# --------------------------------------------------------------------------
#
assert nx.is_isomorphic(G_ex, G_ex_r)

###############################################################################
# Plot the reconstructed graph.
# -----------------------------
#
node_color_list = [nc for _, nc in G_ex_r.nodes(data=&quot;node_color&quot;)]
pos = nx.spectral_layout(G_ex_r)
plt.figure(figsize=(8, 8))
nx.draw_networkx_edges(G_ex_r, pos, alpha=0.3, edge_color=&quot;k&quot;)
nx.draw_networkx_nodes(G_ex_r, pos, alpha=0.8, node_color=node_color_list)
nx.draw_networkx_labels(G_ex_r, pos, font_size=14)
plt.axis(&quot;off&quot;)
plt.title(&quot;The reconstructed graph.&quot;)
plt.show()
</PRE>
</div>
  </div>
</body>
</html>
