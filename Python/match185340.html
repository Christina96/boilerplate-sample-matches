<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for zfs.py &amp; vmware_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for zfs.py &amp; vmware_1.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>zfs.py (18.007664%)<th>vmware_1.py (0.9686727%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(62-82)<td><a href="#" name="0">(818-824)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(218-301)<td><a href="#" name="1">(2455-2467)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(106-124)<td><a href="#" name="2">(795-797)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zfs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import salt.utils.zfs
from tests.support.mock import MagicMock, patch
class ZFSMockData:
    def __init__(self):
        self.pmap_exec_zpool = {
            "retcode": 2,
            "stdout": "",
            "stderr": "\n".join(
                [
                    "missing property argument",
                    "usage:",
                    '        get [-Hp] [-o "all" | field[,...]] &lt;"all" |'
                    " property[,...]&gt; &lt;pool&gt; ...",
                    "",
                    "the following properties are supported:",
                    "",
                    "        PROPERTY         EDIT   VALUES",
                    "",
                    "        allocated          NO   &lt;size&gt;",
                    "        capacity           NO   &lt;size&gt;",
                    "        dedupratio         NO   &lt;1.00x or higher if deduped&gt;",
                    "        expandsize         NO   &lt;size&gt;",
                    "        fragmentation      NO   &lt;percent&gt;",
                    "        free               NO   &lt;size&gt;",
                    "        freeing            NO   &lt;size&gt;",
                    "        guid               NO   &lt;guid&gt;",
                    "        health             NO   &lt;state&gt;",
                    "        leaked             NO   &lt;size&gt;",
                    "        size               NO   &lt;size&gt;",
                    "        altroot           YES   &lt;path&gt;",
                    "        autoexpand        YES   on | off",
                    "        autoreplace       YES   on | off",
                    "        bootfs            YES   &lt;filesystem&gt;",
                    "        bootsize          YES   &lt;size&gt;",
                    "        cachefile         YES   &lt;file&gt; | none",
                    "        comment           YES   &lt;comment-string&gt;",
                    "        dedupditto        YES   &lt;threshold (min 100)&gt;",
                    "        delegation        YES   on | off",
                    "        failmode          YES   wait | continue | panic",
                    "        listsnapshots     YES   on | off",
                    "        readonly          YES   on | off",
                    "        version           YES   &lt;version&gt;",
                    "        feature@...       YES   disabled | enabled | active",
                    "",
                    "The feature@ properties must be appended with a feature name.",
                    "See zpool-features(5). ",
                ]
<a name="0"></a>            ),
        }
        self.pmap_zpool = {
            <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"comment": {"edit": True, "type": "str", "values": "&lt;comment-string&gt;"},
            "freeing": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "listsnapshots": {"edit": True, "type": "bool", "values": "on | off"},
            "leaked": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "version": {"edit": True, "type": "numeric", "values": "&lt;version&gt;"},
            "write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "replace": {"edit": True, "type": "bool", "values": "on | off"},
            "delegation": {"edit": True, "type": "bool", "values": "on | off"},
            "dedupditto": {
                "edit": True,
                "type": "str",
                "values": "&lt;threshold (min 100)&gt;",
            },
            "autoexpand": {"edit": True, "type": "bool", "values": "on | off"},
            "alloc": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "allocated": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "guid": {"edit": False, "type": "numeric", "values": "&lt;guid&gt;"},
            "size": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "cap": {"edit": False, "type": "numeric", "values": "&lt;count&gt;"},
            "capacity": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "capacity-alloc": {"edit"</b></font>: False, "type": "size", "values": "&lt;size&gt;"},
            "capacity-free": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "cachefile": {"edit": True, "type": "str", "values": "&lt;file&gt; | none"},
            "cksum": {"edit": False, "type": "numeric", "values": "&lt;count&gt;"},
            "bootfs": {"edit": True, "type": "str", "values": "&lt;filesystem&gt;"},
            "autoreplace": {"edit": True, "type": "bool", "values": "on | off"},
            "bandwidth-read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "bandwidth-write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "operations-read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "operations-write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "readonly": {"edit": True, "type": "bool", "values": "on | off"},
            "dedupratio": {
                "edit": False,
                "type": "str",
                "values": "&lt;1.00x or higher if deduped&gt;",
            },
            "health": {"edit": False, "type": "str", "values": "&lt;state&gt;"},
            "feature@": {
                "edit": True,
                "type": "str",
<a name="2"></a>                "values": "disabled | enabled | active",
            },
            "expandsize": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "listsnaps": {<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"edit": True, "type": "bool", "values": "on | off"},
            "bootsize": {"edit": True, "type": "size", "values": "&lt;size&gt;"},
            "free": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
            "failmode": {
                "edit": True,
                "type": "str",
                "values": "wait | continue | panic",
            },
            "altroot": {"edit": True, "type": "str", "values": "&lt;path&gt;"},
            "expand": {"edit": True, "type": "bool", "values": "on | off"},
            "frag": {"edit": False, "type": "str", "values": "&lt;percent&gt;"},
            "fragmentation": {"edit": False, "type": "str", "values": "&lt;percent&gt;"},
        }
        self.pmap_exec_zfs = {
            "retcode": 2,
            "stdout": "",
            "stderr": "\n".</b></font>join(
                [
                    "missing property argument",
                    "usage:",
                    '        get [-crHp] [-d max] [-o "all" | field[,...]]',
                    "            [-t type[,...]] [-s source[,...]]",
                    '            &lt;"all" | property[,...]&gt;'
                    " [filesystem|volume|snapshot|bookmark] ...",
                    "",
                    "The following properties are supported:",
                    "",
                    "        PROPERTY       EDIT  INHERIT   VALUES",
                    "",
                    "        available        NO       NO   &lt;size&gt;",
                    "        clones           NO       NO   &lt;dataset&gt;[,...]",
                    "        compressratio    NO       NO   &lt;1.00x or higher if compressed&gt;",
                    "        creation         NO       NO   &lt;date&gt;",
                    "        defer_destroy    NO       NO   yes | no",
                    "        filesystem_count  NO       NO   &lt;count&gt;",
                    "        logicalreferenced  NO       NO   &lt;size&gt;",
                    "        logicalused      NO       NO   &lt;size&gt;",
                    "        mounted          NO       NO   yes | no",
                    "        origin           NO       NO   &lt;snapshot&gt;",
                    "        receive_resume_token  NO       NO   &lt;string token&gt;",
                    "        refcompressratio  NO       NO   &lt;1.00x or higher if compressed&gt;",
                    "        referenced       NO       NO   &lt;size&gt;",
                    "        snapshot_count   NO       NO   &lt;count&gt;",
                    "        type             NO       NO   filesystem | volume | snapshot | bookmark",
                    "        used             NO       NO   &lt;size&gt;",
                    "        usedbychildren   NO       NO   &lt;size&gt;",
                    "        usedbydataset    NO       NO   &lt;size&gt;",
                    "        usedbyrefreservation  NO       NO   &lt;size&gt;",
                    "        usedbysnapshots  NO       NO   &lt;size&gt;",
                    "        userrefs         NO       NO   &lt;count&gt;",
                    "        written          NO       NO   &lt;size&gt;",
                    "        aclinherit      YES      YES   discard | noallow | restricted | passthrough | passthrough-x",
                    "        aclmode         YES      YES   discard | groupmask | passthrough | restricted",
                    "        atime           YES      YES   on | off",
                    "        canmount        YES       NO   on | off | noauto",
                    "        casesensitivity  NO      YES   sensitive | insensitive | mixed",
                    "        checksum        YES      YES   on | off | fletcher2 | fletcher4 | sha256 | sha512 | skein | edonr",
                    "        compression     YES      YES   on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
                    "        copies          YES      YES   1 | 2 | 3",
                    "        dedup           YES      YES   on | off | verify | sha256[,verify], sha512[,verify], skein[,verify], edonr,verify",
                    "        devices         YES      YES   on | off",
                    "        exec            YES      YES   on | off",
                    "        filesystem_limit YES       NO   &lt;count&gt; | none",
                    "        logbias         YES      YES   latency | throughput",
                    "        mlslabel        YES      YES   &lt;sensitivity label&gt;",
                    "        mountpoint      YES      YES   &lt;path&gt; | legacy | none",
                    "        nbmand          YES      YES   on | off",
                    "        normalization    NO      YES   none | formC | formD | formKC | formKD",
                    "        primarycache    YES      YES   all | none | metadata",
                    "        quota           YES       NO   &lt;size&gt; | none",
                    "        readonly        YES      YES   on | off",
                    "        recordsize      YES      YES   512 to 1M, power of 2",
                    "        redundant_metadata YES      YES   all | most",
                    "        refquota        YES       NO   &lt;size&gt; | none",
                    "        refreservation  YES       NO   &lt;size&gt; | none",
                    "        reservation     YES       NO   &lt;size&gt; | none",
                    "        secondarycache  YES      YES   all | none | metadata",
                    "        setuid          YES      YES   on | off",
                    "        sharenfs        YES      YES   on | off | share(1M) options",
                    "        sharesmb        YES      YES   on | off | sharemgr(1M) options",
                    "        snapdir         YES      YES   hidden | visible",
                    "        snapshot_limit  YES       NO   &lt;count&gt; | none",
                    "        sync            YES      YES   standard | always | disabled",
                    "        utf8only         NO      YES   on | off",
                    "        version         YES       NO   1 | 2 | 3 | 4 | 5 | current",
                    "        volblocksize     NO      YES   512 to 128k, power of 2",
                    "        volsize         YES       NO   &lt;size&gt;",
                    "        vscan           YES      YES   on | off",
                    "        xattr           YES      YES   on | off",
                    "        zoned           YES      YES   on | off",
                    "        userused@...     NO       NO   &lt;size&gt;",
                    "        groupused@...    NO       NO   &lt;size&gt;",
                    "        userquota@...   YES       NO   &lt;size&gt; | none",
                    "        groupquota@...  YES       NO   &lt;size&gt; | none",
                    "        written@&lt;snap&gt;   NO       NO   &lt;size&gt;",
                    "",
                    "Sizes are specified in bytes with standard units such as K, M, G, etc.",
                    "",
                    "User-defined properties can be specified by using a name containing a colon (:).",
                    "",
                    "The {user|group}{used|quota}@ properties must be appended with",
                    "a user or group specifier of one of these forms:",
                    '    POSIX name      (eg: "matt")',
                    '    POSIX id        (eg: "126829")',
                    '    SMB name@domain (eg: "matt@sun")',
                    '    SMB SID         (eg: "S-1-234-567-89")',
                ]
<a name="1"></a>            ),
        }
        self.pmap_zfs <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
            "origin": {
                "edit": False,
                "inherit": False,
                "values": "&lt;snapshot&gt;",
                "type": "str",
            },
            "setuid": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "referenced": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "vscan": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "logicalused": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "userrefs": {
                "edit": False,
                "inherit": False,
                "values": "&lt;count&gt;",
                "type": "numeric",
            },
            "primarycache": {
                "edit": True,
                "inherit": True,
                "values": "all | none | metadata",
                "type": "str",
            },
            "logbias": {
                "edit": True,
                "inherit": True,
                "values": "latency | throughput",
                "type": "str",
            },
            "creation": {
                "edit": False,
                "inherit": False,
                "values": "&lt;date&gt;",
                "type": "str",
            },
            "sync": {
                "edit": True,
                "inherit": True,
                "values": "standard | always | disabled",
                "type": "str",
            },
            "dedup": {
                "edit": True,
                "inherit": True,
                "values": (
                    "on | off | verify | sha256[,verify], sha512[,verify],"
                    " skein[,verify], edonr,verify"
                ),
                "type": "bool",
            },
            "sharenfs": {
                "edit": True,
                "inherit": True,
                "values": "on | off | share(1m) options",
                "type": "bool",
            },
            "receive_resume_token": {
                "edit": False,
                "inherit": False,
                "values": "&lt;string token&gt;",
                "type": "str",
            },
            "usedbyrefreservation": {
                "edit"</b></font>: False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "sharesmb": {
                "edit": True,
                "inherit": True,
                "values": "on | off | sharemgr(1m) options",
                "type": "bool",
            },
            "rdonly": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "reservation": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "reserv": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "mountpoint": {
                "edit": True,
                "inherit": True,
                "values": "&lt;path&gt; | legacy | none",
                "type": "str",
            },
            "casesensitivity": {
                "edit": False,
                "inherit": True,
                "values": "sensitive | insensitive | mixed",
                "type": "str",
            },
            "utf8only": {
                "edit": False,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "usedbysnapshots": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "readonly": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "written@": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "avail": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "recsize": {
                "edit": True,
                "inherit": True,
                "values": "512 to 1m, power of 2",
                "type": "str",
            },
            "atime": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "compression": {
                "edit": True,
                "inherit": True,
                "values": "on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
                "type": "bool",
            },
            "snapdir": {
                "edit": True,
                "inherit": True,
                "values": "hidden | visible",
                "type": "str",
            },
            "aclmode": {
                "edit": True,
                "inherit": True,
                "values": "discard | groupmask | passthrough | restricted",
                "type": "str",
            },
            "zoned": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "copies": {
                "edit": True,
                "inherit": True,
                "values": "1 | 2 | 3",
                "type": "numeric",
            },
            "snapshot_limit": {
                "edit": True,
                "inherit": False,
                "values": "&lt;count&gt; | none",
                "type": "numeric",
            },
            "aclinherit": {
                "edit": True,
                "inherit": True,
                "values": (
                    "discard | noallow | restricted | passthrough | passthrough-x"
                ),
                "type": "str",
            },
            "compressratio": {
                "edit": False,
                "inherit": False,
                "values": "&lt;1.00x or higher if compressed&gt;",
                "type": "str",
            },
            "xattr": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "written": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "version": {
                "edit": True,
                "inherit": False,
                "values": "1 | 2 | 3 | 4 | 5 | current",
                "type": "numeric",
            },
            "recordsize": {
                "edit": True,
                "inherit": True,
                "values": "512 to 1m, power of 2",
                "type": "str",
            },
            "refquota": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "filesystem_limit": {
                "edit": True,
                "inherit": False,
                "values": "&lt;count&gt; | none",
                "type": "numeric",
            },
            "lrefer.": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "type": {
                "edit": False,
                "inherit": False,
                "values": "filesystem | volume | snapshot | bookmark",
                "type": "str",
            },
            "secondarycache": {
                "edit": True,
                "inherit": True,
                "values": "all | none | metadata",
                "type": "str",
            },
            "refer": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "available": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "used": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "exec": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "compress": {
                "edit": True,
                "inherit": True,
                "values": "on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
                "type": "bool",
            },
            "volblock": {
                "edit": False,
                "inherit": True,
                "values": "512 to 128k, power of 2",
                "type": "str",
            },
            "refcompressratio": {
                "edit": False,
                "inherit": False,
                "values": "&lt;1.00x or higher if compressed&gt;",
                "type": "str",
            },
            "quota": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "groupquota@": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "userquota@": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "snapshot_count": {
                "edit": False,
                "inherit": False,
                "values": "&lt;count&gt;",
                "type": "numeric",
            },
            "volsize": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "clones": {
                "edit": False,
                "inherit": False,
                "values": "&lt;dataset&gt;[,...]",
                "type": "str",
            },
            "canmount": {
                "edit": True,
                "inherit": False,
                "values": "on | off | noauto",
                "type": "bool",
            },
            "mounted": {
                "edit": False,
                "inherit": False,
                "values": "yes | no",
                "type": "bool_alt",
            },
            "groupused@": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "normalization": {
                "edit": False,
                "inherit": True,
                "values": "none | formc | formd | formkc | formkd",
                "type": "str",
            },
            "usedbychildren": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "usedbydataset": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "mlslabel": {
                "edit": True,
                "inherit": True,
                "values": "&lt;sensitivity label&gt;",
                "type": "str",
            },
            "refreserv": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "defer_destroy": {
                "edit": False,
                "inherit": False,
                "values": "yes | no",
                "type": "bool_alt",
            },
            "volblocksize": {
                "edit": False,
                "inherit": True,
                "values": "512 to 128k, power of 2",
                "type": "str",
            },
            "lused.": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "redundant_metadata": {
                "edit": True,
                "inherit": True,
                "values": "all | most",
                "type": "str",
            },
            "filesystem_count": {
                "edit": False,
                "inherit": False,
                "values": "&lt;count&gt;",
                "type": "numeric",
            },
            "devices": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
            "refreservation": {
                "edit": True,
                "inherit": False,
                "values": "&lt;size&gt; | none",
                "type": "size",
            },
            "userused@": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "logicalreferenced": {
                "edit": False,
                "inherit": False,
                "values": "&lt;size&gt;",
                "type": "size",
            },
            "checksum": {
                "edit": True,
                "inherit": True,
                "values": (
                    "on | off | fletcher2 | fletcher4 | sha256 | sha512 | skein | edonr"
                ),
                "type": "bool",
            },
            "nbmand": {
                "edit": True,
                "inherit": True,
                "values": "on | off",
                "type": "bool",
            },
        }
    def _from_auto(self, name, value, source="auto"):
        with patch.object(
            salt.utils.zfs,
            "property_data_zpool",
            MagicMock(return_value=self.pmap_zpool),
        ), patch.object(
            salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
        ):
            return salt.utils.zfs.from_auto(name, value, source)
    def _from_auto_dict(self, values, source="auto"):
        with patch.object(
            salt.utils.zfs,
            "property_data_zpool",
            MagicMock(return_value=self.pmap_zpool),
        ), patch.object(
            salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
        ):
            return salt.utils.zfs.from_auto_dict(values, source)
    def _to_auto(self, name, value, source="auto", convert_to_human=True):
        with patch.object(
            salt.utils.zfs,
            "property_data_zpool",
            MagicMock(return_value=self.pmap_zpool),
        ), patch.object(
            salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
        ):
            return salt.utils.zfs.to_auto(name, value, source, convert_to_human)
    def _to_auto_dict(self, values, source="auto", convert_to_human=True):
        with patch.object(
            salt.utils.zfs,
            "property_data_zpool",
            MagicMock(return_value=self.pmap_zpool),
        ), patch.object(
            salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
        ):
            return salt.utils.zfs.to_auto_dict(values, source, convert_to_human)
    def get_patched_utils(self):
        return {
            "zfs.is_supported": MagicMock(return_value=True),
            "zfs.has_feature_flags": MagicMock(return_value=True),
            "zfs.property_data_zpool": MagicMock(return_value=self.pmap_zpool),
            "zfs.property_data_zfs": MagicMock(return_value=self.pmap_zfs),
            "zfs.zpool_command": MagicMock(return_value="/bin/false"),
            "zfs.zfs_command": MagicMock(return_value="/bin/false"),
            "zfs.from_auto_dict": self._from_auto_dict,
            "zfs.from_auto": self._from_auto,
            "zfs.to_auto_dict": self._to_auto_dict,
            "zfs.to_auto": self._to_auto,
        }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vmware_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import atexit
import errno
import logging
import ssl
import time
from http.client import BadStatusLine
import salt.exceptions
import salt.modules.cmdmod
import salt.utils.path
import salt.utils.platform
import salt.utils.stringutils
try:
    from pyVim.connect import GetSi, SmartConnect, Disconnect, GetStub, SoapStubAdapter
    from pyVmomi import vim, vmodl, VmomiSupport
    HAS_PYVMOMI = True
except ImportError:
    HAS_PYVMOMI = False
try:
    from com.vmware.vapi.std.errors_client import Unauthenticated
    from vmware.vapi.vsphere.client import create_vsphere_client
    HAS_VSPHERE_SDK = True
except ImportError:
    HAS_VSPHERE_SDK = False
try:
    import gssapi
    import base64
    HAS_GSSAPI = True
except ImportError:
    HAS_GSSAPI = False
log = logging.getLogger(__name__)
def __virtual__():
    if HAS_PYVMOMI:
        return True
    return False, "Missing dependency: The salt.utils.vmware module requires pyVmomi."
def esxcli(
    host, user, pwd, cmd, protocol=None, port=None, esxi_host=None, credstore=None
):
    esx_cmd = salt.utils.path.which("esxcli")
    if not esx_cmd:
        log.error(
            "Missing dependency: The salt.utils.vmware.esxcli function requires ESXCLI."
        )
        return False
    if port is None:
        port = 443
    if protocol is None:
        protocol = "https"
    if credstore:
        esx_cmd += " --credstore '{}'".format(credstore)
    if not esxi_host:
        esx_cmd += " -s {} -u {} -p '{}' --protocol={} --portnumber={} {}".format(
            host, user, pwd, protocol, port, cmd
        )
    else:
        esx_cmd += " -s {} -h {} -u {} -p '{}' --protocol={} --portnumber={} {}".format(
            host, esxi_host, user, pwd, protocol, port, cmd
        )
    ret = salt.modules.cmdmod.run_all(esx_cmd, output_loglevel="quiet")
    return ret
def get_vsphere_client(
    server, username, password, session=None, verify_ssl=True, ca_bundle=None
):
    if not session:
        session = salt.utils.http.session(verify_ssl=verify_ssl, ca_bundle=ca_bundle)
    client = None
    try:
        client = create_vsphere_client(
            server=server, username=username, password=password, session=session
        )
    except Unauthenticated as err:
        log.trace(err)
    return client
def _get_service_instance(
    host,
    username,
    password,
    protocol,
    port,
    mechanism,
    principal,
    domain,
    verify_ssl=True,
):
    log.trace("Retrieving new service instance")
    token = None
    if mechanism == "userpass":
        if username is None:
            raise salt.exceptions.CommandExecutionError(
                "Login mechanism userpass was specified but the mandatory "
                "parameter 'username' is missing"
            )
        if password is None:
            raise salt.exceptions.CommandExecutionError(
                "Login mechanism userpass was specified but the mandatory "
                "parameter 'password' is missing"
            )
    elif mechanism == "sspi":
        if principal is not None and domain is not None:
            try:
                token = get_gssapi_token(principal, host, domain)
            except Exception as exc:  # pylint: disable=broad-except
                raise salt.exceptions.VMwareConnectionError(str(exc))
        else:
            err_msg = (
                "Login mechanism '{}' was specified but the"
                " mandatory parameters are missing".format(mechanism)
            )
            raise salt.exceptions.CommandExecutionError(err_msg)
    else:
        raise salt.exceptions.CommandExecutionError(
            "Unsupported mechanism: '{}'".format(mechanism)
        )
    log.trace(
        "Connecting using the '%s' mechanism, with username '%s'",
        mechanism,
        username,
    )
    default_msg = (
        "Could not connect to host '{}'. "
        "Please check the debug log for more information.".format(host)
    )
    try:
        if verify_ssl:
            service_instance = SmartConnect(
                host=host,
                user=username,
                pwd=password,
                protocol=protocol,
                port=port,
                b64token=token,
                mechanism=mechanism,
            )
    except TypeError as exc:
        if "unexpected keyword argument" in exc.message:
            log.error(
                "Initial connect to the VMware endpoint failed with %s", exc.message
            )
            log.error(
                "This may mean that a version of PyVmomi EARLIER than 6.0.0.2016.6 is"
                " installed."
            )
            log.error("We recommend updating to that version or later.")
            raise
    except Exception as exc:  # pylint: disable=broad-except
        if (
            isinstance(exc, vim.fault.HostConnectFault)
            and "[SSL: CERTIFICATE_VERIFY_FAILED]" in exc.msg
        ) or "[SSL: CERTIFICATE_VERIFY_FAILED]" in str(exc):
            err_msg = (
                "Could not verify the SSL certificate. You can use "
                "verify_ssl: False if you do not want to verify the "
                "SSL certificate. This is not recommended as it is "
                "considered insecure."
            )
        else:
            log.exception(exc)
            err_msg = exc.msg if hasattr(exc, "msg") else default_msg
        raise salt.exceptions.VMwareConnectionError(err_msg)
    if not verify_ssl:
        try:
            service_instance = SmartConnect(
                host=host,
                user=username,
                pwd=password,
                protocol=protocol,
                port=port,
                sslContext=ssl._create_unverified_context(),
                b64token=token,
                mechanism=mechanism,
            )
        except Exception as exc:  # pylint: disable=broad-except
            if "certificate verify failed" in str(exc):
                context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
                context.verify_mode = ssl.CERT_NONE
                try:
                    service_instance = SmartConnect(
                        host=host,
                        user=username,
                        pwd=password,
                        protocol=protocol,
                        port=port,
                        sslContext=context,
                        b64token=token,
                        mechanism=mechanism,
                    )
                except Exception as exc:  # pylint: disable=broad-except
                    log.exception(exc)
                    err_msg = exc.msg if hasattr(exc, "msg") else str(exc)
                    raise salt.exceptions.VMwareConnectionError(
                        "Could not connect to host '{}': {}".format(host, err_msg)
                    )
            else:
                err_msg = exc.msg if hasattr(exc, "msg") else default_msg
                log.trace(exc)
                raise salt.exceptions.VMwareConnectionError(err_msg)
    atexit.register(Disconnect, service_instance)
    return service_instance
def get_customizationspec_ref(si, customization_spec_name):
    customization_spec_name = si.content.customizationSpecManager.GetCustomizationSpec(
        name=customization_spec_name
    )
    return customization_spec_name
def get_mor_using_container_view(si, obj_type, obj_name):
    inventory = get_inventory(si)
    container = inventory.viewManager.CreateContainerView(
        inventory.rootFolder, [obj_type], True
    )
    for item in container.view:
        if item.name == obj_name:
            return item
    return None
def get_service_instance(
    host,
    username=None,
    password=None,
    protocol=None,
    port=None,
    mechanism="userpass",
    principal=None,
    domain=None,
    verify_ssl=True,
):
    if protocol is None:
        protocol = "https"
    if port is None:
        port = 443
    service_instance = GetSi()
    if service_instance:
        stub = GetStub()
        if salt.utils.platform.is_proxy() or (
            hasattr(stub, "host") and stub.host != ":".join([host, str(port)])
        ):
            Disconnect(service_instance)
            service_instance = None
    if not service_instance:
        service_instance = _get_service_instance(
            host,
            username,
            password,
            protocol,
            port,
            mechanism,
            principal,
            domain,
            verify_ssl=verify_ssl,
        )
    log.trace("Checking connection is still authenticated")
    try:
        service_instance.CurrentTime()
    except vim.fault.NotAuthenticated:
        log.trace("Session no longer authenticating. Reconnecting")
        Disconnect(service_instance)
        service_instance = _get_service_instance(
            host,
            username,
            password,
            protocol,
            port,
            mechanism,
            principal,
            domain,
            verify_ssl=verify_ssl,
        )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    return service_instance
def get_new_service_instance_stub(service_instance, path, ns=None, version=None):
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    stub = service_instance._stub
    hostname = stub.host.split(":")[0]
    session_cookie = stub.cookie.split('"')[1]
    VmomiSupport.GetRequestContext()["vcSessionCookie"] = session_cookie
    new_stub = SoapStubAdapter(
        host=hostname, ns=ns, path=path, version=version, poolSize=0, sslContext=context
    )
    new_stub.cookie = stub.cookie
    return new_stub
def get_service_instance_from_managed_object(mo_ref, name="&lt;unnamed&gt;"):
    """
    Retrieves the service instance from a managed object.
    me_ref
        Reference to a managed object (of type vim.ManagedEntity).
    name
        Name of managed object. This field is optional.
    Function that disconnects from the vCenter server or ESXi host
    service_instance
        The Service Instance from which to obtain managed object references.
    Function that returns True if the connection is made to a vCenter Server and
    False if the connection is made to an ESXi host
    service_instance
        The Service Instance from which to obtain managed object references.
    Returns information of the vCenter or ESXi host
    service_instance
        The Service Instance from which to obtain managed object references.
    Return a reference to a Distributed Virtual Switch object.
    :param service_instance: PyVmomi service instance
    :param dvs_name: Name of DVS to return
    :return: A PyVmomi DVS object
    Helper function that returns a list of PhysicalNics and their information.
    Helper function that returns a list of VirtualNics and their information.
    Helper function that returns a list of Virtual NicManagers
    and their information.
    Return a portgroup object corresponding to the portgroup name on the dvs
    :param dvs: DVS object
    :param portgroup_name: Name of portgroup to return
    :return: Portgroup object
    Return a portgroup object corresponding to the portgroup name on the dvs
    :param dvs: DVS object
    :param portgroup_name: Name of portgroup to return
    :return: Portgroup object
    Get the gssapi token for Kerberos connection
    principal
       The service principal
    host
       Host url where we would like to authenticate
    domain
       Kerberos user domain
    Return hardware info for standard minion grains if the service_instance is a HostAgent type
    service_instance
        The service instance object to get hardware info for
    .. versionadded:: 2016.11.0
            for _vnic in view<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.view[0].configManager.networkSystem.networkConfig.vnic:
                hw_grain_data["ip_interfaces"][_vnic.device] = []
                hw_grain_data["ip4_interfaces"][</b></font>_vnic.device] = []
                hw_grain_data["ip6_interfaces"][_vnic.device] = []
                hw_grain_data["ip_interfaces"][_vnic.device].append(
                    _vnic.spec.ip.ipAddress
                )
                hw_grain_data["ip4_interfaces"][_vnic.device].append(
                    _vnic.spec.ip.ipAddress
                )
                if _vnic.spec.ip.ipV6Config:
                    hw_grain_data["ip6_interfaces"][_vnic.device].append(
                        _vnic.spec.ip.ipV6Config.ipV6Address
                    )
                hw_grain_data["hwaddr_interfaces"][_vnic.device] = _vnic.spec.mac
            hw_grain_data["host"] = view.view[
                0
            ].configManager.networkSystem.dnsConfig.hostName
            hw_grain_data["domain"] = view.view[
<a name="0"></a>                0
            ].configManager.networkSystem.dnsConfig.domainName
            hw_grain_data["fqdn"] = "{}{}{}".format(
                view<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.view[0].configManager.networkSystem.dnsConfig.hostName,
                (
                    "."
                    if view.view[0].configManager.networkSystem.dnsConfig.domainName
                    else ""
                ),
                view.view[0].configManager.networkSystem.dnsConfig.</b></font>domainName,
            )
            for _pnic in view.view[0].configManager.networkSystem.networkInfo.pnic:
                hw_grain_data["hwaddr_interfaces"][_pnic.device] = _pnic.mac
            hw_grain_data["timezone"] = view.view[
                0
            ].configManager.dateTimeSystem.dateTimeInfo.timeZone.name
        view = None
    return hw_grain_data
def get_inventory(service_instance):
    return service_instance.RetrieveContent()
def get_root_folder(service_instance):
    try:
        log.trace("Retrieving root folder")
        return service_instance.RetrieveContent().rootFolder
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
def get_content(
    service_instance,
    obj_type,
    property_list=None,
    container_ref=None,
    traversal_spec=None,
    local_properties=False,
):
    if not container_ref:
        container_ref = get_root_folder(service_instance)
    obj_ref = container_ref
    local_traversal_spec = False
    if not traversal_spec and not local_properties:
        local_traversal_spec = True
        try:
            obj_ref = service_instance.content.viewManager.CreateContainerView(
                container_ref, [obj_type], True
            )
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            name="traverseEntities",
            path="view",
            skip=False,
            type=vim.view.ContainerView,
        )
    property_spec = vmodl.query.PropertyCollector.PropertySpec(
        type=obj_type, all=True if not property_list else False, pathSet=property_list
    )
    obj_spec = vmodl.query.PropertyCollector.ObjectSpec(
        obj=obj_ref,
        skip=True if not local_properties else False,
        selectSet=[traversal_spec] if not local_properties else None,
    )
    filter_spec = vmodl.query.PropertyCollector.FilterSpec(
        objectSet=[obj_spec],
        propSet=[property_spec],
        reportMissingObjectsInResults=False,
    )
    try:
        content = service_instance.content.propertyCollector.RetrieveContents(
            [filter_spec]
        )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    if local_traversal_spec:
        try:
            obj_ref.Destroy()
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
    return content
def get_mor_by_property(
    service_instance,
    object_type,
    property_value,
    property_name="name",
    container_ref=None,
):
    object_list = get_mors_with_properties(
        service_instance,
        object_type,
        property_list=[property_name],
        container_ref=container_ref,
    )
    for obj in object_list:
        obj_id = str(obj.get("object", "")).strip("'\"")
        if obj[property_name] == property_value or property_value == obj_id:
            return obj["object"]
    return None
def get_mors_with_properties(
    service_instance,
    object_type,
    property_list=None,
    container_ref=None,
    traversal_spec=None,
    local_properties=False,
):
    content_args = [service_instance, object_type]
    content_kwargs = {
        "property_list": property_list,
        "container_ref": container_ref,
        "traversal_spec": traversal_spec,
        "local_properties": local_properties,
    }
    try:
        content = get_content(*content_args, **content_kwargs)
    except BadStatusLine:
        content = get_content(*content_args, **content_kwargs)
    except OSError as exc:
        if exc.errno != errno.EPIPE:
            raise
        content = get_content(*content_args, **content_kwargs)
    object_list = []
    for obj in content:
        properties = {}
        for prop in obj.propSet:
            properties[prop.name] = prop.val
        properties["object"] = obj.obj
        object_list.append(properties)
    log.trace("Retrieved %s objects", len(object_list))
    return object_list
def get_properties_of_managed_object(mo_ref, properties):
    service_instance = get_service_instance_from_managed_object(mo_ref)
    log.trace("Retrieving name of %s", type(mo_ref).__name__)
    try:
        items = get_mors_with_properties(
            service_instance,
            type(mo_ref),
            container_ref=mo_ref,
            property_list=["name"],
            local_properties=True,
        )
        mo_name = items[0]["name"]
    except vmodl.query.InvalidProperty:
        mo_name = "&lt;unnamed&gt;"
    log.trace(
        "Retrieving properties '%s' of %s '%s'",
        properties,
        type(mo_ref).__name__,
        mo_name,
    )
    items = get_mors_with_properties(
        service_instance,
        type(mo_ref),
        container_ref=mo_ref,
        property_list=properties,
        local_properties=True,
    )
    if not items:
        raise salt.exceptions.VMwareApiError(
            "Properties of managed object '{}' weren't retrieved".format(mo_name)
        )
    return items[0]
def get_managed_object_name(mo_ref):
    props = get_properties_of_managed_object(mo_ref, ["name"])
    return props.get("name")
def get_network_adapter_type(adapter_type):
    if adapter_type == "vmxnet":
        return vim.vm.device.VirtualVmxnet()
    elif adapter_type == "vmxnet2":
        return vim.vm.device.VirtualVmxnet2()
    elif adapter_type == "vmxnet3":
        return vim.vm.device.VirtualVmxnet3()
    elif adapter_type == "e1000":
        return vim.vm.device.VirtualE1000()
    elif adapter_type == "e1000e":
        return vim.vm.device.VirtualE1000e()
    raise ValueError("An unknown network adapter object type name.")
def get_network_adapter_object_type(adapter_object):
    if isinstance(adapter_object, vim.vm.device.VirtualVmxnet2):
        return "vmxnet2"
    if isinstance(adapter_object, vim.vm.device.VirtualVmxnet3):
        return "vmxnet3"
    if isinstance(adapter_object, vim.vm.device.VirtualVmxnet):
        return "vmxnet"
    if isinstance(adapter_object, vim.vm.device.VirtualE1000e):
        return "e1000e"
    if isinstance(adapter_object, vim.vm.device.VirtualE1000):
        return "e1000"
    raise ValueError("An unknown network adapter object type.")
def get_dvss(dc_ref, dvs_names=None, get_all_dvss=False):
    dc_name = get_managed_object_name(dc_ref)
    log.trace(
        "Retrieving DVSs in datacenter '%s', dvs_names='%s', get_all_dvss=%s",
        dc_name,
        ",".join(dvs_names) if dvs_names else None,
        get_all_dvss,
    )
    properties = ["name"]
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="networkFolder",
        skip=True,
        type=vim.Datacenter,
        selectSet=[
            vmodl.query.PropertyCollector.TraversalSpec(
                path="childEntity", skip=False, type=vim.Folder
            )
        ],
    )
    service_instance = get_service_instance_from_managed_object(dc_ref)
    items = [
        i["object"]
        for i in get_mors_with_properties(
            service_instance,
            vim.DistributedVirtualSwitch,
            container_ref=dc_ref,
            property_list=properties,
            traversal_spec=traversal_spec,
        )
        if get_all_dvss or (dvs_names and i["name"] in dvs_names)
    ]
    return items
def get_network_folder(dc_ref):
    dc_name = get_managed_object_name(dc_ref)
    log.trace("Retrieving network folder in datacenter '%s'", dc_name)
    service_instance = get_service_instance_from_managed_object(dc_ref)
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="networkFolder", skip=False, type=vim.Datacenter
    )
    entries = get_mors_with_properties(
        service_instance,
        vim.Folder,
        container_ref=dc_ref,
        property_list=["name"],
        traversal_spec=traversal_spec,
    )
    if not entries:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Network folder in datacenter '{}' wasn't retrieved".format(dc_name)
        )
    return entries[0]["object"]
def create_dvs(dc_ref, dvs_name, dvs_create_spec=None):
    dc_name = get_managed_object_name(dc_ref)
    log.trace("Creating DVS '%s' in datacenter '%s'", dvs_name, dc_name)
    if not dvs_create_spec:
        dvs_create_spec = vim.DVSCreateSpec()
    if not dvs_create_spec.configSpec:
        dvs_create_spec.configSpec = vim.VMwareDVSConfigSpec()
        dvs_create_spec.configSpec.name = dvs_name
    netw_folder_ref = get_network_folder(dc_ref)
    try:
        task = netw_folder_ref.CreateDVS_Task(dvs_create_spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, dvs_name, str(task.__class__))
def update_dvs(dvs_ref, dvs_config_spec):
    dvs_name = get_managed_object_name(dvs_ref)
    log.trace("Updating dvs '%s'", dvs_name)
    try:
        task = dvs_ref.ReconfigureDvs_Task(dvs_config_spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, dvs_name, str(task.__class__))
def set_dvs_network_resource_management_enabled(dvs_ref, enabled):
    dvs_name = get_managed_object_name(dvs_ref)
    log.trace(
        "Setting network resource management enable to %s on dvs '%s'",
        enabled,
        dvs_name,
    )
    try:
        dvs_ref.EnableNetworkResourceManagement(enable=enabled)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
def get_dvportgroups(parent_ref, portgroup_names=None, get_all_portgroups=False):
    if not isinstance(parent_ref, (vim.Datacenter, vim.DistributedVirtualSwitch)):
        raise salt.exceptions.ArgumentValueError(
            "Parent has to be either a datacenter, or a distributed virtual switch"
        )
    parent_name = get_managed_object_name(parent_ref)
    log.trace(
        "Retrieving portgroup in %s '%s', portgroups_names='%s', get_all_portgroups=%s",
        type(parent_ref).__name__,
        parent_name,
        ",".join(portgroup_names) if portgroup_names else None,
        get_all_portgroups,
    )
    properties = ["name"]
    if isinstance(parent_ref, vim.Datacenter):
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            path="networkFolder",
            skip=True,
            type=vim.Datacenter,
            selectSet=[
                vmodl.query.PropertyCollector.TraversalSpec(
                    path="childEntity", skip=False, type=vim.Folder
                )
            ],
        )
    else:  # parent is distributed virtual switch
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            path="portgroup", skip=False, type=vim.DistributedVirtualSwitch
        )
    service_instance = get_service_instance_from_managed_object(parent_ref)
    items = [
        i["object"]
        for i in get_mors_with_properties(
            service_instance,
            vim.DistributedVirtualPortgroup,
            container_ref=parent_ref,
            property_list=properties,
            traversal_spec=traversal_spec,
        )
        if get_all_portgroups or (portgroup_names and i["name"] in portgroup_names)
    ]
    return items
def get_uplink_dvportgroup(dvs_ref):
    dvs_name = get_managed_object_name(dvs_ref)
    log.trace("Retrieving uplink portgroup of dvs '%s'", dvs_name)
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="portgroup", skip=False, type=vim.DistributedVirtualSwitch
    )
    service_instance = get_service_instance_from_managed_object(dvs_ref)
    items = [
        entry["object"]
        for entry in get_mors_with_properties(
            service_instance,
            vim.DistributedVirtualPortgroup,
            container_ref=dvs_ref,
            property_list=["tag"],
            traversal_spec=traversal_spec,
        )
        if entry["tag"] and [t for t in entry["tag"] if t.key == "SYSTEM/DVS.UPLINKPG"]
    ]
    if not items:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Uplink portgroup of DVS '{}' wasn't found".format(dvs_name)
        )
    return items[0]
def create_dvportgroup(dvs_ref, spec):
    dvs_name = get_managed_object_name(dvs_ref)
    log.trace("Adding portgroup %s to dvs '%s'", spec.name, dvs_name)
    log.trace("spec = %s", spec)
    try:
        task = dvs_ref.CreateDVPortgroup_Task(spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, dvs_name, str(task.__class__))
def update_dvportgroup(portgroup_ref, spec):
    pg_name = get_managed_object_name(portgroup_ref)
    log.trace("Updating portgrouo %s", pg_name)
    try:
        task = portgroup_ref.ReconfigureDVPortgroup_Task(spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, pg_name, str(task.__class__))
def remove_dvportgroup(portgroup_ref):
    pg_name = get_managed_object_name(portgroup_ref)
    log.trace("Removing portgroup %s", pg_name)
    try:
        task = portgroup_ref.Destroy_Task()
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, pg_name, str(task.__class__))
def get_networks(parent_ref, network_names=None, get_all_networks=False):
    if not isinstance(parent_ref, vim.Datacenter):
        raise salt.exceptions.ArgumentValueError("Parent has to be a datacenter.")
    parent_name = get_managed_object_name(parent_ref)
    log.trace(
        "Retrieving network from %s '%s', network_names='%s', get_all_networks=%s",
        type(parent_ref).__name__,
        parent_name,
        ",".join(network_names) if network_names else None,
        get_all_networks,
    )
    properties = ["name"]
    service_instance = get_service_instance_from_managed_object(parent_ref)
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="networkFolder",
        skip=True,
        type=vim.Datacenter,
        selectSet=[
            vmodl.query.PropertyCollector.TraversalSpec(
                path="childEntity", skip=False, type=vim.Folder
            )
        ],
    )
    items = [
        i["object"]
        for i in get_mors_with_properties(
            service_instance,
            vim.Network,
            container_ref=parent_ref,
            property_list=properties,
            traversal_spec=traversal_spec,
        )
        if get_all_networks or (network_names and i["name"] in network_names)
    ]
    return items
def list_objects(service_instance, vim_object, properties=None):
    if properties is None:
        properties = ["name"]
    items = []
    item_list = get_mors_with_properties(service_instance, vim_object, properties)
    for item in item_list:
        items.append(item["name"])
    return items
def get_license_manager(service_instance):
    log.debug("Retrieving license manager")
    try:
        lic_manager = service_instance.content.licenseManager
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    return lic_manager
def get_license_assignment_manager(service_instance):
    log.debug("Retrieving license assignment manager")
    try:
        lic_assignment_manager = (
            service_instance.content.licenseManager.licenseAssignmentManager
        )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    if not lic_assignment_manager:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "License assignment manager was not retrieved"
        )
    return lic_assignment_manager
def get_licenses(service_instance, license_manager=None):
    if not license_manager:
        license_manager = get_license_manager(service_instance)
    log.debug("Retrieving licenses")
    try:
        return license_manager.licenses
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
def add_license(service_instance, key, description, license_manager=None):
    if not license_manager:
        license_manager = get_license_manager(service_instance)
    label = vim.KeyValue()
    label.key = "VpxClientLicenseLabel"
    label.value = description
    log.debug("Adding license '%s'", description)
    try:
        vmware_license = license_manager.AddLicense(key, [label])
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    return vmware_license
def get_assigned_licenses(
    service_instance, entity_ref=None, entity_name=None, license_assignment_manager=None
):
    if not license_assignment_manager:
        license_assignment_manager = get_license_assignment_manager(service_instance)
    if not entity_name:
        raise salt.exceptions.ArgumentValueError("No entity_name passed")
    entity_id = None
    entity_type = "moid"
    check_name = False
    if not entity_ref:
        if entity_name:
            check_name = True
        entity_type = "uuid"
        try:
            entity_id = service_instance.content.about.instanceUuid
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
    else:
        entity_id = entity_ref._moId
    log.trace("Retrieving licenses assigned to '%s'", entity_name)
    try:
        assignments = license_assignment_manager.QueryAssignedLicenses(entity_id)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    if entity_type == "uuid" and len(assignments) &gt; 1:
        log.trace("Unexpectectedly retrieved more than one VCenter license assignment.")
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Unexpected return. Expect only a single assignment"
        )
    if check_name:
        if entity_name != assignments[0].entityDisplayName:
            log.trace(
                "Getting license info for wrong vcenter: %s != %s",
                entity_name,
                assignments[0].entityDisplayName,
            )
            raise salt.exceptions.VMwareObjectRetrievalError(
                "Got license assignment info for a different vcenter"
            )
    return [a.assignedLicense for a in assignments]
def assign_license(
    service_instance,
    license_key,
    license_name,
    entity_ref=None,
    entity_name=None,
    license_assignment_manager=None,
):
    if not license_assignment_manager:
        license_assignment_manager = get_license_assignment_manager(service_instance)
    entity_id = None
    if not entity_ref:
        try:
            entity_id = service_instance.content.about.instanceUuid
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.VimFault as exc:
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
        if not entity_name:
            entity_name = "vCenter"
    else:
        entity_id = entity_ref._moId
    log.trace("Assigning license to '%s'", entity_name)
    try:
        vmware_license = license_assignment_manager.UpdateAssignedLicense(
            entity_id, license_key, license_name
        )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    return vmware_license
def list_datacenters(service_instance):
    return list_objects(service_instance, vim.Datacenter)
def get_datacenters(service_instance, datacenter_names=None, get_all_datacenters=False):
    items = [
        i["object"]
        for i in get_mors_with_properties(
            service_instance, vim.Datacenter, property_list=["name"]
        )
        if get_all_datacenters or (datacenter_names and i["name"] in datacenter_names)
    ]
    return items
def get_datacenter(service_instance, datacenter_name):
    items = get_datacenters(service_instance, datacenter_names=[datacenter_name])
    if not items:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Datacenter '{}' was not found".format(datacenter_name)
        )
    return items[0]
def create_datacenter(service_instance, datacenter_name):
    root_folder = get_root_folder(service_instance)
    log.trace("Creating datacenter '%s'", datacenter_name)
    try:
        dc_obj = root_folder.CreateDatacenter(datacenter_name)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    return dc_obj
def get_cluster(dc_ref, cluster):
    dc_name = get_managed_object_name(dc_ref)
    log.trace("Retrieving cluster '%s' from datacenter '%s'", cluster, dc_name)
    si = get_service_instance_from_managed_object(dc_ref, name=dc_name)
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="hostFolder",
        skip=True,
        type=vim.Datacenter,
        selectSet=[
            vmodl.query.PropertyCollector.TraversalSpec(
                path="childEntity", skip=False, type=vim.Folder
            )
        ],
    )
    items = [
        i["object"]
        for i in get_mors_with_properties(
            si,
            vim.ClusterComputeResource,
            container_ref=dc_ref,
            property_list=["name"],
            traversal_spec=traversal_spec,
        )
        if i["name"] == cluster
    ]
    if not items:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Cluster '{}' was not found in datacenter '{}'".format(cluster, dc_name)
        )
    return items[0]
def create_cluster(dc_ref, cluster_name, cluster_spec):
    dc_name = get_managed_object_name(dc_ref)
    log.trace("Creating cluster '%s' in datacenter '%s'", cluster_name, dc_name)
    try:
        dc_ref.hostFolder.CreateClusterEx(cluster_name, cluster_spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
def update_cluster(cluster_ref, cluster_spec):
    cluster_name = get_managed_object_name(cluster_ref)
    log.trace("Updating cluster '%s'", cluster_name)
    try:
        task = cluster_ref.ReconfigureComputeResource_Task(cluster_spec, modify=True)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, cluster_name, "ClusterUpdateTask")
def list_clusters(service_instance):
    return list_objects(service_instance, vim.ClusterComputeResource)
def list_datastore_clusters(service_instance):
    return list_objects(service_instance, vim.StoragePod)
def list_datastores(service_instance):
    return list_objects(service_instance, vim.Datastore)
def get_datastore_files(
    service_instance, directory, datastores, container_object, browser_spec
):
    files = []
    datastore_objects = get_datastores(
        service_instance, container_object, datastore_names=datastores
    )
    for datobj in datastore_objects:
        try:
            task = datobj.browser.SearchDatastore_Task(
                datastorePath="[{}] {}".format(datobj.name, directory),
                searchSpec=browser_spec,
            )
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
        try:
            files.append(
                salt.utils.vmware.wait_for_task(
                    task, directory, "query virtual machine files"
                )
            )
        except salt.exceptions.VMwareFileNotFoundError:
            pass
    return files
def get_datastores(
    service_instance,
    reference,
    datastore_names=None,
    backing_disk_ids=None,
    get_all_datastores=False,
):
    obj_name = get_managed_object_name(reference)
    if get_all_datastores:
        log.trace("Retrieving all datastores visible to '%s'", obj_name)
    else:
        log.trace(
            "Retrieving datastores visible to '%s': names = (%s); "
            "backing disk ids = (%s)",
            obj_name,
            datastore_names,
            backing_disk_ids,
        )
        if backing_disk_ids and not isinstance(reference, vim.HostSystem):
            raise salt.exceptions.ArgumentValueError(
                "Unsupported reference type '{}' when backing disk filter "
                "is set".format(reference.__class__.__name__)
            )
    if (not get_all_datastores) and backing_disk_ids:
        log.trace("Filtering datastores with backing disk ids: %s", backing_disk_ids)
        storage_system = get_storage_system(service_instance, reference, obj_name)
        props = salt.utils.vmware.get_properties_of_managed_object(
            storage_system, ["fileSystemVolumeInfo.mountInfo"]
        )
        mount_infos = props.get("fileSystemVolumeInfo.mountInfo", [])
        disk_datastores = []
        for vol in [
            i.volume for i in mount_infos if isinstance(i.volume, vim.HostVmfsVolume)
        ]:
            if not [e for e in vol.extent if e.diskName in backing_disk_ids]:
                continue
            log.trace(
                "Found datastore '%s' for disk id(s) '%s'",
                vol.name,
                [e.diskName for e in vol.extent],
            )
            disk_datastores.append(vol.name)
        log.trace("Datastore found for disk filter: %s", disk_datastores)
        if datastore_names:
            datastore_names.extend(disk_datastores)
        else:
            datastore_names = disk_datastores
    if (not get_all_datastores) and (not datastore_names):
        log.trace(
            "No datastore to be filtered after retrieving the datastores "
            "backed by the disk id(s) '%s'",
            backing_disk_ids,
        )
        return []
    log.trace("datastore_names = %s", datastore_names)
    if isinstance(reference, vim.HostSystem):
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            name="host_datastore_traversal",
            path="datastore",
            skip=False,
            type=vim.HostSystem,
        )
    elif isinstance(reference, vim.ClusterComputeResource):
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            name="cluster_datastore_traversal",
            path="datastore",
            skip=False,
            type=vim.ClusterComputeResource,
        )
    elif isinstance(reference, vim.Datacenter):
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            name="datacenter_datastore_traversal",
            path="datastore",
            skip=False,
            type=vim.Datacenter,
        )
    elif isinstance(reference, vim.StoragePod):
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            name="datastore_cluster_traversal",
            path="childEntity",
            skip=False,
            type=vim.StoragePod,
        )
    elif (
        isinstance(reference, vim.Folder)
        and get_managed_object_name(reference) == "Datacenters"
    ):
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            path="childEntity",
            selectSet=[
                vmodl.query.PropertyCollector.TraversalSpec(
                    path="datastore", skip=False, type=vim.Datacenter
                )
            ],
            skip=False,
            type=vim.Folder,
        )
    else:
        raise salt.exceptions.ArgumentValueError(
            "Unsupported reference type '{}'".format(reference.__class__.__name__)
        )
    items = get_mors_with_properties(
        service_instance,
        object_type=vim.Datastore,
        property_list=["name"],
        container_ref=reference,
        traversal_spec=traversal_spec,
    )
    log.trace("Retrieved %s datastores", len(items))
    items = [i for i in items if get_all_datastores or i["name"] in datastore_names]
    log.trace("Filtered datastores: %s", [i["name"] for i in items])
    return [i["object"] for i in items]
def rename_datastore(datastore_ref, new_datastore_name):
    ds_name = get_managed_object_name(datastore_ref)
    log.trace("Renaming datastore '%s' to '%s'", ds_name, new_datastore_name)
    try:
        datastore_ref.RenameDatastore(new_datastore_name)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
def get_storage_system(service_instance, host_ref, hostname=None):
    if not hostname:
        hostname = get_managed_object_name(host_ref)
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="configManager.storageSystem", type=vim.HostSystem, skip=False
    )
    objs = get_mors_with_properties(
        service_instance,
        vim.HostStorageSystem,
        property_list=["systemFile"],
        container_ref=host_ref,
        traversal_spec=traversal_spec,
    )
    if not objs:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Host's '{}' storage system was not retrieved".format(hostname)
        )
    log.trace("[%s] Retrieved storage system", hostname)
    return objs[0]["object"]
def _get_partition_info(storage_system, device_path):
    try:
        partition_infos = storage_system.RetrieveDiskPartitionInfo(
            devicePath=[device_path]
        )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    log.trace("partition_info = %s", partition_infos[0])
    return partition_infos[0]
def _get_new_computed_partition_spec(storage_system, device_path, partition_info):
    log.trace(
        "Adding a partition at the end of the disk and getting the new "
        "computed partition spec"
    )
    free_partitions = [p for p in partition_info.layout.partition if p.type == "none"]
    if not free_partitions:
        raise salt.exceptions.VMwareObjectNotFoundError(
            "Free partition was not found on device '{}'".format(
                partition_info.deviceName
            )
        )
    free_partition = free_partitions[0]
    layout = vim.HostDiskPartitionLayout(
        total=partition_info.layout.total, partition=partition_info.layout.partition
    )
    free_partition.type = "vmfs"
    try:
        computed_partition_info = storage_system.ComputeDiskPartitionInfo(
            devicePath=device_path,
            partitionFormat=vim.HostDiskPartitionInfoPartitionFormat.gpt,
            layout=layout,
        )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
<a name="1"></a>        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    log.trace("computed partition info = {0}", computed_partition_info)
    log.trace("Retrieving new partition number")
    partition_numbers <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [
        p.partition
        for p in computed_partition_info.layout.partition
        if (
            p.start.block == free_partition.start.block
            or
            (free_partition.start.block == 0 and p.start.block == 1)
        )
        and p.end.block == free_partition.end.block
        and p.</b></font>type == "vmfs"
    ]
    if not partition_numbers:
        raise salt.exceptions.VMwareNotFoundError(
            "New partition was not found in computed partitions of device '{}'".format(
                partition_info.deviceName
            )
        )
    log.trace("new partition number = %s", partition_numbers[0])
    return (partition_numbers[0], computed_partition_info.spec)
def create_vmfs_datastore(
    host_ref, datastore_name, disk_ref, vmfs_major_version, storage_system=None
):
    hostname = get_managed_object_name(host_ref)
    disk_id = disk_ref.canonicalName
    log.debug(
        "Creating datastore '%s' on host '%s', scsi disk '%s', vmfs v%s",
        datastore_name,
        hostname,
        disk_id,
        vmfs_major_version,
    )
    if not storage_system:
        si = get_service_instance_from_managed_object(host_ref, name=hostname)
        storage_system = get_storage_system(si, host_ref, hostname)
    target_disk = disk_ref
    partition_info = _get_partition_info(storage_system, target_disk.devicePath)
    log.trace("partition_info = %s", partition_info)
    new_partition_number, partition_spec = _get_new_computed_partition_spec(
        storage_system, target_disk.devicePath, partition_info
    )
    spec = vim.VmfsDatastoreCreateSpec(
        vmfs=vim.HostVmfsSpec(
            majorVersion=vmfs_major_version,
            volumeName=datastore_name,
            extent=vim.HostScsiDiskPartition(
                diskName=disk_id, partition=new_partition_number
            ),
        ),
        diskUuid=target_disk.uuid,
        partition=partition_spec,
    )
    try:
        ds_ref = host_ref.configManager.datastoreSystem.CreateVmfsDatastore(spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    log.debug("Created datastore '%s' on host '%s'", datastore_name, hostname)
    return ds_ref
def get_host_datastore_system(host_ref, hostname=None):
    if not hostname:
        hostname = get_managed_object_name(host_ref)
    service_instance = get_service_instance_from_managed_object(host_ref)
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="configManager.datastoreSystem", type=vim.HostSystem, skip=False
    )
    objs = get_mors_with_properties(
        service_instance,
        vim.HostDatastoreSystem,
        property_list=["datastore"],
        container_ref=host_ref,
        traversal_spec=traversal_spec,
    )
    if not objs:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Host's '{}' datastore system was not retrieved".format(hostname)
        )
    log.trace("[%s] Retrieved datastore system", hostname)
    return objs[0]["object"]
def remove_datastore(service_instance, datastore_ref):
    ds_props = get_properties_of_managed_object(datastore_ref, ["host", "info", "name"])
    ds_name = ds_props["name"]
    log.debug("Removing datastore '%s'", ds_name)
    ds_hosts = ds_props.get("host")
    if not ds_hosts:
        raise salt.exceptions.VMwareApiError(
            "Datastore '{}' can't be removed. No attached hosts found".format(ds_name)
        )
    hostname = get_managed_object_name(ds_hosts[0].key)
    host_ds_system = get_host_datastore_system(ds_hosts[0].key, hostname=hostname)
    try:
        host_ds_system.RemoveDatastore(datastore_ref)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    log.trace("[%s] Removed datastore '%s'", hostname, ds_name)
def get_hosts(
    service_instance,
    datacenter_name=None,
    host_names=None,
    cluster_name=None,
    get_all_hosts=False,
):
    properties = ["name"]
    if cluster_name and not datacenter_name:
        raise salt.exceptions.ArgumentValueError(
            "Must specify the datacenter when specifying the cluster"
        )
    if not host_names:
        host_names = []
    if not datacenter_name:
        start_point = get_root_folder(service_instance)
    else:
        start_point = get_datacenter(service_instance, datacenter_name)
        if cluster_name:
            properties.append("parent")
    hosts = get_mors_with_properties(
        service_instance,
        vim.HostSystem,
        container_ref=start_point,
        property_list=properties,
    )
    log.trace("Retrieved hosts: %s", [h["name"] for h in hosts])
    filtered_hosts = []
    for h in hosts:
        if cluster_name:
            if not isinstance(h["parent"], vim.ClusterComputeResource):
                continue
            parent_name = get_managed_object_name(h["parent"])
            if parent_name != cluster_name:
                continue
        if get_all_hosts:
            filtered_hosts.append(h["object"])
            continue
        if h["name"] in host_names:
            filtered_hosts.append(h["object"])
    return filtered_hosts
def _get_scsi_address_to_lun_key_map(
    service_instance, host_ref, storage_system=None, hostname=None
):
    if not hostname:
        hostname = get_managed_object_name(host_ref)
    if not storage_system:
        storage_system = get_storage_system(service_instance, host_ref, hostname)
    try:
        device_info = storage_system.storageDeviceInfo
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    if not device_info:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Host's '{}' storage device info was not retrieved".format(hostname)
        )
    multipath_info = device_info.multipathInfo
    if not multipath_info:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Host's '{}' multipath info was not retrieved".format(hostname)
        )
    if multipath_info.lun is None:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "No luns were retrieved from host '{}'".format(hostname)
        )
    lun_key_by_scsi_addr = {}
    for l in multipath_info.lun:
        lun_key_by_scsi_addr.update({p.name.split(",")[0]: l.lun for p in l.path})
    log.trace(
        "Scsi address to lun id map on host '%s': %s", hostname, lun_key_by_scsi_addr
    )
    return lun_key_by_scsi_addr
def get_all_luns(host_ref, storage_system=None, hostname=None):
    if not hostname:
        hostname = get_managed_object_name(host_ref)
    if not storage_system:
        si = get_service_instance_from_managed_object(host_ref, name=hostname)
        storage_system = get_storage_system(si, host_ref, hostname)
        if not storage_system:
            raise salt.exceptions.VMwareObjectRetrievalError(
                "Host's '{}' storage system was not retrieved".format(hostname)
            )
    try:
        device_info = storage_system.storageDeviceInfo
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    if not device_info:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Host's '{}' storage device info was not retrieved".format(hostname)
        )
    scsi_luns = device_info.scsiLun
    if scsi_luns:
        log.trace(
            "Retrieved scsi luns in host '%s': %s",
            hostname,
            [l.canonicalName for l in scsi_luns],
        )
        return scsi_luns
    log.trace("Retrieved no scsi_luns in host '%s'", hostname)
    return []
def get_scsi_address_to_lun_map(host_ref, storage_system=None, hostname=None):
    if not hostname:
        hostname = get_managed_object_name(host_ref)
    si = get_service_instance_from_managed_object(host_ref, name=hostname)
    if not storage_system:
        storage_system = get_storage_system(si, host_ref, hostname)
    lun_ids_to_scsi_addr_map = _get_scsi_address_to_lun_key_map(
        si, host_ref, storage_system, hostname
    )
    luns_to_key_map = {
        d.key: d for d in get_all_luns(host_ref, storage_system, hostname)
    }
    return {
        scsi_addr: luns_to_key_map[lun_key]
        for scsi_addr, lun_key in lun_ids_to_scsi_addr_map.items()
    }
def get_disks(host_ref, disk_ids=None, scsi_addresses=None, get_all_disks=False):
    hostname = get_managed_object_name(host_ref)
    if get_all_disks:
        log.trace("Retrieving all disks in host '%s'", hostname)
    else:
        log.trace(
            "Retrieving disks in host '%s': ids = (%s); scsi addresses = (%s)",
            hostname,
            disk_ids,
            scsi_addresses,
        )
        if not (disk_ids or scsi_addresses):
            return []
    si = get_service_instance_from_managed_object(host_ref, name=hostname)
    storage_system = get_storage_system(si, host_ref, hostname)
    disk_keys = []
    if scsi_addresses:
        lun_key_by_scsi_addr = _get_scsi_address_to_lun_key_map(
            si, host_ref, storage_system, hostname
        )
        disk_keys = [
            key
            for scsi_addr, key in lun_key_by_scsi_addr.items()
            if scsi_addr in scsi_addresses
        ]
        log.trace("disk_keys based on scsi_addresses = %s", disk_keys)
    scsi_luns = get_all_luns(host_ref, storage_system)
    scsi_disks = [
        disk
        for disk in scsi_luns
        if isinstance(disk, vim.HostScsiDisk)
        and (
            get_all_disks
            or
            (disk_ids and (disk.canonicalName in disk_ids))
            or
            (disk.key in disk_keys)
        )
    ]
    log.trace(
        "Retrieved disks in host '%s': %s",
        hostname,
        [d.canonicalName for d in scsi_disks],
    )
    return scsi_disks
def get_disk_partition_info(host_ref, disk_id, storage_system=None):
    hostname = get_managed_object_name(host_ref)
    service_instance = get_service_instance_from_managed_object(host_ref)
    if not storage_system:
        storage_system = get_storage_system(service_instance, host_ref, hostname)
    props = get_properties_of_managed_object(
        storage_system, ["storageDeviceInfo.scsiLun"]
    )
    if not props.get("storageDeviceInfo.scsiLun"):
        raise salt.exceptions.VMwareObjectRetrievalError(
            "No devices were retrieved in host '{}'".format(hostname)
        )
    log.trace(
        "[%s] Retrieved %s devices: %s",
        hostname,
        len(props["storageDeviceInfo.scsiLun"]),
        ", ".join([l.canonicalName for l in props["storageDeviceInfo.scsiLun"]]),
    )
    disks = [
        l
        for l in props["storageDeviceInfo.scsiLun"]
        if isinstance(l, vim.HostScsiDisk) and l.canonicalName == disk_id
    ]
    if not disks:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Disk '{}' was not found in host '{}'".format(disk_id, hostname)
        )
    log.trace("[%s] device_path = %s", hostname, disks[0].devicePath)
    partition_info = _get_partition_info(storage_system, disks[0].devicePath)
    log.trace(
        "[%s] Retrieved %s partition(s) on disk '%s'",
        hostname,
        len(partition_info.spec.partition),
        disk_id,
    )
    return partition_info
def erase_disk_partitions(
    service_instance, host_ref, disk_id, hostname=None, storage_system=None
):
    if not hostname:
        hostname = get_managed_object_name(host_ref)
    if not storage_system:
        storage_system = get_storage_system(service_instance, host_ref, hostname)
    traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
        path="configManager.storageSystem", type=vim.HostSystem, skip=False
    )
    results = get_mors_with_properties(
        service_instance,
        vim.HostStorageSystem,
        ["storageDeviceInfo.scsiLun"],
        container_ref=host_ref,
        traversal_spec=traversal_spec,
    )
    if not results:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Host's '{}' devices were not retrieved".format(hostname)
        )
    log.trace(
        "[%s] Retrieved %s devices: %s",
        hostname,
        len(results[0].get("storageDeviceInfo.scsiLun", [])),
        ", ".join(
            [l.canonicalName for l in results[0].get("storageDeviceInfo.scsiLun", [])]
        ),
    )
    disks = [
        l
        for l in results[0].get("storageDeviceInfo.scsiLun", [])
        if isinstance(l, vim.HostScsiDisk) and l.canonicalName == disk_id
    ]
    if not disks:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "Disk '{}' was not found in host '{}'".format(disk_id, hostname)
        )
    log.trace("[%s] device_path = %s", hostname, disks[0].devicePath)
    try:
        storage_system.UpdateDiskPartitions(
            disks[0].devicePath, vim.HostDiskPartitionSpec()
        )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    log.trace("[%s] Erased partitions on disk '%s'", hostname, disk_id)
def get_diskgroups(host_ref, cache_disk_ids=None, get_all_disk_groups=False):
    hostname = get_managed_object_name(host_ref)
    if get_all_disk_groups:
        log.trace("Retrieving all disk groups on host '%s'", hostname)
    else:
        log.trace(
            "Retrieving disk groups from host '%s', with cache disk ids : (%s)",
            hostname,
            cache_disk_ids,
        )
        if not cache_disk_ids:
            return []
    try:
        vsan_host_config = host_ref.config.vsanHostConfig
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    if not vsan_host_config:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "No host config found on host '{}'".format(hostname)
        )
    vsan_storage_info = vsan_host_config.storageInfo
    if not vsan_storage_info:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "No vsan storage info found on host '{}'".format(hostname)
        )
    vsan_disk_mappings = vsan_storage_info.diskMapping
    if not vsan_disk_mappings:
        return []
    disk_groups = [
        dm
        for dm in vsan_disk_mappings
        if (get_all_disk_groups or (dm.ssd.canonicalName in cache_disk_ids))
    ]
    log.trace(
        "Retrieved disk groups on host '%s', with cache disk ids : %s",
        hostname,
        [d.ssd.canonicalName for d in disk_groups],
    )
    return disk_groups
def _check_disks_in_diskgroup(disk_group, cache_disk_id, capacity_disk_ids):
    if not disk_group.ssd.canonicalName == cache_disk_id:
        raise salt.exceptions.ArgumentValueError(
            "Incorrect diskgroup cache disk; got id: '{}'; expected id: '{}'".format(
                disk_group.ssd.canonicalName, cache_disk_id
            )
        )
    non_ssd_disks = [d.canonicalName for d in disk_group.nonSsd]
    if sorted(non_ssd_disks) != sorted(capacity_disk_ids):
        raise salt.exceptions.ArgumentValueError(
            "Incorrect capacity disks; got ids: '{}'; expected ids: '{}'".format(
                sorted(non_ssd_disks), sorted(capacity_disk_ids)
            )
        )
    log.trace("Checked disks in diskgroup with cache disk id '%s'", cache_disk_id)
    return True
def get_host_cache(host_ref, host_cache_manager=None):
    hostname = get_managed_object_name(host_ref)
    service_instance = get_service_instance_from_managed_object(host_ref)
    log.trace("Retrieving the host cache on host '%s'", hostname)
    if not host_cache_manager:
        traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
            path="configManager.cacheConfigurationManager",
            type=vim.HostSystem,
            skip=False,
        )
        results = get_mors_with_properties(
            service_instance,
            vim.HostCacheConfigurationManager,
            ["cacheConfigurationInfo"],
            container_ref=host_ref,
            traversal_spec=traversal_spec,
        )
        if not results or not results[0].get("cacheConfigurationInfo"):
            log.trace("Host '%s' has no host cache", hostname)
            return None
        return results[0]["cacheConfigurationInfo"][0]
    else:
        results = get_properties_of_managed_object(
            host_cache_manager, ["cacheConfigurationInfo"]
        )
        if not results:
            log.trace("Host '%s' has no host cache", hostname)
            return None
        return results["cacheConfigurationInfo"][0]
def configure_host_cache(
    host_ref, datastore_ref, swap_size_MiB, host_cache_manager=None
):
    hostname = get_managed_object_name(host_ref)
    if not host_cache_manager:
        props = get_properties_of_managed_object(
            host_ref, ["configManager.cacheConfigurationManager"]
        )
        if not props.get("configManager.cacheConfigurationManager"):
            raise salt.exceptions.VMwareObjectRetrievalError(
                "Host '{}' has no host cache".format(hostname)
            )
        host_cache_manager = props["configManager.cacheConfigurationManager"]
    log.trace(
        "Configuring the host cache on host '%s', datastore '%s', swap size=%s MiB",
        hostname,
        datastore_ref.name,
        swap_size_MiB,
    )
    spec = vim.HostCacheConfigurationSpec(
        datastore=datastore_ref, swapSize=swap_size_MiB
    )
    log.trace("host_cache_spec=%s", spec)
    try:
        task = host_cache_manager.ConfigureHostCache_Task(spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, hostname, "HostCacheConfigurationTask")
    log.trace("Configured host cache on host '%s'", hostname)
    return True
def list_hosts(service_instance):
    return list_objects(service_instance, vim.HostSystem)
def get_resource_pools(
    service_instance,
    resource_pool_names,
    datacenter_name=None,
    get_all_resource_pools=False,
):
    properties = ["name"]
    if not resource_pool_names:
        resource_pool_names = []
    if datacenter_name:
        container_ref = get_datacenter(service_instance, datacenter_name)
    else:
        container_ref = get_root_folder(service_instance)
    resource_pools = get_mors_with_properties(
        service_instance,
        vim.ResourcePool,
        container_ref=container_ref,
        property_list=properties,
    )
    selected_pools = []
    for pool in resource_pools:
        if get_all_resource_pools or (pool["name"] in resource_pool_names):
            selected_pools.append(pool["object"])
    if not selected_pools:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "The resource pools with properties "
            "names={} get_all={} could not be found".format(
                selected_pools, get_all_resource_pools
            )
        )
    return selected_pools
def list_resourcepools(service_instance):
    return list_objects(service_instance, vim.ResourcePool)
def list_networks(service_instance):
    return list_objects(service_instance, vim.Network)
def list_vms(service_instance):
    return list_objects(service_instance, vim.VirtualMachine)
def list_folders(service_instance):
    return list_objects(service_instance, vim.Folder)
def list_dvs(service_instance):
    return list_objects(service_instance, vim.DistributedVirtualSwitch)
def list_vapps(service_instance):
    return list_objects(service_instance, vim.VirtualApp)
def list_portgroups(service_instance):
    return list_objects(service_instance, vim.dvs.DistributedVirtualPortgroup)
def wait_for_task(task, instance_name, task_type, sleep_seconds=1, log_level="debug"):
    time_counter = 0
    start_time = time.time()
    log.trace("task = %s, task_type = %s", task, task.__class__.__name__)
    try:
        task_info = task.info
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.FileNotFound as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    while task_info.state == "running" or task_info.state == "queued":
        if time_counter % sleep_seconds == 0:
            msg = "[ {} ] Waiting for {} task to finish [{} s]".format(
                instance_name, task_type, time_counter
            )
            if log_level == "info":
                log.info(msg)
            else:
                log.debug(msg)
        time.sleep(1.0 - ((time.time() - start_time) % 1.0))
        time_counter += 1
        try:
            task_info = task.info
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.FileNotFound as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
    if task_info.state == "success":
        msg = "[ {} ] Successfully completed {} task in {} seconds".format(
            instance_name, task_type, time_counter
        )
        if log_level == "info":
            log.info(msg)
        else:
            log.debug(msg)
        return task_info.result
    else:
        try:
            raise task_info.error
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.FileNotFound as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.fault.SystemError as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareSystemError(exc.msg)
        except vmodl.fault.InvalidArgument as exc:
            log.exception(exc)
            exc_message = exc.msg
            if exc.faultMessage:
                exc_message = "{} ({})".format(exc_message, exc.faultMessage[0].message)
            raise salt.exceptions.VMwareApiError(exc_message)
def get_vm_by_property(
    service_instance,
    name,
    datacenter=None,
    vm_properties=None,
    traversal_spec=None,
    parent_ref=None,
):
    if datacenter and not parent_ref:
        parent_ref = salt.utils.vmware.get_datacenter(service_instance, datacenter)
    if not vm_properties:
        vm_properties = [
            "name",
            "config.hardware.device",
            "summary.storage.committed",
            "summary.storage.uncommitted",
            "summary.storage.unshared",
            "layoutEx.file",
            "config.guestFullName",
            "config.guestId",
            "guest.net",
            "config.hardware.memoryMB",
            "config.hardware.numCPU",
            "config.files.vmPathName",
            "summary.runtime.powerState",
            "guest.toolsStatus",
        ]
    vm_list = salt.utils.vmware.get_mors_with_properties(
        service_instance,
        vim.VirtualMachine,
        vm_properties,
        container_ref=parent_ref,
        traversal_spec=traversal_spec,
    )
    vm_formatted = [vm for vm in vm_list if vm["name"] == name]
    if not vm_formatted:
        raise salt.exceptions.VMwareObjectRetrievalError(
            "The virtual machine was not found."
        )
    elif len(vm_formatted) &gt; 1:
        raise salt.exceptions.VMwareMultipleObjectsError(
            " ".join(
                [
                    "Multiple virtual machines were found with the"
                    "same name, please specify a container."
                ]
            )
        )
    return vm_formatted[0]
def get_folder(service_instance, datacenter, placement, base_vm_name=None):
    log.trace("Retrieving folder information")
    if base_vm_name:
        vm_object = get_vm_by_property(
            service_instance, base_vm_name, vm_properties=["name"]
        )
        vm_props = salt.utils.vmware.get_properties_of_managed_object(
            vm_object, properties=["parent"]
        )
        if "parent" in vm_props:
            folder_object = vm_props["parent"]
        else:
            raise salt.exceptions.VMwareObjectRetrievalError(
                " ".join(["The virtual machine parent", "object is not defined"])
            )
    elif "folder" in placement:
        folder_objects = salt.utils.vmware.get_folders(
            service_instance, [placement["folder"]], datacenter
        )
        if len(folder_objects) &gt; 1:
            raise salt.exceptions.VMwareMultipleObjectsError(
                " ".join(
                    [
                        "Multiple instances are available of the",
                        "specified folder {}".format(placement["folder"]),
                    ]
                )
            )
        folder_object = folder_objects[0]
    elif datacenter:
        datacenter_object = salt.utils.vmware.get_datacenter(
            service_instance, datacenter
        )
        dc_props = salt.utils.vmware.get_properties_of_managed_object(
            datacenter_object, properties=["vmFolder"]
        )
        if "vmFolder" in dc_props:
            folder_object = dc_props["vmFolder"]
        else:
            raise salt.exceptions.VMwareObjectRetrievalError(
                "The datacenter vm folder object is not defined"
            )
    return folder_object
def get_placement(service_instance, datacenter, placement=None):
    log.trace("Retrieving placement information")
    resourcepool_object, placement_object = None, None
    if "host" in placement:
        host_objects = get_hosts(
            service_instance, datacenter_name=datacenter, host_names=[placement["host"]]
        )
        if not host_objects:
            raise salt.exceptions.VMwareObjectRetrievalError(
                " ".join(
                    [
                        "The specified host",
                        "{} cannot be found.".format(placement["host"]),
                    ]
                )
            )
        try:
            host_props = get_properties_of_managed_object(
                host_objects[0], properties=["resourcePool"]
            )
            resourcepool_object = host_props["resourcePool"]
        except vmodl.query.InvalidProperty:
            traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
                path="parent",
                skip=True,
                type=vim.HostSystem,
                selectSet=[
                    vmodl.query.PropertyCollector.TraversalSpec(
                        path="resourcePool", skip=False, type=vim.ClusterComputeResource
                    )
                ],
            )
            resourcepools = get_mors_with_properties(
                service_instance,
                vim.ResourcePool,
                container_ref=host_objects[0],
                property_list=["name"],
                traversal_spec=traversal_spec,
            )
            if resourcepools:
                resourcepool_object = resourcepools[0]["object"]
            else:
                raise salt.exceptions.VMwareObjectRetrievalError(
                    "The resource pool of host {} cannot be found.".format(
                        placement["host"]
                    )
                )
        placement_object = host_objects[0]
    elif "resourcepool" in placement:
        resourcepool_objects = get_resource_pools(
            service_instance, [placement["resourcepool"]], datacenter_name=datacenter
        )
        if len(resourcepool_objects) &gt; 1:
            raise salt.exceptions.VMwareMultipleObjectsError(
                " ".join(
                    [
                        "Multiple instances are available of the",
                        "specified host {}.".format(placement["host"]),
                    ]
                )
            )
        resourcepool_object = resourcepool_objects[0]
        res_props = get_properties_of_managed_object(
            resourcepool_object, properties=["parent"]
        )
        if "parent" in res_props:
            placement_object = res_props["parent"]
        else:
            raise salt.exceptions.VMwareObjectRetrievalError(
                " ".join(["The resource pool's parent", "object is not defined"])
            )
    elif "cluster" in placement:
        datacenter_object = get_datacenter(service_instance, datacenter)
        cluster_object = get_cluster(datacenter_object, placement["cluster"])
        clus_props = get_properties_of_managed_object(
            cluster_object, properties=["resourcePool"]
        )
        if "resourcePool" in clus_props:
            resourcepool_object = clus_props["resourcePool"]
        else:
            raise salt.exceptions.VMwareObjectRetrievalError(
                " ".join(["The cluster's resource pool", "object is not defined"])
            )
        placement_object = cluster_object
    else:
        raise salt.exceptions.VMwareObjectRetrievalError(
            " ".join(["Placement is not defined."])
        )
    return (resourcepool_object, placement_object)
def convert_to_kb(unit, size):
    if unit.lower() == "gb":
        target_size = int(size * 1024 * 1024)
    elif unit.lower() == "mb":
        target_size = int(size * 1024)
    elif unit.lower() == "kb":
        target_size = int(size)
    else:
        raise salt.exceptions.ArgumentValueError("The unit is not specified")
    return {"size": target_size, "unit": "KB"}
def power_cycle_vm(virtual_machine, action="on"):
    if action == "on":
        try:
            task = virtual_machine.PowerOn()
            task_name = "power on"
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
    elif action == "off":
        try:
            task = virtual_machine.PowerOff()
            task_name = "power off"
        except vim.fault.NoPermission as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(
                "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
            )
        except vim.fault.VimFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareApiError(exc.msg)
        except vmodl.RuntimeFault as exc:
            log.exception(exc)
            raise salt.exceptions.VMwareRuntimeError(exc.msg)
    else:
        raise salt.exceptions.ArgumentValueError("The given action is not supported")
    try:
        wait_for_task(task, get_managed_object_name(virtual_machine), task_name)
    except salt.exceptions.VMwareFileNotFoundError as exc:
        raise salt.exceptions.VMwarePowerOnError(
            " ".join(
                [
                    "An error occurred during power",
                    "operation, a file was not found: {}".format(exc),
                ]
            )
        )
    return virtual_machine
def create_vm(
    vm_name, vm_config_spec, folder_object, resourcepool_object, host_object=None
):
    try:
        if host_object and isinstance(host_object, vim.HostSystem):
            task = folder_object.CreateVM_Task(
                vm_config_spec, pool=resourcepool_object, host=host_object
            )
        else:
            task = folder_object.CreateVM_Task(vm_config_spec, pool=resourcepool_object)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    vm_object = wait_for_task(task, vm_name, "CreateVM Task", 10, "info")
    return vm_object
def register_vm(datacenter, name, vmx_path, resourcepool_object, host_object=None):
    try:
        if host_object:
            task = datacenter.vmFolder.RegisterVM_Task(
                path=vmx_path,
                name=name,
                asTemplate=False,
                host=host_object,
                pool=resourcepool_object,
            )
        else:
            task = datacenter.vmFolder.RegisterVM_Task(
                path=vmx_path, name=name, asTemplate=False, pool=resourcepool_object
            )
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    try:
        vm_ref = wait_for_task(task, name, "RegisterVM Task")
    except salt.exceptions.VMwareFileNotFoundError as exc:
        raise salt.exceptions.VMwareVmRegisterError(
            "An error occurred during registration operation, the "
            "configuration file was not found: {}".format(exc)
        )
    return vm_ref
def update_vm(vm_ref, vm_config_spec):
    vm_name = get_managed_object_name(vm_ref)
    log.trace("Updating vm '%s'", vm_name)
    try:
        task = vm_ref.ReconfigVM_Task(vm_config_spec)
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    vm_ref = wait_for_task(task, vm_name, "ReconfigureVM Task")
    return vm_ref
def delete_vm(vm_ref):
    vm_name = get_managed_object_name(vm_ref)
    log.trace("Destroying vm '%s'", vm_name)
    try:
        task = vm_ref.Destroy_Task()
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
    wait_for_task(task, vm_name, "Destroy Task")
def unregister_vm(vm_ref):
    vm_name = get_managed_object_name(vm_ref)
    log.trace("Destroying vm '%s'", vm_name)
    try:
        vm_ref.UnregisterVM()
    except vim.fault.NoPermission as exc:
        log.exception(exc)
        raise salt.exceptions.VMwareApiError(
            "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
        )
    except vim.fault.VimFault as exc:
        raise salt.exceptions.VMwareApiError(exc.msg)
    except vmodl.RuntimeFault as exc:
        raise salt.exceptions.VMwareRuntimeError(exc.msg)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
