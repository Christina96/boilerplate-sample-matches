<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for zfs.py &amp; vmware_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for zfs.py &amp; vmware_1.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>zfs.py (18.007664%)<th>vmware_1.py (0.9686727%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(62-82)<td><a href="#" name="0">(818-824)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(218-301)<td><a href="#" name="1">(2455-2467)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(106-124)<td><a href="#" name="2">(795-797)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zfs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.utils.zfs
2 from tests.support.mock import MagicMock, patch
3 class ZFSMockData:
4     def __init__(self):
5         self.pmap_exec_zpool = {
6             "retcode": 2,
7             "stdout": "",
8             "stderr": "\n".join(
9                 [
10                     "missing property argument",
11                     "usage:",
12                     '        get [-Hp] [-o "all" | field[,...]] &lt;"all" |'
13                     " property[,...]&gt; &lt;pool&gt; ...",
14                     "",
15                     "the following properties are supported:",
16                     "",
17                     "        PROPERTY         EDIT   VALUES",
18                     "",
19                     "        allocated          NO   &lt;size&gt;",
20                     "        capacity           NO   &lt;size&gt;",
21                     "        dedupratio         NO   &lt;1.00x or higher if deduped&gt;",
22                     "        expandsize         NO   &lt;size&gt;",
23                     "        fragmentation      NO   &lt;percent&gt;",
24                     "        free               NO   &lt;size&gt;",
25                     "        freeing            NO   &lt;size&gt;",
26                     "        guid               NO   &lt;guid&gt;",
27                     "        health             NO   &lt;state&gt;",
28                     "        leaked             NO   &lt;size&gt;",
29                     "        size               NO   &lt;size&gt;",
30                     "        altroot           YES   &lt;path&gt;",
31                     "        autoexpand        YES   on | off",
32                     "        autoreplace       YES   on | off",
33                     "        bootfs            YES   &lt;filesystem&gt;",
34                     "        bootsize          YES   &lt;size&gt;",
35                     "        cachefile         YES   &lt;file&gt; | none",
36                     "        comment           YES   &lt;comment-string&gt;",
37                     "        dedupditto        YES   &lt;threshold (min 100)&gt;",
38                     "        delegation        YES   on | off",
39                     "        failmode          YES   wait | continue | panic",
40                     "        listsnapshots     YES   on | off",
41                     "        readonly          YES   on | off",
42                     "        version           YES   &lt;version&gt;",
43                     "        feature@...       YES   disabled | enabled | active",
44                     "",
45                     "The feature@ properties must be appended with a feature name.",
46                     "See zpool-features(5). ",
47                 ]
48         }
49         self.pmap_zpool = {
50             <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"comment": {"edit": True, "type": "str", "values": "&lt;comment-string&gt;"},
51             "freeing": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
52             "listsnapshots": {"edit": True, "type": "bool", "values": "on | off"},
53             "leaked": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
54             "version": {"edit": True, "type": "numeric", "values": "&lt;version&gt;"},
55             "write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
56             "replace": {"edit": True, "type": "bool", "values": "on | off"},
57             "delegation": {"edit": True, "type": "bool", "values": "on | off"},
58             "dedupditto": {
59                 "edit": True,
60                 "type": "str",
61                 "values": "&lt;threshold (min 100)&gt;",
62             },
63             "autoexpand": {"edit": True, "type": "bool", "values": "on | off"},
64             "alloc": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
65             "allocated": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
66             "guid": {"edit": False, "type": "numeric", "values": "&lt;guid&gt;"},
67             "size": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
68             "cap": {"edit": False, "type": "numeric", "values": "&lt;count&gt;"},
69             "capacity": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
70             "capacity-alloc": {"edit"</b></font>: False, "type": "size", "values": "&lt;size&gt;"},
71             "capacity-free": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
72             "cachefile": {"edit": True, "type": "str", "values": "&lt;file&gt; | none"},
73             "cksum": {"edit": False, "type": "numeric", "values": "&lt;count&gt;"},
74             "bootfs": {"edit": True, "type": "str", "values": "&lt;filesystem&gt;"},
75             "autoreplace": {"edit": True, "type": "bool", "values": "on | off"},
76             "bandwidth-read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
77             "bandwidth-write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
78             "operations-read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
79             "operations-write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
80             "read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
81             "readonly": {"edit": True, "type": "bool", "values": "on | off"},
82             "dedupratio": {
83                 "edit": False,
84                 "type": "str",
85                 "values": "&lt;1.00x or higher if deduped&gt;",
86             },
87             "health": {"edit": False, "type": "str", "values": "&lt;state&gt;"},
88             "feature@": {
89                 "edit": True,
90                 "type": "str",
91             },
92             "expandsize": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
93             "listsnaps": {<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"edit": True, "type": "bool", "values": "on | off"},
94             "bootsize": {"edit": True, "type": "size", "values": "&lt;size&gt;"},
95             "free": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
96             "failmode": {
97                 "edit": True,
98                 "type": "str",
99                 "values": "wait | continue | panic",
100             },
101             "altroot": {"edit": True, "type": "str", "values": "&lt;path&gt;"},
102             "expand": {"edit": True, "type": "bool", "values": "on | off"},
103             "frag": {"edit": False, "type": "str", "values": "&lt;percent&gt;"},
104             "fragmentation": {"edit": False, "type": "str", "values": "&lt;percent&gt;"},
105         }
106         self.pmap_exec_zfs = {
107             "retcode": 2,
108             "stdout": "",
109             "stderr": "\n".</b></font>join(
110                 [
111                     "missing property argument",
112                     "usage:",
113                     '        get [-crHp] [-d max] [-o "all" | field[,...]]',
114                     "            [-t type[,...]] [-s source[,...]]",
115                     '            &lt;"all" | property[,...]&gt;'
116                     " [filesystem|volume|snapshot|bookmark] ...",
117                     "",
118                     "The following properties are supported:",
119                     "",
120                     "        PROPERTY       EDIT  INHERIT   VALUES",
121                     "",
122                     "        available        NO       NO   &lt;size&gt;",
123                     "        clones           NO       NO   &lt;dataset&gt;[,...]",
124                     "        compressratio    NO       NO   &lt;1.00x or higher if compressed&gt;",
125                     "        creation         NO       NO   &lt;date&gt;",
126                     "        defer_destroy    NO       NO   yes | no",
127                     "        filesystem_count  NO       NO   &lt;count&gt;",
128                     "        logicalreferenced  NO       NO   &lt;size&gt;",
129                     "        logicalused      NO       NO   &lt;size&gt;",
130                     "        mounted          NO       NO   yes | no",
131                     "        origin           NO       NO   &lt;snapshot&gt;",
132                     "        receive_resume_token  NO       NO   &lt;string token&gt;",
133                     "        refcompressratio  NO       NO   &lt;1.00x or higher if compressed&gt;",
134                     "        referenced       NO       NO   &lt;size&gt;",
135                     "        snapshot_count   NO       NO   &lt;count&gt;",
136                     "        type             NO       NO   filesystem | volume | snapshot | bookmark",
137                     "        used             NO       NO   &lt;size&gt;",
138                     "        usedbychildren   NO       NO   &lt;size&gt;",
139                     "        usedbydataset    NO       NO   &lt;size&gt;",
140                     "        usedbyrefreservation  NO       NO   &lt;size&gt;",
141                     "        usedbysnapshots  NO       NO   &lt;size&gt;",
142                     "        userrefs         NO       NO   &lt;count&gt;",
143                     "        written          NO       NO   &lt;size&gt;",
144                     "        aclinherit      YES      YES   discard | noallow | restricted | passthrough | passthrough-x",
145                     "        aclmode         YES      YES   discard | groupmask | passthrough | restricted",
146                     "        atime           YES      YES   on | off",
147                     "        canmount        YES       NO   on | off | noauto",
148                     "        casesensitivity  NO      YES   sensitive | insensitive | mixed",
149                     "        checksum        YES      YES   on | off | fletcher2 | fletcher4 | sha256 | sha512 | skein | edonr",
150                     "        compression     YES      YES   on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
151                     "        copies          YES      YES   1 | 2 | 3",
152                     "        dedup           YES      YES   on | off | verify | sha256[,verify], sha512[,verify], skein[,verify], edonr,verify",
153                     "        devices         YES      YES   on | off",
154                     "        exec            YES      YES   on | off",
155                     "        filesystem_limit YES       NO   &lt;count&gt; | none",
156                     "        logbias         YES      YES   latency | throughput",
157                     "        mlslabel        YES      YES   &lt;sensitivity label&gt;",
158                     "        mountpoint      YES      YES   &lt;path&gt; | legacy | none",
159                     "        nbmand          YES      YES   on | off",
160                     "        normalization    NO      YES   none | formC | formD | formKC | formKD",
161                     "        primarycache    YES      YES   all | none | metadata",
162                     "        quota           YES       NO   &lt;size&gt; | none",
163                     "        readonly        YES      YES   on | off",
164                     "        recordsize      YES      YES   512 to 1M, power of 2",
165                     "        redundant_metadata YES      YES   all | most",
166                     "        refquota        YES       NO   &lt;size&gt; | none",
167                     "        refreservation  YES       NO   &lt;size&gt; | none",
168                     "        reservation     YES       NO   &lt;size&gt; | none",
169                     "        secondarycache  YES      YES   all | none | metadata",
170                     "        setuid          YES      YES   on | off",
171                     "        sharenfs        YES      YES   on | off | share(1M) options",
172                     "        sharesmb        YES      YES   on | off | sharemgr(1M) options",
173                     "        snapdir         YES      YES   hidden | visible",
174                     "        snapshot_limit  YES       NO   &lt;count&gt; | none",
175                     "        sync            YES      YES   standard | always | disabled",
176                     "        utf8only         NO      YES   on | off",
177                     "        version         YES       NO   1 | 2 | 3 | 4 | 5 | current",
178                     "        volblocksize     NO      YES   512 to 128k, power of 2",
179                     "        volsize         YES       NO   &lt;size&gt;",
180                     "        vscan           YES      YES   on | off",
181                     "        xattr           YES      YES   on | off",
182                     "        zoned           YES      YES   on | off",
183                     "        userused@...     NO       NO   &lt;size&gt;",
184                     "        groupused@...    NO       NO   &lt;size&gt;",
185                     "        userquota@...   YES       NO   &lt;size&gt; | none",
186                     "        groupquota@...  YES       NO   &lt;size&gt; | none",
187                     "        written@&lt;snap&gt;   NO       NO   &lt;size&gt;",
188                     "",
189                     "Sizes are specified in bytes with standard units such as K, M, G, etc.",
190                     "",
191                     "User-defined properties can be specified by using a name containing a colon (:).",
192                     "",
193                     "The {user|group}{used|quota}@ properties must be appended with",
194                     "a user or group specifier of one of these forms:",
195                     '    POSIX name      (eg: "matt")',
196                     '    POSIX id        (eg: "126829")',
197                     '    SMB name@domain (eg: "matt@sun")',
198                     '    SMB SID         (eg: "S-1-234-567-89")',
199                 ]
200         }
201         self.pmap_zfs <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
202             "origin": {
203                 "edit": False,
204                 "inherit": False,
205                 "values": "&lt;snapshot&gt;",
206                 "type": "str",
207             },
208             "setuid": {
209                 "edit": True,
210                 "inherit": True,
211                 "values": "on | off",
212                 "type": "bool",
213             },
214             "referenced": {
215                 "edit": False,
216                 "inherit": False,
217                 "values": "&lt;size&gt;",
218                 "type": "size",
219             },
220             "vscan": {
221                 "edit": True,
222                 "inherit": True,
223                 "values": "on | off",
224                 "type": "bool",
225             },
226             "logicalused": {
227                 "edit": False,
228                 "inherit": False,
229                 "values": "&lt;size&gt;",
230                 "type": "size",
231             },
232             "userrefs": {
233                 "edit": False,
234                 "inherit": False,
235                 "values": "&lt;count&gt;",
236                 "type": "numeric",
237             },
238             "primarycache": {
239                 "edit": True,
240                 "inherit": True,
241                 "values": "all | none | metadata",
242                 "type": "str",
243             },
244             "logbias": {
245                 "edit": True,
246                 "inherit": True,
247                 "values": "latency | throughput",
248                 "type": "str",
249             },
250             "creation": {
251                 "edit": False,
252                 "inherit": False,
253                 "values": "&lt;date&gt;",
254                 "type": "str",
255             },
256             "sync": {
257                 "edit": True,
258                 "inherit": True,
259                 "values": "standard | always | disabled",
260                 "type": "str",
261             },
262             "dedup": {
263                 "edit": True,
264                 "inherit": True,
265                 "values": (
266                     "on | off | verify | sha256[,verify], sha512[,verify],"
267                     " skein[,verify], edonr,verify"
268                 ),
269                 "type": "bool",
270             },
271             "sharenfs": {
272                 "edit": True,
273                 "inherit": True,
274                 "values": "on | off | share(1m) options",
275                 "type": "bool",
276             },
277             "receive_resume_token": {
278                 "edit": False,
279                 "inherit": False,
280                 "values": "&lt;string token&gt;",
281                 "type": "str",
282             },
283             "usedbyrefreservation": {
284                 "edit"</b></font>: False,
285                 "inherit": False,
286                 "values": "&lt;size&gt;",
287                 "type": "size",
288             },
289             "sharesmb": {
290                 "edit": True,
291                 "inherit": True,
292                 "values": "on | off | sharemgr(1m) options",
293                 "type": "bool",
294             },
295             "rdonly": {
296                 "edit": True,
297                 "inherit": True,
298                 "values": "on | off",
299                 "type": "bool",
300             },
301             "reservation": {
302                 "edit": True,
303                 "inherit": False,
304                 "values": "&lt;size&gt; | none",
305                 "type": "size",
306             },
307             "reserv": {
308                 "edit": True,
309                 "inherit": False,
310                 "values": "&lt;size&gt; | none",
311                 "type": "size",
312             },
313             "mountpoint": {
314                 "edit": True,
315                 "inherit": True,
316                 "values": "&lt;path&gt; | legacy | none",
317                 "type": "str",
318             },
319             "casesensitivity": {
320                 "edit": False,
321                 "inherit": True,
322                 "values": "sensitive | insensitive | mixed",
323                 "type": "str",
324             },
325             "utf8only": {
326                 "edit": False,
327                 "inherit": True,
328                 "values": "on | off",
329                 "type": "bool",
330             },
331             "usedbysnapshots": {
332                 "edit": False,
333                 "inherit": False,
334                 "values": "&lt;size&gt;",
335                 "type": "size",
336             },
337             "readonly": {
338                 "edit": True,
339                 "inherit": True,
340                 "values": "on | off",
341                 "type": "bool",
342             },
343             "written@": {
344                 "edit": False,
345                 "inherit": False,
346                 "values": "&lt;size&gt;",
347                 "type": "size",
348             },
349             "avail": {
350                 "edit": False,
351                 "inherit": False,
352                 "values": "&lt;size&gt;",
353                 "type": "size",
354             },
355             "recsize": {
356                 "edit": True,
357                 "inherit": True,
358                 "values": "512 to 1m, power of 2",
359                 "type": "str",
360             },
361             "atime": {
362                 "edit": True,
363                 "inherit": True,
364                 "values": "on | off",
365                 "type": "bool",
366             },
367             "compression": {
368                 "edit": True,
369                 "inherit": True,
370                 "values": "on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
371                 "type": "bool",
372             },
373             "snapdir": {
374                 "edit": True,
375                 "inherit": True,
376                 "values": "hidden | visible",
377                 "type": "str",
378             },
379             "aclmode": {
380                 "edit": True,
381                 "inherit": True,
382                 "values": "discard | groupmask | passthrough | restricted",
383                 "type": "str",
384             },
385             "zoned": {
386                 "edit": True,
387                 "inherit": True,
388                 "values": "on | off",
389                 "type": "bool",
390             },
391             "copies": {
392                 "edit": True,
393                 "inherit": True,
394                 "values": "1 | 2 | 3",
395                 "type": "numeric",
396             },
397             "snapshot_limit": {
398                 "edit": True,
399                 "inherit": False,
400                 "values": "&lt;count&gt; | none",
401                 "type": "numeric",
402             },
403             "aclinherit": {
404                 "edit": True,
405                 "inherit": True,
406                 "values": (
407                     "discard | noallow | restricted | passthrough | passthrough-x"
408                 ),
409                 "type": "str",
410             },
411             "compressratio": {
412                 "edit": False,
413                 "inherit": False,
414                 "values": "&lt;1.00x or higher if compressed&gt;",
415                 "type": "str",
416             },
417             "xattr": {
418                 "edit": True,
419                 "inherit": True,
420                 "values": "on | off",
421                 "type": "bool",
422             },
423             "written": {
424                 "edit": False,
425                 "inherit": False,
426                 "values": "&lt;size&gt;",
427                 "type": "size",
428             },
429             "version": {
430                 "edit": True,
431                 "inherit": False,
432                 "values": "1 | 2 | 3 | 4 | 5 | current",
433                 "type": "numeric",
434             },
435             "recordsize": {
436                 "edit": True,
437                 "inherit": True,
438                 "values": "512 to 1m, power of 2",
439                 "type": "str",
440             },
441             "refquota": {
442                 "edit": True,
443                 "inherit": False,
444                 "values": "&lt;size&gt; | none",
445                 "type": "size",
446             },
447             "filesystem_limit": {
448                 "edit": True,
449                 "inherit": False,
450                 "values": "&lt;count&gt; | none",
451                 "type": "numeric",
452             },
453             "lrefer.": {
454                 "edit": False,
455                 "inherit": False,
456                 "values": "&lt;size&gt;",
457                 "type": "size",
458             },
459             "type": {
460                 "edit": False,
461                 "inherit": False,
462                 "values": "filesystem | volume | snapshot | bookmark",
463                 "type": "str",
464             },
465             "secondarycache": {
466                 "edit": True,
467                 "inherit": True,
468                 "values": "all | none | metadata",
469                 "type": "str",
470             },
471             "refer": {
472                 "edit": False,
473                 "inherit": False,
474                 "values": "&lt;size&gt;",
475                 "type": "size",
476             },
477             "available": {
478                 "edit": False,
479                 "inherit": False,
480                 "values": "&lt;size&gt;",
481                 "type": "size",
482             },
483             "used": {
484                 "edit": False,
485                 "inherit": False,
486                 "values": "&lt;size&gt;",
487                 "type": "size",
488             },
489             "exec": {
490                 "edit": True,
491                 "inherit": True,
492                 "values": "on | off",
493                 "type": "bool",
494             },
495             "compress": {
496                 "edit": True,
497                 "inherit": True,
498                 "values": "on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
499                 "type": "bool",
500             },
501             "volblock": {
502                 "edit": False,
503                 "inherit": True,
504                 "values": "512 to 128k, power of 2",
505                 "type": "str",
506             },
507             "refcompressratio": {
508                 "edit": False,
509                 "inherit": False,
510                 "values": "&lt;1.00x or higher if compressed&gt;",
511                 "type": "str",
512             },
513             "quota": {
514                 "edit": True,
515                 "inherit": False,
516                 "values": "&lt;size&gt; | none",
517                 "type": "size",
518             },
519             "groupquota@": {
520                 "edit": True,
521                 "inherit": False,
522                 "values": "&lt;size&gt; | none",
523                 "type": "size",
524             },
525             "userquota@": {
526                 "edit": True,
527                 "inherit": False,
528                 "values": "&lt;size&gt; | none",
529                 "type": "size",
530             },
531             "snapshot_count": {
532                 "edit": False,
533                 "inherit": False,
534                 "values": "&lt;count&gt;",
535                 "type": "numeric",
536             },
537             "volsize": {
538                 "edit": True,
539                 "inherit": False,
540                 "values": "&lt;size&gt;",
541                 "type": "size",
542             },
543             "clones": {
544                 "edit": False,
545                 "inherit": False,
546                 "values": "&lt;dataset&gt;[,...]",
547                 "type": "str",
548             },
549             "canmount": {
550                 "edit": True,
551                 "inherit": False,
552                 "values": "on | off | noauto",
553                 "type": "bool",
554             },
555             "mounted": {
556                 "edit": False,
557                 "inherit": False,
558                 "values": "yes | no",
559                 "type": "bool_alt",
560             },
561             "groupused@": {
562                 "edit": False,
563                 "inherit": False,
564                 "values": "&lt;size&gt;",
565                 "type": "size",
566             },
567             "normalization": {
568                 "edit": False,
569                 "inherit": True,
570                 "values": "none | formc | formd | formkc | formkd",
571                 "type": "str",
572             },
573             "usedbychildren": {
574                 "edit": False,
575                 "inherit": False,
576                 "values": "&lt;size&gt;",
577                 "type": "size",
578             },
579             "usedbydataset": {
580                 "edit": False,
581                 "inherit": False,
582                 "values": "&lt;size&gt;",
583                 "type": "size",
584             },
585             "mlslabel": {
586                 "edit": True,
587                 "inherit": True,
588                 "values": "&lt;sensitivity label&gt;",
589                 "type": "str",
590             },
591             "refreserv": {
592                 "edit": True,
593                 "inherit": False,
594                 "values": "&lt;size&gt; | none",
595                 "type": "size",
596             },
597             "defer_destroy": {
598                 "edit": False,
599                 "inherit": False,
600                 "values": "yes | no",
601                 "type": "bool_alt",
602             },
603             "volblocksize": {
604                 "edit": False,
605                 "inherit": True,
606                 "values": "512 to 128k, power of 2",
607                 "type": "str",
608             },
609             "lused.": {
610                 "edit": False,
611                 "inherit": False,
612                 "values": "&lt;size&gt;",
613                 "type": "size",
614             },
615             "redundant_metadata": {
616                 "edit": True,
617                 "inherit": True,
618                 "values": "all | most",
619                 "type": "str",
620             },
621             "filesystem_count": {
622                 "edit": False,
623                 "inherit": False,
624                 "values": "&lt;count&gt;",
625                 "type": "numeric",
626             },
627             "devices": {
628                 "edit": True,
629                 "inherit": True,
630                 "values": "on | off",
631                 "type": "bool",
632             },
633             "refreservation": {
634                 "edit": True,
635                 "inherit": False,
636                 "values": "&lt;size&gt; | none",
637                 "type": "size",
638             },
639             "userused@": {
640                 "edit": False,
641                 "inherit": False,
642                 "values": "&lt;size&gt;",
643                 "type": "size",
644             },
645             "logicalreferenced": {
646                 "edit": False,
647                 "inherit": False,
648                 "values": "&lt;size&gt;",
649                 "type": "size",
650             },
651             "checksum": {
652                 "edit": True,
653                 "inherit": True,
654                 "values": (
655                     "on | off | fletcher2 | fletcher4 | sha256 | sha512 | skein | edonr"
656                 ),
657                 "type": "bool",
658             },
659             "nbmand": {
660                 "edit": True,
661                 "inherit": True,
662                 "values": "on | off",
663                 "type": "bool",
664             },
665         }
666     def _from_auto(self, name, value, source="auto"):
667         with patch.object(
668             salt.utils.zfs,
669             "property_data_zpool",
670             MagicMock(return_value=self.pmap_zpool),
671         ), patch.object(
672             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
673         ):
674             return salt.utils.zfs.from_auto(name, value, source)
675     def _from_auto_dict(self, values, source="auto"):
676         with patch.object(
677             salt.utils.zfs,
678             "property_data_zpool",
679             MagicMock(return_value=self.pmap_zpool),
680         ), patch.object(
681             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
682         ):
683             return salt.utils.zfs.from_auto_dict(values, source)
684     def _to_auto(self, name, value, source="auto", convert_to_human=True):
685         with patch.object(
686             salt.utils.zfs,
687             "property_data_zpool",
688             MagicMock(return_value=self.pmap_zpool),
689         ), patch.object(
690             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
691         ):
692             return salt.utils.zfs.to_auto(name, value, source, convert_to_human)
693     def _to_auto_dict(self, values, source="auto", convert_to_human=True):
694         with patch.object(
695             salt.utils.zfs,
696             "property_data_zpool",
697             MagicMock(return_value=self.pmap_zpool),
698         ), patch.object(
699             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
700         ):
701             return salt.utils.zfs.to_auto_dict(values, source, convert_to_human)
702     def get_patched_utils(self):
703         return {
704             "zfs.is_supported": MagicMock(return_value=True),
705             "zfs.has_feature_flags": MagicMock(return_value=True),
706             "zfs.property_data_zpool": MagicMock(return_value=self.pmap_zpool),
707             "zfs.property_data_zfs": MagicMock(return_value=self.pmap_zfs),
708             "zfs.zpool_command": MagicMock(return_value="/bin/false"),
709             "zfs.zfs_command": MagicMock(return_value="/bin/false"),
710             "zfs.from_auto_dict": self._from_auto_dict,
711             "zfs.from_auto": self._from_auto,
712             "zfs.to_auto_dict": self._to_auto_dict,
713             "zfs.to_auto": self._to_auto,
714         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vmware_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import atexit
2 import errno
3 import logging
4 import ssl
5 import time
6 from http.client import BadStatusLine
7 import salt.exceptions
8 import salt.modules.cmdmod
9 import salt.utils.path
10 import salt.utils.platform
11 import salt.utils.stringutils
12 try:
13     from pyVim.connect import GetSi, SmartConnect, Disconnect, GetStub, SoapStubAdapter
14     from pyVmomi import vim, vmodl, VmomiSupport
15     HAS_PYVMOMI = True
16 except ImportError:
17     HAS_PYVMOMI = False
18 try:
19     from com.vmware.vapi.std.errors_client import Unauthenticated
20     from vmware.vapi.vsphere.client import create_vsphere_client
21     HAS_VSPHERE_SDK = True
22 except ImportError:
23     HAS_VSPHERE_SDK = False
24 try:
25     import gssapi
26     import base64
27     HAS_GSSAPI = True
28 except ImportError:
29     HAS_GSSAPI = False
30 log = logging.getLogger(__name__)
31 def __virtual__():
32     if HAS_PYVMOMI:
33         return True
34     return False, "Missing dependency: The salt.utils.vmware module requires pyVmomi."
35 def esxcli(
36     host, user, pwd, cmd, protocol=None, port=None, esxi_host=None, credstore=None
37 ):
38     esx_cmd = salt.utils.path.which("esxcli")
39     if not esx_cmd:
40         log.error(
41             "Missing dependency: The salt.utils.vmware.esxcli function requires ESXCLI."
42         )
43         return False
44     if port is None:
45         port = 443
46     if protocol is None:
47         protocol = "https"
48     if credstore:
49         esx_cmd += " --credstore '{}'".format(credstore)
50     if not esxi_host:
51         esx_cmd += " -s {} -u {} -p '{}' --protocol={} --portnumber={} {}".format(
52             host, user, pwd, protocol, port, cmd
53         )
54     else:
55         esx_cmd += " -s {} -h {} -u {} -p '{}' --protocol={} --portnumber={} {}".format(
56             host, esxi_host, user, pwd, protocol, port, cmd
57         )
58     ret = salt.modules.cmdmod.run_all(esx_cmd, output_loglevel="quiet")
59     return ret
60 def get_vsphere_client(
61     server, username, password, session=None, verify_ssl=True, ca_bundle=None
62 ):
63     if not session:
64         session = salt.utils.http.session(verify_ssl=verify_ssl, ca_bundle=ca_bundle)
65     client = None
66     try:
67         client = create_vsphere_client(
68             server=server, username=username, password=password, session=session
69         )
70     except Unauthenticated as err:
71         log.trace(err)
72     return client
73 def _get_service_instance(
74     host,
75     username,
76     password,
77     protocol,
78     port,
79     mechanism,
80     principal,
81     domain,
82     verify_ssl=True,
83 ):
84     log.trace("Retrieving new service instance")
85     token = None
86     if mechanism == "userpass":
87         if username is None:
88             raise salt.exceptions.CommandExecutionError(
89                 "Login mechanism userpass was specified but the mandatory "
90                 "parameter 'username' is missing"
91             )
92         if password is None:
93             raise salt.exceptions.CommandExecutionError(
94                 "Login mechanism userpass was specified but the mandatory "
95                 "parameter 'password' is missing"
96             )
97     elif mechanism == "sspi":
98         if principal is not None and domain is not None:
99             try:
100                 token = get_gssapi_token(principal, host, domain)
101             except Exception as exc:  # pylint: disable=broad-except
102                 raise salt.exceptions.VMwareConnectionError(str(exc))
103         else:
104             err_msg = (
105                 "Login mechanism '{}' was specified but the"
106                 " mandatory parameters are missing".format(mechanism)
107             )
108             raise salt.exceptions.CommandExecutionError(err_msg)
109     else:
110         raise salt.exceptions.CommandExecutionError(
111             "Unsupported mechanism: '{}'".format(mechanism)
112         )
113     log.trace(
114         "Connecting using the '%s' mechanism, with username '%s'",
115         mechanism,
116         username,
117     )
118     default_msg = (
119         "Could not connect to host '{}'. "
120         "Please check the debug log for more information.".format(host)
121     )
122     try:
123         if verify_ssl:
124             service_instance = SmartConnect(
125                 host=host,
126                 user=username,
127                 pwd=password,
128                 protocol=protocol,
129                 port=port,
130                 b64token=token,
131                 mechanism=mechanism,
132             )
133     except TypeError as exc:
134         if "unexpected keyword argument" in exc.message:
135             log.error(
136                 "Initial connect to the VMware endpoint failed with %s", exc.message
137             )
138             log.error(
139                 "This may mean that a version of PyVmomi EARLIER than 6.0.0.2016.6 is"
140                 " installed."
141             )
142             log.error("We recommend updating to that version or later.")
143             raise
144     except Exception as exc:  # pylint: disable=broad-except
145         if (
146             isinstance(exc, vim.fault.HostConnectFault)
147             and "[SSL: CERTIFICATE_VERIFY_FAILED]" in exc.msg
148         ) or "[SSL: CERTIFICATE_VERIFY_FAILED]" in str(exc):
149             err_msg = (
150                 "Could not verify the SSL certificate. You can use "
151                 "verify_ssl: False if you do not want to verify the "
152                 "SSL certificate. This is not recommended as it is "
153                 "considered insecure."
154             )
155         else:
156             log.exception(exc)
157             err_msg = exc.msg if hasattr(exc, "msg") else default_msg
158         raise salt.exceptions.VMwareConnectionError(err_msg)
159     if not verify_ssl:
160         try:
161             service_instance = SmartConnect(
162                 host=host,
163                 user=username,
164                 pwd=password,
165                 protocol=protocol,
166                 port=port,
167                 sslContext=ssl._create_unverified_context(),
168                 b64token=token,
169                 mechanism=mechanism,
170             )
171         except Exception as exc:  # pylint: disable=broad-except
172             if "certificate verify failed" in str(exc):
173                 context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
174                 context.verify_mode = ssl.CERT_NONE
175                 try:
176                     service_instance = SmartConnect(
177                         host=host,
178                         user=username,
179                         pwd=password,
180                         protocol=protocol,
181                         port=port,
182                         sslContext=context,
183                         b64token=token,
184                         mechanism=mechanism,
185                     )
186                 except Exception as exc:  # pylint: disable=broad-except
187                     log.exception(exc)
188                     err_msg = exc.msg if hasattr(exc, "msg") else str(exc)
189                     raise salt.exceptions.VMwareConnectionError(
190                         "Could not connect to host '{}': {}".format(host, err_msg)
191                     )
192             else:
193                 err_msg = exc.msg if hasattr(exc, "msg") else default_msg
194                 log.trace(exc)
195                 raise salt.exceptions.VMwareConnectionError(err_msg)
196     atexit.register(Disconnect, service_instance)
197     return service_instance
198 def get_customizationspec_ref(si, customization_spec_name):
199     customization_spec_name = si.content.customizationSpecManager.GetCustomizationSpec(
200         name=customization_spec_name
201     )
202     return customization_spec_name
203 def get_mor_using_container_view(si, obj_type, obj_name):
204     inventory = get_inventory(si)
205     container = inventory.viewManager.CreateContainerView(
206         inventory.rootFolder, [obj_type], True
207     )
208     for item in container.view:
209         if item.name == obj_name:
210             return item
211     return None
212 def get_service_instance(
213     host,
214     username=None,
215     password=None,
216     protocol=None,
217     port=None,
218     mechanism="userpass",
219     principal=None,
220     domain=None,
221     verify_ssl=True,
222 ):
223     if protocol is None:
224         protocol = "https"
225     if port is None:
226         port = 443
227     service_instance = GetSi()
228     if service_instance:
229         stub = GetStub()
230         if salt.utils.platform.is_proxy() or (
231             hasattr(stub, "host") and stub.host != ":".join([host, str(port)])
232         ):
233             Disconnect(service_instance)
234             service_instance = None
235     if not service_instance:
236         service_instance = _get_service_instance(
237             host,
238             username,
239             password,
240             protocol,
241             port,
242             mechanism,
243             principal,
244             domain,
245             verify_ssl=verify_ssl,
246         )
247     log.trace("Checking connection is still authenticated")
248     try:
249         service_instance.CurrentTime()
250     except vim.fault.NotAuthenticated:
251         log.trace("Session no longer authenticating. Reconnecting")
252         Disconnect(service_instance)
253         service_instance = _get_service_instance(
254             host,
255             username,
256             password,
257             protocol,
258             port,
259             mechanism,
260             principal,
261             domain,
262             verify_ssl=verify_ssl,
263         )
264     except vim.fault.NoPermission as exc:
265         log.exception(exc)
266         raise salt.exceptions.VMwareApiError(
267             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
268         )
269     except vim.fault.VimFault as exc:
270         log.exception(exc)
271         raise salt.exceptions.VMwareApiError(exc.msg)
272     except vmodl.RuntimeFault as exc:
273         log.exception(exc)
274         raise salt.exceptions.VMwareRuntimeError(exc.msg)
275     return service_instance
276 def get_new_service_instance_stub(service_instance, path, ns=None, version=None):
277     context = ssl.create_default_context()
278     context.check_hostname = False
279     context.verify_mode = ssl.CERT_NONE
280     stub = service_instance._stub
281     hostname = stub.host.split(":")[0]
282     session_cookie = stub.cookie.split('"')[1]
283     VmomiSupport.GetRequestContext()["vcSessionCookie"] = session_cookie
284     new_stub = SoapStubAdapter(
285         host=hostname, ns=ns, path=path, version=version, poolSize=0, sslContext=context
286     )
287     new_stub.cookie = stub.cookie
288     return new_stub
289 def get_service_instance_from_managed_object(mo_ref, name="&lt;unnamed&gt;"):
290     """
291     Retrieves the service instance from a managed object.
292     me_ref
293         Reference to a managed object (of type vim.ManagedEntity).
294     name
295         Name of managed object. This field is optional.
296     Function that disconnects from the vCenter server or ESXi host
297     service_instance
298         The Service Instance from which to obtain managed object references.
299     Function that returns True if the connection is made to a vCenter Server and
300     False if the connection is made to an ESXi host
301     service_instance
302         The Service Instance from which to obtain managed object references.
303     Returns information of the vCenter or ESXi host
304     service_instance
305         The Service Instance from which to obtain managed object references.
306     Return a reference to a Distributed Virtual Switch object.
307     :param service_instance: PyVmomi service instance
308     :param dvs_name: Name of DVS to return
309     :return: A PyVmomi DVS object
310     Helper function that returns a list of PhysicalNics and their information.
311     Helper function that returns a list of VirtualNics and their information.
312     Helper function that returns a list of Virtual NicManagers
313     and their information.
314     Return a portgroup object corresponding to the portgroup name on the dvs
315     :param dvs: DVS object
316     :param portgroup_name: Name of portgroup to return
317     :return: Portgroup object
318     Return a portgroup object corresponding to the portgroup name on the dvs
319     :param dvs: DVS object
320     :param portgroup_name: Name of portgroup to return
321     :return: Portgroup object
322     Get the gssapi token for Kerberos connection
323     principal
324        The service principal
325     host
326        Host url where we would like to authenticate
327     domain
328        Kerberos user domain
329     Return hardware info for standard minion grains if the service_instance is a HostAgent type
330     service_instance
331         The service instance object to get hardware info for
332     .. versionadded:: 2016.11.0
333     """
334             for _vnic in view<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.view[0].configManager.networkSystem.networkConfig.vnic:
335                 hw_grain_data["ip_interfaces"][_vnic.device] = []
336                 hw_grain_data["ip4_interfaces"][</b></font>_vnic.device] = []
337                 hw_grain_data["ip6_interfaces"][_vnic.device] = []
338                 hw_grain_data["ip_interfaces"][_vnic.device].append(
339                     _vnic.spec.ip.ipAddress
340                 )
341                 hw_grain_data["ip4_interfaces"][_vnic.device].append(
342                     _vnic.spec.ip.ipAddress
343                 )
344                 if _vnic.spec.ip.ipV6Config:
345                     hw_grain_data["ip6_interfaces"][_vnic.device].append(
346                         _vnic.spec.ip.ipV6Config.ipV6Address
347                     )
348                 hw_grain_data["hwaddr_interfaces"][_vnic.device] = _vnic.spec.mac
349             hw_grain_data["host"] = view.view[
350                 0
351             ].configManager.networkSystem.dnsConfig.hostName
352             hw_grain_data["domain"] = view.view[
353             ].configManager.networkSystem.dnsConfig.domainName
354             hw_grain_data["fqdn"] = "{}{}{}".format(
355                 view<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.view[0].configManager.networkSystem.dnsConfig.hostName,
356                 (
357                     "."
358                     if view.view[0].configManager.networkSystem.dnsConfig.domainName
359                     else ""
360                 ),
361                 view.view[0].configManager.networkSystem.dnsConfig.</b></font>domainName,
362             )
363             for _pnic in view.view[0].configManager.networkSystem.networkInfo.pnic:
364                 hw_grain_data["hwaddr_interfaces"][_pnic.device] = _pnic.mac
365             hw_grain_data["timezone"] = view.view[
366                 0
367             ].configManager.dateTimeSystem.dateTimeInfo.timeZone.name
368         view = None
369     return hw_grain_data
370 def get_inventory(service_instance):
371     """
372     Return the inventory of a Service Instance Object.
373     service_instance
374         The Service Instance Object for which to obtain inventory.
375     """
376     return service_instance.RetrieveContent()
377 def get_root_folder(service_instance):
378     """
379     Returns the root folder of a vCenter.
380     service_instance
381         The Service Instance Object for which to obtain the root folder.
382     """
383     try:
384         log.trace("Retrieving root folder")
385         return service_instance.RetrieveContent().rootFolder
386     except vim.fault.NoPermission as exc:
387         log.exception(exc)
388         raise salt.exceptions.VMwareApiError(
389             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
390         )
391     except vim.fault.VimFault as exc:
392         log.exception(exc)
393         raise salt.exceptions.VMwareApiError(exc.msg)
394     except vmodl.RuntimeFault as exc:
395         log.exception(exc)
396         raise salt.exceptions.VMwareRuntimeError(exc.msg)
397 def get_content(
398     service_instance,
399     obj_type,
400     property_list=None,
401     container_ref=None,
402     traversal_spec=None,
403     local_properties=False,
404 ):
405     """
406     Returns the content of the specified type of object for a Service Instance.
407     For more information, please see:
408     http://pubs.vmware.com/vsphere-50/index.jsp?topic=%2Fcom.vmware.wssdk.pg.doc_50%2FPG_Ch5_PropertyCollector.7.6.html
409     service_instance
410         The Service Instance from which to obtain content.
411     obj_type
412         The type of content to obtain.
413     property_list
414         An optional list of object properties to used to return even more filtered content results.
415     container_ref
416         An optional reference to the managed object to search under. Can either be an object of type Folder, Datacenter,
417         ComputeResource, Resource Pool or HostSystem. If not specified, default behaviour is to search under the inventory
418         rootFolder.
419     traversal_spec
420         An optional TraversalSpec to be used instead of the standard
421         ``Traverse All`` spec.
422     local_properties
423         Flag specifying whether the properties to be retrieved are local to the
424         container. If that is the case, the traversal spec needs to be None.
425     """
426     if not container_ref:
427         container_ref = get_root_folder(service_instance)
428     obj_ref = container_ref
429     local_traversal_spec = False
430     if not traversal_spec and not local_properties:
431         local_traversal_spec = True
432         try:
433             obj_ref = service_instance.content.viewManager.CreateContainerView(
434                 container_ref, [obj_type], True
435             )
436         except vim.fault.NoPermission as exc:
437             log.exception(exc)
438             raise salt.exceptions.VMwareApiError(
439                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
440             )
441         except vim.fault.VimFault as exc:
442             log.exception(exc)
443             raise salt.exceptions.VMwareApiError(exc.msg)
444         except vmodl.RuntimeFault as exc:
445             log.exception(exc)
446             raise salt.exceptions.VMwareRuntimeError(exc.msg)
447         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
448             name="traverseEntities",
449             path="view",
450             skip=False,
451             type=vim.view.ContainerView,
452         )
453     property_spec = vmodl.query.PropertyCollector.PropertySpec(
454         type=obj_type, all=True if not property_list else False, pathSet=property_list
455     )
456     obj_spec = vmodl.query.PropertyCollector.ObjectSpec(
457         obj=obj_ref,
458         skip=True if not local_properties else False,
459         selectSet=[traversal_spec] if not local_properties else None,
460     )
461     filter_spec = vmodl.query.PropertyCollector.FilterSpec(
462         objectSet=[obj_spec],
463         propSet=[property_spec],
464         reportMissingObjectsInResults=False,
465     )
466     try:
467         content = service_instance.content.propertyCollector.RetrieveContents(
468             [filter_spec]
469         )
470     except vim.fault.NoPermission as exc:
471         log.exception(exc)
472         raise salt.exceptions.VMwareApiError(
473             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
474         )
475     except vim.fault.VimFault as exc:
476         log.exception(exc)
477         raise salt.exceptions.VMwareApiError(exc.msg)
478     except vmodl.RuntimeFault as exc:
479         log.exception(exc)
480         raise salt.exceptions.VMwareRuntimeError(exc.msg)
481     if local_traversal_spec:
482         try:
483             obj_ref.Destroy()
484         except vim.fault.NoPermission as exc:
485             log.exception(exc)
486             raise salt.exceptions.VMwareApiError(
487                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
488             )
489         except vim.fault.VimFault as exc:
490             log.exception(exc)
491             raise salt.exceptions.VMwareApiError(exc.msg)
492         except vmodl.RuntimeFault as exc:
493             log.exception(exc)
494             raise salt.exceptions.VMwareRuntimeError(exc.msg)
495     return content
496 def get_mor_by_property(
497     service_instance,
498     object_type,
499     property_value,
500     property_name="name",
501     container_ref=None,
502 ):
503     """
504     Returns the first managed object reference having the specified property value.
505     service_instance
506         The Service Instance from which to obtain managed object references.
507     object_type
508         The type of content for which to obtain managed object references.
509     property_value
510         The name of the property for which to obtain the managed object reference.
511     property_name
512         An object property used to return the specified object reference results. Defaults to ``name``.
513     container_ref
514         An optional reference to the managed object to search under. Can either be an object of type Folder, Datacenter,
515         ComputeResource, Resource Pool or HostSystem. If not specified, default behaviour is to search under the inventory
516         rootFolder.
517     """
518     object_list = get_mors_with_properties(
519         service_instance,
520         object_type,
521         property_list=[property_name],
522         container_ref=container_ref,
523     )
524     for obj in object_list:
525         obj_id = str(obj.get("object", "")).strip("'\"")
526         if obj[property_name] == property_value or property_value == obj_id:
527             return obj["object"]
528     return None
529 def get_mors_with_properties(
530     service_instance,
531     object_type,
532     property_list=None,
533     container_ref=None,
534     traversal_spec=None,
535     local_properties=False,
536 ):
537     """
538     Returns a list containing properties and managed object references for the managed object.
539     service_instance
540         The Service Instance from which to obtain managed object references.
541     object_type
542         The type of content for which to obtain managed object references.
543     property_list
544         An optional list of object properties used to return even more filtered managed object reference results.
545     container_ref
546         An optional reference to the managed object to search under. Can either be an object of type Folder, Datacenter,
547         ComputeResource, Resource Pool or HostSystem. If not specified, default behaviour is to search under the inventory
548         rootFolder.
549     traversal_spec
550         An optional TraversalSpec to be used instead of the standard
551         ``Traverse All`` spec
552     local_properties
553         Flag specigying whether the properties to be retrieved are local to the
554         container. If that is the case, the traversal spec needs to be None.
555     """
556     content_args = [service_instance, object_type]
557     content_kwargs = {
558         "property_list": property_list,
559         "container_ref": container_ref,
560         "traversal_spec": traversal_spec,
561         "local_properties": local_properties,
562     }
563     try:
564         content = get_content(*content_args, **content_kwargs)
565     except BadStatusLine:
566         content = get_content(*content_args, **content_kwargs)
567     except OSError as exc:
568         if exc.errno != errno.EPIPE:
569             raise
570         content = get_content(*content_args, **content_kwargs)
571     object_list = []
572     for obj in content:
573         properties = {}
574         for prop in obj.propSet:
575             properties[prop.name] = prop.val
576         properties["object"] = obj.obj
577         object_list.append(properties)
578     log.trace("Retrieved %s objects", len(object_list))
579     return object_list
580 def get_properties_of_managed_object(mo_ref, properties):
581     """
582     Returns specific properties of a managed object, retrieved in an
583     optimally.
584     mo_ref
585         The managed object reference.
586     properties
587         List of properties of the managed object to retrieve.
588     """
589     service_instance = get_service_instance_from_managed_object(mo_ref)
590     log.trace("Retrieving name of %s", type(mo_ref).__name__)
591     try:
592         items = get_mors_with_properties(
593             service_instance,
594             type(mo_ref),
595             container_ref=mo_ref,
596             property_list=["name"],
597             local_properties=True,
598         )
599         mo_name = items[0]["name"]
600     except vmodl.query.InvalidProperty:
601         mo_name = "&lt;unnamed&gt;"
602     log.trace(
603         "Retrieving properties '%s' of %s '%s'",
604         properties,
605         type(mo_ref).__name__,
606         mo_name,
607     )
608     items = get_mors_with_properties(
609         service_instance,
610         type(mo_ref),
611         container_ref=mo_ref,
612         property_list=properties,
613         local_properties=True,
614     )
615     if not items:
616         raise salt.exceptions.VMwareApiError(
617             "Properties of managed object '{}' weren't retrieved".format(mo_name)
618         )
619     return items[0]
620 def get_managed_object_name(mo_ref):
621     """
622     Returns the name of a managed object.
623     If the name wasn't found, it returns None.
624     mo_ref
625         The managed object reference.
626     """
627     props = get_properties_of_managed_object(mo_ref, ["name"])
628     return props.get("name")
629 def get_network_adapter_type(adapter_type):
630     """
631     Return the network adapter type.
632     adpater_type
633         The adapter type from which to obtain the network adapter type.
634     """
635     if adapter_type == "vmxnet":
636         return vim.vm.device.VirtualVmxnet()
637     elif adapter_type == "vmxnet2":
638         return vim.vm.device.VirtualVmxnet2()
639     elif adapter_type == "vmxnet3":
640         return vim.vm.device.VirtualVmxnet3()
641     elif adapter_type == "e1000":
642         return vim.vm.device.VirtualE1000()
643     elif adapter_type == "e1000e":
644         return vim.vm.device.VirtualE1000e()
645     raise ValueError("An unknown network adapter object type name.")
646 def get_network_adapter_object_type(adapter_object):
647     """
648     Returns the network adapter type.
649     adapter_object
650         The adapter object from which to obtain the network adapter type.
651     """
652     if isinstance(adapter_object, vim.vm.device.VirtualVmxnet2):
653         return "vmxnet2"
654     if isinstance(adapter_object, vim.vm.device.VirtualVmxnet3):
655         return "vmxnet3"
656     if isinstance(adapter_object, vim.vm.device.VirtualVmxnet):
657         return "vmxnet"
658     if isinstance(adapter_object, vim.vm.device.VirtualE1000e):
659         return "e1000e"
660     if isinstance(adapter_object, vim.vm.device.VirtualE1000):
661         return "e1000"
662     raise ValueError("An unknown network adapter object type.")
663 def get_dvss(dc_ref, dvs_names=None, get_all_dvss=False):
664     """
665     Returns distributed virtual switches (DVSs) in a datacenter.
666     dc_ref
667         The parent datacenter reference.
668     dvs_names
669         The names of the DVSs to return. Default is None.
670     get_all_dvss
671         Return all DVSs in the datacenter. Default is False.
672     """
673     dc_name = get_managed_object_name(dc_ref)
674     log.trace(
675         "Retrieving DVSs in datacenter '%s', dvs_names='%s', get_all_dvss=%s",
676         dc_name,
677         ",".join(dvs_names) if dvs_names else None,
678         get_all_dvss,
679     )
680     properties = ["name"]
681     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
682         path="networkFolder",
683         skip=True,
684         type=vim.Datacenter,
685         selectSet=[
686             vmodl.query.PropertyCollector.TraversalSpec(
687                 path="childEntity", skip=False, type=vim.Folder
688             )
689         ],
690     )
691     service_instance = get_service_instance_from_managed_object(dc_ref)
692     items = [
693         i["object"]
694         for i in get_mors_with_properties(
695             service_instance,
696             vim.DistributedVirtualSwitch,
697             container_ref=dc_ref,
698             property_list=properties,
699             traversal_spec=traversal_spec,
700         )
701         if get_all_dvss or (dvs_names and i["name"] in dvs_names)
702     ]
703     return items
704 def get_network_folder(dc_ref):
705     """
706     Retrieves the network folder of a datacenter
707     """
708     dc_name = get_managed_object_name(dc_ref)
709     log.trace("Retrieving network folder in datacenter '%s'", dc_name)
710     service_instance = get_service_instance_from_managed_object(dc_ref)
711     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
712         path="networkFolder", skip=False, type=vim.Datacenter
713     )
714     entries = get_mors_with_properties(
715         service_instance,
716         vim.Folder,
717         container_ref=dc_ref,
718         property_list=["name"],
719         traversal_spec=traversal_spec,
720     )
721     if not entries:
722         raise salt.exceptions.VMwareObjectRetrievalError(
723             "Network folder in datacenter '{}' wasn't retrieved".format(dc_name)
724         )
725     return entries[0]["object"]
726 def create_dvs(dc_ref, dvs_name, dvs_create_spec=None):
727     """
728     Creates a distributed virtual switches (DVS) in a datacenter.
729     Returns the reference to the newly created distributed virtual switch.
730     dc_ref
731         The parent datacenter reference.
732     dvs_name
733         The name of the DVS to create.
734     dvs_create_spec
735         The DVS spec (vim.DVSCreateSpec) to use when creating the DVS.
736         Default is None.
737     """
738     dc_name = get_managed_object_name(dc_ref)
739     log.trace("Creating DVS '%s' in datacenter '%s'", dvs_name, dc_name)
740     if not dvs_create_spec:
741         dvs_create_spec = vim.DVSCreateSpec()
742     if not dvs_create_spec.configSpec:
743         dvs_create_spec.configSpec = vim.VMwareDVSConfigSpec()
744         dvs_create_spec.configSpec.name = dvs_name
745     netw_folder_ref = get_network_folder(dc_ref)
746     try:
747         task = netw_folder_ref.CreateDVS_Task(dvs_create_spec)
748     except vim.fault.NoPermission as exc:
749         log.exception(exc)
750         raise salt.exceptions.VMwareApiError(
751             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
752         )
753     except vim.fault.VimFault as exc:
754         log.exception(exc)
755         raise salt.exceptions.VMwareApiError(exc.msg)
756     except vmodl.RuntimeFault as exc:
757         log.exception(exc)
758         raise salt.exceptions.VMwareRuntimeError(exc.msg)
759     wait_for_task(task, dvs_name, str(task.__class__))
760 def update_dvs(dvs_ref, dvs_config_spec):
761     """
762     Updates a distributed virtual switch with the config_spec.
763     dvs_ref
764         The DVS reference.
765     dvs_config_spec
766         The updated config spec (vim.VMwareDVSConfigSpec) to be applied to
767         the DVS.
768     """
769     dvs_name = get_managed_object_name(dvs_ref)
770     log.trace("Updating dvs '%s'", dvs_name)
771     try:
772         task = dvs_ref.ReconfigureDvs_Task(dvs_config_spec)
773     except vim.fault.NoPermission as exc:
774         log.exception(exc)
775         raise salt.exceptions.VMwareApiError(
776             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
777         )
778     except vim.fault.VimFault as exc:
779         log.exception(exc)
780         raise salt.exceptions.VMwareApiError(exc.msg)
781     except vmodl.RuntimeFault as exc:
782         log.exception(exc)
783         raise salt.exceptions.VMwareRuntimeError(exc.msg)
784     wait_for_task(task, dvs_name, str(task.__class__))
785 def set_dvs_network_resource_management_enabled(dvs_ref, enabled):
786     """
787     Sets whether NIOC is enabled on a DVS.
788     dvs_ref
789         The DVS reference.
790     enabled
791         Flag specifying whether NIOC is enabled.
792     """
793     dvs_name = get_managed_object_name(dvs_ref)
794     log.trace(
795         "Setting network resource management enable to %s on dvs '%s'",
796         enabled,
797         dvs_name,
798     )
799     try:
800         dvs_ref.EnableNetworkResourceManagement(enable=enabled)
801     except vim.fault.NoPermission as exc:
802         log.exception(exc)
803         raise salt.exceptions.VMwareApiError(
804             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
805         )
806     except vim.fault.VimFault as exc:
807         log.exception(exc)
808         raise salt.exceptions.VMwareApiError(exc.msg)
809     except vmodl.RuntimeFault as exc:
810         log.exception(exc)
811         raise salt.exceptions.VMwareRuntimeError(exc.msg)
812 def get_dvportgroups(parent_ref, portgroup_names=None, get_all_portgroups=False):
813     """
814     Returns distributed virtual porgroups (dvportgroups).
815     The parent object can be either a datacenter or a dvs.
816     parent_ref
817         The parent object reference. Can be either a datacenter or a dvs.
818     portgroup_names
819         The names of the dvss to return. Default is None.
820     get_all_portgroups
821         Return all portgroups in the parent. Default is False.
822     """
823     if not isinstance(parent_ref, (vim.Datacenter, vim.DistributedVirtualSwitch)):
824         raise salt.exceptions.ArgumentValueError(
825             "Parent has to be either a datacenter, or a distributed virtual switch"
826         )
827     parent_name = get_managed_object_name(parent_ref)
828     log.trace(
829         "Retrieving portgroup in %s '%s', portgroups_names='%s', get_all_portgroups=%s",
830         type(parent_ref).__name__,
831         parent_name,
832         ",".join(portgroup_names) if portgroup_names else None,
833         get_all_portgroups,
834     )
835     properties = ["name"]
836     if isinstance(parent_ref, vim.Datacenter):
837         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
838             path="networkFolder",
839             skip=True,
840             type=vim.Datacenter,
841             selectSet=[
842                 vmodl.query.PropertyCollector.TraversalSpec(
843                     path="childEntity", skip=False, type=vim.Folder
844                 )
845             ],
846         )
847     else:  # parent is distributed virtual switch
848         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
849             path="portgroup", skip=False, type=vim.DistributedVirtualSwitch
850         )
851     service_instance = get_service_instance_from_managed_object(parent_ref)
852     items = [
853         i["object"]
854         for i in get_mors_with_properties(
855             service_instance,
856             vim.DistributedVirtualPortgroup,
857             container_ref=parent_ref,
858             property_list=properties,
859             traversal_spec=traversal_spec,
860         )
861         if get_all_portgroups or (portgroup_names and i["name"] in portgroup_names)
862     ]
863     return items
864 def get_uplink_dvportgroup(dvs_ref):
865     """
866     Returns the uplink distributed virtual portgroup of a distributed virtual
867     switch (dvs)
868     dvs_ref
869         The dvs reference
870     """
871     dvs_name = get_managed_object_name(dvs_ref)
872     log.trace("Retrieving uplink portgroup of dvs '%s'", dvs_name)
873     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
874         path="portgroup", skip=False, type=vim.DistributedVirtualSwitch
875     )
876     service_instance = get_service_instance_from_managed_object(dvs_ref)
877     items = [
878         entry["object"]
879         for entry in get_mors_with_properties(
880             service_instance,
881             vim.DistributedVirtualPortgroup,
882             container_ref=dvs_ref,
883             property_list=["tag"],
884             traversal_spec=traversal_spec,
885         )
886         if entry["tag"] and [t for t in entry["tag"] if t.key == "SYSTEM/DVS.UPLINKPG"]
887     ]
888     if not items:
889         raise salt.exceptions.VMwareObjectRetrievalError(
890             "Uplink portgroup of DVS '{}' wasn't found".format(dvs_name)
891         )
892     return items[0]
893 def create_dvportgroup(dvs_ref, spec):
894     """
895     Creates a distributed virtual portgroup on a distributed virtual switch
896     (dvs)
897     dvs_ref
898         The dvs reference
899     spec
900         Portgroup spec (vim.DVPortgroupConfigSpec)
901     """
902     dvs_name = get_managed_object_name(dvs_ref)
903     log.trace("Adding portgroup %s to dvs '%s'", spec.name, dvs_name)
904     log.trace("spec = %s", spec)
905     try:
906         task = dvs_ref.CreateDVPortgroup_Task(spec)
907     except vim.fault.NoPermission as exc:
908         log.exception(exc)
909         raise salt.exceptions.VMwareApiError(
910             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
911         )
912     except vim.fault.VimFault as exc:
913         log.exception(exc)
914         raise salt.exceptions.VMwareApiError(exc.msg)
915     except vmodl.RuntimeFault as exc:
916         log.exception(exc)
917         raise salt.exceptions.VMwareRuntimeError(exc.msg)
918     wait_for_task(task, dvs_name, str(task.__class__))
919 def update_dvportgroup(portgroup_ref, spec):
920     """
921     Updates a distributed virtual portgroup
922     portgroup_ref
923         The portgroup reference
924     spec
925         Portgroup spec (vim.DVPortgroupConfigSpec)
926     """
927     pg_name = get_managed_object_name(portgroup_ref)
928     log.trace("Updating portgrouo %s", pg_name)
929     try:
930         task = portgroup_ref.ReconfigureDVPortgroup_Task(spec)
931     except vim.fault.NoPermission as exc:
932         log.exception(exc)
933         raise salt.exceptions.VMwareApiError(
934             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
935         )
936     except vim.fault.VimFault as exc:
937         log.exception(exc)
938         raise salt.exceptions.VMwareApiError(exc.msg)
939     except vmodl.RuntimeFault as exc:
940         log.exception(exc)
941         raise salt.exceptions.VMwareRuntimeError(exc.msg)
942     wait_for_task(task, pg_name, str(task.__class__))
943 def remove_dvportgroup(portgroup_ref):
944     """
945     Removes a distributed virtual portgroup
946     portgroup_ref
947         The portgroup reference
948     """
949     pg_name = get_managed_object_name(portgroup_ref)
950     log.trace("Removing portgroup %s", pg_name)
951     try:
952         task = portgroup_ref.Destroy_Task()
953     except vim.fault.NoPermission as exc:
954         log.exception(exc)
955         raise salt.exceptions.VMwareApiError(
956             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
957         )
958     except vim.fault.VimFault as exc:
959         log.exception(exc)
960         raise salt.exceptions.VMwareApiError(exc.msg)
961     except vmodl.RuntimeFault as exc:
962         log.exception(exc)
963         raise salt.exceptions.VMwareRuntimeError(exc.msg)
964     wait_for_task(task, pg_name, str(task.__class__))
965 def get_networks(parent_ref, network_names=None, get_all_networks=False):
966     """
967     Returns networks of standard switches.
968     The parent object can be a datacenter.
969     parent_ref
970         The parent object reference. A datacenter object.
971     network_names
972         The name of the standard switch networks. Default is None.
973     get_all_networks
974         Boolean indicates whether to return all networks in the parent.
975         Default is False.
976     """
977     if not isinstance(parent_ref, vim.Datacenter):
978         raise salt.exceptions.ArgumentValueError("Parent has to be a datacenter.")
979     parent_name = get_managed_object_name(parent_ref)
980     log.trace(
981         "Retrieving network from %s '%s', network_names='%s', get_all_networks=%s",
982         type(parent_ref).__name__,
983         parent_name,
984         ",".join(network_names) if network_names else None,
985         get_all_networks,
986     )
987     properties = ["name"]
988     service_instance = get_service_instance_from_managed_object(parent_ref)
989     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
990         path="networkFolder",
991         skip=True,
992         type=vim.Datacenter,
993         selectSet=[
994             vmodl.query.PropertyCollector.TraversalSpec(
995                 path="childEntity", skip=False, type=vim.Folder
996             )
997         ],
998     )
999     items = [
1000         i["object"]
1001         for i in get_mors_with_properties(
1002             service_instance,
1003             vim.Network,
1004             container_ref=parent_ref,
1005             property_list=properties,
1006             traversal_spec=traversal_spec,
1007         )
1008         if get_all_networks or (network_names and i["name"] in network_names)
1009     ]
1010     return items
1011 def list_objects(service_instance, vim_object, properties=None):
1012     """
1013     Returns a simple list of objects from a given service instance.
1014     service_instance
1015         The Service Instance for which to obtain a list of objects.
1016     object_type
1017         The type of content for which to obtain information.
1018     properties
1019         An optional list of object properties used to return reference results.
1020         If not provided, defaults to ``name``.
1021     """
1022     if properties is None:
1023         properties = ["name"]
1024     items = []
1025     item_list = get_mors_with_properties(service_instance, vim_object, properties)
1026     for item in item_list:
1027         items.append(item["name"])
1028     return items
1029 def get_license_manager(service_instance):
1030     """
1031     Returns the license manager.
1032     service_instance
1033         The Service Instance Object from which to obrain the license manager.
1034     """
1035     log.debug("Retrieving license manager")
1036     try:
1037         lic_manager = service_instance.content.licenseManager
1038     except vim.fault.NoPermission as exc:
1039         log.exception(exc)
1040         raise salt.exceptions.VMwareApiError(
1041             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1042         )
1043     except vim.fault.VimFault as exc:
1044         log.exception(exc)
1045         raise salt.exceptions.VMwareApiError(exc.msg)
1046     except vmodl.RuntimeFault as exc:
1047         log.exception(exc)
1048         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1049     return lic_manager
1050 def get_license_assignment_manager(service_instance):
1051     """
1052     Returns the license assignment manager.
1053     service_instance
1054         The Service Instance Object from which to obrain the license manager.
1055     """
1056     log.debug("Retrieving license assignment manager")
1057     try:
1058         lic_assignment_manager = (
1059             service_instance.content.licenseManager.licenseAssignmentManager
1060         )
1061     except vim.fault.NoPermission as exc:
1062         log.exception(exc)
1063         raise salt.exceptions.VMwareApiError(
1064             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1065         )
1066     except vim.fault.VimFault as exc:
1067         log.exception(exc)
1068         raise salt.exceptions.VMwareApiError(exc.msg)
1069     except vmodl.RuntimeFault as exc:
1070         log.exception(exc)
1071         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1072     if not lic_assignment_manager:
1073         raise salt.exceptions.VMwareObjectRetrievalError(
1074             "License assignment manager was not retrieved"
1075         )
1076     return lic_assignment_manager
1077 def get_licenses(service_instance, license_manager=None):
1078     """
1079     Returns the licenses on a specific instance.
1080     service_instance
1081         The Service Instance Object from which to obrain the licenses.
1082     license_manager
1083         The License Manager object of the service instance. If not provided it
1084         will be retrieved.
1085     """
1086     if not license_manager:
1087         license_manager = get_license_manager(service_instance)
1088     log.debug("Retrieving licenses")
1089     try:
1090         return license_manager.licenses
1091     except vim.fault.NoPermission as exc:
1092         log.exception(exc)
1093         raise salt.exceptions.VMwareApiError(
1094             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1095         )
1096     except vim.fault.VimFault as exc:
1097         log.exception(exc)
1098         raise salt.exceptions.VMwareApiError(exc.msg)
1099     except vmodl.RuntimeFault as exc:
1100         log.exception(exc)
1101         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1102 def add_license(service_instance, key, description, license_manager=None):
1103     """
1104     Adds a license.
1105     service_instance
1106         The Service Instance Object.
1107     key
1108         The key of the license to add.
1109     description
1110         The description of the license to add.
1111     license_manager
1112         The License Manager object of the service instance. If not provided it
1113         will be retrieved.
1114     """
1115     if not license_manager:
1116         license_manager = get_license_manager(service_instance)
1117     label = vim.KeyValue()
1118     label.key = "VpxClientLicenseLabel"
1119     label.value = description
1120     log.debug("Adding license '%s'", description)
1121     try:
1122         vmware_license = license_manager.AddLicense(key, [label])
1123     except vim.fault.NoPermission as exc:
1124         log.exception(exc)
1125         raise salt.exceptions.VMwareApiError(
1126             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1127         )
1128     except vim.fault.VimFault as exc:
1129         log.exception(exc)
1130         raise salt.exceptions.VMwareApiError(exc.msg)
1131     except vmodl.RuntimeFault as exc:
1132         log.exception(exc)
1133         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1134     return vmware_license
1135 def get_assigned_licenses(
1136     service_instance, entity_ref=None, entity_name=None, license_assignment_manager=None
1137 ):
1138     """
1139     Returns the licenses assigned to an entity. If entity ref is not provided,
1140     then entity_name is assumed to be the vcenter. This is later checked if
1141     the entity name is provided.
1142     service_instance
1143         The Service Instance Object from which to obtain the licenses.
1144     entity_ref
1145         VMware entity to get the assigned licenses for.
1146         If None, the entity is the vCenter itself.
1147         Default is None.
1148     entity_name
1149         Entity name used in logging.
1150         Default is None.
1151     license_assignment_manager
1152         The LicenseAssignmentManager object of the service instance.
1153         If not provided it will be retrieved.
1154         Default is None.
1155     """
1156     if not license_assignment_manager:
1157         license_assignment_manager = get_license_assignment_manager(service_instance)
1158     if not entity_name:
1159         raise salt.exceptions.ArgumentValueError("No entity_name passed")
1160     entity_id = None
1161     entity_type = "moid"
1162     check_name = False
1163     if not entity_ref:
1164         if entity_name:
1165             check_name = True
1166         entity_type = "uuid"
1167         try:
1168             entity_id = service_instance.content.about.instanceUuid
1169         except vim.fault.NoPermission as exc:
1170             log.exception(exc)
1171             raise salt.exceptions.VMwareApiError(
1172                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1173             )
1174         except vim.fault.VimFault as exc:
1175             log.exception(exc)
1176             raise salt.exceptions.VMwareApiError(exc.msg)
1177         except vmodl.RuntimeFault as exc:
1178             log.exception(exc)
1179             raise salt.exceptions.VMwareRuntimeError(exc.msg)
1180     else:
1181         entity_id = entity_ref._moId
1182     log.trace("Retrieving licenses assigned to '%s'", entity_name)
1183     try:
1184         assignments = license_assignment_manager.QueryAssignedLicenses(entity_id)
1185     except vim.fault.NoPermission as exc:
1186         log.exception(exc)
1187         raise salt.exceptions.VMwareApiError(
1188             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1189         )
1190     except vim.fault.VimFault as exc:
1191         log.exception(exc)
1192         raise salt.exceptions.VMwareApiError(exc.msg)
1193     except vmodl.RuntimeFault as exc:
1194         log.exception(exc)
1195         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1196     if entity_type == "uuid" and len(assignments) &gt; 1:
1197         log.trace("Unexpectectedly retrieved more than one VCenter license assignment.")
1198         raise salt.exceptions.VMwareObjectRetrievalError(
1199             "Unexpected return. Expect only a single assignment"
1200         )
1201     if check_name:
1202         if entity_name != assignments[0].entityDisplayName:
1203             log.trace(
1204                 "Getting license info for wrong vcenter: %s != %s",
1205                 entity_name,
1206                 assignments[0].entityDisplayName,
1207             )
1208             raise salt.exceptions.VMwareObjectRetrievalError(
1209                 "Got license assignment info for a different vcenter"
1210             )
1211     return [a.assignedLicense for a in assignments]
1212 def assign_license(
1213     service_instance,
1214     license_key,
1215     license_name,
1216     entity_ref=None,
1217     entity_name=None,
1218     license_assignment_manager=None,
1219 ):
1220     """
1221     Assigns a license to an entity.
1222     service_instance
1223         The Service Instance Object from which to obrain the licenses.
1224     license_key
1225         The key of the license to add.
1226     license_name
1227         The description of the license to add.
1228     entity_ref
1229         VMware entity to assign the license to.
1230         If None, the entity is the vCenter itself.
1231         Default is None.
1232     entity_name
1233         Entity name used in logging.
1234         Default is None.
1235     license_assignment_manager
1236         The LicenseAssignmentManager object of the service instance.
1237         If not provided it will be retrieved
1238         Default is None.
1239     """
1240     if not license_assignment_manager:
1241         license_assignment_manager = get_license_assignment_manager(service_instance)
1242     entity_id = None
1243     if not entity_ref:
1244         try:
1245             entity_id = service_instance.content.about.instanceUuid
1246         except vim.fault.NoPermission as exc:
1247             log.exception(exc)
1248             raise salt.exceptions.VMwareApiError(
1249                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1250             )
1251         except vim.fault.VimFault as exc:
1252             raise salt.exceptions.VMwareApiError(exc.msg)
1253         except vmodl.RuntimeFault as exc:
1254             raise salt.exceptions.VMwareRuntimeError(exc.msg)
1255         if not entity_name:
1256             entity_name = "vCenter"
1257     else:
1258         entity_id = entity_ref._moId
1259     log.trace("Assigning license to '%s'", entity_name)
1260     try:
1261         vmware_license = license_assignment_manager.UpdateAssignedLicense(
1262             entity_id, license_key, license_name
1263         )
1264     except vim.fault.NoPermission as exc:
1265         log.exception(exc)
1266         raise salt.exceptions.VMwareApiError(
1267             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1268         )
1269     except vim.fault.VimFault as exc:
1270         log.exception(exc)
1271         raise salt.exceptions.VMwareApiError(exc.msg)
1272     except vmodl.RuntimeFault as exc:
1273         log.exception(exc)
1274         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1275     return vmware_license
1276 def list_datacenters(service_instance):
1277     """
1278     Returns a list of datacenters associated with a given service instance.
1279     service_instance
1280         The Service Instance Object from which to obtain datacenters.
1281     """
1282     return list_objects(service_instance, vim.Datacenter)
1283 def get_datacenters(service_instance, datacenter_names=None, get_all_datacenters=False):
1284     """
1285     Returns all datacenters in a vCenter.
1286     service_instance
1287         The Service Instance Object from which to obtain cluster.
1288     datacenter_names
1289         List of datacenter names to filter by. Default value is None.
1290     get_all_datacenters
1291         Flag specifying whether to retrieve all datacenters.
1292         Default value is None.
1293     """
1294     items = [
1295         i["object"]
1296         for i in get_mors_with_properties(
1297             service_instance, vim.Datacenter, property_list=["name"]
1298         )
1299         if get_all_datacenters or (datacenter_names and i["name"] in datacenter_names)
1300     ]
1301     return items
1302 def get_datacenter(service_instance, datacenter_name):
1303     """
1304     Returns a vim.Datacenter managed object.
1305     service_instance
1306         The Service Instance Object from which to obtain datacenter.
1307     datacenter_name
1308         The datacenter name
1309     """
1310     items = get_datacenters(service_instance, datacenter_names=[datacenter_name])
1311     if not items:
1312         raise salt.exceptions.VMwareObjectRetrievalError(
1313             "Datacenter '{}' was not found".format(datacenter_name)
1314         )
1315     return items[0]
1316 def create_datacenter(service_instance, datacenter_name):
1317     """
1318     Creates a datacenter.
1319     .. versionadded:: 2017.7.0
1320     service_instance
1321         The Service Instance Object
1322     datacenter_name
1323         The datacenter name
1324     """
1325     root_folder = get_root_folder(service_instance)
1326     log.trace("Creating datacenter '%s'", datacenter_name)
1327     try:
1328         dc_obj = root_folder.CreateDatacenter(datacenter_name)
1329     except vim.fault.NoPermission as exc:
1330         log.exception(exc)
1331         raise salt.exceptions.VMwareApiError(
1332             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1333         )
1334     except vim.fault.VimFault as exc:
1335         log.exception(exc)
1336         raise salt.exceptions.VMwareApiError(exc.msg)
1337     except vmodl.RuntimeFault as exc:
1338         log.exception(exc)
1339         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1340     return dc_obj
1341 def get_cluster(dc_ref, cluster):
1342     """
1343     Returns a cluster in a datacenter.
1344     dc_ref
1345         The datacenter reference
1346     cluster
1347         The cluster to be retrieved
1348     """
1349     dc_name = get_managed_object_name(dc_ref)
1350     log.trace("Retrieving cluster '%s' from datacenter '%s'", cluster, dc_name)
1351     si = get_service_instance_from_managed_object(dc_ref, name=dc_name)
1352     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1353         path="hostFolder",
1354         skip=True,
1355         type=vim.Datacenter,
1356         selectSet=[
1357             vmodl.query.PropertyCollector.TraversalSpec(
1358                 path="childEntity", skip=False, type=vim.Folder
1359             )
1360         ],
1361     )
1362     items = [
1363         i["object"]
1364         for i in get_mors_with_properties(
1365             si,
1366             vim.ClusterComputeResource,
1367             container_ref=dc_ref,
1368             property_list=["name"],
1369             traversal_spec=traversal_spec,
1370         )
1371         if i["name"] == cluster
1372     ]
1373     if not items:
1374         raise salt.exceptions.VMwareObjectRetrievalError(
1375             "Cluster '{}' was not found in datacenter '{}'".format(cluster, dc_name)
1376         )
1377     return items[0]
1378 def create_cluster(dc_ref, cluster_name, cluster_spec):
1379     """
1380     Creates a cluster in a datacenter.
1381     dc_ref
1382         The parent datacenter reference.
1383     cluster_name
1384         The cluster name.
1385     cluster_spec
1386         The cluster spec (vim.ClusterConfigSpecEx).
1387         Defaults to None.
1388     """
1389     dc_name = get_managed_object_name(dc_ref)
1390     log.trace("Creating cluster '%s' in datacenter '%s'", cluster_name, dc_name)
1391     try:
1392         dc_ref.hostFolder.CreateClusterEx(cluster_name, cluster_spec)
1393     except vim.fault.NoPermission as exc:
1394         log.exception(exc)
1395         raise salt.exceptions.VMwareApiError(
1396             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1397         )
1398     except vim.fault.VimFault as exc:
1399         log.exception(exc)
1400         raise salt.exceptions.VMwareApiError(exc.msg)
1401     except vmodl.RuntimeFault as exc:
1402         log.exception(exc)
1403         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1404 def update_cluster(cluster_ref, cluster_spec):
1405     """
1406     Updates a cluster in a datacenter.
1407     cluster_ref
1408         The cluster reference.
1409     cluster_spec
1410         The cluster spec (vim.ClusterConfigSpecEx).
1411         Defaults to None.
1412     """
1413     cluster_name = get_managed_object_name(cluster_ref)
1414     log.trace("Updating cluster '%s'", cluster_name)
1415     try:
1416         task = cluster_ref.ReconfigureComputeResource_Task(cluster_spec, modify=True)
1417     except vim.fault.NoPermission as exc:
1418         log.exception(exc)
1419         raise salt.exceptions.VMwareApiError(
1420             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1421         )
1422     except vim.fault.VimFault as exc:
1423         log.exception(exc)
1424         raise salt.exceptions.VMwareApiError(exc.msg)
1425     except vmodl.RuntimeFault as exc:
1426         log.exception(exc)
1427         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1428     wait_for_task(task, cluster_name, "ClusterUpdateTask")
1429 def list_clusters(service_instance):
1430     """
1431     Returns a list of clusters associated with a given service instance.
1432     service_instance
1433         The Service Instance Object from which to obtain clusters.
1434     """
1435     return list_objects(service_instance, vim.ClusterComputeResource)
1436 def list_datastore_clusters(service_instance):
1437     """
1438     Returns a list of datastore clusters associated with a given service instance.
1439     service_instance
1440         The Service Instance Object from which to obtain datastore clusters.
1441     """
1442     return list_objects(service_instance, vim.StoragePod)
1443 def list_datastores(service_instance):
1444     """
1445     Returns a list of datastores associated with a given service instance.
1446     service_instance
1447         The Service Instance Object from which to obtain datastores.
1448     """
1449     return list_objects(service_instance, vim.Datastore)
1450 def get_datastore_files(
1451     service_instance, directory, datastores, container_object, browser_spec
1452 ):
1453     """
1454     Get the files with a given browser specification from the datastore.
1455     service_instance
1456         The Service Instance Object from which to obtain datastores.
1457     directory
1458         The name of the directory where we would like to search
1459     datastores
1460         Name of the datastores
1461     container_object
1462         The base object for searches
1463     browser_spec
1464         BrowserSpec object which defines the search criteria
1465     return
1466         list of vim.host.DatastoreBrowser.SearchResults objects
1467     """
1468     files = []
1469     datastore_objects = get_datastores(
1470         service_instance, container_object, datastore_names=datastores
1471     )
1472     for datobj in datastore_objects:
1473         try:
1474             task = datobj.browser.SearchDatastore_Task(
1475                 datastorePath="[{}] {}".format(datobj.name, directory),
1476                 searchSpec=browser_spec,
1477             )
1478         except vim.fault.NoPermission as exc:
1479             log.exception(exc)
1480             raise salt.exceptions.VMwareApiError(
1481                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1482             )
1483         except vim.fault.VimFault as exc:
1484             log.exception(exc)
1485             raise salt.exceptions.VMwareApiError(exc.msg)
1486         except vmodl.RuntimeFault as exc:
1487             log.exception(exc)
1488             raise salt.exceptions.VMwareRuntimeError(exc.msg)
1489         try:
1490             files.append(
1491                 salt.utils.vmware.wait_for_task(
1492                     task, directory, "query virtual machine files"
1493                 )
1494             )
1495         except salt.exceptions.VMwareFileNotFoundError:
1496             pass
1497     return files
1498 def get_datastores(
1499     service_instance,
1500     reference,
1501     datastore_names=None,
1502     backing_disk_ids=None,
1503     get_all_datastores=False,
1504 ):
1505     """
1506     Returns a list of vim.Datastore objects representing the datastores visible
1507     from a VMware object, filtered by their names, or the backing disk
1508     cannonical name or scsi_addresses
1509     service_instance
1510         The Service Instance Object from which to obtain datastores.
1511     reference
1512         The VMware object from which the datastores are visible.
1513     datastore_names
1514         The list of datastore names to be retrieved. Default value is None.
1515     backing_disk_ids
1516         The list of canonical names of the disks backing the datastores
1517         to be retrieved. Only supported if reference is a vim.HostSystem.
1518         Default value is None
1519     get_all_datastores
1520         Specifies whether to retrieve all disks in the host.
1521         Default value is False.
1522     """
1523     obj_name = get_managed_object_name(reference)
1524     if get_all_datastores:
1525         log.trace("Retrieving all datastores visible to '%s'", obj_name)
1526     else:
1527         log.trace(
1528             "Retrieving datastores visible to '%s': names = (%s); "
1529             "backing disk ids = (%s)",
1530             obj_name,
1531             datastore_names,
1532             backing_disk_ids,
1533         )
1534         if backing_disk_ids and not isinstance(reference, vim.HostSystem):
1535             raise salt.exceptions.ArgumentValueError(
1536                 "Unsupported reference type '{}' when backing disk filter "
1537                 "is set".format(reference.__class__.__name__)
1538             )
1539     if (not get_all_datastores) and backing_disk_ids:
1540         log.trace("Filtering datastores with backing disk ids: %s", backing_disk_ids)
1541         storage_system = get_storage_system(service_instance, reference, obj_name)
1542         props = salt.utils.vmware.get_properties_of_managed_object(
1543             storage_system, ["fileSystemVolumeInfo.mountInfo"]
1544         )
1545         mount_infos = props.get("fileSystemVolumeInfo.mountInfo", [])
1546         disk_datastores = []
1547         for vol in [
1548             i.volume for i in mount_infos if isinstance(i.volume, vim.HostVmfsVolume)
1549         ]:
1550             if not [e for e in vol.extent if e.diskName in backing_disk_ids]:
1551                 continue
1552             log.trace(
1553                 "Found datastore '%s' for disk id(s) '%s'",
1554                 vol.name,
1555                 [e.diskName for e in vol.extent],
1556             )
1557             disk_datastores.append(vol.name)
1558         log.trace("Datastore found for disk filter: %s", disk_datastores)
1559         if datastore_names:
1560             datastore_names.extend(disk_datastores)
1561         else:
1562             datastore_names = disk_datastores
1563     if (not get_all_datastores) and (not datastore_names):
1564         log.trace(
1565             "No datastore to be filtered after retrieving the datastores "
1566             "backed by the disk id(s) '%s'",
1567             backing_disk_ids,
1568         )
1569         return []
1570     log.trace("datastore_names = %s", datastore_names)
1571     if isinstance(reference, vim.HostSystem):
1572         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1573             name="host_datastore_traversal",
1574             path="datastore",
1575             skip=False,
1576             type=vim.HostSystem,
1577         )
1578     elif isinstance(reference, vim.ClusterComputeResource):
1579         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1580             name="cluster_datastore_traversal",
1581             path="datastore",
1582             skip=False,
1583             type=vim.ClusterComputeResource,
1584         )
1585     elif isinstance(reference, vim.Datacenter):
1586         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1587             name="datacenter_datastore_traversal",
1588             path="datastore",
1589             skip=False,
1590             type=vim.Datacenter,
1591         )
1592     elif isinstance(reference, vim.StoragePod):
1593         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1594             name="datastore_cluster_traversal",
1595             path="childEntity",
1596             skip=False,
1597             type=vim.StoragePod,
1598         )
1599     elif (
1600         isinstance(reference, vim.Folder)
1601         and get_managed_object_name(reference) == "Datacenters"
1602     ):
1603         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1604             path="childEntity",
1605             selectSet=[
1606                 vmodl.query.PropertyCollector.TraversalSpec(
1607                     path="datastore", skip=False, type=vim.Datacenter
1608                 )
1609             ],
1610             skip=False,
1611             type=vim.Folder,
1612         )
1613     else:
1614         raise salt.exceptions.ArgumentValueError(
1615             "Unsupported reference type '{}'".format(reference.__class__.__name__)
1616         )
1617     items = get_mors_with_properties(
1618         service_instance,
1619         object_type=vim.Datastore,
1620         property_list=["name"],
1621         container_ref=reference,
1622         traversal_spec=traversal_spec,
1623     )
1624     log.trace("Retrieved %s datastores", len(items))
1625     items = [i for i in items if get_all_datastores or i["name"] in datastore_names]
1626     log.trace("Filtered datastores: %s", [i["name"] for i in items])
1627     return [i["object"] for i in items]
1628 def rename_datastore(datastore_ref, new_datastore_name):
1629     """
1630     Renames a datastore
1631     datastore_ref
1632         vim.Datastore reference to the datastore object to be changed
1633     new_datastore_name
1634         New datastore name
1635     """
1636     ds_name = get_managed_object_name(datastore_ref)
1637     log.trace("Renaming datastore '%s' to '%s'", ds_name, new_datastore_name)
1638     try:
1639         datastore_ref.RenameDatastore(new_datastore_name)
1640     except vim.fault.NoPermission as exc:
1641         log.exception(exc)
1642         raise salt.exceptions.VMwareApiError(
1643             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1644         )
1645     except vim.fault.VimFault as exc:
1646         log.exception(exc)
1647         raise salt.exceptions.VMwareApiError(exc.msg)
1648     except vmodl.RuntimeFault as exc:
1649         log.exception(exc)
1650         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1651 def get_storage_system(service_instance, host_ref, hostname=None):
1652     """
1653     Returns a host's storage system
1654     """
1655     if not hostname:
1656         hostname = get_managed_object_name(host_ref)
1657     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1658         path="configManager.storageSystem", type=vim.HostSystem, skip=False
1659     )
1660     objs = get_mors_with_properties(
1661         service_instance,
1662         vim.HostStorageSystem,
1663         property_list=["systemFile"],
1664         container_ref=host_ref,
1665         traversal_spec=traversal_spec,
1666     )
1667     if not objs:
1668         raise salt.exceptions.VMwareObjectRetrievalError(
1669             "Host's '{}' storage system was not retrieved".format(hostname)
1670         )
1671     log.trace("[%s] Retrieved storage system", hostname)
1672     return objs[0]["object"]
1673 def _get_partition_info(storage_system, device_path):
1674     """
1675     Returns partition information for a device path, of type
1676     vim.HostDiskPartitionInfo
1677     """
1678     try:
1679         partition_infos = storage_system.RetrieveDiskPartitionInfo(
1680             devicePath=[device_path]
1681         )
1682     except vim.fault.NoPermission as exc:
1683         log.exception(exc)
1684         raise salt.exceptions.VMwareApiError(
1685             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1686         )
1687     except vim.fault.VimFault as exc:
1688         log.exception(exc)
1689         raise salt.exceptions.VMwareApiError(exc.msg)
1690     except vmodl.RuntimeFault as exc:
1691         log.exception(exc)
1692         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1693     log.trace("partition_info = %s", partition_infos[0])
1694     return partition_infos[0]
1695 def _get_new_computed_partition_spec(storage_system, device_path, partition_info):
1696     """
1697     Computes the new disk partition info when adding a new vmfs partition that
1698     uses up the remainder of the disk; returns a tuple
1699     (new_partition_number, vim.HostDiskPartitionSpec
1700     """
1701     log.trace(
1702         "Adding a partition at the end of the disk and getting the new "
1703         "computed partition spec"
1704     )
1705     free_partitions = [p for p in partition_info.layout.partition if p.type == "none"]
1706     if not free_partitions:
1707         raise salt.exceptions.VMwareObjectNotFoundError(
1708             "Free partition was not found on device '{}'".format(
1709                 partition_info.deviceName
1710             )
1711         )
1712     free_partition = free_partitions[0]
1713     layout = vim.HostDiskPartitionLayout(
1714         total=partition_info.layout.total, partition=partition_info.layout.partition
1715     )
1716     free_partition.type = "vmfs"
1717     try:
1718         computed_partition_info = storage_system.ComputeDiskPartitionInfo(
1719             devicePath=device_path,
1720             partitionFormat=vim.HostDiskPartitionInfoPartitionFormat.gpt,
1721             layout=layout,
1722         )
1723     except vim.fault.NoPermission as exc:
1724         log.exception(exc)
1725         raise salt.exceptions.VMwareApiError(
1726             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1727         )
1728     except vim.fault.VimFault as exc:
1729         log.exception(exc)
1730         raise salt.exceptions.VMwareApiError(exc.msg)
1731     except vmodl.RuntimeFault as exc:
1732         log.exception(exc)
1733     log.trace("computed partition info = {0}", computed_partition_info)
1734     log.trace("Retrieving new partition number")
1735     partition_numbers <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [
1736         p.partition
1737         for p in computed_partition_info.layout.partition
1738         if (
1739             p.start.block == free_partition.start.block
1740             or
1741             (free_partition.start.block == 0 and p.start.block == 1)
1742         )
1743         and p.end.block == free_partition.end.block
1744         and p.</b></font>type == "vmfs"
1745     ]
1746     if not partition_numbers:
1747         raise salt.exceptions.VMwareNotFoundError(
1748             "New partition was not found in computed partitions of device '{}'".format(
1749                 partition_info.deviceName
1750             )
1751         )
1752     log.trace("new partition number = %s", partition_numbers[0])
1753     return (partition_numbers[0], computed_partition_info.spec)
1754 def create_vmfs_datastore(
1755     host_ref, datastore_name, disk_ref, vmfs_major_version, storage_system=None
1756 ):
1757     """
1758     Creates a VMFS datastore from a disk_id
1759     host_ref
1760         vim.HostSystem object referencing a host to create the datastore on
1761     datastore_name
1762         Name of the datastore
1763     disk_ref
1764         vim.HostScsiDislk on which the datastore is created
1765     vmfs_major_version
1766         VMFS major version to use
1767     """
1768     hostname = get_managed_object_name(host_ref)
1769     disk_id = disk_ref.canonicalName
1770     log.debug(
1771         "Creating datastore '%s' on host '%s', scsi disk '%s', vmfs v%s",
1772         datastore_name,
1773         hostname,
1774         disk_id,
1775         vmfs_major_version,
1776     )
1777     if not storage_system:
1778         si = get_service_instance_from_managed_object(host_ref, name=hostname)
1779         storage_system = get_storage_system(si, host_ref, hostname)
1780     target_disk = disk_ref
1781     partition_info = _get_partition_info(storage_system, target_disk.devicePath)
1782     log.trace("partition_info = %s", partition_info)
1783     new_partition_number, partition_spec = _get_new_computed_partition_spec(
1784         storage_system, target_disk.devicePath, partition_info
1785     )
1786     spec = vim.VmfsDatastoreCreateSpec(
1787         vmfs=vim.HostVmfsSpec(
1788             majorVersion=vmfs_major_version,
1789             volumeName=datastore_name,
1790             extent=vim.HostScsiDiskPartition(
1791                 diskName=disk_id, partition=new_partition_number
1792             ),
1793         ),
1794         diskUuid=target_disk.uuid,
1795         partition=partition_spec,
1796     )
1797     try:
1798         ds_ref = host_ref.configManager.datastoreSystem.CreateVmfsDatastore(spec)
1799     except vim.fault.NoPermission as exc:
1800         log.exception(exc)
1801         raise salt.exceptions.VMwareApiError(
1802             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1803         )
1804     except vim.fault.VimFault as exc:
1805         log.exception(exc)
1806         raise salt.exceptions.VMwareApiError(exc.msg)
1807     except vmodl.RuntimeFault as exc:
1808         log.exception(exc)
1809         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1810     log.debug("Created datastore '%s' on host '%s'", datastore_name, hostname)
1811     return ds_ref
1812 def get_host_datastore_system(host_ref, hostname=None):
1813     """
1814     Returns a host's datastore system
1815     host_ref
1816         Reference to the ESXi host
1817     hostname
1818         Name of the host. This argument is optional.
1819     """
1820     if not hostname:
1821         hostname = get_managed_object_name(host_ref)
1822     service_instance = get_service_instance_from_managed_object(host_ref)
1823     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1824         path="configManager.datastoreSystem", type=vim.HostSystem, skip=False
1825     )
1826     objs = get_mors_with_properties(
1827         service_instance,
1828         vim.HostDatastoreSystem,
1829         property_list=["datastore"],
1830         container_ref=host_ref,
1831         traversal_spec=traversal_spec,
1832     )
1833     if not objs:
1834         raise salt.exceptions.VMwareObjectRetrievalError(
1835             "Host's '{}' datastore system was not retrieved".format(hostname)
1836         )
1837     log.trace("[%s] Retrieved datastore system", hostname)
1838     return objs[0]["object"]
1839 def remove_datastore(service_instance, datastore_ref):
1840     """
1841     Creates a VMFS datastore from a disk_id
1842     service_instance
1843         The Service Instance Object containing the datastore
1844     datastore_ref
1845         The reference to the datastore to remove
1846     """
1847     ds_props = get_properties_of_managed_object(datastore_ref, ["host", "info", "name"])
1848     ds_name = ds_props["name"]
1849     log.debug("Removing datastore '%s'", ds_name)
1850     ds_hosts = ds_props.get("host")
1851     if not ds_hosts:
1852         raise salt.exceptions.VMwareApiError(
1853             "Datastore '{}' can't be removed. No attached hosts found".format(ds_name)
1854         )
1855     hostname = get_managed_object_name(ds_hosts[0].key)
1856     host_ds_system = get_host_datastore_system(ds_hosts[0].key, hostname=hostname)
1857     try:
1858         host_ds_system.RemoveDatastore(datastore_ref)
1859     except vim.fault.NoPermission as exc:
1860         log.exception(exc)
1861         raise salt.exceptions.VMwareApiError(
1862             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1863         )
1864     except vim.fault.VimFault as exc:
1865         log.exception(exc)
1866         raise salt.exceptions.VMwareApiError(exc.msg)
1867     except vmodl.RuntimeFault as exc:
1868         log.exception(exc)
1869         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1870     log.trace("[%s] Removed datastore '%s'", hostname, ds_name)
1871 def get_hosts(
1872     service_instance,
1873     datacenter_name=None,
1874     host_names=None,
1875     cluster_name=None,
1876     get_all_hosts=False,
1877 ):
1878     """
1879     Returns a list of vim.HostSystem objects representing ESXi hosts
1880     in a vcenter filtered by their names and/or datacenter, cluster membership.
1881     service_instance
1882         The Service Instance Object from which to obtain the hosts.
1883     datacenter_name
1884         The datacenter name. Default is None.
1885     host_names
1886         The host_names to be retrieved. Default is None.
1887     cluster_name
1888         The cluster name - used to restrict the hosts retrieved. Only used if
1889         the datacenter is set.  This argument is optional.
1890     get_all_hosts
1891         Specifies whether to retrieve all hosts in the container.
1892         Default value is False.
1893     """
1894     properties = ["name"]
1895     if cluster_name and not datacenter_name:
1896         raise salt.exceptions.ArgumentValueError(
1897             "Must specify the datacenter when specifying the cluster"
1898         )
1899     if not host_names:
1900         host_names = []
1901     if not datacenter_name:
1902         start_point = get_root_folder(service_instance)
1903     else:
1904         start_point = get_datacenter(service_instance, datacenter_name)
1905         if cluster_name:
1906             properties.append("parent")
1907     hosts = get_mors_with_properties(
1908         service_instance,
1909         vim.HostSystem,
1910         container_ref=start_point,
1911         property_list=properties,
1912     )
1913     log.trace("Retrieved hosts: %s", [h["name"] for h in hosts])
1914     filtered_hosts = []
1915     for h in hosts:
1916         if cluster_name:
1917             if not isinstance(h["parent"], vim.ClusterComputeResource):
1918                 continue
1919             parent_name = get_managed_object_name(h["parent"])
1920             if parent_name != cluster_name:
1921                 continue
1922         if get_all_hosts:
1923             filtered_hosts.append(h["object"])
1924             continue
1925         if h["name"] in host_names:
1926             filtered_hosts.append(h["object"])
1927     return filtered_hosts
1928 def _get_scsi_address_to_lun_key_map(
1929     service_instance, host_ref, storage_system=None, hostname=None
1930 ):
1931     """
1932     Returns a map between the scsi addresses and the keys of all luns on an ESXi
1933     host.
1934         map[&lt;scsi_address&gt;] = &lt;lun key&gt;
1935     service_instance
1936         The Service Instance Object from which to obtain the hosts
1937     host_ref
1938         The vim.HostSystem object representing the host that contains the
1939         requested disks.
1940     storage_system
1941         The host's storage system. Default is None.
1942     hostname
1943         Name of the host. Default is None.
1944     """
1945     if not hostname:
1946         hostname = get_managed_object_name(host_ref)
1947     if not storage_system:
1948         storage_system = get_storage_system(service_instance, host_ref, hostname)
1949     try:
1950         device_info = storage_system.storageDeviceInfo
1951     except vim.fault.NoPermission as exc:
1952         log.exception(exc)
1953         raise salt.exceptions.VMwareApiError(
1954             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1955         )
1956     except vim.fault.VimFault as exc:
1957         log.exception(exc)
1958         raise salt.exceptions.VMwareApiError(exc.msg)
1959     except vmodl.RuntimeFault as exc:
1960         log.exception(exc)
1961         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1962     if not device_info:
1963         raise salt.exceptions.VMwareObjectRetrievalError(
1964             "Host's '{}' storage device info was not retrieved".format(hostname)
1965         )
1966     multipath_info = device_info.multipathInfo
1967     if not multipath_info:
1968         raise salt.exceptions.VMwareObjectRetrievalError(
1969             "Host's '{}' multipath info was not retrieved".format(hostname)
1970         )
1971     if multipath_info.lun is None:
1972         raise salt.exceptions.VMwareObjectRetrievalError(
1973             "No luns were retrieved from host '{}'".format(hostname)
1974         )
1975     lun_key_by_scsi_addr = {}
1976     for l in multipath_info.lun:
1977         lun_key_by_scsi_addr.update({p.name.split(",")[0]: l.lun for p in l.path})
1978     log.trace(
1979         "Scsi address to lun id map on host '%s': %s", hostname, lun_key_by_scsi_addr
1980     )
1981     return lun_key_by_scsi_addr
1982 def get_all_luns(host_ref, storage_system=None, hostname=None):
1983     """
1984     Returns a list of all vim.HostScsiDisk objects in a disk
1985     host_ref
1986         The vim.HostSystem object representing the host that contains the
1987         requested disks.
1988     storage_system
1989         The host's storage system. Default is None.
1990     hostname
1991         Name of the host. This argument is optional.
1992     """
1993     if not hostname:
1994         hostname = get_managed_object_name(host_ref)
1995     if not storage_system:
1996         si = get_service_instance_from_managed_object(host_ref, name=hostname)
1997         storage_system = get_storage_system(si, host_ref, hostname)
1998         if not storage_system:
1999             raise salt.exceptions.VMwareObjectRetrievalError(
2000                 "Host's '{}' storage system was not retrieved".format(hostname)
2001             )
2002     try:
2003         device_info = storage_system.storageDeviceInfo
2004     except vim.fault.NoPermission as exc:
2005         log.exception(exc)
2006         raise salt.exceptions.VMwareApiError(
2007             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2008         )
2009     except vim.fault.VimFault as exc:
2010         log.exception(exc)
2011         raise salt.exceptions.VMwareApiError(exc.msg)
2012     except vmodl.RuntimeFault as exc:
2013         log.exception(exc)
2014         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2015     if not device_info:
2016         raise salt.exceptions.VMwareObjectRetrievalError(
2017             "Host's '{}' storage device info was not retrieved".format(hostname)
2018         )
2019     scsi_luns = device_info.scsiLun
2020     if scsi_luns:
2021         log.trace(
2022             "Retrieved scsi luns in host '%s': %s",
2023             hostname,
2024             [l.canonicalName for l in scsi_luns],
2025         )
2026         return scsi_luns
2027     log.trace("Retrieved no scsi_luns in host '%s'", hostname)
2028     return []
2029 def get_scsi_address_to_lun_map(host_ref, storage_system=None, hostname=None):
2030     """
2031     Returns a map of all vim.ScsiLun objects on a ESXi host keyed by their
2032     scsi address
2033     host_ref
2034         The vim.HostSystem object representing the host that contains the
2035         requested disks.
2036     storage_system
2037         The host's storage system. Default is None.
2038     hostname
2039         Name of the host. This argument is optional.
2040     """
2041     if not hostname:
2042         hostname = get_managed_object_name(host_ref)
2043     si = get_service_instance_from_managed_object(host_ref, name=hostname)
2044     if not storage_system:
2045         storage_system = get_storage_system(si, host_ref, hostname)
2046     lun_ids_to_scsi_addr_map = _get_scsi_address_to_lun_key_map(
2047         si, host_ref, storage_system, hostname
2048     )
2049     luns_to_key_map = {
2050         d.key: d for d in get_all_luns(host_ref, storage_system, hostname)
2051     }
2052     return {
2053         scsi_addr: luns_to_key_map[lun_key]
2054         for scsi_addr, lun_key in lun_ids_to_scsi_addr_map.items()
2055     }
2056 def get_disks(host_ref, disk_ids=None, scsi_addresses=None, get_all_disks=False):
2057     """
2058     Returns a list of vim.HostScsiDisk objects representing disks
2059     in a ESXi host, filtered by their cannonical names and scsi_addresses
2060     host_ref
2061         The vim.HostSystem object representing the host that contains the
2062         requested disks.
2063     disk_ids
2064         The list of canonical names of the disks to be retrieved. Default value
2065         is None
2066     scsi_addresses
2067         The list of scsi addresses of the disks to be retrieved. Default value
2068         is None
2069     get_all_disks
2070         Specifies whether to retrieve all disks in the host.
2071         Default value is False.
2072     """
2073     hostname = get_managed_object_name(host_ref)
2074     if get_all_disks:
2075         log.trace("Retrieving all disks in host '%s'", hostname)
2076     else:
2077         log.trace(
2078             "Retrieving disks in host '%s': ids = (%s); scsi addresses = (%s)",
2079             hostname,
2080             disk_ids,
2081             scsi_addresses,
2082         )
2083         if not (disk_ids or scsi_addresses):
2084             return []
2085     si = get_service_instance_from_managed_object(host_ref, name=hostname)
2086     storage_system = get_storage_system(si, host_ref, hostname)
2087     disk_keys = []
2088     if scsi_addresses:
2089         lun_key_by_scsi_addr = _get_scsi_address_to_lun_key_map(
2090             si, host_ref, storage_system, hostname
2091         )
2092         disk_keys = [
2093             key
2094             for scsi_addr, key in lun_key_by_scsi_addr.items()
2095             if scsi_addr in scsi_addresses
2096         ]
2097         log.trace("disk_keys based on scsi_addresses = %s", disk_keys)
2098     scsi_luns = get_all_luns(host_ref, storage_system)
2099     scsi_disks = [
2100         disk
2101         for disk in scsi_luns
2102         if isinstance(disk, vim.HostScsiDisk)
2103         and (
2104             get_all_disks
2105             or
2106             (disk_ids and (disk.canonicalName in disk_ids))
2107             or
2108             (disk.key in disk_keys)
2109         )
2110     ]
2111     log.trace(
2112         "Retrieved disks in host '%s': %s",
2113         hostname,
2114         [d.canonicalName for d in scsi_disks],
2115     )
2116     return scsi_disks
2117 def get_disk_partition_info(host_ref, disk_id, storage_system=None):
2118     """
2119     Returns all partitions on a disk
2120     host_ref
2121         The reference of the ESXi host containing the disk
2122     disk_id
2123         The canonical name of the disk whose partitions are to be removed
2124     storage_system
2125         The ESXi host's storage system. Default is None.
2126     """
2127     hostname = get_managed_object_name(host_ref)
2128     service_instance = get_service_instance_from_managed_object(host_ref)
2129     if not storage_system:
2130         storage_system = get_storage_system(service_instance, host_ref, hostname)
2131     props = get_properties_of_managed_object(
2132         storage_system, ["storageDeviceInfo.scsiLun"]
2133     )
2134     if not props.get("storageDeviceInfo.scsiLun"):
2135         raise salt.exceptions.VMwareObjectRetrievalError(
2136             "No devices were retrieved in host '{}'".format(hostname)
2137         )
2138     log.trace(
2139         "[%s] Retrieved %s devices: %s",
2140         hostname,
2141         len(props["storageDeviceInfo.scsiLun"]),
2142         ", ".join([l.canonicalName for l in props["storageDeviceInfo.scsiLun"]]),
2143     )
2144     disks = [
2145         l
2146         for l in props["storageDeviceInfo.scsiLun"]
2147         if isinstance(l, vim.HostScsiDisk) and l.canonicalName == disk_id
2148     ]
2149     if not disks:
2150         raise salt.exceptions.VMwareObjectRetrievalError(
2151             "Disk '{}' was not found in host '{}'".format(disk_id, hostname)
2152         )
2153     log.trace("[%s] device_path = %s", hostname, disks[0].devicePath)
2154     partition_info = _get_partition_info(storage_system, disks[0].devicePath)
2155     log.trace(
2156         "[%s] Retrieved %s partition(s) on disk '%s'",
2157         hostname,
2158         len(partition_info.spec.partition),
2159         disk_id,
2160     )
2161     return partition_info
2162 def erase_disk_partitions(
2163     service_instance, host_ref, disk_id, hostname=None, storage_system=None
2164 ):
2165     """
2166     Erases all partitions on a disk
2167     in a vcenter filtered by their names and/or datacenter, cluster membership
2168     service_instance
2169         The Service Instance Object from which to obtain all information
2170     host_ref
2171         The reference of the ESXi host containing the disk
2172     disk_id
2173         The canonical name of the disk whose partitions are to be removed
2174     hostname
2175         The ESXi hostname. Default is None.
2176     storage_system
2177         The ESXi host's storage system. Default is None.
2178     """
2179     if not hostname:
2180         hostname = get_managed_object_name(host_ref)
2181     if not storage_system:
2182         storage_system = get_storage_system(service_instance, host_ref, hostname)
2183     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
2184         path="configManager.storageSystem", type=vim.HostSystem, skip=False
2185     )
2186     results = get_mors_with_properties(
2187         service_instance,
2188         vim.HostStorageSystem,
2189         ["storageDeviceInfo.scsiLun"],
2190         container_ref=host_ref,
2191         traversal_spec=traversal_spec,
2192     )
2193     if not results:
2194         raise salt.exceptions.VMwareObjectRetrievalError(
2195             "Host's '{}' devices were not retrieved".format(hostname)
2196         )
2197     log.trace(
2198         "[%s] Retrieved %s devices: %s",
2199         hostname,
2200         len(results[0].get("storageDeviceInfo.scsiLun", [])),
2201         ", ".join(
2202             [l.canonicalName for l in results[0].get("storageDeviceInfo.scsiLun", [])]
2203         ),
2204     )
2205     disks = [
2206         l
2207         for l in results[0].get("storageDeviceInfo.scsiLun", [])
2208         if isinstance(l, vim.HostScsiDisk) and l.canonicalName == disk_id
2209     ]
2210     if not disks:
2211         raise salt.exceptions.VMwareObjectRetrievalError(
2212             "Disk '{}' was not found in host '{}'".format(disk_id, hostname)
2213         )
2214     log.trace("[%s] device_path = %s", hostname, disks[0].devicePath)
2215     try:
2216         storage_system.UpdateDiskPartitions(
2217             disks[0].devicePath, vim.HostDiskPartitionSpec()
2218         )
2219     except vim.fault.NoPermission as exc:
2220         log.exception(exc)
2221         raise salt.exceptions.VMwareApiError(
2222             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2223         )
2224     except vim.fault.VimFault as exc:
2225         log.exception(exc)
2226         raise salt.exceptions.VMwareApiError(exc.msg)
2227     except vmodl.RuntimeFault as exc:
2228         log.exception(exc)
2229         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2230     log.trace("[%s] Erased partitions on disk '%s'", hostname, disk_id)
2231 def get_diskgroups(host_ref, cache_disk_ids=None, get_all_disk_groups=False):
2232     """
2233     Returns a list of vim.VsanHostDiskMapping objects representing disks
2234     in a ESXi host, filtered by their cannonical names.
2235     host_ref
2236         The vim.HostSystem object representing the host that contains the
2237         requested disks.
2238     cache_disk_ids
2239         The list of cannonical names of the cache disks to be retrieved. The
2240         canonical name of the cache disk is enough to identify the disk group
2241         because it is guaranteed to have one and only one cache disk.
2242         Default is None.
2243     get_all_disk_groups
2244         Specifies whether to retrieve all disks groups in the host.
2245         Default value is False.
2246     """
2247     hostname = get_managed_object_name(host_ref)
2248     if get_all_disk_groups:
2249         log.trace("Retrieving all disk groups on host '%s'", hostname)
2250     else:
2251         log.trace(
2252             "Retrieving disk groups from host '%s', with cache disk ids : (%s)",
2253             hostname,
2254             cache_disk_ids,
2255         )
2256         if not cache_disk_ids:
2257             return []
2258     try:
2259         vsan_host_config = host_ref.config.vsanHostConfig
2260     except vim.fault.NoPermission as exc:
2261         log.exception(exc)
2262         raise salt.exceptions.VMwareApiError(
2263             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2264         )
2265     except vim.fault.VimFault as exc:
2266         log.exception(exc)
2267         raise salt.exceptions.VMwareApiError(exc.msg)
2268     except vmodl.RuntimeFault as exc:
2269         log.exception(exc)
2270         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2271     if not vsan_host_config:
2272         raise salt.exceptions.VMwareObjectRetrievalError(
2273             "No host config found on host '{}'".format(hostname)
2274         )
2275     vsan_storage_info = vsan_host_config.storageInfo
2276     if not vsan_storage_info:
2277         raise salt.exceptions.VMwareObjectRetrievalError(
2278             "No vsan storage info found on host '{}'".format(hostname)
2279         )
2280     vsan_disk_mappings = vsan_storage_info.diskMapping
2281     if not vsan_disk_mappings:
2282         return []
2283     disk_groups = [
2284         dm
2285         for dm in vsan_disk_mappings
2286         if (get_all_disk_groups or (dm.ssd.canonicalName in cache_disk_ids))
2287     ]
2288     log.trace(
2289         "Retrieved disk groups on host '%s', with cache disk ids : %s",
2290         hostname,
2291         [d.ssd.canonicalName for d in disk_groups],
2292     )
2293     return disk_groups
2294 def _check_disks_in_diskgroup(disk_group, cache_disk_id, capacity_disk_ids):
2295     """
2296     Checks that the disks in a disk group are as expected and raises
2297     CheckError exceptions if the check fails
2298     """
2299     if not disk_group.ssd.canonicalName == cache_disk_id:
2300         raise salt.exceptions.ArgumentValueError(
2301             "Incorrect diskgroup cache disk; got id: '{}'; expected id: '{}'".format(
2302                 disk_group.ssd.canonicalName, cache_disk_id
2303             )
2304         )
2305     non_ssd_disks = [d.canonicalName for d in disk_group.nonSsd]
2306     if sorted(non_ssd_disks) != sorted(capacity_disk_ids):
2307         raise salt.exceptions.ArgumentValueError(
2308             "Incorrect capacity disks; got ids: '{}'; expected ids: '{}'".format(
2309                 sorted(non_ssd_disks), sorted(capacity_disk_ids)
2310             )
2311         )
2312     log.trace("Checked disks in diskgroup with cache disk id '%s'", cache_disk_id)
2313     return True
2314 def get_host_cache(host_ref, host_cache_manager=None):
2315     """
2316     Returns a vim.HostScsiDisk if the host cache is configured on the specified
2317     host, other wise returns None
2318     host_ref
2319         The vim.HostSystem object representing the host that contains the
2320         requested disks.
2321     host_cache_manager
2322         The vim.HostCacheConfigurationManager object representing the cache
2323         configuration manager on the specified host. Default is None. If None,
2324         it will be retrieved in the method
2325     """
2326     hostname = get_managed_object_name(host_ref)
2327     service_instance = get_service_instance_from_managed_object(host_ref)
2328     log.trace("Retrieving the host cache on host '%s'", hostname)
2329     if not host_cache_manager:
2330         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
2331             path="configManager.cacheConfigurationManager",
2332             type=vim.HostSystem,
2333             skip=False,
2334         )
2335         results = get_mors_with_properties(
2336             service_instance,
2337             vim.HostCacheConfigurationManager,
2338             ["cacheConfigurationInfo"],
2339             container_ref=host_ref,
2340             traversal_spec=traversal_spec,
2341         )
2342         if not results or not results[0].get("cacheConfigurationInfo"):
2343             log.trace("Host '%s' has no host cache", hostname)
2344             return None
2345         return results[0]["cacheConfigurationInfo"][0]
2346     else:
2347         results = get_properties_of_managed_object(
2348             host_cache_manager, ["cacheConfigurationInfo"]
2349         )
2350         if not results:
2351             log.trace("Host '%s' has no host cache", hostname)
2352             return None
2353         return results["cacheConfigurationInfo"][0]
2354 def configure_host_cache(
2355     host_ref, datastore_ref, swap_size_MiB, host_cache_manager=None
2356 ):
2357     """
2358     Configures the host cahe of the specified host
2359     host_ref
2360         The vim.HostSystem object representing the host that contains the
2361         requested disks.
2362     datastore_ref
2363         The vim.Datastore opject representing the datastore the host cache will
2364         be configured on.
2365     swap_size_MiB
2366         The size in Mibibytes of the swap.
2367     host_cache_manager
2368         The vim.HostCacheConfigurationManager object representing the cache
2369         configuration manager on the specified host. Default is None. If None,
2370         it will be retrieved in the method
2371     """
2372     hostname = get_managed_object_name(host_ref)
2373     if not host_cache_manager:
2374         props = get_properties_of_managed_object(
2375             host_ref, ["configManager.cacheConfigurationManager"]
2376         )
2377         if not props.get("configManager.cacheConfigurationManager"):
2378             raise salt.exceptions.VMwareObjectRetrievalError(
2379                 "Host '{}' has no host cache".format(hostname)
2380             )
2381         host_cache_manager = props["configManager.cacheConfigurationManager"]
2382     log.trace(
2383         "Configuring the host cache on host '%s', datastore '%s', swap size=%s MiB",
2384         hostname,
2385         datastore_ref.name,
2386         swap_size_MiB,
2387     )
2388     spec = vim.HostCacheConfigurationSpec(
2389         datastore=datastore_ref, swapSize=swap_size_MiB
2390     )
2391     log.trace("host_cache_spec=%s", spec)
2392     try:
2393         task = host_cache_manager.ConfigureHostCache_Task(spec)
2394     except vim.fault.NoPermission as exc:
2395         log.exception(exc)
2396         raise salt.exceptions.VMwareApiError(
2397             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2398         )
2399     except vim.fault.VimFault as exc:
2400         log.exception(exc)
2401         raise salt.exceptions.VMwareApiError(exc.msg)
2402     except vmodl.RuntimeFault as exc:
2403         log.exception(exc)
2404         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2405     wait_for_task(task, hostname, "HostCacheConfigurationTask")
2406     log.trace("Configured host cache on host '%s'", hostname)
2407     return True
2408 def list_hosts(service_instance):
2409     """
2410     Returns a list of hosts associated with a given service instance.
2411     service_instance
2412         The Service Instance Object from which to obtain hosts.
2413     """
2414     return list_objects(service_instance, vim.HostSystem)
2415 def get_resource_pools(
2416     service_instance,
2417     resource_pool_names,
2418     datacenter_name=None,
2419     get_all_resource_pools=False,
2420 ):
2421     """
2422     Retrieves resource pool objects
2423     service_instance
2424         The service instance object to query the vCenter
2425     resource_pool_names
2426         Resource pool names
2427     datacenter_name
2428         Name of the datacenter where the resource pool is available
2429     get_all_resource_pools
2430         Boolean
2431     return
2432         Resourcepool managed object reference
2433     """
2434     properties = ["name"]
2435     if not resource_pool_names:
2436         resource_pool_names = []
2437     if datacenter_name:
2438         container_ref = get_datacenter(service_instance, datacenter_name)
2439     else:
2440         container_ref = get_root_folder(service_instance)
2441     resource_pools = get_mors_with_properties(
2442         service_instance,
2443         vim.ResourcePool,
2444         container_ref=container_ref,
2445         property_list=properties,
2446     )
2447     selected_pools = []
2448     for pool in resource_pools:
2449         if get_all_resource_pools or (pool["name"] in resource_pool_names):
2450             selected_pools.append(pool["object"])
2451     if not selected_pools:
2452         raise salt.exceptions.VMwareObjectRetrievalError(
2453             "The resource pools with properties "
2454             "names={} get_all={} could not be found".format(
2455                 selected_pools, get_all_resource_pools
2456             )
2457         )
2458     return selected_pools
2459 def list_resourcepools(service_instance):
2460     """
2461     Returns a list of resource pools associated with a given service instance.
2462     service_instance
2463         The Service Instance Object from which to obtain resource pools.
2464     """
2465     return list_objects(service_instance, vim.ResourcePool)
2466 def list_networks(service_instance):
2467     """
2468     Returns a list of networks associated with a given service instance.
2469     service_instance
2470         The Service Instance Object from which to obtain networks.
2471     """
2472     return list_objects(service_instance, vim.Network)
2473 def list_vms(service_instance):
2474     """
2475     Returns a list of VMs associated with a given service instance.
2476     service_instance
2477         The Service Instance Object from which to obtain VMs.
2478     """
2479     return list_objects(service_instance, vim.VirtualMachine)
2480 def list_folders(service_instance):
2481     """
2482     Returns a list of folders associated with a given service instance.
2483     service_instance
2484         The Service Instance Object from which to obtain folders.
2485     """
2486     return list_objects(service_instance, vim.Folder)
2487 def list_dvs(service_instance):
2488     """
2489     Returns a list of distributed virtual switches associated with a given service instance.
2490     service_instance
2491         The Service Instance Object from which to obtain distributed virtual switches.
2492     """
2493     return list_objects(service_instance, vim.DistributedVirtualSwitch)
2494 def list_vapps(service_instance):
2495     """
2496     Returns a list of vApps associated with a given service instance.
2497     service_instance
2498         The Service Instance Object from which to obtain vApps.
2499     """
2500     return list_objects(service_instance, vim.VirtualApp)
2501 def list_portgroups(service_instance):
2502     """
2503     Returns a list of distributed virtual portgroups associated with a given service instance.
2504     service_instance
2505         The Service Instance Object from which to obtain distributed virtual switches.
2506     """
2507     return list_objects(service_instance, vim.dvs.DistributedVirtualPortgroup)
2508 def wait_for_task(task, instance_name, task_type, sleep_seconds=1, log_level="debug"):
2509     """
2510     Waits for a task to be completed.
2511     task
2512         The task to wait for.
2513     instance_name
2514         The name of the ESXi host, vCenter Server, or Virtual Machine that
2515         the task is being run on.
2516     task_type
2517         The type of task being performed. Useful information for debugging purposes.
2518     sleep_seconds
2519         The number of seconds to wait before querying the task again.
2520         Defaults to ``1`` second.
2521     log_level
2522         The level at which to log task information. Default is ``debug``,
2523         but ``info`` is also supported.
2524     """
2525     time_counter = 0
2526     start_time = time.time()
2527     log.trace("task = %s, task_type = %s", task, task.__class__.__name__)
2528     try:
2529         task_info = task.info
2530     except vim.fault.NoPermission as exc:
2531         log.exception(exc)
2532         raise salt.exceptions.VMwareApiError(
2533             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2534         )
2535     except vim.fault.FileNotFound as exc:
2536         log.exception(exc)
2537         raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
2538     except vim.fault.VimFault as exc:
2539         log.exception(exc)
2540         raise salt.exceptions.VMwareApiError(exc.msg)
2541     except vmodl.RuntimeFault as exc:
2542         log.exception(exc)
2543         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2544     while task_info.state == "running" or task_info.state == "queued":
2545         if time_counter % sleep_seconds == 0:
2546             msg = "[ {} ] Waiting for {} task to finish [{} s]".format(
2547                 instance_name, task_type, time_counter
2548             )
2549             if log_level == "info":
2550                 log.info(msg)
2551             else:
2552                 log.debug(msg)
2553         time.sleep(1.0 - ((time.time() - start_time) % 1.0))
2554         time_counter += 1
2555         try:
2556             task_info = task.info
2557         except vim.fault.NoPermission as exc:
2558             log.exception(exc)
2559             raise salt.exceptions.VMwareApiError(
2560                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2561             )
2562         except vim.fault.FileNotFound as exc:
2563             log.exception(exc)
2564             raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
2565         except vim.fault.VimFault as exc:
2566             log.exception(exc)
2567             raise salt.exceptions.VMwareApiError(exc.msg)
2568         except vmodl.RuntimeFault as exc:
2569             log.exception(exc)
2570             raise salt.exceptions.VMwareRuntimeError(exc.msg)
2571     if task_info.state == "success":
2572         msg = "[ {} ] Successfully completed {} task in {} seconds".format(
2573             instance_name, task_type, time_counter
2574         )
2575         if log_level == "info":
2576             log.info(msg)
2577         else:
2578             log.debug(msg)
2579         return task_info.result
2580     else:
2581         try:
2582             raise task_info.error
2583         except vim.fault.NoPermission as exc:
2584             log.exception(exc)
2585             raise salt.exceptions.VMwareApiError(
2586                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2587             )
2588         except vim.fault.FileNotFound as exc:
2589             log.exception(exc)
2590             raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
2591         except vim.fault.VimFault as exc:
2592             log.exception(exc)
2593             raise salt.exceptions.VMwareApiError(exc.msg)
2594         except vmodl.fault.SystemError as exc:
2595             log.exception(exc)
2596             raise salt.exceptions.VMwareSystemError(exc.msg)
2597         except vmodl.fault.InvalidArgument as exc:
2598             log.exception(exc)
2599             exc_message = exc.msg
2600             if exc.faultMessage:
2601                 exc_message = "{} ({})".format(exc_message, exc.faultMessage[0].message)
2602             raise salt.exceptions.VMwareApiError(exc_message)
2603 def get_vm_by_property(
2604     service_instance,
2605     name,
2606     datacenter=None,
2607     vm_properties=None,
2608     traversal_spec=None,
2609     parent_ref=None,
2610 ):
2611     """
2612     Get virtual machine properties based on the traversal specs and properties list,
2613     returns Virtual Machine object with properties.
2614     service_instance
2615         Service instance object to access vCenter
2616     name
2617         Name of the virtual machine.
2618     datacenter
2619         Datacenter name
2620     vm_properties
2621         List of vm properties.
2622     traversal_spec
2623         Traversal Spec object(s) for searching.
2624     parent_ref
2625         Container Reference object for searching under a given object.
2626     """
2627     if datacenter and not parent_ref:
2628         parent_ref = salt.utils.vmware.get_datacenter(service_instance, datacenter)
2629     if not vm_properties:
2630         vm_properties = [
2631             "name",
2632             "config.hardware.device",
2633             "summary.storage.committed",
2634             "summary.storage.uncommitted",
2635             "summary.storage.unshared",
2636             "layoutEx.file",
2637             "config.guestFullName",
2638             "config.guestId",
2639             "guest.net",
2640             "config.hardware.memoryMB",
2641             "config.hardware.numCPU",
2642             "config.files.vmPathName",
2643             "summary.runtime.powerState",
2644             "guest.toolsStatus",
2645         ]
2646     vm_list = salt.utils.vmware.get_mors_with_properties(
2647         service_instance,
2648         vim.VirtualMachine,
2649         vm_properties,
2650         container_ref=parent_ref,
2651         traversal_spec=traversal_spec,
2652     )
2653     vm_formatted = [vm for vm in vm_list if vm["name"] == name]
2654     if not vm_formatted:
2655         raise salt.exceptions.VMwareObjectRetrievalError(
2656             "The virtual machine was not found."
2657         )
2658     elif len(vm_formatted) &gt; 1:
2659         raise salt.exceptions.VMwareMultipleObjectsError(
2660             " ".join(
2661                 [
2662                     "Multiple virtual machines were found with the"
2663                     "same name, please specify a container."
2664                 ]
2665             )
2666         )
2667     return vm_formatted[0]
2668 def get_folder(service_instance, datacenter, placement, base_vm_name=None):
2669     """
2670     Returns a Folder Object
2671     service_instance
2672         Service instance object
2673     datacenter
2674         Name of the datacenter
2675     placement
2676         Placement dictionary
2677     base_vm_name
2678         Existing virtual machine name (for cloning)
2679     """
2680     log.trace("Retrieving folder information")
2681     if base_vm_name:
2682         vm_object = get_vm_by_property(
2683             service_instance, base_vm_name, vm_properties=["name"]
2684         )
2685         vm_props = salt.utils.vmware.get_properties_of_managed_object(
2686             vm_object, properties=["parent"]
2687         )
2688         if "parent" in vm_props:
2689             folder_object = vm_props["parent"]
2690         else:
2691             raise salt.exceptions.VMwareObjectRetrievalError(
2692                 " ".join(["The virtual machine parent", "object is not defined"])
2693             )
2694     elif "folder" in placement:
2695         folder_objects = salt.utils.vmware.get_folders(
2696             service_instance, [placement["folder"]], datacenter
2697         )
2698         if len(folder_objects) &gt; 1:
2699             raise salt.exceptions.VMwareMultipleObjectsError(
2700                 " ".join(
2701                     [
2702                         "Multiple instances are available of the",
2703                         "specified folder {}".format(placement["folder"]),
2704                     ]
2705                 )
2706             )
2707         folder_object = folder_objects[0]
2708     elif datacenter:
2709         datacenter_object = salt.utils.vmware.get_datacenter(
2710             service_instance, datacenter
2711         )
2712         dc_props = salt.utils.vmware.get_properties_of_managed_object(
2713             datacenter_object, properties=["vmFolder"]
2714         )
2715         if "vmFolder" in dc_props:
2716             folder_object = dc_props["vmFolder"]
2717         else:
2718             raise salt.exceptions.VMwareObjectRetrievalError(
2719                 "The datacenter vm folder object is not defined"
2720             )
2721     return folder_object
2722 def get_placement(service_instance, datacenter, placement=None):
2723     """
2724     To create a virtual machine a resource pool needs to be supplied, we would like to use the strictest as possible.
2725     datacenter
2726         Name of the datacenter
2727     placement
2728         Dictionary with the placement info, cluster, host resource pool name
2729     return
2730         Resource pool, cluster and host object if any applies
2731     """
2732     log.trace("Retrieving placement information")
2733     resourcepool_object, placement_object = None, None
2734     if "host" in placement:
2735         host_objects = get_hosts(
2736             service_instance, datacenter_name=datacenter, host_names=[placement["host"]]
2737         )
2738         if not host_objects:
2739             raise salt.exceptions.VMwareObjectRetrievalError(
2740                 " ".join(
2741                     [
2742                         "The specified host",
2743                         "{} cannot be found.".format(placement["host"]),
2744                     ]
2745                 )
2746             )
2747         try:
2748             host_props = get_properties_of_managed_object(
2749                 host_objects[0], properties=["resourcePool"]
2750             )
2751             resourcepool_object = host_props["resourcePool"]
2752         except vmodl.query.InvalidProperty:
2753             traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
2754                 path="parent",
2755                 skip=True,
2756                 type=vim.HostSystem,
2757                 selectSet=[
2758                     vmodl.query.PropertyCollector.TraversalSpec(
2759                         path="resourcePool", skip=False, type=vim.ClusterComputeResource
2760                     )
2761                 ],
2762             )
2763             resourcepools = get_mors_with_properties(
2764                 service_instance,
2765                 vim.ResourcePool,
2766                 container_ref=host_objects[0],
2767                 property_list=["name"],
2768                 traversal_spec=traversal_spec,
2769             )
2770             if resourcepools:
2771                 resourcepool_object = resourcepools[0]["object"]
2772             else:
2773                 raise salt.exceptions.VMwareObjectRetrievalError(
2774                     "The resource pool of host {} cannot be found.".format(
2775                         placement["host"]
2776                     )
2777                 )
2778         placement_object = host_objects[0]
2779     elif "resourcepool" in placement:
2780         resourcepool_objects = get_resource_pools(
2781             service_instance, [placement["resourcepool"]], datacenter_name=datacenter
2782         )
2783         if len(resourcepool_objects) &gt; 1:
2784             raise salt.exceptions.VMwareMultipleObjectsError(
2785                 " ".join(
2786                     [
2787                         "Multiple instances are available of the",
2788                         "specified host {}.".format(placement["host"]),
2789                     ]
2790                 )
2791             )
2792         resourcepool_object = resourcepool_objects[0]
2793         res_props = get_properties_of_managed_object(
2794             resourcepool_object, properties=["parent"]
2795         )
2796         if "parent" in res_props:
2797             placement_object = res_props["parent"]
2798         else:
2799             raise salt.exceptions.VMwareObjectRetrievalError(
2800                 " ".join(["The resource pool's parent", "object is not defined"])
2801             )
2802     elif "cluster" in placement:
2803         datacenter_object = get_datacenter(service_instance, datacenter)
2804         cluster_object = get_cluster(datacenter_object, placement["cluster"])
2805         clus_props = get_properties_of_managed_object(
2806             cluster_object, properties=["resourcePool"]
2807         )
2808         if "resourcePool" in clus_props:
2809             resourcepool_object = clus_props["resourcePool"]
2810         else:
2811             raise salt.exceptions.VMwareObjectRetrievalError(
2812                 " ".join(["The cluster's resource pool", "object is not defined"])
2813             )
2814         placement_object = cluster_object
2815     else:
2816         raise salt.exceptions.VMwareObjectRetrievalError(
2817             " ".join(["Placement is not defined."])
2818         )
2819     return (resourcepool_object, placement_object)
2820 def convert_to_kb(unit, size):
2821     """
2822     Converts the given size to KB based on the unit, returns a long integer.
2823     unit
2824         Unit of the size eg. GB; Note: to VMware a GB is the same as GiB = 1024MiB
2825     size
2826         Number which represents the size
2827     """
2828     if unit.lower() == "gb":
2829         target_size = int(size * 1024 * 1024)
2830     elif unit.lower() == "mb":
2831         target_size = int(size * 1024)
2832     elif unit.lower() == "kb":
2833         target_size = int(size)
2834     else:
2835         raise salt.exceptions.ArgumentValueError("The unit is not specified")
2836     return {"size": target_size, "unit": "KB"}
2837 def power_cycle_vm(virtual_machine, action="on"):
2838     """
2839     Powers on/off a virtual machine specified by its name.
2840     virtual_machine
2841         vim.VirtualMachine object to power on/off virtual machine
2842     action
2843         Operation option to power on/off the machine
2844     """
2845     if action == "on":
2846         try:
2847             task = virtual_machine.PowerOn()
2848             task_name = "power on"
2849         except vim.fault.NoPermission as exc:
2850             log.exception(exc)
2851             raise salt.exceptions.VMwareApiError(
2852                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2853             )
2854         except vim.fault.VimFault as exc:
2855             log.exception(exc)
2856             raise salt.exceptions.VMwareApiError(exc.msg)
2857         except vmodl.RuntimeFault as exc:
2858             log.exception(exc)
2859             raise salt.exceptions.VMwareRuntimeError(exc.msg)
2860     elif action == "off":
2861         try:
2862             task = virtual_machine.PowerOff()
2863             task_name = "power off"
2864         except vim.fault.NoPermission as exc:
2865             log.exception(exc)
2866             raise salt.exceptions.VMwareApiError(
2867                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2868             )
2869         except vim.fault.VimFault as exc:
2870             log.exception(exc)
2871             raise salt.exceptions.VMwareApiError(exc.msg)
2872         except vmodl.RuntimeFault as exc:
2873             log.exception(exc)
2874             raise salt.exceptions.VMwareRuntimeError(exc.msg)
2875     else:
2876         raise salt.exceptions.ArgumentValueError("The given action is not supported")
2877     try:
2878         wait_for_task(task, get_managed_object_name(virtual_machine), task_name)
2879     except salt.exceptions.VMwareFileNotFoundError as exc:
2880         raise salt.exceptions.VMwarePowerOnError(
2881             " ".join(
2882                 [
2883                     "An error occurred during power",
2884                     "operation, a file was not found: {}".format(exc),
2885                 ]
2886             )
2887         )
2888     return virtual_machine
2889 def create_vm(
2890     vm_name, vm_config_spec, folder_object, resourcepool_object, host_object=None
2891 ):
2892     """
2893     Creates virtual machine from config spec
2894     vm_name
2895         Virtual machine name to be created
2896     vm_config_spec
2897         Virtual Machine Config Spec object
2898     folder_object
2899         vm Folder managed object reference
2900     resourcepool_object
2901         Resource pool object where the machine will be created
2902     host_object
2903         Host object where the machine will ne placed (optional)
2904     return
2905         Virtual Machine managed object reference
2906     """
2907     try:
2908         if host_object and isinstance(host_object, vim.HostSystem):
2909             task = folder_object.CreateVM_Task(
2910                 vm_config_spec, pool=resourcepool_object, host=host_object
2911             )
2912         else:
2913             task = folder_object.CreateVM_Task(vm_config_spec, pool=resourcepool_object)
2914     except vim.fault.NoPermission as exc:
2915         log.exception(exc)
2916         raise salt.exceptions.VMwareApiError(
2917             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2918         )
2919     except vim.fault.VimFault as exc:
2920         log.exception(exc)
2921         raise salt.exceptions.VMwareApiError(exc.msg)
2922     except vmodl.RuntimeFault as exc:
2923         log.exception(exc)
2924         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2925     vm_object = wait_for_task(task, vm_name, "CreateVM Task", 10, "info")
2926     return vm_object
2927 def register_vm(datacenter, name, vmx_path, resourcepool_object, host_object=None):
2928     """
2929     Registers a virtual machine to the inventory with the given vmx file, on success
2930     it returns the vim.VirtualMachine managed object reference
2931     datacenter
2932         Datacenter object of the virtual machine, vim.Datacenter object
2933     name
2934         Name of the virtual machine
2935     vmx_path:
2936         Full path to the vmx file, datastore name should be included
2937     resourcepool
2938         Placement resource pool of the virtual machine, vim.ResourcePool object
2939     host
2940         Placement host of the virtual machine, vim.HostSystem object
2941     """
2942     try:
2943         if host_object:
2944             task = datacenter.vmFolder.RegisterVM_Task(
2945                 path=vmx_path,
2946                 name=name,
2947                 asTemplate=False,
2948                 host=host_object,
2949                 pool=resourcepool_object,
2950             )
2951         else:
2952             task = datacenter.vmFolder.RegisterVM_Task(
2953                 path=vmx_path, name=name, asTemplate=False, pool=resourcepool_object
2954             )
2955     except vim.fault.NoPermission as exc:
2956         log.exception(exc)
2957         raise salt.exceptions.VMwareApiError(
2958             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2959         )
2960     except vim.fault.VimFault as exc:
2961         log.exception(exc)
2962         raise salt.exceptions.VMwareApiError(exc.msg)
2963     except vmodl.RuntimeFault as exc:
2964         log.exception(exc)
2965         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2966     try:
2967         vm_ref = wait_for_task(task, name, "RegisterVM Task")
2968     except salt.exceptions.VMwareFileNotFoundError as exc:
2969         raise salt.exceptions.VMwareVmRegisterError(
2970             "An error occurred during registration operation, the "
2971             "configuration file was not found: {}".format(exc)
2972         )
2973     return vm_ref
2974 def update_vm(vm_ref, vm_config_spec):
2975     """
2976     Updates the virtual machine configuration with the given object
2977     vm_ref
2978         Virtual machine managed object reference
2979     vm_config_spec
2980         Virtual machine config spec object to update
2981     """
2982     vm_name = get_managed_object_name(vm_ref)
2983     log.trace("Updating vm '%s'", vm_name)
2984     try:
2985         task = vm_ref.ReconfigVM_Task(vm_config_spec)
2986     except vim.fault.NoPermission as exc:
2987         log.exception(exc)
2988         raise salt.exceptions.VMwareApiError(
2989             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2990         )
2991     except vim.fault.VimFault as exc:
2992         log.exception(exc)
2993         raise salt.exceptions.VMwareApiError(exc.msg)
2994     except vmodl.RuntimeFault as exc:
2995         log.exception(exc)
2996         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2997     vm_ref = wait_for_task(task, vm_name, "ReconfigureVM Task")
2998     return vm_ref
2999 def delete_vm(vm_ref):
3000     """
3001     Destroys the virtual machine
3002     vm_ref
3003         Managed object reference of a virtual machine object
3004     """
3005     vm_name = get_managed_object_name(vm_ref)
3006     log.trace("Destroying vm '%s'", vm_name)
3007     try:
3008         task = vm_ref.Destroy_Task()
3009     except vim.fault.NoPermission as exc:
3010         log.exception(exc)
3011         raise salt.exceptions.VMwareApiError(
3012             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
3013         )
3014     except vim.fault.VimFault as exc:
3015         log.exception(exc)
3016         raise salt.exceptions.VMwareApiError(exc.msg)
3017     except vmodl.RuntimeFault as exc:
3018         log.exception(exc)
3019         raise salt.exceptions.VMwareRuntimeError(exc.msg)
3020     wait_for_task(task, vm_name, "Destroy Task")
3021 def unregister_vm(vm_ref):
3022     """
3023     Destroys the virtual machine
3024     vm_ref
3025         Managed object reference of a virtual machine object
3026     """
3027     vm_name = get_managed_object_name(vm_ref)
3028     log.trace("Destroying vm '%s'", vm_name)
3029     try:
3030         vm_ref.UnregisterVM()
3031     except vim.fault.NoPermission as exc:
3032         log.exception(exc)
3033         raise salt.exceptions.VMwareApiError(
3034             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
3035         )
3036     except vim.fault.VimFault as exc:
3037         raise salt.exceptions.VMwareApiError(exc.msg)
3038     except vmodl.RuntimeFault as exc:
3039         raise salt.exceptions.VMwareRuntimeError(exc.msg)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
