<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for zfs.py &amp; vmware_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for zfs.py &amp; vmware_1.py
      </h3>
<h1 align="center">
        1.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>zfs.py (18.007664%)<th>vmware_1.py (0.9686727%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(62-82)<td><a href="#" name="0">(818-824)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(218-301)<td><a href="#" name="1">(2455-2467)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(106-124)<td><a href="#" name="2">(795-797)</a><td align="center"><font color="#aa0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>zfs.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import salt.utils.zfs
2 from tests.support.mock import MagicMock, patch
3 class ZFSMockData:
4     def __init__(self):
5         self.pmap_exec_zpool = {
6             "retcode": 2,
7             "stdout": "",
8             "stderr": "\n".join(
9                 [
10                     "missing property argument",
11                     "usage:",
12                     '        get [-Hp] [-o "all" | field[,...]] &lt;"all" |'
13                     " property[,...]&gt; &lt;pool&gt; ...",
14                     "",
15                     "the following properties are supported:",
16                     "",
17                     "        PROPERTY         EDIT   VALUES",
18                     "",
19                     "        allocated          NO   &lt;size&gt;",
20                     "        capacity           NO   &lt;size&gt;",
21                     "        dedupratio         NO   &lt;1.00x or higher if deduped&gt;",
22                     "        expandsize         NO   &lt;size&gt;",
23                     "        fragmentation      NO   &lt;percent&gt;",
24                     "        free               NO   &lt;size&gt;",
25                     "        freeing            NO   &lt;size&gt;",
26                     "        guid               NO   &lt;guid&gt;",
27                     "        health             NO   &lt;state&gt;",
28                     "        leaked             NO   &lt;size&gt;",
29                     "        size               NO   &lt;size&gt;",
30                     "        altroot           YES   &lt;path&gt;",
31                     "        autoexpand        YES   on | off",
32                     "        autoreplace       YES   on | off",
33                     "        bootfs            YES   &lt;filesystem&gt;",
34                     "        bootsize          YES   &lt;size&gt;",
35                     "        cachefile         YES   &lt;file&gt; | none",
36                     "        comment           YES   &lt;comment-string&gt;",
37                     "        dedupditto        YES   &lt;threshold (min 100)&gt;",
38                     "        delegation        YES   on | off",
39                     "        failmode          YES   wait | continue | panic",
40                     "        listsnapshots     YES   on | off",
41                     "        readonly          YES   on | off",
42                     "        version           YES   &lt;version&gt;",
43                     "        feature@...       YES   disabled | enabled | active",
44                     "",
45                     "The feature@ properties must be appended with a feature name.",
46                     "See zpool-features(5). ",
47                 ]
48 <a name="0"></a>            ),
49         }
50         self.pmap_zpool = {
51             <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"comment": {"edit": True, "type": "str", "values": "&lt;comment-string&gt;"},
52             "freeing": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
53             "listsnapshots": {"edit": True, "type": "bool", "values": "on | off"},
54             "leaked": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
55             "version": {"edit": True, "type": "numeric", "values": "&lt;version&gt;"},
56             "write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
57             "replace": {"edit": True, "type": "bool", "values": "on | off"},
58             "delegation": {"edit": True, "type": "bool", "values": "on | off"},
59             "dedupditto": {
60                 "edit": True,
61                 "type": "str",
62                 "values": "&lt;threshold (min 100)&gt;",
63             },
64             "autoexpand": {"edit": True, "type": "bool", "values": "on | off"},
65             "alloc": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
66             "allocated": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
67             "guid": {"edit": False, "type": "numeric", "values": "&lt;guid&gt;"},
68             "size": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
69             "cap": {"edit": False, "type": "numeric", "values": "&lt;count&gt;"},
70             "capacity": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
71             "capacity-alloc": {"edit"</b></font>: False, "type": "size", "values": "&lt;size&gt;"},
72             "capacity-free": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
73             "cachefile": {"edit": True, "type": "str", "values": "&lt;file&gt; | none"},
74             "cksum": {"edit": False, "type": "numeric", "values": "&lt;count&gt;"},
75             "bootfs": {"edit": True, "type": "str", "values": "&lt;filesystem&gt;"},
76             "autoreplace": {"edit": True, "type": "bool", "values": "on | off"},
77             "bandwidth-read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
78             "bandwidth-write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
79             "operations-read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
80             "operations-write": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
81             "read": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
82             "readonly": {"edit": True, "type": "bool", "values": "on | off"},
83             "dedupratio": {
84                 "edit": False,
85                 "type": "str",
86                 "values": "&lt;1.00x or higher if deduped&gt;",
87             },
88             "health": {"edit": False, "type": "str", "values": "&lt;state&gt;"},
89             "feature@": {
90                 "edit": True,
91                 "type": "str",
92 <a name="2"></a>                "values": "disabled | enabled | active",
93             },
94             "expandsize": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
95             "listsnaps": {<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>"edit": True, "type": "bool", "values": "on | off"},
96             "bootsize": {"edit": True, "type": "size", "values": "&lt;size&gt;"},
97             "free": {"edit": False, "type": "size", "values": "&lt;size&gt;"},
98             "failmode": {
99                 "edit": True,
100                 "type": "str",
101                 "values": "wait | continue | panic",
102             },
103             "altroot": {"edit": True, "type": "str", "values": "&lt;path&gt;"},
104             "expand": {"edit": True, "type": "bool", "values": "on | off"},
105             "frag": {"edit": False, "type": "str", "values": "&lt;percent&gt;"},
106             "fragmentation": {"edit": False, "type": "str", "values": "&lt;percent&gt;"},
107         }
108         self.pmap_exec_zfs = {
109             "retcode": 2,
110             "stdout": "",
111             "stderr": "\n".</b></font>join(
112                 [
113                     "missing property argument",
114                     "usage:",
115                     '        get [-crHp] [-d max] [-o "all" | field[,...]]',
116                     "            [-t type[,...]] [-s source[,...]]",
117                     '            &lt;"all" | property[,...]&gt;'
118                     " [filesystem|volume|snapshot|bookmark] ...",
119                     "",
120                     "The following properties are supported:",
121                     "",
122                     "        PROPERTY       EDIT  INHERIT   VALUES",
123                     "",
124                     "        available        NO       NO   &lt;size&gt;",
125                     "        clones           NO       NO   &lt;dataset&gt;[,...]",
126                     "        compressratio    NO       NO   &lt;1.00x or higher if compressed&gt;",
127                     "        creation         NO       NO   &lt;date&gt;",
128                     "        defer_destroy    NO       NO   yes | no",
129                     "        filesystem_count  NO       NO   &lt;count&gt;",
130                     "        logicalreferenced  NO       NO   &lt;size&gt;",
131                     "        logicalused      NO       NO   &lt;size&gt;",
132                     "        mounted          NO       NO   yes | no",
133                     "        origin           NO       NO   &lt;snapshot&gt;",
134                     "        receive_resume_token  NO       NO   &lt;string token&gt;",
135                     "        refcompressratio  NO       NO   &lt;1.00x or higher if compressed&gt;",
136                     "        referenced       NO       NO   &lt;size&gt;",
137                     "        snapshot_count   NO       NO   &lt;count&gt;",
138                     "        type             NO       NO   filesystem | volume | snapshot | bookmark",
139                     "        used             NO       NO   &lt;size&gt;",
140                     "        usedbychildren   NO       NO   &lt;size&gt;",
141                     "        usedbydataset    NO       NO   &lt;size&gt;",
142                     "        usedbyrefreservation  NO       NO   &lt;size&gt;",
143                     "        usedbysnapshots  NO       NO   &lt;size&gt;",
144                     "        userrefs         NO       NO   &lt;count&gt;",
145                     "        written          NO       NO   &lt;size&gt;",
146                     "        aclinherit      YES      YES   discard | noallow | restricted | passthrough | passthrough-x",
147                     "        aclmode         YES      YES   discard | groupmask | passthrough | restricted",
148                     "        atime           YES      YES   on | off",
149                     "        canmount        YES       NO   on | off | noauto",
150                     "        casesensitivity  NO      YES   sensitive | insensitive | mixed",
151                     "        checksum        YES      YES   on | off | fletcher2 | fletcher4 | sha256 | sha512 | skein | edonr",
152                     "        compression     YES      YES   on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
153                     "        copies          YES      YES   1 | 2 | 3",
154                     "        dedup           YES      YES   on | off | verify | sha256[,verify], sha512[,verify], skein[,verify], edonr,verify",
155                     "        devices         YES      YES   on | off",
156                     "        exec            YES      YES   on | off",
157                     "        filesystem_limit YES       NO   &lt;count&gt; | none",
158                     "        logbias         YES      YES   latency | throughput",
159                     "        mlslabel        YES      YES   &lt;sensitivity label&gt;",
160                     "        mountpoint      YES      YES   &lt;path&gt; | legacy | none",
161                     "        nbmand          YES      YES   on | off",
162                     "        normalization    NO      YES   none | formC | formD | formKC | formKD",
163                     "        primarycache    YES      YES   all | none | metadata",
164                     "        quota           YES       NO   &lt;size&gt; | none",
165                     "        readonly        YES      YES   on | off",
166                     "        recordsize      YES      YES   512 to 1M, power of 2",
167                     "        redundant_metadata YES      YES   all | most",
168                     "        refquota        YES       NO   &lt;size&gt; | none",
169                     "        refreservation  YES       NO   &lt;size&gt; | none",
170                     "        reservation     YES       NO   &lt;size&gt; | none",
171                     "        secondarycache  YES      YES   all | none | metadata",
172                     "        setuid          YES      YES   on | off",
173                     "        sharenfs        YES      YES   on | off | share(1M) options",
174                     "        sharesmb        YES      YES   on | off | sharemgr(1M) options",
175                     "        snapdir         YES      YES   hidden | visible",
176                     "        snapshot_limit  YES       NO   &lt;count&gt; | none",
177                     "        sync            YES      YES   standard | always | disabled",
178                     "        utf8only         NO      YES   on | off",
179                     "        version         YES       NO   1 | 2 | 3 | 4 | 5 | current",
180                     "        volblocksize     NO      YES   512 to 128k, power of 2",
181                     "        volsize         YES       NO   &lt;size&gt;",
182                     "        vscan           YES      YES   on | off",
183                     "        xattr           YES      YES   on | off",
184                     "        zoned           YES      YES   on | off",
185                     "        userused@...     NO       NO   &lt;size&gt;",
186                     "        groupused@...    NO       NO   &lt;size&gt;",
187                     "        userquota@...   YES       NO   &lt;size&gt; | none",
188                     "        groupquota@...  YES       NO   &lt;size&gt; | none",
189                     "        written@&lt;snap&gt;   NO       NO   &lt;size&gt;",
190                     "",
191                     "Sizes are specified in bytes with standard units such as K, M, G, etc.",
192                     "",
193                     "User-defined properties can be specified by using a name containing a colon (:).",
194                     "",
195                     "The {user|group}{used|quota}@ properties must be appended with",
196                     "a user or group specifier of one of these forms:",
197                     '    POSIX name      (eg: "matt")',
198                     '    POSIX id        (eg: "126829")',
199                     '    SMB name@domain (eg: "matt@sun")',
200                     '    SMB SID         (eg: "S-1-234-567-89")',
201                 ]
202 <a name="1"></a>            ),
203         }
204         self.pmap_zfs <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>= {
205             "origin": {
206                 "edit": False,
207                 "inherit": False,
208                 "values": "&lt;snapshot&gt;",
209                 "type": "str",
210             },
211             "setuid": {
212                 "edit": True,
213                 "inherit": True,
214                 "values": "on | off",
215                 "type": "bool",
216             },
217             "referenced": {
218                 "edit": False,
219                 "inherit": False,
220                 "values": "&lt;size&gt;",
221                 "type": "size",
222             },
223             "vscan": {
224                 "edit": True,
225                 "inherit": True,
226                 "values": "on | off",
227                 "type": "bool",
228             },
229             "logicalused": {
230                 "edit": False,
231                 "inherit": False,
232                 "values": "&lt;size&gt;",
233                 "type": "size",
234             },
235             "userrefs": {
236                 "edit": False,
237                 "inherit": False,
238                 "values": "&lt;count&gt;",
239                 "type": "numeric",
240             },
241             "primarycache": {
242                 "edit": True,
243                 "inherit": True,
244                 "values": "all | none | metadata",
245                 "type": "str",
246             },
247             "logbias": {
248                 "edit": True,
249                 "inherit": True,
250                 "values": "latency | throughput",
251                 "type": "str",
252             },
253             "creation": {
254                 "edit": False,
255                 "inherit": False,
256                 "values": "&lt;date&gt;",
257                 "type": "str",
258             },
259             "sync": {
260                 "edit": True,
261                 "inherit": True,
262                 "values": "standard | always | disabled",
263                 "type": "str",
264             },
265             "dedup": {
266                 "edit": True,
267                 "inherit": True,
268                 "values": (
269                     "on | off | verify | sha256[,verify], sha512[,verify],"
270                     " skein[,verify], edonr,verify"
271                 ),
272                 "type": "bool",
273             },
274             "sharenfs": {
275                 "edit": True,
276                 "inherit": True,
277                 "values": "on | off | share(1m) options",
278                 "type": "bool",
279             },
280             "receive_resume_token": {
281                 "edit": False,
282                 "inherit": False,
283                 "values": "&lt;string token&gt;",
284                 "type": "str",
285             },
286             "usedbyrefreservation": {
287                 "edit"</b></font>: False,
288                 "inherit": False,
289                 "values": "&lt;size&gt;",
290                 "type": "size",
291             },
292             "sharesmb": {
293                 "edit": True,
294                 "inherit": True,
295                 "values": "on | off | sharemgr(1m) options",
296                 "type": "bool",
297             },
298             "rdonly": {
299                 "edit": True,
300                 "inherit": True,
301                 "values": "on | off",
302                 "type": "bool",
303             },
304             "reservation": {
305                 "edit": True,
306                 "inherit": False,
307                 "values": "&lt;size&gt; | none",
308                 "type": "size",
309             },
310             "reserv": {
311                 "edit": True,
312                 "inherit": False,
313                 "values": "&lt;size&gt; | none",
314                 "type": "size",
315             },
316             "mountpoint": {
317                 "edit": True,
318                 "inherit": True,
319                 "values": "&lt;path&gt; | legacy | none",
320                 "type": "str",
321             },
322             "casesensitivity": {
323                 "edit": False,
324                 "inherit": True,
325                 "values": "sensitive | insensitive | mixed",
326                 "type": "str",
327             },
328             "utf8only": {
329                 "edit": False,
330                 "inherit": True,
331                 "values": "on | off",
332                 "type": "bool",
333             },
334             "usedbysnapshots": {
335                 "edit": False,
336                 "inherit": False,
337                 "values": "&lt;size&gt;",
338                 "type": "size",
339             },
340             "readonly": {
341                 "edit": True,
342                 "inherit": True,
343                 "values": "on | off",
344                 "type": "bool",
345             },
346             "written@": {
347                 "edit": False,
348                 "inherit": False,
349                 "values": "&lt;size&gt;",
350                 "type": "size",
351             },
352             "avail": {
353                 "edit": False,
354                 "inherit": False,
355                 "values": "&lt;size&gt;",
356                 "type": "size",
357             },
358             "recsize": {
359                 "edit": True,
360                 "inherit": True,
361                 "values": "512 to 1m, power of 2",
362                 "type": "str",
363             },
364             "atime": {
365                 "edit": True,
366                 "inherit": True,
367                 "values": "on | off",
368                 "type": "bool",
369             },
370             "compression": {
371                 "edit": True,
372                 "inherit": True,
373                 "values": "on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
374                 "type": "bool",
375             },
376             "snapdir": {
377                 "edit": True,
378                 "inherit": True,
379                 "values": "hidden | visible",
380                 "type": "str",
381             },
382             "aclmode": {
383                 "edit": True,
384                 "inherit": True,
385                 "values": "discard | groupmask | passthrough | restricted",
386                 "type": "str",
387             },
388             "zoned": {
389                 "edit": True,
390                 "inherit": True,
391                 "values": "on | off",
392                 "type": "bool",
393             },
394             "copies": {
395                 "edit": True,
396                 "inherit": True,
397                 "values": "1 | 2 | 3",
398                 "type": "numeric",
399             },
400             "snapshot_limit": {
401                 "edit": True,
402                 "inherit": False,
403                 "values": "&lt;count&gt; | none",
404                 "type": "numeric",
405             },
406             "aclinherit": {
407                 "edit": True,
408                 "inherit": True,
409                 "values": (
410                     "discard | noallow | restricted | passthrough | passthrough-x"
411                 ),
412                 "type": "str",
413             },
414             "compressratio": {
415                 "edit": False,
416                 "inherit": False,
417                 "values": "&lt;1.00x or higher if compressed&gt;",
418                 "type": "str",
419             },
420             "xattr": {
421                 "edit": True,
422                 "inherit": True,
423                 "values": "on | off",
424                 "type": "bool",
425             },
426             "written": {
427                 "edit": False,
428                 "inherit": False,
429                 "values": "&lt;size&gt;",
430                 "type": "size",
431             },
432             "version": {
433                 "edit": True,
434                 "inherit": False,
435                 "values": "1 | 2 | 3 | 4 | 5 | current",
436                 "type": "numeric",
437             },
438             "recordsize": {
439                 "edit": True,
440                 "inherit": True,
441                 "values": "512 to 1m, power of 2",
442                 "type": "str",
443             },
444             "refquota": {
445                 "edit": True,
446                 "inherit": False,
447                 "values": "&lt;size&gt; | none",
448                 "type": "size",
449             },
450             "filesystem_limit": {
451                 "edit": True,
452                 "inherit": False,
453                 "values": "&lt;count&gt; | none",
454                 "type": "numeric",
455             },
456             "lrefer.": {
457                 "edit": False,
458                 "inherit": False,
459                 "values": "&lt;size&gt;",
460                 "type": "size",
461             },
462             "type": {
463                 "edit": False,
464                 "inherit": False,
465                 "values": "filesystem | volume | snapshot | bookmark",
466                 "type": "str",
467             },
468             "secondarycache": {
469                 "edit": True,
470                 "inherit": True,
471                 "values": "all | none | metadata",
472                 "type": "str",
473             },
474             "refer": {
475                 "edit": False,
476                 "inherit": False,
477                 "values": "&lt;size&gt;",
478                 "type": "size",
479             },
480             "available": {
481                 "edit": False,
482                 "inherit": False,
483                 "values": "&lt;size&gt;",
484                 "type": "size",
485             },
486             "used": {
487                 "edit": False,
488                 "inherit": False,
489                 "values": "&lt;size&gt;",
490                 "type": "size",
491             },
492             "exec": {
493                 "edit": True,
494                 "inherit": True,
495                 "values": "on | off",
496                 "type": "bool",
497             },
498             "compress": {
499                 "edit": True,
500                 "inherit": True,
501                 "values": "on | off | lzjb | gzip | gzip-[1-9] | zle | lz4",
502                 "type": "bool",
503             },
504             "volblock": {
505                 "edit": False,
506                 "inherit": True,
507                 "values": "512 to 128k, power of 2",
508                 "type": "str",
509             },
510             "refcompressratio": {
511                 "edit": False,
512                 "inherit": False,
513                 "values": "&lt;1.00x or higher if compressed&gt;",
514                 "type": "str",
515             },
516             "quota": {
517                 "edit": True,
518                 "inherit": False,
519                 "values": "&lt;size&gt; | none",
520                 "type": "size",
521             },
522             "groupquota@": {
523                 "edit": True,
524                 "inherit": False,
525                 "values": "&lt;size&gt; | none",
526                 "type": "size",
527             },
528             "userquota@": {
529                 "edit": True,
530                 "inherit": False,
531                 "values": "&lt;size&gt; | none",
532                 "type": "size",
533             },
534             "snapshot_count": {
535                 "edit": False,
536                 "inherit": False,
537                 "values": "&lt;count&gt;",
538                 "type": "numeric",
539             },
540             "volsize": {
541                 "edit": True,
542                 "inherit": False,
543                 "values": "&lt;size&gt;",
544                 "type": "size",
545             },
546             "clones": {
547                 "edit": False,
548                 "inherit": False,
549                 "values": "&lt;dataset&gt;[,...]",
550                 "type": "str",
551             },
552             "canmount": {
553                 "edit": True,
554                 "inherit": False,
555                 "values": "on | off | noauto",
556                 "type": "bool",
557             },
558             "mounted": {
559                 "edit": False,
560                 "inherit": False,
561                 "values": "yes | no",
562                 "type": "bool_alt",
563             },
564             "groupused@": {
565                 "edit": False,
566                 "inherit": False,
567                 "values": "&lt;size&gt;",
568                 "type": "size",
569             },
570             "normalization": {
571                 "edit": False,
572                 "inherit": True,
573                 "values": "none | formc | formd | formkc | formkd",
574                 "type": "str",
575             },
576             "usedbychildren": {
577                 "edit": False,
578                 "inherit": False,
579                 "values": "&lt;size&gt;",
580                 "type": "size",
581             },
582             "usedbydataset": {
583                 "edit": False,
584                 "inherit": False,
585                 "values": "&lt;size&gt;",
586                 "type": "size",
587             },
588             "mlslabel": {
589                 "edit": True,
590                 "inherit": True,
591                 "values": "&lt;sensitivity label&gt;",
592                 "type": "str",
593             },
594             "refreserv": {
595                 "edit": True,
596                 "inherit": False,
597                 "values": "&lt;size&gt; | none",
598                 "type": "size",
599             },
600             "defer_destroy": {
601                 "edit": False,
602                 "inherit": False,
603                 "values": "yes | no",
604                 "type": "bool_alt",
605             },
606             "volblocksize": {
607                 "edit": False,
608                 "inherit": True,
609                 "values": "512 to 128k, power of 2",
610                 "type": "str",
611             },
612             "lused.": {
613                 "edit": False,
614                 "inherit": False,
615                 "values": "&lt;size&gt;",
616                 "type": "size",
617             },
618             "redundant_metadata": {
619                 "edit": True,
620                 "inherit": True,
621                 "values": "all | most",
622                 "type": "str",
623             },
624             "filesystem_count": {
625                 "edit": False,
626                 "inherit": False,
627                 "values": "&lt;count&gt;",
628                 "type": "numeric",
629             },
630             "devices": {
631                 "edit": True,
632                 "inherit": True,
633                 "values": "on | off",
634                 "type": "bool",
635             },
636             "refreservation": {
637                 "edit": True,
638                 "inherit": False,
639                 "values": "&lt;size&gt; | none",
640                 "type": "size",
641             },
642             "userused@": {
643                 "edit": False,
644                 "inherit": False,
645                 "values": "&lt;size&gt;",
646                 "type": "size",
647             },
648             "logicalreferenced": {
649                 "edit": False,
650                 "inherit": False,
651                 "values": "&lt;size&gt;",
652                 "type": "size",
653             },
654             "checksum": {
655                 "edit": True,
656                 "inherit": True,
657                 "values": (
658                     "on | off | fletcher2 | fletcher4 | sha256 | sha512 | skein | edonr"
659                 ),
660                 "type": "bool",
661             },
662             "nbmand": {
663                 "edit": True,
664                 "inherit": True,
665                 "values": "on | off",
666                 "type": "bool",
667             },
668         }
669     def _from_auto(self, name, value, source="auto"):
670         with patch.object(
671             salt.utils.zfs,
672             "property_data_zpool",
673             MagicMock(return_value=self.pmap_zpool),
674         ), patch.object(
675             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
676         ):
677             return salt.utils.zfs.from_auto(name, value, source)
678     def _from_auto_dict(self, values, source="auto"):
679         with patch.object(
680             salt.utils.zfs,
681             "property_data_zpool",
682             MagicMock(return_value=self.pmap_zpool),
683         ), patch.object(
684             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
685         ):
686             return salt.utils.zfs.from_auto_dict(values, source)
687     def _to_auto(self, name, value, source="auto", convert_to_human=True):
688         with patch.object(
689             salt.utils.zfs,
690             "property_data_zpool",
691             MagicMock(return_value=self.pmap_zpool),
692         ), patch.object(
693             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
694         ):
695             return salt.utils.zfs.to_auto(name, value, source, convert_to_human)
696     def _to_auto_dict(self, values, source="auto", convert_to_human=True):
697         with patch.object(
698             salt.utils.zfs,
699             "property_data_zpool",
700             MagicMock(return_value=self.pmap_zpool),
701         ), patch.object(
702             salt.utils.zfs, "property_data_zfs", MagicMock(return_value=self.pmap_zfs)
703         ):
704             return salt.utils.zfs.to_auto_dict(values, source, convert_to_human)
705     def get_patched_utils(self):
706         return {
707             "zfs.is_supported": MagicMock(return_value=True),
708             "zfs.has_feature_flags": MagicMock(return_value=True),
709             "zfs.property_data_zpool": MagicMock(return_value=self.pmap_zpool),
710             "zfs.property_data_zfs": MagicMock(return_value=self.pmap_zfs),
711             "zfs.zpool_command": MagicMock(return_value="/bin/false"),
712             "zfs.zfs_command": MagicMock(return_value="/bin/false"),
713             "zfs.from_auto_dict": self._from_auto_dict,
714             "zfs.from_auto": self._from_auto,
715             "zfs.to_auto_dict": self._to_auto_dict,
716             "zfs.to_auto": self._to_auto,
717         }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>vmware_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import atexit
2 import errno
3 import logging
4 import ssl
5 import time
6 from http.client import BadStatusLine
7 import salt.exceptions
8 import salt.modules.cmdmod
9 import salt.utils.path
10 import salt.utils.platform
11 import salt.utils.stringutils
12 try:
13     from pyVim.connect import GetSi, SmartConnect, Disconnect, GetStub, SoapStubAdapter
14     from pyVmomi import vim, vmodl, VmomiSupport
15     HAS_PYVMOMI = True
16 except ImportError:
17     HAS_PYVMOMI = False
18 try:
19     from com.vmware.vapi.std.errors_client import Unauthenticated
20     from vmware.vapi.vsphere.client import create_vsphere_client
21     HAS_VSPHERE_SDK = True
22 except ImportError:
23     HAS_VSPHERE_SDK = False
24 try:
25     import gssapi
26     import base64
27     HAS_GSSAPI = True
28 except ImportError:
29     HAS_GSSAPI = False
30 log = logging.getLogger(__name__)
31 def __virtual__():
32     if HAS_PYVMOMI:
33         return True
34     return False, "Missing dependency: The salt.utils.vmware module requires pyVmomi."
35 def esxcli(
36     host, user, pwd, cmd, protocol=None, port=None, esxi_host=None, credstore=None
37 ):
38     esx_cmd = salt.utils.path.which("esxcli")
39     if not esx_cmd:
40         log.error(
41             "Missing dependency: The salt.utils.vmware.esxcli function requires ESXCLI."
42         )
43         return False
44     if port is None:
45         port = 443
46     if protocol is None:
47         protocol = "https"
48     if credstore:
49         esx_cmd += " --credstore '{}'".format(credstore)
50     if not esxi_host:
51         esx_cmd += " -s {} -u {} -p '{}' --protocol={} --portnumber={} {}".format(
52             host, user, pwd, protocol, port, cmd
53         )
54     else:
55         esx_cmd += " -s {} -h {} -u {} -p '{}' --protocol={} --portnumber={} {}".format(
56             host, esxi_host, user, pwd, protocol, port, cmd
57         )
58     ret = salt.modules.cmdmod.run_all(esx_cmd, output_loglevel="quiet")
59     return ret
60 def get_vsphere_client(
61     server, username, password, session=None, verify_ssl=True, ca_bundle=None
62 ):
63     if not session:
64         session = salt.utils.http.session(verify_ssl=verify_ssl, ca_bundle=ca_bundle)
65     client = None
66     try:
67         client = create_vsphere_client(
68             server=server, username=username, password=password, session=session
69         )
70     except Unauthenticated as err:
71         log.trace(err)
72     return client
73 def _get_service_instance(
74     host,
75     username,
76     password,
77     protocol,
78     port,
79     mechanism,
80     principal,
81     domain,
82     verify_ssl=True,
83 ):
84     log.trace("Retrieving new service instance")
85     token = None
86     if mechanism == "userpass":
87         if username is None:
88             raise salt.exceptions.CommandExecutionError(
89                 "Login mechanism userpass was specified but the mandatory "
90                 "parameter 'username' is missing"
91             )
92         if password is None:
93             raise salt.exceptions.CommandExecutionError(
94                 "Login mechanism userpass was specified but the mandatory "
95                 "parameter 'password' is missing"
96             )
97     elif mechanism == "sspi":
98         if principal is not None and domain is not None:
99             try:
100                 token = get_gssapi_token(principal, host, domain)
101             except Exception as exc:  # pylint: disable=broad-except
102                 raise salt.exceptions.VMwareConnectionError(str(exc))
103         else:
104             err_msg = (
105                 "Login mechanism '{}' was specified but the"
106                 " mandatory parameters are missing".format(mechanism)
107             )
108             raise salt.exceptions.CommandExecutionError(err_msg)
109     else:
110         raise salt.exceptions.CommandExecutionError(
111             "Unsupported mechanism: '{}'".format(mechanism)
112         )
113     log.trace(
114         "Connecting using the '%s' mechanism, with username '%s'",
115         mechanism,
116         username,
117     )
118     default_msg = (
119         "Could not connect to host '{}'. "
120         "Please check the debug log for more information.".format(host)
121     )
122     try:
123         if verify_ssl:
124             service_instance = SmartConnect(
125                 host=host,
126                 user=username,
127                 pwd=password,
128                 protocol=protocol,
129                 port=port,
130                 b64token=token,
131                 mechanism=mechanism,
132             )
133     except TypeError as exc:
134         if "unexpected keyword argument" in exc.message:
135             log.error(
136                 "Initial connect to the VMware endpoint failed with %s", exc.message
137             )
138             log.error(
139                 "This may mean that a version of PyVmomi EARLIER than 6.0.0.2016.6 is"
140                 " installed."
141             )
142             log.error("We recommend updating to that version or later.")
143             raise
144     except Exception as exc:  # pylint: disable=broad-except
145         if (
146             isinstance(exc, vim.fault.HostConnectFault)
147             and "[SSL: CERTIFICATE_VERIFY_FAILED]" in exc.msg
148         ) or "[SSL: CERTIFICATE_VERIFY_FAILED]" in str(exc):
149             err_msg = (
150                 "Could not verify the SSL certificate. You can use "
151                 "verify_ssl: False if you do not want to verify the "
152                 "SSL certificate. This is not recommended as it is "
153                 "considered insecure."
154             )
155         else:
156             log.exception(exc)
157             err_msg = exc.msg if hasattr(exc, "msg") else default_msg
158         raise salt.exceptions.VMwareConnectionError(err_msg)
159     if not verify_ssl:
160         try:
161             service_instance = SmartConnect(
162                 host=host,
163                 user=username,
164                 pwd=password,
165                 protocol=protocol,
166                 port=port,
167                 sslContext=ssl._create_unverified_context(),
168                 b64token=token,
169                 mechanism=mechanism,
170             )
171         except Exception as exc:  # pylint: disable=broad-except
172             if "certificate verify failed" in str(exc):
173                 context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
174                 context.verify_mode = ssl.CERT_NONE
175                 try:
176                     service_instance = SmartConnect(
177                         host=host,
178                         user=username,
179                         pwd=password,
180                         protocol=protocol,
181                         port=port,
182                         sslContext=context,
183                         b64token=token,
184                         mechanism=mechanism,
185                     )
186                 except Exception as exc:  # pylint: disable=broad-except
187                     log.exception(exc)
188                     err_msg = exc.msg if hasattr(exc, "msg") else str(exc)
189                     raise salt.exceptions.VMwareConnectionError(
190                         "Could not connect to host '{}': {}".format(host, err_msg)
191                     )
192             else:
193                 err_msg = exc.msg if hasattr(exc, "msg") else default_msg
194                 log.trace(exc)
195                 raise salt.exceptions.VMwareConnectionError(err_msg)
196     atexit.register(Disconnect, service_instance)
197     return service_instance
198 def get_customizationspec_ref(si, customization_spec_name):
199     customization_spec_name = si.content.customizationSpecManager.GetCustomizationSpec(
200         name=customization_spec_name
201     )
202     return customization_spec_name
203 def get_mor_using_container_view(si, obj_type, obj_name):
204     inventory = get_inventory(si)
205     container = inventory.viewManager.CreateContainerView(
206         inventory.rootFolder, [obj_type], True
207     )
208     for item in container.view:
209         if item.name == obj_name:
210             return item
211     return None
212 def get_service_instance(
213     host,
214     username=None,
215     password=None,
216     protocol=None,
217     port=None,
218     mechanism="userpass",
219     principal=None,
220     domain=None,
221     verify_ssl=True,
222 ):
223     if protocol is None:
224         protocol = "https"
225     if port is None:
226         port = 443
227     service_instance = GetSi()
228     if service_instance:
229         stub = GetStub()
230         if salt.utils.platform.is_proxy() or (
231             hasattr(stub, "host") and stub.host != ":".join([host, str(port)])
232         ):
233             Disconnect(service_instance)
234             service_instance = None
235     if not service_instance:
236         service_instance = _get_service_instance(
237             host,
238             username,
239             password,
240             protocol,
241             port,
242             mechanism,
243             principal,
244             domain,
245             verify_ssl=verify_ssl,
246         )
247     log.trace("Checking connection is still authenticated")
248     try:
249         service_instance.CurrentTime()
250     except vim.fault.NotAuthenticated:
251         log.trace("Session no longer authenticating. Reconnecting")
252         Disconnect(service_instance)
253         service_instance = _get_service_instance(
254             host,
255             username,
256             password,
257             protocol,
258             port,
259             mechanism,
260             principal,
261             domain,
262             verify_ssl=verify_ssl,
263         )
264     except vim.fault.NoPermission as exc:
265         log.exception(exc)
266         raise salt.exceptions.VMwareApiError(
267             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
268         )
269     except vim.fault.VimFault as exc:
270         log.exception(exc)
271         raise salt.exceptions.VMwareApiError(exc.msg)
272     except vmodl.RuntimeFault as exc:
273         log.exception(exc)
274         raise salt.exceptions.VMwareRuntimeError(exc.msg)
275     return service_instance
276 def get_new_service_instance_stub(service_instance, path, ns=None, version=None):
277     context = ssl.create_default_context()
278     context.check_hostname = False
279     context.verify_mode = ssl.CERT_NONE
280     stub = service_instance._stub
281     hostname = stub.host.split(":")[0]
282     session_cookie = stub.cookie.split('"')[1]
283     VmomiSupport.GetRequestContext()["vcSessionCookie"] = session_cookie
284     new_stub = SoapStubAdapter(
285         host=hostname, ns=ns, path=path, version=version, poolSize=0, sslContext=context
286     )
287     new_stub.cookie = stub.cookie
288     return new_stub
289 def get_service_instance_from_managed_object(mo_ref, name="&lt;unnamed&gt;"):
290     """
291     Retrieves the service instance from a managed object.
292     me_ref
293         Reference to a managed object (of type vim.ManagedEntity).
294     name
295         Name of managed object. This field is optional.
296     Function that disconnects from the vCenter server or ESXi host
297     service_instance
298         The Service Instance from which to obtain managed object references.
299     Function that returns True if the connection is made to a vCenter Server and
300     False if the connection is made to an ESXi host
301     service_instance
302         The Service Instance from which to obtain managed object references.
303     Returns information of the vCenter or ESXi host
304     service_instance
305         The Service Instance from which to obtain managed object references.
306     Return a reference to a Distributed Virtual Switch object.
307     :param service_instance: PyVmomi service instance
308     :param dvs_name: Name of DVS to return
309     :return: A PyVmomi DVS object
310     Helper function that returns a list of PhysicalNics and their information.
311     Helper function that returns a list of VirtualNics and their information.
312     Helper function that returns a list of Virtual NicManagers
313     and their information.
314     Return a portgroup object corresponding to the portgroup name on the dvs
315     :param dvs: DVS object
316     :param portgroup_name: Name of portgroup to return
317     :return: Portgroup object
318     Return a portgroup object corresponding to the portgroup name on the dvs
319     :param dvs: DVS object
320     :param portgroup_name: Name of portgroup to return
321     :return: Portgroup object
322     Get the gssapi token for Kerberos connection
323     principal
324        The service principal
325     host
326        Host url where we would like to authenticate
327     domain
328        Kerberos user domain
329     Return hardware info for standard minion grains if the service_instance is a HostAgent type
330     service_instance
331         The service instance object to get hardware info for
332     .. versionadded:: 2016.11.0
333             for _vnic in view<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.view[0].configManager.networkSystem.networkConfig.vnic:
334                 hw_grain_data["ip_interfaces"][_vnic.device] = []
335                 hw_grain_data["ip4_interfaces"][</b></font>_vnic.device] = []
336                 hw_grain_data["ip6_interfaces"][_vnic.device] = []
337                 hw_grain_data["ip_interfaces"][_vnic.device].append(
338                     _vnic.spec.ip.ipAddress
339                 )
340                 hw_grain_data["ip4_interfaces"][_vnic.device].append(
341                     _vnic.spec.ip.ipAddress
342                 )
343                 if _vnic.spec.ip.ipV6Config:
344                     hw_grain_data["ip6_interfaces"][_vnic.device].append(
345                         _vnic.spec.ip.ipV6Config.ipV6Address
346                     )
347                 hw_grain_data["hwaddr_interfaces"][_vnic.device] = _vnic.spec.mac
348             hw_grain_data["host"] = view.view[
349                 0
350             ].configManager.networkSystem.dnsConfig.hostName
351             hw_grain_data["domain"] = view.view[
352 <a name="0"></a>                0
353             ].configManager.networkSystem.dnsConfig.domainName
354             hw_grain_data["fqdn"] = "{}{}{}".format(
355                 view<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>.view[0].configManager.networkSystem.dnsConfig.hostName,
356                 (
357                     "."
358                     if view.view[0].configManager.networkSystem.dnsConfig.domainName
359                     else ""
360                 ),
361                 view.view[0].configManager.networkSystem.dnsConfig.</b></font>domainName,
362             )
363             for _pnic in view.view[0].configManager.networkSystem.networkInfo.pnic:
364                 hw_grain_data["hwaddr_interfaces"][_pnic.device] = _pnic.mac
365             hw_grain_data["timezone"] = view.view[
366                 0
367             ].configManager.dateTimeSystem.dateTimeInfo.timeZone.name
368         view = None
369     return hw_grain_data
370 def get_inventory(service_instance):
371     return service_instance.RetrieveContent()
372 def get_root_folder(service_instance):
373     try:
374         log.trace("Retrieving root folder")
375         return service_instance.RetrieveContent().rootFolder
376     except vim.fault.NoPermission as exc:
377         log.exception(exc)
378         raise salt.exceptions.VMwareApiError(
379             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
380         )
381     except vim.fault.VimFault as exc:
382         log.exception(exc)
383         raise salt.exceptions.VMwareApiError(exc.msg)
384     except vmodl.RuntimeFault as exc:
385         log.exception(exc)
386         raise salt.exceptions.VMwareRuntimeError(exc.msg)
387 def get_content(
388     service_instance,
389     obj_type,
390     property_list=None,
391     container_ref=None,
392     traversal_spec=None,
393     local_properties=False,
394 ):
395     if not container_ref:
396         container_ref = get_root_folder(service_instance)
397     obj_ref = container_ref
398     local_traversal_spec = False
399     if not traversal_spec and not local_properties:
400         local_traversal_spec = True
401         try:
402             obj_ref = service_instance.content.viewManager.CreateContainerView(
403                 container_ref, [obj_type], True
404             )
405         except vim.fault.NoPermission as exc:
406             log.exception(exc)
407             raise salt.exceptions.VMwareApiError(
408                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
409             )
410         except vim.fault.VimFault as exc:
411             log.exception(exc)
412             raise salt.exceptions.VMwareApiError(exc.msg)
413         except vmodl.RuntimeFault as exc:
414             log.exception(exc)
415             raise salt.exceptions.VMwareRuntimeError(exc.msg)
416         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
417             name="traverseEntities",
418             path="view",
419             skip=False,
420             type=vim.view.ContainerView,
421         )
422     property_spec = vmodl.query.PropertyCollector.PropertySpec(
423         type=obj_type, all=True if not property_list else False, pathSet=property_list
424     )
425     obj_spec = vmodl.query.PropertyCollector.ObjectSpec(
426         obj=obj_ref,
427         skip=True if not local_properties else False,
428         selectSet=[traversal_spec] if not local_properties else None,
429     )
430     filter_spec = vmodl.query.PropertyCollector.FilterSpec(
431         objectSet=[obj_spec],
432         propSet=[property_spec],
433         reportMissingObjectsInResults=False,
434     )
435     try:
436         content = service_instance.content.propertyCollector.RetrieveContents(
437             [filter_spec]
438         )
439     except vim.fault.NoPermission as exc:
440         log.exception(exc)
441         raise salt.exceptions.VMwareApiError(
442             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
443         )
444     except vim.fault.VimFault as exc:
445         log.exception(exc)
446         raise salt.exceptions.VMwareApiError(exc.msg)
447     except vmodl.RuntimeFault as exc:
448         log.exception(exc)
449         raise salt.exceptions.VMwareRuntimeError(exc.msg)
450     if local_traversal_spec:
451         try:
452             obj_ref.Destroy()
453         except vim.fault.NoPermission as exc:
454             log.exception(exc)
455             raise salt.exceptions.VMwareApiError(
456                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
457             )
458         except vim.fault.VimFault as exc:
459             log.exception(exc)
460             raise salt.exceptions.VMwareApiError(exc.msg)
461         except vmodl.RuntimeFault as exc:
462             log.exception(exc)
463             raise salt.exceptions.VMwareRuntimeError(exc.msg)
464     return content
465 def get_mor_by_property(
466     service_instance,
467     object_type,
468     property_value,
469     property_name="name",
470     container_ref=None,
471 ):
472     object_list = get_mors_with_properties(
473         service_instance,
474         object_type,
475         property_list=[property_name],
476         container_ref=container_ref,
477     )
478     for obj in object_list:
479         obj_id = str(obj.get("object", "")).strip("'\"")
480         if obj[property_name] == property_value or property_value == obj_id:
481             return obj["object"]
482     return None
483 def get_mors_with_properties(
484     service_instance,
485     object_type,
486     property_list=None,
487     container_ref=None,
488     traversal_spec=None,
489     local_properties=False,
490 ):
491     content_args = [service_instance, object_type]
492     content_kwargs = {
493         "property_list": property_list,
494         "container_ref": container_ref,
495         "traversal_spec": traversal_spec,
496         "local_properties": local_properties,
497     }
498     try:
499         content = get_content(*content_args, **content_kwargs)
500     except BadStatusLine:
501         content = get_content(*content_args, **content_kwargs)
502     except OSError as exc:
503         if exc.errno != errno.EPIPE:
504             raise
505         content = get_content(*content_args, **content_kwargs)
506     object_list = []
507     for obj in content:
508         properties = {}
509         for prop in obj.propSet:
510             properties[prop.name] = prop.val
511         properties["object"] = obj.obj
512         object_list.append(properties)
513     log.trace("Retrieved %s objects", len(object_list))
514     return object_list
515 def get_properties_of_managed_object(mo_ref, properties):
516     service_instance = get_service_instance_from_managed_object(mo_ref)
517     log.trace("Retrieving name of %s", type(mo_ref).__name__)
518     try:
519         items = get_mors_with_properties(
520             service_instance,
521             type(mo_ref),
522             container_ref=mo_ref,
523             property_list=["name"],
524             local_properties=True,
525         )
526         mo_name = items[0]["name"]
527     except vmodl.query.InvalidProperty:
528         mo_name = "&lt;unnamed&gt;"
529     log.trace(
530         "Retrieving properties '%s' of %s '%s'",
531         properties,
532         type(mo_ref).__name__,
533         mo_name,
534     )
535     items = get_mors_with_properties(
536         service_instance,
537         type(mo_ref),
538         container_ref=mo_ref,
539         property_list=properties,
540         local_properties=True,
541     )
542     if not items:
543         raise salt.exceptions.VMwareApiError(
544             "Properties of managed object '{}' weren't retrieved".format(mo_name)
545         )
546     return items[0]
547 def get_managed_object_name(mo_ref):
548     props = get_properties_of_managed_object(mo_ref, ["name"])
549     return props.get("name")
550 def get_network_adapter_type(adapter_type):
551     if adapter_type == "vmxnet":
552         return vim.vm.device.VirtualVmxnet()
553     elif adapter_type == "vmxnet2":
554         return vim.vm.device.VirtualVmxnet2()
555     elif adapter_type == "vmxnet3":
556         return vim.vm.device.VirtualVmxnet3()
557     elif adapter_type == "e1000":
558         return vim.vm.device.VirtualE1000()
559     elif adapter_type == "e1000e":
560         return vim.vm.device.VirtualE1000e()
561     raise ValueError("An unknown network adapter object type name.")
562 def get_network_adapter_object_type(adapter_object):
563     if isinstance(adapter_object, vim.vm.device.VirtualVmxnet2):
564         return "vmxnet2"
565     if isinstance(adapter_object, vim.vm.device.VirtualVmxnet3):
566         return "vmxnet3"
567     if isinstance(adapter_object, vim.vm.device.VirtualVmxnet):
568         return "vmxnet"
569     if isinstance(adapter_object, vim.vm.device.VirtualE1000e):
570         return "e1000e"
571     if isinstance(adapter_object, vim.vm.device.VirtualE1000):
572         return "e1000"
573     raise ValueError("An unknown network adapter object type.")
574 def get_dvss(dc_ref, dvs_names=None, get_all_dvss=False):
575     dc_name = get_managed_object_name(dc_ref)
576     log.trace(
577         "Retrieving DVSs in datacenter '%s', dvs_names='%s', get_all_dvss=%s",
578         dc_name,
579         ",".join(dvs_names) if dvs_names else None,
580         get_all_dvss,
581     )
582     properties = ["name"]
583     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
584         path="networkFolder",
585         skip=True,
586         type=vim.Datacenter,
587         selectSet=[
588             vmodl.query.PropertyCollector.TraversalSpec(
589                 path="childEntity", skip=False, type=vim.Folder
590             )
591         ],
592     )
593     service_instance = get_service_instance_from_managed_object(dc_ref)
594     items = [
595         i["object"]
596         for i in get_mors_with_properties(
597             service_instance,
598             vim.DistributedVirtualSwitch,
599             container_ref=dc_ref,
600             property_list=properties,
601             traversal_spec=traversal_spec,
602         )
603         if get_all_dvss or (dvs_names and i["name"] in dvs_names)
604     ]
605     return items
606 def get_network_folder(dc_ref):
607     dc_name = get_managed_object_name(dc_ref)
608     log.trace("Retrieving network folder in datacenter '%s'", dc_name)
609     service_instance = get_service_instance_from_managed_object(dc_ref)
610     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
611         path="networkFolder", skip=False, type=vim.Datacenter
612     )
613     entries = get_mors_with_properties(
614         service_instance,
615         vim.Folder,
616         container_ref=dc_ref,
617         property_list=["name"],
618         traversal_spec=traversal_spec,
619     )
620     if not entries:
621         raise salt.exceptions.VMwareObjectRetrievalError(
622             "Network folder in datacenter '{}' wasn't retrieved".format(dc_name)
623         )
624     return entries[0]["object"]
625 def create_dvs(dc_ref, dvs_name, dvs_create_spec=None):
626     dc_name = get_managed_object_name(dc_ref)
627     log.trace("Creating DVS '%s' in datacenter '%s'", dvs_name, dc_name)
628     if not dvs_create_spec:
629         dvs_create_spec = vim.DVSCreateSpec()
630     if not dvs_create_spec.configSpec:
631         dvs_create_spec.configSpec = vim.VMwareDVSConfigSpec()
632         dvs_create_spec.configSpec.name = dvs_name
633     netw_folder_ref = get_network_folder(dc_ref)
634     try:
635         task = netw_folder_ref.CreateDVS_Task(dvs_create_spec)
636     except vim.fault.NoPermission as exc:
637         log.exception(exc)
638         raise salt.exceptions.VMwareApiError(
639             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
640         )
641     except vim.fault.VimFault as exc:
642         log.exception(exc)
643         raise salt.exceptions.VMwareApiError(exc.msg)
644     except vmodl.RuntimeFault as exc:
645         log.exception(exc)
646         raise salt.exceptions.VMwareRuntimeError(exc.msg)
647     wait_for_task(task, dvs_name, str(task.__class__))
648 def update_dvs(dvs_ref, dvs_config_spec):
649     dvs_name = get_managed_object_name(dvs_ref)
650     log.trace("Updating dvs '%s'", dvs_name)
651     try:
652         task = dvs_ref.ReconfigureDvs_Task(dvs_config_spec)
653     except vim.fault.NoPermission as exc:
654         log.exception(exc)
655         raise salt.exceptions.VMwareApiError(
656             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
657         )
658     except vim.fault.VimFault as exc:
659         log.exception(exc)
660         raise salt.exceptions.VMwareApiError(exc.msg)
661     except vmodl.RuntimeFault as exc:
662         log.exception(exc)
663         raise salt.exceptions.VMwareRuntimeError(exc.msg)
664     wait_for_task(task, dvs_name, str(task.__class__))
665 def set_dvs_network_resource_management_enabled(dvs_ref, enabled):
666     dvs_name = get_managed_object_name(dvs_ref)
667     log.trace(
668         "Setting network resource management enable to %s on dvs '%s'",
669         enabled,
670         dvs_name,
671     )
672     try:
673         dvs_ref.EnableNetworkResourceManagement(enable=enabled)
674     except vim.fault.NoPermission as exc:
675         log.exception(exc)
676         raise salt.exceptions.VMwareApiError(
677             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
678         )
679     except vim.fault.VimFault as exc:
680         log.exception(exc)
681         raise salt.exceptions.VMwareApiError(exc.msg)
682     except vmodl.RuntimeFault as exc:
683         log.exception(exc)
684         raise salt.exceptions.VMwareRuntimeError(exc.msg)
685 def get_dvportgroups(parent_ref, portgroup_names=None, get_all_portgroups=False):
686     if not isinstance(parent_ref, (vim.Datacenter, vim.DistributedVirtualSwitch)):
687         raise salt.exceptions.ArgumentValueError(
688             "Parent has to be either a datacenter, or a distributed virtual switch"
689         )
690     parent_name = get_managed_object_name(parent_ref)
691     log.trace(
692         "Retrieving portgroup in %s '%s', portgroups_names='%s', get_all_portgroups=%s",
693         type(parent_ref).__name__,
694         parent_name,
695         ",".join(portgroup_names) if portgroup_names else None,
696         get_all_portgroups,
697     )
698     properties = ["name"]
699     if isinstance(parent_ref, vim.Datacenter):
700         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
701             path="networkFolder",
702             skip=True,
703             type=vim.Datacenter,
704             selectSet=[
705                 vmodl.query.PropertyCollector.TraversalSpec(
706                     path="childEntity", skip=False, type=vim.Folder
707                 )
708             ],
709         )
710     else:  # parent is distributed virtual switch
711         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
712             path="portgroup", skip=False, type=vim.DistributedVirtualSwitch
713         )
714     service_instance = get_service_instance_from_managed_object(parent_ref)
715     items = [
716         i["object"]
717         for i in get_mors_with_properties(
718             service_instance,
719             vim.DistributedVirtualPortgroup,
720             container_ref=parent_ref,
721             property_list=properties,
722             traversal_spec=traversal_spec,
723         )
724         if get_all_portgroups or (portgroup_names and i["name"] in portgroup_names)
725     ]
726     return items
727 def get_uplink_dvportgroup(dvs_ref):
728     dvs_name = get_managed_object_name(dvs_ref)
729     log.trace("Retrieving uplink portgroup of dvs '%s'", dvs_name)
730     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
731         path="portgroup", skip=False, type=vim.DistributedVirtualSwitch
732     )
733     service_instance = get_service_instance_from_managed_object(dvs_ref)
734     items = [
735         entry["object"]
736         for entry in get_mors_with_properties(
737             service_instance,
738             vim.DistributedVirtualPortgroup,
739             container_ref=dvs_ref,
740             property_list=["tag"],
741             traversal_spec=traversal_spec,
742         )
743         if entry["tag"] and [t for t in entry["tag"] if t.key == "SYSTEM/DVS.UPLINKPG"]
744     ]
745     if not items:
746         raise salt.exceptions.VMwareObjectRetrievalError(
747             "Uplink portgroup of DVS '{}' wasn't found".format(dvs_name)
748         )
749     return items[0]
750 def create_dvportgroup(dvs_ref, spec):
751     dvs_name = get_managed_object_name(dvs_ref)
752     log.trace("Adding portgroup %s to dvs '%s'", spec.name, dvs_name)
753     log.trace("spec = %s", spec)
754     try:
755         task = dvs_ref.CreateDVPortgroup_Task(spec)
756     except vim.fault.NoPermission as exc:
757         log.exception(exc)
758         raise salt.exceptions.VMwareApiError(
759             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
760         )
761     except vim.fault.VimFault as exc:
762         log.exception(exc)
763         raise salt.exceptions.VMwareApiError(exc.msg)
764     except vmodl.RuntimeFault as exc:
765         log.exception(exc)
766         raise salt.exceptions.VMwareRuntimeError(exc.msg)
767     wait_for_task(task, dvs_name, str(task.__class__))
768 def update_dvportgroup(portgroup_ref, spec):
769     pg_name = get_managed_object_name(portgroup_ref)
770     log.trace("Updating portgrouo %s", pg_name)
771     try:
772         task = portgroup_ref.ReconfigureDVPortgroup_Task(spec)
773     except vim.fault.NoPermission as exc:
774         log.exception(exc)
775         raise salt.exceptions.VMwareApiError(
776             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
777         )
778     except vim.fault.VimFault as exc:
779         log.exception(exc)
780         raise salt.exceptions.VMwareApiError(exc.msg)
781     except vmodl.RuntimeFault as exc:
782         log.exception(exc)
783         raise salt.exceptions.VMwareRuntimeError(exc.msg)
784     wait_for_task(task, pg_name, str(task.__class__))
785 def remove_dvportgroup(portgroup_ref):
786     pg_name = get_managed_object_name(portgroup_ref)
787     log.trace("Removing portgroup %s", pg_name)
788     try:
789         task = portgroup_ref.Destroy_Task()
790     except vim.fault.NoPermission as exc:
791         log.exception(exc)
792         raise salt.exceptions.VMwareApiError(
793             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
794         )
795     except vim.fault.VimFault as exc:
796         log.exception(exc)
797         raise salt.exceptions.VMwareApiError(exc.msg)
798     except vmodl.RuntimeFault as exc:
799         log.exception(exc)
800         raise salt.exceptions.VMwareRuntimeError(exc.msg)
801     wait_for_task(task, pg_name, str(task.__class__))
802 def get_networks(parent_ref, network_names=None, get_all_networks=False):
803     if not isinstance(parent_ref, vim.Datacenter):
804         raise salt.exceptions.ArgumentValueError("Parent has to be a datacenter.")
805     parent_name = get_managed_object_name(parent_ref)
806     log.trace(
807         "Retrieving network from %s '%s', network_names='%s', get_all_networks=%s",
808         type(parent_ref).__name__,
809         parent_name,
810         ",".join(network_names) if network_names else None,
811         get_all_networks,
812     )
813     properties = ["name"]
814     service_instance = get_service_instance_from_managed_object(parent_ref)
815     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
816         path="networkFolder",
817         skip=True,
818         type=vim.Datacenter,
819         selectSet=[
820             vmodl.query.PropertyCollector.TraversalSpec(
821                 path="childEntity", skip=False, type=vim.Folder
822             )
823         ],
824     )
825     items = [
826         i["object"]
827         for i in get_mors_with_properties(
828             service_instance,
829             vim.Network,
830             container_ref=parent_ref,
831             property_list=properties,
832             traversal_spec=traversal_spec,
833         )
834         if get_all_networks or (network_names and i["name"] in network_names)
835     ]
836     return items
837 def list_objects(service_instance, vim_object, properties=None):
838     if properties is None:
839         properties = ["name"]
840     items = []
841     item_list = get_mors_with_properties(service_instance, vim_object, properties)
842     for item in item_list:
843         items.append(item["name"])
844     return items
845 def get_license_manager(service_instance):
846     log.debug("Retrieving license manager")
847     try:
848         lic_manager = service_instance.content.licenseManager
849     except vim.fault.NoPermission as exc:
850         log.exception(exc)
851         raise salt.exceptions.VMwareApiError(
852             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
853         )
854     except vim.fault.VimFault as exc:
855         log.exception(exc)
856         raise salt.exceptions.VMwareApiError(exc.msg)
857     except vmodl.RuntimeFault as exc:
858         log.exception(exc)
859         raise salt.exceptions.VMwareRuntimeError(exc.msg)
860     return lic_manager
861 def get_license_assignment_manager(service_instance):
862     log.debug("Retrieving license assignment manager")
863     try:
864         lic_assignment_manager = (
865             service_instance.content.licenseManager.licenseAssignmentManager
866         )
867     except vim.fault.NoPermission as exc:
868         log.exception(exc)
869         raise salt.exceptions.VMwareApiError(
870             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
871         )
872     except vim.fault.VimFault as exc:
873         log.exception(exc)
874         raise salt.exceptions.VMwareApiError(exc.msg)
875     except vmodl.RuntimeFault as exc:
876         log.exception(exc)
877         raise salt.exceptions.VMwareRuntimeError(exc.msg)
878     if not lic_assignment_manager:
879         raise salt.exceptions.VMwareObjectRetrievalError(
880             "License assignment manager was not retrieved"
881         )
882     return lic_assignment_manager
883 def get_licenses(service_instance, license_manager=None):
884     if not license_manager:
885         license_manager = get_license_manager(service_instance)
886     log.debug("Retrieving licenses")
887     try:
888         return license_manager.licenses
889     except vim.fault.NoPermission as exc:
890         log.exception(exc)
891         raise salt.exceptions.VMwareApiError(
892             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
893         )
894     except vim.fault.VimFault as exc:
895         log.exception(exc)
896         raise salt.exceptions.VMwareApiError(exc.msg)
897     except vmodl.RuntimeFault as exc:
898         log.exception(exc)
899         raise salt.exceptions.VMwareRuntimeError(exc.msg)
900 def add_license(service_instance, key, description, license_manager=None):
901     if not license_manager:
902         license_manager = get_license_manager(service_instance)
903     label = vim.KeyValue()
904     label.key = "VpxClientLicenseLabel"
905     label.value = description
906     log.debug("Adding license '%s'", description)
907     try:
908         vmware_license = license_manager.AddLicense(key, [label])
909     except vim.fault.NoPermission as exc:
910         log.exception(exc)
911         raise salt.exceptions.VMwareApiError(
912             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
913         )
914     except vim.fault.VimFault as exc:
915         log.exception(exc)
916         raise salt.exceptions.VMwareApiError(exc.msg)
917     except vmodl.RuntimeFault as exc:
918         log.exception(exc)
919         raise salt.exceptions.VMwareRuntimeError(exc.msg)
920     return vmware_license
921 def get_assigned_licenses(
922     service_instance, entity_ref=None, entity_name=None, license_assignment_manager=None
923 ):
924     if not license_assignment_manager:
925         license_assignment_manager = get_license_assignment_manager(service_instance)
926     if not entity_name:
927         raise salt.exceptions.ArgumentValueError("No entity_name passed")
928     entity_id = None
929     entity_type = "moid"
930     check_name = False
931     if not entity_ref:
932         if entity_name:
933             check_name = True
934         entity_type = "uuid"
935         try:
936             entity_id = service_instance.content.about.instanceUuid
937         except vim.fault.NoPermission as exc:
938             log.exception(exc)
939             raise salt.exceptions.VMwareApiError(
940                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
941             )
942         except vim.fault.VimFault as exc:
943             log.exception(exc)
944             raise salt.exceptions.VMwareApiError(exc.msg)
945         except vmodl.RuntimeFault as exc:
946             log.exception(exc)
947             raise salt.exceptions.VMwareRuntimeError(exc.msg)
948     else:
949         entity_id = entity_ref._moId
950     log.trace("Retrieving licenses assigned to '%s'", entity_name)
951     try:
952         assignments = license_assignment_manager.QueryAssignedLicenses(entity_id)
953     except vim.fault.NoPermission as exc:
954         log.exception(exc)
955         raise salt.exceptions.VMwareApiError(
956             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
957         )
958     except vim.fault.VimFault as exc:
959         log.exception(exc)
960         raise salt.exceptions.VMwareApiError(exc.msg)
961     except vmodl.RuntimeFault as exc:
962         log.exception(exc)
963         raise salt.exceptions.VMwareRuntimeError(exc.msg)
964     if entity_type == "uuid" and len(assignments) &gt; 1:
965         log.trace("Unexpectectedly retrieved more than one VCenter license assignment.")
966         raise salt.exceptions.VMwareObjectRetrievalError(
967             "Unexpected return. Expect only a single assignment"
968         )
969     if check_name:
970         if entity_name != assignments[0].entityDisplayName:
971             log.trace(
972                 "Getting license info for wrong vcenter: %s != %s",
973                 entity_name,
974                 assignments[0].entityDisplayName,
975             )
976             raise salt.exceptions.VMwareObjectRetrievalError(
977                 "Got license assignment info for a different vcenter"
978             )
979     return [a.assignedLicense for a in assignments]
980 def assign_license(
981     service_instance,
982     license_key,
983     license_name,
984     entity_ref=None,
985     entity_name=None,
986     license_assignment_manager=None,
987 ):
988     if not license_assignment_manager:
989         license_assignment_manager = get_license_assignment_manager(service_instance)
990     entity_id = None
991     if not entity_ref:
992         try:
993             entity_id = service_instance.content.about.instanceUuid
994         except vim.fault.NoPermission as exc:
995             log.exception(exc)
996             raise salt.exceptions.VMwareApiError(
997                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
998             )
999         except vim.fault.VimFault as exc:
1000             raise salt.exceptions.VMwareApiError(exc.msg)
1001         except vmodl.RuntimeFault as exc:
1002             raise salt.exceptions.VMwareRuntimeError(exc.msg)
1003         if not entity_name:
1004             entity_name = "vCenter"
1005     else:
1006         entity_id = entity_ref._moId
1007     log.trace("Assigning license to '%s'", entity_name)
1008     try:
1009         vmware_license = license_assignment_manager.UpdateAssignedLicense(
1010             entity_id, license_key, license_name
1011         )
1012     except vim.fault.NoPermission as exc:
1013         log.exception(exc)
1014         raise salt.exceptions.VMwareApiError(
1015             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1016         )
1017     except vim.fault.VimFault as exc:
1018         log.exception(exc)
1019         raise salt.exceptions.VMwareApiError(exc.msg)
1020     except vmodl.RuntimeFault as exc:
1021         log.exception(exc)
1022         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1023     return vmware_license
1024 def list_datacenters(service_instance):
1025     return list_objects(service_instance, vim.Datacenter)
1026 def get_datacenters(service_instance, datacenter_names=None, get_all_datacenters=False):
1027     items = [
1028         i["object"]
1029         for i in get_mors_with_properties(
1030             service_instance, vim.Datacenter, property_list=["name"]
1031         )
1032         if get_all_datacenters or (datacenter_names and i["name"] in datacenter_names)
1033     ]
1034     return items
1035 def get_datacenter(service_instance, datacenter_name):
1036     items = get_datacenters(service_instance, datacenter_names=[datacenter_name])
1037     if not items:
1038         raise salt.exceptions.VMwareObjectRetrievalError(
1039             "Datacenter '{}' was not found".format(datacenter_name)
1040         )
1041     return items[0]
1042 def create_datacenter(service_instance, datacenter_name):
1043     root_folder = get_root_folder(service_instance)
1044     log.trace("Creating datacenter '%s'", datacenter_name)
1045     try:
1046         dc_obj = root_folder.CreateDatacenter(datacenter_name)
1047     except vim.fault.NoPermission as exc:
1048         log.exception(exc)
1049         raise salt.exceptions.VMwareApiError(
1050             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1051         )
1052     except vim.fault.VimFault as exc:
1053         log.exception(exc)
1054         raise salt.exceptions.VMwareApiError(exc.msg)
1055     except vmodl.RuntimeFault as exc:
1056         log.exception(exc)
1057         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1058     return dc_obj
1059 def get_cluster(dc_ref, cluster):
1060     dc_name = get_managed_object_name(dc_ref)
1061     log.trace("Retrieving cluster '%s' from datacenter '%s'", cluster, dc_name)
1062     si = get_service_instance_from_managed_object(dc_ref, name=dc_name)
1063     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1064         path="hostFolder",
1065         skip=True,
1066         type=vim.Datacenter,
1067         selectSet=[
1068             vmodl.query.PropertyCollector.TraversalSpec(
1069                 path="childEntity", skip=False, type=vim.Folder
1070             )
1071         ],
1072     )
1073     items = [
1074         i["object"]
1075         for i in get_mors_with_properties(
1076             si,
1077             vim.ClusterComputeResource,
1078             container_ref=dc_ref,
1079             property_list=["name"],
1080             traversal_spec=traversal_spec,
1081         )
1082         if i["name"] == cluster
1083     ]
1084     if not items:
1085         raise salt.exceptions.VMwareObjectRetrievalError(
1086             "Cluster '{}' was not found in datacenter '{}'".format(cluster, dc_name)
1087         )
1088     return items[0]
1089 def create_cluster(dc_ref, cluster_name, cluster_spec):
1090     dc_name = get_managed_object_name(dc_ref)
1091     log.trace("Creating cluster '%s' in datacenter '%s'", cluster_name, dc_name)
1092     try:
1093         dc_ref.hostFolder.CreateClusterEx(cluster_name, cluster_spec)
1094     except vim.fault.NoPermission as exc:
1095         log.exception(exc)
1096         raise salt.exceptions.VMwareApiError(
1097             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1098         )
1099     except vim.fault.VimFault as exc:
1100         log.exception(exc)
1101         raise salt.exceptions.VMwareApiError(exc.msg)
1102     except vmodl.RuntimeFault as exc:
1103         log.exception(exc)
1104         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1105 def update_cluster(cluster_ref, cluster_spec):
1106     cluster_name = get_managed_object_name(cluster_ref)
1107     log.trace("Updating cluster '%s'", cluster_name)
1108     try:
1109         task = cluster_ref.ReconfigureComputeResource_Task(cluster_spec, modify=True)
1110     except vim.fault.NoPermission as exc:
1111         log.exception(exc)
1112         raise salt.exceptions.VMwareApiError(
1113             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1114         )
1115     except vim.fault.VimFault as exc:
1116         log.exception(exc)
1117         raise salt.exceptions.VMwareApiError(exc.msg)
1118     except vmodl.RuntimeFault as exc:
1119         log.exception(exc)
1120         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1121     wait_for_task(task, cluster_name, "ClusterUpdateTask")
1122 def list_clusters(service_instance):
1123     return list_objects(service_instance, vim.ClusterComputeResource)
1124 def list_datastore_clusters(service_instance):
1125     return list_objects(service_instance, vim.StoragePod)
1126 def list_datastores(service_instance):
1127     return list_objects(service_instance, vim.Datastore)
1128 def get_datastore_files(
1129     service_instance, directory, datastores, container_object, browser_spec
1130 ):
1131     files = []
1132     datastore_objects = get_datastores(
1133         service_instance, container_object, datastore_names=datastores
1134     )
1135     for datobj in datastore_objects:
1136         try:
1137             task = datobj.browser.SearchDatastore_Task(
1138                 datastorePath="[{}] {}".format(datobj.name, directory),
1139                 searchSpec=browser_spec,
1140             )
1141         except vim.fault.NoPermission as exc:
1142             log.exception(exc)
1143             raise salt.exceptions.VMwareApiError(
1144                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1145             )
1146         except vim.fault.VimFault as exc:
1147             log.exception(exc)
1148             raise salt.exceptions.VMwareApiError(exc.msg)
1149         except vmodl.RuntimeFault as exc:
1150             log.exception(exc)
1151             raise salt.exceptions.VMwareRuntimeError(exc.msg)
1152         try:
1153             files.append(
1154                 salt.utils.vmware.wait_for_task(
1155                     task, directory, "query virtual machine files"
1156                 )
1157             )
1158         except salt.exceptions.VMwareFileNotFoundError:
1159             pass
1160     return files
1161 def get_datastores(
1162     service_instance,
1163     reference,
1164     datastore_names=None,
1165     backing_disk_ids=None,
1166     get_all_datastores=False,
1167 ):
1168     obj_name = get_managed_object_name(reference)
1169     if get_all_datastores:
1170         log.trace("Retrieving all datastores visible to '%s'", obj_name)
1171     else:
1172         log.trace(
1173             "Retrieving datastores visible to '%s': names = (%s); "
1174             "backing disk ids = (%s)",
1175             obj_name,
1176             datastore_names,
1177             backing_disk_ids,
1178         )
1179         if backing_disk_ids and not isinstance(reference, vim.HostSystem):
1180             raise salt.exceptions.ArgumentValueError(
1181                 "Unsupported reference type '{}' when backing disk filter "
1182                 "is set".format(reference.__class__.__name__)
1183             )
1184     if (not get_all_datastores) and backing_disk_ids:
1185         log.trace("Filtering datastores with backing disk ids: %s", backing_disk_ids)
1186         storage_system = get_storage_system(service_instance, reference, obj_name)
1187         props = salt.utils.vmware.get_properties_of_managed_object(
1188             storage_system, ["fileSystemVolumeInfo.mountInfo"]
1189         )
1190         mount_infos = props.get("fileSystemVolumeInfo.mountInfo", [])
1191         disk_datastores = []
1192         for vol in [
1193             i.volume for i in mount_infos if isinstance(i.volume, vim.HostVmfsVolume)
1194         ]:
1195             if not [e for e in vol.extent if e.diskName in backing_disk_ids]:
1196                 continue
1197             log.trace(
1198                 "Found datastore '%s' for disk id(s) '%s'",
1199                 vol.name,
1200                 [e.diskName for e in vol.extent],
1201             )
1202             disk_datastores.append(vol.name)
1203         log.trace("Datastore found for disk filter: %s", disk_datastores)
1204         if datastore_names:
1205             datastore_names.extend(disk_datastores)
1206         else:
1207             datastore_names = disk_datastores
1208     if (not get_all_datastores) and (not datastore_names):
1209         log.trace(
1210             "No datastore to be filtered after retrieving the datastores "
1211             "backed by the disk id(s) '%s'",
1212             backing_disk_ids,
1213         )
1214         return []
1215     log.trace("datastore_names = %s", datastore_names)
1216     if isinstance(reference, vim.HostSystem):
1217         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1218             name="host_datastore_traversal",
1219             path="datastore",
1220             skip=False,
1221             type=vim.HostSystem,
1222         )
1223     elif isinstance(reference, vim.ClusterComputeResource):
1224         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1225             name="cluster_datastore_traversal",
1226             path="datastore",
1227             skip=False,
1228             type=vim.ClusterComputeResource,
1229         )
1230     elif isinstance(reference, vim.Datacenter):
1231         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1232             name="datacenter_datastore_traversal",
1233             path="datastore",
1234             skip=False,
1235             type=vim.Datacenter,
1236         )
1237     elif isinstance(reference, vim.StoragePod):
1238         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1239             name="datastore_cluster_traversal",
1240             path="childEntity",
1241             skip=False,
1242             type=vim.StoragePod,
1243         )
1244     elif (
1245         isinstance(reference, vim.Folder)
1246         and get_managed_object_name(reference) == "Datacenters"
1247     ):
1248         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1249             path="childEntity",
1250             selectSet=[
1251                 vmodl.query.PropertyCollector.TraversalSpec(
1252                     path="datastore", skip=False, type=vim.Datacenter
1253                 )
1254             ],
1255             skip=False,
1256             type=vim.Folder,
1257         )
1258     else:
1259         raise salt.exceptions.ArgumentValueError(
1260             "Unsupported reference type '{}'".format(reference.__class__.__name__)
1261         )
1262     items = get_mors_with_properties(
1263         service_instance,
1264         object_type=vim.Datastore,
1265         property_list=["name"],
1266         container_ref=reference,
1267         traversal_spec=traversal_spec,
1268     )
1269     log.trace("Retrieved %s datastores", len(items))
1270     items = [i for i in items if get_all_datastores or i["name"] in datastore_names]
1271     log.trace("Filtered datastores: %s", [i["name"] for i in items])
1272     return [i["object"] for i in items]
1273 def rename_datastore(datastore_ref, new_datastore_name):
1274     ds_name = get_managed_object_name(datastore_ref)
1275     log.trace("Renaming datastore '%s' to '%s'", ds_name, new_datastore_name)
1276     try:
1277         datastore_ref.RenameDatastore(new_datastore_name)
1278     except vim.fault.NoPermission as exc:
1279         log.exception(exc)
1280         raise salt.exceptions.VMwareApiError(
1281             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1282         )
1283     except vim.fault.VimFault as exc:
1284         log.exception(exc)
1285         raise salt.exceptions.VMwareApiError(exc.msg)
1286     except vmodl.RuntimeFault as exc:
1287         log.exception(exc)
1288         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1289 def get_storage_system(service_instance, host_ref, hostname=None):
1290     if not hostname:
1291         hostname = get_managed_object_name(host_ref)
1292     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1293         path="configManager.storageSystem", type=vim.HostSystem, skip=False
1294     )
1295     objs = get_mors_with_properties(
1296         service_instance,
1297         vim.HostStorageSystem,
1298         property_list=["systemFile"],
1299         container_ref=host_ref,
1300         traversal_spec=traversal_spec,
1301     )
1302     if not objs:
1303         raise salt.exceptions.VMwareObjectRetrievalError(
1304             "Host's '{}' storage system was not retrieved".format(hostname)
1305         )
1306     log.trace("[%s] Retrieved storage system", hostname)
1307     return objs[0]["object"]
1308 def _get_partition_info(storage_system, device_path):
1309     try:
1310         partition_infos = storage_system.RetrieveDiskPartitionInfo(
1311             devicePath=[device_path]
1312         )
1313     except vim.fault.NoPermission as exc:
1314         log.exception(exc)
1315         raise salt.exceptions.VMwareApiError(
1316             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1317         )
1318     except vim.fault.VimFault as exc:
1319         log.exception(exc)
1320         raise salt.exceptions.VMwareApiError(exc.msg)
1321     except vmodl.RuntimeFault as exc:
1322         log.exception(exc)
1323         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1324     log.trace("partition_info = %s", partition_infos[0])
1325     return partition_infos[0]
1326 def _get_new_computed_partition_spec(storage_system, device_path, partition_info):
1327     log.trace(
1328         "Adding a partition at the end of the disk and getting the new "
1329         "computed partition spec"
1330     )
1331     free_partitions = [p for p in partition_info.layout.partition if p.type == "none"]
1332     if not free_partitions:
1333         raise salt.exceptions.VMwareObjectNotFoundError(
1334             "Free partition was not found on device '{}'".format(
1335                 partition_info.deviceName
1336             )
1337         )
1338     free_partition = free_partitions[0]
1339     layout = vim.HostDiskPartitionLayout(
1340         total=partition_info.layout.total, partition=partition_info.layout.partition
1341     )
1342     free_partition.type = "vmfs"
1343     try:
1344         computed_partition_info = storage_system.ComputeDiskPartitionInfo(
1345             devicePath=device_path,
1346             partitionFormat=vim.HostDiskPartitionInfoPartitionFormat.gpt,
1347             layout=layout,
1348         )
1349     except vim.fault.NoPermission as exc:
1350         log.exception(exc)
1351         raise salt.exceptions.VMwareApiError(
1352             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1353         )
1354     except vim.fault.VimFault as exc:
1355         log.exception(exc)
1356         raise salt.exceptions.VMwareApiError(exc.msg)
1357     except vmodl.RuntimeFault as exc:
1358         log.exception(exc)
1359 <a name="1"></a>        raise salt.exceptions.VMwareRuntimeError(exc.msg)
1360     log.trace("computed partition info = {0}", computed_partition_info)
1361     log.trace("Retrieving new partition number")
1362     partition_numbers <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= [
1363         p.partition
1364         for p in computed_partition_info.layout.partition
1365         if (
1366             p.start.block == free_partition.start.block
1367             or
1368             (free_partition.start.block == 0 and p.start.block == 1)
1369         )
1370         and p.end.block == free_partition.end.block
1371         and p.</b></font>type == "vmfs"
1372     ]
1373     if not partition_numbers:
1374         raise salt.exceptions.VMwareNotFoundError(
1375             "New partition was not found in computed partitions of device '{}'".format(
1376                 partition_info.deviceName
1377             )
1378         )
1379     log.trace("new partition number = %s", partition_numbers[0])
1380     return (partition_numbers[0], computed_partition_info.spec)
1381 def create_vmfs_datastore(
1382     host_ref, datastore_name, disk_ref, vmfs_major_version, storage_system=None
1383 ):
1384     hostname = get_managed_object_name(host_ref)
1385     disk_id = disk_ref.canonicalName
1386     log.debug(
1387         "Creating datastore '%s' on host '%s', scsi disk '%s', vmfs v%s",
1388         datastore_name,
1389         hostname,
1390         disk_id,
1391         vmfs_major_version,
1392     )
1393     if not storage_system:
1394         si = get_service_instance_from_managed_object(host_ref, name=hostname)
1395         storage_system = get_storage_system(si, host_ref, hostname)
1396     target_disk = disk_ref
1397     partition_info = _get_partition_info(storage_system, target_disk.devicePath)
1398     log.trace("partition_info = %s", partition_info)
1399     new_partition_number, partition_spec = _get_new_computed_partition_spec(
1400         storage_system, target_disk.devicePath, partition_info
1401     )
1402     spec = vim.VmfsDatastoreCreateSpec(
1403         vmfs=vim.HostVmfsSpec(
1404             majorVersion=vmfs_major_version,
1405             volumeName=datastore_name,
1406             extent=vim.HostScsiDiskPartition(
1407                 diskName=disk_id, partition=new_partition_number
1408             ),
1409         ),
1410         diskUuid=target_disk.uuid,
1411         partition=partition_spec,
1412     )
1413     try:
1414         ds_ref = host_ref.configManager.datastoreSystem.CreateVmfsDatastore(spec)
1415     except vim.fault.NoPermission as exc:
1416         log.exception(exc)
1417         raise salt.exceptions.VMwareApiError(
1418             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1419         )
1420     except vim.fault.VimFault as exc:
1421         log.exception(exc)
1422         raise salt.exceptions.VMwareApiError(exc.msg)
1423     except vmodl.RuntimeFault as exc:
1424         log.exception(exc)
1425         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1426     log.debug("Created datastore '%s' on host '%s'", datastore_name, hostname)
1427     return ds_ref
1428 def get_host_datastore_system(host_ref, hostname=None):
1429     if not hostname:
1430         hostname = get_managed_object_name(host_ref)
1431     service_instance = get_service_instance_from_managed_object(host_ref)
1432     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1433         path="configManager.datastoreSystem", type=vim.HostSystem, skip=False
1434     )
1435     objs = get_mors_with_properties(
1436         service_instance,
1437         vim.HostDatastoreSystem,
1438         property_list=["datastore"],
1439         container_ref=host_ref,
1440         traversal_spec=traversal_spec,
1441     )
1442     if not objs:
1443         raise salt.exceptions.VMwareObjectRetrievalError(
1444             "Host's '{}' datastore system was not retrieved".format(hostname)
1445         )
1446     log.trace("[%s] Retrieved datastore system", hostname)
1447     return objs[0]["object"]
1448 def remove_datastore(service_instance, datastore_ref):
1449     ds_props = get_properties_of_managed_object(datastore_ref, ["host", "info", "name"])
1450     ds_name = ds_props["name"]
1451     log.debug("Removing datastore '%s'", ds_name)
1452     ds_hosts = ds_props.get("host")
1453     if not ds_hosts:
1454         raise salt.exceptions.VMwareApiError(
1455             "Datastore '{}' can't be removed. No attached hosts found".format(ds_name)
1456         )
1457     hostname = get_managed_object_name(ds_hosts[0].key)
1458     host_ds_system = get_host_datastore_system(ds_hosts[0].key, hostname=hostname)
1459     try:
1460         host_ds_system.RemoveDatastore(datastore_ref)
1461     except vim.fault.NoPermission as exc:
1462         log.exception(exc)
1463         raise salt.exceptions.VMwareApiError(
1464             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1465         )
1466     except vim.fault.VimFault as exc:
1467         log.exception(exc)
1468         raise salt.exceptions.VMwareApiError(exc.msg)
1469     except vmodl.RuntimeFault as exc:
1470         log.exception(exc)
1471         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1472     log.trace("[%s] Removed datastore '%s'", hostname, ds_name)
1473 def get_hosts(
1474     service_instance,
1475     datacenter_name=None,
1476     host_names=None,
1477     cluster_name=None,
1478     get_all_hosts=False,
1479 ):
1480     properties = ["name"]
1481     if cluster_name and not datacenter_name:
1482         raise salt.exceptions.ArgumentValueError(
1483             "Must specify the datacenter when specifying the cluster"
1484         )
1485     if not host_names:
1486         host_names = []
1487     if not datacenter_name:
1488         start_point = get_root_folder(service_instance)
1489     else:
1490         start_point = get_datacenter(service_instance, datacenter_name)
1491         if cluster_name:
1492             properties.append("parent")
1493     hosts = get_mors_with_properties(
1494         service_instance,
1495         vim.HostSystem,
1496         container_ref=start_point,
1497         property_list=properties,
1498     )
1499     log.trace("Retrieved hosts: %s", [h["name"] for h in hosts])
1500     filtered_hosts = []
1501     for h in hosts:
1502         if cluster_name:
1503             if not isinstance(h["parent"], vim.ClusterComputeResource):
1504                 continue
1505             parent_name = get_managed_object_name(h["parent"])
1506             if parent_name != cluster_name:
1507                 continue
1508         if get_all_hosts:
1509             filtered_hosts.append(h["object"])
1510             continue
1511         if h["name"] in host_names:
1512             filtered_hosts.append(h["object"])
1513     return filtered_hosts
1514 def _get_scsi_address_to_lun_key_map(
1515     service_instance, host_ref, storage_system=None, hostname=None
1516 ):
1517     if not hostname:
1518         hostname = get_managed_object_name(host_ref)
1519     if not storage_system:
1520         storage_system = get_storage_system(service_instance, host_ref, hostname)
1521     try:
1522         device_info = storage_system.storageDeviceInfo
1523     except vim.fault.NoPermission as exc:
1524         log.exception(exc)
1525         raise salt.exceptions.VMwareApiError(
1526             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1527         )
1528     except vim.fault.VimFault as exc:
1529         log.exception(exc)
1530         raise salt.exceptions.VMwareApiError(exc.msg)
1531     except vmodl.RuntimeFault as exc:
1532         log.exception(exc)
1533         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1534     if not device_info:
1535         raise salt.exceptions.VMwareObjectRetrievalError(
1536             "Host's '{}' storage device info was not retrieved".format(hostname)
1537         )
1538     multipath_info = device_info.multipathInfo
1539     if not multipath_info:
1540         raise salt.exceptions.VMwareObjectRetrievalError(
1541             "Host's '{}' multipath info was not retrieved".format(hostname)
1542         )
1543     if multipath_info.lun is None:
1544         raise salt.exceptions.VMwareObjectRetrievalError(
1545             "No luns were retrieved from host '{}'".format(hostname)
1546         )
1547     lun_key_by_scsi_addr = {}
1548     for l in multipath_info.lun:
1549         lun_key_by_scsi_addr.update({p.name.split(",")[0]: l.lun for p in l.path})
1550     log.trace(
1551         "Scsi address to lun id map on host '%s': %s", hostname, lun_key_by_scsi_addr
1552     )
1553     return lun_key_by_scsi_addr
1554 def get_all_luns(host_ref, storage_system=None, hostname=None):
1555     if not hostname:
1556         hostname = get_managed_object_name(host_ref)
1557     if not storage_system:
1558         si = get_service_instance_from_managed_object(host_ref, name=hostname)
1559         storage_system = get_storage_system(si, host_ref, hostname)
1560         if not storage_system:
1561             raise salt.exceptions.VMwareObjectRetrievalError(
1562                 "Host's '{}' storage system was not retrieved".format(hostname)
1563             )
1564     try:
1565         device_info = storage_system.storageDeviceInfo
1566     except vim.fault.NoPermission as exc:
1567         log.exception(exc)
1568         raise salt.exceptions.VMwareApiError(
1569             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1570         )
1571     except vim.fault.VimFault as exc:
1572         log.exception(exc)
1573         raise salt.exceptions.VMwareApiError(exc.msg)
1574     except vmodl.RuntimeFault as exc:
1575         log.exception(exc)
1576         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1577     if not device_info:
1578         raise salt.exceptions.VMwareObjectRetrievalError(
1579             "Host's '{}' storage device info was not retrieved".format(hostname)
1580         )
1581     scsi_luns = device_info.scsiLun
1582     if scsi_luns:
1583         log.trace(
1584             "Retrieved scsi luns in host '%s': %s",
1585             hostname,
1586             [l.canonicalName for l in scsi_luns],
1587         )
1588         return scsi_luns
1589     log.trace("Retrieved no scsi_luns in host '%s'", hostname)
1590     return []
1591 def get_scsi_address_to_lun_map(host_ref, storage_system=None, hostname=None):
1592     if not hostname:
1593         hostname = get_managed_object_name(host_ref)
1594     si = get_service_instance_from_managed_object(host_ref, name=hostname)
1595     if not storage_system:
1596         storage_system = get_storage_system(si, host_ref, hostname)
1597     lun_ids_to_scsi_addr_map = _get_scsi_address_to_lun_key_map(
1598         si, host_ref, storage_system, hostname
1599     )
1600     luns_to_key_map = {
1601         d.key: d for d in get_all_luns(host_ref, storage_system, hostname)
1602     }
1603     return {
1604         scsi_addr: luns_to_key_map[lun_key]
1605         for scsi_addr, lun_key in lun_ids_to_scsi_addr_map.items()
1606     }
1607 def get_disks(host_ref, disk_ids=None, scsi_addresses=None, get_all_disks=False):
1608     hostname = get_managed_object_name(host_ref)
1609     if get_all_disks:
1610         log.trace("Retrieving all disks in host '%s'", hostname)
1611     else:
1612         log.trace(
1613             "Retrieving disks in host '%s': ids = (%s); scsi addresses = (%s)",
1614             hostname,
1615             disk_ids,
1616             scsi_addresses,
1617         )
1618         if not (disk_ids or scsi_addresses):
1619             return []
1620     si = get_service_instance_from_managed_object(host_ref, name=hostname)
1621     storage_system = get_storage_system(si, host_ref, hostname)
1622     disk_keys = []
1623     if scsi_addresses:
1624         lun_key_by_scsi_addr = _get_scsi_address_to_lun_key_map(
1625             si, host_ref, storage_system, hostname
1626         )
1627         disk_keys = [
1628             key
1629             for scsi_addr, key in lun_key_by_scsi_addr.items()
1630             if scsi_addr in scsi_addresses
1631         ]
1632         log.trace("disk_keys based on scsi_addresses = %s", disk_keys)
1633     scsi_luns = get_all_luns(host_ref, storage_system)
1634     scsi_disks = [
1635         disk
1636         for disk in scsi_luns
1637         if isinstance(disk, vim.HostScsiDisk)
1638         and (
1639             get_all_disks
1640             or
1641             (disk_ids and (disk.canonicalName in disk_ids))
1642             or
1643             (disk.key in disk_keys)
1644         )
1645     ]
1646     log.trace(
1647         "Retrieved disks in host '%s': %s",
1648         hostname,
1649         [d.canonicalName for d in scsi_disks],
1650     )
1651     return scsi_disks
1652 def get_disk_partition_info(host_ref, disk_id, storage_system=None):
1653     hostname = get_managed_object_name(host_ref)
1654     service_instance = get_service_instance_from_managed_object(host_ref)
1655     if not storage_system:
1656         storage_system = get_storage_system(service_instance, host_ref, hostname)
1657     props = get_properties_of_managed_object(
1658         storage_system, ["storageDeviceInfo.scsiLun"]
1659     )
1660     if not props.get("storageDeviceInfo.scsiLun"):
1661         raise salt.exceptions.VMwareObjectRetrievalError(
1662             "No devices were retrieved in host '{}'".format(hostname)
1663         )
1664     log.trace(
1665         "[%s] Retrieved %s devices: %s",
1666         hostname,
1667         len(props["storageDeviceInfo.scsiLun"]),
1668         ", ".join([l.canonicalName for l in props["storageDeviceInfo.scsiLun"]]),
1669     )
1670     disks = [
1671         l
1672         for l in props["storageDeviceInfo.scsiLun"]
1673         if isinstance(l, vim.HostScsiDisk) and l.canonicalName == disk_id
1674     ]
1675     if not disks:
1676         raise salt.exceptions.VMwareObjectRetrievalError(
1677             "Disk '{}' was not found in host '{}'".format(disk_id, hostname)
1678         )
1679     log.trace("[%s] device_path = %s", hostname, disks[0].devicePath)
1680     partition_info = _get_partition_info(storage_system, disks[0].devicePath)
1681     log.trace(
1682         "[%s] Retrieved %s partition(s) on disk '%s'",
1683         hostname,
1684         len(partition_info.spec.partition),
1685         disk_id,
1686     )
1687     return partition_info
1688 def erase_disk_partitions(
1689     service_instance, host_ref, disk_id, hostname=None, storage_system=None
1690 ):
1691     if not hostname:
1692         hostname = get_managed_object_name(host_ref)
1693     if not storage_system:
1694         storage_system = get_storage_system(service_instance, host_ref, hostname)
1695     traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1696         path="configManager.storageSystem", type=vim.HostSystem, skip=False
1697     )
1698     results = get_mors_with_properties(
1699         service_instance,
1700         vim.HostStorageSystem,
1701         ["storageDeviceInfo.scsiLun"],
1702         container_ref=host_ref,
1703         traversal_spec=traversal_spec,
1704     )
1705     if not results:
1706         raise salt.exceptions.VMwareObjectRetrievalError(
1707             "Host's '{}' devices were not retrieved".format(hostname)
1708         )
1709     log.trace(
1710         "[%s] Retrieved %s devices: %s",
1711         hostname,
1712         len(results[0].get("storageDeviceInfo.scsiLun", [])),
1713         ", ".join(
1714             [l.canonicalName for l in results[0].get("storageDeviceInfo.scsiLun", [])]
1715         ),
1716     )
1717     disks = [
1718         l
1719         for l in results[0].get("storageDeviceInfo.scsiLun", [])
1720         if isinstance(l, vim.HostScsiDisk) and l.canonicalName == disk_id
1721     ]
1722     if not disks:
1723         raise salt.exceptions.VMwareObjectRetrievalError(
1724             "Disk '{}' was not found in host '{}'".format(disk_id, hostname)
1725         )
1726     log.trace("[%s] device_path = %s", hostname, disks[0].devicePath)
1727     try:
1728         storage_system.UpdateDiskPartitions(
1729             disks[0].devicePath, vim.HostDiskPartitionSpec()
1730         )
1731     except vim.fault.NoPermission as exc:
1732         log.exception(exc)
1733         raise salt.exceptions.VMwareApiError(
1734             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1735         )
1736     except vim.fault.VimFault as exc:
1737         log.exception(exc)
1738         raise salt.exceptions.VMwareApiError(exc.msg)
1739     except vmodl.RuntimeFault as exc:
1740         log.exception(exc)
1741         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1742     log.trace("[%s] Erased partitions on disk '%s'", hostname, disk_id)
1743 def get_diskgroups(host_ref, cache_disk_ids=None, get_all_disk_groups=False):
1744     hostname = get_managed_object_name(host_ref)
1745     if get_all_disk_groups:
1746         log.trace("Retrieving all disk groups on host '%s'", hostname)
1747     else:
1748         log.trace(
1749             "Retrieving disk groups from host '%s', with cache disk ids : (%s)",
1750             hostname,
1751             cache_disk_ids,
1752         )
1753         if not cache_disk_ids:
1754             return []
1755     try:
1756         vsan_host_config = host_ref.config.vsanHostConfig
1757     except vim.fault.NoPermission as exc:
1758         log.exception(exc)
1759         raise salt.exceptions.VMwareApiError(
1760             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1761         )
1762     except vim.fault.VimFault as exc:
1763         log.exception(exc)
1764         raise salt.exceptions.VMwareApiError(exc.msg)
1765     except vmodl.RuntimeFault as exc:
1766         log.exception(exc)
1767         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1768     if not vsan_host_config:
1769         raise salt.exceptions.VMwareObjectRetrievalError(
1770             "No host config found on host '{}'".format(hostname)
1771         )
1772     vsan_storage_info = vsan_host_config.storageInfo
1773     if not vsan_storage_info:
1774         raise salt.exceptions.VMwareObjectRetrievalError(
1775             "No vsan storage info found on host '{}'".format(hostname)
1776         )
1777     vsan_disk_mappings = vsan_storage_info.diskMapping
1778     if not vsan_disk_mappings:
1779         return []
1780     disk_groups = [
1781         dm
1782         for dm in vsan_disk_mappings
1783         if (get_all_disk_groups or (dm.ssd.canonicalName in cache_disk_ids))
1784     ]
1785     log.trace(
1786         "Retrieved disk groups on host '%s', with cache disk ids : %s",
1787         hostname,
1788         [d.ssd.canonicalName for d in disk_groups],
1789     )
1790     return disk_groups
1791 def _check_disks_in_diskgroup(disk_group, cache_disk_id, capacity_disk_ids):
1792     if not disk_group.ssd.canonicalName == cache_disk_id:
1793         raise salt.exceptions.ArgumentValueError(
1794             "Incorrect diskgroup cache disk; got id: '{}'; expected id: '{}'".format(
1795                 disk_group.ssd.canonicalName, cache_disk_id
1796             )
1797         )
1798     non_ssd_disks = [d.canonicalName for d in disk_group.nonSsd]
1799     if sorted(non_ssd_disks) != sorted(capacity_disk_ids):
1800         raise salt.exceptions.ArgumentValueError(
1801             "Incorrect capacity disks; got ids: '{}'; expected ids: '{}'".format(
1802                 sorted(non_ssd_disks), sorted(capacity_disk_ids)
1803             )
1804         )
1805     log.trace("Checked disks in diskgroup with cache disk id '%s'", cache_disk_id)
1806     return True
1807 def get_host_cache(host_ref, host_cache_manager=None):
1808     hostname = get_managed_object_name(host_ref)
1809     service_instance = get_service_instance_from_managed_object(host_ref)
1810     log.trace("Retrieving the host cache on host '%s'", hostname)
1811     if not host_cache_manager:
1812         traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
1813             path="configManager.cacheConfigurationManager",
1814             type=vim.HostSystem,
1815             skip=False,
1816         )
1817         results = get_mors_with_properties(
1818             service_instance,
1819             vim.HostCacheConfigurationManager,
1820             ["cacheConfigurationInfo"],
1821             container_ref=host_ref,
1822             traversal_spec=traversal_spec,
1823         )
1824         if not results or not results[0].get("cacheConfigurationInfo"):
1825             log.trace("Host '%s' has no host cache", hostname)
1826             return None
1827         return results[0]["cacheConfigurationInfo"][0]
1828     else:
1829         results = get_properties_of_managed_object(
1830             host_cache_manager, ["cacheConfigurationInfo"]
1831         )
1832         if not results:
1833             log.trace("Host '%s' has no host cache", hostname)
1834             return None
1835         return results["cacheConfigurationInfo"][0]
1836 def configure_host_cache(
1837     host_ref, datastore_ref, swap_size_MiB, host_cache_manager=None
1838 ):
1839     hostname = get_managed_object_name(host_ref)
1840     if not host_cache_manager:
1841         props = get_properties_of_managed_object(
1842             host_ref, ["configManager.cacheConfigurationManager"]
1843         )
1844         if not props.get("configManager.cacheConfigurationManager"):
1845             raise salt.exceptions.VMwareObjectRetrievalError(
1846                 "Host '{}' has no host cache".format(hostname)
1847             )
1848         host_cache_manager = props["configManager.cacheConfigurationManager"]
1849     log.trace(
1850         "Configuring the host cache on host '%s', datastore '%s', swap size=%s MiB",
1851         hostname,
1852         datastore_ref.name,
1853         swap_size_MiB,
1854     )
1855     spec = vim.HostCacheConfigurationSpec(
1856         datastore=datastore_ref, swapSize=swap_size_MiB
1857     )
1858     log.trace("host_cache_spec=%s", spec)
1859     try:
1860         task = host_cache_manager.ConfigureHostCache_Task(spec)
1861     except vim.fault.NoPermission as exc:
1862         log.exception(exc)
1863         raise salt.exceptions.VMwareApiError(
1864             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1865         )
1866     except vim.fault.VimFault as exc:
1867         log.exception(exc)
1868         raise salt.exceptions.VMwareApiError(exc.msg)
1869     except vmodl.RuntimeFault as exc:
1870         log.exception(exc)
1871         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1872     wait_for_task(task, hostname, "HostCacheConfigurationTask")
1873     log.trace("Configured host cache on host '%s'", hostname)
1874     return True
1875 def list_hosts(service_instance):
1876     return list_objects(service_instance, vim.HostSystem)
1877 def get_resource_pools(
1878     service_instance,
1879     resource_pool_names,
1880     datacenter_name=None,
1881     get_all_resource_pools=False,
1882 ):
1883     properties = ["name"]
1884     if not resource_pool_names:
1885         resource_pool_names = []
1886     if datacenter_name:
1887         container_ref = get_datacenter(service_instance, datacenter_name)
1888     else:
1889         container_ref = get_root_folder(service_instance)
1890     resource_pools = get_mors_with_properties(
1891         service_instance,
1892         vim.ResourcePool,
1893         container_ref=container_ref,
1894         property_list=properties,
1895     )
1896     selected_pools = []
1897     for pool in resource_pools:
1898         if get_all_resource_pools or (pool["name"] in resource_pool_names):
1899             selected_pools.append(pool["object"])
1900     if not selected_pools:
1901         raise salt.exceptions.VMwareObjectRetrievalError(
1902             "The resource pools with properties "
1903             "names={} get_all={} could not be found".format(
1904                 selected_pools, get_all_resource_pools
1905             )
1906         )
1907     return selected_pools
1908 def list_resourcepools(service_instance):
1909     return list_objects(service_instance, vim.ResourcePool)
1910 def list_networks(service_instance):
1911     return list_objects(service_instance, vim.Network)
1912 def list_vms(service_instance):
1913     return list_objects(service_instance, vim.VirtualMachine)
1914 def list_folders(service_instance):
1915     return list_objects(service_instance, vim.Folder)
1916 def list_dvs(service_instance):
1917     return list_objects(service_instance, vim.DistributedVirtualSwitch)
1918 def list_vapps(service_instance):
1919     return list_objects(service_instance, vim.VirtualApp)
1920 def list_portgroups(service_instance):
1921     return list_objects(service_instance, vim.dvs.DistributedVirtualPortgroup)
1922 def wait_for_task(task, instance_name, task_type, sleep_seconds=1, log_level="debug"):
1923     time_counter = 0
1924     start_time = time.time()
1925     log.trace("task = %s, task_type = %s", task, task.__class__.__name__)
1926     try:
1927         task_info = task.info
1928     except vim.fault.NoPermission as exc:
1929         log.exception(exc)
1930         raise salt.exceptions.VMwareApiError(
1931             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1932         )
1933     except vim.fault.FileNotFound as exc:
1934         log.exception(exc)
1935         raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
1936     except vim.fault.VimFault as exc:
1937         log.exception(exc)
1938         raise salt.exceptions.VMwareApiError(exc.msg)
1939     except vmodl.RuntimeFault as exc:
1940         log.exception(exc)
1941         raise salt.exceptions.VMwareRuntimeError(exc.msg)
1942     while task_info.state == "running" or task_info.state == "queued":
1943         if time_counter % sleep_seconds == 0:
1944             msg = "[ {} ] Waiting for {} task to finish [{} s]".format(
1945                 instance_name, task_type, time_counter
1946             )
1947             if log_level == "info":
1948                 log.info(msg)
1949             else:
1950                 log.debug(msg)
1951         time.sleep(1.0 - ((time.time() - start_time) % 1.0))
1952         time_counter += 1
1953         try:
1954             task_info = task.info
1955         except vim.fault.NoPermission as exc:
1956             log.exception(exc)
1957             raise salt.exceptions.VMwareApiError(
1958                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1959             )
1960         except vim.fault.FileNotFound as exc:
1961             log.exception(exc)
1962             raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
1963         except vim.fault.VimFault as exc:
1964             log.exception(exc)
1965             raise salt.exceptions.VMwareApiError(exc.msg)
1966         except vmodl.RuntimeFault as exc:
1967             log.exception(exc)
1968             raise salt.exceptions.VMwareRuntimeError(exc.msg)
1969     if task_info.state == "success":
1970         msg = "[ {} ] Successfully completed {} task in {} seconds".format(
1971             instance_name, task_type, time_counter
1972         )
1973         if log_level == "info":
1974             log.info(msg)
1975         else:
1976             log.debug(msg)
1977         return task_info.result
1978     else:
1979         try:
1980             raise task_info.error
1981         except vim.fault.NoPermission as exc:
1982             log.exception(exc)
1983             raise salt.exceptions.VMwareApiError(
1984                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
1985             )
1986         except vim.fault.FileNotFound as exc:
1987             log.exception(exc)
1988             raise salt.exceptions.VMwareFileNotFoundError(exc.msg)
1989         except vim.fault.VimFault as exc:
1990             log.exception(exc)
1991             raise salt.exceptions.VMwareApiError(exc.msg)
1992         except vmodl.fault.SystemError as exc:
1993             log.exception(exc)
1994             raise salt.exceptions.VMwareSystemError(exc.msg)
1995         except vmodl.fault.InvalidArgument as exc:
1996             log.exception(exc)
1997             exc_message = exc.msg
1998             if exc.faultMessage:
1999                 exc_message = "{} ({})".format(exc_message, exc.faultMessage[0].message)
2000             raise salt.exceptions.VMwareApiError(exc_message)
2001 def get_vm_by_property(
2002     service_instance,
2003     name,
2004     datacenter=None,
2005     vm_properties=None,
2006     traversal_spec=None,
2007     parent_ref=None,
2008 ):
2009     if datacenter and not parent_ref:
2010         parent_ref = salt.utils.vmware.get_datacenter(service_instance, datacenter)
2011     if not vm_properties:
2012         vm_properties = [
2013             "name",
2014             "config.hardware.device",
2015             "summary.storage.committed",
2016             "summary.storage.uncommitted",
2017             "summary.storage.unshared",
2018             "layoutEx.file",
2019             "config.guestFullName",
2020             "config.guestId",
2021             "guest.net",
2022             "config.hardware.memoryMB",
2023             "config.hardware.numCPU",
2024             "config.files.vmPathName",
2025             "summary.runtime.powerState",
2026             "guest.toolsStatus",
2027         ]
2028     vm_list = salt.utils.vmware.get_mors_with_properties(
2029         service_instance,
2030         vim.VirtualMachine,
2031         vm_properties,
2032         container_ref=parent_ref,
2033         traversal_spec=traversal_spec,
2034     )
2035     vm_formatted = [vm for vm in vm_list if vm["name"] == name]
2036     if not vm_formatted:
2037         raise salt.exceptions.VMwareObjectRetrievalError(
2038             "The virtual machine was not found."
2039         )
2040     elif len(vm_formatted) &gt; 1:
2041         raise salt.exceptions.VMwareMultipleObjectsError(
2042             " ".join(
2043                 [
2044                     "Multiple virtual machines were found with the"
2045                     "same name, please specify a container."
2046                 ]
2047             )
2048         )
2049     return vm_formatted[0]
2050 def get_folder(service_instance, datacenter, placement, base_vm_name=None):
2051     log.trace("Retrieving folder information")
2052     if base_vm_name:
2053         vm_object = get_vm_by_property(
2054             service_instance, base_vm_name, vm_properties=["name"]
2055         )
2056         vm_props = salt.utils.vmware.get_properties_of_managed_object(
2057             vm_object, properties=["parent"]
2058         )
2059         if "parent" in vm_props:
2060             folder_object = vm_props["parent"]
2061         else:
2062             raise salt.exceptions.VMwareObjectRetrievalError(
2063                 " ".join(["The virtual machine parent", "object is not defined"])
2064             )
2065     elif "folder" in placement:
2066         folder_objects = salt.utils.vmware.get_folders(
2067             service_instance, [placement["folder"]], datacenter
2068         )
2069         if len(folder_objects) &gt; 1:
2070             raise salt.exceptions.VMwareMultipleObjectsError(
2071                 " ".join(
2072                     [
2073                         "Multiple instances are available of the",
2074                         "specified folder {}".format(placement["folder"]),
2075                     ]
2076                 )
2077             )
2078         folder_object = folder_objects[0]
2079     elif datacenter:
2080         datacenter_object = salt.utils.vmware.get_datacenter(
2081             service_instance, datacenter
2082         )
2083         dc_props = salt.utils.vmware.get_properties_of_managed_object(
2084             datacenter_object, properties=["vmFolder"]
2085         )
2086         if "vmFolder" in dc_props:
2087             folder_object = dc_props["vmFolder"]
2088         else:
2089             raise salt.exceptions.VMwareObjectRetrievalError(
2090                 "The datacenter vm folder object is not defined"
2091             )
2092     return folder_object
2093 def get_placement(service_instance, datacenter, placement=None):
2094     log.trace("Retrieving placement information")
2095     resourcepool_object, placement_object = None, None
2096     if "host" in placement:
2097         host_objects = get_hosts(
2098             service_instance, datacenter_name=datacenter, host_names=[placement["host"]]
2099         )
2100         if not host_objects:
2101             raise salt.exceptions.VMwareObjectRetrievalError(
2102                 " ".join(
2103                     [
2104                         "The specified host",
2105                         "{} cannot be found.".format(placement["host"]),
2106                     ]
2107                 )
2108             )
2109         try:
2110             host_props = get_properties_of_managed_object(
2111                 host_objects[0], properties=["resourcePool"]
2112             )
2113             resourcepool_object = host_props["resourcePool"]
2114         except vmodl.query.InvalidProperty:
2115             traversal_spec = vmodl.query.PropertyCollector.TraversalSpec(
2116                 path="parent",
2117                 skip=True,
2118                 type=vim.HostSystem,
2119                 selectSet=[
2120                     vmodl.query.PropertyCollector.TraversalSpec(
2121                         path="resourcePool", skip=False, type=vim.ClusterComputeResource
2122                     )
2123                 ],
2124             )
2125             resourcepools = get_mors_with_properties(
2126                 service_instance,
2127                 vim.ResourcePool,
2128                 container_ref=host_objects[0],
2129                 property_list=["name"],
2130                 traversal_spec=traversal_spec,
2131             )
2132             if resourcepools:
2133                 resourcepool_object = resourcepools[0]["object"]
2134             else:
2135                 raise salt.exceptions.VMwareObjectRetrievalError(
2136                     "The resource pool of host {} cannot be found.".format(
2137                         placement["host"]
2138                     )
2139                 )
2140         placement_object = host_objects[0]
2141     elif "resourcepool" in placement:
2142         resourcepool_objects = get_resource_pools(
2143             service_instance, [placement["resourcepool"]], datacenter_name=datacenter
2144         )
2145         if len(resourcepool_objects) &gt; 1:
2146             raise salt.exceptions.VMwareMultipleObjectsError(
2147                 " ".join(
2148                     [
2149                         "Multiple instances are available of the",
2150                         "specified host {}.".format(placement["host"]),
2151                     ]
2152                 )
2153             )
2154         resourcepool_object = resourcepool_objects[0]
2155         res_props = get_properties_of_managed_object(
2156             resourcepool_object, properties=["parent"]
2157         )
2158         if "parent" in res_props:
2159             placement_object = res_props["parent"]
2160         else:
2161             raise salt.exceptions.VMwareObjectRetrievalError(
2162                 " ".join(["The resource pool's parent", "object is not defined"])
2163             )
2164     elif "cluster" in placement:
2165         datacenter_object = get_datacenter(service_instance, datacenter)
2166         cluster_object = get_cluster(datacenter_object, placement["cluster"])
2167         clus_props = get_properties_of_managed_object(
2168             cluster_object, properties=["resourcePool"]
2169         )
2170         if "resourcePool" in clus_props:
2171             resourcepool_object = clus_props["resourcePool"]
2172         else:
2173             raise salt.exceptions.VMwareObjectRetrievalError(
2174                 " ".join(["The cluster's resource pool", "object is not defined"])
2175             )
2176         placement_object = cluster_object
2177     else:
2178         raise salt.exceptions.VMwareObjectRetrievalError(
2179             " ".join(["Placement is not defined."])
2180         )
2181     return (resourcepool_object, placement_object)
2182 def convert_to_kb(unit, size):
2183     if unit.lower() == "gb":
2184         target_size = int(size * 1024 * 1024)
2185     elif unit.lower() == "mb":
2186         target_size = int(size * 1024)
2187     elif unit.lower() == "kb":
2188         target_size = int(size)
2189     else:
2190         raise salt.exceptions.ArgumentValueError("The unit is not specified")
2191     return {"size": target_size, "unit": "KB"}
2192 def power_cycle_vm(virtual_machine, action="on"):
2193     if action == "on":
2194         try:
2195             task = virtual_machine.PowerOn()
2196             task_name = "power on"
2197         except vim.fault.NoPermission as exc:
2198             log.exception(exc)
2199             raise salt.exceptions.VMwareApiError(
2200                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2201             )
2202         except vim.fault.VimFault as exc:
2203             log.exception(exc)
2204             raise salt.exceptions.VMwareApiError(exc.msg)
2205         except vmodl.RuntimeFault as exc:
2206             log.exception(exc)
2207             raise salt.exceptions.VMwareRuntimeError(exc.msg)
2208     elif action == "off":
2209         try:
2210             task = virtual_machine.PowerOff()
2211             task_name = "power off"
2212         except vim.fault.NoPermission as exc:
2213             log.exception(exc)
2214             raise salt.exceptions.VMwareApiError(
2215                 "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2216             )
2217         except vim.fault.VimFault as exc:
2218             log.exception(exc)
2219             raise salt.exceptions.VMwareApiError(exc.msg)
2220         except vmodl.RuntimeFault as exc:
2221             log.exception(exc)
2222             raise salt.exceptions.VMwareRuntimeError(exc.msg)
2223     else:
2224         raise salt.exceptions.ArgumentValueError("The given action is not supported")
2225     try:
2226         wait_for_task(task, get_managed_object_name(virtual_machine), task_name)
2227     except salt.exceptions.VMwareFileNotFoundError as exc:
2228         raise salt.exceptions.VMwarePowerOnError(
2229             " ".join(
2230                 [
2231                     "An error occurred during power",
2232                     "operation, a file was not found: {}".format(exc),
2233                 ]
2234             )
2235         )
2236     return virtual_machine
2237 def create_vm(
2238     vm_name, vm_config_spec, folder_object, resourcepool_object, host_object=None
2239 ):
2240     try:
2241         if host_object and isinstance(host_object, vim.HostSystem):
2242             task = folder_object.CreateVM_Task(
2243                 vm_config_spec, pool=resourcepool_object, host=host_object
2244             )
2245         else:
2246             task = folder_object.CreateVM_Task(vm_config_spec, pool=resourcepool_object)
2247     except vim.fault.NoPermission as exc:
2248         log.exception(exc)
2249         raise salt.exceptions.VMwareApiError(
2250             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2251         )
2252     except vim.fault.VimFault as exc:
2253         log.exception(exc)
2254         raise salt.exceptions.VMwareApiError(exc.msg)
2255     except vmodl.RuntimeFault as exc:
2256         log.exception(exc)
2257         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2258     vm_object = wait_for_task(task, vm_name, "CreateVM Task", 10, "info")
2259     return vm_object
2260 def register_vm(datacenter, name, vmx_path, resourcepool_object, host_object=None):
2261     try:
2262         if host_object:
2263             task = datacenter.vmFolder.RegisterVM_Task(
2264                 path=vmx_path,
2265                 name=name,
2266                 asTemplate=False,
2267                 host=host_object,
2268                 pool=resourcepool_object,
2269             )
2270         else:
2271             task = datacenter.vmFolder.RegisterVM_Task(
2272                 path=vmx_path, name=name, asTemplate=False, pool=resourcepool_object
2273             )
2274     except vim.fault.NoPermission as exc:
2275         log.exception(exc)
2276         raise salt.exceptions.VMwareApiError(
2277             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2278         )
2279     except vim.fault.VimFault as exc:
2280         log.exception(exc)
2281         raise salt.exceptions.VMwareApiError(exc.msg)
2282     except vmodl.RuntimeFault as exc:
2283         log.exception(exc)
2284         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2285     try:
2286         vm_ref = wait_for_task(task, name, "RegisterVM Task")
2287     except salt.exceptions.VMwareFileNotFoundError as exc:
2288         raise salt.exceptions.VMwareVmRegisterError(
2289             "An error occurred during registration operation, the "
2290             "configuration file was not found: {}".format(exc)
2291         )
2292     return vm_ref
2293 def update_vm(vm_ref, vm_config_spec):
2294     vm_name = get_managed_object_name(vm_ref)
2295     log.trace("Updating vm '%s'", vm_name)
2296     try:
2297         task = vm_ref.ReconfigVM_Task(vm_config_spec)
2298     except vim.fault.NoPermission as exc:
2299         log.exception(exc)
2300         raise salt.exceptions.VMwareApiError(
2301             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2302         )
2303     except vim.fault.VimFault as exc:
2304         log.exception(exc)
2305         raise salt.exceptions.VMwareApiError(exc.msg)
2306     except vmodl.RuntimeFault as exc:
2307         log.exception(exc)
2308         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2309     vm_ref = wait_for_task(task, vm_name, "ReconfigureVM Task")
2310     return vm_ref
2311 def delete_vm(vm_ref):
2312     vm_name = get_managed_object_name(vm_ref)
2313     log.trace("Destroying vm '%s'", vm_name)
2314     try:
2315         task = vm_ref.Destroy_Task()
2316     except vim.fault.NoPermission as exc:
2317         log.exception(exc)
2318         raise salt.exceptions.VMwareApiError(
2319             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2320         )
2321     except vim.fault.VimFault as exc:
2322         log.exception(exc)
2323         raise salt.exceptions.VMwareApiError(exc.msg)
2324     except vmodl.RuntimeFault as exc:
2325         log.exception(exc)
2326         raise salt.exceptions.VMwareRuntimeError(exc.msg)
2327     wait_for_task(task, vm_name, "Destroy Task")
2328 def unregister_vm(vm_ref):
2329     vm_name = get_managed_object_name(vm_ref)
2330     log.trace("Destroying vm '%s'", vm_name)
2331     try:
2332         vm_ref.UnregisterVM()
2333     except vim.fault.NoPermission as exc:
2334         log.exception(exc)
2335         raise salt.exceptions.VMwareApiError(
2336             "Not enough permissions. Required privilege: {}".format(exc.privilegeId)
2337         )
2338     except vim.fault.VimFault as exc:
2339         raise salt.exceptions.VMwareApiError(exc.msg)
2340     except vmodl.RuntimeFault as exc:
2341         raise salt.exceptions.VMwareRuntimeError(exc.msg)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
