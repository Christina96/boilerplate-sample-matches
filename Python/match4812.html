<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_euler.py & test_centrality_1.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_euler.py & test_centrality_1.py
      </h3>
      <h1 align="center">
        5.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_euler.py (3.5%)<TH>test_centrality_1.py (15.300547%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match4812-0.html#0',2,'match4812-1.html#0',3)" NAME="0">(88-93)<TD><A HREF="javascript:ZweiFrames('match4812-0.html#0',2,'match4812-1.html#0',3)" NAME="0">(72-76)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match4812-0.html#1',2,'match4812-1.html#1',3)" NAME="1">(78-82)<TD><A HREF="javascript:ZweiFrames('match4812-0.html#1',2,'match4812-1.html#1',3)" NAME="1">(60-65)</A><TD ALIGN=center><FONT COLOR="#dd0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_euler.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import collections

import pytest

import networkx as nx


class TestIsEulerian:
    def test_is_eulerian(self):
        assert nx.is_eulerian(nx.complete_graph(5))
        assert nx.is_eulerian(nx.complete_graph(7))
        assert nx.is_eulerian(nx.hypercube_graph(4))
        assert nx.is_eulerian(nx.hypercube_graph(6))

        assert not nx.is_eulerian(nx.complete_graph(4))
        assert not nx.is_eulerian(nx.complete_graph(6))
        assert not nx.is_eulerian(nx.hypercube_graph(3))
        assert not nx.is_eulerian(nx.hypercube_graph(5))

        assert not nx.is_eulerian(nx.petersen_graph())
        assert not nx.is_eulerian(nx.path_graph(4))

    def test_is_eulerian2(self):
        # not connected
        G = nx.Graph()
        G.add_nodes_from([1, 2, 3])
        assert not nx.is_eulerian(G)
        # not strongly connected
        G = nx.DiGraph()
        G.add_nodes_from([1, 2, 3])
        assert not nx.is_eulerian(G)
        G = nx.MultiDiGraph()
        G.add_edge(1, 2)
        G.add_edge(2, 3)
        G.add_edge(2, 3)
        G.add_edge(3, 1)
        assert not nx.is_eulerian(G)


class TestEulerianCircuit:
    def test_eulerian_circuit_cycle(self):
        G = nx.cycle_graph(4)

        edges = list(nx.eulerian_circuit(G, source=0))
        nodes = [u for u, v in edges]
        assert nodes == [0, 3, 2, 1]
        assert edges == [(0, 3), (3, 2), (2, 1), (1, 0)]

        edges = list(nx.eulerian_circuit(G, source=1))
        nodes = [u for u, v in edges]
        assert nodes == [1, 2, 3, 0]
        assert edges == [(1, 2), (2, 3), (3, 0), (0, 1)]

        G = nx.complete_graph(3)

        edges = list(nx.eulerian_circuit(G, source=0))
        nodes = [u for u, v in edges]
        assert nodes == [0, 2, 1]
        assert edges == [(0, 2), (2, 1), (1, 0)]

        edges = list(nx.eulerian_circuit(G, source=1))
        nodes = [u for u, v in edges]
        assert nodes == [1, 2, 0]
        assert edges == [(1, 2), (2, 0), (0, 1)]

    def test_eulerian_circuit_digraph(self):
        G = nx.DiGraph()
        nx.add_cycle(G, [0, 1, 2, 3])

        edges = list(nx.eulerian_circuit(G, source=0))
        nodes = [u for u, v in edges]
        assert nodes == [0, 1, 2, 3]
        assert edges == [(0, 1), (1, 2), (2, 3), (3, 0)]

<A NAME="1"></A>        edges = list(nx.eulerian_circuit(G, source=1))
        nodes = [u for u, v in edges]
        assert nodes == [1, 2, 3, 0]
        assert edges == [<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match4812-1.html#1',3,'match4812-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(1, 2), (2, 3), (3, 0), (0, 1)]

    def test_multigraph(self):
        G = nx.MultiGraph()
        nx.add_cycle(G, [0</B></FONT>, 1, 2, 3])
        G.add_edge(1, 2)
        G.add_edge(1, 2)
<A NAME="0"></A>        edges = list(nx.eulerian_circuit(G, source=0))
        nodes = [u for u, v in edges]
        assert nodes == [0, 3, 2, 1, 2, 1]
        assert edges == [(<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match4812-1.html#0',3,'match4812-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>0, 3), (3, 2), (2, 1), (1, 2), (2, 1), (1, 0)]

    def test_multigraph_with_keys(self):
        G = nx.MultiGraph()
        nx.add_cycle(G, [0, 1, 2, 3])
        G.</B></FONT>add_edge(1, 2)
        G.add_edge(1, 2)
        edges = list(nx.eulerian_circuit(G, source=0, keys=True))
        nodes = [u for u, v, k in edges]
        assert nodes == [0, 3, 2, 1, 2, 1]
        assert edges[:2] == [(0, 3, 0), (3, 2, 0)]
        assert collections.Counter(edges[2:5]) == collections.Counter(
            [(2, 1, 0), (1, 2, 1), (2, 1, 2)]
        )
        assert edges[5:] == [(1, 0, 0)]

    def test_not_eulerian(self):
        with pytest.raises(nx.NetworkXError):
            f = list(nx.eulerian_circuit(nx.complete_graph(4)))


class TestIsSemiEulerian:
    def test_is_semieulerian(self):
        # Test graphs with Eulerian paths but no cycles return True.
        assert nx.is_semieulerian(nx.path_graph(4))
        G = nx.path_graph(6, create_using=nx.DiGraph)
        assert nx.is_semieulerian(G)

        # Test graphs with Eulerian cycles return False.
        assert not nx.is_semieulerian(nx.complete_graph(5))
        assert not nx.is_semieulerian(nx.complete_graph(7))
        assert not nx.is_semieulerian(nx.hypercube_graph(4))
        assert not nx.is_semieulerian(nx.hypercube_graph(6))


class TestHasEulerianPath:
    def test_has_eulerian_path_cyclic(self):
        # Test graphs with Eulerian cycles return True.
        assert nx.has_eulerian_path(nx.complete_graph(5))
        assert nx.has_eulerian_path(nx.complete_graph(7))
        assert nx.has_eulerian_path(nx.hypercube_graph(4))
        assert nx.has_eulerian_path(nx.hypercube_graph(6))

    def test_has_eulerian_path_non_cyclic(self):
        # Test graphs with Eulerian paths but no cycles return True.
        assert nx.has_eulerian_path(nx.path_graph(4))
        G = nx.path_graph(6, create_using=nx.DiGraph)
        assert nx.has_eulerian_path(G)

    def test_has_eulerian_path_directed_graph(self):
        # Test directed graphs and returns False
        G = nx.DiGraph()
        G.add_edges_from([(0, 1), (1, 2), (0, 2)])
        assert not nx.has_eulerian_path(G)

    def test_has_eulerian_path_isolated_node(self):
        # Test directed graphs without isolated node returns True
        G = nx.DiGraph()
        G.add_edges_from([(0, 1), (1, 2), (2, 0)])
        assert nx.has_eulerian_path(G)

        # Test directed graphs with isolated node returns True
        G.add_node(3)
        assert nx.has_eulerian_path(G)

    @pytest.mark.parametrize(&quot;G&quot;, (nx.Graph(), nx.DiGraph()))
    def test_has_eulerian_path_not_weakly_connected(self, G):
        G.add_edges_from([(0, 1), (2, 3), (3, 2)])
        assert not nx.has_eulerian_path(G)

    @pytest.mark.parametrize(&quot;G&quot;, (nx.Graph(), nx.DiGraph()))
    def test_has_eulerian_path_unbalancedins_more_than_one(self, G):
        G.add_edges_from([(0, 1), (2, 3)])
        assert not nx.has_eulerian_path(G)


class TestFindPathStart:
    def testfind_path_start(self):
        find_path_start = nx.algorithms.euler._find_path_start
        # Test digraphs return correct starting node.
        G = nx.path_graph(6, create_using=nx.DiGraph)
        assert find_path_start(G) == 0
        edges = [(0, 1), (1, 2), (2, 0), (4, 0)]
        assert find_path_start(nx.DiGraph(edges)) == 4

        # Test graph with no Eulerian path return None.
        edges = [(0, 1), (1, 2), (2, 3), (2, 4)]
        assert find_path_start(nx.DiGraph(edges)) is None


class TestEulerianPath:
    def test_eulerian_path(self):
        x = [(4, 0), (0, 1), (1, 2), (2, 0)]
        for e1, e2 in zip(x, nx.eulerian_path(nx.DiGraph(x))):
            assert e1 == e2

    def test_eulerian_path_straight_link(self):
        G = nx.DiGraph()
        result = [(1, 2), (2, 3), (3, 4), (4, 5)]
        G.add_edges_from(result)
        assert result == list(nx.eulerian_path(G))
        assert result == list(nx.eulerian_path(G, source=1))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=3))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=4))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=5))

    def test_eulerian_path_multigraph(self):
        G = nx.MultiDiGraph()
        result = [(2, 1), (1, 2), (2, 1), (1, 2), (2, 3), (3, 4), (4, 3)]
        G.add_edges_from(result)
        assert result == list(nx.eulerian_path(G))
        assert result == list(nx.eulerian_path(G, source=2))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=3))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=4))

    def test_eulerian_path_eulerian_circuit(self):
        G = nx.DiGraph()
        result = [(1, 2), (2, 3), (3, 4), (4, 1)]
        result2 = [(2, 3), (3, 4), (4, 1), (1, 2)]
        result3 = [(3, 4), (4, 1), (1, 2), (2, 3)]
        G.add_edges_from(result)
        assert result == list(nx.eulerian_path(G))
        assert result == list(nx.eulerian_path(G, source=1))
        assert result2 == list(nx.eulerian_path(G, source=2))
        assert result3 == list(nx.eulerian_path(G, source=3))

    def test_eulerian_path_undirected(self):
        G = nx.Graph()
        result = [(1, 2), (2, 3), (3, 4), (4, 5)]
        result2 = [(5, 4), (4, 3), (3, 2), (2, 1)]
        G.add_edges_from(result)
        assert list(nx.eulerian_path(G)) in (result, result2)
        assert result == list(nx.eulerian_path(G, source=1))
        assert result2 == list(nx.eulerian_path(G, source=5))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=3))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=2))

    def test_eulerian_path_multigraph_undirected(self):
        G = nx.MultiGraph()
        result = [(2, 1), (1, 2), (2, 1), (1, 2), (2, 3), (3, 4)]
        G.add_edges_from(result)
        assert result == list(nx.eulerian_path(G))
        assert result == list(nx.eulerian_path(G, source=2))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=3))
        with pytest.raises(nx.NetworkXError):
            list(nx.eulerian_path(G, source=1))


class TestEulerize:
    def test_disconnected(self):
        with pytest.raises(nx.NetworkXError):
            G = nx.from_edgelist([(0, 1), (2, 3)])
            nx.eulerize(G)

    def test_null_graph(self):
        with pytest.raises(nx.NetworkXPointlessConcept):
            nx.eulerize(nx.Graph())

    def test_null_multigraph(self):
        with pytest.raises(nx.NetworkXPointlessConcept):
            nx.eulerize(nx.MultiGraph())

    def test_on_empty_graph(self):
        with pytest.raises(nx.NetworkXError):
            nx.eulerize(nx.empty_graph(3))

    def test_on_eulerian(self):
        G = nx.cycle_graph(3)
        H = nx.eulerize(G)
        assert nx.is_isomorphic(G, H)

    def test_on_eulerian_multigraph(self):
        G = nx.MultiGraph(nx.cycle_graph(3))
        G.add_edge(0, 1)
        H = nx.eulerize(G)
        assert nx.is_eulerian(H)

    def test_on_complete_graph(self):
        G = nx.complete_graph(4)
        assert nx.is_eulerian(nx.eulerize(G))
        assert nx.is_eulerian(nx.eulerize(nx.MultiGraph(G)))
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_centrality_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;Unit tests for the :mod:`networkx.algorithms.community.centrality`
module.

&quot;&quot;&quot;
from operator import itemgetter


import networkx as nx
from networkx.algorithms.community import girvan_newman


def set_of_sets(iterable):
    return set(map(frozenset, iterable))


def validate_communities(result, expected):
    assert set_of_sets(result) == set_of_sets(expected)


def validate_possible_communities(result, *expected):
    assert any(set_of_sets(result) == set_of_sets(p) for p in expected)


class TestGirvanNewman:
    &quot;&quot;&quot;Unit tests for the
    :func:`networkx.algorithms.community.centrality.girvan_newman`
    function.

    &quot;&quot;&quot;

    def test_no_edges(self):
        G = nx.empty_graph(3)
        communities = list(girvan_newman(G))
        assert len(communities) == 1
        validate_communities(communities[0], [{0}, {1}, {2}])

    def test_undirected(self):
        # Start with the graph .-.-.-.
        G = nx.path_graph(4)
        communities = list(girvan_newman(G))
        assert len(communities) == 3
        # After one removal, we get the graph .-. .-.
        validate_communities(communities[0], [{0, 1}, {2, 3}])
        # After the next, we get the graph .-. . ., but there are two
        # symmetric possible versions.
        validate_possible_communities(
            communities[1], [{0}, {1}, {2, 3}], [{0, 1}, {2}, {3}]
        )
        # After the last removal, we always get the empty graph.
        validate_communities(communities[2], [{0}, {1}, {2}, {3}])

    def test_directed(self):
        G = nx.DiGraph(nx.path_graph(4))
        communities = list(girvan_newman(G))
        assert len(communities) == 3
        validate_communities(communities[0], [{0, 1}, {2, 3}])
<A NAME="1"></A>        validate_possible_communities(
            communities[1], [{0}, {1}, {2, 3}], [{0, 1}, {2}, {3}]
        )
        validate_communities(communities[2], [<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4812-0.html#1',2,'match4812-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{0}, {1}, {2}, {3}])

    def test_selfloops(self):
        G = nx.path_graph(4)
        G.add_edge(0, 0)
        G.</B></FONT>add_edge(2, 2)
        communities = list(girvan_newman(G))
        assert len(communities) == 3
        validate_communities(communities[0], [{0, 1}, {2, 3}])
<A NAME="0"></A>        validate_possible_communities(
            communities[1], [{0}, {1}, {2, 3}], [{0, 1}, {2}, {3}]
        )
        validate_communities(communities<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4812-0.html#0',2,'match4812-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[2], [{0}, {1}, {2}, {3}])

    def test_most_valuable_edge(self):
        G = nx.Graph()
        G.add_weighted_edges_from([(0</B></FONT>, 1, 3), (1, 2, 2), (2, 3, 1)])
        # Let the most valuable edge be the one with the highest weight.

        def heaviest(G):
            return max(G.edges(data=&quot;weight&quot;), key=itemgetter(2))[:2]

        communities = list(girvan_newman(G, heaviest))
        assert len(communities) == 3
        validate_communities(communities[0], [{0}, {1, 2, 3}])
        validate_communities(communities[1], [{0}, {1}, {2, 3}])
        validate_communities(communities[2], [{0}, {1}, {2}, {3}])
</PRE>
</div>
  </div>
</body>
</html>
