<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for test_postgres_1.py & bigip.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for test_postgres_1.py & bigip.py
      </h3>
      <h1 align="center">
        6.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>test_postgres_1.py (6.6956997%)<TH>bigip.py (5.8851676%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#0',2,'match44314-1.html#0',3)" NAME="0">(514-537)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#0',2,'match44314-1.html#0',3)" NAME="0">(777-793)</A><TD ALIGN=center><FONT COLOR="#ff0000">19</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#1',2,'match44314-1.html#1',3)" NAME="1">(696-712)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#1',2,'match44314-1.html#1',3)" NAME="1">(960-975)</A><TD ALIGN=center><FONT COLOR="#e40000">17</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#2',2,'match44314-1.html#2',3)" NAME="2">(812-827)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#2',2,'match44314-1.html#2',3)" NAME="2">(1194-1208)</A><TD ALIGN=center><FONT COLOR="#d60000">16</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#3',2,'match44314-1.html#3',3)" NAME="3">(774-789)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#3',2,'match44314-1.html#3',3)" NAME="3">(1005-1019)</A><TD ALIGN=center><FONT COLOR="#d60000">16</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#4',2,'match44314-1.html#4',3)" NAME="4">(737-751)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#4',2,'match44314-1.html#4',3)" NAME="4">(369-382)</A><TD ALIGN=center><FONT COLOR="#c90000">15</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#5',2,'match44314-1.html#5',3)" NAME="5">(414-428)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#5',2,'match44314-1.html#5',3)" NAME="5">(338-350)</A><TD ALIGN=center><FONT COLOR="#c90000">15</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#6',2,'match44314-1.html#6',3)" NAME="6">(485-497)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#6',2,'match44314-1.html#6',3)" NAME="6">(508-519)</A><TD ALIGN=center><FONT COLOR="#ae0000">13</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match44314-0.html#7',2,'match44314-1.html#7',3)" NAME="7">(1427-1439)<TD><A HREF="javascript:ZweiFrames('match44314-0.html#7',2,'match44314-1.html#7',3)" NAME="7">(1966-1978)</A><TD ALIGN=center><FONT COLOR="#a10000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_postgres_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
import datetime
import logging
import re

import salt.modules.postgres as postgres
from salt.exceptions import SaltInvocationError
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import Mock, call, patch
from tests.support.unit import TestCase

test_list_db_csv = (
    &quot;Name,Owner,Encoding,Collate,Ctype,Access privileges,Tablespace\n&quot;
    &quot;template1,postgres,LATIN1,en_US,en_US&quot;
    ',&quot;{=c/postgres,postgres=CTc/postgres}&quot;,pg_default\n'
    &quot;template0,postgres,LATIN1,en_US,en_US&quot;
    ',&quot;{=c/postgres,postgres=CTc/postgres}&quot;,pg_default\n'
    &quot;postgres,postgres,LATIN1,en_US,en_US,,pg_default\n&quot;
    &quot;test_db,postgres,LATIN1,en_US,en_US,,pg_default&quot;
)

test_list_schema_csv = (
    &quot;name,owner,acl\n&quot;
    'public,postgres,&quot;{postgres=UC/postgres,=UC/postgres}&quot;\n'
    'pg_toast,postgres,&quot;&quot;'
)

test_list_language_csv = &quot;Name\ninternal\nc\nsql\nplpgsql\n&quot;

test_privileges_list_table_csv = (
    &quot;name\n&quot;
    '&quot;{baruwatest=arwdDxt/baruwatest,bayestest=arwd/baruwatest,baruwa=a*r*w*d*D*x*t*/baruwatest}&quot;\n'
)

test_privileges_list_group_csv = (
    &quot;rolname,admin_option\nbaruwa,f\nbaruwatest2,t\nbaruwatest,f\n&quot;
)

log = logging.getLogger(__name__)


class PostgresTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        patcher = patch(&quot;salt.utils.path.which&quot;, Mock(return_value=&quot;/usr/bin/pgsql&quot;))
        patcher.start()
        self.addCleanup(patcher.stop)
        return {
            postgres: {
                &quot;__grains__&quot;: {&quot;os_family&quot;: &quot;Linux&quot;},
                &quot;__salt__&quot;: {
                    &quot;config.option&quot;: Mock(),
                    &quot;cmd.run_all&quot;: Mock(),
                    &quot;file.chown&quot;: Mock(),
                    &quot;file.remove&quot;: Mock(),
                },
            }
        }

    def test_run_psql(self):
        postgres._run_psql('echo &quot;hi&quot;')
        cmd = postgres.__salt__[&quot;cmd.run_all&quot;]

        self.assertEqual(&quot;postgres&quot;, cmd.call_args[1][&quot;runas&quot;])

    def test_db_alter(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            postgres.db_alter(
                &quot;dbname&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                maintenance_db=&quot;maint_db&quot;,
                password=&quot;foo&quot;,
                tablespace=&quot;testspace&quot;,
                owner=&quot;otheruser&quot;,
                runas=&quot;foo&quot;,
            )
            postgres._run_psql.assert_has_calls(
                [
                    call(
                        [
                            &quot;/usr/bin/pgsql&quot;,
                            &quot;--no-align&quot;,
                            &quot;--no-readline&quot;,
                            &quot;--no-psqlrc&quot;,
                            &quot;--no-password&quot;,
                            &quot;--username&quot;,
                            &quot;testuser&quot;,
                            &quot;--host&quot;,
                            &quot;testhost&quot;,
                            &quot;--port&quot;,
                            &quot;testport&quot;,
                            &quot;--dbname&quot;,
                            &quot;maint_db&quot;,
                            &quot;-c&quot;,
                            'ALTER DATABASE &quot;dbname&quot; OWNER TO &quot;otheruser&quot;',
                        ],
                        host=&quot;testhost&quot;,
                        user=&quot;testuser&quot;,
                        password=&quot;foo&quot;,
                        runas=&quot;foo&quot;,
                        port=&quot;testport&quot;,
                    ),
                    call(
                        [
                            &quot;/usr/bin/pgsql&quot;,
                            &quot;--no-align&quot;,
                            &quot;--no-readline&quot;,
                            &quot;--no-psqlrc&quot;,
                            &quot;--no-password&quot;,
                            &quot;--username&quot;,
                            &quot;testuser&quot;,
                            &quot;--host&quot;,
                            &quot;testhost&quot;,
                            &quot;--port&quot;,
                            &quot;testport&quot;,
                            &quot;--dbname&quot;,
                            &quot;maint_db&quot;,
                            &quot;-c&quot;,
                            'ALTER DATABASE &quot;dbname&quot; SET TABLESPACE &quot;testspace&quot;',
                        ],
                        host=&quot;testhost&quot;,
                        user=&quot;testuser&quot;,
                        password=&quot;foo&quot;,
                        runas=&quot;foo&quot;,
                        port=&quot;testport&quot;,
                    ),
                ]
            )

    def test_db_alter_owner_recurse(self):
        with patch(
            &quot;salt.modules.postgres.owner_to&quot;, Mock(return_value={&quot;retcode&quot;: None})
        ):
            postgres.db_alter(
                &quot;dbname&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                maintenance_db=&quot;maint_db&quot;,
                password=&quot;foo&quot;,
                tablespace=&quot;testspace&quot;,
                owner=&quot;otheruser&quot;,
                owner_recurse=True,
                runas=&quot;foo&quot;,
            )
            postgres.owner_to.assert_called_once_with(
                &quot;dbname&quot;,
                &quot;otheruser&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                password=&quot;foo&quot;,
                runas=&quot;foo&quot;,
            )

    def test_db_create(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            postgres.db_create(
                &quot;dbname&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                maintenance_db=&quot;maint_db&quot;,
                password=&quot;foo&quot;,
                tablespace=&quot;testspace&quot;,
                owner=&quot;otheruser&quot;,
                runas=&quot;foo&quot;,
            )

            postgres._run_psql.assert_called_once_with(
                [
                    &quot;/usr/bin/pgsql&quot;,
                    &quot;--no-align&quot;,
                    &quot;--no-readline&quot;,
                    &quot;--no-psqlrc&quot;,
                    &quot;--no-password&quot;,
                    &quot;--username&quot;,
                    &quot;testuser&quot;,
                    &quot;--host&quot;,
                    &quot;testhost&quot;,
                    &quot;--port&quot;,
                    &quot;testport&quot;,
                    &quot;--dbname&quot;,
                    &quot;maint_db&quot;,
                    &quot;-c&quot;,
                    'CREATE DATABASE &quot;dbname&quot; WITH TABLESPACE = &quot;testspace&quot; '
                    'OWNER = &quot;otheruser&quot;',
                ],
                host=&quot;testhost&quot;,
                user=&quot;testuser&quot;,
                password=&quot;foo&quot;,
                runas=&quot;foo&quot;,
                port=&quot;testport&quot;,
            )

    def test_db_create_empty_string_param(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            postgres.db_create(
                &quot;dbname&quot;,
                lc_collate=&quot;&quot;,
                encoding=&quot;utf8&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=1234,
                maintenance_db=&quot;maint_db&quot;,
                password=&quot;foo&quot;,
            )

            postgres._run_psql.assert_called_once_with(
                [
                    &quot;/usr/bin/pgsql&quot;,
                    &quot;--no-align&quot;,
                    &quot;--no-readline&quot;,
                    &quot;--no-psqlrc&quot;,
                    &quot;--no-password&quot;,
                    &quot;--username&quot;,
                    &quot;testuser&quot;,
                    &quot;--host&quot;,
                    &quot;testhost&quot;,
                    &quot;--port&quot;,
                    &quot;1234&quot;,
                    &quot;--dbname&quot;,
                    &quot;maint_db&quot;,
                    &quot;-c&quot;,
                    &quot;CREATE DATABASE \&quot;dbname\&quot; WITH ENCODING = 'utf8' LC_COLLATE = ''&quot;,
                ],
                host=&quot;testhost&quot;,
                password=&quot;foo&quot;,
                port=1234,
                runas=None,
                user=&quot;testuser&quot;,
            )

    def test_db_create_with_trivial_sql_injection(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            self.assertRaises(
                SaltInvocationError,
                postgres.db_create,
                &quot;dbname&quot;,
                lc_collate=&quot;foo' ENCODING='utf8&quot;,
            )

    def test_db_exists(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_list_db_csv}),
        ):
            ret = postgres.db_exists(
                &quot;test_db&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                maintenance_db=&quot;maint_db&quot;,
                password=&quot;foo&quot;,
                runas=&quot;foo&quot;,
            )
            self.assertTrue(ret)

    def test_db_list(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_list_db_csv}),
        ):
            ret = postgres.db_list(
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                maintenance_db=&quot;maint_db&quot;,
                password=&quot;foo&quot;,
                runas=&quot;foo&quot;,
            )
            self.assertDictEqual(
                ret,
                {
                    &quot;test_db&quot;: {
                        &quot;Encoding&quot;: &quot;LATIN1&quot;,
                        &quot;Ctype&quot;: &quot;en_US&quot;,
                        &quot;Tablespace&quot;: &quot;pg_default&quot;,
                        &quot;Collate&quot;: &quot;en_US&quot;,
                        &quot;Owner&quot;: &quot;postgres&quot;,
                        &quot;Access privileges&quot;: &quot;&quot;,
                    },
                    &quot;template1&quot;: {
                        &quot;Encoding&quot;: &quot;LATIN1&quot;,
                        &quot;Ctype&quot;: &quot;en_US&quot;,
                        &quot;Tablespace&quot;: &quot;pg_default&quot;,
                        &quot;Collate&quot;: &quot;en_US&quot;,
                        &quot;Owner&quot;: &quot;postgres&quot;,
                        &quot;Access privileges&quot;: &quot;{=c/postgres,postgres=CTc/postgres}&quot;,
                    },
                    &quot;template0&quot;: {
                        &quot;Encoding&quot;: &quot;LATIN1&quot;,
                        &quot;Ctype&quot;: &quot;en_US&quot;,
                        &quot;Tablespace&quot;: &quot;pg_default&quot;,
                        &quot;Collate&quot;: &quot;en_US&quot;,
                        &quot;Owner&quot;: &quot;postgres&quot;,
                        &quot;Access privileges&quot;: &quot;{=c/postgres,postgres=CTc/postgres}&quot;,
                    },
                    &quot;postgres&quot;: {
                        &quot;Encoding&quot;: &quot;LATIN1&quot;,
                        &quot;Ctype&quot;: &quot;en_US&quot;,
                        &quot;Tablespace&quot;: &quot;pg_default&quot;,
                        &quot;Collate&quot;: &quot;en_US&quot;,
                        &quot;Owner&quot;: &quot;postgres&quot;,
                        &quot;Access privileges&quot;: &quot;&quot;,
                    },
                },
            )

    def test_db_remove(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            postgres.db_remove(
                &quot;test_db&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                maintenance_db=&quot;maint_db&quot;,
                password=&quot;foo&quot;,
                runas=&quot;foo&quot;,
            )

            calls = (
                call(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;maint_db&quot;,
                        &quot;-c&quot;,
                        'REVOKE CONNECT ON DATABASE &quot;test_db&quot; FROM public;',
                    ],
                    host=&quot;testhost&quot;,
                    password=&quot;foo&quot;,
                    port=&quot;testport&quot;,
                    runas=&quot;foo&quot;,
                    user=&quot;testuser&quot;,
                ),
                call(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;maint_db&quot;,
                        &quot;-c&quot;,
                        &quot;SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity&quot;
                        &quot; WHERE datname = 'test_db' AND pid &lt;&gt; pg_backend_pid();&quot;,
                    ],
                    host=&quot;testhost&quot;,
                    password=&quot;foo&quot;,
                    port=&quot;testport&quot;,
                    runas=&quot;foo&quot;,
                    user=&quot;testuser&quot;,
                ),
                call(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;maint_db&quot;,
                        &quot;-c&quot;,
                        'DROP DATABASE &quot;test_db&quot;;',
                    ],
                    host=&quot;testhost&quot;,
                    password=&quot;foo&quot;,
                    port=&quot;testport&quot;,
                    runas=&quot;foo&quot;,
                    user=&quot;testuser&quot;,
                ),
            )

            postgres._run_psql.assert_has_calls(calls, any_order=True)

    def test_group_create(self):
<A NAME="5"></A>        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.user_exists&quot;, Mock(return_value<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match44314-1.html#5',3,'match44314-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=False)):
                postgres.group_create(
                    &quot;testgroup&quot;,
                    user=&quot;testuser&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    maintenance_db=&quot;maint_db&quot;,
                    password=&quot;foo&quot;,
                    createdb=False,
                    encrypted=False,
                    superuser=False,
                    replication=False,
                    rolepassword=&quot;testrolepass&quot;,
                    groups=&quot;testgroup&quot;,
                    runas=</B></FONT>&quot;foo&quot;,
                )
                # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
                # The first 14 elements of this list are initial args used in all (or
                # virtually all) commands run through _run_psql(), so the actual SQL
                # query will be in the 15th argument.
                self.assertTrue(
                    postgres._run_psql.call_args[0][0][14].startswith(&quot;CREATE ROLE&quot;)
                )

    def test_group_remove(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.user_exists&quot;, Mock(return_value=True)):
                postgres.group_remove(
                    &quot;testgroup&quot;,
                    user=&quot;testuser&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    maintenance_db=&quot;maint_db&quot;,
                    password=&quot;foo&quot;,
                    runas=&quot;foo&quot;,
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;maint_db&quot;,
                        &quot;-c&quot;,
                        'DROP ROLE &quot;testgroup&quot;',
                    ],
                    host=&quot;testhost&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;foo&quot;,
                    runas=&quot;foo&quot;,
                    port=&quot;testport&quot;,
                )

    def test_group_update(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
<A NAME="6"></A>                &quot;salt.modules.postgres.role_get&quot;,
                Mock(return_value={&quot;superuser&quot;: False}),
            ):
                postgres<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match44314-1.html#6',3,'match44314-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.group_update(
                    &quot;testgroup&quot;,
                    user='&quot;testuser&quot;',
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    maintenance_db=&quot;maint_db&quot;,
                    password=&quot;foo&quot;,
                    createdb=False,
                    encrypted=False,
                    replication=False,
                    rolepassword=&quot;test_role_pass&quot;,
                    groups=&quot;testgroup&quot;,
                    runas=</B></FONT>&quot;foo&quot;,
                )
                # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
                # The first 14 elements of this list are initial args used in all (or
                # virtually all) commands run through _run_psql(), so the actual SQL
                # query will be in the 15th argument.
                self.assertTrue(
                    re.match(
                        'ALTER.* &quot;testgroup&quot; .* UNENCRYPTED PASSWORD',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )

    def test_user_create(self):
<A NAME="0"></A>        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.user_exists&quot;, Mock(return_value<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match44314-1.html#0',3,'match44314-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>=False)):
                postgres.user_create(
                    &quot;testuser&quot;,
                    user=&quot;testuser&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    maintenance_db=&quot;maint_test&quot;,
                    password=&quot;test_pass&quot;,
                    login=True,
                    createdb=False,
                    createroles=False,
                    encrypted=False,
                    superuser=False,
                    replication=False,
                    rolepassword=&quot;test_role_pass&quot;,
                    valid_until=&quot;2042-07-01&quot;,
                    groups=&quot;test_groups&quot;,
                    runas=&quot;foo&quot;,
                )
                # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
                # The first 14 elements of this list are initial args used in all (or
                # virtually all) commands run through _run_psql(), so the actual SQL
                # query will be in the 15th argument.
                call =</B></FONT> postgres._run_psql.call_args[0][0][14]
                self.assertTrue(re.match('CREATE ROLE &quot;testuser&quot;', call))
                for i in (
                    &quot;INHERIT&quot;,
                    &quot;NOCREATEDB&quot;,
                    &quot;NOCREATEROLE&quot;,
                    &quot;NOSUPERUSER&quot;,
                    &quot;NOREPLICATION&quot;,
                    &quot;LOGIN&quot;,
                    &quot;UNENCRYPTED&quot;,
                    &quot;PASSWORD&quot;,
                    &quot;VALID UNTIL&quot;,
                ):
                    self.assertTrue(i in call, &quot;{} not in {}&quot;.format(i, call))

    def test_user_exists(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.version&quot;, Mock(return_value=&quot;9.1&quot;)):
                with patch(
                    &quot;salt.modules.postgres.psql_query&quot;,
                    Mock(
                        return_value=[
                            {
                                &quot;name&quot;: &quot;test_user&quot;,
                                &quot;superuser&quot;: &quot;t&quot;,
                                &quot;inherits privileges&quot;: &quot;t&quot;,
                                &quot;can create roles&quot;: &quot;t&quot;,
                                &quot;can create databases&quot;: &quot;t&quot;,
                                &quot;can update system catalogs&quot;: &quot;t&quot;,
                                &quot;can login&quot;: &quot;t&quot;,
                                &quot;replication&quot;: None,
                                &quot;password&quot;: &quot;test_password&quot;,
                                &quot;connections&quot;: &quot;-1&quot;,
                                &quot;groups&quot;: &quot;&quot;,
                                &quot;expiry time&quot;: &quot;&quot;,
                                &quot;defaults variables&quot;: None,
                            }
                        ]
                    ),
                ):
                    ret = postgres.user_exists(
                        &quot;test_user&quot;,
                        user=&quot;test_user&quot;,
                        host=&quot;test_host&quot;,
                        port=&quot;test_port&quot;,
                        maintenance_db=&quot;maint_db&quot;,
                        password=&quot;test_password&quot;,
                        runas=&quot;foo&quot;,
                    )
                    self.assertTrue(ret)

    def test_user_list(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.version&quot;, Mock(return_value=&quot;9.1&quot;)):
                with patch(
                    &quot;salt.modules.postgres.psql_query&quot;,
                    Mock(
                        return_value=[
                            {
                                &quot;name&quot;: &quot;test_user&quot;,
                                &quot;superuser&quot;: &quot;t&quot;,
                                &quot;inherits privileges&quot;: &quot;t&quot;,
                                &quot;can create roles&quot;: &quot;t&quot;,
                                &quot;can create databases&quot;: &quot;t&quot;,
                                &quot;can update system catalogs&quot;: &quot;t&quot;,
                                &quot;can login&quot;: &quot;t&quot;,
                                &quot;replication&quot;: None,
                                &quot;connections&quot;: &quot;-1&quot;,
                                &quot;groups&quot;: &quot;&quot;,
                                &quot;expiry time&quot;: &quot;2017-08-16 08:57:46&quot;,
                                &quot;defaults variables&quot;: None,
                            }
                        ]
                    ),
                ):
                    ret = postgres.user_list(
                        &quot;test_user&quot;,
                        host=&quot;test_host&quot;,
                        port=&quot;test_port&quot;,
                        maintenance_db=&quot;maint_db&quot;,
                        password=&quot;test_password&quot;,
                        runas=&quot;foo&quot;,
                    )

                    self.assertDictEqual(
                        ret,
                        {
                            &quot;test_user&quot;: {
                                &quot;superuser&quot;: True,
                                &quot;defaults variables&quot;: None,
                                &quot;can create databases&quot;: True,
                                &quot;can create roles&quot;: True,
                                &quot;connections&quot;: None,
                                &quot;replication&quot;: None,
                                &quot;expiry time&quot;: datetime.datetime(
                                    2017, 8, 16, 8, 57, 46
                                ),
                                &quot;can login&quot;: True,
                                &quot;can update system catalogs&quot;: True,
                                &quot;groups&quot;: [],
                                &quot;inherits privileges&quot;: True,
                            }
                        },
                    )

    def test_user_remove(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.version&quot;, Mock(return_value=&quot;9.1&quot;)):
                with patch(
                    &quot;salt.modules.postgres.user_exists&quot;, Mock(return_value=True)
                ):
                    postgres.user_remove(
                        &quot;testuser&quot;,
                        user=&quot;testuser&quot;,
                        host=&quot;testhost&quot;,
                        port=&quot;testport&quot;,
                        maintenance_db=&quot;maint_db&quot;,
                        password=&quot;testpassword&quot;,
                        runas=&quot;foo&quot;,
                    )
                    postgres._run_psql.assert_called_once_with(
                        [
                            &quot;/usr/bin/pgsql&quot;,
                            &quot;--no-align&quot;,
                            &quot;--no-readline&quot;,
                            &quot;--no-psqlrc&quot;,
                            &quot;--no-password&quot;,
                            &quot;--username&quot;,
                            &quot;testuser&quot;,
                            &quot;--host&quot;,
                            &quot;testhost&quot;,
                            &quot;--port&quot;,
                            &quot;testport&quot;,
                            &quot;--dbname&quot;,
                            &quot;maint_db&quot;,
                            &quot;-c&quot;,
                            'DROP ROLE &quot;testuser&quot;',
                        ],
                        host=&quot;testhost&quot;,
                        port=&quot;testport&quot;,
                        user=&quot;testuser&quot;,
                        password=&quot;testpassword&quot;,
                        runas=&quot;foo&quot;,
                    )

    def test_user_update(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
<A NAME="1"></A>                &quot;salt.modules.postgres.role_get&quot;,
                Mock(return_value={&quot;superuser&quot;: False}),
            ):
                postgres<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match44314-1.html#1',3,'match44314-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.user_update(
                    &quot;test_username&quot;,
                    user=&quot;test_user&quot;,
                    host=&quot;test_host&quot;,
                    port=&quot;test_port&quot;,
                    maintenance_db=&quot;test_maint&quot;,
                    password=&quot;test_pass&quot;,
                    createdb=False,
                    createroles=False,
                    encrypted=False,
                    inherit=True,
                    login=True,
                    replication=False,
                    rolepassword=&quot;test_role_pass&quot;,
                    valid_until=&quot;2017-07-01&quot;,
                    groups=&quot;test_groups&quot;,
                    runas=</B></FONT>&quot;foo&quot;,
                )
                # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
                # The first 14 elements of this list are initial args used in all (or
                # virtually all) commands run through _run_psql(), so the actual SQL
                # query will be in the 15th argument.
                self.assertTrue(
                    re.match(
                        'ALTER ROLE &quot;test_username&quot; WITH  INHERIT NOCREATEDB '
                        &quot;NOCREATEROLE NOREPLICATION LOGIN &quot;
                        &quot;UNENCRYPTED PASSWORD ['\&quot;]{0,5}test_role_pass['\&quot;]{0,5} &quot;
                        &quot;VALID UNTIL '2017-07-01';&quot;
                        ' GRANT &quot;test_groups&quot; TO &quot;test_username&quot;',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )

    def test_user_update2(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
<A NAME="4"></A>                &quot;salt.modules.postgres.role_get&quot;,
                Mock(return_value={&quot;superuser&quot;: False}),
            ):
                postgres<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match44314-1.html#4',3,'match44314-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.user_update(
                    &quot;test_username&quot;,
                    user=&quot;test_user&quot;,
                    host=&quot;test_host&quot;,
                    port=&quot;test_port&quot;,
                    maintenance_db=&quot;test_maint&quot;,
                    password=&quot;test_pass&quot;,
                    createdb=False,
                    createroles=True,
                    encrypted=False,
                    inherit=True,
                    login=True,
                    replication=False,
                    groups=&quot;test_groups&quot;,
                    runas=</B></FONT>&quot;foo&quot;,
                )
                # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
                # The first 14 elements of this list are initial args used in all (or
                # virtually all) commands run through _run_psql(), so the actual SQL
                # query will be in the 15th argument.
                self.assertTrue(
                    re.match(
                        'ALTER ROLE &quot;test_username&quot; WITH  INHERIT NOCREATEDB '
                        &quot;CREATEROLE NOREPLICATION LOGIN;&quot;
                        ' GRANT &quot;test_groups&quot; TO &quot;test_username&quot;',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )

    def test_user_update3(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
<A NAME="3"></A>                &quot;salt.modules.postgres.role_get&quot;,
                Mock(return_value={&quot;superuser&quot;: False}),
            ):
                postgres<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match44314-1.html#3',3,'match44314-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.user_update(
                    &quot;test_username&quot;,
                    user=&quot;test_user&quot;,
                    host=&quot;test_host&quot;,
                    port=&quot;test_port&quot;,
                    maintenance_db=&quot;test_maint&quot;,
                    password=&quot;test_pass&quot;,
                    createdb=False,
                    createroles=True,
                    encrypted=False,
                    inherit=True,
                    login=True,
                    rolepassword=False,
                    replication=False,
                    groups=&quot;test_groups&quot;,
                    runas=</B></FONT>&quot;foo&quot;,
                )
                # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
                # The first 14 elements of this list are initial args used in all (or
                # virtually all) commands run through _run_psql(), so the actual SQL
                # query will be in the 15th argument.
                self.assertTrue(
                    re.match(
                        'ALTER ROLE &quot;test_username&quot; WITH  INHERIT NOCREATEDB '
                        &quot;CREATEROLE NOREPLICATION LOGIN NOPASSWORD;&quot;
                        ' GRANT &quot;test_groups&quot; TO &quot;test_username&quot;',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )

    def test_user_update_encrypted_passwd(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
<A NAME="2"></A>                &quot;salt.modules.postgres.role_get&quot;,
                Mock(return_value={&quot;superuser&quot;: False}),
            ):
                postgres<FONT color="#980517"><A HREF="javascript:ZweiFrames('match44314-1.html#2',3,'match44314-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>.user_update(
                    &quot;test_username&quot;,
                    user=&quot;test_user&quot;,
                    host=&quot;test_host&quot;,
                    port=&quot;test_port&quot;,
                    maintenance_db=&quot;test_maint&quot;,
                    password=&quot;test_pass&quot;,
                    createdb=False,
                    createroles=True,
                    encrypted=True,
                    inherit=True,
                    login=True,
                    rolepassword=&quot;foobar&quot;,
                    replication=False,
                    groups=&quot;test_groups&quot;,
                    runas=</B></FONT>&quot;foo&quot;,
                )
                # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
                # The first 14 elements of this list are initial args used in all (or
                # virtually all) commands run through _run_psql(), so the actual SQL
                # query will be in the 15th argument.
                self.assertTrue(
                    re.match(
                        'ALTER ROLE &quot;test_username&quot; WITH  INHERIT NOCREATEDB '
                        &quot;CREATEROLE NOREPLICATION LOGIN &quot;
                        &quot;ENCRYPTED PASSWORD &quot;
                        &quot;['\&quot;]{0,5}md531c27e68d3771c392b52102c01be1da1['\&quot;]{0,5}&quot;
                        '; GRANT &quot;test_groups&quot; TO &quot;test_username&quot;',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )

    def test_version(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: &quot;9.1.9&quot;}),
        ):
            postgres.version(
                user=&quot;test_user&quot;,
                host=&quot;test_host&quot;,
                port=&quot;test_port&quot;,
                maintenance_db=&quot;test_maint&quot;,
                password=&quot;test_pass&quot;,
                runas=&quot;foo&quot;,
            )
            # postgres._run_psql.call_args[0][0] will contain the list of CLI args.
            # The first 14 elements of this list are initial args used in all (or
            # virtually all) commands run through _run_psql(), so the actual SQL
            # query will be in the 15th argument.
            self.assertTrue(
                re.match(
                    &quot;SELECT setting FROM pg_catalog.pg_settings&quot;,
                    postgres._run_psql.call_args[0][0][14],
                )
            )

    def test_installed_extensions(self):
        with patch(
            &quot;salt.modules.postgres.psql_query&quot;,
            Mock(return_value=[{&quot;extname&quot;: &quot;foo&quot;, &quot;extversion&quot;: &quot;1&quot;}]),
        ):
            exts = postgres.installed_extensions()
            self.assertEqual(exts, {&quot;foo&quot;: {&quot;extversion&quot;: &quot;1&quot;, &quot;extname&quot;: &quot;foo&quot;}})

    def test_available_extensions(self):
        with patch(
            &quot;salt.modules.postgres.psql_query&quot;,
            Mock(return_value=[{&quot;name&quot;: &quot;foo&quot;, &quot;default_version&quot;: &quot;1&quot;}]),
        ):
            exts = postgres.available_extensions()
            self.assertEqual(exts, {&quot;foo&quot;: {&quot;default_version&quot;: &quot;1&quot;, &quot;name&quot;: &quot;foo&quot;}})

    def test_drop_extension2(self):
        with patch(
            &quot;salt.modules.postgres.installed_extensions&quot;, Mock(side_effect=[{}, {}])
        ):
            with patch(
                &quot;salt.modules.postgres._psql_prepare_and_run&quot;, Mock(return_value=None)
            ):
                with patch(
                    &quot;salt.modules.postgres.available_extensions&quot;,
                    Mock(return_value={&quot;foo&quot;: {&quot;default_version&quot;: &quot;1&quot;, &quot;name&quot;: &quot;foo&quot;}}),
                ):
                    self.assertEqual(postgres.drop_extension(&quot;foo&quot;), True)

    def test_drop_extension3(self):
        with patch(
            &quot;salt.modules.postgres.installed_extensions&quot;,
            Mock(side_effect=[{&quot;foo&quot;: {&quot;extversion&quot;: &quot;1&quot;, &quot;extname&quot;: &quot;foo&quot;}}, {}]),
        ):
            with patch(
                &quot;salt.modules.postgres._psql_prepare_and_run&quot;, Mock(return_value=None)
            ):
                with patch(
                    &quot;salt.modules.postgres.available_extensions&quot;,
                    Mock(return_value={&quot;foo&quot;: {&quot;default_version&quot;: &quot;1&quot;, &quot;name&quot;: &quot;foo&quot;}}),
                ):
                    self.assertEqual(postgres.drop_extension(&quot;foo&quot;), True)

    def test_drop_extension1(self):
        with patch(
            &quot;salt.modules.postgres.installed_extensions&quot;,
            Mock(
                side_effect=[
                    {&quot;foo&quot;: {&quot;extversion&quot;: &quot;1&quot;, &quot;extname&quot;: &quot;foo&quot;}},
                    {&quot;foo&quot;: {&quot;extversion&quot;: &quot;1&quot;, &quot;extname&quot;: &quot;foo&quot;}},
                ]
            ),
        ):
            with patch(
                &quot;salt.modules.postgres._psql_prepare_and_run&quot;, Mock(return_value=None)
            ):
                with patch(
                    &quot;salt.modules.postgres.available_extensions&quot;,
                    Mock(return_value={&quot;foo&quot;: {&quot;default_version&quot;: &quot;1&quot;, &quot;name&quot;: &quot;foo&quot;}}),
                ):
                    self.assertEqual(postgres.drop_extension(&quot;foo&quot;), False)

    def test_create_mtdata(self):
        with patch(
            &quot;salt.modules.postgres.installed_extensions&quot;,
            Mock(
                return_value={
                    &quot;foo&quot;: {
                        &quot;extversion&quot;: &quot;0.8&quot;,
                        &quot;extrelocatable&quot;: &quot;t&quot;,
                        &quot;schema_name&quot;: &quot;foo&quot;,
                        &quot;extname&quot;: &quot;foo&quot;,
                    }
                },
            ),
        ):
            with patch(
                &quot;salt.modules.postgres.available_extensions&quot;,
                Mock(return_value={&quot;foo&quot;: {&quot;default_version&quot;: &quot;1.4&quot;, &quot;name&quot;: &quot;foo&quot;}}),
            ):
                ret = postgres.create_metadata(&quot;foo&quot;, schema=&quot;bar&quot;, ext_version=&quot;1.4&quot;)
                self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
                self.assertTrue(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertTrue(postgres._EXTENSION_TO_MOVE in ret)
                ret = postgres.create_metadata(&quot;foo&quot;, schema=&quot;foo&quot;, ext_version=&quot;0.4&quot;)
                self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
                ret = postgres.create_metadata(&quot;foo&quot;)
                self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
                ret = postgres.create_metadata(&quot;foobar&quot;)
                self.assertTrue(postgres._EXTENSION_NOT_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)

    def test_create_extension_newerthan(self):
        &quot;&quot;&quot;
        scenario of creating upgrading extensions with possible schema and
        version specifications
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres.create_metadata&quot;,
            Mock(
                side_effect=[
                    # create succeeded
                    [postgres._EXTENSION_NOT_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_NOT_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    # create failed
                    [postgres._EXTENSION_NOT_INSTALLED],
                    [postgres._EXTENSION_NOT_INSTALLED],
                    # move+upgrade succeeded
                    [
                        postgres._EXTENSION_TO_MOVE,
                        postgres._EXTENSION_TO_UPGRADE,
                        postgres._EXTENSION_INSTALLED,
                    ],
                    [postgres._EXTENSION_INSTALLED],
                    # move succeeded
                    [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    # upgrade succeeded
                    [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    # upgrade failed
                    [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
                    # move failed
                    [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
                ]
            ),
        ):
            with patch(
                &quot;salt.modules.postgres._psql_prepare_and_run&quot;, Mock(return_value=None)
            ):
                with patch(
                    &quot;salt.modules.postgres.available_extensions&quot;,
                    Mock(
                        return_value={&quot;foo&quot;: {&quot;default_version&quot;: &quot;1.4&quot;, &quot;name&quot;: &quot;foo&quot;}}
                    ),
                ):
                    self.assertTrue(postgres.create_extension(&quot;foo&quot;))
                    self.assertTrue(
                        re.match(
                            'CREATE EXTENSION IF NOT EXISTS &quot;foo&quot; ;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    self.assertTrue(
                        postgres.create_extension(
                            &quot;foo&quot;, schema=&quot;a&quot;, ext_version=&quot;b&quot;, from_version=&quot;c&quot;
                        )
                    )
                    self.assertTrue(
                        re.match(
                            'CREATE EXTENSION IF NOT EXISTS &quot;foo&quot; '
                            'WITH SCHEMA &quot;a&quot; VERSION b FROM c ;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    self.assertFalse(postgres.create_extension(&quot;foo&quot;))
                    ret = postgres.create_extension(&quot;foo&quot;, ext_version=&quot;a&quot;, schema=&quot;b&quot;)
                    self.assertTrue(ret)
                    self.assertTrue(
                        re.match(
                            'ALTER EXTENSION &quot;foo&quot; SET SCHEMA &quot;b&quot;;'
                            ' ALTER EXTENSION &quot;foo&quot; UPDATE TO a;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    ret = postgres.create_extension(&quot;foo&quot;, ext_version=&quot;a&quot;, schema=&quot;b&quot;)
                    self.assertTrue(ret)
                    self.assertTrue(
                        re.match(
                            'ALTER EXTENSION &quot;foo&quot; SET SCHEMA &quot;b&quot;;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    ret = postgres.create_extension(&quot;foo&quot;, ext_version=&quot;a&quot;, schema=&quot;b&quot;)
                    self.assertTrue(ret)
                    self.assertTrue(
                        re.match(
                            'ALTER EXTENSION &quot;foo&quot; UPDATE TO a;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    self.assertFalse(
                        postgres.create_extension(&quot;foo&quot;, ext_version=&quot;a&quot;, schema=&quot;b&quot;)
                    )
                    self.assertFalse(
                        postgres.create_extension(&quot;foo&quot;, ext_version=&quot;a&quot;, schema=&quot;b&quot;)
                    )

    def test_encrypt_passwords(self):
        self.assertEqual(postgres._maybe_encrypt_password(&quot;foo&quot;, &quot;bar&quot;, False), &quot;bar&quot;)
        self.assertEqual(
            postgres._maybe_encrypt_password(&quot;foo&quot;, &quot;bar&quot;, True),
            &quot;md596948aad3fcae80c08a35c9b5958cd89&quot;,
        )

    def test_schema_list(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_list_schema_csv}),
        ):
            ret = postgres.schema_list(
                &quot;maint_db&quot;,
                db_user=&quot;testuser&quot;,
                db_host=&quot;testhost&quot;,
                db_port=&quot;testport&quot;,
                db_password=&quot;foo&quot;,
            )
            self.assertDictEqual(
                ret,
                {
                    &quot;public&quot;: {
                        &quot;acl&quot;: &quot;{postgres=UC/postgres,=UC/postgres}&quot;,
                        &quot;owner&quot;: &quot;postgres&quot;,
                    },
                    &quot;pg_toast&quot;: {&quot;acl&quot;: &quot;&quot;, &quot;owner&quot;: &quot;postgres&quot;},
                },
            )

    def test_schema_exists(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.psql_query&quot;,
                Mock(
                    return_value=[
                        {
                            &quot;name&quot;: &quot;public&quot;,
                            &quot;acl&quot;: &quot;{postgres=UC/postgres,=UC/postgres}&quot;,
                            &quot;owner&quot;: &quot;postgres&quot;,
                        }
                    ]
                ),
            ):
                ret = postgres.schema_exists(&quot;template1&quot;, &quot;public&quot;)
                self.assertTrue(ret)

    def test_schema_get(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.psql_query&quot;,
                Mock(
                    return_value=[
                        {
                            &quot;name&quot;: &quot;public&quot;,
                            &quot;acl&quot;: &quot;{postgres=UC/postgres,=UC/postgres}&quot;,
                            &quot;owner&quot;: &quot;postgres&quot;,
                        }
                    ]
                ),
            ):
                ret = postgres.schema_get(&quot;template1&quot;, &quot;public&quot;)
                self.assertTrue(ret)

    def test_schema_get_again(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.psql_query&quot;,
                Mock(
                    return_value=[
                        {
                            &quot;name&quot;: &quot;public&quot;,
                            &quot;acl&quot;: &quot;{postgres=UC/postgres,=UC/postgres}&quot;,
                            &quot;owner&quot;: &quot;postgres&quot;,
                        }
                    ]
                ),
            ):
                ret = postgres.schema_get(&quot;template1&quot;, &quot;pg_toast&quot;)
                self.assertFalse(ret)

    def test_schema_create(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.schema_exists&quot;, Mock(return_value=False)):
                postgres.schema_create(
                    &quot;maint_db&quot;,
                    &quot;testschema&quot;,
                    user=&quot;user&quot;,
                    db_host=&quot;testhost&quot;,
                    db_port=&quot;testport&quot;,
                    db_user=&quot;testuser&quot;,
                    db_password=&quot;testpassword&quot;,
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;maint_db&quot;,
                        &quot;-c&quot;,
                        'CREATE SCHEMA &quot;testschema&quot;',
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_schema_create2(self):
        with patch(&quot;salt.modules.postgres.schema_exists&quot;, Mock(return_value=True)):
            ret = postgres.schema_create(
                &quot;test_db&quot;,
                &quot;test_schema&quot;,
                user=&quot;user&quot;,
                db_host=&quot;test_host&quot;,
                db_port=&quot;test_port&quot;,
                db_user=&quot;test_user&quot;,
                db_password=&quot;test_password&quot;,
            )
            self.assertFalse(ret)

    def test_schema_remove(self):
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.schema_exists&quot;, Mock(return_value=True)):
                postgres.schema_remove(
                    &quot;maint_db&quot;,
                    &quot;testschema&quot;,
                    user=&quot;user&quot;,
                    db_host=&quot;testhost&quot;,
                    db_port=&quot;testport&quot;,
                    db_user=&quot;testuser&quot;,
                    db_password=&quot;testpassword&quot;,
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;maint_db&quot;,
                        &quot;-c&quot;,
                        'DROP SCHEMA &quot;testschema&quot;',
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_schema_remove2(self):
        with patch(&quot;salt.modules.postgres.schema_exists&quot;, Mock(return_value=False)):
            ret = postgres.schema_remove(
                &quot;test_db&quot;,
                &quot;test_schema&quot;,
                user=&quot;user&quot;,
                db_host=&quot;test_host&quot;,
                db_port=&quot;test_port&quot;,
                db_user=&quot;test_user&quot;,
                db_password=&quot;test_password&quot;,
            )
            self.assertFalse(ret)

    def test_language_list(self):
        &quot;&quot;&quot;
        Test language listing
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_list_language_csv}),
        ):
            ret = postgres.language_list(
                &quot;testdb&quot;,
                user=&quot;testuser&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                password=&quot;foo&quot;,
            )
            self.assertDictEqual(
                ret,
                {&quot;c&quot;: &quot;c&quot;, &quot;internal&quot;: &quot;internal&quot;, &quot;plpgsql&quot;: &quot;plpgsql&quot;, &quot;sql&quot;: &quot;sql&quot;},
            )

    def test_language_exists(self):
        &quot;&quot;&quot;
        Test language existence check
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.psql_query&quot;,
                Mock(
                    return_value=[
                        {&quot;Name&quot;: &quot;internal&quot;},
                        {&quot;Name&quot;: &quot;c&quot;},
                        {&quot;Name&quot;: &quot;sql&quot;},
                        {&quot;Name&quot;: &quot;plpgsql&quot;},
                    ]
                ),
            ):
                with patch(
                    &quot;salt.modules.postgres.language_exists&quot;, Mock(return_value=True)
                ):
                    ret = postgres.language_exists(&quot;sql&quot;, &quot;testdb&quot;)
                    self.assertTrue(ret)

    def test_language_create(self):
        &quot;&quot;&quot;
        Test language creation - does not exist in db
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.language_exists&quot;, Mock(return_value=False)
            ):
                postgres.language_create(
                    &quot;plpythonu&quot;,
                    &quot;testdb&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;testdb&quot;,
                        &quot;-c&quot;,
                        &quot;CREATE LANGUAGE plpythonu&quot;,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_language_create_exists(self):
        &quot;&quot;&quot;
        Test language creation - already exists in db
        &quot;&quot;&quot;
        with patch(&quot;salt.modules.postgres.language_exists&quot;, Mock(return_value=True)):
            ret = postgres.language_create(
                &quot;plpythonu&quot;,
                &quot;testdb&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )
            self.assertFalse(ret)

    def test_language_remove(self):
        &quot;&quot;&quot;
        Test language removal - exists in db
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.language_exists&quot;, Mock(return_value=True)
            ):
                postgres.language_remove(
                    &quot;plpgsql&quot;,
                    &quot;testdb&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;testdb&quot;,
                        &quot;-c&quot;,
                        &quot;DROP LANGUAGE plpgsql&quot;,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_language_remove_non_exist(self):
        &quot;&quot;&quot;
        Test language removal - does not exist in db
        &quot;&quot;&quot;
        with patch(&quot;salt.modules.postgres.language_exists&quot;, Mock(return_value=False)):
            ret = postgres.language_remove(
                &quot;plpgsql&quot;,
                &quot;testdb&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )
            self.assertFalse(ret)

    def test_privileges_list_table(self):
        &quot;&quot;&quot;
        Test privilege listing on a table
<A NAME="7"></A>        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match44314-1.html#7',3,'match44314-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_privileges_list_table_csv}),
        ):
            ret = postgres.privileges_list(
                &quot;awl&quot;,
                &quot;table&quot;,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )
            expected =</B></FONT> {
                &quot;bayestest&quot;: {
                    &quot;INSERT&quot;: False,
                    &quot;UPDATE&quot;: False,
                    &quot;SELECT&quot;: False,
                    &quot;DELETE&quot;: False,
                },
                &quot;baruwa&quot;: {
                    &quot;INSERT&quot;: True,
                    &quot;TRUNCATE&quot;: True,
                    &quot;UPDATE&quot;: True,
                    &quot;TRIGGER&quot;: True,
                    &quot;REFERENCES&quot;: True,
                    &quot;SELECT&quot;: True,
                    &quot;DELETE&quot;: True,
                },
                &quot;baruwatest&quot;: {
                    &quot;INSERT&quot;: False,
                    &quot;TRUNCATE&quot;: False,
                    &quot;UPDATE&quot;: False,
                    &quot;TRIGGER&quot;: False,
                    &quot;REFERENCES&quot;: False,
                    &quot;SELECT&quot;: False,
                    &quot;DELETE&quot;: False,
                },
            }

            self.assertDictEqual(ret, expected)

            query = (
                &quot;COPY (SELECT relacl AS name FROM pg_catalog.pg_class c &quot;
                &quot;JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace &quot;
                &quot;WHERE nspname = 'public' AND relname = 'awl' AND relkind = 'r' &quot;
                &quot;ORDER BY relname) TO STDOUT WITH CSV HEADER&quot;
            )

            postgres._run_psql.assert_called_once_with(
                [
                    &quot;/usr/bin/pgsql&quot;,
                    &quot;--no-align&quot;,
                    &quot;--no-readline&quot;,
                    &quot;--no-psqlrc&quot;,
                    &quot;--no-password&quot;,
                    &quot;--username&quot;,
                    &quot;testuser&quot;,
                    &quot;--host&quot;,
                    &quot;testhost&quot;,
                    &quot;--port&quot;,
                    &quot;testport&quot;,
                    &quot;--dbname&quot;,
                    &quot;db_name&quot;,
                    &quot;-v&quot;,
                    &quot;datestyle=ISO,MDY&quot;,
                    &quot;-c&quot;,
                    query,
                ],
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                password=&quot;testpassword&quot;,
                user=&quot;testuser&quot;,
                runas=&quot;user&quot;,
            )

    def test_privileges_list_group(self):
        &quot;&quot;&quot;
        Test privilege listing on a group
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_privileges_list_group_csv}),
        ):
            ret = postgres.privileges_list(
                &quot;admin&quot;,
                &quot;group&quot;,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )
            expected = {
                &quot;baruwa&quot;: False,
                &quot;baruwatest&quot;: False,
                &quot;baruwatest2&quot;: True,
            }

            self.assertDictEqual(ret, expected)

            query = (
                &quot;COPY (SELECT rolname, admin_option &quot;
                &quot;FROM pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles r &quot;
                &quot;ON m.member=r.oid WHERE m.roleid IN (SELECT oid FROM &quot;
                &quot;pg_catalog.pg_roles WHERE rolname='admin') ORDER BY rolname) &quot;
                &quot;TO STDOUT WITH CSV HEADER&quot;
            )

            postgres._run_psql.assert_called_once_with(
                [
                    &quot;/usr/bin/pgsql&quot;,
                    &quot;--no-align&quot;,
                    &quot;--no-readline&quot;,
                    &quot;--no-psqlrc&quot;,
                    &quot;--no-password&quot;,
                    &quot;--username&quot;,
                    &quot;testuser&quot;,
                    &quot;--host&quot;,
                    &quot;testhost&quot;,
                    &quot;--port&quot;,
                    &quot;testport&quot;,
                    &quot;--dbname&quot;,
                    &quot;db_name&quot;,
                    &quot;-v&quot;,
                    &quot;datestyle=ISO,MDY&quot;,
                    &quot;-c&quot;,
                    query,
                ],
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                password=&quot;testpassword&quot;,
                user=&quot;testuser&quot;,
                runas=&quot;user&quot;,
            )

    def test_has_privileges_on_table(self):
        &quot;&quot;&quot;
        Test privilege checks on table
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_privileges_list_table_csv}),
        ):
            ret = postgres.has_privileges(
                &quot;baruwa&quot;,
                &quot;awl&quot;,
                &quot;table&quot;,
                &quot;SELECT,INSERT&quot;,
                grant_option=True,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertTrue(ret)

            ret = postgres.has_privileges(
                &quot;baruwa&quot;,
                &quot;awl&quot;,
                &quot;table&quot;,
                &quot;ALL&quot;,
                grant_option=True,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertTrue(ret)

            ret = postgres.has_privileges(
                &quot;baruwa&quot;,
                &quot;awl&quot;,
                &quot;table&quot;,
                &quot;ALL&quot;,
                grant_option=False,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertTrue(ret)

            ret = postgres.has_privileges(
                &quot;bayestest&quot;,
                &quot;awl&quot;,
                &quot;table&quot;,
                &quot;SELECT,INSERT,TRUNCATE&quot;,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertFalse(ret)

            ret = postgres.has_privileges(
                &quot;bayestest&quot;,
                &quot;awl&quot;,
                &quot;table&quot;,
                &quot;SELECT,INSERT&quot;,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertTrue(ret)

    def test_has_privileges_on_group(self):
        &quot;&quot;&quot;
        Test privilege checks on group
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;,
            Mock(return_value={&quot;retcode&quot;: 0, &quot;stdout&quot;: test_privileges_list_group_csv}),
        ):
            ret = postgres.has_privileges(
                &quot;baruwa&quot;,
                &quot;admin&quot;,
                &quot;group&quot;,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertTrue(ret)

            ret = postgres.has_privileges(
                &quot;baruwa&quot;,
                &quot;admin&quot;,
                &quot;group&quot;,
                grant_option=True,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertFalse(ret)

            ret = postgres.has_privileges(
                &quot;tony&quot;,
                &quot;admin&quot;,
                &quot;group&quot;,
                maintenance_db=&quot;db_name&quot;,
                runas=&quot;user&quot;,
                host=&quot;testhost&quot;,
                port=&quot;testport&quot;,
                user=&quot;testuser&quot;,
                password=&quot;testpassword&quot;,
            )

            self.assertFalse(ret)

    def test_privileges_grant_table(self):
        &quot;&quot;&quot;
        Test granting privileges on table
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.has_privileges&quot;, Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    &quot;baruwa&quot;,
                    &quot;awl&quot;,
                    &quot;table&quot;,
                    &quot;ALL&quot;,
                    grant_option=True,
                    maintenance_db=&quot;db_name&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )

                query = 'GRANT ALL ON TABLE public.&quot;awl&quot; TO &quot;baruwa&quot; WITH GRANT OPTION'

                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;db_name&quot;,
                        &quot;-c&quot;,
                        query,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.has_privileges&quot;, Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    &quot;baruwa&quot;,
                    &quot;awl&quot;,
                    &quot;table&quot;,
                    &quot;ALL&quot;,
                    maintenance_db=&quot;db_name&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )

                query = 'GRANT ALL ON TABLE public.&quot;awl&quot; TO &quot;baruwa&quot;'

                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;db_name&quot;,
                        &quot;-c&quot;,
                        query,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

        # Test grant on all tables
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.has_privileges&quot;, Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    &quot;baruwa&quot;,
                    &quot;ALL&quot;,
                    &quot;table&quot;,
                    &quot;SELECT&quot;,
                    maintenance_db=&quot;db_name&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )

                query = 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO &quot;baruwa&quot;'

                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;db_name&quot;,
                        &quot;-c&quot;,
                        query,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_privileges_grant_group(self):
        &quot;&quot;&quot;
        Test granting privileges on group
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.has_privileges&quot;, Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    &quot;baruwa&quot;,
                    &quot;admins&quot;,
                    &quot;group&quot;,
                    grant_option=True,
                    maintenance_db=&quot;db_name&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )

                query = 'GRANT admins TO &quot;baruwa&quot; WITH ADMIN OPTION'

                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;db_name&quot;,
                        &quot;-c&quot;,
                        query,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.has_privileges&quot;, Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    &quot;baruwa&quot;,
                    &quot;admins&quot;,
                    &quot;group&quot;,
                    maintenance_db=&quot;db_name&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )

                query = 'GRANT admins TO &quot;baruwa&quot;'

                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;db_name&quot;,
                        &quot;-c&quot;,
                        query,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_privileges_revoke_table(self):
        &quot;&quot;&quot;
        Test revoking privileges on table
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.has_privileges&quot;, Mock(return_value=True)):
                ret = postgres.privileges_revoke(
                    &quot;baruwa&quot;,
                    &quot;awl&quot;,
                    &quot;table&quot;,
                    &quot;ALL&quot;,
                    maintenance_db=&quot;db_name&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )

                query = &quot;REVOKE ALL ON TABLE public.awl FROM baruwa&quot;

                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;db_name&quot;,
                        &quot;-c&quot;,
                        query,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_privileges_revoke_group(self):
        &quot;&quot;&quot;
        Test revoking privileges on group
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_psql&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(&quot;salt.modules.postgres.has_privileges&quot;, Mock(return_value=True)):
                ret = postgres.privileges_revoke(
                    &quot;baruwa&quot;,
                    &quot;admins&quot;,
                    &quot;group&quot;,
                    maintenance_db=&quot;db_name&quot;,
                    runas=&quot;user&quot;,
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    user=&quot;testuser&quot;,
                    password=&quot;testpassword&quot;,
                )

                query = &quot;REVOKE admins FROM baruwa&quot;

                postgres._run_psql.assert_called_once_with(
                    [
                        &quot;/usr/bin/pgsql&quot;,
                        &quot;--no-align&quot;,
                        &quot;--no-readline&quot;,
                        &quot;--no-psqlrc&quot;,
                        &quot;--no-password&quot;,
                        &quot;--username&quot;,
                        &quot;testuser&quot;,
                        &quot;--host&quot;,
                        &quot;testhost&quot;,
                        &quot;--port&quot;,
                        &quot;testport&quot;,
                        &quot;--dbname&quot;,
                        &quot;db_name&quot;,
                        &quot;-c&quot;,
                        query,
                    ],
                    host=&quot;testhost&quot;,
                    port=&quot;testport&quot;,
                    password=&quot;testpassword&quot;,
                    user=&quot;testuser&quot;,
                    runas=&quot;user&quot;,
                )

    def test_datadir_init(self):
        &quot;&quot;&quot;
        Test Initializing a postgres data directory
        &quot;&quot;&quot;
        with patch(
            &quot;salt.modules.postgres._run_initdb&quot;, Mock(return_value={&quot;retcode&quot;: 0})
        ):
            with patch(
                &quot;salt.modules.postgres.datadir_exists&quot;, Mock(return_value=False)
            ):
                name = &quot;/var/lib/pgsql/data&quot;
                ret = postgres.datadir_init(
                    name, user=&quot;postgres&quot;, password=&quot;test&quot;, runas=&quot;postgres&quot;
                )
                postgres._run_initdb.assert_called_once_with(
                    name,
                    auth=&quot;password&quot;,
                    encoding=&quot;UTF8&quot;,
                    locale=None,
                    password=&quot;test&quot;,
                    runas=&quot;postgres&quot;,
                    checksums=False,
                    waldir=None,
                    user=&quot;postgres&quot;,
                )
                self.assertTrue(ret)

    def test_datadir_exists(self):
        &quot;&quot;&quot;
        Test Checks if postgres data directory has been initialized
        &quot;&quot;&quot;
        with patch(&quot;os.path.isfile&quot;, Mock(return_value=True)):
            name = &quot;/var/lib/pgsql/data&quot;
            ret = postgres.datadir_exists(name)
            self.assertTrue(ret)

    def test_pg_is_older_ext_ver(self):
        &quot;&quot;&quot;
        Test Checks if postgres extension version string is older
        &quot;&quot;&quot;
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;8.5&quot;, &quot;9.5&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;8.5&quot;, &quot;8.6&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;8.5.2&quot;, &quot;8.5.3&quot;))
        self.assertFalse(postgres._pg_is_older_ext_ver(&quot;9.5&quot;, &quot;8.5&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;9.5&quot;, &quot;9.6&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;9.5.0&quot;, &quot;9.5.1&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;9.5&quot;, &quot;9.5.1&quot;))
        self.assertFalse(postgres._pg_is_older_ext_ver(&quot;9.5.1&quot;, &quot;9.5&quot;))
        self.assertFalse(postgres._pg_is_older_ext_ver(&quot;9.5b&quot;, &quot;9.5a&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;10a&quot;, &quot;10b&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;1.2.3.4&quot;, &quot;1.2.3.5&quot;))
        self.assertTrue(postgres._pg_is_older_ext_ver(&quot;10dev&quot;, &quot;10next&quot;))
        self.assertFalse(postgres._pg_is_older_ext_ver(&quot;10next&quot;, &quot;10dev&quot;))
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bigip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
&quot;&quot;&quot;
A state module designed to enforce load-balancing configurations for F5 Big-IP entities.
    :maturity:      develop
    :platform:      f5_bigip_11.6
&quot;&quot;&quot;


import salt.utils.json


# set up virtual function
def __virtual__():
    &quot;&quot;&quot;
    Only load if the bigip exec module is available in __salt__
    &quot;&quot;&quot;
    if &quot;bigip.list_transaction&quot; in __salt__:
        return &quot;bigip&quot;
    return (False, &quot;bigip module could not be loaded&quot;)


def _load_result(response, ret):
    &quot;&quot;&quot;
    format the results of listing functions
    &quot;&quot;&quot;

    # were we able to connect?
    if response[&quot;code&quot;] is None:
        ret[&quot;comment&quot;] = response[&quot;content&quot;]
    # forbidden?
    elif response[&quot;code&quot;] == 401:
        ret[&quot;comment&quot;] = &quot;401 Forbidden: Authentication required!&quot;
    # Not found?
    elif response[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = response[&quot;content&quot;][&quot;message&quot;]
    # 200?
    elif response[&quot;code&quot;] == 200:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = (
            &quot;Listing Current Configuration Only.  &quot;
            &quot;Not action or changes occurred during the execution of this state.&quot;
        )
        ret[&quot;changes&quot;] = response[&quot;content&quot;]
    # something bad
    else:
        ret[&quot;comment&quot;] = response[&quot;content&quot;][&quot;message&quot;]

    return ret


def _strip_key(dictionary, keyword):
    &quot;&quot;&quot;
    look for a certain key within a dictionary and nullify ti's contents, check within nested
    dictionaries and lists as well.  Certain attributes such as &quot;generation&quot; will change even
    when there were no changes made to the entity.
    &quot;&quot;&quot;

    for key, value in dictionary.items():
        if key == keyword:
            dictionary[key] = None
        elif isinstance(value, dict):
            _strip_key(value, keyword)
        elif isinstance(value, list):
            for item in value:
                if isinstance(item, dict):
                    _strip_key(item, keyword)

    return dictionary


def _check_for_changes(entity_type, ret, existing, modified):
    &quot;&quot;&quot;
    take an existing entity and a modified entity and check for changes.
    &quot;&quot;&quot;

    ret[&quot;result&quot;] = True

    # were there any changes? generation always changes, remove it.

    if isinstance(existing, dict) and isinstance(modified, dict):
        if &quot;generation&quot; in modified[&quot;content&quot;].keys():
            del modified[&quot;content&quot;][&quot;generation&quot;]

        if &quot;generation&quot; in existing[&quot;content&quot;].keys():
            del existing[&quot;content&quot;][&quot;generation&quot;]

        if modified[&quot;content&quot;] == existing[&quot;content&quot;]:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} is currently enforced to the desired state.  No changes&quot;
                &quot; made.&quot;.format(entity_type=entity_type)
            )
        else:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} was enforced to the desired state.  Note: Only&quot;
                &quot; parameters specified were enforced. See changes for details.&quot;.format(
                    entity_type=entity_type
                )
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = modified[&quot;content&quot;]

    else:
        if modified == existing:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} is currently enforced to the desired state.  No changes&quot;
                &quot; made.&quot;.format(entity_type=entity_type)
            )
        else:
            ret[&quot;comment&quot;] = (
                &quot;{entity_type} was enforced to the desired state.  Note: Only&quot;
                &quot; parameters specified were enforced. See changes for details.&quot;.format(
                    entity_type=entity_type
                )
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = existing
            ret[&quot;changes&quot;][&quot;new&quot;] = modified

    return ret


def _test_output(ret, action, params):
    &quot;&quot;&quot;
    For testing just output what the state will attempt to do without actually doing it.
    &quot;&quot;&quot;

    if action == &quot;list&quot;:
        ret[
            &quot;comment&quot;
        ] += &quot;The list action will just list an entity and will make no changes.\n&quot;
    elif action == &quot;create&quot; or action == &quot;add&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The create action will attempt to create an entity if it does not already&quot;
            &quot; exist.\n&quot;
        )
    elif action == &quot;delete&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The delete action will attempt to delete an existing entity if it&quot;
            &quot; exists.\n&quot;
        )
    elif action == &quot;manage&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The manage action will create a new entity if it does not exist.  If it&quot;
            &quot; does exist, it will be enforcedto the desired state.\n&quot;
        )
    elif action == &quot;modify&quot;:
        ret[&quot;comment&quot;] += (
            &quot;The modify action will attempt to modify an existing entity only if it&quot;
            &quot; exists.\n&quot;
        )

    ret[&quot;comment&quot;] += &quot;An iControl REST Request will be made using the parameters:\n&quot;
    ret[&quot;comment&quot;] += salt.utils.json.dumps(params, indent=4)

    ret[&quot;changes&quot;] = {}
    # Return ``None`` when running with ``test=true``.
    ret[&quot;result&quot;] = None

    return ret


def list_node(hostname, username, password, name):
    &quot;&quot;&quot;
    A function to connect to a bigip device and list a specific node.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to list.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)
    return _load_result(response, ret)


def create_node(hostname, username, password, name, address):
    &quot;&quot;&quot;
    Create a new node if it does not already exist.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to create
    address
        The address of the node
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;address&quot;: address,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A node by this name currently exists.  No change made.&quot;

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        response = __salt__[&quot;bigip.create_node&quot;](
            hostname, username, password, name, address
        )

        ret[&quot;result&quot;] = True
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
        ret[&quot;comment&quot;] = &quot;Node was successfully created.&quot;

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_node(
    hostname,
    username,
    password,
    name,
    address,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    &quot;&quot;&quot;
    Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,
    only the properties which are different than the existing will be updated.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to manage.
    address
        The address of the node
    connection_limit
        [integer]
    description
        [string]
    dynam
        c_ratio:        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;address&quot;: address,
                &quot;connection_limit&quot;: connection_limit,
                &quot;description&quot;: description,
                &quot;dynamic_ratio&quot;: dynamic_ratio,
                &quot;logging&quot;: logging,
                &quot;monitor&quot;: monitor,
                &quot;rate_limit&quot;: rate_limit,
                &quot;ratio&quot;: ratio,
                &quot;session&quot;: session,
                &quot;state:&quot;: node_state,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)

    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        # ensure the address is the same, we don't want to modify a different node than what
        # we think we are managing
        if existing[&quot;content&quot;][&quot;address&quot;] != address:
            ret[&quot;result&quot;] = False
            ret[
<A NAME="5"></A>                &quot;comment&quot;
            ] = &quot;A node with this name exists but the address does not match.&quot;

        modified <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#5',2,'match44314-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= __salt__[&quot;bigip.modify_node&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=ratio,
            session=</B></FONT>session,
            state=node_state,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            ret = _check_for_changes(&quot;Node&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # not found, attempt to create it
    elif existing[&quot;code&quot;] == 404:

        new = __salt__[&quot;bigip.create_node&quot;](hostname, username, password, name, address)

        # were we able to create it?
<A NAME="4"></A>        if new[&quot;code&quot;] == 200:
            # try modification

            modified = __salt__<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#4',2,'match44314-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;bigip.modify_node&quot;](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                logging=logging,
                monitor=monitor,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=</B></FONT>node_state,
            )
            # was the modification successful?
            if modified[&quot;code&quot;] == 200:

                ret[&quot;result&quot;] = True
                ret[&quot;comment&quot;] = (
                    &quot;Node was created and enforced to the desired state.  Note: Only&quot;
                    &quot; parameters specified were enforced.  See changes for details.&quot;
                )
                ret[&quot;changes&quot;][&quot;old&quot;] = {}
                ret[&quot;changes&quot;][&quot;new&quot;] = modified[&quot;content&quot;]

            # roll it back
            else:

                deleted = __salt__[&quot;bigip.delete_node&quot;](
                    hostname, username, password, name
                )
                # did we get rid of it?
                if deleted[&quot;code&quot;] == 200:
                    ret[&quot;comment&quot;] = (
                        &quot;Node was successfully created but an error occurred during&quot;
                        &quot; modification. The creation of the node has been rolled back.&quot;
                        &quot; Message is as follows:\n{message}&quot;.format(
                            message=modified[&quot;content&quot;][&quot;message&quot;]
                        )
                    )
                # something bad happened
                else:
                    ret[&quot;comment&quot;] = (
                        &quot;Node was successfully created but an error occurred during&quot;
                        &quot; modification. The creation of the node was not able to be&quot;
                        &quot; rolled back. Message is as follows:\n&quot;
                        &quot; {message}\n{message_two}&quot;.format(
                            message=modified[&quot;content&quot;][&quot;message&quot;],
                            message_two=deleted[&quot;content&quot;][&quot;message&quot;],
                        )
                    )

        # unable to create it
        else:
            ret = _load_result(new, ret)
    # an error occurred
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_node(
    hostname,
    username,
    password,
    name,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    &quot;&quot;&quot;
    Modify an existing node. Only a node which already exists will be modified and
    only the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;connection_limit&quot;: connection_limit,
                &quot;description&quot;: description,
                &quot;dynamic_ratio&quot;: dynamic_ratio,
                &quot;logging&quot;: logging,
                &quot;monitor&quot;: monitor,
                &quot;rate_limit&quot;: rate_limit,
                &quot;ratio&quot;: ratio,
                &quot;session&quot;: session,
                &quot;state:&quot;: node_state,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)

<A NAME="6"></A>    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        modified = __salt__<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#6',2,'match44314-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;bigip.modify_node&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=</B></FONT>ratio,
            session=session,
            state=node_state,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            ret = _check_for_changes(&quot;Node&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # not found, attempt to create it
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A node with this name was not found.&quot;
    # an error occurred
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_node(hostname, username, password, name):
    &quot;&quot;&quot;
    Delete an existing node.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node which will be deleted.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    # is this node currently configured?
    existing = __salt__[&quot;bigip.list_node&quot;](hostname, username, password, name)
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_node&quot;](hostname, username, password, name)
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Node was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}

        # something bad happened
        else:
            ret = _load_result(existing, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This node already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}

    else:
        ret = _load_result(existing, ret)

    return ret


def list_pool(hostname, username, password, name):
    &quot;&quot;&quot;
    A function to connect to a bigip device and list a specific pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to list.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)
    return _load_result(response, ret)


def create_pool(
    hostname,
    username,
    password,
    name,
    members=None,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    &quot;&quot;&quot;
    Create a new node if it does not already exist.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    members
        List of members to be added to the pool
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: members,
                &quot;allow_nat&quot;: allow_nat,
                &quot;allow_snat&quot;: allow_snat,
                &quot;description&quot;: description,
                &quot;gateway_failsafe_device&quot;: gateway_failsafe_device,
                &quot;ignore_persisted_weight&quot;: ignore_persisted_weight,
                &quot;ip_tos_client:&quot;: ip_tos_to_client,
                &quot;ip_tos_server&quot;: ip_tos_to_server,
                &quot;link_qos_to_client&quot;: link_qos_to_client,
                &quot;link_qos_to_server&quot;: link_qos_to_server,
                &quot;load_balancing_mode&quot;: load_balancing_mode,
                &quot;min_active_members&quot;: min_active_members,
                &quot;min_up_members&quot;: min_up_members,
                &quot;min_up_members_checking&quot;: min_up_members_checking,
                &quot;monitor&quot;: monitor,
                &quot;profiles&quot;: profiles,
                &quot;queue_depth_limit&quot;: queue_depth_limit,
                &quot;queue_on_connection_limit&quot;: queue_on_connection_limit,
                &quot;queue_time_limit&quot;: queue_time_limit,
                &quot;reselect_tries&quot;: reselect_tries,
                &quot;service_down_action&quot;: service_down_action,
                &quot;slow_ramp_time&quot;: slow_ramp_time,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A pool by this name currently exists.  No change made.&quot;

<A NAME="0"></A>    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#0',2,'match44314-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= __salt__[&quot;bigip.create_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            members=members,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=</B></FONT>min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Pool was successfully created.&quot;
        else:
            ret = _load_result(existing, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    &quot;&quot;&quot;
    Create a new pool if it does not already exist. Pool members are managed separately. Only the
    parameters specified are enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;allow_nat&quot;: allow_nat,
                &quot;allow_snat&quot;: allow_snat,
                &quot;description&quot;: description,
                &quot;gateway_failsafe_device&quot;: gateway_failsafe_device,
                &quot;ignore_persisted_weight&quot;: ignore_persisted_weight,
                &quot;ip_tos_client:&quot;: ip_tos_to_client,
                &quot;ip_tos_server&quot;: ip_tos_to_server,
                &quot;link_qos_to_client&quot;: link_qos_to_client,
                &quot;link_qos_to_server&quot;: link_qos_to_server,
                &quot;load_balancing_mode&quot;: load_balancing_mode,
                &quot;min_active_members&quot;: min_active_members,
                &quot;min_up_members&quot;: min_up_members,
                &quot;min_up_members_checking&quot;: min_up_members_checking,
                &quot;monitor&quot;: monitor,
                &quot;profiles&quot;: profiles,
                &quot;queue_depth_limit&quot;: queue_depth_limit,
                &quot;queue_on_connection_limit&quot;: queue_on_connection_limit,
                &quot;queue_time_limit&quot;: queue_time_limit,
                &quot;reselect_tries&quot;: reselect_tries,
                &quot;service_down_action&quot;: service_down_action,
                &quot;slow_ramp_time&quot;: slow_ramp_time,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

<A NAME="1"></A>    # if it exists
    if existing[&quot;code&quot;] == 200:

        modified = __salt__<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#1',2,'match44314-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;bigip.modify_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=</B></FONT>min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # remove member listings and self-links
            del existing[&quot;content&quot;][&quot;membersReference&quot;]
            del modified[&quot;content&quot;][&quot;membersReference&quot;]
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]

            ret = _check_for_changes(&quot;Pool&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

<A NAME="3"></A>    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        new = __salt__<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#3',2,'match44314-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;bigip.create_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=</B></FONT>load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )

        # were we able to create it?
        if new[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = (
                &quot;Pool was created and enforced to the desired state.  Note: Only&quot;
                &quot; parameters specified were enforced.  See changes for details.&quot;
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = new[&quot;content&quot;]

        # unable to create it
        else:
            ret = _load_result(new, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    &quot;&quot;&quot;
    Modify an existing pool. Pool members are managed separately. Only the
    parameters specified are enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;allow_nat&quot;: allow_nat,
                &quot;allow_snat&quot;: allow_snat,
                &quot;description&quot;: description,
                &quot;gateway_failsafe_device&quot;: gateway_failsafe_device,
                &quot;ignore_persisted_weight&quot;: ignore_persisted_weight,
                &quot;ip_tos_client:&quot;: ip_tos_to_client,
                &quot;ip_tos_server&quot;: ip_tos_to_server,
                &quot;link_qos_to_client&quot;: link_qos_to_client,
                &quot;link_qos_to_server&quot;: link_qos_to_server,
                &quot;load_balancing_mode&quot;: load_balancing_mode,
                &quot;min_active_members&quot;: min_active_members,
                &quot;min_up_members&quot;: min_up_members,
                &quot;min_up_members_checking&quot;: min_up_members_checking,
                &quot;monitor&quot;: monitor,
                &quot;profiles&quot;: profiles,
                &quot;queue_depth_limit&quot;: queue_depth_limit,
                &quot;queue_on_connection_limit&quot;: queue_on_connection_limit,
                &quot;queue_time_limit&quot;: queue_time_limit,
                &quot;reselect_tries&quot;: reselect_tries,
                &quot;service_down_action&quot;: service_down_action,
                &quot;slow_ramp_time&quot;: slow_ramp_time,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

<A NAME="2"></A>    # if it exists
    if existing[&quot;code&quot;] == 200:

        modified = __salt__<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#2',2,'match44314-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>[&quot;bigip.modify_pool&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=</B></FONT>load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # remove member listings and self-links
            del existing[&quot;content&quot;][&quot;membersReference&quot;]
            del modified[&quot;content&quot;][&quot;membersReference&quot;]
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]

            ret = _check_for_changes(&quot;Pool&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;
    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_pool(hostname, username, password, name):
    &quot;&quot;&quot;
    Delete an existing pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool which will be deleted
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_pool&quot;](hostname, username, password, name)
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Pool was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}

        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This pool already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}

    else:
        ret = _load_result(existing, ret)

    return ret


def manage_pool_members(hostname, username, password, name, members):
    &quot;&quot;&quot;
    Manage the members of an existing pool.  This function replaces all current pool members.
    Only the parameters specified are enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    members
        list of pool members to manage.

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: members,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # what are the current members?
        current_members = existing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        modified = __salt__[&quot;bigip.replace_pool_members&quot;](
            hostname, username, password, name, members
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # re-list the pool with new membership
            new_listing = __salt__[&quot;bigip.list_pool&quot;](
                hostname, username, password, name
            )

            # just in case something happened...
            if new_listing[&quot;code&quot;] != 200:
                ret = _load_result(new_listing, ret)
                ret[&quot;comment&quot;] = (
                    &quot;modification of the pool was successful but an error occurred upon&quot;
                    &quot; retrieving new listing.&quot;
                )
                return ret

            new_members = new_listing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

            # remove generation keys and create new lists indexed by integers
            for current_member in current_members:
                del current_member[&quot;generation&quot;]

            for new_member in new_members:
                del new_member[&quot;generation&quot;]

            # anything changed?
            ret = _check_for_changes(
                &quot;Pool Membership&quot;, ret, current_members, new_members
            )

        else:
            ret = _load_result(modified, ret)

    # pool does not exists
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;

    else:
        ret = _load_result(existing, ret)

    return ret


def add_pool_member(hostname, username, password, name, member):
    &quot;&quot;&quot;
    A function to connect to a bigip device and add a new member to an existing pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member to add to the pool
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;add&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: member,
            },
        )

    # is this pool member currently configured?
    existing_pool = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    if existing_pool[&quot;code&quot;] == 200:

        # for some reason iControl REST doesn't support listing a single pool member.
        # the response from GET for listing a member will return 200 even if it doesn't exists.
        # because of this we have to do some rather &quot;unnecessary&quot; searching within a pool.

        # what are the current members?
        current_members = existing_pool[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        # loop through them
        exists = False
        for current_member in current_members:
            if current_member[&quot;name&quot;] == member[&quot;name&quot;]:
                exists = True
                break

        if exists:
            ret[&quot;result&quot;] = True
            ret[
                &quot;comment&quot;
            ] = &quot;Member: {name} already exists within this pool.  No changes made.&quot;.format(
                name=member[&quot;name&quot;]
            )
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        else:
            new_member = __salt__[&quot;bigip.add_pool_member&quot;](
                hostname, username, password, name, member
            )

            if new_member[&quot;code&quot;] == 200:
                ret[&quot;result&quot;] = True
                ret[
                    &quot;comment&quot;
                ] = &quot;Member: {name} has been successfully added to the pool.&quot;.format(
                    name=member[&quot;name&quot;]
                )
                ret[&quot;changes&quot;][&quot;old&quot;] = {}

                # look up the member again...
                pool_listing = __salt__[&quot;bigip.list_pool&quot;](
                    hostname, username, password, name
                )

                if pool_listing[&quot;code&quot;] != 200:
                    ret = _load_result(new_member, ret)
                    return ret

                members = pool_listing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]
                # loop through them
                for current_member in members:
                    if current_member[&quot;name&quot;] == member[&quot;name&quot;]:
                        added_member = current_member
                        break

                ret[&quot;changes&quot;][&quot;new&quot;] = added_member

            # member wasn't added
            else:
                ret = _load_result(new_member, ret)

    # pool does not exists
    elif existing_pool[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;
    else:
        ret = _load_result(existing_pool, ret)

    return ret


def modify_pool_member(
    hostname,
    username,
    password,
    name,
    member,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    inherit_profile=None,
    logging=None,
    monitor=None,
    priority_group=None,
    profiles=None,
    rate_limit=None,
    ratio=None,
    session=None,
    member_state=None,
):
    &quot;&quot;&quot;
    A function to connect to a bigip device and modify a member of an existing pool.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    inherit_profile
        [enabled | disabled]
    logging
        [enabled | disabled]
    monitor
        [name]
    priority_group
        [integer]
    profiles
        [none | profile_name]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    member_state (state)
        [ user-up | user-down ]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: member,
            },
        )

    # is this pool member currently configured?
    existing_pool = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    if existing_pool[&quot;code&quot;] == 200:

        # for some reason iControl REST doesn't support listing a single pool member.
        # the response from GET for listing a member will return 200 even if it doesn't exists.
        # because of this we have to do some rather &quot;unnecessary&quot; searching within a pool.

        # what are the current members?
        current_members = existing_pool[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        # loop through them
        exists = False
        for current_member in current_members:
            if current_member[&quot;name&quot;] == member:
                exists = True
                existing_member = current_member
                break

        if exists:

            # modify the pool member
            modified = __salt__[&quot;bigip.modify_pool_member&quot;](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                member=member,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                inherit_profile=inherit_profile,
                logging=logging,
                monitor=monitor,
                priority_group=priority_group,
                profiles=profiles,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=member_state,
            )

            # re-list the pool
            new_pool = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

            if modified[&quot;code&quot;] == 200 and modified[&quot;code&quot;] == 200:

                # what are the new members?
                new_members = new_pool[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

                # loop through them
                for new_member in new_members:
                    if new_member[&quot;name&quot;] == member:
                        modified_member = new_member
                        break

                # check for changes
                old = {&quot;content&quot;: existing_member}
                new = {&quot;content&quot;: modified_member}
                ret = _check_for_changes(
                    &quot;Pool Member: {member}&quot;.format(member=member), ret, old, new
                )

            else:
                ret = _load_result(modified, ret)
        else:
            ret[
                &quot;comment&quot;
            ] = &quot;Member: {name} does not exists within this pool.  No changes made.&quot;.format(
                name=member[&quot;name&quot;]
            )

    # pool does not exists
    elif existing_pool[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A pool with this name was not found.&quot;
    else:
        ret = _load_result(existing_pool, ret)

    return ret


def delete_pool_member(hostname, username, password, name, member):
    &quot;&quot;&quot;
    Delete an existing pool member.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to be modified
    member
        The name of the member to delete from the pool
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;members&quot;: member,
            },
        )

    # is this pool currently configured?
    existing = __salt__[&quot;bigip.list_pool&quot;](hostname, username, password, name)

    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        # what are the current members?
        current_members = existing[&quot;content&quot;][&quot;membersReference&quot;][&quot;items&quot;]

        # loop through them
        exists = False
        for current_member in current_members:
            if current_member[&quot;name&quot;] == member:
                exists = True
                existing_member = current_member
                break

        if exists:
            deleted = __salt__[&quot;bigip.delete_pool_member&quot;](
                hostname, username, password, name, member
            )
            # did we get rid of it?
            if deleted[&quot;code&quot;] == 200:
                ret[&quot;result&quot;] = True
                ret[
                    &quot;comment&quot;
                ] = &quot;Pool Member: {member} was successfully deleted.&quot;.format(
                    member=member
                )
                ret[&quot;changes&quot;][&quot;old&quot;] = existing_member
                ret[&quot;changes&quot;][&quot;new&quot;] = {}

        # something bad happened
        else:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;This pool member already does not exist. No changes made.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = {}

    else:
        ret = _load_result(existing, ret)

    return ret


def list_virtual(hostname, username, password, name):
    &quot;&quot;&quot;
    A function to list a specific virtual.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to list
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)
    return _load_result(response, ret)


def create_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    &quot;&quot;&quot;
    A function to connect to a bigip device and create a virtual server if it does not already exists.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]

        vlan_ids
            [ list]
        enabled
            [ true | false ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;destination&quot;: destination,
                &quot;pool&quot;: pool,
                &quot;address_status&quot;: address_status,
                &quot;auto_lasthop&quot;: auto_lasthop,
                &quot;bwc_policy&quot;: bwc_policy,
                &quot;cmp_enabled&quot;: cmp_enabled,
                &quot;connection_limit&quot;: connection_limit,
                &quot;dhcp_relay&quot;: dhcp_relay,
                &quot;description&quot;: description,
                &quot;fallback_persistence&quot;: fallback_persistence,
                &quot;flow_eviction_policy&quot;: flow_eviction_policy,
                &quot;gtm_score&quot;: gtm_score,
                &quot;ip_forward&quot;: ip_forward,
                &quot;ip_protocol&quot;: ip_protocol,
                &quot;internal&quot;: internal,
                &quot;twelve_forward&quot;: twelve_forward,
                &quot;last_hop_pool&quot;: last_hop_pool,
                &quot;mask&quot;: mask,
                &quot;mirror&quot;: mirror,
                &quot;nat64&quot;: nat64,
                &quot;persist&quot;: persist,
                &quot;profiles&quot;: profiles,
                &quot;policies&quot;: policies,
                &quot;rate_class&quot;: rate_class,
                &quot;rate_limit&quot;: rate_limit,
                &quot;rate_limit_mode&quot;: rate_limit_mode,
                &quot;rate_limit_dst&quot;: rate_limit_dst,
                &quot;rate_limit_src&quot;: rate_limit_src,
                &quot;rules&quot;: rules,
                &quot;related_rules&quot;: related_rules,
                &quot;reject&quot;: reject,
                &quot;source&quot;: source,
                &quot;source_address_translation&quot;: source_address_translation,
                &quot;source_port&quot;: source_port,
                &quot;virtual_state&quot;: virtual_state,
                &quot;traffic_classes&quot;: traffic_classes,
                &quot;translate_address&quot;: translate_address,
                &quot;translate_port&quot;: translate_port,
                &quot;vlans&quot;: vlans,
            },
        )

    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)

    # does this virtual exist?
<A NAME="7"></A>    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match44314-0.html#7',2,'match44314-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>= &quot;A virtual by this name currently exists.  No change made.&quot;

    elif existing[&quot;code&quot;] == 404:

        # create it
        virtual = __salt__[&quot;bigip.create_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=</B></FONT>pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if virtual[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = virtual[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Virtual was successfully created.&quot;
        else:
            ret = _load_result(existing, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    &quot;&quot;&quot;
    Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the
    parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]

        vlan_ids
            [ list]
        enabled
            [ true | false ]
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;manage&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;destination&quot;: destination,
                &quot;pool&quot;: pool,
                &quot;address_status&quot;: address_status,
                &quot;auto_lasthop&quot;: auto_lasthop,
                &quot;bwc_policy&quot;: bwc_policy,
                &quot;cmp_enabled&quot;: cmp_enabled,
                &quot;connection_limit&quot;: connection_limit,
                &quot;dhcp_relay&quot;: dhcp_relay,
                &quot;description&quot;: description,
                &quot;fallback_persistence&quot;: fallback_persistence,
                &quot;flow_eviction_policy&quot;: flow_eviction_policy,
                &quot;gtm_score&quot;: gtm_score,
                &quot;ip_forward&quot;: ip_forward,
                &quot;ip_protocol&quot;: ip_protocol,
                &quot;internal&quot;: internal,
                &quot;twelve_forward&quot;: twelve_forward,
                &quot;last_hop_pool&quot;: last_hop_pool,
                &quot;mask&quot;: mask,
                &quot;mirror&quot;: mirror,
                &quot;nat64&quot;: nat64,
                &quot;persist&quot;: persist,
                &quot;profiles&quot;: profiles,
                &quot;policies&quot;: policies,
                &quot;rate_class&quot;: rate_class,
                &quot;rate_limit&quot;: rate_limit,
                &quot;rate_limit_mode&quot;: rate_limit_mode,
                &quot;rate_limit_dst&quot;: rate_limit_dst,
                &quot;rate_limit_src&quot;: rate_limit_src,
                &quot;rules&quot;: rules,
                &quot;related_rules&quot;: related_rules,
                &quot;reject&quot;: reject,
                &quot;source&quot;: source,
                &quot;source_address_translation&quot;: source_address_translation,
                &quot;source_port&quot;: source_port,
                &quot;virtual_state&quot;: virtual_state,
                &quot;traffic_classes&quot;: traffic_classes,
                &quot;translate_address&quot;: translate_address,
                &quot;translate_port&quot;: translate_port,
                &quot;vlans&quot;: vlans,
            },
        )

    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)

    # does this virtual exist?
    if existing[&quot;code&quot;] == 200:

        # modify
        modified = __salt__[&quot;bigip.modify_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # relist it to compare
            relisting = __salt__[&quot;bigip.list_virtual&quot;](
                hostname, username, password, name
            )

            if relisting[&quot;code&quot;] == 200:

                relisting = _strip_key(relisting, &quot;generation&quot;)
                existing = _strip_key(existing, &quot;generation&quot;)

                ret = _check_for_changes(&quot;Virtual&quot;, ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)

        else:
            ret = _load_result(modified, ret)

    elif existing[&quot;code&quot;] == 404:

        # create it
        virtual = __salt__[&quot;bigip.create_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )

        # were we able to create it?
        if virtual[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = virtual[&quot;content&quot;]
            ret[
                &quot;comment&quot;
            ] = &quot;Virtual was successfully created and enforced to the desired state.&quot;

        else:
            ret = _load_result(virtual, ret)

    else:
        ret = _load_result(existing, ret)

    return ret


def modify_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    &quot;&quot;&quot;
    Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit_dst
        [integer]
    rate_limit_src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary ]

        vlan_ids
            [ list]
        enabled
            [ true | false ]

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;modify&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
                &quot;destination&quot;: destination,
                &quot;pool&quot;: pool,
                &quot;address_status&quot;: address_status,
                &quot;auto_lasthop&quot;: auto_lasthop,
                &quot;bwc_policy&quot;: bwc_policy,
                &quot;cmp_enabled&quot;: cmp_enabled,
                &quot;connection_limit&quot;: connection_limit,
                &quot;dhcp_relay&quot;: dhcp_relay,
                &quot;description&quot;: description,
                &quot;fallback_persistence&quot;: fallback_persistence,
                &quot;flow_eviction_policy&quot;: flow_eviction_policy,
                &quot;gtm_score&quot;: gtm_score,
                &quot;ip_forward&quot;: ip_forward,
                &quot;ip_protocol&quot;: ip_protocol,
                &quot;internal&quot;: internal,
                &quot;twelve_forward&quot;: twelve_forward,
                &quot;last_hop_pool&quot;: last_hop_pool,
                &quot;mask&quot;: mask,
                &quot;mirror&quot;: mirror,
                &quot;nat64&quot;: nat64,
                &quot;persist&quot;: persist,
                &quot;profiles&quot;: profiles,
                &quot;policies&quot;: policies,
                &quot;rate_class&quot;: rate_class,
                &quot;rate_limit&quot;: rate_limit,
                &quot;rate_limit_mode&quot;: rate_limit_mode,
                &quot;rate_limit_dst&quot;: rate_limit_dst,
                &quot;rate_limit_src&quot;: rate_limit_src,
                &quot;rules&quot;: rules,
                &quot;related_rules&quot;: related_rules,
                &quot;reject&quot;: reject,
                &quot;source&quot;: source,
                &quot;source_address_translation&quot;: source_address_translation,
                &quot;source_port&quot;: source_port,
                &quot;virtual_state&quot;: virtual_state,
                &quot;traffic_classes&quot;: traffic_classes,
                &quot;translate_address&quot;: translate_address,
                &quot;translate_port&quot;: translate_port,
                &quot;vlans&quot;: vlans,
            },
        )

    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)

    # does this virtual exist?
    if existing[&quot;code&quot;] == 200:

        # modify
        modified = __salt__[&quot;bigip.modify_virtual&quot;](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:

            # relist it to compare
            relisting = __salt__[&quot;bigip.list_virtual&quot;](
                hostname, username, password, name
            )

            if relisting[&quot;code&quot;] == 200:

                relisting = _strip_key(relisting, &quot;generation&quot;)
                existing = _strip_key(existing, &quot;generation&quot;)

                ret = _check_for_changes(&quot;Virtual&quot;, ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)

        else:
            ret = _load_result(modified, ret)

    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A Virtual with this name was not found.&quot;
        # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_virtual(hostname, username, password, name):
    &quot;&quot;&quot;
    Delete an existing virtual.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual which will be deleted
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;name&quot;: name,
            },
        )

    # is this virtual currently configured?
    existing = __salt__[&quot;bigip.list_virtual&quot;](hostname, username, password, name)
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_virtual&quot;](hostname, username, password, name)
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Virtual was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This virtual already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}
    else:
        ret = _load_result(existing, ret)

    return ret


def list_monitor(hostname, username, password, monitor_type, name):
    &quot;&quot;&quot;
    A function to list an existing monitor.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to list
    name
        The name of the monitor to list
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;monitor_type&quot;: monitor_type,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )
    return _load_result(response, ret)


def create_monitor(hostname, username, password, monitor_type, name, **kwargs):
    &quot;&quot;&quot;
    A function to connect to a bigip device and create a monitor.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;monitor_type&quot;: monitor_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;create&quot;, params)

    # is this monitor currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A monitor by this name currently exists.  No change made.&quot;

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Monitor was successfully created.&quot;
        else:
            ret = _load_result(response, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_monitor(hostname, username, password, monitor_type, name, **kwargs):
    &quot;&quot;&quot;
    Create a new monitor if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;monitor_type&quot;: monitor_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;manage&quot;, params)

    # is this monitor currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the monitor
        modified = __salt__[&quot;bigip.modify_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Monitor&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Monitor was successfully created.&quot;
        else:
            ret = _load_result(response, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_monitor(hostname, username, password, monitor_type, name, **kwargs):
    &quot;&quot;&quot;
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;monitor_type&quot;: monitor_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;modify&quot;, params)

    # is this monitor currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the monitor
        modified = __salt__[&quot;bigip.modify_monitor&quot;](
            hostname, username, password, monitor_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Monitor&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A Monitor with this name was not found.&quot;
    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_monitor(hostname, username, password, monitor_type, name):
    &quot;&quot;&quot;
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;monitor_type&quot;: monitor_type,
                &quot;name&quot;: name,
            },
        )

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_monitor&quot;](
        hostname, username, password, monitor_type, name
    )
    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_monitor&quot;](
            hostname, username, password, monitor_type, name
        )
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Monitor was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This Monitor already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}
    else:
        ret = _load_result(existing, ret)

    return ret


def list_profile(hostname, username, password, profile_type, name):
    &quot;&quot;&quot;
    A function to list an existing profile.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to list
    name
        The name of the profile to list
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;list&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;profile_type&quot;: profile_type,
                &quot;name&quot;: name,
            },
        )

    response = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )
    return _load_result(response, ret)


def create_profile(hostname, username, password, profile_type, name, **kwargs):
    r&quot;&quot;&quot;
    A function to connect to a bigip device and create a profile.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.

    Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\`` when
    used within strings.

    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;create&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;profile_type&quot;: profile_type,
                &quot;name&quot;: name,
            },
        )

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;A profile by this name currently exists.  No change made.&quot;

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )

        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Profile was successfully created.&quot;
        else:
            ret = _load_result(response, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def manage_profile(hostname, username, password, profile_type, name, **kwargs):
    &quot;&quot;&quot;
    Create a new profile if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;profile_type&quot;: profile_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;manage&quot;, params)

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the profile
        modified = __salt__[&quot;bigip.modify_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Profile&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:

        response = __salt__[&quot;bigip.create_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )
        if response[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;changes&quot;][&quot;old&quot;] = {}
            ret[&quot;changes&quot;][&quot;new&quot;] = response[&quot;content&quot;]
            ret[&quot;comment&quot;] = &quot;Profile was successfully created.&quot;
        else:
            ret = _load_result(existing, ret)

    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def modify_profile(hostname, username, password, profile_type, name, **kwargs):
    &quot;&quot;&quot;
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:

        params = {
            &quot;hostname&quot;: hostname,
            &quot;username&quot;: username,
            &quot;password&quot;: password,
            &quot;profile_type&quot;: profile_type,
            &quot;name&quot;: name,
        }

        for key, value in kwargs.items():
            params[key] = value

        return _test_output(ret, &quot;modify&quot;, params)

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists
    if existing[&quot;code&quot;] == 200:

        # modify the profile
        modified = __salt__[&quot;bigip.modify_profile&quot;](
            hostname, username, password, profile_type, name, **kwargs
        )

        # was the modification successful?
        if modified[&quot;code&quot;] == 200:
            del existing[&quot;content&quot;][&quot;selfLink&quot;]
            del modified[&quot;content&quot;][&quot;selfLink&quot;]
            ret = _check_for_changes(&quot;Profile&quot;, ret, existing, modified)
        else:
            ret = _load_result(modified, ret)

    # if it doesn't exist
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;comment&quot;] = &quot;A Profile with this name was not found.&quot;
    # else something else was returned
    else:
        ret = _load_result(existing, ret)

    return ret


def delete_profile(hostname, username, password, profile_type, name):
    &quot;&quot;&quot;
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.

    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...

        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    &quot;&quot;&quot;

    ret = {&quot;name&quot;: name, &quot;changes&quot;: {}, &quot;result&quot;: False, &quot;comment&quot;: &quot;&quot;}

    if __opts__[&quot;test&quot;]:
        return _test_output(
            ret,
            &quot;delete&quot;,
            params={
                &quot;hostname&quot;: hostname,
                &quot;username&quot;: username,
                &quot;password&quot;: password,
                &quot;profile_type&quot;: profile_type,
                &quot;name&quot;: name,
            },
        )

    # is this profile currently configured?
    existing = __salt__[&quot;bigip.list_profile&quot;](
        hostname, username, password, profile_type, name
    )

    # if it exists by name
    if existing[&quot;code&quot;] == 200:

        deleted = __salt__[&quot;bigip.delete_profile&quot;](
            hostname, username, password, profile_type, name
        )
        # did we get rid of it?
        if deleted[&quot;code&quot;] == 200:
            ret[&quot;result&quot;] = True
            ret[&quot;comment&quot;] = &quot;Profile was successfully deleted.&quot;
            ret[&quot;changes&quot;][&quot;old&quot;] = existing[&quot;content&quot;]
            ret[&quot;changes&quot;][&quot;new&quot;] = {}
        # something bad happened
        else:
            ret = _load_result(deleted, ret)

    # not found
    elif existing[&quot;code&quot;] == 404:
        ret[&quot;result&quot;] = True
        ret[&quot;comment&quot;] = &quot;This Profile already does not exist. No changes made.&quot;
        ret[&quot;changes&quot;][&quot;old&quot;] = {}
        ret[&quot;changes&quot;][&quot;new&quot;] = {}
    else:
        ret = _load_result(existing, ret)

    return ret
</PRE>
</div>
  </div>
</body>
</html>
