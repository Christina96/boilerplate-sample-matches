<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_postgres_1.py &amp; bigip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_postgres_1.py &amp; bigip.py
      </h3>
<h1 align="center">
        6.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_postgres_1.py (6.6956997%)<th>bigip.py (5.8851676%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(514-537)<td><a href="#" name="0">(777-793)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(696-712)<td><a href="#" name="1">(960-975)</a><td align="center"><font color="#e40000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(812-827)<td><a href="#" name="2">(1194-1208)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(774-789)<td><a href="#" name="3">(1005-1019)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(737-751)<td><a href="#" name="4">(369-382)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(414-428)<td><a href="#" name="5">(338-350)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(485-497)<td><a href="#" name="6">(508-519)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1427-1439)<td><a href="#" name="7">(1966-1978)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_postgres_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
import datetime
import logging
import re
import salt.modules.postgres as postgres
from salt.exceptions import SaltInvocationError
from tests.support.mixins import LoaderModuleMockMixin
from tests.support.mock import Mock, call, patch
from tests.support.unit import TestCase
test_list_db_csv = (
    "Name,Owner,Encoding,Collate,Ctype,Access privileges,Tablespace\n"
    "template1,postgres,LATIN1,en_US,en_US"
    ',"{=c/postgres,postgres=CTc/postgres}",pg_default\n'
    "template0,postgres,LATIN1,en_US,en_US"
    ',"{=c/postgres,postgres=CTc/postgres}",pg_default\n'
    "postgres,postgres,LATIN1,en_US,en_US,,pg_default\n"
    "test_db,postgres,LATIN1,en_US,en_US,,pg_default"
)
test_list_schema_csv = (
    "name,owner,acl\n"
    'public,postgres,"{postgres=UC/postgres,=UC/postgres}"\n'
    'pg_toast,postgres,""'
)
test_list_language_csv = "Name\ninternal\nc\nsql\nplpgsql\n"
test_privileges_list_table_csv = (
    "name\n"
    '"{baruwatest=arwdDxt/baruwatest,bayestest=arwd/baruwatest,baruwa=a*r*w*d*D*x*t*/baruwatest}"\n'
)
test_privileges_list_group_csv = (
    "rolname,admin_option\nbaruwa,f\nbaruwatest2,t\nbaruwatest,f\n"
)
log = logging.getLogger(__name__)
class PostgresTestCase(TestCase, LoaderModuleMockMixin):
    def setup_loader_modules(self):
        patcher = patch("salt.utils.path.which", Mock(return_value="/usr/bin/pgsql"))
        patcher.start()
        self.addCleanup(patcher.stop)
        return {
            postgres: {
                "__grains__": {"os_family": "Linux"},
                "__salt__": {
                    "config.option": Mock(),
                    "cmd.run_all": Mock(),
                    "file.chown": Mock(),
                    "file.remove": Mock(),
                },
            }
        }
    def test_run_psql(self):
        postgres._run_psql('echo "hi"')
        cmd = postgres.__salt__["cmd.run_all"]
        self.assertEqual("postgres", cmd.call_args[1]["runas"])
    def test_db_alter(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            postgres.db_alter(
                "dbname",
                user="testuser",
                host="testhost",
                port="testport",
                maintenance_db="maint_db",
                password="foo",
                tablespace="testspace",
                owner="otheruser",
                runas="foo",
            )
            postgres._run_psql.assert_has_calls(
                [
                    call(
                        [
                            "/usr/bin/pgsql",
                            "--no-align",
                            "--no-readline",
                            "--no-psqlrc",
                            "--no-password",
                            "--username",
                            "testuser",
                            "--host",
                            "testhost",
                            "--port",
                            "testport",
                            "--dbname",
                            "maint_db",
                            "-c",
                            'ALTER DATABASE "dbname" OWNER TO "otheruser"',
                        ],
                        host="testhost",
                        user="testuser",
                        password="foo",
                        runas="foo",
                        port="testport",
                    ),
                    call(
                        [
                            "/usr/bin/pgsql",
                            "--no-align",
                            "--no-readline",
                            "--no-psqlrc",
                            "--no-password",
                            "--username",
                            "testuser",
                            "--host",
                            "testhost",
                            "--port",
                            "testport",
                            "--dbname",
                            "maint_db",
                            "-c",
                            'ALTER DATABASE "dbname" SET TABLESPACE "testspace"',
                        ],
                        host="testhost",
                        user="testuser",
                        password="foo",
                        runas="foo",
                        port="testport",
                    ),
                ]
            )
    def test_db_alter_owner_recurse(self):
        with patch(
            "salt.modules.postgres.owner_to", Mock(return_value={"retcode": None})
        ):
            postgres.db_alter(
                "dbname",
                user="testuser",
                host="testhost",
                port="testport",
                maintenance_db="maint_db",
                password="foo",
                tablespace="testspace",
                owner="otheruser",
                owner_recurse=True,
                runas="foo",
            )
            postgres.owner_to.assert_called_once_with(
                "dbname",
                "otheruser",
                user="testuser",
                host="testhost",
                port="testport",
                password="foo",
                runas="foo",
            )
    def test_db_create(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            postgres.db_create(
                "dbname",
                user="testuser",
                host="testhost",
                port="testport",
                maintenance_db="maint_db",
                password="foo",
                tablespace="testspace",
                owner="otheruser",
                runas="foo",
            )
            postgres._run_psql.assert_called_once_with(
                [
                    "/usr/bin/pgsql",
                    "--no-align",
                    "--no-readline",
                    "--no-psqlrc",
                    "--no-password",
                    "--username",
                    "testuser",
                    "--host",
                    "testhost",
                    "--port",
                    "testport",
                    "--dbname",
                    "maint_db",
                    "-c",
                    'CREATE DATABASE "dbname" WITH TABLESPACE = "testspace" '
                    'OWNER = "otheruser"',
                ],
                host="testhost",
                user="testuser",
                password="foo",
                runas="foo",
                port="testport",
            )
    def test_db_create_empty_string_param(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            postgres.db_create(
                "dbname",
                lc_collate="",
                encoding="utf8",
                user="testuser",
                host="testhost",
                port=1234,
                maintenance_db="maint_db",
                password="foo",
            )
            postgres._run_psql.assert_called_once_with(
                [
                    "/usr/bin/pgsql",
                    "--no-align",
                    "--no-readline",
                    "--no-psqlrc",
                    "--no-password",
                    "--username",
                    "testuser",
                    "--host",
                    "testhost",
                    "--port",
                    "1234",
                    "--dbname",
                    "maint_db",
                    "-c",
                    "CREATE DATABASE \"dbname\" WITH ENCODING = 'utf8' LC_COLLATE = ''",
                ],
                host="testhost",
                password="foo",
                port=1234,
                runas=None,
                user="testuser",
            )
    def test_db_create_with_trivial_sql_injection(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            self.assertRaises(
                SaltInvocationError,
                postgres.db_create,
                "dbname",
                lc_collate="foo' ENCODING='utf8",
            )
    def test_db_exists(self):
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": test_list_db_csv}),
        ):
            ret = postgres.db_exists(
                "test_db",
                user="testuser",
                host="testhost",
                port="testport",
                maintenance_db="maint_db",
                password="foo",
                runas="foo",
            )
            self.assertTrue(ret)
    def test_db_list(self):
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": test_list_db_csv}),
        ):
            ret = postgres.db_list(
                user="testuser",
                host="testhost",
                port="testport",
                maintenance_db="maint_db",
                password="foo",
                runas="foo",
            )
            self.assertDictEqual(
                ret,
                {
                    "test_db": {
                        "Encoding": "LATIN1",
                        "Ctype": "en_US",
                        "Tablespace": "pg_default",
                        "Collate": "en_US",
                        "Owner": "postgres",
                        "Access privileges": "",
                    },
                    "template1": {
                        "Encoding": "LATIN1",
                        "Ctype": "en_US",
                        "Tablespace": "pg_default",
                        "Collate": "en_US",
                        "Owner": "postgres",
                        "Access privileges": "{=c/postgres,postgres=CTc/postgres}",
                    },
                    "template0": {
                        "Encoding": "LATIN1",
                        "Ctype": "en_US",
                        "Tablespace": "pg_default",
                        "Collate": "en_US",
                        "Owner": "postgres",
                        "Access privileges": "{=c/postgres,postgres=CTc/postgres}",
                    },
                    "postgres": {
                        "Encoding": "LATIN1",
                        "Ctype": "en_US",
                        "Tablespace": "pg_default",
                        "Collate": "en_US",
                        "Owner": "postgres",
                        "Access privileges": "",
                    },
                },
            )
    def test_db_remove(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            postgres.db_remove(
                "test_db",
                user="testuser",
                host="testhost",
                port="testport",
                maintenance_db="maint_db",
                password="foo",
                runas="foo",
            )
            calls = (
                call(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "maint_db",
                        "-c",
                        'REVOKE CONNECT ON DATABASE "test_db" FROM public;',
                    ],
                    host="testhost",
                    password="foo",
                    port="testport",
                    runas="foo",
                    user="testuser",
                ),
                call(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "maint_db",
                        "-c",
                        "SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity"
                        " WHERE datname = 'test_db' AND pid &lt;&gt; pg_backend_pid();",
                    ],
                    host="testhost",
                    password="foo",
                    port="testport",
                    runas="foo",
                    user="testuser",
                ),
                call(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "maint_db",
                        "-c",
                        'DROP DATABASE "test_db";',
                    ],
                    host="testhost",
                    password="foo",
                    port="testport",
                    runas="foo",
                    user="testuser",
                ),
            )
            postgres._run_psql.assert_has_calls(calls, any_order=True)
    def test_group_create(self):
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.user_exists", Mock(return_value<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False)):
                postgres.group_create(
                    "testgroup",
                    user="testuser",
                    host="testhost",
                    port="testport",
                    maintenance_db="maint_db",
                    password="foo",
                    createdb=False,
                    encrypted=False,
                    superuser=False,
                    replication=False,
                    rolepassword="testrolepass",
                    groups="testgroup",
                    runas=</b></font>"foo",
                )
                self.assertTrue(
                    postgres._run_psql.call_args[0][0][14].startswith("CREATE ROLE")
                )
    def test_group_remove(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.user_exists", Mock(return_value=True)):
                postgres.group_remove(
                    "testgroup",
                    user="testuser",
                    host="testhost",
                    port="testport",
                    maintenance_db="maint_db",
                    password="foo",
                    runas="foo",
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "maint_db",
                        "-c",
                        'DROP ROLE "testgroup"',
                    ],
                    host="testhost",
                    user="testuser",
                    password="foo",
                    runas="foo",
                    port="testport",
                )
    def test_group_update(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                Mock(return_value={"superuser": False}),
            ):
                postgres<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.group_update(
                    "testgroup",
                    user='"testuser"',
                    host="testhost",
                    port="testport",
                    maintenance_db="maint_db",
                    password="foo",
                    createdb=False,
                    encrypted=False,
                    replication=False,
                    rolepassword="test_role_pass",
                    groups="testgroup",
                    runas=</b></font>"foo",
                )
                self.assertTrue(
                    re.match(
                        'ALTER.* "testgroup" .* UNENCRYPTED PASSWORD',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )
    def test_user_create(self):
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.user_exists", Mock(return_value<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False)):
                postgres.user_create(
                    "testuser",
                    user="testuser",
                    host="testhost",
                    port="testport",
                    maintenance_db="maint_test",
                    password="test_pass",
                    login=True,
                    createdb=False,
                    createroles=False,
                    encrypted=False,
                    superuser=False,
                    replication=False,
                    rolepassword="test_role_pass",
                    valid_until="2042-07-01",
                    groups="test_groups",
                    runas="foo",
                )
                call =</b></font> postgres._run_psql.call_args[0][0][14]
                self.assertTrue(re.match('CREATE ROLE "testuser"', call))
                for i in (
                    "INHERIT",
                    "NOCREATEDB",
                    "NOCREATEROLE",
                    "NOSUPERUSER",
                    "NOREPLICATION",
                    "LOGIN",
                    "UNENCRYPTED",
                    "PASSWORD",
                    "VALID UNTIL",
                ):
                    self.assertTrue(i in call, "{} not in {}".format(i, call))
    def test_user_exists(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.version", Mock(return_value="9.1")):
                with patch(
                    "salt.modules.postgres.psql_query",
                    Mock(
                        return_value=[
                            {
                                "name": "test_user",
                                "superuser": "t",
                                "inherits privileges": "t",
                                "can create roles": "t",
                                "can create databases": "t",
                                "can update system catalogs": "t",
                                "can login": "t",
                                "replication": None,
                                "password": "test_password",
                                "connections": "-1",
                                "groups": "",
                                "expiry time": "",
                                "defaults variables": None,
                            }
                        ]
                    ),
                ):
                    ret = postgres.user_exists(
                        "test_user",
                        user="test_user",
                        host="test_host",
                        port="test_port",
                        maintenance_db="maint_db",
                        password="test_password",
                        runas="foo",
                    )
                    self.assertTrue(ret)
    def test_user_list(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.version", Mock(return_value="9.1")):
                with patch(
                    "salt.modules.postgres.psql_query",
                    Mock(
                        return_value=[
                            {
                                "name": "test_user",
                                "superuser": "t",
                                "inherits privileges": "t",
                                "can create roles": "t",
                                "can create databases": "t",
                                "can update system catalogs": "t",
                                "can login": "t",
                                "replication": None,
                                "connections": "-1",
                                "groups": "",
                                "expiry time": "2017-08-16 08:57:46",
                                "defaults variables": None,
                            }
                        ]
                    ),
                ):
                    ret = postgres.user_list(
                        "test_user",
                        host="test_host",
                        port="test_port",
                        maintenance_db="maint_db",
                        password="test_password",
                        runas="foo",
                    )
                    self.assertDictEqual(
                        ret,
                        {
                            "test_user": {
                                "superuser": True,
                                "defaults variables": None,
                                "can create databases": True,
                                "can create roles": True,
                                "connections": None,
                                "replication": None,
                                "expiry time": datetime.datetime(
                                    2017, 8, 16, 8, 57, 46
                                ),
                                "can login": True,
                                "can update system catalogs": True,
                                "groups": [],
                                "inherits privileges": True,
                            }
                        },
                    )
    def test_user_remove(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.version", Mock(return_value="9.1")):
                with patch(
                    "salt.modules.postgres.user_exists", Mock(return_value=True)
                ):
                    postgres.user_remove(
                        "testuser",
                        user="testuser",
                        host="testhost",
                        port="testport",
                        maintenance_db="maint_db",
                        password="testpassword",
                        runas="foo",
                    )
                    postgres._run_psql.assert_called_once_with(
                        [
                            "/usr/bin/pgsql",
                            "--no-align",
                            "--no-readline",
                            "--no-psqlrc",
                            "--no-password",
                            "--username",
                            "testuser",
                            "--host",
                            "testhost",
                            "--port",
                            "testport",
                            "--dbname",
                            "maint_db",
                            "-c",
                            'DROP ROLE "testuser"',
                        ],
                        host="testhost",
                        port="testport",
                        user="testuser",
                        password="testpassword",
                        runas="foo",
                    )
    def test_user_update(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                Mock(return_value={"superuser": False}),
            ):
                postgres<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
                    "test_username",
                    user="test_user",
                    host="test_host",
                    port="test_port",
                    maintenance_db="test_maint",
                    password="test_pass",
                    createdb=False,
                    createroles=False,
                    encrypted=False,
                    inherit=True,
                    login=True,
                    replication=False,
                    rolepassword="test_role_pass",
                    valid_until="2017-07-01",
                    groups="test_groups",
                    runas=</b></font>"foo",
                )
                self.assertTrue(
                    re.match(
                        'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
                        "NOCREATEROLE NOREPLICATION LOGIN "
                        "UNENCRYPTED PASSWORD ['\"]{0,5}test_role_pass['\"]{0,5} "
                        "VALID UNTIL '2017-07-01';"
                        ' GRANT "test_groups" TO "test_username"',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )
    def test_user_update2(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                Mock(return_value={"superuser": False}),
            ):
                postgres<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
                    "test_username",
                    user="test_user",
                    host="test_host",
                    port="test_port",
                    maintenance_db="test_maint",
                    password="test_pass",
                    createdb=False,
                    createroles=True,
                    encrypted=False,
                    inherit=True,
                    login=True,
                    replication=False,
                    groups="test_groups",
                    runas=</b></font>"foo",
                )
                self.assertTrue(
                    re.match(
                        'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
                        "CREATEROLE NOREPLICATION LOGIN;"
                        ' GRANT "test_groups" TO "test_username"',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )
    def test_user_update3(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                Mock(return_value={"superuser": False}),
            ):
                postgres<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
                    "test_username",
                    user="test_user",
                    host="test_host",
                    port="test_port",
                    maintenance_db="test_maint",
                    password="test_pass",
                    createdb=False,
                    createroles=True,
                    encrypted=False,
                    inherit=True,
                    login=True,
                    rolepassword=False,
                    replication=False,
                    groups="test_groups",
                    runas=</b></font>"foo",
                )
                self.assertTrue(
                    re.match(
                        'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
                        "CREATEROLE NOREPLICATION LOGIN NOPASSWORD;"
                        ' GRANT "test_groups" TO "test_username"',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )
    def test_user_update_encrypted_passwd(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                Mock(return_value={"superuser": False}),
            ):
                postgres<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
                    "test_username",
                    user="test_user",
                    host="test_host",
                    port="test_port",
                    maintenance_db="test_maint",
                    password="test_pass",
                    createdb=False,
                    createroles=True,
                    encrypted=True,
                    inherit=True,
                    login=True,
                    rolepassword="foobar",
                    replication=False,
                    groups="test_groups",
                    runas=</b></font>"foo",
                )
                self.assertTrue(
                    re.match(
                        'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
                        "CREATEROLE NOREPLICATION LOGIN "
                        "ENCRYPTED PASSWORD "
                        "['\"]{0,5}md531c27e68d3771c392b52102c01be1da1['\"]{0,5}"
                        '; GRANT "test_groups" TO "test_username"',
                        postgres._run_psql.call_args[0][0][14],
                    )
                )
    def test_version(self):
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": "9.1.9"}),
        ):
            postgres.version(
                user="test_user",
                host="test_host",
                port="test_port",
                maintenance_db="test_maint",
                password="test_pass",
                runas="foo",
            )
            self.assertTrue(
                re.match(
                    "SELECT setting FROM pg_catalog.pg_settings",
                    postgres._run_psql.call_args[0][0][14],
                )
            )
    def test_installed_extensions(self):
        with patch(
            "salt.modules.postgres.psql_query",
            Mock(return_value=[{"extname": "foo", "extversion": "1"}]),
        ):
            exts = postgres.installed_extensions()
            self.assertEqual(exts, {"foo": {"extversion": "1", "extname": "foo"}})
    def test_available_extensions(self):
        with patch(
            "salt.modules.postgres.psql_query",
            Mock(return_value=[{"name": "foo", "default_version": "1"}]),
        ):
            exts = postgres.available_extensions()
            self.assertEqual(exts, {"foo": {"default_version": "1", "name": "foo"}})
    def test_drop_extension2(self):
        with patch(
            "salt.modules.postgres.installed_extensions", Mock(side_effect=[{}, {}])
        ):
            with patch(
                "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
            ):
                with patch(
                    "salt.modules.postgres.available_extensions",
                    Mock(return_value={"foo": {"default_version": "1", "name": "foo"}}),
                ):
                    self.assertEqual(postgres.drop_extension("foo"), True)
    def test_drop_extension3(self):
        with patch(
            "salt.modules.postgres.installed_extensions",
            Mock(side_effect=[{"foo": {"extversion": "1", "extname": "foo"}}, {}]),
        ):
            with patch(
                "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
            ):
                with patch(
                    "salt.modules.postgres.available_extensions",
                    Mock(return_value={"foo": {"default_version": "1", "name": "foo"}}),
                ):
                    self.assertEqual(postgres.drop_extension("foo"), True)
    def test_drop_extension1(self):
        with patch(
            "salt.modules.postgres.installed_extensions",
            Mock(
                side_effect=[
                    {"foo": {"extversion": "1", "extname": "foo"}},
                    {"foo": {"extversion": "1", "extname": "foo"}},
                ]
            ),
        ):
            with patch(
                "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
            ):
                with patch(
                    "salt.modules.postgres.available_extensions",
                    Mock(return_value={"foo": {"default_version": "1", "name": "foo"}}),
                ):
                    self.assertEqual(postgres.drop_extension("foo"), False)
    def test_create_mtdata(self):
        with patch(
            "salt.modules.postgres.installed_extensions",
            Mock(
                return_value={
                    "foo": {
                        "extversion": "0.8",
                        "extrelocatable": "t",
                        "schema_name": "foo",
                        "extname": "foo",
                    }
                },
            ),
        ):
            with patch(
                "salt.modules.postgres.available_extensions",
                Mock(return_value={"foo": {"default_version": "1.4", "name": "foo"}}),
            ):
                ret = postgres.create_metadata("foo", schema="bar", ext_version="1.4")
                self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
                self.assertTrue(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertTrue(postgres._EXTENSION_TO_MOVE in ret)
                ret = postgres.create_metadata("foo", schema="foo", ext_version="0.4")
                self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
                ret = postgres.create_metadata("foo")
                self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
                ret = postgres.create_metadata("foobar")
                self.assertTrue(postgres._EXTENSION_NOT_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_INSTALLED in ret)
                self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
                self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
    def test_create_extension_newerthan(self):
        """
        scenario of creating upgrading extensions with possible schema and
        version specifications
        """
        with patch(
            "salt.modules.postgres.create_metadata",
            Mock(
                side_effect=[
                    [postgres._EXTENSION_NOT_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_NOT_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_NOT_INSTALLED],
                    [postgres._EXTENSION_NOT_INSTALLED],
                    [
                        postgres._EXTENSION_TO_MOVE,
                        postgres._EXTENSION_TO_UPGRADE,
                        postgres._EXTENSION_INSTALLED,
                    ],
                    [postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
                    [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
                ]
            ),
        ):
            with patch(
                "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
            ):
                with patch(
                    "salt.modules.postgres.available_extensions",
                    Mock(
                        return_value={"foo": {"default_version": "1.4", "name": "foo"}}
                    ),
                ):
                    self.assertTrue(postgres.create_extension("foo"))
                    self.assertTrue(
                        re.match(
                            'CREATE EXTENSION IF NOT EXISTS "foo" ;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    self.assertTrue(
                        postgres.create_extension(
                            "foo", schema="a", ext_version="b", from_version="c"
                        )
                    )
                    self.assertTrue(
                        re.match(
                            'CREATE EXTENSION IF NOT EXISTS "foo" '
                            'WITH SCHEMA "a" VERSION b FROM c ;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    self.assertFalse(postgres.create_extension("foo"))
                    ret = postgres.create_extension("foo", ext_version="a", schema="b")
                    self.assertTrue(ret)
                    self.assertTrue(
                        re.match(
                            'ALTER EXTENSION "foo" SET SCHEMA "b";'
                            ' ALTER EXTENSION "foo" UPDATE TO a;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    ret = postgres.create_extension("foo", ext_version="a", schema="b")
                    self.assertTrue(ret)
                    self.assertTrue(
                        re.match(
                            'ALTER EXTENSION "foo" SET SCHEMA "b";',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    ret = postgres.create_extension("foo", ext_version="a", schema="b")
                    self.assertTrue(ret)
                    self.assertTrue(
                        re.match(
                            'ALTER EXTENSION "foo" UPDATE TO a;',
                            postgres._psql_prepare_and_run.call_args[0][0][1],
                        )
                    )
                    self.assertFalse(
                        postgres.create_extension("foo", ext_version="a", schema="b")
                    )
                    self.assertFalse(
                        postgres.create_extension("foo", ext_version="a", schema="b")
                    )
    def test_encrypt_passwords(self):
        self.assertEqual(postgres._maybe_encrypt_password("foo", "bar", False), "bar")
        self.assertEqual(
            postgres._maybe_encrypt_password("foo", "bar", True),
            "md596948aad3fcae80c08a35c9b5958cd89",
        )
    def test_schema_list(self):
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": test_list_schema_csv}),
        ):
            ret = postgres.schema_list(
                "maint_db",
                db_user="testuser",
                db_host="testhost",
                db_port="testport",
                db_password="foo",
            )
            self.assertDictEqual(
                ret,
                {
                    "public": {
                        "acl": "{postgres=UC/postgres,=UC/postgres}",
                        "owner": "postgres",
                    },
                    "pg_toast": {"acl": "", "owner": "postgres"},
                },
            )
    def test_schema_exists(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.psql_query",
                Mock(
                    return_value=[
                        {
                            "name": "public",
                            "acl": "{postgres=UC/postgres,=UC/postgres}",
                            "owner": "postgres",
                        }
                    ]
                ),
            ):
                ret = postgres.schema_exists("template1", "public")
                self.assertTrue(ret)
    def test_schema_get(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.psql_query",
                Mock(
                    return_value=[
                        {
                            "name": "public",
                            "acl": "{postgres=UC/postgres,=UC/postgres}",
                            "owner": "postgres",
                        }
                    ]
                ),
            ):
                ret = postgres.schema_get("template1", "public")
                self.assertTrue(ret)
    def test_schema_get_again(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.psql_query",
                Mock(
                    return_value=[
                        {
                            "name": "public",
                            "acl": "{postgres=UC/postgres,=UC/postgres}",
                            "owner": "postgres",
                        }
                    ]
                ),
            ):
                ret = postgres.schema_get("template1", "pg_toast")
                self.assertFalse(ret)
    def test_schema_create(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.schema_exists", Mock(return_value=False)):
                postgres.schema_create(
                    "maint_db",
                    "testschema",
                    user="user",
                    db_host="testhost",
                    db_port="testport",
                    db_user="testuser",
                    db_password="testpassword",
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "maint_db",
                        "-c",
                        'CREATE SCHEMA "testschema"',
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_schema_create2(self):
        with patch("salt.modules.postgres.schema_exists", Mock(return_value=True)):
            ret = postgres.schema_create(
                "test_db",
                "test_schema",
                user="user",
                db_host="test_host",
                db_port="test_port",
                db_user="test_user",
                db_password="test_password",
            )
            self.assertFalse(ret)
    def test_schema_remove(self):
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.schema_exists", Mock(return_value=True)):
                postgres.schema_remove(
                    "maint_db",
                    "testschema",
                    user="user",
                    db_host="testhost",
                    db_port="testport",
                    db_user="testuser",
                    db_password="testpassword",
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "maint_db",
                        "-c",
                        'DROP SCHEMA "testschema"',
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_schema_remove2(self):
        with patch("salt.modules.postgres.schema_exists", Mock(return_value=False)):
            ret = postgres.schema_remove(
                "test_db",
                "test_schema",
                user="user",
                db_host="test_host",
                db_port="test_port",
                db_user="test_user",
                db_password="test_password",
            )
            self.assertFalse(ret)
    def test_language_list(self):
        """
        Test language listing
        """
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": test_list_language_csv}),
        ):
            ret = postgres.language_list(
                "testdb",
                user="testuser",
                host="testhost",
                port="testport",
                password="foo",
            )
            self.assertDictEqual(
                ret,
                {"c": "c", "internal": "internal", "plpgsql": "plpgsql", "sql": "sql"},
            )
    def test_language_exists(self):
        """
        Test language existence check
        """
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.psql_query",
                Mock(
                    return_value=[
                        {"Name": "internal"},
                        {"Name": "c"},
                        {"Name": "sql"},
                        {"Name": "plpgsql"},
                    ]
                ),
            ):
                with patch(
                    "salt.modules.postgres.language_exists", Mock(return_value=True)
                ):
                    ret = postgres.language_exists("sql", "testdb")
                    self.assertTrue(ret)
    def test_language_create(self):
        """
        Test language creation - does not exist in db
        """
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.language_exists", Mock(return_value=False)
            ):
                postgres.language_create(
                    "plpythonu",
                    "testdb",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "testdb",
                        "-c",
                        "CREATE LANGUAGE plpythonu",
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_language_create_exists(self):
        """
        Test language creation - already exists in db
        """
        with patch("salt.modules.postgres.language_exists", Mock(return_value=True)):
            ret = postgres.language_create(
                "plpythonu",
                "testdb",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertFalse(ret)
    def test_language_remove(self):
        """
        Test language removal - exists in db
        """
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.language_exists", Mock(return_value=True)
            ):
                postgres.language_remove(
                    "plpgsql",
                    "testdb",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "testdb",
                        "-c",
                        "DROP LANGUAGE plpgsql",
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_language_remove_non_exist(self):
        """
        Test language removal - does not exist in db
        """
        with patch("salt.modules.postgres.language_exists", Mock(return_value=False)):
            ret = postgres.language_remove(
                "plpgsql",
                "testdb",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertFalse(ret)
    def test_privileges_list_table(self):
        """
        Test privilege listing on a table
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={"retcode": 0, "stdout": test_privileges_list_table_csv}),
        ):
            ret = postgres.privileges_list(
                "awl",
                "table",
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            expected =</b></font> {
                "bayestest": {
                    "INSERT": False,
                    "UPDATE": False,
                    "SELECT": False,
                    "DELETE": False,
                },
                "baruwa": {
                    "INSERT": True,
                    "TRUNCATE": True,
                    "UPDATE": True,
                    "TRIGGER": True,
                    "REFERENCES": True,
                    "SELECT": True,
                    "DELETE": True,
                },
                "baruwatest": {
                    "INSERT": False,
                    "TRUNCATE": False,
                    "UPDATE": False,
                    "TRIGGER": False,
                    "REFERENCES": False,
                    "SELECT": False,
                    "DELETE": False,
                },
            }
            self.assertDictEqual(ret, expected)
            query = (
                "COPY (SELECT relacl AS name FROM pg_catalog.pg_class c "
                "JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace "
                "WHERE nspname = 'public' AND relname = 'awl' AND relkind = 'r' "
                "ORDER BY relname) TO STDOUT WITH CSV HEADER"
            )
            postgres._run_psql.assert_called_once_with(
                [
                    "/usr/bin/pgsql",
                    "--no-align",
                    "--no-readline",
                    "--no-psqlrc",
                    "--no-password",
                    "--username",
                    "testuser",
                    "--host",
                    "testhost",
                    "--port",
                    "testport",
                    "--dbname",
                    "db_name",
                    "-v",
                    "datestyle=ISO,MDY",
                    "-c",
                    query,
                ],
                host="testhost",
                port="testport",
                password="testpassword",
                user="testuser",
                runas="user",
            )
    def test_privileges_list_group(self):
        """
        Test privilege listing on a group
        """
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": test_privileges_list_group_csv}),
        ):
            ret = postgres.privileges_list(
                "admin",
                "group",
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            expected = {
                "baruwa": False,
                "baruwatest": False,
                "baruwatest2": True,
            }
            self.assertDictEqual(ret, expected)
            query = (
                "COPY (SELECT rolname, admin_option "
                "FROM pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles r "
                "ON m.member=r.oid WHERE m.roleid IN (SELECT oid FROM "
                "pg_catalog.pg_roles WHERE rolname='admin') ORDER BY rolname) "
                "TO STDOUT WITH CSV HEADER"
            )
            postgres._run_psql.assert_called_once_with(
                [
                    "/usr/bin/pgsql",
                    "--no-align",
                    "--no-readline",
                    "--no-psqlrc",
                    "--no-password",
                    "--username",
                    "testuser",
                    "--host",
                    "testhost",
                    "--port",
                    "testport",
                    "--dbname",
                    "db_name",
                    "-v",
                    "datestyle=ISO,MDY",
                    "-c",
                    query,
                ],
                host="testhost",
                port="testport",
                password="testpassword",
                user="testuser",
                runas="user",
            )
    def test_has_privileges_on_table(self):
        """
        Test privilege checks on table
        """
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": test_privileges_list_table_csv}),
        ):
            ret = postgres.has_privileges(
                "baruwa",
                "awl",
                "table",
                "SELECT,INSERT",
                grant_option=True,
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertTrue(ret)
            ret = postgres.has_privileges(
                "baruwa",
                "awl",
                "table",
                "ALL",
                grant_option=True,
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertTrue(ret)
            ret = postgres.has_privileges(
                "baruwa",
                "awl",
                "table",
                "ALL",
                grant_option=False,
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertTrue(ret)
            ret = postgres.has_privileges(
                "bayestest",
                "awl",
                "table",
                "SELECT,INSERT,TRUNCATE",
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertFalse(ret)
            ret = postgres.has_privileges(
                "bayestest",
                "awl",
                "table",
                "SELECT,INSERT",
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertTrue(ret)
    def test_has_privileges_on_group(self):
        """
        Test privilege checks on group
        """
        with patch(
            "salt.modules.postgres._run_psql",
            Mock(return_value={"retcode": 0, "stdout": test_privileges_list_group_csv}),
        ):
            ret = postgres.has_privileges(
                "baruwa",
                "admin",
                "group",
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertTrue(ret)
            ret = postgres.has_privileges(
                "baruwa",
                "admin",
                "group",
                grant_option=True,
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertFalse(ret)
            ret = postgres.has_privileges(
                "tony",
                "admin",
                "group",
                maintenance_db="db_name",
                runas="user",
                host="testhost",
                port="testport",
                user="testuser",
                password="testpassword",
            )
            self.assertFalse(ret)
    def test_privileges_grant_table(self):
        """
        Test granting privileges on table
        """
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.has_privileges", Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    "baruwa",
                    "awl",
                    "table",
                    "ALL",
                    grant_option=True,
                    maintenance_db="db_name",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                query = 'GRANT ALL ON TABLE public."awl" TO "baruwa" WITH GRANT OPTION'
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "db_name",
                        "-c",
                        query,
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.has_privileges", Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    "baruwa",
                    "awl",
                    "table",
                    "ALL",
                    maintenance_db="db_name",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                query = 'GRANT ALL ON TABLE public."awl" TO "baruwa"'
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "db_name",
                        "-c",
                        query,
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.has_privileges", Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    "baruwa",
                    "ALL",
                    "table",
                    "SELECT",
                    maintenance_db="db_name",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                query = 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO "baruwa"'
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "db_name",
                        "-c",
                        query,
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_privileges_grant_group(self):
        """
        Test granting privileges on group
        """
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.has_privileges", Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    "baruwa",
                    "admins",
                    "group",
                    grant_option=True,
                    maintenance_db="db_name",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                query = 'GRANT admins TO "baruwa" WITH ADMIN OPTION'
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "db_name",
                        "-c",
                        query,
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.has_privileges", Mock(return_value=False)
            ):
                ret = postgres.privileges_grant(
                    "baruwa",
                    "admins",
                    "group",
                    maintenance_db="db_name",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                query = 'GRANT admins TO "baruwa"'
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "db_name",
                        "-c",
                        query,
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_privileges_revoke_table(self):
        """
        Test revoking privileges on table
        """
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.has_privileges", Mock(return_value=True)):
                ret = postgres.privileges_revoke(
                    "baruwa",
                    "awl",
                    "table",
                    "ALL",
                    maintenance_db="db_name",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                query = "REVOKE ALL ON TABLE public.awl FROM baruwa"
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "db_name",
                        "-c",
                        query,
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_privileges_revoke_group(self):
        """
        Test revoking privileges on group
        """
        with patch(
            "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
        ):
            with patch("salt.modules.postgres.has_privileges", Mock(return_value=True)):
                ret = postgres.privileges_revoke(
                    "baruwa",
                    "admins",
                    "group",
                    maintenance_db="db_name",
                    runas="user",
                    host="testhost",
                    port="testport",
                    user="testuser",
                    password="testpassword",
                )
                query = "REVOKE admins FROM baruwa"
                postgres._run_psql.assert_called_once_with(
                    [
                        "/usr/bin/pgsql",
                        "--no-align",
                        "--no-readline",
                        "--no-psqlrc",
                        "--no-password",
                        "--username",
                        "testuser",
                        "--host",
                        "testhost",
                        "--port",
                        "testport",
                        "--dbname",
                        "db_name",
                        "-c",
                        query,
                    ],
                    host="testhost",
                    port="testport",
                    password="testpassword",
                    user="testuser",
                    runas="user",
                )
    def test_datadir_init(self):
        """
        Test Initializing a postgres data directory
        """
        with patch(
            "salt.modules.postgres._run_initdb", Mock(return_value={"retcode": 0})
        ):
            with patch(
                "salt.modules.postgres.datadir_exists", Mock(return_value=False)
            ):
                name = "/var/lib/pgsql/data"
                ret = postgres.datadir_init(
                    name, user="postgres", password="test", runas="postgres"
                )
                postgres._run_initdb.assert_called_once_with(
                    name,
                    auth="password",
                    encoding="UTF8",
                    locale=None,
                    password="test",
                    runas="postgres",
                    checksums=False,
                    waldir=None,
                    user="postgres",
                )
                self.assertTrue(ret)
    def test_datadir_exists(self):
        """
        Test Checks if postgres data directory has been initialized
        """
        with patch("os.path.isfile", Mock(return_value=True)):
            name = "/var/lib/pgsql/data"
            ret = postgres.datadir_exists(name)
            self.assertTrue(ret)
    def test_pg_is_older_ext_ver(self):
        """
        Test Checks if postgres extension version string is older
        """
        self.assertTrue(postgres._pg_is_older_ext_ver("8.5", "9.5"))
        self.assertTrue(postgres._pg_is_older_ext_ver("8.5", "8.6"))
        self.assertTrue(postgres._pg_is_older_ext_ver("8.5.2", "8.5.3"))
        self.assertFalse(postgres._pg_is_older_ext_ver("9.5", "8.5"))
        self.assertTrue(postgres._pg_is_older_ext_ver("9.5", "9.6"))
        self.assertTrue(postgres._pg_is_older_ext_ver("9.5.0", "9.5.1"))
        self.assertTrue(postgres._pg_is_older_ext_ver("9.5", "9.5.1"))
        self.assertFalse(postgres._pg_is_older_ext_ver("9.5.1", "9.5"))
        self.assertFalse(postgres._pg_is_older_ext_ver("9.5b", "9.5a"))
        self.assertTrue(postgres._pg_is_older_ext_ver("10a", "10b"))
        self.assertTrue(postgres._pg_is_older_ext_ver("1.2.3.4", "1.2.3.5"))
        self.assertTrue(postgres._pg_is_older_ext_ver("10dev", "10next"))
        self.assertFalse(postgres._pg_is_older_ext_ver("10next", "10dev"))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bigip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
"""
A state module designed to enforce load-balancing configurations for F5 Big-IP entities.
    :maturity:      develop
    :platform:      f5_bigip_11.6
"""
import salt.utils.json
def __virtual__():
    """
    Only load if the bigip exec module is available in __salt__
    """
    if "bigip.list_transaction" in __salt__:
        return "bigip"
    return (False, "bigip module could not be loaded")
def _load_result(response, ret):
    """
    format the results of listing functions
    """
    if response["code"] is None:
        ret["comment"] = response["content"]
    elif response["code"] == 401:
        ret["comment"] = "401 Forbidden: Authentication required!"
    elif response["code"] == 404:
        ret["comment"] = response["content"]["message"]
    elif response["code"] == 200:
        ret["result"] = True
        ret["comment"] = (
            "Listing Current Configuration Only.  "
            "Not action or changes occurred during the execution of this state."
        )
        ret["changes"] = response["content"]
    else:
        ret["comment"] = response["content"]["message"]
    return ret
def _strip_key(dictionary, keyword):
    """
    look for a certain key within a dictionary and nullify ti's contents, check within nested
    dictionaries and lists as well.  Certain attributes such as "generation" will change even
    when there were no changes made to the entity.
    """
    for key, value in dictionary.items():
        if key == keyword:
            dictionary[key] = None
        elif isinstance(value, dict):
            _strip_key(value, keyword)
        elif isinstance(value, list):
            for item in value:
                if isinstance(item, dict):
                    _strip_key(item, keyword)
    return dictionary
def _check_for_changes(entity_type, ret, existing, modified):
    """
    take an existing entity and a modified entity and check for changes.
    """
    ret["result"] = True
    if isinstance(existing, dict) and isinstance(modified, dict):
        if "generation" in modified["content"].keys():
            del modified["content"]["generation"]
        if "generation" in existing["content"].keys():
            del existing["content"]["generation"]
        if modified["content"] == existing["content"]:
            ret["comment"] = (
                "{entity_type} is currently enforced to the desired state.  No changes"
                " made.".format(entity_type=entity_type)
            )
        else:
            ret["comment"] = (
                "{entity_type} was enforced to the desired state.  Note: Only"
                " parameters specified were enforced. See changes for details.".format(
                    entity_type=entity_type
                )
            )
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = modified["content"]
    else:
        if modified == existing:
            ret["comment"] = (
                "{entity_type} is currently enforced to the desired state.  No changes"
                " made.".format(entity_type=entity_type)
            )
        else:
            ret["comment"] = (
                "{entity_type} was enforced to the desired state.  Note: Only"
                " parameters specified were enforced. See changes for details.".format(
                    entity_type=entity_type
                )
            )
            ret["changes"]["old"] = existing
            ret["changes"]["new"] = modified
    return ret
def _test_output(ret, action, params):
    """
    For testing just output what the state will attempt to do without actually doing it.
    """
    if action == "list":
        ret[
            "comment"
        ] += "The list action will just list an entity and will make no changes.\n"
    elif action == "create" or action == "add":
        ret["comment"] += (
            "The create action will attempt to create an entity if it does not already"
            " exist.\n"
        )
    elif action == "delete":
        ret["comment"] += (
            "The delete action will attempt to delete an existing entity if it"
            " exists.\n"
        )
    elif action == "manage":
        ret["comment"] += (
            "The manage action will create a new entity if it does not exist.  If it"
            " does exist, it will be enforcedto the desired state.\n"
        )
    elif action == "modify":
        ret["comment"] += (
            "The modify action will attempt to modify an existing entity only if it"
            " exists.\n"
        )
    ret["comment"] += "An iControl REST Request will be made using the parameters:\n"
    ret["comment"] += salt.utils.json.dumps(params, indent=4)
    ret["changes"] = {}
    ret["result"] = None
    return ret
def list_node(hostname, username, password, name):
    """
    A function to connect to a bigip device and list a specific node.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to list.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    response = __salt__["bigip.list_node"](hostname, username, password, name)
    return _load_result(response, ret)
def create_node(hostname, username, password, name, address):
    """
    Create a new node if it does not already exist.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to create
    address
        The address of the node
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "address": address,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A node by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response = __salt__["bigip.create_node"](
            hostname, username, password, name, address
        )
        ret["result"] = True
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = response["content"]
        ret["comment"] = "Node was successfully created."
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_node(
    hostname,
    username,
    password,
    name,
    address,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    """
    Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,
    only the properties which are different than the existing will be updated.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to manage.
    address
        The address of the node
    connection_limit
        [integer]
    description
        [string]
    dynam
        c_ratio:        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "address": address,
                "connection_limit": connection_limit,
                "description": description,
                "dynamic_ratio": dynamic_ratio,
                "logging": logging,
                "monitor": monitor,
                "rate_limit": rate_limit,
                "ratio": ratio,
                "session": session,
                "state:": node_state,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        if existing["content"]["address"] != address:
            ret["result"] = False
            ret[
            ] = "A node with this name exists but the address does not match."
        modified <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["bigip.modify_node"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=ratio,
            session=</b></font>session,
            state=node_state,
        )
        if modified["code"] == 200:
            ret = _check_for_changes("Node", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        new = __salt__["bigip.create_node"](hostname, username, password, name, address)
            modified = __salt__<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_node"](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                logging=logging,
                monitor=monitor,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=</b></font>node_state,
            )
            if modified["code"] == 200:
                ret["result"] = True
                ret["comment"] = (
                    "Node was created and enforced to the desired state.  Note: Only"
                    " parameters specified were enforced.  See changes for details."
                )
                ret["changes"]["old"] = {}
                ret["changes"]["new"] = modified["content"]
            else:
                deleted = __salt__["bigip.delete_node"](
                    hostname, username, password, name
                )
                if deleted["code"] == 200:
                    ret["comment"] = (
                        "Node was successfully created but an error occurred during"
                        " modification. The creation of the node has been rolled back."
                        " Message is as follows:\n{message}".format(
                            message=modified["content"]["message"]
                        )
                    )
                else:
                    ret["comment"] = (
                        "Node was successfully created but an error occurred during"
                        " modification. The creation of the node was not able to be"
                        " rolled back. Message is as follows:\n"
                        " {message}\n{message_two}".format(
                            message=modified["content"]["message"],
                            message_two=deleted["content"]["message"],
                        )
                    )
        else:
            ret = _load_result(new, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_node(
    hostname,
    username,
    password,
    name,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    logging=None,
    monitor=None,
    rate_limit=None,
    ratio=None,
    session=None,
    node_state=None,
):
    """
    Modify an existing node. Only a node which already exists will be modified and
    only the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node to modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    logging
        [enabled | disabled]
    monitor
        [[name] | none | default]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    node_state (state)
        [user-down | user-up ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "connection_limit": connection_limit,
                "description": description,
                "dynamic_ratio": dynamic_ratio,
                "logging": logging,
                "monitor": monitor,
                "rate_limit": rate_limit,
                "ratio": ratio,
                "session": session,
                "state:": node_state,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_node"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            connection_limit=connection_limit,
            description=description,
            dynamic_ratio=dynamic_ratio,
            logging=logging,
            monitor=monitor,
            rate_limit=rate_limit,
            ratio=</b></font>ratio,
            session=session,
            state=node_state,
        )
        if modified["code"] == 200:
            ret = _check_for_changes("Node", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A node with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_node(hostname, username, password, name):
    """
    Delete an existing node.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the node which will be deleted.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_node"](hostname, username, password, name)
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_node"](hostname, username, password, name)
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Node was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(existing, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This node already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_pool(hostname, username, password, name):
    """
    A function to connect to a bigip device and list a specific pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to list.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    response = __salt__["bigip.list_pool"](hostname, username, password, name)
    return _load_result(response, ret)
def create_pool(
    hostname,
    username,
    password,
    name,
    members=None,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    """
    Create a new node if it does not already exist.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    members
        List of members to be added to the pool
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": members,
                "allow_nat": allow_nat,
                "allow_snat": allow_snat,
                "description": description,
                "gateway_failsafe_device": gateway_failsafe_device,
                "ignore_persisted_weight": ignore_persisted_weight,
                "ip_tos_client:": ip_tos_to_client,
                "ip_tos_server": ip_tos_to_server,
                "link_qos_to_client": link_qos_to_client,
                "link_qos_to_server": link_qos_to_server,
                "load_balancing_mode": load_balancing_mode,
                "min_active_members": min_active_members,
                "min_up_members": min_up_members,
                "min_up_members_checking": min_up_members_checking,
                "monitor": monitor,
                "profiles": profiles,
                "queue_depth_limit": queue_depth_limit,
                "queue_on_connection_limit": queue_on_connection_limit,
                "queue_time_limit": queue_time_limit,
                "reselect_tries": reselect_tries,
                "service_down_action": service_down_action,
                "slow_ramp_time": slow_ramp_time,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A pool by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["bigip.create_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            members=members,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=</b></font>min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Pool was successfully created."
        else:
            ret = _load_result(existing, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    """
    Create a new pool if it does not already exist. Pool members are managed separately. Only the
    parameters specified are enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "allow_nat": allow_nat,
                "allow_snat": allow_snat,
                "description": description,
                "gateway_failsafe_device": gateway_failsafe_device,
                "ignore_persisted_weight": ignore_persisted_weight,
                "ip_tos_client:": ip_tos_to_client,
                "ip_tos_server": ip_tos_to_server,
                "link_qos_to_client": link_qos_to_client,
                "link_qos_to_server": link_qos_to_server,
                "load_balancing_mode": load_balancing_mode,
                "min_active_members": min_active_members,
                "min_up_members": min_up_members,
                "min_up_members_checking": min_up_members_checking,
                "monitor": monitor,
                "profiles": profiles,
                "queue_depth_limit": queue_depth_limit,
                "queue_on_connection_limit": queue_on_connection_limit,
                "queue_time_limit": queue_time_limit,
                "reselect_tries": reselect_tries,
                "service_down_action": service_down_action,
                "slow_ramp_time": slow_ramp_time,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=load_balancing_mode,
            min_active_members=</b></font>min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if modified["code"] == 200:
            del existing["content"]["membersReference"]
            del modified["content"]["membersReference"]
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Pool", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        new = __salt__<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.create_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=</b></font>load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if new["code"] == 200:
            ret["result"] = True
            ret["comment"] = (
                "Pool was created and enforced to the desired state.  Note: Only"
                " parameters specified were enforced.  See changes for details."
            )
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = new["content"]
        else:
            ret = _load_result(new, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_pool(
    hostname,
    username,
    password,
    name,
    allow_nat=None,
    allow_snat=None,
    description=None,
    gateway_failsafe_device=None,
    ignore_persisted_weight=None,
    ip_tos_to_client=None,
    ip_tos_to_server=None,
    link_qos_to_client=None,
    link_qos_to_server=None,
    load_balancing_mode=None,
    min_active_members=None,
    min_up_members=None,
    min_up_members_action=None,
    min_up_members_checking=None,
    monitor=None,
    profiles=None,
    queue_depth_limit=None,
    queue_on_connection_limit=None,
    queue_time_limit=None,
    reselect_tries=None,
    service_down_action=None,
    slow_ramp_time=None,
):
    """
    Modify an existing pool. Pool members are managed separately. Only the
    parameters specified are enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to create
    allow_nat
        [yes | no]
    allow_snat
        [yes | no]
    description
        [string]
    gateway_failsafe_device
        [string]
    ignore_persisted_weight
        [enabled | disabled]
    ip_tos_to_client
        [pass-through | [integer]]
    ip_tos_to_server
        [pass-through | [integer]]
    link_qos_to_client
        [pass-through | [integer]]
    link_qos_to_server
        [pass-through | [integer]]
    load_balancing_mode
        [dynamic-ratio-member | dynamic-ratio-node |
        fastest-app-response | fastest-node |
        least-connections-members |
        least-connections-node |
        least-sessions |
        observed-member | observed-node |
        predictive-member | predictive-node |
        ratio-least-connections-member |
        ratio-least-connections-node |
        ratio-member | ratio-node | ratio-session |
        round-robin | weighted-least-connections-member |
        weighted-least-connections-node]
    min_active_members
        [integer]
    min_up_members
        [integer]
    min_up_members_action
        [failover | reboot | restart-all]
    min_up_members_checking
        [enabled | disabled]
    monitor
        [name]
    profiles
        [none | profile_name]
    queue_depth_limit
        [integer]
    queue_on_connection_limit
        [enabled | disabled]
    queue_time_limit
        [integer]
    reselect_tries
        [integer]
    service_down_action
        [drop | none | reselect | reset]
    slow_ramp_time
        [integer]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "allow_nat": allow_nat,
                "allow_snat": allow_snat,
                "description": description,
                "gateway_failsafe_device": gateway_failsafe_device,
                "ignore_persisted_weight": ignore_persisted_weight,
                "ip_tos_client:": ip_tos_to_client,
                "ip_tos_server": ip_tos_to_server,
                "link_qos_to_client": link_qos_to_client,
                "link_qos_to_server": link_qos_to_server,
                "load_balancing_mode": load_balancing_mode,
                "min_active_members": min_active_members,
                "min_up_members": min_up_members,
                "min_up_members_checking": min_up_members_checking,
                "monitor": monitor,
                "profiles": profiles,
                "queue_depth_limit": queue_depth_limit,
                "queue_on_connection_limit": queue_on_connection_limit,
                "queue_time_limit": queue_time_limit,
                "reselect_tries": reselect_tries,
                "service_down_action": service_down_action,
                "slow_ramp_time": slow_ramp_time,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_pool"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            allow_nat=allow_nat,
            allow_snat=allow_snat,
            description=description,
            gateway_failsafe_device=gateway_failsafe_device,
            ignore_persisted_weight=ignore_persisted_weight,
            ip_tos_to_client=ip_tos_to_client,
            ip_tos_to_server=ip_tos_to_server,
            link_qos_to_client=link_qos_to_client,
            link_qos_to_server=link_qos_to_server,
            load_balancing_mode=</b></font>load_balancing_mode,
            min_active_members=min_active_members,
            min_up_members=min_up_members,
            min_up_members_action=min_up_members_action,
            min_up_members_checking=min_up_members_checking,
            monitor=monitor,
            profiles=profiles,
            queue_depth_limit=queue_depth_limit,
            queue_on_connection_limit=queue_on_connection_limit,
            queue_time_limit=queue_time_limit,
            reselect_tries=reselect_tries,
            service_down_action=service_down_action,
            slow_ramp_time=slow_ramp_time,
        )
        if modified["code"] == 200:
            del existing["content"]["membersReference"]
            del modified["content"]["membersReference"]
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Pool", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_pool(hostname, username, password, name):
    """
    Delete an existing pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool which will be deleted
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_pool"](hostname, username, password, name)
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Pool was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This pool already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_pool_members(hostname, username, password, name, members):
    """
    Manage the members of an existing pool.  This function replaces all current pool members.
    Only the parameters specified are enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    members
        list of pool members to manage.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": members,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        current_members = existing["content"]["membersReference"]["items"]
        modified = __salt__["bigip.replace_pool_members"](
            hostname, username, password, name, members
        )
        if modified["code"] == 200:
            new_listing = __salt__["bigip.list_pool"](
                hostname, username, password, name
            )
            if new_listing["code"] != 200:
                ret = _load_result(new_listing, ret)
                ret["comment"] = (
                    "modification of the pool was successful but an error occurred upon"
                    " retrieving new listing."
                )
                return ret
            new_members = new_listing["content"]["membersReference"]["items"]
            for current_member in current_members:
                del current_member["generation"]
            for new_member in new_members:
                del new_member["generation"]
            ret = _check_for_changes(
                "Pool Membership", ret, current_members, new_members
            )
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def add_pool_member(hostname, username, password, name, member):
    """
    A function to connect to a bigip device and add a new member to an existing pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member to add to the pool
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "add",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": member,
            },
        )
    existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing_pool["code"] == 200:
        current_members = existing_pool["content"]["membersReference"]["items"]
        exists = False
        for current_member in current_members:
            if current_member["name"] == member["name"]:
                exists = True
                break
        if exists:
            ret["result"] = True
            ret[
                "comment"
            ] = "Member: {name} already exists within this pool.  No changes made.".format(
                name=member["name"]
            )
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = {}
        else:
            new_member = __salt__["bigip.add_pool_member"](
                hostname, username, password, name, member
            )
            if new_member["code"] == 200:
                ret["result"] = True
                ret[
                    "comment"
                ] = "Member: {name} has been successfully added to the pool.".format(
                    name=member["name"]
                )
                ret["changes"]["old"] = {}
                pool_listing = __salt__["bigip.list_pool"](
                    hostname, username, password, name
                )
                if pool_listing["code"] != 200:
                    ret = _load_result(new_member, ret)
                    return ret
                members = pool_listing["content"]["membersReference"]["items"]
                for current_member in members:
                    if current_member["name"] == member["name"]:
                        added_member = current_member
                        break
                ret["changes"]["new"] = added_member
            else:
                ret = _load_result(new_member, ret)
    elif existing_pool["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing_pool, ret)
    return ret
def modify_pool_member(
    hostname,
    username,
    password,
    name,
    member,
    connection_limit=None,
    description=None,
    dynamic_ratio=None,
    inherit_profile=None,
    logging=None,
    monitor=None,
    priority_group=None,
    profiles=None,
    rate_limit=None,
    ratio=None,
    session=None,
    member_state=None,
):
    """
    A function to connect to a bigip device and modify a member of an existing pool.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to modify
    member
        The member modify
    connection_limit
        [integer]
    description
        [string]
    dynamic_ratio
        [integer]
    inherit_profile
        [enabled | disabled]
    logging
        [enabled | disabled]
    monitor
        [name]
    priority_group
        [integer]
    profiles
        [none | profile_name]
    rate_limit
        [integer]
    ratio
        [integer]
    session
        [user-enabled | user-disabled]
    member_state (state)
        [ user-up | user-down ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": member,
            },
        )
    existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing_pool["code"] == 200:
        current_members = existing_pool["content"]["membersReference"]["items"]
        exists = False
        for current_member in current_members:
            if current_member["name"] == member:
                exists = True
                existing_member = current_member
                break
        if exists:
            modified = __salt__["bigip.modify_pool_member"](
                hostname=hostname,
                username=username,
                password=password,
                name=name,
                member=member,
                connection_limit=connection_limit,
                description=description,
                dynamic_ratio=dynamic_ratio,
                inherit_profile=inherit_profile,
                logging=logging,
                monitor=monitor,
                priority_group=priority_group,
                profiles=profiles,
                rate_limit=rate_limit,
                ratio=ratio,
                session=session,
                state=member_state,
            )
            new_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
            if modified["code"] == 200 and modified["code"] == 200:
                new_members = new_pool["content"]["membersReference"]["items"]
                for new_member in new_members:
                    if new_member["name"] == member:
                        modified_member = new_member
                        break
                old = {"content": existing_member}
                new = {"content": modified_member}
                ret = _check_for_changes(
                    "Pool Member: {member}".format(member=member), ret, old, new
                )
            else:
                ret = _load_result(modified, ret)
        else:
            ret[
                "comment"
            ] = "Member: {name} does not exists within this pool.  No changes made.".format(
                name=member["name"]
            )
    elif existing_pool["code"] == 404:
        ret["comment"] = "A pool with this name was not found."
    else:
        ret = _load_result(existing_pool, ret)
    return ret
def delete_pool_member(hostname, username, password, name, member):
    """
    Delete an existing pool member.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the pool to be modified
    member
        The name of the member to delete from the pool
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "members": member,
            },
        )
    existing = __salt__["bigip.list_pool"](hostname, username, password, name)
    if existing["code"] == 200:
        current_members = existing["content"]["membersReference"]["items"]
        exists = False
        for current_member in current_members:
            if current_member["name"] == member:
                exists = True
                existing_member = current_member
                break
        if exists:
            deleted = __salt__["bigip.delete_pool_member"](
                hostname, username, password, name, member
            )
            if deleted["code"] == 200:
                ret["result"] = True
                ret[
                    "comment"
                ] = "Pool Member: {member} was successfully deleted.".format(
                    member=member
                )
                ret["changes"]["old"] = existing_member
                ret["changes"]["new"] = {}
        else:
            ret["result"] = True
            ret["comment"] = "This pool member already does not exist. No changes made."
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_virtual(hostname, username, password, name):
    """
    A function to list a specific virtual.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to list
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    response = __salt__["bigip.list_virtual"](hostname, username, password, name)
    return _load_result(response, ret)
def create_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    """
    A function to connect to a bigip device and create a virtual server if it does not already exists.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]
        vlan_ids
            [ list]
        enabled
            [ true | false ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "destination": destination,
                "pool": pool,
                "address_status": address_status,
                "auto_lasthop": auto_lasthop,
                "bwc_policy": bwc_policy,
                "cmp_enabled": cmp_enabled,
                "connection_limit": connection_limit,
                "dhcp_relay": dhcp_relay,
                "description": description,
                "fallback_persistence": fallback_persistence,
                "flow_eviction_policy": flow_eviction_policy,
                "gtm_score": gtm_score,
                "ip_forward": ip_forward,
                "ip_protocol": ip_protocol,
                "internal": internal,
                "twelve_forward": twelve_forward,
                "last_hop_pool": last_hop_pool,
                "mask": mask,
                "mirror": mirror,
                "nat64": nat64,
                "persist": persist,
                "profiles": profiles,
                "policies": policies,
                "rate_class": rate_class,
                "rate_limit": rate_limit,
                "rate_limit_mode": rate_limit_mode,
                "rate_limit_dst": rate_limit_dst,
                "rate_limit_src": rate_limit_src,
                "rules": rules,
                "related_rules": related_rules,
                "reject": reject,
                "source": source,
                "source_address_translation": source_address_translation,
                "source_port": source_port,
                "virtual_state": virtual_state,
                "traffic_classes": traffic_classes,
                "translate_address": translate_address,
                "translate_port": translate_port,
                "vlans": vlans,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
        ret["result"] = True
        ret["comment"] <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "A virtual by this name currently exists.  No change made."
    elif existing["code"] == 404:
        virtual = __salt__["bigip.create_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=</b></font>pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if virtual["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = virtual["content"]
            ret["comment"] = "Virtual was successfully created."
        else:
            ret = _load_result(existing, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    """
    Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the
    parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit-dst
        [integer]
    rate_limit-src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary]
        vlan_ids
            [ list]
        enabled
            [ true | false ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "manage",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "destination": destination,
                "pool": pool,
                "address_status": address_status,
                "auto_lasthop": auto_lasthop,
                "bwc_policy": bwc_policy,
                "cmp_enabled": cmp_enabled,
                "connection_limit": connection_limit,
                "dhcp_relay": dhcp_relay,
                "description": description,
                "fallback_persistence": fallback_persistence,
                "flow_eviction_policy": flow_eviction_policy,
                "gtm_score": gtm_score,
                "ip_forward": ip_forward,
                "ip_protocol": ip_protocol,
                "internal": internal,
                "twelve_forward": twelve_forward,
                "last_hop_pool": last_hop_pool,
                "mask": mask,
                "mirror": mirror,
                "nat64": nat64,
                "persist": persist,
                "profiles": profiles,
                "policies": policies,
                "rate_class": rate_class,
                "rate_limit": rate_limit,
                "rate_limit_mode": rate_limit_mode,
                "rate_limit_dst": rate_limit_dst,
                "rate_limit_src": rate_limit_src,
                "rules": rules,
                "related_rules": related_rules,
                "reject": reject,
                "source": source,
                "source_address_translation": source_address_translation,
                "source_port": source_port,
                "virtual_state": virtual_state,
                "traffic_classes": traffic_classes,
                "translate_address": translate_address,
                "translate_port": translate_port,
                "vlans": vlans,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if modified["code"] == 200:
            relisting = __salt__["bigip.list_virtual"](
                hostname, username, password, name
            )
            if relisting["code"] == 200:
                relisting = _strip_key(relisting, "generation")
                existing = _strip_key(existing, "generation")
                ret = _check_for_changes("Virtual", ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        virtual = __salt__["bigip.create_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if virtual["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = virtual["content"]
            ret[
                "comment"
            ] = "Virtual was successfully created and enforced to the desired state."
        else:
            ret = _load_result(virtual, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_virtual(
    hostname,
    username,
    password,
    name,
    destination,
    pool=None,
    address_status=None,
    auto_lasthop=None,
    bwc_policy=None,
    cmp_enabled=None,
    connection_limit=None,
    dhcp_relay=None,
    description=None,
    fallback_persistence=None,
    flow_eviction_policy=None,
    gtm_score=None,
    ip_forward=None,
    ip_protocol=None,
    internal=None,
    twelve_forward=None,
    last_hop_pool=None,
    mask=None,
    mirror=None,
    nat64=None,
    persist=None,
    profiles=None,
    policies=None,
    rate_class=None,
    rate_limit=None,
    rate_limit_mode=None,
    rate_limit_dst=None,
    rate_limit_src=None,
    rules=None,
    related_rules=None,
    reject=None,
    source=None,
    source_address_translation=None,
    source_port=None,
    virtual_state=None,
    traffic_classes=None,
    translate_address=None,
    translate_port=None,
    vlans=None,
):
    """
    Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual to create
    destination
        [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
    pool
        [ [pool_name] | none]
    address_status
        [yes | no]
    auto_lasthop
        [default | enabled | disabled ]
    bwc_policy
        [none] | string]
    cmp_enabled
        [yes | no]
    dhcp_relay
        [yes | no}
    connection_limit
        [integer]
    description
        [string]
    state
        [disabled | enabled]
    fallback_persistence
        [none | [profile name] ]
    flow_eviction_policy
        [none | [eviction policy name] ]
    gtm_score
        [integer]
    ip_forward
        [yes | no]
    ip_protocol
        [any | protocol]
    internal
        [yes | no]
    twelve_forward(12-forward)
        [yes | no]
    last_hop-pool
        [ [pool_name] | none]
    mask
        { [ipv4] | [ipv6] }
    mirror
        { [disabled | enabled | none] }
    nat64
        [enabled | disabled]
    persist
        [list]
    profiles
        [none | default | list ]
    policies
        [none | default | list ]
    rate_class
        [name]
    rate_limit
        [integer]
    rate_limit-mode
        [destination | object | object-destination |
        object-source | object-source-destination |
        source | source-destination]
    rate_limit_dst
        [integer]
    rate_limit_src
        [integer]
    rules
        [none | list ]
    related_rules
        [none | list ]
    reject
        [yes | no]
    source
        { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
    source_address_translation
        [none | snat:pool_name | lsn | automap | dictionary ]
    source_port
        [change | preserve | preserve-strict]
    state
        [enabled | disabled]
    traffic_classes
        [none | default | list ]
    translate_address
        [enabled | disabled]
    translate_port
        [enabled | disabled]
    vlans
        [none | default | dictionary ]
        vlan_ids
            [ list]
        enabled
            [ true | false ]
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "modify",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
                "destination": destination,
                "pool": pool,
                "address_status": address_status,
                "auto_lasthop": auto_lasthop,
                "bwc_policy": bwc_policy,
                "cmp_enabled": cmp_enabled,
                "connection_limit": connection_limit,
                "dhcp_relay": dhcp_relay,
                "description": description,
                "fallback_persistence": fallback_persistence,
                "flow_eviction_policy": flow_eviction_policy,
                "gtm_score": gtm_score,
                "ip_forward": ip_forward,
                "ip_protocol": ip_protocol,
                "internal": internal,
                "twelve_forward": twelve_forward,
                "last_hop_pool": last_hop_pool,
                "mask": mask,
                "mirror": mirror,
                "nat64": nat64,
                "persist": persist,
                "profiles": profiles,
                "policies": policies,
                "rate_class": rate_class,
                "rate_limit": rate_limit,
                "rate_limit_mode": rate_limit_mode,
                "rate_limit_dst": rate_limit_dst,
                "rate_limit_src": rate_limit_src,
                "rules": rules,
                "related_rules": related_rules,
                "reject": reject,
                "source": source,
                "source_address_translation": source_address_translation,
                "source_port": source_port,
                "virtual_state": virtual_state,
                "traffic_classes": traffic_classes,
                "translate_address": translate_address,
                "translate_port": translate_port,
                "vlans": vlans,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_virtual"](
            hostname=hostname,
            username=username,
            password=password,
            name=name,
            destination=destination,
            description=description,
            pool=pool,
            address_status=address_status,
            auto_lasthop=auto_lasthop,
            bwc_policy=bwc_policy,
            cmp_enabled=cmp_enabled,
            connection_limit=connection_limit,
            dhcp_relay=dhcp_relay,
            fallback_persistence=fallback_persistence,
            flow_eviction_policy=flow_eviction_policy,
            gtm_score=gtm_score,
            ip_forward=ip_forward,
            ip_protocol=ip_protocol,
            internal=internal,
            twelve_forward=twelve_forward,
            last_hop_pool=last_hop_pool,
            mask=mask,
            mirror=mirror,
            nat64=nat64,
            persist=persist,
            profiles=profiles,
            policies=policies,
            rate_class=rate_class,
            rate_limit=rate_limit,
            rate_limit_mode=rate_limit_mode,
            rate_limit_dst=rate_limit_dst,
            rate_limit_src=rate_limit_src,
            rules=rules,
            related_rules=related_rules,
            reject=reject,
            source=source,
            source_address_translation=source_address_translation,
            source_port=source_port,
            state=virtual_state,
            traffic_classes=traffic_classes,
            translate_address=translate_address,
            translate_port=translate_port,
            vlans=vlans,
        )
        if modified["code"] == 200:
            relisting = __salt__["bigip.list_virtual"](
                hostname, username, password, name
            )
            if relisting["code"] == 200:
                relisting = _strip_key(relisting, "generation")
                existing = _strip_key(existing, "generation")
                ret = _check_for_changes("Virtual", ret, existing, relisting)
            else:
                ret = _load_result(relisting, ret)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A Virtual with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_virtual(hostname, username, password, name):
    """
    Delete an existing virtual.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    name
        The name of the virtual which will be deleted
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_virtual"](hostname, username, password, name)
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Virtual was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This virtual already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_monitor(hostname, username, password, monitor_type, name):
    """
    A function to list an existing monitor.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to list
    name
        The name of the monitor to list
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "monitor_type": monitor_type,
                "name": name,
            },
        )
    response = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    return _load_result(response, ret)
def create_monitor(hostname, username, password, monitor_type, name, **kwargs):
    """
    A function to connect to a bigip device and create a monitor.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "monitor_type": monitor_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "create", params)
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A monitor by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response = __salt__["bigip.create_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Monitor was successfully created."
        else:
            ret = _load_result(response, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_monitor(hostname, username, password, monitor_type, name, **kwargs):
    """
    Create a new monitor if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "monitor_type": monitor_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "manage", params)
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Monitor", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        response = __salt__["bigip.create_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Monitor was successfully created."
        else:
            ret = _load_result(response, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_monitor(hostname, username, password, monitor_type, name, **kwargs):
    """
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "monitor_type": monitor_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "modify", params)
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_monitor"](
            hostname, username, password, monitor_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Monitor", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A Monitor with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_monitor(hostname, username, password, monitor_type, name):
    """
    Modify an existing monitor.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    monitor_type
        The type of monitor to create
    name
        The name of the monitor to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "monitor_type": monitor_type,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_monitor"](
        hostname, username, password, monitor_type, name
    )
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_monitor"](
            hostname, username, password, monitor_type, name
        )
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Monitor was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This Monitor already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
def list_profile(hostname, username, password, profile_type, name):
    """
    A function to list an existing profile.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to list
    name
        The name of the profile to list
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "list",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "profile_type": profile_type,
                "name": name,
            },
        )
    response = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    return _load_result(response, ret)
def create_profile(hostname, username, password, profile_type, name, **kwargs):
    r"""
    A function to connect to a bigip device and create a profile.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\`` when
    used within strings.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "create",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "profile_type": profile_type,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        ret["result"] = True
        ret["comment"] = "A profile by this name currently exists.  No change made."
    elif existing["code"] == 404:
        response = __salt__["bigip.create_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Profile was successfully created."
        else:
            ret = _load_result(response, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def manage_profile(hostname, username, password, profile_type, name, **kwargs):
    """
    Create a new profile if a monitor of this type and name does not already exists.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "profile_type": profile_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "manage", params)
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Profile", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        response = __salt__["bigip.create_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if response["code"] == 200:
            ret["result"] = True
            ret["changes"]["old"] = {}
            ret["changes"]["new"] = response["content"]
            ret["comment"] = "Profile was successfully created."
        else:
            ret = _load_result(existing, ret)
    else:
        ret = _load_result(existing, ret)
    return ret
def modify_profile(hostname, username, password, profile_type, name, **kwargs):
    """
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each monitor type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        params = {
            "hostname": hostname,
            "username": username,
            "password": password,
            "profile_type": profile_type,
            "name": name,
        }
        for key, value in kwargs.items():
            params[key] = value
        return _test_output(ret, "modify", params)
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        modified = __salt__["bigip.modify_profile"](
            hostname, username, password, profile_type, name, **kwargs
        )
        if modified["code"] == 200:
            del existing["content"]["selfLink"]
            del modified["content"]["selfLink"]
            ret = _check_for_changes("Profile", ret, existing, modified)
        else:
            ret = _load_result(modified, ret)
    elif existing["code"] == 404:
        ret["comment"] = "A Profile with this name was not found."
    else:
        ret = _load_result(existing, ret)
    return ret
def delete_profile(hostname, username, password, profile_type, name):
    """
    Modify an existing profile.  If it does exists, only
    the parameters specified will be enforced.
    hostname
        The host/address of the bigip device
    username
        The iControl REST username
    password
        The iControl REST password
    profile_type
        The type of profile to create
    name
        The name of the profile to create
    kwargs
        [ arg=val ] ...
        Consult F5 BIGIP user guide for specific options for each profile type.
        Typically, tmsh arg names are used.
    """
    ret = {"name": name, "changes": {}, "result": False, "comment": ""}
    if __opts__["test"]:
        return _test_output(
            ret,
            "delete",
            params={
                "hostname": hostname,
                "username": username,
                "password": password,
                "profile_type": profile_type,
                "name": name,
            },
        )
    existing = __salt__["bigip.list_profile"](
        hostname, username, password, profile_type, name
    )
    if existing["code"] == 200:
        deleted = __salt__["bigip.delete_profile"](
            hostname, username, password, profile_type, name
        )
        if deleted["code"] == 200:
            ret["result"] = True
            ret["comment"] = "Profile was successfully deleted."
            ret["changes"]["old"] = existing["content"]
            ret["changes"]["new"] = {}
        else:
            ret = _load_result(deleted, ret)
    elif existing["code"] == 404:
        ret["result"] = True
        ret["comment"] = "This Profile already does not exist. No changes made."
        ret["changes"]["old"] = {}
        ret["changes"]["new"] = {}
    else:
        ret = _load_result(existing, ret)
    return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
