<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_postgres_1.py &amp; bigip.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_postgres_1.py &amp; bigip.py
      </h3>
<h1 align="center">
        6.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_postgres_1.py (6.6956997%)<th>bigip.py (5.8851676%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(514-537)<td><a href="#" name="0">(777-793)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(696-712)<td><a href="#" name="1">(960-975)</a><td align="center"><font color="#e40000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(812-827)<td><a href="#" name="2">(1194-1208)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(774-789)<td><a href="#" name="3">(1005-1019)</a><td align="center"><font color="#d60000">16</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(737-751)<td><a href="#" name="4">(369-382)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(414-428)<td><a href="#" name="5">(338-350)</a><td align="center"><font color="#c90000">15</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(485-497)<td><a href="#" name="6">(508-519)</a><td align="center"><font color="#ae0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(1427-1439)<td><a href="#" name="7">(1966-1978)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_postgres_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import logging
3 import re
4 import salt.modules.postgres as postgres
5 from salt.exceptions import SaltInvocationError
6 from tests.support.mixins import LoaderModuleMockMixin
7 from tests.support.mock import Mock, call, patch
8 from tests.support.unit import TestCase
9 test_list_db_csv = (
10     "Name,Owner,Encoding,Collate,Ctype,Access privileges,Tablespace\n"
11     "template1,postgres,LATIN1,en_US,en_US"
12     ',"{=c/postgres,postgres=CTc/postgres}",pg_default\n'
13     "template0,postgres,LATIN1,en_US,en_US"
14     ',"{=c/postgres,postgres=CTc/postgres}",pg_default\n'
15     "postgres,postgres,LATIN1,en_US,en_US,,pg_default\n"
16     "test_db,postgres,LATIN1,en_US,en_US,,pg_default"
17 )
18 test_list_schema_csv = (
19     "name,owner,acl\n"
20     'public,postgres,"{postgres=UC/postgres,=UC/postgres}"\n'
21     'pg_toast,postgres,""'
22 )
23 test_list_language_csv = "Name\ninternal\nc\nsql\nplpgsql\n"
24 test_privileges_list_table_csv = (
25     "name\n"
26     '"{baruwatest=arwdDxt/baruwatest,bayestest=arwd/baruwatest,baruwa=a*r*w*d*D*x*t*/baruwatest}"\n'
27 )
28 test_privileges_list_group_csv = (
29     "rolname,admin_option\nbaruwa,f\nbaruwatest2,t\nbaruwatest,f\n"
30 )
31 log = logging.getLogger(__name__)
32 class PostgresTestCase(TestCase, LoaderModuleMockMixin):
33     def setup_loader_modules(self):
34         patcher = patch("salt.utils.path.which", Mock(return_value="/usr/bin/pgsql"))
35         patcher.start()
36         self.addCleanup(patcher.stop)
37         return {
38             postgres: {
39                 "__grains__": {"os_family": "Linux"},
40                 "__salt__": {
41                     "config.option": Mock(),
42                     "cmd.run_all": Mock(),
43                     "file.chown": Mock(),
44                     "file.remove": Mock(),
45                 },
46             }
47         }
48     def test_run_psql(self):
49         postgres._run_psql('echo "hi"')
50         cmd = postgres.__salt__["cmd.run_all"]
51         self.assertEqual("postgres", cmd.call_args[1]["runas"])
52     def test_db_alter(self):
53         with patch(
54             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
55         ):
56             postgres.db_alter(
57                 "dbname",
58                 user="testuser",
59                 host="testhost",
60                 port="testport",
61                 maintenance_db="maint_db",
62                 password="foo",
63                 tablespace="testspace",
64                 owner="otheruser",
65                 runas="foo",
66             )
67             postgres._run_psql.assert_has_calls(
68                 [
69                     call(
70                         [
71                             "/usr/bin/pgsql",
72                             "--no-align",
73                             "--no-readline",
74                             "--no-psqlrc",
75                             "--no-password",
76                             "--username",
77                             "testuser",
78                             "--host",
79                             "testhost",
80                             "--port",
81                             "testport",
82                             "--dbname",
83                             "maint_db",
84                             "-c",
85                             'ALTER DATABASE "dbname" OWNER TO "otheruser"',
86                         ],
87                         host="testhost",
88                         user="testuser",
89                         password="foo",
90                         runas="foo",
91                         port="testport",
92                     ),
93                     call(
94                         [
95                             "/usr/bin/pgsql",
96                             "--no-align",
97                             "--no-readline",
98                             "--no-psqlrc",
99                             "--no-password",
100                             "--username",
101                             "testuser",
102                             "--host",
103                             "testhost",
104                             "--port",
105                             "testport",
106                             "--dbname",
107                             "maint_db",
108                             "-c",
109                             'ALTER DATABASE "dbname" SET TABLESPACE "testspace"',
110                         ],
111                         host="testhost",
112                         user="testuser",
113                         password="foo",
114                         runas="foo",
115                         port="testport",
116                     ),
117                 ]
118             )
119     def test_db_alter_owner_recurse(self):
120         with patch(
121             "salt.modules.postgres.owner_to", Mock(return_value={"retcode": None})
122         ):
123             postgres.db_alter(
124                 "dbname",
125                 user="testuser",
126                 host="testhost",
127                 port="testport",
128                 maintenance_db="maint_db",
129                 password="foo",
130                 tablespace="testspace",
131                 owner="otheruser",
132                 owner_recurse=True,
133                 runas="foo",
134             )
135             postgres.owner_to.assert_called_once_with(
136                 "dbname",
137                 "otheruser",
138                 user="testuser",
139                 host="testhost",
140                 port="testport",
141                 password="foo",
142                 runas="foo",
143             )
144     def test_db_create(self):
145         with patch(
146             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
147         ):
148             postgres.db_create(
149                 "dbname",
150                 user="testuser",
151                 host="testhost",
152                 port="testport",
153                 maintenance_db="maint_db",
154                 password="foo",
155                 tablespace="testspace",
156                 owner="otheruser",
157                 runas="foo",
158             )
159             postgres._run_psql.assert_called_once_with(
160                 [
161                     "/usr/bin/pgsql",
162                     "--no-align",
163                     "--no-readline",
164                     "--no-psqlrc",
165                     "--no-password",
166                     "--username",
167                     "testuser",
168                     "--host",
169                     "testhost",
170                     "--port",
171                     "testport",
172                     "--dbname",
173                     "maint_db",
174                     "-c",
175                     'CREATE DATABASE "dbname" WITH TABLESPACE = "testspace" '
176                     'OWNER = "otheruser"',
177                 ],
178                 host="testhost",
179                 user="testuser",
180                 password="foo",
181                 runas="foo",
182                 port="testport",
183             )
184     def test_db_create_empty_string_param(self):
185         with patch(
186             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
187         ):
188             postgres.db_create(
189                 "dbname",
190                 lc_collate="",
191                 encoding="utf8",
192                 user="testuser",
193                 host="testhost",
194                 port=1234,
195                 maintenance_db="maint_db",
196                 password="foo",
197             )
198             postgres._run_psql.assert_called_once_with(
199                 [
200                     "/usr/bin/pgsql",
201                     "--no-align",
202                     "--no-readline",
203                     "--no-psqlrc",
204                     "--no-password",
205                     "--username",
206                     "testuser",
207                     "--host",
208                     "testhost",
209                     "--port",
210                     "1234",
211                     "--dbname",
212                     "maint_db",
213                     "-c",
214                     "CREATE DATABASE \"dbname\" WITH ENCODING = 'utf8' LC_COLLATE = ''",
215                 ],
216                 host="testhost",
217                 password="foo",
218                 port=1234,
219                 runas=None,
220                 user="testuser",
221             )
222     def test_db_create_with_trivial_sql_injection(self):
223         with patch(
224             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
225         ):
226             self.assertRaises(
227                 SaltInvocationError,
228                 postgres.db_create,
229                 "dbname",
230                 lc_collate="foo' ENCODING='utf8",
231             )
232     def test_db_exists(self):
233         with patch(
234             "salt.modules.postgres._run_psql",
235             Mock(return_value={"retcode": 0, "stdout": test_list_db_csv}),
236         ):
237             ret = postgres.db_exists(
238                 "test_db",
239                 user="testuser",
240                 host="testhost",
241                 port="testport",
242                 maintenance_db="maint_db",
243                 password="foo",
244                 runas="foo",
245             )
246             self.assertTrue(ret)
247     def test_db_list(self):
248         with patch(
249             "salt.modules.postgres._run_psql",
250             Mock(return_value={"retcode": 0, "stdout": test_list_db_csv}),
251         ):
252             ret = postgres.db_list(
253                 user="testuser",
254                 host="testhost",
255                 port="testport",
256                 maintenance_db="maint_db",
257                 password="foo",
258                 runas="foo",
259             )
260             self.assertDictEqual(
261                 ret,
262                 {
263                     "test_db": {
264                         "Encoding": "LATIN1",
265                         "Ctype": "en_US",
266                         "Tablespace": "pg_default",
267                         "Collate": "en_US",
268                         "Owner": "postgres",
269                         "Access privileges": "",
270                     },
271                     "template1": {
272                         "Encoding": "LATIN1",
273                         "Ctype": "en_US",
274                         "Tablespace": "pg_default",
275                         "Collate": "en_US",
276                         "Owner": "postgres",
277                         "Access privileges": "{=c/postgres,postgres=CTc/postgres}",
278                     },
279                     "template0": {
280                         "Encoding": "LATIN1",
281                         "Ctype": "en_US",
282                         "Tablespace": "pg_default",
283                         "Collate": "en_US",
284                         "Owner": "postgres",
285                         "Access privileges": "{=c/postgres,postgres=CTc/postgres}",
286                     },
287                     "postgres": {
288                         "Encoding": "LATIN1",
289                         "Ctype": "en_US",
290                         "Tablespace": "pg_default",
291                         "Collate": "en_US",
292                         "Owner": "postgres",
293                         "Access privileges": "",
294                     },
295                 },
296             )
297     def test_db_remove(self):
298         with patch(
299             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
300         ):
301             postgres.db_remove(
302                 "test_db",
303                 user="testuser",
304                 host="testhost",
305                 port="testport",
306                 maintenance_db="maint_db",
307                 password="foo",
308                 runas="foo",
309             )
310             calls = (
311                 call(
312                     [
313                         "/usr/bin/pgsql",
314                         "--no-align",
315                         "--no-readline",
316                         "--no-psqlrc",
317                         "--no-password",
318                         "--username",
319                         "testuser",
320                         "--host",
321                         "testhost",
322                         "--port",
323                         "testport",
324                         "--dbname",
325                         "maint_db",
326                         "-c",
327                         'REVOKE CONNECT ON DATABASE "test_db" FROM public;',
328                     ],
329                     host="testhost",
330                     password="foo",
331                     port="testport",
332                     runas="foo",
333                     user="testuser",
334                 ),
335                 call(
336                     [
337                         "/usr/bin/pgsql",
338                         "--no-align",
339                         "--no-readline",
340                         "--no-psqlrc",
341                         "--no-password",
342                         "--username",
343                         "testuser",
344                         "--host",
345                         "testhost",
346                         "--port",
347                         "testport",
348                         "--dbname",
349                         "maint_db",
350                         "-c",
351                         "SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity"
352                         " WHERE datname = 'test_db' AND pid &lt;&gt; pg_backend_pid();",
353                     ],
354                     host="testhost",
355                     password="foo",
356                     port="testport",
357                     runas="foo",
358                     user="testuser",
359                 ),
360                 call(
361                     [
362                         "/usr/bin/pgsql",
363                         "--no-align",
364                         "--no-readline",
365                         "--no-psqlrc",
366                         "--no-password",
367                         "--username",
368                         "testuser",
369                         "--host",
370                         "testhost",
371                         "--port",
372                         "testport",
373                         "--dbname",
374                         "maint_db",
375                         "-c",
376                         'DROP DATABASE "test_db";',
377                     ],
378                     host="testhost",
379                     password="foo",
380                     port="testport",
381                     runas="foo",
382                     user="testuser",
383                 ),
384             )
385             postgres._run_psql.assert_has_calls(calls, any_order=True)
386     def test_group_create(self):
387             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
388         ):
389             with patch("salt.modules.postgres.user_exists", Mock(return_value<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False)):
390                 postgres.group_create(
391                     "testgroup",
392                     user="testuser",
393                     host="testhost",
394                     port="testport",
395                     maintenance_db="maint_db",
396                     password="foo",
397                     createdb=False,
398                     encrypted=False,
399                     superuser=False,
400                     replication=False,
401                     rolepassword="testrolepass",
402                     groups="testgroup",
403                     runas=</b></font>"foo",
404                 )
405                 self.assertTrue(
406                     postgres._run_psql.call_args[0][0][14].startswith("CREATE ROLE")
407                 )
408     def test_group_remove(self):
409         with patch(
410             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
411         ):
412             with patch("salt.modules.postgres.user_exists", Mock(return_value=True)):
413                 postgres.group_remove(
414                     "testgroup",
415                     user="testuser",
416                     host="testhost",
417                     port="testport",
418                     maintenance_db="maint_db",
419                     password="foo",
420                     runas="foo",
421                 )
422                 postgres._run_psql.assert_called_once_with(
423                     [
424                         "/usr/bin/pgsql",
425                         "--no-align",
426                         "--no-readline",
427                         "--no-psqlrc",
428                         "--no-password",
429                         "--username",
430                         "testuser",
431                         "--host",
432                         "testhost",
433                         "--port",
434                         "testport",
435                         "--dbname",
436                         "maint_db",
437                         "-c",
438                         'DROP ROLE "testgroup"',
439                     ],
440                     host="testhost",
441                     user="testuser",
442                     password="foo",
443                     runas="foo",
444                     port="testport",
445                 )
446     def test_group_update(self):
447         with patch(
448             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
449         ):
450             with patch(
451                 Mock(return_value={"superuser": False}),
452             ):
453                 postgres<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.group_update(
454                     "testgroup",
455                     user='"testuser"',
456                     host="testhost",
457                     port="testport",
458                     maintenance_db="maint_db",
459                     password="foo",
460                     createdb=False,
461                     encrypted=False,
462                     replication=False,
463                     rolepassword="test_role_pass",
464                     groups="testgroup",
465                     runas=</b></font>"foo",
466                 )
467                 self.assertTrue(
468                     re.match(
469                         'ALTER.* "testgroup" .* UNENCRYPTED PASSWORD',
470                         postgres._run_psql.call_args[0][0][14],
471                     )
472                 )
473     def test_user_create(self):
474             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
475         ):
476             with patch("salt.modules.postgres.user_exists", Mock(return_value<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>=False)):
477                 postgres.user_create(
478                     "testuser",
479                     user="testuser",
480                     host="testhost",
481                     port="testport",
482                     maintenance_db="maint_test",
483                     password="test_pass",
484                     login=True,
485                     createdb=False,
486                     createroles=False,
487                     encrypted=False,
488                     superuser=False,
489                     replication=False,
490                     rolepassword="test_role_pass",
491                     valid_until="2042-07-01",
492                     groups="test_groups",
493                     runas="foo",
494                 )
495                 call =</b></font> postgres._run_psql.call_args[0][0][14]
496                 self.assertTrue(re.match('CREATE ROLE "testuser"', call))
497                 for i in (
498                     "INHERIT",
499                     "NOCREATEDB",
500                     "NOCREATEROLE",
501                     "NOSUPERUSER",
502                     "NOREPLICATION",
503                     "LOGIN",
504                     "UNENCRYPTED",
505                     "PASSWORD",
506                     "VALID UNTIL",
507                 ):
508                     self.assertTrue(i in call, "{} not in {}".format(i, call))
509     def test_user_exists(self):
510         with patch(
511             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
512         ):
513             with patch("salt.modules.postgres.version", Mock(return_value="9.1")):
514                 with patch(
515                     "salt.modules.postgres.psql_query",
516                     Mock(
517                         return_value=[
518                             {
519                                 "name": "test_user",
520                                 "superuser": "t",
521                                 "inherits privileges": "t",
522                                 "can create roles": "t",
523                                 "can create databases": "t",
524                                 "can update system catalogs": "t",
525                                 "can login": "t",
526                                 "replication": None,
527                                 "password": "test_password",
528                                 "connections": "-1",
529                                 "groups": "",
530                                 "expiry time": "",
531                                 "defaults variables": None,
532                             }
533                         ]
534                     ),
535                 ):
536                     ret = postgres.user_exists(
537                         "test_user",
538                         user="test_user",
539                         host="test_host",
540                         port="test_port",
541                         maintenance_db="maint_db",
542                         password="test_password",
543                         runas="foo",
544                     )
545                     self.assertTrue(ret)
546     def test_user_list(self):
547         with patch(
548             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
549         ):
550             with patch("salt.modules.postgres.version", Mock(return_value="9.1")):
551                 with patch(
552                     "salt.modules.postgres.psql_query",
553                     Mock(
554                         return_value=[
555                             {
556                                 "name": "test_user",
557                                 "superuser": "t",
558                                 "inherits privileges": "t",
559                                 "can create roles": "t",
560                                 "can create databases": "t",
561                                 "can update system catalogs": "t",
562                                 "can login": "t",
563                                 "replication": None,
564                                 "connections": "-1",
565                                 "groups": "",
566                                 "expiry time": "2017-08-16 08:57:46",
567                                 "defaults variables": None,
568                             }
569                         ]
570                     ),
571                 ):
572                     ret = postgres.user_list(
573                         "test_user",
574                         host="test_host",
575                         port="test_port",
576                         maintenance_db="maint_db",
577                         password="test_password",
578                         runas="foo",
579                     )
580                     self.assertDictEqual(
581                         ret,
582                         {
583                             "test_user": {
584                                 "superuser": True,
585                                 "defaults variables": None,
586                                 "can create databases": True,
587                                 "can create roles": True,
588                                 "connections": None,
589                                 "replication": None,
590                                 "expiry time": datetime.datetime(
591                                     2017, 8, 16, 8, 57, 46
592                                 ),
593                                 "can login": True,
594                                 "can update system catalogs": True,
595                                 "groups": [],
596                                 "inherits privileges": True,
597                             }
598                         },
599                     )
600     def test_user_remove(self):
601         with patch(
602             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
603         ):
604             with patch("salt.modules.postgres.version", Mock(return_value="9.1")):
605                 with patch(
606                     "salt.modules.postgres.user_exists", Mock(return_value=True)
607                 ):
608                     postgres.user_remove(
609                         "testuser",
610                         user="testuser",
611                         host="testhost",
612                         port="testport",
613                         maintenance_db="maint_db",
614                         password="testpassword",
615                         runas="foo",
616                     )
617                     postgres._run_psql.assert_called_once_with(
618                         [
619                             "/usr/bin/pgsql",
620                             "--no-align",
621                             "--no-readline",
622                             "--no-psqlrc",
623                             "--no-password",
624                             "--username",
625                             "testuser",
626                             "--host",
627                             "testhost",
628                             "--port",
629                             "testport",
630                             "--dbname",
631                             "maint_db",
632                             "-c",
633                             'DROP ROLE "testuser"',
634                         ],
635                         host="testhost",
636                         port="testport",
637                         user="testuser",
638                         password="testpassword",
639                         runas="foo",
640                     )
641     def test_user_update(self):
642         with patch(
643             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
644         ):
645             with patch(
646                 Mock(return_value={"superuser": False}),
647             ):
648                 postgres<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
649                     "test_username",
650                     user="test_user",
651                     host="test_host",
652                     port="test_port",
653                     maintenance_db="test_maint",
654                     password="test_pass",
655                     createdb=False,
656                     createroles=False,
657                     encrypted=False,
658                     inherit=True,
659                     login=True,
660                     replication=False,
661                     rolepassword="test_role_pass",
662                     valid_until="2017-07-01",
663                     groups="test_groups",
664                     runas=</b></font>"foo",
665                 )
666                 self.assertTrue(
667                     re.match(
668                         'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
669                         "NOCREATEROLE NOREPLICATION LOGIN "
670                         "UNENCRYPTED PASSWORD ['\"]{0,5}test_role_pass['\"]{0,5} "
671                         "VALID UNTIL '2017-07-01';"
672                         ' GRANT "test_groups" TO "test_username"',
673                         postgres._run_psql.call_args[0][0][14],
674                     )
675                 )
676     def test_user_update2(self):
677         with patch(
678             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
679         ):
680             with patch(
681                 Mock(return_value={"superuser": False}),
682             ):
683                 postgres<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
684                     "test_username",
685                     user="test_user",
686                     host="test_host",
687                     port="test_port",
688                     maintenance_db="test_maint",
689                     password="test_pass",
690                     createdb=False,
691                     createroles=True,
692                     encrypted=False,
693                     inherit=True,
694                     login=True,
695                     replication=False,
696                     groups="test_groups",
697                     runas=</b></font>"foo",
698                 )
699                 self.assertTrue(
700                     re.match(
701                         'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
702                         "CREATEROLE NOREPLICATION LOGIN;"
703                         ' GRANT "test_groups" TO "test_username"',
704                         postgres._run_psql.call_args[0][0][14],
705                     )
706                 )
707     def test_user_update3(self):
708         with patch(
709             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
710         ):
711             with patch(
712                 Mock(return_value={"superuser": False}),
713             ):
714                 postgres<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
715                     "test_username",
716                     user="test_user",
717                     host="test_host",
718                     port="test_port",
719                     maintenance_db="test_maint",
720                     password="test_pass",
721                     createdb=False,
722                     createroles=True,
723                     encrypted=False,
724                     inherit=True,
725                     login=True,
726                     rolepassword=False,
727                     replication=False,
728                     groups="test_groups",
729                     runas=</b></font>"foo",
730                 )
731                 self.assertTrue(
732                     re.match(
733                         'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
734                         "CREATEROLE NOREPLICATION LOGIN NOPASSWORD;"
735                         ' GRANT "test_groups" TO "test_username"',
736                         postgres._run_psql.call_args[0][0][14],
737                     )
738                 )
739     def test_user_update_encrypted_passwd(self):
740         with patch(
741             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
742         ):
743             with patch(
744                 Mock(return_value={"superuser": False}),
745             ):
746                 postgres<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>.user_update(
747                     "test_username",
748                     user="test_user",
749                     host="test_host",
750                     port="test_port",
751                     maintenance_db="test_maint",
752                     password="test_pass",
753                     createdb=False,
754                     createroles=True,
755                     encrypted=True,
756                     inherit=True,
757                     login=True,
758                     rolepassword="foobar",
759                     replication=False,
760                     groups="test_groups",
761                     runas=</b></font>"foo",
762                 )
763                 self.assertTrue(
764                     re.match(
765                         'ALTER ROLE "test_username" WITH  INHERIT NOCREATEDB '
766                         "CREATEROLE NOREPLICATION LOGIN "
767                         "ENCRYPTED PASSWORD "
768                         "['\"]{0,5}md531c27e68d3771c392b52102c01be1da1['\"]{0,5}"
769                         '; GRANT "test_groups" TO "test_username"',
770                         postgres._run_psql.call_args[0][0][14],
771                     )
772                 )
773     def test_version(self):
774         with patch(
775             "salt.modules.postgres._run_psql",
776             Mock(return_value={"retcode": 0, "stdout": "9.1.9"}),
777         ):
778             postgres.version(
779                 user="test_user",
780                 host="test_host",
781                 port="test_port",
782                 maintenance_db="test_maint",
783                 password="test_pass",
784                 runas="foo",
785             )
786             self.assertTrue(
787                 re.match(
788                     "SELECT setting FROM pg_catalog.pg_settings",
789                     postgres._run_psql.call_args[0][0][14],
790                 )
791             )
792     def test_installed_extensions(self):
793         with patch(
794             "salt.modules.postgres.psql_query",
795             Mock(return_value=[{"extname": "foo", "extversion": "1"}]),
796         ):
797             exts = postgres.installed_extensions()
798             self.assertEqual(exts, {"foo": {"extversion": "1", "extname": "foo"}})
799     def test_available_extensions(self):
800         with patch(
801             "salt.modules.postgres.psql_query",
802             Mock(return_value=[{"name": "foo", "default_version": "1"}]),
803         ):
804             exts = postgres.available_extensions()
805             self.assertEqual(exts, {"foo": {"default_version": "1", "name": "foo"}})
806     def test_drop_extension2(self):
807         with patch(
808             "salt.modules.postgres.installed_extensions", Mock(side_effect=[{}, {}])
809         ):
810             with patch(
811                 "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
812             ):
813                 with patch(
814                     "salt.modules.postgres.available_extensions",
815                     Mock(return_value={"foo": {"default_version": "1", "name": "foo"}}),
816                 ):
817                     self.assertEqual(postgres.drop_extension("foo"), True)
818     def test_drop_extension3(self):
819         with patch(
820             "salt.modules.postgres.installed_extensions",
821             Mock(side_effect=[{"foo": {"extversion": "1", "extname": "foo"}}, {}]),
822         ):
823             with patch(
824                 "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
825             ):
826                 with patch(
827                     "salt.modules.postgres.available_extensions",
828                     Mock(return_value={"foo": {"default_version": "1", "name": "foo"}}),
829                 ):
830                     self.assertEqual(postgres.drop_extension("foo"), True)
831     def test_drop_extension1(self):
832         with patch(
833             "salt.modules.postgres.installed_extensions",
834             Mock(
835                 side_effect=[
836                     {"foo": {"extversion": "1", "extname": "foo"}},
837                     {"foo": {"extversion": "1", "extname": "foo"}},
838                 ]
839             ),
840         ):
841             with patch(
842                 "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
843             ):
844                 with patch(
845                     "salt.modules.postgres.available_extensions",
846                     Mock(return_value={"foo": {"default_version": "1", "name": "foo"}}),
847                 ):
848                     self.assertEqual(postgres.drop_extension("foo"), False)
849     def test_create_mtdata(self):
850         with patch(
851             "salt.modules.postgres.installed_extensions",
852             Mock(
853                 return_value={
854                     "foo": {
855                         "extversion": "0.8",
856                         "extrelocatable": "t",
857                         "schema_name": "foo",
858                         "extname": "foo",
859                     }
860                 },
861             ),
862         ):
863             with patch(
864                 "salt.modules.postgres.available_extensions",
865                 Mock(return_value={"foo": {"default_version": "1.4", "name": "foo"}}),
866             ):
867                 ret = postgres.create_metadata("foo", schema="bar", ext_version="1.4")
868                 self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
869                 self.assertTrue(postgres._EXTENSION_TO_UPGRADE in ret)
870                 self.assertTrue(postgres._EXTENSION_TO_MOVE in ret)
871                 ret = postgres.create_metadata("foo", schema="foo", ext_version="0.4")
872                 self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
873                 self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
874                 self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
875                 ret = postgres.create_metadata("foo")
876                 self.assertTrue(postgres._EXTENSION_INSTALLED in ret)
877                 self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
878                 self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
879                 ret = postgres.create_metadata("foobar")
880                 self.assertTrue(postgres._EXTENSION_NOT_INSTALLED in ret)
881                 self.assertFalse(postgres._EXTENSION_INSTALLED in ret)
882                 self.assertFalse(postgres._EXTENSION_TO_UPGRADE in ret)
883                 self.assertFalse(postgres._EXTENSION_TO_MOVE in ret)
884     def test_create_extension_newerthan(self):
885         with patch(
886             "salt.modules.postgres.create_metadata",
887             Mock(
888                 side_effect=[
889                     [postgres._EXTENSION_NOT_INSTALLED],
890                     [postgres._EXTENSION_INSTALLED],
891                     [postgres._EXTENSION_NOT_INSTALLED],
892                     [postgres._EXTENSION_INSTALLED],
893                     [postgres._EXTENSION_NOT_INSTALLED],
894                     [postgres._EXTENSION_NOT_INSTALLED],
895                     [
896                         postgres._EXTENSION_TO_MOVE,
897                         postgres._EXTENSION_TO_UPGRADE,
898                         postgres._EXTENSION_INSTALLED,
899                     ],
900                     [postgres._EXTENSION_INSTALLED],
901                     [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
902                     [postgres._EXTENSION_INSTALLED],
903                     [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
904                     [postgres._EXTENSION_INSTALLED],
905                     [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
906                     [postgres._EXTENSION_TO_UPGRADE, postgres._EXTENSION_INSTALLED],
907                     [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
908                     [postgres._EXTENSION_TO_MOVE, postgres._EXTENSION_INSTALLED],
909                 ]
910             ),
911         ):
912             with patch(
913                 "salt.modules.postgres._psql_prepare_and_run", Mock(return_value=None)
914             ):
915                 with patch(
916                     "salt.modules.postgres.available_extensions",
917                     Mock(
918                         return_value={"foo": {"default_version": "1.4", "name": "foo"}}
919                     ),
920                 ):
921                     self.assertTrue(postgres.create_extension("foo"))
922                     self.assertTrue(
923                         re.match(
924                             'CREATE EXTENSION IF NOT EXISTS "foo" ;',
925                             postgres._psql_prepare_and_run.call_args[0][0][1],
926                         )
927                     )
928                     self.assertTrue(
929                         postgres.create_extension(
930                             "foo", schema="a", ext_version="b", from_version="c"
931                         )
932                     )
933                     self.assertTrue(
934                         re.match(
935                             'CREATE EXTENSION IF NOT EXISTS "foo" '
936                             'WITH SCHEMA "a" VERSION b FROM c ;',
937                             postgres._psql_prepare_and_run.call_args[0][0][1],
938                         )
939                     )
940                     self.assertFalse(postgres.create_extension("foo"))
941                     ret = postgres.create_extension("foo", ext_version="a", schema="b")
942                     self.assertTrue(ret)
943                     self.assertTrue(
944                         re.match(
945                             'ALTER EXTENSION "foo" SET SCHEMA "b";'
946                             ' ALTER EXTENSION "foo" UPDATE TO a;',
947                             postgres._psql_prepare_and_run.call_args[0][0][1],
948                         )
949                     )
950                     ret = postgres.create_extension("foo", ext_version="a", schema="b")
951                     self.assertTrue(ret)
952                     self.assertTrue(
953                         re.match(
954                             'ALTER EXTENSION "foo" SET SCHEMA "b";',
955                             postgres._psql_prepare_and_run.call_args[0][0][1],
956                         )
957                     )
958                     ret = postgres.create_extension("foo", ext_version="a", schema="b")
959                     self.assertTrue(ret)
960                     self.assertTrue(
961                         re.match(
962                             'ALTER EXTENSION "foo" UPDATE TO a;',
963                             postgres._psql_prepare_and_run.call_args[0][0][1],
964                         )
965                     )
966                     self.assertFalse(
967                         postgres.create_extension("foo", ext_version="a", schema="b")
968                     )
969                     self.assertFalse(
970                         postgres.create_extension("foo", ext_version="a", schema="b")
971                     )
972     def test_encrypt_passwords(self):
973         self.assertEqual(postgres._maybe_encrypt_password("foo", "bar", False), "bar")
974         self.assertEqual(
975             postgres._maybe_encrypt_password("foo", "bar", True),
976             "md596948aad3fcae80c08a35c9b5958cd89",
977         )
978     def test_schema_list(self):
979         with patch(
980             "salt.modules.postgres._run_psql",
981             Mock(return_value={"retcode": 0, "stdout": test_list_schema_csv}),
982         ):
983             ret = postgres.schema_list(
984                 "maint_db",
985                 db_user="testuser",
986                 db_host="testhost",
987                 db_port="testport",
988                 db_password="foo",
989             )
990             self.assertDictEqual(
991                 ret,
992                 {
993                     "public": {
994                         "acl": "{postgres=UC/postgres,=UC/postgres}",
995                         "owner": "postgres",
996                     },
997                     "pg_toast": {"acl": "", "owner": "postgres"},
998                 },
999             )
1000     def test_schema_exists(self):
1001         with patch(
1002             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1003         ):
1004             with patch(
1005                 "salt.modules.postgres.psql_query",
1006                 Mock(
1007                     return_value=[
1008                         {
1009                             "name": "public",
1010                             "acl": "{postgres=UC/postgres,=UC/postgres}",
1011                             "owner": "postgres",
1012                         }
1013                     ]
1014                 ),
1015             ):
1016                 ret = postgres.schema_exists("template1", "public")
1017                 self.assertTrue(ret)
1018     def test_schema_get(self):
1019         with patch(
1020             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1021         ):
1022             with patch(
1023                 "salt.modules.postgres.psql_query",
1024                 Mock(
1025                     return_value=[
1026                         {
1027                             "name": "public",
1028                             "acl": "{postgres=UC/postgres,=UC/postgres}",
1029                             "owner": "postgres",
1030                         }
1031                     ]
1032                 ),
1033             ):
1034                 ret = postgres.schema_get("template1", "public")
1035                 self.assertTrue(ret)
1036     def test_schema_get_again(self):
1037         with patch(
1038             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1039         ):
1040             with patch(
1041                 "salt.modules.postgres.psql_query",
1042                 Mock(
1043                     return_value=[
1044                         {
1045                             "name": "public",
1046                             "acl": "{postgres=UC/postgres,=UC/postgres}",
1047                             "owner": "postgres",
1048                         }
1049                     ]
1050                 ),
1051             ):
1052                 ret = postgres.schema_get("template1", "pg_toast")
1053                 self.assertFalse(ret)
1054     def test_schema_create(self):
1055         with patch(
1056             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1057         ):
1058             with patch("salt.modules.postgres.schema_exists", Mock(return_value=False)):
1059                 postgres.schema_create(
1060                     "maint_db",
1061                     "testschema",
1062                     user="user",
1063                     db_host="testhost",
1064                     db_port="testport",
1065                     db_user="testuser",
1066                     db_password="testpassword",
1067                 )
1068                 postgres._run_psql.assert_called_once_with(
1069                     [
1070                         "/usr/bin/pgsql",
1071                         "--no-align",
1072                         "--no-readline",
1073                         "--no-psqlrc",
1074                         "--no-password",
1075                         "--username",
1076                         "testuser",
1077                         "--host",
1078                         "testhost",
1079                         "--port",
1080                         "testport",
1081                         "--dbname",
1082                         "maint_db",
1083                         "-c",
1084                         'CREATE SCHEMA "testschema"',
1085                     ],
1086                     host="testhost",
1087                     port="testport",
1088                     password="testpassword",
1089                     user="testuser",
1090                     runas="user",
1091                 )
1092     def test_schema_create2(self):
1093         with patch("salt.modules.postgres.schema_exists", Mock(return_value=True)):
1094             ret = postgres.schema_create(
1095                 "test_db",
1096                 "test_schema",
1097                 user="user",
1098                 db_host="test_host",
1099                 db_port="test_port",
1100                 db_user="test_user",
1101                 db_password="test_password",
1102             )
1103             self.assertFalse(ret)
1104     def test_schema_remove(self):
1105         with patch(
1106             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1107         ):
1108             with patch("salt.modules.postgres.schema_exists", Mock(return_value=True)):
1109                 postgres.schema_remove(
1110                     "maint_db",
1111                     "testschema",
1112                     user="user",
1113                     db_host="testhost",
1114                     db_port="testport",
1115                     db_user="testuser",
1116                     db_password="testpassword",
1117                 )
1118                 postgres._run_psql.assert_called_once_with(
1119                     [
1120                         "/usr/bin/pgsql",
1121                         "--no-align",
1122                         "--no-readline",
1123                         "--no-psqlrc",
1124                         "--no-password",
1125                         "--username",
1126                         "testuser",
1127                         "--host",
1128                         "testhost",
1129                         "--port",
1130                         "testport",
1131                         "--dbname",
1132                         "maint_db",
1133                         "-c",
1134                         'DROP SCHEMA "testschema"',
1135                     ],
1136                     host="testhost",
1137                     port="testport",
1138                     password="testpassword",
1139                     user="testuser",
1140                     runas="user",
1141                 )
1142     def test_schema_remove2(self):
1143         with patch("salt.modules.postgres.schema_exists", Mock(return_value=False)):
1144             ret = postgres.schema_remove(
1145                 "test_db",
1146                 "test_schema",
1147                 user="user",
1148                 db_host="test_host",
1149                 db_port="test_port",
1150                 db_user="test_user",
1151                 db_password="test_password",
1152             )
1153             self.assertFalse(ret)
1154     def test_language_list(self):
1155         with patch(
1156             "salt.modules.postgres._run_psql",
1157             Mock(return_value={"retcode": 0, "stdout": test_list_language_csv}),
1158         ):
1159             ret = postgres.language_list(
1160                 "testdb",
1161                 user="testuser",
1162                 host="testhost",
1163                 port="testport",
1164                 password="foo",
1165             )
1166             self.assertDictEqual(
1167                 ret,
1168                 {"c": "c", "internal": "internal", "plpgsql": "plpgsql", "sql": "sql"},
1169             )
1170     def test_language_exists(self):
1171         with patch(
1172             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1173         ):
1174             with patch(
1175                 "salt.modules.postgres.psql_query",
1176                 Mock(
1177                     return_value=[
1178                         {"Name": "internal"},
1179                         {"Name": "c"},
1180                         {"Name": "sql"},
1181                         {"Name": "plpgsql"},
1182                     ]
1183                 ),
1184             ):
1185                 with patch(
1186                     "salt.modules.postgres.language_exists", Mock(return_value=True)
1187                 ):
1188                     ret = postgres.language_exists("sql", "testdb")
1189                     self.assertTrue(ret)
1190     def test_language_create(self):
1191         with patch(
1192             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1193         ):
1194             with patch(
1195                 "salt.modules.postgres.language_exists", Mock(return_value=False)
1196             ):
1197                 postgres.language_create(
1198                     "plpythonu",
1199                     "testdb",
1200                     runas="user",
1201                     host="testhost",
1202                     port="testport",
1203                     user="testuser",
1204                     password="testpassword",
1205                 )
1206                 postgres._run_psql.assert_called_once_with(
1207                     [
1208                         "/usr/bin/pgsql",
1209                         "--no-align",
1210                         "--no-readline",
1211                         "--no-psqlrc",
1212                         "--no-password",
1213                         "--username",
1214                         "testuser",
1215                         "--host",
1216                         "testhost",
1217                         "--port",
1218                         "testport",
1219                         "--dbname",
1220                         "testdb",
1221                         "-c",
1222                         "CREATE LANGUAGE plpythonu",
1223                     ],
1224                     host="testhost",
1225                     port="testport",
1226                     password="testpassword",
1227                     user="testuser",
1228                     runas="user",
1229                 )
1230     def test_language_create_exists(self):
1231         with patch("salt.modules.postgres.language_exists", Mock(return_value=True)):
1232             ret = postgres.language_create(
1233                 "plpythonu",
1234                 "testdb",
1235                 runas="user",
1236                 host="testhost",
1237                 port="testport",
1238                 user="testuser",
1239                 password="testpassword",
1240             )
1241             self.assertFalse(ret)
1242     def test_language_remove(self):
1243         with patch(
1244             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1245         ):
1246             with patch(
1247                 "salt.modules.postgres.language_exists", Mock(return_value=True)
1248             ):
1249                 postgres.language_remove(
1250                     "plpgsql",
1251                     "testdb",
1252                     runas="user",
1253                     host="testhost",
1254                     port="testport",
1255                     user="testuser",
1256                     password="testpassword",
1257                 )
1258                 postgres._run_psql.assert_called_once_with(
1259                     [
1260                         "/usr/bin/pgsql",
1261                         "--no-align",
1262                         "--no-readline",
1263                         "--no-psqlrc",
1264                         "--no-password",
1265                         "--username",
1266                         "testuser",
1267                         "--host",
1268                         "testhost",
1269                         "--port",
1270                         "testport",
1271                         "--dbname",
1272                         "testdb",
1273                         "-c",
1274                         "DROP LANGUAGE plpgsql",
1275                     ],
1276                     host="testhost",
1277                     port="testport",
1278                     password="testpassword",
1279                     user="testuser",
1280                     runas="user",
1281                 )
1282     def test_language_remove_non_exist(self):
1283         with patch("salt.modules.postgres.language_exists", Mock(return_value=False)):
1284             ret = postgres.language_remove(
1285                 "plpgsql",
1286                 "testdb",
1287                 runas="user",
1288                 host="testhost",
1289                 port="testport",
1290                 user="testuser",
1291                 password="testpassword",
1292             )
1293             self.assertFalse(ret)
1294     def test_privileges_list_table(self):
1295         """
1296             Mock(return_value<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>={"retcode": 0, "stdout": test_privileges_list_table_csv}),
1297         ):
1298             ret = postgres.privileges_list(
1299                 "awl",
1300                 "table",
1301                 maintenance_db="db_name",
1302                 runas="user",
1303                 host="testhost",
1304                 port="testport",
1305                 user="testuser",
1306                 password="testpassword",
1307             )
1308             expected =</b></font> {
1309                 "bayestest": {
1310                     "INSERT": False,
1311                     "UPDATE": False,
1312                     "SELECT": False,
1313                     "DELETE": False,
1314                 },
1315                 "baruwa": {
1316                     "INSERT": True,
1317                     "TRUNCATE": True,
1318                     "UPDATE": True,
1319                     "TRIGGER": True,
1320                     "REFERENCES": True,
1321                     "SELECT": True,
1322                     "DELETE": True,
1323                 },
1324                 "baruwatest": {
1325                     "INSERT": False,
1326                     "TRUNCATE": False,
1327                     "UPDATE": False,
1328                     "TRIGGER": False,
1329                     "REFERENCES": False,
1330                     "SELECT": False,
1331                     "DELETE": False,
1332                 },
1333             }
1334             self.assertDictEqual(ret, expected)
1335             query = (
1336                 "COPY (SELECT relacl AS name FROM pg_catalog.pg_class c "
1337                 "JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace "
1338                 "WHERE nspname = 'public' AND relname = 'awl' AND relkind = 'r' "
1339                 "ORDER BY relname) TO STDOUT WITH CSV HEADER"
1340             )
1341             postgres._run_psql.assert_called_once_with(
1342                 [
1343                     "/usr/bin/pgsql",
1344                     "--no-align",
1345                     "--no-readline",
1346                     "--no-psqlrc",
1347                     "--no-password",
1348                     "--username",
1349                     "testuser",
1350                     "--host",
1351                     "testhost",
1352                     "--port",
1353                     "testport",
1354                     "--dbname",
1355                     "db_name",
1356                     "-v",
1357                     "datestyle=ISO,MDY",
1358                     "-c",
1359                     query,
1360                 ],
1361                 host="testhost",
1362                 port="testport",
1363                 password="testpassword",
1364                 user="testuser",
1365                 runas="user",
1366             )
1367     def test_privileges_list_group(self):
1368         """
1369         Test privilege listing on a group
1370         """
1371         with patch(
1372             "salt.modules.postgres._run_psql",
1373             Mock(return_value={"retcode": 0, "stdout": test_privileges_list_group_csv}),
1374         ):
1375             ret = postgres.privileges_list(
1376                 "admin",
1377                 "group",
1378                 maintenance_db="db_name",
1379                 runas="user",
1380                 host="testhost",
1381                 port="testport",
1382                 user="testuser",
1383                 password="testpassword",
1384             )
1385             expected = {
1386                 "baruwa": False,
1387                 "baruwatest": False,
1388                 "baruwatest2": True,
1389             }
1390             self.assertDictEqual(ret, expected)
1391             query = (
1392                 "COPY (SELECT rolname, admin_option "
1393                 "FROM pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles r "
1394                 "ON m.member=r.oid WHERE m.roleid IN (SELECT oid FROM "
1395                 "pg_catalog.pg_roles WHERE rolname='admin') ORDER BY rolname) "
1396                 "TO STDOUT WITH CSV HEADER"
1397             )
1398             postgres._run_psql.assert_called_once_with(
1399                 [
1400                     "/usr/bin/pgsql",
1401                     "--no-align",
1402                     "--no-readline",
1403                     "--no-psqlrc",
1404                     "--no-password",
1405                     "--username",
1406                     "testuser",
1407                     "--host",
1408                     "testhost",
1409                     "--port",
1410                     "testport",
1411                     "--dbname",
1412                     "db_name",
1413                     "-v",
1414                     "datestyle=ISO,MDY",
1415                     "-c",
1416                     query,
1417                 ],
1418                 host="testhost",
1419                 port="testport",
1420                 password="testpassword",
1421                 user="testuser",
1422                 runas="user",
1423             )
1424     def test_has_privileges_on_table(self):
1425         """
1426         Test privilege checks on table
1427         """
1428         with patch(
1429             "salt.modules.postgres._run_psql",
1430             Mock(return_value={"retcode": 0, "stdout": test_privileges_list_table_csv}),
1431         ):
1432             ret = postgres.has_privileges(
1433                 "baruwa",
1434                 "awl",
1435                 "table",
1436                 "SELECT,INSERT",
1437                 grant_option=True,
1438                 maintenance_db="db_name",
1439                 runas="user",
1440                 host="testhost",
1441                 port="testport",
1442                 user="testuser",
1443                 password="testpassword",
1444             )
1445             self.assertTrue(ret)
1446             ret = postgres.has_privileges(
1447                 "baruwa",
1448                 "awl",
1449                 "table",
1450                 "ALL",
1451                 grant_option=True,
1452                 maintenance_db="db_name",
1453                 runas="user",
1454                 host="testhost",
1455                 port="testport",
1456                 user="testuser",
1457                 password="testpassword",
1458             )
1459             self.assertTrue(ret)
1460             ret = postgres.has_privileges(
1461                 "baruwa",
1462                 "awl",
1463                 "table",
1464                 "ALL",
1465                 grant_option=False,
1466                 maintenance_db="db_name",
1467                 runas="user",
1468                 host="testhost",
1469                 port="testport",
1470                 user="testuser",
1471                 password="testpassword",
1472             )
1473             self.assertTrue(ret)
1474             ret = postgres.has_privileges(
1475                 "bayestest",
1476                 "awl",
1477                 "table",
1478                 "SELECT,INSERT,TRUNCATE",
1479                 maintenance_db="db_name",
1480                 runas="user",
1481                 host="testhost",
1482                 port="testport",
1483                 user="testuser",
1484                 password="testpassword",
1485             )
1486             self.assertFalse(ret)
1487             ret = postgres.has_privileges(
1488                 "bayestest",
1489                 "awl",
1490                 "table",
1491                 "SELECT,INSERT",
1492                 maintenance_db="db_name",
1493                 runas="user",
1494                 host="testhost",
1495                 port="testport",
1496                 user="testuser",
1497                 password="testpassword",
1498             )
1499             self.assertTrue(ret)
1500     def test_has_privileges_on_group(self):
1501         """
1502         Test privilege checks on group
1503         """
1504         with patch(
1505             "salt.modules.postgres._run_psql",
1506             Mock(return_value={"retcode": 0, "stdout": test_privileges_list_group_csv}),
1507         ):
1508             ret = postgres.has_privileges(
1509                 "baruwa",
1510                 "admin",
1511                 "group",
1512                 maintenance_db="db_name",
1513                 runas="user",
1514                 host="testhost",
1515                 port="testport",
1516                 user="testuser",
1517                 password="testpassword",
1518             )
1519             self.assertTrue(ret)
1520             ret = postgres.has_privileges(
1521                 "baruwa",
1522                 "admin",
1523                 "group",
1524                 grant_option=True,
1525                 maintenance_db="db_name",
1526                 runas="user",
1527                 host="testhost",
1528                 port="testport",
1529                 user="testuser",
1530                 password="testpassword",
1531             )
1532             self.assertFalse(ret)
1533             ret = postgres.has_privileges(
1534                 "tony",
1535                 "admin",
1536                 "group",
1537                 maintenance_db="db_name",
1538                 runas="user",
1539                 host="testhost",
1540                 port="testport",
1541                 user="testuser",
1542                 password="testpassword",
1543             )
1544             self.assertFalse(ret)
1545     def test_privileges_grant_table(self):
1546         """
1547         Test granting privileges on table
1548         """
1549         with patch(
1550             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1551         ):
1552             with patch(
1553                 "salt.modules.postgres.has_privileges", Mock(return_value=False)
1554             ):
1555                 ret = postgres.privileges_grant(
1556                     "baruwa",
1557                     "awl",
1558                     "table",
1559                     "ALL",
1560                     grant_option=True,
1561                     maintenance_db="db_name",
1562                     runas="user",
1563                     host="testhost",
1564                     port="testport",
1565                     user="testuser",
1566                     password="testpassword",
1567                 )
1568                 query = 'GRANT ALL ON TABLE public."awl" TO "baruwa" WITH GRANT OPTION'
1569                 postgres._run_psql.assert_called_once_with(
1570                     [
1571                         "/usr/bin/pgsql",
1572                         "--no-align",
1573                         "--no-readline",
1574                         "--no-psqlrc",
1575                         "--no-password",
1576                         "--username",
1577                         "testuser",
1578                         "--host",
1579                         "testhost",
1580                         "--port",
1581                         "testport",
1582                         "--dbname",
1583                         "db_name",
1584                         "-c",
1585                         query,
1586                     ],
1587                     host="testhost",
1588                     port="testport",
1589                     password="testpassword",
1590                     user="testuser",
1591                     runas="user",
1592                 )
1593         with patch(
1594             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1595         ):
1596             with patch(
1597                 "salt.modules.postgres.has_privileges", Mock(return_value=False)
1598             ):
1599                 ret = postgres.privileges_grant(
1600                     "baruwa",
1601                     "awl",
1602                     "table",
1603                     "ALL",
1604                     maintenance_db="db_name",
1605                     runas="user",
1606                     host="testhost",
1607                     port="testport",
1608                     user="testuser",
1609                     password="testpassword",
1610                 )
1611                 query = 'GRANT ALL ON TABLE public."awl" TO "baruwa"'
1612                 postgres._run_psql.assert_called_once_with(
1613                     [
1614                         "/usr/bin/pgsql",
1615                         "--no-align",
1616                         "--no-readline",
1617                         "--no-psqlrc",
1618                         "--no-password",
1619                         "--username",
1620                         "testuser",
1621                         "--host",
1622                         "testhost",
1623                         "--port",
1624                         "testport",
1625                         "--dbname",
1626                         "db_name",
1627                         "-c",
1628                         query,
1629                     ],
1630                     host="testhost",
1631                     port="testport",
1632                     password="testpassword",
1633                     user="testuser",
1634                     runas="user",
1635                 )
1636         with patch(
1637             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1638         ):
1639             with patch(
1640                 "salt.modules.postgres.has_privileges", Mock(return_value=False)
1641             ):
1642                 ret = postgres.privileges_grant(
1643                     "baruwa",
1644                     "ALL",
1645                     "table",
1646                     "SELECT",
1647                     maintenance_db="db_name",
1648                     runas="user",
1649                     host="testhost",
1650                     port="testport",
1651                     user="testuser",
1652                     password="testpassword",
1653                 )
1654                 query = 'GRANT SELECT ON ALL TABLES IN SCHEMA public TO "baruwa"'
1655                 postgres._run_psql.assert_called_once_with(
1656                     [
1657                         "/usr/bin/pgsql",
1658                         "--no-align",
1659                         "--no-readline",
1660                         "--no-psqlrc",
1661                         "--no-password",
1662                         "--username",
1663                         "testuser",
1664                         "--host",
1665                         "testhost",
1666                         "--port",
1667                         "testport",
1668                         "--dbname",
1669                         "db_name",
1670                         "-c",
1671                         query,
1672                     ],
1673                     host="testhost",
1674                     port="testport",
1675                     password="testpassword",
1676                     user="testuser",
1677                     runas="user",
1678                 )
1679     def test_privileges_grant_group(self):
1680         """
1681         Test granting privileges on group
1682         """
1683         with patch(
1684             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1685         ):
1686             with patch(
1687                 "salt.modules.postgres.has_privileges", Mock(return_value=False)
1688             ):
1689                 ret = postgres.privileges_grant(
1690                     "baruwa",
1691                     "admins",
1692                     "group",
1693                     grant_option=True,
1694                     maintenance_db="db_name",
1695                     runas="user",
1696                     host="testhost",
1697                     port="testport",
1698                     user="testuser",
1699                     password="testpassword",
1700                 )
1701                 query = 'GRANT admins TO "baruwa" WITH ADMIN OPTION'
1702                 postgres._run_psql.assert_called_once_with(
1703                     [
1704                         "/usr/bin/pgsql",
1705                         "--no-align",
1706                         "--no-readline",
1707                         "--no-psqlrc",
1708                         "--no-password",
1709                         "--username",
1710                         "testuser",
1711                         "--host",
1712                         "testhost",
1713                         "--port",
1714                         "testport",
1715                         "--dbname",
1716                         "db_name",
1717                         "-c",
1718                         query,
1719                     ],
1720                     host="testhost",
1721                     port="testport",
1722                     password="testpassword",
1723                     user="testuser",
1724                     runas="user",
1725                 )
1726         with patch(
1727             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1728         ):
1729             with patch(
1730                 "salt.modules.postgres.has_privileges", Mock(return_value=False)
1731             ):
1732                 ret = postgres.privileges_grant(
1733                     "baruwa",
1734                     "admins",
1735                     "group",
1736                     maintenance_db="db_name",
1737                     runas="user",
1738                     host="testhost",
1739                     port="testport",
1740                     user="testuser",
1741                     password="testpassword",
1742                 )
1743                 query = 'GRANT admins TO "baruwa"'
1744                 postgres._run_psql.assert_called_once_with(
1745                     [
1746                         "/usr/bin/pgsql",
1747                         "--no-align",
1748                         "--no-readline",
1749                         "--no-psqlrc",
1750                         "--no-password",
1751                         "--username",
1752                         "testuser",
1753                         "--host",
1754                         "testhost",
1755                         "--port",
1756                         "testport",
1757                         "--dbname",
1758                         "db_name",
1759                         "-c",
1760                         query,
1761                     ],
1762                     host="testhost",
1763                     port="testport",
1764                     password="testpassword",
1765                     user="testuser",
1766                     runas="user",
1767                 )
1768     def test_privileges_revoke_table(self):
1769         """
1770         Test revoking privileges on table
1771         """
1772         with patch(
1773             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1774         ):
1775             with patch("salt.modules.postgres.has_privileges", Mock(return_value=True)):
1776                 ret = postgres.privileges_revoke(
1777                     "baruwa",
1778                     "awl",
1779                     "table",
1780                     "ALL",
1781                     maintenance_db="db_name",
1782                     runas="user",
1783                     host="testhost",
1784                     port="testport",
1785                     user="testuser",
1786                     password="testpassword",
1787                 )
1788                 query = "REVOKE ALL ON TABLE public.awl FROM baruwa"
1789                 postgres._run_psql.assert_called_once_with(
1790                     [
1791                         "/usr/bin/pgsql",
1792                         "--no-align",
1793                         "--no-readline",
1794                         "--no-psqlrc",
1795                         "--no-password",
1796                         "--username",
1797                         "testuser",
1798                         "--host",
1799                         "testhost",
1800                         "--port",
1801                         "testport",
1802                         "--dbname",
1803                         "db_name",
1804                         "-c",
1805                         query,
1806                     ],
1807                     host="testhost",
1808                     port="testport",
1809                     password="testpassword",
1810                     user="testuser",
1811                     runas="user",
1812                 )
1813     def test_privileges_revoke_group(self):
1814         """
1815         Test revoking privileges on group
1816         """
1817         with patch(
1818             "salt.modules.postgres._run_psql", Mock(return_value={"retcode": 0})
1819         ):
1820             with patch("salt.modules.postgres.has_privileges", Mock(return_value=True)):
1821                 ret = postgres.privileges_revoke(
1822                     "baruwa",
1823                     "admins",
1824                     "group",
1825                     maintenance_db="db_name",
1826                     runas="user",
1827                     host="testhost",
1828                     port="testport",
1829                     user="testuser",
1830                     password="testpassword",
1831                 )
1832                 query = "REVOKE admins FROM baruwa"
1833                 postgres._run_psql.assert_called_once_with(
1834                     [
1835                         "/usr/bin/pgsql",
1836                         "--no-align",
1837                         "--no-readline",
1838                         "--no-psqlrc",
1839                         "--no-password",
1840                         "--username",
1841                         "testuser",
1842                         "--host",
1843                         "testhost",
1844                         "--port",
1845                         "testport",
1846                         "--dbname",
1847                         "db_name",
1848                         "-c",
1849                         query,
1850                     ],
1851                     host="testhost",
1852                     port="testport",
1853                     password="testpassword",
1854                     user="testuser",
1855                     runas="user",
1856                 )
1857     def test_datadir_init(self):
1858         """
1859         Test Initializing a postgres data directory
1860         """
1861         with patch(
1862             "salt.modules.postgres._run_initdb", Mock(return_value={"retcode": 0})
1863         ):
1864             with patch(
1865                 "salt.modules.postgres.datadir_exists", Mock(return_value=False)
1866             ):
1867                 name = "/var/lib/pgsql/data"
1868                 ret = postgres.datadir_init(
1869                     name, user="postgres", password="test", runas="postgres"
1870                 )
1871                 postgres._run_initdb.assert_called_once_with(
1872                     name,
1873                     auth="password",
1874                     encoding="UTF8",
1875                     locale=None,
1876                     password="test",
1877                     runas="postgres",
1878                     checksums=False,
1879                     waldir=None,
1880                     user="postgres",
1881                 )
1882                 self.assertTrue(ret)
1883     def test_datadir_exists(self):
1884         """
1885         Test Checks if postgres data directory has been initialized
1886         """
1887         with patch("os.path.isfile", Mock(return_value=True)):
1888             name = "/var/lib/pgsql/data"
1889             ret = postgres.datadir_exists(name)
1890             self.assertTrue(ret)
1891     def test_pg_is_older_ext_ver(self):
1892         """
1893         Test Checks if postgres extension version string is older
1894         """
1895         self.assertTrue(postgres._pg_is_older_ext_ver("8.5", "9.5"))
1896         self.assertTrue(postgres._pg_is_older_ext_ver("8.5", "8.6"))
1897         self.assertTrue(postgres._pg_is_older_ext_ver("8.5.2", "8.5.3"))
1898         self.assertFalse(postgres._pg_is_older_ext_ver("9.5", "8.5"))
1899         self.assertTrue(postgres._pg_is_older_ext_ver("9.5", "9.6"))
1900         self.assertTrue(postgres._pg_is_older_ext_ver("9.5.0", "9.5.1"))
1901         self.assertTrue(postgres._pg_is_older_ext_ver("9.5", "9.5.1"))
1902         self.assertFalse(postgres._pg_is_older_ext_ver("9.5.1", "9.5"))
1903         self.assertFalse(postgres._pg_is_older_ext_ver("9.5b", "9.5a"))
1904         self.assertTrue(postgres._pg_is_older_ext_ver("10a", "10b"))
1905         self.assertTrue(postgres._pg_is_older_ext_ver("1.2.3.4", "1.2.3.5"))
1906         self.assertTrue(postgres._pg_is_older_ext_ver("10dev", "10next"))
1907         self.assertFalse(postgres._pg_is_older_ext_ver("10next", "10dev"))
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>bigip.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 """
2 A state module designed to enforce load-balancing configurations for F5 Big-IP entities.
3     :maturity:      develop
4     :platform:      f5_bigip_11.6
5 """
6 import salt.utils.json
7 def __virtual__():
8     """
9     Only load if the bigip exec module is available in __salt__
10     """
11     if "bigip.list_transaction" in __salt__:
12         return "bigip"
13     return (False, "bigip module could not be loaded")
14 def _load_result(response, ret):
15     """
16     format the results of listing functions
17     """
18     if response["code"] is None:
19         ret["comment"] = response["content"]
20     elif response["code"] == 401:
21         ret["comment"] = "401 Forbidden: Authentication required!"
22     elif response["code"] == 404:
23         ret["comment"] = response["content"]["message"]
24     elif response["code"] == 200:
25         ret["result"] = True
26         ret["comment"] = (
27             "Listing Current Configuration Only.  "
28             "Not action or changes occurred during the execution of this state."
29         )
30         ret["changes"] = response["content"]
31     else:
32         ret["comment"] = response["content"]["message"]
33     return ret
34 def _strip_key(dictionary, keyword):
35     """
36     look for a certain key within a dictionary and nullify ti's contents, check within nested
37     dictionaries and lists as well.  Certain attributes such as "generation" will change even
38     when there were no changes made to the entity.
39     """
40     for key, value in dictionary.items():
41         if key == keyword:
42             dictionary[key] = None
43         elif isinstance(value, dict):
44             _strip_key(value, keyword)
45         elif isinstance(value, list):
46             for item in value:
47                 if isinstance(item, dict):
48                     _strip_key(item, keyword)
49     return dictionary
50 def _check_for_changes(entity_type, ret, existing, modified):
51     """
52     take an existing entity and a modified entity and check for changes.
53     """
54     ret["result"] = True
55     if isinstance(existing, dict) and isinstance(modified, dict):
56         if "generation" in modified["content"].keys():
57             del modified["content"]["generation"]
58         if "generation" in existing["content"].keys():
59             del existing["content"]["generation"]
60         if modified["content"] == existing["content"]:
61             ret["comment"] = (
62                 "{entity_type} is currently enforced to the desired state.  No changes"
63                 " made.".format(entity_type=entity_type)
64             )
65         else:
66             ret["comment"] = (
67                 "{entity_type} was enforced to the desired state.  Note: Only"
68                 " parameters specified were enforced. See changes for details.".format(
69                     entity_type=entity_type
70                 )
71             )
72             ret["changes"]["old"] = existing["content"]
73             ret["changes"]["new"] = modified["content"]
74     else:
75         if modified == existing:
76             ret["comment"] = (
77                 "{entity_type} is currently enforced to the desired state.  No changes"
78                 " made.".format(entity_type=entity_type)
79             )
80         else:
81             ret["comment"] = (
82                 "{entity_type} was enforced to the desired state.  Note: Only"
83                 " parameters specified were enforced. See changes for details.".format(
84                     entity_type=entity_type
85                 )
86             )
87             ret["changes"]["old"] = existing
88             ret["changes"]["new"] = modified
89     return ret
90 def _test_output(ret, action, params):
91     """
92     For testing just output what the state will attempt to do without actually doing it.
93     """
94     if action == "list":
95         ret[
96             "comment"
97         ] += "The list action will just list an entity and will make no changes.\n"
98     elif action == "create" or action == "add":
99         ret["comment"] += (
100             "The create action will attempt to create an entity if it does not already"
101             " exist.\n"
102         )
103     elif action == "delete":
104         ret["comment"] += (
105             "The delete action will attempt to delete an existing entity if it"
106             " exists.\n"
107         )
108     elif action == "manage":
109         ret["comment"] += (
110             "The manage action will create a new entity if it does not exist.  If it"
111             " does exist, it will be enforcedto the desired state.\n"
112         )
113     elif action == "modify":
114         ret["comment"] += (
115             "The modify action will attempt to modify an existing entity only if it"
116             " exists.\n"
117         )
118     ret["comment"] += "An iControl REST Request will be made using the parameters:\n"
119     ret["comment"] += salt.utils.json.dumps(params, indent=4)
120     ret["changes"] = {}
121     ret["result"] = None
122     return ret
123 def list_node(hostname, username, password, name):
124     """
125     A function to connect to a bigip device and list a specific node.
126     hostname
127         The host/address of the bigip device
128     username
129         The iControl REST username
130     password
131         The iControl REST password
132     name
133         The name of the node to list.
134     """
135     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
136     if __opts__["test"]:
137         return _test_output(
138             ret,
139             "list",
140             params={
141                 "hostname": hostname,
142                 "username": username,
143                 "password": password,
144                 "name": name,
145             },
146         )
147     response = __salt__["bigip.list_node"](hostname, username, password, name)
148     return _load_result(response, ret)
149 def create_node(hostname, username, password, name, address):
150     """
151     Create a new node if it does not already exist.
152     hostname
153         The host/address of the bigip device
154     username
155         The iControl REST username
156     password
157         The iControl REST password
158     name
159         The name of the node to create
160     address
161         The address of the node
162     """
163     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
164     if __opts__["test"]:
165         return _test_output(
166             ret,
167             "create",
168             params={
169                 "hostname": hostname,
170                 "username": username,
171                 "password": password,
172                 "name": name,
173                 "address": address,
174             },
175         )
176     existing = __salt__["bigip.list_node"](hostname, username, password, name)
177     if existing["code"] == 200:
178         ret["result"] = True
179         ret["comment"] = "A node by this name currently exists.  No change made."
180     elif existing["code"] == 404:
181         response = __salt__["bigip.create_node"](
182             hostname, username, password, name, address
183         )
184         ret["result"] = True
185         ret["changes"]["old"] = {}
186         ret["changes"]["new"] = response["content"]
187         ret["comment"] = "Node was successfully created."
188     else:
189         ret = _load_result(existing, ret)
190     return ret
191 def manage_node(
192     hostname,
193     username,
194     password,
195     name,
196     address,
197     connection_limit=None,
198     description=None,
199     dynamic_ratio=None,
200     logging=None,
201     monitor=None,
202     rate_limit=None,
203     ratio=None,
204     session=None,
205     node_state=None,
206 ):
207     """
208     Manages a node of a given bigip device.  If the node does not exist it will be created, otherwise,
209     only the properties which are different than the existing will be updated.
210     hostname
211         The host/address of the bigip device
212     username
213         The iControl REST username
214     password
215         The iControl REST password
216     name
217         The name of the node to manage.
218     address
219         The address of the node
220     connection_limit
221         [integer]
222     description
223         [string]
224     dynam
225         c_ratio:        [integer]
226     logging
227         [enabled | disabled]
228     monitor
229         [[name] | none | default]
230     rate_limit
231         [integer]
232     ratio
233         [integer]
234     session
235         [user-enabled | user-disabled]
236     node_state (state)
237         [user-down | user-up ]
238     """
239     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
240     if __opts__["test"]:
241         return _test_output(
242             ret,
243             "manage",
244             params={
245                 "hostname": hostname,
246                 "username": username,
247                 "password": password,
248                 "name": name,
249                 "address": address,
250                 "connection_limit": connection_limit,
251                 "description": description,
252                 "dynamic_ratio": dynamic_ratio,
253                 "logging": logging,
254                 "monitor": monitor,
255                 "rate_limit": rate_limit,
256                 "ratio": ratio,
257                 "session": session,
258                 "state:": node_state,
259             },
260         )
261     existing = __salt__["bigip.list_node"](hostname, username, password, name)
262     if existing["code"] == 200:
263         if existing["content"]["address"] != address:
264             ret["result"] = False
265             ret[
266             ] = "A node with this name exists but the address does not match."
267         modified <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["bigip.modify_node"](
268             hostname=hostname,
269             username=username,
270             password=password,
271             name=name,
272             connection_limit=connection_limit,
273             description=description,
274             dynamic_ratio=dynamic_ratio,
275             logging=logging,
276             monitor=monitor,
277             rate_limit=rate_limit,
278             ratio=ratio,
279             session=</b></font>session,
280             state=node_state,
281         )
282         if modified["code"] == 200:
283             ret = _check_for_changes("Node", ret, existing, modified)
284         else:
285             ret = _load_result(modified, ret)
286     elif existing["code"] == 404:
287         new = __salt__["bigip.create_node"](hostname, username, password, name, address)
288             modified = __salt__<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_node"](
289                 hostname=hostname,
290                 username=username,
291                 password=password,
292                 name=name,
293                 connection_limit=connection_limit,
294                 description=description,
295                 dynamic_ratio=dynamic_ratio,
296                 logging=logging,
297                 monitor=monitor,
298                 rate_limit=rate_limit,
299                 ratio=ratio,
300                 session=session,
301                 state=</b></font>node_state,
302             )
303             if modified["code"] == 200:
304                 ret["result"] = True
305                 ret["comment"] = (
306                     "Node was created and enforced to the desired state.  Note: Only"
307                     " parameters specified were enforced.  See changes for details."
308                 )
309                 ret["changes"]["old"] = {}
310                 ret["changes"]["new"] = modified["content"]
311             else:
312                 deleted = __salt__["bigip.delete_node"](
313                     hostname, username, password, name
314                 )
315                 if deleted["code"] == 200:
316                     ret["comment"] = (
317                         "Node was successfully created but an error occurred during"
318                         " modification. The creation of the node has been rolled back."
319                         " Message is as follows:\n{message}".format(
320                             message=modified["content"]["message"]
321                         )
322                     )
323                 else:
324                     ret["comment"] = (
325                         "Node was successfully created but an error occurred during"
326                         " modification. The creation of the node was not able to be"
327                         " rolled back. Message is as follows:\n"
328                         " {message}\n{message_two}".format(
329                             message=modified["content"]["message"],
330                             message_two=deleted["content"]["message"],
331                         )
332                     )
333         else:
334             ret = _load_result(new, ret)
335     else:
336         ret = _load_result(existing, ret)
337     return ret
338 def modify_node(
339     hostname,
340     username,
341     password,
342     name,
343     connection_limit=None,
344     description=None,
345     dynamic_ratio=None,
346     logging=None,
347     monitor=None,
348     rate_limit=None,
349     ratio=None,
350     session=None,
351     node_state=None,
352 ):
353     """
354     Modify an existing node. Only a node which already exists will be modified and
355     only the parameters specified will be enforced.
356     hostname
357         The host/address of the bigip device
358     username
359         The iControl REST username
360     password
361         The iControl REST password
362     name
363         The name of the node to modify
364     connection_limit
365         [integer]
366     description
367         [string]
368     dynamic_ratio
369         [integer]
370     logging
371         [enabled | disabled]
372     monitor
373         [[name] | none | default]
374     rate_limit
375         [integer]
376     ratio
377         [integer]
378     session
379         [user-enabled | user-disabled]
380     node_state (state)
381         [user-down | user-up ]
382     """
383     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
384     if __opts__["test"]:
385         return _test_output(
386             ret,
387             "modify",
388             params={
389                 "hostname": hostname,
390                 "username": username,
391                 "password": password,
392                 "name": name,
393                 "connection_limit": connection_limit,
394                 "description": description,
395                 "dynamic_ratio": dynamic_ratio,
396                 "logging": logging,
397                 "monitor": monitor,
398                 "rate_limit": rate_limit,
399                 "ratio": ratio,
400                 "session": session,
401                 "state:": node_state,
402             },
403         )
404     existing = __salt__["bigip.list_node"](hostname, username, password, name)
405     if existing["code"] == 200:
406         modified = __salt__<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_node"](
407             hostname=hostname,
408             username=username,
409             password=password,
410             name=name,
411             connection_limit=connection_limit,
412             description=description,
413             dynamic_ratio=dynamic_ratio,
414             logging=logging,
415             monitor=monitor,
416             rate_limit=rate_limit,
417             ratio=</b></font>ratio,
418             session=session,
419             state=node_state,
420         )
421         if modified["code"] == 200:
422             ret = _check_for_changes("Node", ret, existing, modified)
423         else:
424             ret = _load_result(modified, ret)
425     elif existing["code"] == 404:
426         ret["comment"] = "A node with this name was not found."
427     else:
428         ret = _load_result(existing, ret)
429     return ret
430 def delete_node(hostname, username, password, name):
431     """
432     Delete an existing node.
433     hostname
434         The host/address of the bigip device
435     username
436         The iControl REST username
437     password
438         The iControl REST password
439     name
440         The name of the node which will be deleted.
441     """
442     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
443     if __opts__["test"]:
444         return _test_output(
445             ret,
446             "delete",
447             params={
448                 "hostname": hostname,
449                 "username": username,
450                 "password": password,
451                 "name": name,
452             },
453         )
454     existing = __salt__["bigip.list_node"](hostname, username, password, name)
455     if existing["code"] == 200:
456         deleted = __salt__["bigip.delete_node"](hostname, username, password, name)
457         if deleted["code"] == 200:
458             ret["result"] = True
459             ret["comment"] = "Node was successfully deleted."
460             ret["changes"]["old"] = existing["content"]
461             ret["changes"]["new"] = {}
462         else:
463             ret = _load_result(existing, ret)
464     elif existing["code"] == 404:
465         ret["result"] = True
466         ret["comment"] = "This node already does not exist. No changes made."
467         ret["changes"]["old"] = {}
468         ret["changes"]["new"] = {}
469     else:
470         ret = _load_result(existing, ret)
471     return ret
472 def list_pool(hostname, username, password, name):
473     """
474     A function to connect to a bigip device and list a specific pool.
475     hostname
476         The host/address of the bigip device
477     username
478         The iControl REST username
479     password
480         The iControl REST password
481     name
482         The name of the pool to list.
483     """
484     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
485     if __opts__["test"]:
486         return _test_output(
487             ret,
488             "list",
489             params={
490                 "hostname": hostname,
491                 "username": username,
492                 "password": password,
493                 "name": name,
494             },
495         )
496     response = __salt__["bigip.list_pool"](hostname, username, password, name)
497     return _load_result(response, ret)
498 def create_pool(
499     hostname,
500     username,
501     password,
502     name,
503     members=None,
504     allow_nat=None,
505     allow_snat=None,
506     description=None,
507     gateway_failsafe_device=None,
508     ignore_persisted_weight=None,
509     ip_tos_to_client=None,
510     ip_tos_to_server=None,
511     link_qos_to_client=None,
512     link_qos_to_server=None,
513     load_balancing_mode=None,
514     min_active_members=None,
515     min_up_members=None,
516     min_up_members_action=None,
517     min_up_members_checking=None,
518     monitor=None,
519     profiles=None,
520     queue_depth_limit=None,
521     queue_on_connection_limit=None,
522     queue_time_limit=None,
523     reselect_tries=None,
524     service_down_action=None,
525     slow_ramp_time=None,
526 ):
527     """
528     Create a new node if it does not already exist.
529     hostname
530         The host/address of the bigip device
531     username
532         The iControl REST username
533     password
534         The iControl REST password
535     name
536         The name of the pool to create
537     members
538         List of members to be added to the pool
539     allow_nat
540         [yes | no]
541     allow_snat
542         [yes | no]
543     description
544         [string]
545     gateway_failsafe_device
546         [string]
547     ignore_persisted_weight
548         [enabled | disabled]
549     ip_tos_to_client
550         [pass-through | [integer]]
551     ip_tos_to_server
552         [pass-through | [integer]]
553     link_qos_to_client
554         [pass-through | [integer]]
555     link_qos_to_server
556         [pass-through | [integer]]
557     load_balancing_mode
558         [dynamic-ratio-member | dynamic-ratio-node |
559         fastest-app-response | fastest-node |
560         least-connections-members |
561         least-connections-node |
562         least-sessions |
563         observed-member | observed-node |
564         predictive-member | predictive-node |
565         ratio-least-connections-member |
566         ratio-least-connections-node |
567         ratio-member | ratio-node | ratio-session |
568         round-robin | weighted-least-connections-member |
569         weighted-least-connections-node]
570     min_active_members
571         [integer]
572     min_up_members
573         [integer]
574     min_up_members_action
575         [failover | reboot | restart-all]
576     min_up_members_checking
577         [enabled | disabled]
578     monitor
579         [name]
580     profiles
581         [none | profile_name]
582     queue_depth_limit
583         [integer]
584     queue_on_connection_limit
585         [enabled | disabled]
586     queue_time_limit
587         [integer]
588     reselect_tries
589         [integer]
590     service_down_action
591         [drop | none | reselect | reset]
592     slow_ramp_time
593         [integer]
594     """
595     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
596     if __opts__["test"]:
597         return _test_output(
598             ret,
599             "create",
600             params={
601                 "hostname": hostname,
602                 "username": username,
603                 "password": password,
604                 "name": name,
605                 "members": members,
606                 "allow_nat": allow_nat,
607                 "allow_snat": allow_snat,
608                 "description": description,
609                 "gateway_failsafe_device": gateway_failsafe_device,
610                 "ignore_persisted_weight": ignore_persisted_weight,
611                 "ip_tos_client:": ip_tos_to_client,
612                 "ip_tos_server": ip_tos_to_server,
613                 "link_qos_to_client": link_qos_to_client,
614                 "link_qos_to_server": link_qos_to_server,
615                 "load_balancing_mode": load_balancing_mode,
616                 "min_active_members": min_active_members,
617                 "min_up_members": min_up_members,
618                 "min_up_members_checking": min_up_members_checking,
619                 "monitor": monitor,
620                 "profiles": profiles,
621                 "queue_depth_limit": queue_depth_limit,
622                 "queue_on_connection_limit": queue_on_connection_limit,
623                 "queue_time_limit": queue_time_limit,
624                 "reselect_tries": reselect_tries,
625                 "service_down_action": service_down_action,
626                 "slow_ramp_time": slow_ramp_time,
627             },
628         )
629     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
630     if existing["code"] == 200:
631         ret["result"] = True
632         ret["comment"] = "A pool by this name currently exists.  No change made."
633     elif existing["code"] == 404:
634         response <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= __salt__["bigip.create_pool"](
635             hostname=hostname,
636             username=username,
637             password=password,
638             name=name,
639             members=members,
640             allow_nat=allow_nat,
641             allow_snat=allow_snat,
642             description=description,
643             gateway_failsafe_device=gateway_failsafe_device,
644             ignore_persisted_weight=ignore_persisted_weight,
645             ip_tos_to_client=ip_tos_to_client,
646             ip_tos_to_server=ip_tos_to_server,
647             link_qos_to_client=link_qos_to_client,
648             link_qos_to_server=link_qos_to_server,
649             load_balancing_mode=load_balancing_mode,
650             min_active_members=</b></font>min_active_members,
651             min_up_members=min_up_members,
652             min_up_members_action=min_up_members_action,
653             min_up_members_checking=min_up_members_checking,
654             monitor=monitor,
655             profiles=profiles,
656             queue_depth_limit=queue_depth_limit,
657             queue_on_connection_limit=queue_on_connection_limit,
658             queue_time_limit=queue_time_limit,
659             reselect_tries=reselect_tries,
660             service_down_action=service_down_action,
661             slow_ramp_time=slow_ramp_time,
662         )
663         if response["code"] == 200:
664             ret["result"] = True
665             ret["changes"]["old"] = {}
666             ret["changes"]["new"] = response["content"]
667             ret["comment"] = "Pool was successfully created."
668         else:
669             ret = _load_result(existing, ret)
670     else:
671         ret = _load_result(existing, ret)
672     return ret
673 def manage_pool(
674     hostname,
675     username,
676     password,
677     name,
678     allow_nat=None,
679     allow_snat=None,
680     description=None,
681     gateway_failsafe_device=None,
682     ignore_persisted_weight=None,
683     ip_tos_to_client=None,
684     ip_tos_to_server=None,
685     link_qos_to_client=None,
686     link_qos_to_server=None,
687     load_balancing_mode=None,
688     min_active_members=None,
689     min_up_members=None,
690     min_up_members_action=None,
691     min_up_members_checking=None,
692     monitor=None,
693     profiles=None,
694     queue_depth_limit=None,
695     queue_on_connection_limit=None,
696     queue_time_limit=None,
697     reselect_tries=None,
698     service_down_action=None,
699     slow_ramp_time=None,
700 ):
701     """
702     Create a new pool if it does not already exist. Pool members are managed separately. Only the
703     parameters specified are enforced.
704     hostname
705         The host/address of the bigip device
706     username
707         The iControl REST username
708     password
709         The iControl REST password
710     name
711         The name of the pool to create
712     allow_nat
713         [yes | no]
714     allow_snat
715         [yes | no]
716     description
717         [string]
718     gateway_failsafe_device
719         [string]
720     ignore_persisted_weight
721         [enabled | disabled]
722     ip_tos_to_client
723         [pass-through | [integer]]
724     ip_tos_to_server
725         [pass-through | [integer]]
726     link_qos_to_client
727         [pass-through | [integer]]
728     link_qos_to_server
729         [pass-through | [integer]]
730     load_balancing_mode
731         [dynamic-ratio-member | dynamic-ratio-node |
732         fastest-app-response | fastest-node |
733         least-connections-members |
734         least-connections-node |
735         least-sessions |
736         observed-member | observed-node |
737         predictive-member | predictive-node |
738         ratio-least-connections-member |
739         ratio-least-connections-node |
740         ratio-member | ratio-node | ratio-session |
741         round-robin | weighted-least-connections-member |
742         weighted-least-connections-node]
743     min_active_members
744         [integer]
745     min_up_members
746         [integer]
747     min_up_members_action
748         [failover | reboot | restart-all]
749     min_up_members_checking
750         [enabled | disabled]
751     monitor
752         [name]
753     profiles
754         [none | profile_name]
755     queue_depth_limit
756         [integer]
757     queue_on_connection_limit
758         [enabled | disabled]
759     queue_time_limit
760         [integer]
761     reselect_tries
762         [integer]
763     service_down_action
764         [drop | none | reselect | reset]
765     slow_ramp_time
766         [integer]
767     """
768     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
769     if __opts__["test"]:
770         return _test_output(
771             ret,
772             "manage",
773             params={
774                 "hostname": hostname,
775                 "username": username,
776                 "password": password,
777                 "name": name,
778                 "allow_nat": allow_nat,
779                 "allow_snat": allow_snat,
780                 "description": description,
781                 "gateway_failsafe_device": gateway_failsafe_device,
782                 "ignore_persisted_weight": ignore_persisted_weight,
783                 "ip_tos_client:": ip_tos_to_client,
784                 "ip_tos_server": ip_tos_to_server,
785                 "link_qos_to_client": link_qos_to_client,
786                 "link_qos_to_server": link_qos_to_server,
787                 "load_balancing_mode": load_balancing_mode,
788                 "min_active_members": min_active_members,
789                 "min_up_members": min_up_members,
790                 "min_up_members_checking": min_up_members_checking,
791                 "monitor": monitor,
792                 "profiles": profiles,
793                 "queue_depth_limit": queue_depth_limit,
794                 "queue_on_connection_limit": queue_on_connection_limit,
795                 "queue_time_limit": queue_time_limit,
796                 "reselect_tries": reselect_tries,
797                 "service_down_action": service_down_action,
798                 "slow_ramp_time": slow_ramp_time,
799             },
800         )
801     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
802     if existing["code"] == 200:
803         modified = __salt__<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_pool"](
804             hostname=hostname,
805             username=username,
806             password=password,
807             name=name,
808             allow_nat=allow_nat,
809             allow_snat=allow_snat,
810             description=description,
811             gateway_failsafe_device=gateway_failsafe_device,
812             ignore_persisted_weight=ignore_persisted_weight,
813             ip_tos_to_client=ip_tos_to_client,
814             ip_tos_to_server=ip_tos_to_server,
815             link_qos_to_client=link_qos_to_client,
816             link_qos_to_server=link_qos_to_server,
817             load_balancing_mode=load_balancing_mode,
818             min_active_members=</b></font>min_active_members,
819             min_up_members=min_up_members,
820             min_up_members_action=min_up_members_action,
821             min_up_members_checking=min_up_members_checking,
822             monitor=monitor,
823             profiles=profiles,
824             queue_depth_limit=queue_depth_limit,
825             queue_on_connection_limit=queue_on_connection_limit,
826             queue_time_limit=queue_time_limit,
827             reselect_tries=reselect_tries,
828             service_down_action=service_down_action,
829             slow_ramp_time=slow_ramp_time,
830         )
831         if modified["code"] == 200:
832             del existing["content"]["membersReference"]
833             del modified["content"]["membersReference"]
834             del existing["content"]["selfLink"]
835             del modified["content"]["selfLink"]
836             ret = _check_for_changes("Pool", ret, existing, modified)
837         else:
838             ret = _load_result(modified, ret)
839     elif existing["code"] == 404:
840         new = __salt__<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.create_pool"](
841             hostname=hostname,
842             username=username,
843             password=password,
844             name=name,
845             allow_nat=allow_nat,
846             allow_snat=allow_snat,
847             description=description,
848             gateway_failsafe_device=gateway_failsafe_device,
849             ignore_persisted_weight=ignore_persisted_weight,
850             ip_tos_to_client=ip_tos_to_client,
851             ip_tos_to_server=ip_tos_to_server,
852             link_qos_to_client=link_qos_to_client,
853             link_qos_to_server=link_qos_to_server,
854             load_balancing_mode=</b></font>load_balancing_mode,
855             min_active_members=min_active_members,
856             min_up_members=min_up_members,
857             min_up_members_action=min_up_members_action,
858             min_up_members_checking=min_up_members_checking,
859             monitor=monitor,
860             profiles=profiles,
861             queue_depth_limit=queue_depth_limit,
862             queue_on_connection_limit=queue_on_connection_limit,
863             queue_time_limit=queue_time_limit,
864             reselect_tries=reselect_tries,
865             service_down_action=service_down_action,
866             slow_ramp_time=slow_ramp_time,
867         )
868         if new["code"] == 200:
869             ret["result"] = True
870             ret["comment"] = (
871                 "Pool was created and enforced to the desired state.  Note: Only"
872                 " parameters specified were enforced.  See changes for details."
873             )
874             ret["changes"]["old"] = {}
875             ret["changes"]["new"] = new["content"]
876         else:
877             ret = _load_result(new, ret)
878     else:
879         ret = _load_result(existing, ret)
880     return ret
881 def modify_pool(
882     hostname,
883     username,
884     password,
885     name,
886     allow_nat=None,
887     allow_snat=None,
888     description=None,
889     gateway_failsafe_device=None,
890     ignore_persisted_weight=None,
891     ip_tos_to_client=None,
892     ip_tos_to_server=None,
893     link_qos_to_client=None,
894     link_qos_to_server=None,
895     load_balancing_mode=None,
896     min_active_members=None,
897     min_up_members=None,
898     min_up_members_action=None,
899     min_up_members_checking=None,
900     monitor=None,
901     profiles=None,
902     queue_depth_limit=None,
903     queue_on_connection_limit=None,
904     queue_time_limit=None,
905     reselect_tries=None,
906     service_down_action=None,
907     slow_ramp_time=None,
908 ):
909     """
910     Modify an existing pool. Pool members are managed separately. Only the
911     parameters specified are enforced.
912     hostname
913         The host/address of the bigip device
914     username
915         The iControl REST username
916     password
917         The iControl REST password
918     name
919         The name of the pool to create
920     allow_nat
921         [yes | no]
922     allow_snat
923         [yes | no]
924     description
925         [string]
926     gateway_failsafe_device
927         [string]
928     ignore_persisted_weight
929         [enabled | disabled]
930     ip_tos_to_client
931         [pass-through | [integer]]
932     ip_tos_to_server
933         [pass-through | [integer]]
934     link_qos_to_client
935         [pass-through | [integer]]
936     link_qos_to_server
937         [pass-through | [integer]]
938     load_balancing_mode
939         [dynamic-ratio-member | dynamic-ratio-node |
940         fastest-app-response | fastest-node |
941         least-connections-members |
942         least-connections-node |
943         least-sessions |
944         observed-member | observed-node |
945         predictive-member | predictive-node |
946         ratio-least-connections-member |
947         ratio-least-connections-node |
948         ratio-member | ratio-node | ratio-session |
949         round-robin | weighted-least-connections-member |
950         weighted-least-connections-node]
951     min_active_members
952         [integer]
953     min_up_members
954         [integer]
955     min_up_members_action
956         [failover | reboot | restart-all]
957     min_up_members_checking
958         [enabled | disabled]
959     monitor
960         [name]
961     profiles
962         [none | profile_name]
963     queue_depth_limit
964         [integer]
965     queue_on_connection_limit
966         [enabled | disabled]
967     queue_time_limit
968         [integer]
969     reselect_tries
970         [integer]
971     service_down_action
972         [drop | none | reselect | reset]
973     slow_ramp_time
974         [integer]
975     """
976     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
977     if __opts__["test"]:
978         return _test_output(
979             ret,
980             "modify",
981             params={
982                 "hostname": hostname,
983                 "username": username,
984                 "password": password,
985                 "name": name,
986                 "allow_nat": allow_nat,
987                 "allow_snat": allow_snat,
988                 "description": description,
989                 "gateway_failsafe_device": gateway_failsafe_device,
990                 "ignore_persisted_weight": ignore_persisted_weight,
991                 "ip_tos_client:": ip_tos_to_client,
992                 "ip_tos_server": ip_tos_to_server,
993                 "link_qos_to_client": link_qos_to_client,
994                 "link_qos_to_server": link_qos_to_server,
995                 "load_balancing_mode": load_balancing_mode,
996                 "min_active_members": min_active_members,
997                 "min_up_members": min_up_members,
998                 "min_up_members_checking": min_up_members_checking,
999                 "monitor": monitor,
1000                 "profiles": profiles,
1001                 "queue_depth_limit": queue_depth_limit,
1002                 "queue_on_connection_limit": queue_on_connection_limit,
1003                 "queue_time_limit": queue_time_limit,
1004                 "reselect_tries": reselect_tries,
1005                 "service_down_action": service_down_action,
1006                 "slow_ramp_time": slow_ramp_time,
1007             },
1008         )
1009     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1010     if existing["code"] == 200:
1011         modified = __salt__<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>["bigip.modify_pool"](
1012             hostname=hostname,
1013             username=username,
1014             password=password,
1015             name=name,
1016             allow_nat=allow_nat,
1017             allow_snat=allow_snat,
1018             description=description,
1019             gateway_failsafe_device=gateway_failsafe_device,
1020             ignore_persisted_weight=ignore_persisted_weight,
1021             ip_tos_to_client=ip_tos_to_client,
1022             ip_tos_to_server=ip_tos_to_server,
1023             link_qos_to_client=link_qos_to_client,
1024             link_qos_to_server=link_qos_to_server,
1025             load_balancing_mode=</b></font>load_balancing_mode,
1026             min_active_members=min_active_members,
1027             min_up_members=min_up_members,
1028             min_up_members_action=min_up_members_action,
1029             min_up_members_checking=min_up_members_checking,
1030             monitor=monitor,
1031             profiles=profiles,
1032             queue_depth_limit=queue_depth_limit,
1033             queue_on_connection_limit=queue_on_connection_limit,
1034             queue_time_limit=queue_time_limit,
1035             reselect_tries=reselect_tries,
1036             service_down_action=service_down_action,
1037             slow_ramp_time=slow_ramp_time,
1038         )
1039         if modified["code"] == 200:
1040             del existing["content"]["membersReference"]
1041             del modified["content"]["membersReference"]
1042             del existing["content"]["selfLink"]
1043             del modified["content"]["selfLink"]
1044             ret = _check_for_changes("Pool", ret, existing, modified)
1045         else:
1046             ret = _load_result(modified, ret)
1047     elif existing["code"] == 404:
1048         ret["comment"] = "A pool with this name was not found."
1049     else:
1050         ret = _load_result(existing, ret)
1051     return ret
1052 def delete_pool(hostname, username, password, name):
1053     """
1054     Delete an existing pool.
1055     hostname
1056         The host/address of the bigip device
1057     username
1058         The iControl REST username
1059     password
1060         The iControl REST password
1061     name
1062         The name of the pool which will be deleted
1063     """
1064     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1065     if __opts__["test"]:
1066         return _test_output(
1067             ret,
1068             "delete",
1069             params={
1070                 "hostname": hostname,
1071                 "username": username,
1072                 "password": password,
1073                 "name": name,
1074             },
1075         )
1076     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1077     if existing["code"] == 200:
1078         deleted = __salt__["bigip.delete_pool"](hostname, username, password, name)
1079         if deleted["code"] == 200:
1080             ret["result"] = True
1081             ret["comment"] = "Pool was successfully deleted."
1082             ret["changes"]["old"] = existing["content"]
1083             ret["changes"]["new"] = {}
1084         else:
1085             ret = _load_result(deleted, ret)
1086     elif existing["code"] == 404:
1087         ret["result"] = True
1088         ret["comment"] = "This pool already does not exist. No changes made."
1089         ret["changes"]["old"] = {}
1090         ret["changes"]["new"] = {}
1091     else:
1092         ret = _load_result(existing, ret)
1093     return ret
1094 def manage_pool_members(hostname, username, password, name, members):
1095     """
1096     Manage the members of an existing pool.  This function replaces all current pool members.
1097     Only the parameters specified are enforced.
1098     hostname
1099         The host/address of the bigip device
1100     username
1101         The iControl REST username
1102     password
1103         The iControl REST password
1104     name
1105         The name of the pool to modify
1106     members
1107         list of pool members to manage.
1108     """
1109     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1110     if __opts__["test"]:
1111         return _test_output(
1112             ret,
1113             "manage",
1114             params={
1115                 "hostname": hostname,
1116                 "username": username,
1117                 "password": password,
1118                 "name": name,
1119                 "members": members,
1120             },
1121         )
1122     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1123     if existing["code"] == 200:
1124         current_members = existing["content"]["membersReference"]["items"]
1125         modified = __salt__["bigip.replace_pool_members"](
1126             hostname, username, password, name, members
1127         )
1128         if modified["code"] == 200:
1129             new_listing = __salt__["bigip.list_pool"](
1130                 hostname, username, password, name
1131             )
1132             if new_listing["code"] != 200:
1133                 ret = _load_result(new_listing, ret)
1134                 ret["comment"] = (
1135                     "modification of the pool was successful but an error occurred upon"
1136                     " retrieving new listing."
1137                 )
1138                 return ret
1139             new_members = new_listing["content"]["membersReference"]["items"]
1140             for current_member in current_members:
1141                 del current_member["generation"]
1142             for new_member in new_members:
1143                 del new_member["generation"]
1144             ret = _check_for_changes(
1145                 "Pool Membership", ret, current_members, new_members
1146             )
1147         else:
1148             ret = _load_result(modified, ret)
1149     elif existing["code"] == 404:
1150         ret["comment"] = "A pool with this name was not found."
1151     else:
1152         ret = _load_result(existing, ret)
1153     return ret
1154 def add_pool_member(hostname, username, password, name, member):
1155     """
1156     A function to connect to a bigip device and add a new member to an existing pool.
1157     hostname
1158         The host/address of the bigip device
1159     username
1160         The iControl REST username
1161     password
1162         The iControl REST password
1163     name
1164         The name of the pool to modify
1165     member
1166         The member to add to the pool
1167     """
1168     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1169     if __opts__["test"]:
1170         return _test_output(
1171             ret,
1172             "add",
1173             params={
1174                 "hostname": hostname,
1175                 "username": username,
1176                 "password": password,
1177                 "name": name,
1178                 "members": member,
1179             },
1180         )
1181     existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
1182     if existing_pool["code"] == 200:
1183         current_members = existing_pool["content"]["membersReference"]["items"]
1184         exists = False
1185         for current_member in current_members:
1186             if current_member["name"] == member["name"]:
1187                 exists = True
1188                 break
1189         if exists:
1190             ret["result"] = True
1191             ret[
1192                 "comment"
1193             ] = "Member: {name} already exists within this pool.  No changes made.".format(
1194                 name=member["name"]
1195             )
1196             ret["changes"]["old"] = {}
1197             ret["changes"]["new"] = {}
1198         else:
1199             new_member = __salt__["bigip.add_pool_member"](
1200                 hostname, username, password, name, member
1201             )
1202             if new_member["code"] == 200:
1203                 ret["result"] = True
1204                 ret[
1205                     "comment"
1206                 ] = "Member: {name} has been successfully added to the pool.".format(
1207                     name=member["name"]
1208                 )
1209                 ret["changes"]["old"] = {}
1210                 pool_listing = __salt__["bigip.list_pool"](
1211                     hostname, username, password, name
1212                 )
1213                 if pool_listing["code"] != 200:
1214                     ret = _load_result(new_member, ret)
1215                     return ret
1216                 members = pool_listing["content"]["membersReference"]["items"]
1217                 for current_member in members:
1218                     if current_member["name"] == member["name"]:
1219                         added_member = current_member
1220                         break
1221                 ret["changes"]["new"] = added_member
1222             else:
1223                 ret = _load_result(new_member, ret)
1224     elif existing_pool["code"] == 404:
1225         ret["comment"] = "A pool with this name was not found."
1226     else:
1227         ret = _load_result(existing_pool, ret)
1228     return ret
1229 def modify_pool_member(
1230     hostname,
1231     username,
1232     password,
1233     name,
1234     member,
1235     connection_limit=None,
1236     description=None,
1237     dynamic_ratio=None,
1238     inherit_profile=None,
1239     logging=None,
1240     monitor=None,
1241     priority_group=None,
1242     profiles=None,
1243     rate_limit=None,
1244     ratio=None,
1245     session=None,
1246     member_state=None,
1247 ):
1248     """
1249     A function to connect to a bigip device and modify a member of an existing pool.
1250     hostname
1251         The host/address of the bigip device
1252     username
1253         The iControl REST username
1254     password
1255         The iControl REST password
1256     name
1257         The name of the pool to modify
1258     member
1259         The member modify
1260     connection_limit
1261         [integer]
1262     description
1263         [string]
1264     dynamic_ratio
1265         [integer]
1266     inherit_profile
1267         [enabled | disabled]
1268     logging
1269         [enabled | disabled]
1270     monitor
1271         [name]
1272     priority_group
1273         [integer]
1274     profiles
1275         [none | profile_name]
1276     rate_limit
1277         [integer]
1278     ratio
1279         [integer]
1280     session
1281         [user-enabled | user-disabled]
1282     member_state (state)
1283         [ user-up | user-down ]
1284     """
1285     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1286     if __opts__["test"]:
1287         return _test_output(
1288             ret,
1289             "modify",
1290             params={
1291                 "hostname": hostname,
1292                 "username": username,
1293                 "password": password,
1294                 "name": name,
1295                 "members": member,
1296             },
1297         )
1298     existing_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
1299     if existing_pool["code"] == 200:
1300         current_members = existing_pool["content"]["membersReference"]["items"]
1301         exists = False
1302         for current_member in current_members:
1303             if current_member["name"] == member:
1304                 exists = True
1305                 existing_member = current_member
1306                 break
1307         if exists:
1308             modified = __salt__["bigip.modify_pool_member"](
1309                 hostname=hostname,
1310                 username=username,
1311                 password=password,
1312                 name=name,
1313                 member=member,
1314                 connection_limit=connection_limit,
1315                 description=description,
1316                 dynamic_ratio=dynamic_ratio,
1317                 inherit_profile=inherit_profile,
1318                 logging=logging,
1319                 monitor=monitor,
1320                 priority_group=priority_group,
1321                 profiles=profiles,
1322                 rate_limit=rate_limit,
1323                 ratio=ratio,
1324                 session=session,
1325                 state=member_state,
1326             )
1327             new_pool = __salt__["bigip.list_pool"](hostname, username, password, name)
1328             if modified["code"] == 200 and modified["code"] == 200:
1329                 new_members = new_pool["content"]["membersReference"]["items"]
1330                 for new_member in new_members:
1331                     if new_member["name"] == member:
1332                         modified_member = new_member
1333                         break
1334                 old = {"content": existing_member}
1335                 new = {"content": modified_member}
1336                 ret = _check_for_changes(
1337                     "Pool Member: {member}".format(member=member), ret, old, new
1338                 )
1339             else:
1340                 ret = _load_result(modified, ret)
1341         else:
1342             ret[
1343                 "comment"
1344             ] = "Member: {name} does not exists within this pool.  No changes made.".format(
1345                 name=member["name"]
1346             )
1347     elif existing_pool["code"] == 404:
1348         ret["comment"] = "A pool with this name was not found."
1349     else:
1350         ret = _load_result(existing_pool, ret)
1351     return ret
1352 def delete_pool_member(hostname, username, password, name, member):
1353     """
1354     Delete an existing pool member.
1355     hostname
1356         The host/address of the bigip device
1357     username
1358         The iControl REST username
1359     password
1360         The iControl REST password
1361     name
1362         The name of the pool to be modified
1363     member
1364         The name of the member to delete from the pool
1365     """
1366     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1367     if __opts__["test"]:
1368         return _test_output(
1369             ret,
1370             "delete",
1371             params={
1372                 "hostname": hostname,
1373                 "username": username,
1374                 "password": password,
1375                 "name": name,
1376                 "members": member,
1377             },
1378         )
1379     existing = __salt__["bigip.list_pool"](hostname, username, password, name)
1380     if existing["code"] == 200:
1381         current_members = existing["content"]["membersReference"]["items"]
1382         exists = False
1383         for current_member in current_members:
1384             if current_member["name"] == member:
1385                 exists = True
1386                 existing_member = current_member
1387                 break
1388         if exists:
1389             deleted = __salt__["bigip.delete_pool_member"](
1390                 hostname, username, password, name, member
1391             )
1392             if deleted["code"] == 200:
1393                 ret["result"] = True
1394                 ret[
1395                     "comment"
1396                 ] = "Pool Member: {member} was successfully deleted.".format(
1397                     member=member
1398                 )
1399                 ret["changes"]["old"] = existing_member
1400                 ret["changes"]["new"] = {}
1401         else:
1402             ret["result"] = True
1403             ret["comment"] = "This pool member already does not exist. No changes made."
1404             ret["changes"]["old"] = {}
1405             ret["changes"]["new"] = {}
1406     else:
1407         ret = _load_result(existing, ret)
1408     return ret
1409 def list_virtual(hostname, username, password, name):
1410     """
1411     A function to list a specific virtual.
1412     hostname
1413         The host/address of the bigip device
1414     username
1415         The iControl REST username
1416     password
1417         The iControl REST password
1418     name
1419         The name of the virtual to list
1420     """
1421     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1422     if __opts__["test"]:
1423         return _test_output(
1424             ret,
1425             "list",
1426             params={
1427                 "hostname": hostname,
1428                 "username": username,
1429                 "password": password,
1430                 "name": name,
1431             },
1432         )
1433     response = __salt__["bigip.list_virtual"](hostname, username, password, name)
1434     return _load_result(response, ret)
1435 def create_virtual(
1436     hostname,
1437     username,
1438     password,
1439     name,
1440     destination,
1441     pool=None,
1442     address_status=None,
1443     auto_lasthop=None,
1444     bwc_policy=None,
1445     cmp_enabled=None,
1446     connection_limit=None,
1447     dhcp_relay=None,
1448     description=None,
1449     fallback_persistence=None,
1450     flow_eviction_policy=None,
1451     gtm_score=None,
1452     ip_forward=None,
1453     ip_protocol=None,
1454     internal=None,
1455     twelve_forward=None,
1456     last_hop_pool=None,
1457     mask=None,
1458     mirror=None,
1459     nat64=None,
1460     persist=None,
1461     profiles=None,
1462     policies=None,
1463     rate_class=None,
1464     rate_limit=None,
1465     rate_limit_mode=None,
1466     rate_limit_dst=None,
1467     rate_limit_src=None,
1468     rules=None,
1469     related_rules=None,
1470     reject=None,
1471     source=None,
1472     source_address_translation=None,
1473     source_port=None,
1474     virtual_state=None,
1475     traffic_classes=None,
1476     translate_address=None,
1477     translate_port=None,
1478     vlans=None,
1479 ):
1480     """
1481     A function to connect to a bigip device and create a virtual server if it does not already exists.
1482     hostname
1483         The host/address of the bigip device
1484     username
1485         The iControl REST username
1486     password
1487         The iControl REST password
1488     name
1489         The name of the virtual to create
1490     destination
1491         [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
1492     pool
1493         [ [pool_name] | none]
1494     address_status
1495         [yes | no]
1496     auto_lasthop
1497         [default | enabled | disabled ]
1498     bwc_policy
1499         [none] | string]
1500     cmp_enabled
1501         [yes | no]
1502     dhcp_relay
1503         [yes | no}
1504     connection_limit
1505         [integer]
1506     description
1507         [string]
1508     state
1509         [disabled | enabled]
1510     fallback_persistence
1511         [none | [profile name] ]
1512     flow_eviction_policy
1513         [none | [eviction policy name] ]
1514     gtm_score
1515         [integer]
1516     ip_forward
1517         [yes | no]
1518     ip_protocol
1519         [any | protocol]
1520     internal
1521         [yes | no]
1522     twelve_forward(12-forward)
1523         [yes | no]
1524     last_hop-pool
1525         [ [pool_name] | none]
1526     mask
1527         { [ipv4] | [ipv6] }
1528     mirror
1529         { [disabled | enabled | none] }
1530     nat64
1531         [enabled | disabled]
1532     persist
1533         [list]
1534     profiles
1535         [none | default | list ]
1536     policies
1537         [none | default | list ]
1538     rate_class
1539         [name]
1540     rate_limit
1541         [integer]
1542     rate_limit-mode
1543         [destination | object | object-destination |
1544         object-source | object-source-destination |
1545         source | source-destination]
1546     rate_limit-dst
1547         [integer]
1548     rate_limit-src
1549         [integer]
1550     rules
1551         [none | list ]
1552     related_rules
1553         [none | list ]
1554     reject
1555         [yes | no]
1556     source
1557         { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
1558     source_address_translation
1559         [none | snat:pool_name | lsn | automap | dictionary ]
1560     source_port
1561         [change | preserve | preserve-strict]
1562     state
1563         [enabled | disabled]
1564     traffic_classes
1565         [none | default | list ]
1566     translate_address
1567         [enabled | disabled]
1568     translate_port
1569         [enabled | disabled]
1570     vlans
1571         [none | default | dictionary]
1572         vlan_ids
1573             [ list]
1574         enabled
1575             [ true | false ]
1576     """
1577     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1578     if __opts__["test"]:
1579         return _test_output(
1580             ret,
1581             "create",
1582             params={
1583                 "hostname": hostname,
1584                 "username": username,
1585                 "password": password,
1586                 "name": name,
1587                 "destination": destination,
1588                 "pool": pool,
1589                 "address_status": address_status,
1590                 "auto_lasthop": auto_lasthop,
1591                 "bwc_policy": bwc_policy,
1592                 "cmp_enabled": cmp_enabled,
1593                 "connection_limit": connection_limit,
1594                 "dhcp_relay": dhcp_relay,
1595                 "description": description,
1596                 "fallback_persistence": fallback_persistence,
1597                 "flow_eviction_policy": flow_eviction_policy,
1598                 "gtm_score": gtm_score,
1599                 "ip_forward": ip_forward,
1600                 "ip_protocol": ip_protocol,
1601                 "internal": internal,
1602                 "twelve_forward": twelve_forward,
1603                 "last_hop_pool": last_hop_pool,
1604                 "mask": mask,
1605                 "mirror": mirror,
1606                 "nat64": nat64,
1607                 "persist": persist,
1608                 "profiles": profiles,
1609                 "policies": policies,
1610                 "rate_class": rate_class,
1611                 "rate_limit": rate_limit,
1612                 "rate_limit_mode": rate_limit_mode,
1613                 "rate_limit_dst": rate_limit_dst,
1614                 "rate_limit_src": rate_limit_src,
1615                 "rules": rules,
1616                 "related_rules": related_rules,
1617                 "reject": reject,
1618                 "source": source,
1619                 "source_address_translation": source_address_translation,
1620                 "source_port": source_port,
1621                 "virtual_state": virtual_state,
1622                 "traffic_classes": traffic_classes,
1623                 "translate_address": translate_address,
1624                 "translate_port": translate_port,
1625                 "vlans": vlans,
1626             },
1627         )
1628     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
1629         ret["result"] = True
1630         ret["comment"] <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>= "A virtual by this name currently exists.  No change made."
1631     elif existing["code"] == 404:
1632         virtual = __salt__["bigip.create_virtual"](
1633             hostname=hostname,
1634             username=username,
1635             password=password,
1636             name=name,
1637             destination=destination,
1638             description=description,
1639             pool=</b></font>pool,
1640             address_status=address_status,
1641             auto_lasthop=auto_lasthop,
1642             bwc_policy=bwc_policy,
1643             cmp_enabled=cmp_enabled,
1644             connection_limit=connection_limit,
1645             dhcp_relay=dhcp_relay,
1646             fallback_persistence=fallback_persistence,
1647             flow_eviction_policy=flow_eviction_policy,
1648             gtm_score=gtm_score,
1649             ip_forward=ip_forward,
1650             ip_protocol=ip_protocol,
1651             internal=internal,
1652             twelve_forward=twelve_forward,
1653             last_hop_pool=last_hop_pool,
1654             mask=mask,
1655             mirror=mirror,
1656             nat64=nat64,
1657             persist=persist,
1658             profiles=profiles,
1659             policies=policies,
1660             rate_class=rate_class,
1661             rate_limit=rate_limit,
1662             rate_limit_mode=rate_limit_mode,
1663             rate_limit_dst=rate_limit_dst,
1664             rate_limit_src=rate_limit_src,
1665             rules=rules,
1666             related_rules=related_rules,
1667             reject=reject,
1668             source=source,
1669             source_address_translation=source_address_translation,
1670             source_port=source_port,
1671             state=virtual_state,
1672             traffic_classes=traffic_classes,
1673             translate_address=translate_address,
1674             translate_port=translate_port,
1675             vlans=vlans,
1676         )
1677         if virtual["code"] == 200:
1678             ret["result"] = True
1679             ret["changes"]["old"] = {}
1680             ret["changes"]["new"] = virtual["content"]
1681             ret["comment"] = "Virtual was successfully created."
1682         else:
1683             ret = _load_result(existing, ret)
1684     else:
1685         ret = _load_result(existing, ret)
1686     return ret
1687 def manage_virtual(
1688     hostname,
1689     username,
1690     password,
1691     name,
1692     destination,
1693     pool=None,
1694     address_status=None,
1695     auto_lasthop=None,
1696     bwc_policy=None,
1697     cmp_enabled=None,
1698     connection_limit=None,
1699     dhcp_relay=None,
1700     description=None,
1701     fallback_persistence=None,
1702     flow_eviction_policy=None,
1703     gtm_score=None,
1704     ip_forward=None,
1705     ip_protocol=None,
1706     internal=None,
1707     twelve_forward=None,
1708     last_hop_pool=None,
1709     mask=None,
1710     mirror=None,
1711     nat64=None,
1712     persist=None,
1713     profiles=None,
1714     policies=None,
1715     rate_class=None,
1716     rate_limit=None,
1717     rate_limit_mode=None,
1718     rate_limit_dst=None,
1719     rate_limit_src=None,
1720     rules=None,
1721     related_rules=None,
1722     reject=None,
1723     source=None,
1724     source_address_translation=None,
1725     source_port=None,
1726     virtual_state=None,
1727     traffic_classes=None,
1728     translate_address=None,
1729     translate_port=None,
1730     vlans=None,
1731 ):
1732     """
1733     Manage a virtual server.  If a virtual does not exists it will be created, otherwise only the
1734     parameters specified will be enforced.
1735     hostname
1736         The host/address of the bigip device
1737     username
1738         The iControl REST username
1739     password
1740         The iControl REST password
1741     name
1742         The name of the virtual to create
1743     destination
1744         [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
1745     pool
1746         [ [pool_name] | none]
1747     address_status
1748         [yes | no]
1749     auto_lasthop
1750         [default | enabled | disabled ]
1751     bwc_policy
1752         [none] | string]
1753     cmp_enabled
1754         [yes | no]
1755     dhcp_relay
1756         [yes | no}
1757     connection_limit
1758         [integer]
1759     description
1760         [string]
1761     state
1762         [disabled | enabled]
1763     fallback_persistence
1764         [none | [profile name] ]
1765     flow_eviction_policy
1766         [none | [eviction policy name] ]
1767     gtm_score
1768         [integer]
1769     ip_forward
1770         [yes | no]
1771     ip_protocol
1772         [any | protocol]
1773     internal
1774         [yes | no]
1775     twelve_forward(12-forward)
1776         [yes | no]
1777     last_hop-pool
1778         [ [pool_name] | none]
1779     mask
1780         { [ipv4] | [ipv6] }
1781     mirror
1782         { [disabled | enabled | none] }
1783     nat64
1784         [enabled | disabled]
1785     persist
1786         [list]
1787     profiles
1788         [none | default | list ]
1789     policies
1790         [none | default | list ]
1791     rate_class
1792         [name]
1793     rate_limit
1794         [integer]
1795     rate_limit-mode
1796         [destination | object | object-destination |
1797         object-source | object-source-destination |
1798         source | source-destination]
1799     rate_limit-dst
1800         [integer]
1801     rate_limit-src
1802         [integer]
1803     rules
1804         [none | list ]
1805     related_rules
1806         [none | list ]
1807     reject
1808         [yes | no]
1809     source
1810         { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
1811     source_address_translation
1812         [none | snat:pool_name | lsn | automap | dictionary ]
1813     source_port
1814         [change | preserve | preserve-strict]
1815     state
1816         [enabled | disabled]
1817     traffic_classes
1818         [none | default | list ]
1819     translate_address
1820         [enabled | disabled]
1821     translate_port
1822         [enabled | disabled]
1823     vlans
1824         [none | default | dictionary]
1825         vlan_ids
1826             [ list]
1827         enabled
1828             [ true | false ]
1829     """
1830     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
1831     if __opts__["test"]:
1832         return _test_output(
1833             ret,
1834             "manage",
1835             params={
1836                 "hostname": hostname,
1837                 "username": username,
1838                 "password": password,
1839                 "name": name,
1840                 "destination": destination,
1841                 "pool": pool,
1842                 "address_status": address_status,
1843                 "auto_lasthop": auto_lasthop,
1844                 "bwc_policy": bwc_policy,
1845                 "cmp_enabled": cmp_enabled,
1846                 "connection_limit": connection_limit,
1847                 "dhcp_relay": dhcp_relay,
1848                 "description": description,
1849                 "fallback_persistence": fallback_persistence,
1850                 "flow_eviction_policy": flow_eviction_policy,
1851                 "gtm_score": gtm_score,
1852                 "ip_forward": ip_forward,
1853                 "ip_protocol": ip_protocol,
1854                 "internal": internal,
1855                 "twelve_forward": twelve_forward,
1856                 "last_hop_pool": last_hop_pool,
1857                 "mask": mask,
1858                 "mirror": mirror,
1859                 "nat64": nat64,
1860                 "persist": persist,
1861                 "profiles": profiles,
1862                 "policies": policies,
1863                 "rate_class": rate_class,
1864                 "rate_limit": rate_limit,
1865                 "rate_limit_mode": rate_limit_mode,
1866                 "rate_limit_dst": rate_limit_dst,
1867                 "rate_limit_src": rate_limit_src,
1868                 "rules": rules,
1869                 "related_rules": related_rules,
1870                 "reject": reject,
1871                 "source": source,
1872                 "source_address_translation": source_address_translation,
1873                 "source_port": source_port,
1874                 "virtual_state": virtual_state,
1875                 "traffic_classes": traffic_classes,
1876                 "translate_address": translate_address,
1877                 "translate_port": translate_port,
1878                 "vlans": vlans,
1879             },
1880         )
1881     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
1882     if existing["code"] == 200:
1883         modified = __salt__["bigip.modify_virtual"](
1884             hostname=hostname,
1885             username=username,
1886             password=password,
1887             name=name,
1888             destination=destination,
1889             description=description,
1890             pool=pool,
1891             address_status=address_status,
1892             auto_lasthop=auto_lasthop,
1893             bwc_policy=bwc_policy,
1894             cmp_enabled=cmp_enabled,
1895             connection_limit=connection_limit,
1896             dhcp_relay=dhcp_relay,
1897             fallback_persistence=fallback_persistence,
1898             flow_eviction_policy=flow_eviction_policy,
1899             gtm_score=gtm_score,
1900             ip_forward=ip_forward,
1901             ip_protocol=ip_protocol,
1902             internal=internal,
1903             twelve_forward=twelve_forward,
1904             last_hop_pool=last_hop_pool,
1905             mask=mask,
1906             mirror=mirror,
1907             nat64=nat64,
1908             persist=persist,
1909             profiles=profiles,
1910             policies=policies,
1911             rate_class=rate_class,
1912             rate_limit=rate_limit,
1913             rate_limit_mode=rate_limit_mode,
1914             rate_limit_dst=rate_limit_dst,
1915             rate_limit_src=rate_limit_src,
1916             rules=rules,
1917             related_rules=related_rules,
1918             reject=reject,
1919             source=source,
1920             source_address_translation=source_address_translation,
1921             source_port=source_port,
1922             state=virtual_state,
1923             traffic_classes=traffic_classes,
1924             translate_address=translate_address,
1925             translate_port=translate_port,
1926             vlans=vlans,
1927         )
1928         if modified["code"] == 200:
1929             relisting = __salt__["bigip.list_virtual"](
1930                 hostname, username, password, name
1931             )
1932             if relisting["code"] == 200:
1933                 relisting = _strip_key(relisting, "generation")
1934                 existing = _strip_key(existing, "generation")
1935                 ret = _check_for_changes("Virtual", ret, existing, relisting)
1936             else:
1937                 ret = _load_result(relisting, ret)
1938         else:
1939             ret = _load_result(modified, ret)
1940     elif existing["code"] == 404:
1941         virtual = __salt__["bigip.create_virtual"](
1942             hostname=hostname,
1943             username=username,
1944             password=password,
1945             name=name,
1946             destination=destination,
1947             description=description,
1948             pool=pool,
1949             address_status=address_status,
1950             auto_lasthop=auto_lasthop,
1951             bwc_policy=bwc_policy,
1952             cmp_enabled=cmp_enabled,
1953             connection_limit=connection_limit,
1954             dhcp_relay=dhcp_relay,
1955             fallback_persistence=fallback_persistence,
1956             flow_eviction_policy=flow_eviction_policy,
1957             gtm_score=gtm_score,
1958             ip_forward=ip_forward,
1959             ip_protocol=ip_protocol,
1960             internal=internal,
1961             twelve_forward=twelve_forward,
1962             last_hop_pool=last_hop_pool,
1963             mask=mask,
1964             mirror=mirror,
1965             nat64=nat64,
1966             persist=persist,
1967             profiles=profiles,
1968             policies=policies,
1969             rate_class=rate_class,
1970             rate_limit=rate_limit,
1971             rate_limit_mode=rate_limit_mode,
1972             rate_limit_dst=rate_limit_dst,
1973             rate_limit_src=rate_limit_src,
1974             rules=rules,
1975             related_rules=related_rules,
1976             reject=reject,
1977             source=source,
1978             source_address_translation=source_address_translation,
1979             source_port=source_port,
1980             state=virtual_state,
1981             traffic_classes=traffic_classes,
1982             translate_address=translate_address,
1983             translate_port=translate_port,
1984             vlans=vlans,
1985         )
1986         if virtual["code"] == 200:
1987             ret["result"] = True
1988             ret["changes"]["old"] = {}
1989             ret["changes"]["new"] = virtual["content"]
1990             ret[
1991                 "comment"
1992             ] = "Virtual was successfully created and enforced to the desired state."
1993         else:
1994             ret = _load_result(virtual, ret)
1995     else:
1996         ret = _load_result(existing, ret)
1997     return ret
1998 def modify_virtual(
1999     hostname,
2000     username,
2001     password,
2002     name,
2003     destination,
2004     pool=None,
2005     address_status=None,
2006     auto_lasthop=None,
2007     bwc_policy=None,
2008     cmp_enabled=None,
2009     connection_limit=None,
2010     dhcp_relay=None,
2011     description=None,
2012     fallback_persistence=None,
2013     flow_eviction_policy=None,
2014     gtm_score=None,
2015     ip_forward=None,
2016     ip_protocol=None,
2017     internal=None,
2018     twelve_forward=None,
2019     last_hop_pool=None,
2020     mask=None,
2021     mirror=None,
2022     nat64=None,
2023     persist=None,
2024     profiles=None,
2025     policies=None,
2026     rate_class=None,
2027     rate_limit=None,
2028     rate_limit_mode=None,
2029     rate_limit_dst=None,
2030     rate_limit_src=None,
2031     rules=None,
2032     related_rules=None,
2033     reject=None,
2034     source=None,
2035     source_address_translation=None,
2036     source_port=None,
2037     virtual_state=None,
2038     traffic_classes=None,
2039     translate_address=None,
2040     translate_port=None,
2041     vlans=None,
2042 ):
2043     """
2044     Modify an virtual server.  modify an existing virtual.  Only parameters specified will be enforced.
2045     hostname
2046         The host/address of the bigip device
2047     username
2048         The iControl REST username
2049     password
2050         The iControl REST password
2051     name
2052         The name of the virtual to create
2053     destination
2054         [ [virtual_address_name:port] | [ipv4:port] | [ipv6.port] ]
2055     pool
2056         [ [pool_name] | none]
2057     address_status
2058         [yes | no]
2059     auto_lasthop
2060         [default | enabled | disabled ]
2061     bwc_policy
2062         [none] | string]
2063     cmp_enabled
2064         [yes | no]
2065     dhcp_relay
2066         [yes | no}
2067     connection_limit
2068         [integer]
2069     description
2070         [string]
2071     state
2072         [disabled | enabled]
2073     fallback_persistence
2074         [none | [profile name] ]
2075     flow_eviction_policy
2076         [none | [eviction policy name] ]
2077     gtm_score
2078         [integer]
2079     ip_forward
2080         [yes | no]
2081     ip_protocol
2082         [any | protocol]
2083     internal
2084         [yes | no]
2085     twelve_forward(12-forward)
2086         [yes | no]
2087     last_hop-pool
2088         [ [pool_name] | none]
2089     mask
2090         { [ipv4] | [ipv6] }
2091     mirror
2092         { [disabled | enabled | none] }
2093     nat64
2094         [enabled | disabled]
2095     persist
2096         [list]
2097     profiles
2098         [none | default | list ]
2099     policies
2100         [none | default | list ]
2101     rate_class
2102         [name]
2103     rate_limit
2104         [integer]
2105     rate_limit-mode
2106         [destination | object | object-destination |
2107         object-source | object-source-destination |
2108         source | source-destination]
2109     rate_limit_dst
2110         [integer]
2111     rate_limit_src
2112         [integer]
2113     rules
2114         [none | list ]
2115     related_rules
2116         [none | list ]
2117     reject
2118         [yes | no]
2119     source
2120         { [ipv4[/prefixlen]] | [ipv6[/prefixlen]] }
2121     source_address_translation
2122         [none | snat:pool_name | lsn | automap | dictionary ]
2123     source_port
2124         [change | preserve | preserve-strict]
2125     state
2126         [enabled | disabled]
2127     traffic_classes
2128         [none | default | list ]
2129     translate_address
2130         [enabled | disabled]
2131     translate_port
2132         [enabled | disabled]
2133     vlans
2134         [none | default | dictionary ]
2135         vlan_ids
2136             [ list]
2137         enabled
2138             [ true | false ]
2139     """
2140     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2141     if __opts__["test"]:
2142         return _test_output(
2143             ret,
2144             "modify",
2145             params={
2146                 "hostname": hostname,
2147                 "username": username,
2148                 "password": password,
2149                 "name": name,
2150                 "destination": destination,
2151                 "pool": pool,
2152                 "address_status": address_status,
2153                 "auto_lasthop": auto_lasthop,
2154                 "bwc_policy": bwc_policy,
2155                 "cmp_enabled": cmp_enabled,
2156                 "connection_limit": connection_limit,
2157                 "dhcp_relay": dhcp_relay,
2158                 "description": description,
2159                 "fallback_persistence": fallback_persistence,
2160                 "flow_eviction_policy": flow_eviction_policy,
2161                 "gtm_score": gtm_score,
2162                 "ip_forward": ip_forward,
2163                 "ip_protocol": ip_protocol,
2164                 "internal": internal,
2165                 "twelve_forward": twelve_forward,
2166                 "last_hop_pool": last_hop_pool,
2167                 "mask": mask,
2168                 "mirror": mirror,
2169                 "nat64": nat64,
2170                 "persist": persist,
2171                 "profiles": profiles,
2172                 "policies": policies,
2173                 "rate_class": rate_class,
2174                 "rate_limit": rate_limit,
2175                 "rate_limit_mode": rate_limit_mode,
2176                 "rate_limit_dst": rate_limit_dst,
2177                 "rate_limit_src": rate_limit_src,
2178                 "rules": rules,
2179                 "related_rules": related_rules,
2180                 "reject": reject,
2181                 "source": source,
2182                 "source_address_translation": source_address_translation,
2183                 "source_port": source_port,
2184                 "virtual_state": virtual_state,
2185                 "traffic_classes": traffic_classes,
2186                 "translate_address": translate_address,
2187                 "translate_port": translate_port,
2188                 "vlans": vlans,
2189             },
2190         )
2191     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
2192     if existing["code"] == 200:
2193         modified = __salt__["bigip.modify_virtual"](
2194             hostname=hostname,
2195             username=username,
2196             password=password,
2197             name=name,
2198             destination=destination,
2199             description=description,
2200             pool=pool,
2201             address_status=address_status,
2202             auto_lasthop=auto_lasthop,
2203             bwc_policy=bwc_policy,
2204             cmp_enabled=cmp_enabled,
2205             connection_limit=connection_limit,
2206             dhcp_relay=dhcp_relay,
2207             fallback_persistence=fallback_persistence,
2208             flow_eviction_policy=flow_eviction_policy,
2209             gtm_score=gtm_score,
2210             ip_forward=ip_forward,
2211             ip_protocol=ip_protocol,
2212             internal=internal,
2213             twelve_forward=twelve_forward,
2214             last_hop_pool=last_hop_pool,
2215             mask=mask,
2216             mirror=mirror,
2217             nat64=nat64,
2218             persist=persist,
2219             profiles=profiles,
2220             policies=policies,
2221             rate_class=rate_class,
2222             rate_limit=rate_limit,
2223             rate_limit_mode=rate_limit_mode,
2224             rate_limit_dst=rate_limit_dst,
2225             rate_limit_src=rate_limit_src,
2226             rules=rules,
2227             related_rules=related_rules,
2228             reject=reject,
2229             source=source,
2230             source_address_translation=source_address_translation,
2231             source_port=source_port,
2232             state=virtual_state,
2233             traffic_classes=traffic_classes,
2234             translate_address=translate_address,
2235             translate_port=translate_port,
2236             vlans=vlans,
2237         )
2238         if modified["code"] == 200:
2239             relisting = __salt__["bigip.list_virtual"](
2240                 hostname, username, password, name
2241             )
2242             if relisting["code"] == 200:
2243                 relisting = _strip_key(relisting, "generation")
2244                 existing = _strip_key(existing, "generation")
2245                 ret = _check_for_changes("Virtual", ret, existing, relisting)
2246             else:
2247                 ret = _load_result(relisting, ret)
2248         else:
2249             ret = _load_result(modified, ret)
2250     elif existing["code"] == 404:
2251         ret["comment"] = "A Virtual with this name was not found."
2252     else:
2253         ret = _load_result(existing, ret)
2254     return ret
2255 def delete_virtual(hostname, username, password, name):
2256     """
2257     Delete an existing virtual.
2258     hostname
2259         The host/address of the bigip device
2260     username
2261         The iControl REST username
2262     password
2263         The iControl REST password
2264     name
2265         The name of the virtual which will be deleted
2266     """
2267     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2268     if __opts__["test"]:
2269         return _test_output(
2270             ret,
2271             "delete",
2272             params={
2273                 "hostname": hostname,
2274                 "username": username,
2275                 "password": password,
2276                 "name": name,
2277             },
2278         )
2279     existing = __salt__["bigip.list_virtual"](hostname, username, password, name)
2280     if existing["code"] == 200:
2281         deleted = __salt__["bigip.delete_virtual"](hostname, username, password, name)
2282         if deleted["code"] == 200:
2283             ret["result"] = True
2284             ret["comment"] = "Virtual was successfully deleted."
2285             ret["changes"]["old"] = existing["content"]
2286             ret["changes"]["new"] = {}
2287         else:
2288             ret = _load_result(deleted, ret)
2289     elif existing["code"] == 404:
2290         ret["result"] = True
2291         ret["comment"] = "This virtual already does not exist. No changes made."
2292         ret["changes"]["old"] = {}
2293         ret["changes"]["new"] = {}
2294     else:
2295         ret = _load_result(existing, ret)
2296     return ret
2297 def list_monitor(hostname, username, password, monitor_type, name):
2298     """
2299     A function to list an existing monitor.
2300     hostname
2301         The host/address of the bigip device
2302     username
2303         The iControl REST username
2304     password
2305         The iControl REST password
2306     monitor_type
2307         The type of monitor to list
2308     name
2309         The name of the monitor to list
2310     """
2311     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2312     if __opts__["test"]:
2313         return _test_output(
2314             ret,
2315             "list",
2316             params={
2317                 "hostname": hostname,
2318                 "username": username,
2319                 "password": password,
2320                 "monitor_type": monitor_type,
2321                 "name": name,
2322             },
2323         )
2324     response = __salt__["bigip.list_monitor"](
2325         hostname, username, password, monitor_type, name
2326     )
2327     return _load_result(response, ret)
2328 def create_monitor(hostname, username, password, monitor_type, name, **kwargs):
2329     """
2330     A function to connect to a bigip device and create a monitor.
2331     hostname
2332         The host/address of the bigip device
2333     username
2334         The iControl REST username
2335     password
2336         The iControl REST password
2337     monitor_type
2338         The type of monitor to create
2339     name
2340         The name of the monitor to create
2341     kwargs
2342         [ arg=val ] ...
2343         Consult F5 BIGIP user guide for specific options for each monitor type.
2344         Typically, tmsh arg names are used.
2345     """
2346     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2347     if __opts__["test"]:
2348         params = {
2349             "hostname": hostname,
2350             "username": username,
2351             "password": password,
2352             "monitor_type": monitor_type,
2353             "name": name,
2354         }
2355         for key, value in kwargs.items():
2356             params[key] = value
2357         return _test_output(ret, "create", params)
2358     existing = __salt__["bigip.list_monitor"](
2359         hostname, username, password, monitor_type, name
2360     )
2361     if existing["code"] == 200:
2362         ret["result"] = True
2363         ret["comment"] = "A monitor by this name currently exists.  No change made."
2364     elif existing["code"] == 404:
2365         response = __salt__["bigip.create_monitor"](
2366             hostname, username, password, monitor_type, name, **kwargs
2367         )
2368         if response["code"] == 200:
2369             ret["result"] = True
2370             ret["changes"]["old"] = {}
2371             ret["changes"]["new"] = response["content"]
2372             ret["comment"] = "Monitor was successfully created."
2373         else:
2374             ret = _load_result(response, ret)
2375     else:
2376         ret = _load_result(existing, ret)
2377     return ret
2378 def manage_monitor(hostname, username, password, monitor_type, name, **kwargs):
2379     """
2380     Create a new monitor if a monitor of this type and name does not already exists.  If it does exists, only
2381     the parameters specified will be enforced.
2382     hostname
2383         The host/address of the bigip device
2384     username
2385         The iControl REST username
2386     password
2387         The iControl REST password
2388     monitor_type
2389         The type of monitor to create
2390     name
2391         The name of the monitor to create
2392     kwargs
2393         [ arg=val ] ...
2394         Consult F5 BIGIP user guide for specific options for each monitor type.
2395         Typically, tmsh arg names are used.
2396     """
2397     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2398     if __opts__["test"]:
2399         params = {
2400             "hostname": hostname,
2401             "username": username,
2402             "password": password,
2403             "monitor_type": monitor_type,
2404             "name": name,
2405         }
2406         for key, value in kwargs.items():
2407             params[key] = value
2408         return _test_output(ret, "manage", params)
2409     existing = __salt__["bigip.list_monitor"](
2410         hostname, username, password, monitor_type, name
2411     )
2412     if existing["code"] == 200:
2413         modified = __salt__["bigip.modify_monitor"](
2414             hostname, username, password, monitor_type, name, **kwargs
2415         )
2416         if modified["code"] == 200:
2417             del existing["content"]["selfLink"]
2418             del modified["content"]["selfLink"]
2419             ret = _check_for_changes("Monitor", ret, existing, modified)
2420         else:
2421             ret = _load_result(modified, ret)
2422     elif existing["code"] == 404:
2423         response = __salt__["bigip.create_monitor"](
2424             hostname, username, password, monitor_type, name, **kwargs
2425         )
2426         if response["code"] == 200:
2427             ret["result"] = True
2428             ret["changes"]["old"] = {}
2429             ret["changes"]["new"] = response["content"]
2430             ret["comment"] = "Monitor was successfully created."
2431         else:
2432             ret = _load_result(response, ret)
2433     else:
2434         ret = _load_result(existing, ret)
2435     return ret
2436 def modify_monitor(hostname, username, password, monitor_type, name, **kwargs):
2437     """
2438     Modify an existing monitor.  If it does exists, only
2439     the parameters specified will be enforced.
2440     hostname
2441         The host/address of the bigip device
2442     username
2443         The iControl REST username
2444     password
2445         The iControl REST password
2446     monitor_type
2447         The type of monitor to create
2448     name
2449         The name of the monitor to create
2450     kwargs
2451         [ arg=val ] ...
2452         Consult F5 BIGIP user guide for specific options for each monitor type.
2453         Typically, tmsh arg names are used.
2454     """
2455     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2456     if __opts__["test"]:
2457         params = {
2458             "hostname": hostname,
2459             "username": username,
2460             "password": password,
2461             "monitor_type": monitor_type,
2462             "name": name,
2463         }
2464         for key, value in kwargs.items():
2465             params[key] = value
2466         return _test_output(ret, "modify", params)
2467     existing = __salt__["bigip.list_monitor"](
2468         hostname, username, password, monitor_type, name
2469     )
2470     if existing["code"] == 200:
2471         modified = __salt__["bigip.modify_monitor"](
2472             hostname, username, password, monitor_type, name, **kwargs
2473         )
2474         if modified["code"] == 200:
2475             del existing["content"]["selfLink"]
2476             del modified["content"]["selfLink"]
2477             ret = _check_for_changes("Monitor", ret, existing, modified)
2478         else:
2479             ret = _load_result(modified, ret)
2480     elif existing["code"] == 404:
2481         ret["comment"] = "A Monitor with this name was not found."
2482     else:
2483         ret = _load_result(existing, ret)
2484     return ret
2485 def delete_monitor(hostname, username, password, monitor_type, name):
2486     """
2487     Modify an existing monitor.  If it does exists, only
2488     the parameters specified will be enforced.
2489     hostname
2490         The host/address of the bigip device
2491     username
2492         The iControl REST username
2493     password
2494         The iControl REST password
2495     monitor_type
2496         The type of monitor to create
2497     name
2498         The name of the monitor to create
2499     kwargs
2500         [ arg=val ] ...
2501         Consult F5 BIGIP user guide for specific options for each monitor type.
2502         Typically, tmsh arg names are used.
2503     """
2504     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2505     if __opts__["test"]:
2506         return _test_output(
2507             ret,
2508             "delete",
2509             params={
2510                 "hostname": hostname,
2511                 "username": username,
2512                 "password": password,
2513                 "monitor_type": monitor_type,
2514                 "name": name,
2515             },
2516         )
2517     existing = __salt__["bigip.list_monitor"](
2518         hostname, username, password, monitor_type, name
2519     )
2520     if existing["code"] == 200:
2521         deleted = __salt__["bigip.delete_monitor"](
2522             hostname, username, password, monitor_type, name
2523         )
2524         if deleted["code"] == 200:
2525             ret["result"] = True
2526             ret["comment"] = "Monitor was successfully deleted."
2527             ret["changes"]["old"] = existing["content"]
2528             ret["changes"]["new"] = {}
2529         else:
2530             ret = _load_result(deleted, ret)
2531     elif existing["code"] == 404:
2532         ret["result"] = True
2533         ret["comment"] = "This Monitor already does not exist. No changes made."
2534         ret["changes"]["old"] = {}
2535         ret["changes"]["new"] = {}
2536     else:
2537         ret = _load_result(existing, ret)
2538     return ret
2539 def list_profile(hostname, username, password, profile_type, name):
2540     """
2541     A function to list an existing profile.
2542     hostname
2543         The host/address of the bigip device
2544     username
2545         The iControl REST username
2546     password
2547         The iControl REST password
2548     profile_type
2549         The type of profile to list
2550     name
2551         The name of the profile to list
2552     """
2553     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2554     if __opts__["test"]:
2555         return _test_output(
2556             ret,
2557             "list",
2558             params={
2559                 "hostname": hostname,
2560                 "username": username,
2561                 "password": password,
2562                 "profile_type": profile_type,
2563                 "name": name,
2564             },
2565         )
2566     response = __salt__["bigip.list_profile"](
2567         hostname, username, password, profile_type, name
2568     )
2569     return _load_result(response, ret)
2570 def create_profile(hostname, username, password, profile_type, name, **kwargs):
2571     r"""
2572     A function to connect to a bigip device and create a profile.
2573     hostname
2574         The host/address of the bigip device
2575     username
2576         The iControl REST username
2577     password
2578         The iControl REST password
2579     profile_type
2580         The type of profile to create
2581     name
2582         The name of the profile to create
2583     kwargs
2584         [ arg=val ] ...
2585         Consult F5 BIGIP user guide for specific options for each profile type.
2586         Typically, tmsh arg names are used.
2587     Special Characters ``|``, ``,`` and ``:`` must be escaped using ``\`` when
2588     used within strings.
2589     """
2590     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2591     if __opts__["test"]:
2592         return _test_output(
2593             ret,
2594             "create",
2595             params={
2596                 "hostname": hostname,
2597                 "username": username,
2598                 "password": password,
2599                 "profile_type": profile_type,
2600                 "name": name,
2601             },
2602         )
2603     existing = __salt__["bigip.list_profile"](
2604         hostname, username, password, profile_type, name
2605     )
2606     if existing["code"] == 200:
2607         ret["result"] = True
2608         ret["comment"] = "A profile by this name currently exists.  No change made."
2609     elif existing["code"] == 404:
2610         response = __salt__["bigip.create_profile"](
2611             hostname, username, password, profile_type, name, **kwargs
2612         )
2613         if response["code"] == 200:
2614             ret["result"] = True
2615             ret["changes"]["old"] = {}
2616             ret["changes"]["new"] = response["content"]
2617             ret["comment"] = "Profile was successfully created."
2618         else:
2619             ret = _load_result(response, ret)
2620     else:
2621         ret = _load_result(existing, ret)
2622     return ret
2623 def manage_profile(hostname, username, password, profile_type, name, **kwargs):
2624     """
2625     Create a new profile if a monitor of this type and name does not already exists.  If it does exists, only
2626     the parameters specified will be enforced.
2627     hostname
2628         The host/address of the bigip device
2629     username
2630         The iControl REST username
2631     password
2632         The iControl REST password
2633     profile_type
2634         The type of profile to create
2635     name
2636         The name of the profile to create
2637     kwargs
2638         [ arg=val ] ...
2639         Consult F5 BIGIP user guide for specific options for each profile type.
2640         Typically, tmsh arg names are used.
2641     """
2642     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2643     if __opts__["test"]:
2644         params = {
2645             "hostname": hostname,
2646             "username": username,
2647             "password": password,
2648             "profile_type": profile_type,
2649             "name": name,
2650         }
2651         for key, value in kwargs.items():
2652             params[key] = value
2653         return _test_output(ret, "manage", params)
2654     existing = __salt__["bigip.list_profile"](
2655         hostname, username, password, profile_type, name
2656     )
2657     if existing["code"] == 200:
2658         modified = __salt__["bigip.modify_profile"](
2659             hostname, username, password, profile_type, name, **kwargs
2660         )
2661         if modified["code"] == 200:
2662             del existing["content"]["selfLink"]
2663             del modified["content"]["selfLink"]
2664             ret = _check_for_changes("Profile", ret, existing, modified)
2665         else:
2666             ret = _load_result(modified, ret)
2667     elif existing["code"] == 404:
2668         response = __salt__["bigip.create_profile"](
2669             hostname, username, password, profile_type, name, **kwargs
2670         )
2671         if response["code"] == 200:
2672             ret["result"] = True
2673             ret["changes"]["old"] = {}
2674             ret["changes"]["new"] = response["content"]
2675             ret["comment"] = "Profile was successfully created."
2676         else:
2677             ret = _load_result(existing, ret)
2678     else:
2679         ret = _load_result(existing, ret)
2680     return ret
2681 def modify_profile(hostname, username, password, profile_type, name, **kwargs):
2682     """
2683     Modify an existing profile.  If it does exists, only
2684     the parameters specified will be enforced.
2685     hostname
2686         The host/address of the bigip device
2687     username
2688         The iControl REST username
2689     password
2690         The iControl REST password
2691     profile_type
2692         The type of profile to create
2693     name
2694         The name of the profile to create
2695     kwargs
2696         [ arg=val ] ...
2697         Consult F5 BIGIP user guide for specific options for each monitor type.
2698         Typically, tmsh arg names are used.
2699     """
2700     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2701     if __opts__["test"]:
2702         params = {
2703             "hostname": hostname,
2704             "username": username,
2705             "password": password,
2706             "profile_type": profile_type,
2707             "name": name,
2708         }
2709         for key, value in kwargs.items():
2710             params[key] = value
2711         return _test_output(ret, "modify", params)
2712     existing = __salt__["bigip.list_profile"](
2713         hostname, username, password, profile_type, name
2714     )
2715     if existing["code"] == 200:
2716         modified = __salt__["bigip.modify_profile"](
2717             hostname, username, password, profile_type, name, **kwargs
2718         )
2719         if modified["code"] == 200:
2720             del existing["content"]["selfLink"]
2721             del modified["content"]["selfLink"]
2722             ret = _check_for_changes("Profile", ret, existing, modified)
2723         else:
2724             ret = _load_result(modified, ret)
2725     elif existing["code"] == 404:
2726         ret["comment"] = "A Profile with this name was not found."
2727     else:
2728         ret = _load_result(existing, ret)
2729     return ret
2730 def delete_profile(hostname, username, password, profile_type, name):
2731     """
2732     Modify an existing profile.  If it does exists, only
2733     the parameters specified will be enforced.
2734     hostname
2735         The host/address of the bigip device
2736     username
2737         The iControl REST username
2738     password
2739         The iControl REST password
2740     profile_type
2741         The type of profile to create
2742     name
2743         The name of the profile to create
2744     kwargs
2745         [ arg=val ] ...
2746         Consult F5 BIGIP user guide for specific options for each profile type.
2747         Typically, tmsh arg names are used.
2748     """
2749     ret = {"name": name, "changes": {}, "result": False, "comment": ""}
2750     if __opts__["test"]:
2751         return _test_output(
2752             ret,
2753             "delete",
2754             params={
2755                 "hostname": hostname,
2756                 "username": username,
2757                 "password": password,
2758                 "profile_type": profile_type,
2759                 "name": name,
2760             },
2761         )
2762     existing = __salt__["bigip.list_profile"](
2763         hostname, username, password, profile_type, name
2764     )
2765     if existing["code"] == 200:
2766         deleted = __salt__["bigip.delete_profile"](
2767             hostname, username, password, profile_type, name
2768         )
2769         if deleted["code"] == 200:
2770             ret["result"] = True
2771             ret["comment"] = "Profile was successfully deleted."
2772             ret["changes"]["old"] = existing["content"]
2773             ret["changes"]["new"] = {}
2774         else:
2775             ret = _load_result(deleted, ret)
2776     elif existing["code"] == 404:
2777         ret["result"] = True
2778         ret["comment"] = "This Profile already does not exist. No changes made."
2779         ret["changes"]["old"] = {}
2780         ret["changes"]["new"] = {}
2781     else:
2782         ret = _load_result(existing, ret)
2783     return ret
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
