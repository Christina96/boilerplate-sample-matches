<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_dnsutil.py &amp; test_virt_1.py</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_dnsutil.py &amp; test_virt_1.py
      </h3>
<h1 align="center">
        0.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_dnsutil.py (9.090909%)<th>test_virt_1.py (0.14287415%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(111-115)<td><a href="#" name="0">(4648-4653)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_dnsutil.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import logging
2 import salt.modules.dnsutil as dnsutil
3 import salt.utils.stringutils
4 from tests.support.mock import MagicMock, mock_open, patch
5 from tests.support.unit import TestCase, skipIf
6 log = logging.getLogger(__name__)
7 mock_hosts_file = salt.utils.stringutils.to_str(
8     "##\n"
9     "# Host Database\n"
10     "#\n"
11     "# localhost is used to configure the loopback interface\n"
12     "# when the system is booting.  Do not change this entry.\n"
13     "##\n"
14     "127.0.0.1	localhost\n"
15     "255.255.255.255	broadcasthost\n"
16     "::1             localhost\n"
17     "fe80::1%lo0	localhost"
18 )
19 mock_hosts_file_rtn = {
20     "::1": ["localhost"],
21     "255.255.255.255": ["broadcasthost"],
22     "127.0.0.1": ["localhost"],
23     "fe80::1%lo0": ["localhost"],
24 }
25 mock_soa_zone = salt.utils.stringutils.to_str(
26     "$TTL 3D\n"
27     "@               IN      SOA     land-5.com. root.land-5.com. (\n"
28     "199609203       ; Serial\n"
29     "28800   ; Refresh\n"
30     "7200    ; Retry\n"
31     "604800  ; Expire\n"
32     "86400)  ; Minimum TTL\n"
33     "NS      land-5.com.\n\n"
34     "1                       PTR     localhost."
35 )
36 mock_writes_list = salt.utils.data.decode(
37     [
38         "##\n",
39         "# Host Database\n",
40         "#\n",
41         "# localhost is used to configure the loopback interface\n",
42         "# when the system is booting.  Do not change this entry.\n",
43         "##\n",
44         "127.0.0.1 localhost",
45         "\n",
46         "255.255.255.255 broadcasthost",
47         "\n",
48         "::1 localhost",
49         "\n",
50         "fe80::1%lo0 localhost",
51         "\n",
52     ],
53     to_str=True,
54 )
55 class DNSUtilTestCase(TestCase):
56     def test_parse_hosts(self):
57         with patch("salt.utils.files.fopen", mock_open(read_data=mock_hosts_file)):
58             self.assertEqual(
59                 dnsutil.parse_hosts(),
60                 {
61                     "::1": ["localhost"],
62                     "255.255.255.255": ["broadcasthost"],
63                     "127.0.0.1": ["localhost"],
64                     "fe80::1%lo0": ["localhost"],
65                 },
66             )
67     def test_hosts_append(self):
68         with patch(
69             "salt.utils.files.fopen", mock_open(read_data=mock_hosts_file)
70         ) as m_open, patch(
71             "salt.modules.dnsutil.parse_hosts",
72             MagicMock(return_value=mock_hosts_file_rtn),
73         ):
74             dnsutil.hosts_append("/etc/hosts", "127.0.0.1", "ad1.yuk.co,ad2.yuk.co")
75             writes = m_open.write_calls()
76             num_writes = len(writes)
77             assert num_writes == 1, num_writes
78             expected = salt.utils.stringutils.to_str(
79                 "\n127.0.0.1 ad1.yuk.co ad2.yuk.co"
80             )
81             assert writes[0] == expected, writes[0]
82     def test_hosts_remove(self):
83         to_remove = "ad1.yuk.co"
84         new_mock_file = mock_hosts_file + "\n127.0.0.1 " + to_remove + "\n"
85         with patch(
86             "salt.utils.files.fopen", mock_open(read_data=new_mock_file)
87         ) as m_open:
88             dnsutil.hosts_remove("/etc/hosts", to_remove)
89             writes = m_open.write_calls()
90             assert writes == mock_writes_list, writes
91     @skipIf(True, "Waiting on bug report fixes")
92     def test_parse_zone(self):
93         with patch("salt.utils.files.fopen", mock_open<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>(read_data=mock_soa_zone)):
94             log.debug(mock_soa_zone)
95             log.debug(dnsutil.parse_zone("/var/lib/named/example.com.zone"))
96     def</b></font> test_to_seconds_hour(self):
97         self.assertEqual(
98             dnsutil._to_seconds("4H"),
99             14400,
100             msg="Did not detect valid hours as invalid",
101         )
102     def test_to_seconds_day(self):
103         self.assertEqual(
104             dnsutil._to_seconds("1D"), 86400, msg="Did not detect valid day as invalid"
105         )
106     def test_to_seconds_week(self):
107         self.assertEqual(
108             dnsutil._to_seconds("2W"),
109             604800,
110             msg="Did not set time greater than one week to one week",
111         )
112     def test_to_seconds_empty(self):
113         self.assertEqual(
114             dnsutil._to_seconds(""), 604800, msg="Did not set empty time to one week"
115         )
116     def test_to_seconds_large(self):
117         self.assertEqual(
118             dnsutil._to_seconds("604801"),
119             604800,
120             msg="Did not set time greater than one week to one week",
121         )
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_virt_1.py</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 import datetime
2 import os
3 import shutil
4 import tempfile
5 import xml.etree.ElementTree as ET
6 import salt.config
7 import salt.modules.config as config
8 import salt.modules.virt as virt
9 import salt.syspaths
10 import salt.utils.yaml
11 from salt.exceptions import CommandExecutionError, SaltInvocationError
12 from tests.support.helpers import dedent
13 from tests.support.mixins import LoaderModuleMockMixin
14 from tests.support.mock import MagicMock, patch
15 from tests.support.unit import TestCase
16 class LibvirtMock(MagicMock):  # pylint: disable=too-many-ancestors
17     class virDomain(MagicMock):
18     class libvirtError(Exception):
19         def __init__(self, msg):
20             super().__init__(msg)
21             self.msg = msg
22         def get_error_message(self):
23             return self.msg
24 class VirtTestCase(TestCase, LoaderModuleMockMixin):
25     def setup_loader_modules(self):
26         self.mock_libvirt = LibvirtMock()
27         self.mock_conn = MagicMock()
28         self.mock_conn.getStoragePoolCapabilities.return_value = (
29             "&lt;storagepoolCapabilities/&gt;"
30         )
31         self.mock_libvirt.openAuth.return_value = self.mock_conn
32         self.mock_popen = MagicMock()
33         self.addCleanup(delattr, self, "mock_libvirt")
34         self.addCleanup(delattr, self, "mock_conn")
35         self.addCleanup(delattr, self, "mock_popen")
36         self.mock_subprocess = MagicMock()
37         self.mock_subprocess.return_value = (
38             self.mock_subprocess
39         )  # pylint: disable=no-member
40         self.mock_subprocess.Popen.return_value = (
41             self.mock_popen
42         )  # pylint: disable=no-member
43         loader_globals = {
44             "__salt__": {"config.get": config.get, "config.option": config.option},
45             "libvirt": self.mock_libvirt,
46             "subprocess": self.mock_subprocess,
47         }
48         return {virt: loader_globals, config: loader_globals}
49     def set_mock_vm(self, name, xml):
50         self.mock_conn.listDefinedDomains.return_value = [
51             name
52         ]  # pylint: disable=no-member
53         mock_domain = self.mock_libvirt.virDomain()
54         self.mock_conn.lookupByName.return_value = (
55             mock_domain  # pylint: disable=no-member
56         )
57         mock_domain.XMLDesc.return_value = xml  # pylint: disable=no-member
58         mock_domain.info.return_value = [
59             4,
60             2048 * 1024,
61             1024 * 1024,
62             2,
63             1234,
64         ]  # pylint: disable=no-member
65         mock_domain.ID.return_value = 1
66         mock_domain.name.return_value = name
67         return mock_domain
68     def assert_equal_unit(self, actual, expected, unit="KiB"):
69         self.assertEqual(actual.get("unit"), unit)
70         self.assertEqual(actual.text, str(expected))
71     def test_disk_profile_merge(self):
72         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
73         userdisks = [
74             {"name": "system", "image": "/path/to/image"},
75             {"name": "data", "size": 16384, "format": "raw"},
76         ]
77         disks = virt._disk_profile(self.mock_conn, "default", "kvm", userdisks, "myvm")
78         self.assertEqual(
79             [
80                 {
81                     "name": "system",
82                     "device": "disk",
83                     "size": 8192,
84                     "format": "qcow2",
85                     "model": "virtio",
86                     "filename": "myvm_system.qcow2",
87                     "image": "/path/to/image",
88                     "source_file": "{}{}myvm_system.qcow2".format(root_dir, os.sep),
89                 },
90                 {
91                     "name": "data",
92                     "device": "disk",
93                     "size": 16384,
94                     "format": "raw",
95                     "model": "virtio",
96                     "filename": "myvm_data.raw",
97                     "source_file": "{}{}myvm_data.raw".format(root_dir, os.sep),
98                 },
99             ],
100             disks,
101         )
102     def test_boot_default_dev(self):
103         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
104         nicp = virt._nic_profile("default", "kvm")
105         xml_data = virt._gen_xml(
106             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
107         )
108         root = ET.fromstring(xml_data)
109         self.assertEqual(root.find("os/boot").attrib["dev"], "hd")
110         self.assertEqual(root.find("os/type").attrib["arch"], "x86_64")
111         self.assertEqual(root.find("os/type").text, "hvm")
112     def test_boot_custom_dev(self):
113         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
114         nicp = virt._nic_profile("default", "kvm")
115         xml_data = virt._gen_xml(
116             self.mock_conn,
117             "hello",
118             1,
119             512,
120             diskp,
121             nicp,
122             "kvm",
123             "hvm",
124             "x86_64",
125             boot_dev="cdrom",
126         )
127         root = ET.fromstring(xml_data)
128         self.assertEqual(root.find("os/boot").attrib["dev"], "cdrom")
129     def test_boot_multiple_devs(self):
130         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
131         nicp = virt._nic_profile("default", "kvm")
132         xml_data = virt._gen_xml(
133             self.mock_conn,
134             "hello",
135             1,
136             512,
137             diskp,
138             nicp,
139             "kvm",
140             "hvm",
141             "x86_64",
142             boot_dev="cdrom network",
143         )
144         root = ET.fromstring(xml_data)
145         devs = root.findall(".//boot")
146         self.assertTrue(len(devs) == 2)
147     def test_gen_xml_no_nic(self):
148         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
149         nicp = virt._nic_profile("default", "kvm")
150         xml_data = virt._gen_xml(
151             self.mock_conn,
152             "hello",
153             1,
154             512,
155             diskp,
156             nicp,
157             "kvm",
158             "hvm",
159             "x86_64",
160             serials=[{"type": "pty"}],
161         )
162         root = ET.fromstring(xml_data)
163         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
164     def test_gen_xml_for_telnet_serial(self):
165         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
166         nicp = virt._nic_profile("default", "kvm")
167         xml_data = virt._gen_xml(
168             self.mock_conn,
169             "hello",
170             1,
171             512,
172             diskp,
173             nicp,
174             "kvm",
175             "hvm",
176             "x86_64",
177             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
178         )
179         root = ET.fromstring(xml_data)
180         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
181         self.assertEqual(root.find("devices/serial/source").attrib["service"], "22223")
182         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
183     def test_gen_xml_for_telnet_serial_unspecified_port(self):
184         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
185         nicp = virt._nic_profile("default", "kvm")
186         xml_data = virt._gen_xml(
187             self.mock_conn,
188             "hello",
189             1,
190             512,
191             diskp,
192             nicp,
193             "kvm",
194             "hvm",
195             "x86_64",
196             serials=[{"type": "tcp"}],
197         )
198         root = ET.fromstring(xml_data)
199         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
200         self.assertEqual(root.find("devices/serial/source").attrib["service"], "23023")
201         self.assertFalse("tls" in root.find("devices/serial/source").keys())
202         self.assertEqual(root.find("devices/serial/protocol").attrib["type"], "telnet")
203     def test_gen_xml_for_chardev_types(self):
204         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
205         nicp = virt._nic_profile("default", "kvm")
206         xml_data = virt._gen_xml(
207             self.mock_conn,
208             "hello",
209             1,
210             512,
211             diskp,
212             nicp,
213             "kvm",
214             "hvm",
215             "x86_64",
216             consoles=[
217                 {"type": "pty", "path": "/dev/pts/2", "target_port": 2},
218                 {"type": "pty", "target_type": "usb-serial"},
219                 {"type": "stdio"},
220                 {"type": "file", "path": "/path/to/serial.log"},
221             ],
222             serials=[
223                 {"type": "pipe", "path": "/tmp/mypipe"},
224                 {"type": "udp", "host": "127.0.0.1", "port": 1234},
225                 {"type": "tcp", "port": 22223, "protocol": "raw", "tls": True},
226                 {"type": "unix", "path": "/path/to/socket"},
227             ],
228         )
229         root = ET.fromstring(xml_data)
230         self.assertEqual(root.find("devices/console[1]").attrib["type"], "pty")
231         self.assertEqual(
232             root.find("devices/console[1]/source").attrib["path"], "/dev/pts/2"
233         )
234         self.assertEqual(root.find("devices/console[1]/target").attrib["port"], "2")
235         self.assertEqual(root.find("devices/console[2]").attrib["type"], "pty")
236         self.assertIsNone(root.find("devices/console[2]/source"))
237         self.assertEqual(
238             root.find("devices/console[2]/target").attrib["type"], "usb-serial"
239         )
240         self.assertEqual(root.find("devices/console[3]").attrib["type"], "stdio")
241         self.assertIsNone(root.find("devices/console[3]/source"))
242         self.assertEqual(root.find("devices/console[4]").attrib["type"], "file")
243         self.assertEqual(
244             root.find("devices/console[4]/source").attrib["path"], "/path/to/serial.log"
245         )
246         self.assertEqual(root.find("devices/serial[1]").attrib["type"], "pipe")
247         self.assertEqual(
248             root.find("devices/serial[1]/source").attrib["path"], "/tmp/mypipe"
249         )
250         self.assertEqual(root.find("devices/serial[2]").attrib["type"], "udp")
251         self.assertEqual(root.find("devices/serial[2]/source").attrib["mode"], "bind")
252         self.assertEqual(
253             root.find("devices/serial[2]/source").attrib["service"], "1234"
254         )
255         self.assertEqual(
256             root.find("devices/serial[2]/source").attrib["host"], "127.0.0.1"
257         )
258         self.assertEqual(root.find("devices/serial[3]").attrib["type"], "tcp")
259         self.assertEqual(root.find("devices/serial[3]/source").attrib["mode"], "bind")
260         self.assertEqual(
261             root.find("devices/serial[3]/source").attrib["service"], "22223"
262         )
263         self.assertEqual(root.find("devices/serial[3]/source").attrib["tls"], "yes")
264         self.assertEqual(root.find("devices/serial[3]/protocol").attrib["type"], "raw")
265         self.assertEqual(root.find("devices/serial[4]").attrib["type"], "unix")
266         self.assertEqual(
267             root.find("devices/serial[4]/source").attrib["path"], "/path/to/socket"
268         )
269     def test_gen_xml_no_nic_console(self):
270         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
271         nicp = virt._nic_profile("default", "kvm")
272         xml_data = virt._gen_xml(
273             self.mock_conn,
274             "hello",
275             1,
276             512,
277             diskp,
278             nicp,
279             "kvm",
280             "hvm",
281             "x86_64",
282             consoles=[{"type": "pty"}],
283         )
284         root = ET.fromstring(xml_data)
285         self.assertEqual(root.find("devices/console").attrib["type"], "pty")
286     def test_gen_xml_for_telnet_console(self):
287         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
288         nicp = virt._nic_profile("default", "kvm")
289         xml_data = virt._gen_xml(
290             self.mock_conn,
291             "hello",
292             1,
293             512,
294             diskp,
295             nicp,
296             "kvm",
297             "hvm",
298             "x86_64",
299             consoles=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
300         )
301         root = ET.fromstring(xml_data)
302         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
303         self.assertEqual(root.find("devices/console/source").attrib["service"], "22223")
304         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
305     def test_gen_xml_for_telnet_console_unspecified_port(self):
306         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
307         nicp = virt._nic_profile("default", "kvm")
308         xml_data = virt._gen_xml(
309             self.mock_conn,
310             "hello",
311             1,
312             512,
313             diskp,
314             nicp,
315             "kvm",
316             "hvm",
317             "x86_64",
318             consoles=[{"type": "tcp"}],
319         )
320         root = ET.fromstring(xml_data)
321         self.assertEqual(root.find("devices/console").attrib["type"], "tcp")
322         self.assertEqual(root.find("devices/console/source").attrib["service"], "23023")
323         self.assertEqual(root.find("devices/console/protocol").attrib["type"], "telnet")
324     def test_gen_xml_for_serial_no_console(self):
325         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
326         nicp = virt._nic_profile("default", "kvm")
327         xml_data = virt._gen_xml(
328             self.mock_conn,
329             "hello",
330             1,
331             512,
332             diskp,
333             nicp,
334             "kvm",
335             "hvm",
336             "x86_64",
337             serials=[{"type": "pty"}],
338             consoles=[],
339         )
340         root = ET.fromstring(xml_data)
341         self.assertEqual(root.find("devices/serial").attrib["type"], "pty")
342         self.assertEqual(root.find("devices/console"), None)
343     def test_gen_xml_for_telnet_no_console(self):
344         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
345         nicp = virt._nic_profile("default", "kvm")
346         xml_data = virt._gen_xml(
347             self.mock_conn,
348             "hello",
349             1,
350             512,
351             diskp,
352             nicp,
353             "kvm",
354             "hvm",
355             "x86_64",
356             serials=[{"type": "tcp", "port": 22223, "protocol": "telnet"}],
357             consoles=[],
358         )
359         root = ET.fromstring(xml_data)
360         self.assertEqual(root.find("devices/serial").attrib["type"], "tcp")
361         self.assertEqual(root.find("devices/console"), None)
362     def test_gen_xml_nographics_default(self):
363         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
364         nicp = virt._nic_profile("default", "kvm")
365         xml_data = virt._gen_xml(
366             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
367         )
368         root = ET.fromstring(xml_data)
369         self.assertIsNone(root.find("devices/graphics"))
370     def test_gen_xml_noloader_default(self):
371         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
372         nicp = virt._nic_profile("default", "kvm")
373         xml_data = virt._gen_xml(
374             self.mock_conn, "hello", 1, 512, diskp, nicp, "kvm", "hvm", "x86_64"
375         )
376         root = ET.fromstring(xml_data)
377         self.assertIsNone(root.find("os/loader"))
378     def test_gen_xml_vnc_default(self):
379         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
380         nicp = virt._nic_profile("default", "kvm")
381         xml_data = virt._gen_xml(
382             self.mock_conn,
383             "hello",
384             1,
385             512,
386             diskp,
387             nicp,
388             "kvm",
389             "hvm",
390             "x86_64",
391             graphics={
392                 "type": "vnc",
393                 "port": 1234,
394                 "tlsPort": 5678,
395                 "listen": {"type": "address", "address": "myhost"},
396             },
397         )
398         root = ET.fromstring(xml_data)
399         self.assertEqual(root.find("devices/graphics").attrib["type"], "vnc")
400         self.assertEqual(root.find("devices/graphics").attrib["autoport"], "no")
401         self.assertEqual(root.find("devices/graphics").attrib["port"], "1234")
402         self.assertFalse("tlsPort" in root.find("devices/graphics").attrib)
403         self.assertEqual(root.find("devices/graphics").attrib["listen"], "myhost")
404         self.assertEqual(root.find("devices/graphics/listen").attrib["type"], "address")
405         self.assertEqual(
406             root.find("devices/graphics/listen").attrib["address"], "myhost"
407         )
408     def test_gen_xml_memory(self):
409         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
410         nicp = virt._nic_profile("default", "kvm")
411         xml_data = virt._gen_xml(
412             self.mock_conn,
413             "hello",
414             1,
415             {
416                 "boot": "512m",
417                 "current": "256m",
418                 "max": "1g",
419                 "hard_limit": "1024",
420                 "soft_limit": "512m",
421                 "swap_hard_limit": "1g",
422                 "min_guarantee": "256m",
423                 "hugepages": [
424                     {"size": "128m"},
425                     {"nodeset": "0", "size": "256m"},
426                     {"nodeset": "1", "size": "512m"},
427                 ],
428                 "nosharepages": True,
429                 "locked": True,
430                 "source": "file",
431                 "access": "shared",
432                 "allocation": "immediate",
433                 "discard": True,
434             },
435             diskp,
436             nicp,
437             "kvm",
438             "hvm",
439             "x86_64",
440         )
441         root = ET.fromstring(xml_data)
442         self.assert_equal_unit(root.find("memory"), 512 * 1024)
443         self.assert_equal_unit(root.find("currentMemory"), 256 * 1024)
444         self.assert_equal_unit(root.find("maxMemory"), 1024 * 1024)
445         self.assertFalse("slots" in root.find("maxMemory").keys())
446         self.assert_equal_unit(root.find("memtune/hard_limit"), 1024 * 1024)
447         self.assert_equal_unit(root.find("memtune/soft_limit"), 512 * 1024)
448         self.assert_equal_unit(root.find("memtune/swap_hard_limit"), 1024 ** 2)
449         self.assert_equal_unit(root.find("memtune/min_guarantee"), 256 * 1024)
450         self.assertEqual(
451             [
452                 {"nodeset": page.get("nodeset"), "size": page.get("size")}
453                 for page in root.findall("memoryBacking/hugepages/page")
454             ],
455             [
456                 {"nodeset": None, "size": str(128 * 1024)},
457                 {"nodeset": "0", "size": str(256 * 1024)},
458                 {"nodeset": "1", "size": str(512 * 1024)},
459             ],
460         )
461         self.assertIsNotNone(root.find("memoryBacking/nosharepages"))
462         self.assertIsNotNone(root.find("memoryBacking/locked"))
463         self.assertIsNotNone(root.find("memoryBacking/discard"))
464         self.assertEqual(root.find("memoryBacking/source").get("type"), "file")
465         self.assertEqual(root.find("memoryBacking/access").get("mode"), "shared")
466         self.assertEqual(root.find("memoryBacking/allocation").get("mode"), "immediate")
467     def test_gen_xml_cpu(self):
468         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
469         nicp = virt._nic_profile("default", "kvm")
470         xml_data = virt._gen_xml(
471             self.mock_conn,
472             "hello",
473             {
474                 "maximum": 12,
475                 "placement": "static",
476                 "cpuset": "0-11",
477                 "current": 5,
478                 "mode": "custom",
479                 "match": "minimum",
480                 "check": "full",
481                 "vendor": "Intel",
482                 "model": {
483                     "name": "core2duo",
484                     "fallback": "allow",
485                     "vendor_id": "GenuineIntel",
486                 },
487                 "cache": {"level": 3, "mode": "emulate"},
488                 "features": {"lahf": "optional", "vmx": "require"},
489                 "vcpus": {
490                     0: {"enabled": True, "hotpluggable": True},
491                     1: {"enabled": False},
492                 },
493             },
494             512,
495             diskp,
496             nicp,
497             "kvm",
498             "hvm",
499             "x86_64",
500         )
501         root = ET.fromstring(xml_data)
502         self.assertEqual(root.find("vcpu").get("current"), "5")
503         self.assertEqual(root.find("vcpu").get("placement"), "static")
504         self.assertEqual(root.find("vcpu").get("cpuset"), "0-11")
505         self.assertEqual(root.find("vcpu").text, "12")
506         self.assertEqual(root.find("cpu").get("match"), "minimum")
507         self.assertEqual(root.find("cpu").get("mode"), "custom")
508         self.assertEqual(root.find("cpu").get("check"), "full")
509         self.assertEqual(root.find("cpu/vendor").text, "Intel")
510         self.assertEqual(root.find("cpu/model").text, "core2duo")
511         self.assertEqual(root.find("cpu/model").get("fallback"), "allow")
512         self.assertEqual(root.find("cpu/model").get("vendor_id"), "GenuineIntel")
513         self.assertEqual(root.find("cpu/cache").get("level"), "3")
514         self.assertEqual(root.find("cpu/cache").get("mode"), "emulate")
515         self.assertEqual(
516             {f.get("name"): f.get("policy") for f in root.findall("cpu/feature")},
517             {"lahf": "optional", "vmx": "require"},
518         )
519         self.assertEqual(
520             {
521                 v.get("id"): {
522                     "enabled": v.get("enabled"),
523                     "hotpluggable": v.get("hotpluggable"),
524                 }
525                 for v in root.findall("vcpus/vcpu")
526             },
527             {
528                 "0": {"enabled": "yes", "hotpluggable": "yes"},
529                 "1": {"enabled": "no", "hotpluggable": None},
530             },
531         )
532     def test_gen_xml_cpu_topology(self):
533         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
534         nicp = virt._nic_profile("default", "kvm")
535         xml_data = virt._gen_xml(
536             self.mock_conn,
537             "hello",
538             {"maximum": 1, "topology": {"sockets": 4, "cores": 16, "threads": 2}},
539             512,
540             diskp,
541             nicp,
542             "kvm",
543             "hvm",
544             "x86_64",
545         )
546         root = ET.fromstring(xml_data)
547         self.assertEqual(root.find("cpu/topology").get("sockets"), "4")
548         self.assertEqual(root.find("cpu/topology").get("cores"), "16")
549         self.assertEqual(root.find("cpu/topology").get("threads"), "2")
550     def test_gen_xml_cpu_numa(self):
551         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
552         nicp = virt._nic_profile("default", "kvm")
553         xml_data = virt._gen_xml(
554             self.mock_conn,
555             "hello",
556             {
557                 "maximum": 1,
558                 "numa": {
559                     0: {
560                         "cpus": "0-3",
561                         "memory": "1g",
562                         "discard": True,
563                         "distances": {0: 10, 1: 20},
564                     },
565                     1: {"cpus": "4-7", "memory": "2g", "distances": {0: 20, 1: 10}},
566                 },
567             },
568             512,
569             diskp,
570             nicp,
571             "kvm",
572             "hvm",
573             "x86_64",
574         )
575         root = ET.fromstring(xml_data)
576         cell0 = root.find("cpu/numa/cell[@id='0']")
577         self.assertEqual(cell0.get("cpus"), "0-3")
578         self.assertIsNone(cell0.get("unit"))
579         self.assertEqual(cell0.get("memory"), str(1024 ** 2))
580         self.assertEqual(cell0.get("discard"), "yes")
581         self.assertEqual(
582             {d.get("id"): d.get("value") for d in cell0.findall("distances/sibling")},
583             {"0": "10", "1": "20"},
584         )
585         cell1 = root.find("cpu/numa/cell[@id='1']")
586         self.assertEqual(cell1.get("cpus"), "4-7")
587         self.assertIsNone(cell0.get("unit"))
588         self.assertEqual(cell1.get("memory"), str(2 * 1024 ** 2))
589         self.assertFalse("discard" in cell1.keys())
590         self.assertEqual(
591             {d.get("id"): d.get("value") for d in cell1.findall("distances/sibling")},
592             {"0": "20", "1": "10"},
593         )
594     def test_gen_xml_cputune(self):
595         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
596         nicp = virt._nic_profile("default", "kvm")
597         cputune = {
598             "shares": 2048,
599             "period": 122000,
600             "quota": -1,
601             "global_period": 1000000,
602             "global_quota": -3,
603             "emulator_period": 1200000,
604             "emulator_quota": -10,
605             "iothread_period": 133000,
606             "iothread_quota": -1,
607             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
608             "emulatorpin": "1-3",
609             "iothreadpin": {1: "5-6", 2: "7-8"},
610             "vcpusched": [
611                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
612                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
613                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
614             ],
615             "iothreadsched": [
616                 {"scheduler": "idle"},
617                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1},
618             ],
619             "emulatorsched": {"scheduler": "rr", "priority": 2},
620             "cachetune": {
621                 "0-3": {
622                     0: {"level": 3, "type": "both", "size": 3},
623                     1: {"level": 3, "type": "both", "size": 3},
624                     "monitor": {1: 3, "0-3": 3},
625                 },
626                 "4-5": {"monitor": {4: 3, 5: 2}},
627             },
628             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
629         }
630         xml_data = virt._gen_xml(
631             self.mock_conn,
632             "hello",
633             {"maximum": 1, "tuning": cputune, "iothreads": 2},
634             512,
635             diskp,
636             nicp,
637             "kvm",
638             "hvm",
639             "x86_64",
640         )
641         root = ET.fromstring(xml_data)
642         self.assertEqual(root.find("cputune").find("shares").text, "2048")
643         self.assertEqual(root.find("cputune").find("period").text, "122000")
644         self.assertEqual(root.find("cputune").find("quota").text, "-1")
645         self.assertEqual(root.find("cputune").find("global_period").text, "1000000")
646         self.assertEqual(root.find("cputune").find("global_quota").text, "-3")
647         self.assertEqual(root.find("cputune").find("emulator_period").text, "1200000")
648         self.assertEqual(root.find("cputune").find("emulator_quota").text, "-10")
649         self.assertEqual(root.find("cputune").find("iothread_period").text, "133000")
650         self.assertEqual(root.find("cputune").find("iothread_quota").text, "-1")
651         self.assertEqual(
652             root.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
653             "1-4,^2",
654         )
655         self.assertEqual(
656             root.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
657             "0,1",
658         )
659         self.assertEqual(
660             root.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
661             "2,3",
662         )
663         self.assertEqual(
664             root.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
665             "0,4",
666         )
667         self.assertEqual(
668             root.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1-3"
669         )
670         self.assertEqual(
671             root.find("cputune")
672             .find("iothreadpin[@iothread='1']")
673             .attrib.get("cpuset"),
674             "5-6",
675         )
676         self.assertEqual(
677             root.find("cputune")
678             .find("iothreadpin[@iothread='2']")
679             .attrib.get("cpuset"),
680             "7-8",
681         )
682         self.assertDictEqual(
683             {
684                 s.get("vcpus"): {
685                     "scheduler": s.get("scheduler"),
686                     "priority": s.get("priority"),
687                 }
688                 for s in root.findall("cputune/vcpusched")
689             },
690             {
691                 "0": {"scheduler": "fifo", "priority": "1"},
692                 "1": {"scheduler": "fifo", "priority": "2"},
693                 "2": {"scheduler": "idle", "priority": "3"},
694             },
695         )
696         self.assertDictEqual(
697             {
698                 s.get("iothreads"): {
699                     "scheduler": s.get("scheduler"),
700                     "priority": s.get("priority"),
701                 }
702                 for s in root.findall("cputune/iothreadsched")
703             },
704             {
705                 None: {"scheduler": "idle", "priority": None},
706                 "5-7": {"scheduler": "batch", "priority": "1"},
707             },
708         )
709         self.assertEqual(root.find("cputune/emulatorsched").get("scheduler"), "rr")
710         self.assertEqual(root.find("cputune/emulatorsched").get("priority"), "2")
711         self.assertEqual(
712             root.find("./cputune/cachetune[@vcpus='0-3']").attrib.get("vcpus"), "0-3"
713         )
714         self.assertEqual(
715             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
716                 "level"
717             ),
718             "3",
719         )
720         self.assertEqual(
721             root.find("./cputune/cachetune[@vcpus='0-3']/cache[@id='0']").attrib.get(
722                 "type"
723             ),
724             "both",
725         )
726         self.assertEqual(
727             root.find(
728                 "./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"
729             ).attrib.get("level"),
730             "3",
731         )
732         self.assertNotEqual(
733             root.find("./cputune/cachetune[@vcpus='0-3']/monitor[@vcpus='1']"), None
734         )
735         self.assertNotEqual(
736             root.find("./cputune/cachetune[@vcpus='4-5']").attrib.get("vcpus"), None
737         )
738         self.assertEqual(
739             root.find("./cputune/cachetune[@vcpus='4-5']/cache[@id='0']"), None
740         )
741         self.assertEqual(
742             root.find(
743                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='4']"
744             ).attrib.get("level"),
745             "3",
746         )
747         self.assertEqual(
748             root.find(
749                 "./cputune/cachetune[@vcpus='4-5']/monitor[@vcpus='5']"
750             ).attrib.get("level"),
751             "2",
752         )
753         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='0-2']"), None)
754         self.assertEqual(
755             root.find("./cputune/memorytune[@vcpus='0-2']/node[@id='0']").attrib.get(
756                 "bandwidth"
757             ),
758             "60",
759         )
760         self.assertNotEqual(root.find("./cputune/memorytune[@vcpus='3-4']"), None)
761         self.assertEqual(
762             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='0']").attrib.get(
763                 "bandwidth"
764             ),
765             "50",
766         )
767         self.assertEqual(
768             root.find("./cputune/memorytune[@vcpus='3-4']/node[@id='1']").attrib.get(
769                 "bandwidth"
770             ),
771             "70",
772         )
773         self.assertEqual(root.find("iothreads").text, "2")
774     def test_default_disk_profile_hypervisor_esxi(self):
775         mock = MagicMock(return_value={})
776         with patch.dict(
777             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
778         ):
779             ret = virt._disk_profile(
780                 self.mock_conn, "nonexistent", "vmware", None, "test-vm"
781             )
782             self.assertTrue(len(ret) == 1)
783             found = [disk for disk in ret if disk["name"] == "system"]
784             self.assertTrue(bool(found))
785             system = found[0]
786             self.assertEqual(system["format"], "vmdk")
787             self.assertEqual(system["model"], "scsi")
788             self.assertTrue(int(system["size"]) &gt;= 1)
789     def test_default_disk_profile_hypervisor_kvm(self):
790         mock = MagicMock(side_effect=[{}, "/images/dir"])
791         with patch.dict(
792             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
793         ):
794             ret = virt._disk_profile(
795                 self.mock_conn, "nonexistent", "kvm", None, "test-vm"
796             )
797             self.assertTrue(len(ret) == 1)
798             found = [disk for disk in ret if disk["name"] == "system"]
799             self.assertTrue(bool(found))
800             system = found[0]
801             self.assertEqual(system["format"], "qcow2")
802             self.assertEqual(system["model"], "virtio")
803             self.assertTrue(int(system["size"]) &gt;= 1)
804     def test_default_disk_profile_hypervisor_xen(self):
805         mock = MagicMock(side_effect=[{}, "/images/dir"])
806         with patch.dict(
807             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
808         ):
809             ret = virt._disk_profile(
810                 self.mock_conn, "nonexistent", "xen", None, "test-vm"
811             )
812             self.assertTrue(len(ret) == 1)
813             found = [disk for disk in ret if disk["name"] == "system"]
814             self.assertTrue(bool(found))
815             system = found[0]
816             self.assertEqual(system["format"], "qcow2")
817             self.assertEqual(system["model"], "xen")
818             self.assertTrue(int(system["size"]) &gt;= 1)
819     def test_default_nic_profile_hypervisor_esxi(self):
820         mock = MagicMock(return_value={})
821         with patch.dict(
822             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
823         ):
824             ret = virt._nic_profile("nonexistent", "vmware")
825             self.assertTrue(len(ret) == 1)
826             eth0 = ret[0]
827             self.assertEqual(eth0["name"], "eth0")
828             self.assertEqual(eth0["type"], "bridge")
829             self.assertEqual(eth0["source"], "DEFAULT")
830             self.assertEqual(eth0["model"], "e1000")
831     def test_default_nic_profile_hypervisor_kvm(self):
832         mock = MagicMock(return_value={})
833         with patch.dict(
834             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
835         ):
836             ret = virt._nic_profile("nonexistent", "kvm")
837             self.assertTrue(len(ret) == 1)
838             eth0 = ret[0]
839             self.assertEqual(eth0["name"], "eth0")
840             self.assertEqual(eth0["type"], "bridge")
841             self.assertEqual(eth0["source"], "br0")
842             self.assertEqual(eth0["model"], "virtio")
843     def test_default_nic_profile_hypervisor_xen(self):
844         mock = MagicMock(return_value={})
845         with patch.dict(
846             virt.__salt__, {"config.get": mock}  # pylint: disable=no-member
847         ):
848             ret = virt._nic_profile("nonexistent", "xen")
849             self.assertTrue(len(ret) == 1)
850             eth0 = ret[0]
851             self.assertEqual(eth0["name"], "eth0")
852             self.assertEqual(eth0["type"], "bridge")
853             self.assertEqual(eth0["source"], "br0")
854             self.assertFalse(eth0["model"])
855     def test_gen_vol_xml_esx(self):
856         xml_data = virt._gen_vol_xml("vmname/system.vmdk", 8192, format="vmdk")
857         root = ET.fromstring(xml_data)
858         self.assertIsNone(root.get("type"))
859         self.assertEqual(root.find("name").text, "vmname/system.vmdk")
860         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
861         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
862         self.assertEqual(root.find("allocation").text, str(0))
863         self.assertEqual(root.find("target/format").get("type"), "vmdk")
864         self.assertIsNone(root.find("target/permissions"))
865         self.assertIsNone(root.find("target/nocow"))
866         self.assertIsNone(root.find("backingStore"))
867     def test_gen_vol_xml_file(self):
868         xml_data = virt._gen_vol_xml(
869             "myvm_system.qcow2",
870             8192,
871             format="qcow2",
872             allocation=4096,
873             type="file",
874             permissions={
875                 "mode": "0775",
876                 "owner": "123",
877                 "group": "456",
878                 "label": "sec_label",
879             },
880             backing_store={"path": "/backing/image", "format": "raw"},
881             nocow=True,
882         )
883         root = ET.fromstring(xml_data)
884         self.assertEqual(root.get("type"), "file")
885         self.assertEqual(root.find("name").text, "myvm_system.qcow2")
886         self.assertIsNone(root.find("key"))
887         self.assertIsNone(root.find("target/path"))
888         self.assertEqual(root.find("target/format").get("type"), "qcow2")
889         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
890         self.assertEqual(root.find("capacity").text, str(8192 * 1024))
891         self.assertEqual(root.find("capacity").attrib["unit"], "KiB")
892         self.assertEqual(root.find("allocation").text, str(4096 * 1024))
893         self.assertEqual(root.find("target/permissions/mode").text, "0775")
894         self.assertEqual(root.find("target/permissions/owner").text, "123")
895         self.assertEqual(root.find("target/permissions/group").text, "456")
896         self.assertEqual(root.find("target/permissions/label").text, "sec_label")
897         self.assertIsNotNone(root.find("target/nocow"))
898         self.assertEqual(root.find("backingStore/path").text, "/backing/image")
899         self.assertEqual(root.find("backingStore/format").get("type"), "raw")
900     def test_gen_xml_for_kvm_default_profile(self):
901         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
902         nicp = virt._nic_profile("default", "kvm")
903         xml_data = virt._gen_xml(
904             self.mock_conn,
905             "hello",
906             1,
907             512,
908             diskp,
909             nicp,
910             "kvm",
911             "hvm",
912             "x86_64",
913         )
914         root = ET.fromstring(xml_data)
915         self.assertEqual(root.attrib["type"], "kvm")
916         self.assertEqual(root.find("vcpu").text, "1")
917         self.assertEqual(root.find("memory").text, str(512 * 1024))
918         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
919         disks = root.findall(".//disk")
920         self.assertEqual(len(disks), 1)
921         disk = disks[0]
922         root_dir = salt.config.DEFAULT_MINION_OPTS.get("root_dir")
923         self.assertTrue(disk.find("source").attrib["file"].startswith(root_dir))
924         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
925         self.assertEqual(disk.find("target").attrib["dev"], "vda")
926         self.assertEqual(disk.find("target").attrib["bus"], "virtio")
927         self.assertEqual(disk.find("driver").attrib["name"], "qemu")
928         self.assertEqual(disk.find("driver").attrib["type"], "qcow2")
929         interfaces = root.findall(".//interface")
930         self.assertEqual(len(interfaces), 1)
931         iface = interfaces[0]
932         self.assertEqual(iface.attrib["type"], "bridge")
933         self.assertEqual(iface.find("source").attrib["bridge"], "br0")
934         self.assertEqual(iface.find("model").attrib["type"], "virtio")
935     def test_gen_xml_for_esxi_default_profile(self):
936         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
937         nicp = virt._nic_profile("default", "vmware")
938         xml_data = virt._gen_xml(
939             self.mock_conn,
940             "hello",
941             1,
942             512,
943             diskp,
944             nicp,
945             "vmware",
946             "hvm",
947             "x86_64",
948         )
949         root = ET.fromstring(xml_data)
950         self.assertEqual(root.attrib["type"], "vmware")
951         self.assertEqual(root.find("vcpu").text, "1")
952         self.assertEqual(root.find("memory").text, str(512 * 1024))
953         self.assertEqual(root.find("memory").attrib["unit"], "KiB")
954         disks = root.findall(".//disk")
955         self.assertEqual(len(disks), 1)
956         disk = disks[0]
957         self.assertTrue("[0]" in disk.find("source").attrib["file"])
958         self.assertTrue("hello_system" in disk.find("source").attrib["file"])
959         self.assertEqual(disk.find("target").attrib["dev"], "sda")
960         self.assertEqual(disk.find("target").attrib["bus"], "scsi")
961         self.assertEqual(disk.find("address").attrib["unit"], "0")
962         interfaces = root.findall(".//interface")
963         self.assertEqual(len(interfaces), 1)
964         iface = interfaces[0]
965         self.assertEqual(iface.attrib["type"], "bridge")
966         self.assertEqual(iface.find("source").attrib["bridge"], "DEFAULT")
967         self.assertEqual(iface.find("model").attrib["type"], "e1000")
968     def test_gen_xml_for_esxi_custom_profile(self):
969         disks = {
970             "noeffect": [
971                 {"first": {"size": 8192, "pool": "datastore1"}},
972                 {"second": {"size": 4096, "pool": "datastore2"}},
973             ]
974         }
975         nics = {
976             "noeffect": [
977                 {"name": "eth1", "source": "ONENET"},
978                 {"name": "eth2", "source": "TWONET"},
979             ]
980         }
981         with patch.dict(
982             virt.__salt__,  # pylint: disable=no-member
983             {"config.get": MagicMock(side_effect=[disks, nics])},
984         ):
985             diskp = virt._disk_profile(
986                 self.mock_conn, "noeffect", "vmware", [], "hello"
987             )
988             nicp = virt._nic_profile("noeffect", "vmware")
989             xml_data = virt._gen_xml(
990                 self.mock_conn,
991                 "hello",
992                 1,
993                 512,
994                 diskp,
995                 nicp,
996                 "vmware",
997                 "hvm",
998                 "x86_64",
999             )
1000             root = ET.fromstring(xml_data)
1001             self.assertEqual(root.attrib["type"], "vmware")
1002             self.assertEqual(root.find("vcpu").text, "1")
1003             self.assertEqual(root.find("memory").text, str(512 * 1024))
1004             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1005             self.assertTrue(len(root.findall(".//disk")) == 2)
1006             self.assertTrue(len(root.findall(".//interface")) == 2)
1007     def test_gen_xml_for_kvm_custom_profile(self):
1008         disks = {
1009             "noeffect": [
1010                 {"first": {"size": 8192, "pool": "/var/lib/images"}},
1011                 {"second": {"size": 4096, "pool": "/var/lib/images"}},
1012             ]
1013         }
1014         nics = {
1015             "noeffect": [
1016                 {"name": "eth1", "source": "b2"},
1017                 {"name": "eth2", "source": "b2"},
1018             ]
1019         }
1020         with patch.dict(
1021             virt.__salt__,  # pylint: disable=no-member
1022             {"config.get": MagicMock(side_effect=[disks, nics])},
1023         ):
1024             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1025             nicp = virt._nic_profile("noeffect", "kvm")
1026             xml_data = virt._gen_xml(
1027                 self.mock_conn,
1028                 "hello",
1029                 1,
1030                 512,
1031                 diskp,
1032                 nicp,
1033                 "kvm",
1034                 "hvm",
1035                 "x86_64",
1036             )
1037             root = ET.fromstring(xml_data)
1038             self.assertEqual(root.attrib["type"], "kvm")
1039             self.assertEqual(root.find("vcpu").text, "1")
1040             self.assertEqual(root.find("memory").text, str(512 * 1024))
1041             self.assertEqual(root.find("memory").attrib["unit"], "KiB")
1042             disks = root.findall(".//disk")
1043             self.assertTrue(len(disks) == 2)
1044             self.assertEqual(disks[0].find("target").get("dev"), "vda")
1045             self.assertEqual(disks[1].find("target").get("dev"), "vdb")
1046             self.assertTrue(len(root.findall(".//interface")) == 2)
1047     def test_disk_profile_kvm_disk_pool(self):
1048         disks = {
1049             "noeffect": [
1050                 {"first": {"size": 8192, "pool": "mypool"}},
1051                 {"second": {"size": 4096}},
1052             ]
1053         }
1054         with patch.dict(
1055             virt.__salt__,
1056             {
1057                 "config.get": MagicMock(
1058                     side_effect=[
1059                         disks,
1060                         os.path.join(salt.syspaths.ROOT_DIR, "default", "path"),
1061                     ]
1062                 )
1063             },
1064         ):
1065             diskp = virt._disk_profile(self.mock_conn, "noeffect", "kvm", [], "hello")
1066             pools_path = (
1067                 os.path.join(salt.syspaths.ROOT_DIR, "pools", "mypool") + os.sep
1068             )
1069             default_path = (
1070                 os.path.join(salt.syspaths.ROOT_DIR, "default", "path") + os.sep
1071             )
1072             self.assertEqual(len(diskp), 2)
1073             self.assertTrue(diskp[1]["source_file"].startswith(default_path))
1074     def test_disk_profile_kvm_disk_external_image(self):
1075         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1076             diskp = virt._disk_profile(
1077                 self.mock_conn,
1078                 None,
1079                 "kvm",
1080                 [{"name": "mydisk", "source_file": "/path/to/my/image.qcow2"}],
1081                 "hello",
1082             )
1083             self.assertEqual(len(diskp), 1)
1084             self.assertEqual(diskp[0]["source_file"], "/path/to/my/image.qcow2")
1085     def test_disk_profile_cdrom_default(self):
1086         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
1087             diskp = virt._disk_profile(
1088                 self.mock_conn,
1089                 None,
1090                 "kvm",
1091                 [
1092                     {
1093                         "name": "mydisk",
1094                         "device": "cdrom",
1095                         "source_file": "/path/to/my.iso",
1096                     }
1097                 ],
1098                 "hello",
1099             )
1100             self.assertEqual(len(diskp), 1)
1101             self.assertEqual(diskp[0]["model"], "ide")
1102             self.assertEqual(diskp[0]["format"], "raw")
1103     def test_disk_profile_pool_disk_type(self):
1104         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1105         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1106             &lt;pool type="disk"&gt;
1107               &lt;name&gt;test-vdb&lt;/name&gt;
1108               &lt;source&gt;
1109                 &lt;device path='/dev/vdb'/&gt;
1110               &lt;/source&gt;
1111               &lt;target&gt;
1112                 &lt;path&gt;/dev&lt;/path&gt;
1113               &lt;/target&gt;
1114             &lt;/pool&gt;
1115         """
1116         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = (
1117             []
1118         )
1119         diskp = virt._disk_profile(
1120             self.mock_conn,
1121             None,
1122             "kvm",
1123             [{"name": "mydisk", "pool": "test-vdb"}],
1124             "hello",
1125         )
1126         self.assertEqual(diskp[0]["filename"], "vdb1")
1127         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1128             "vdb1",
1129             "vdb2",
1130         ]
1131         diskp = virt._disk_profile(
1132             self.mock_conn,
1133             None,
1134             "kvm",
1135             [{"name": "mydisk", "pool": "test-vdb"}],
1136             "hello",
1137         )
1138         self.assertEqual(diskp[0]["filename"], "vdb3")
1139         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1140             "vdb1",
1141             "vdb3",
1142         ]
1143         diskp = virt._disk_profile(
1144             self.mock_conn,
1145             None,
1146             "kvm",
1147             [{"name": "mydisk", "pool": "test-vdb"}],
1148             "hello",
1149         )
1150         self.assertEqual(diskp[0]["filename"], "vdb2")
1151         diskp = virt._disk_profile(
1152             self.mock_conn,
1153             None,
1154             "kvm",
1155             [{"name": "mydisk", "pool": "test-vdb", "source_file": "vdb1"}],
1156             "hello",
1157         )
1158         self.assertEqual(diskp[0]["filename"], "vdb1")
1159     def test_gen_xml_volume(self):
1160         self.mock_conn.listStoragePools.return_value = ["default"]
1161         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1162             "&lt;pool type='dir'/&gt;"
1163         )
1164         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1165             "myvolume"
1166         ]
1167         diskp = virt._disk_profile(
1168             self.mock_conn,
1169             None,
1170             "kvm",
1171             [
1172                 {"name": "system", "pool": "default"},
1173                 {"name": "data", "pool": "default", "source_file": "myvolume"},
1174             ],
1175             "hello",
1176         )
1177         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1178             "&lt;pool type='dir'/&gt;"
1179         )
1180         nicp = virt._nic_profile(None, "kvm")
1181         xml_data = virt._gen_xml(
1182             self.mock_conn,
1183             "hello",
1184             1,
1185             512,
1186             diskp,
1187             nicp,
1188             "kvm",
1189             "hvm",
1190             "x86_64",
1191         )
1192         root = ET.fromstring(xml_data)
1193         disk = root.findall(".//disk")[0]
1194         self.assertEqual(disk.attrib["device"], "disk")
1195         self.assertEqual(disk.attrib["type"], "volume")
1196         source = disk.find("source")
1197         self.assertEqual("default", source.attrib["pool"])
1198         self.assertEqual("hello_system", source.attrib["volume"])
1199         self.assertEqual("myvolume", root.find(".//disk[2]/source").get("volume"))
1200         self.mock_conn.listStoragePools.return_value = ["test-rbd"]
1201         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1202             &lt;pool type='rbd'&gt;
1203               &lt;name&gt;test-rbd&lt;/name&gt;
1204               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1205               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1206               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1207               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1208               &lt;source&gt;
1209                 &lt;host name='ses2.tf.local'/&gt;
1210                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1211                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1212                 &lt;auth type='ceph' username='libvirt'&gt;
1213                   &lt;secret usage='pool_test-rbd'/&gt;
1214                 &lt;/auth&gt;
1215               &lt;/source&gt;
1216             &lt;/pool&gt;
1217         """
1218         self.mock_conn.getStoragePoolCapabilities.return_value = """
1219             &lt;storagepoolCapabilities&gt;
1220               &lt;pool type='rbd' supported='yes'&gt;
1221                 &lt;volOptions&gt;
1222                   &lt;defaultFormat type='raw'/&gt;
1223                   &lt;enum name='targetFormatType'&gt;
1224                   &lt;/enum&gt;
1225                 &lt;/volOptions&gt;
1226               &lt;/pool&gt;
1227             &lt;/storagepoolCapabilities&gt;
1228         """
1229         diskp = virt._disk_profile(
1230             self.mock_conn,
1231             None,
1232             "kvm",
1233             [{"name": "system", "pool": "test-rbd"}],
1234             "test-vm",
1235         )
1236         xml_data = virt._gen_xml(
1237             self.mock_conn,
1238             "hello",
1239             1,
1240             512,
1241             diskp,
1242             nicp,
1243             "kvm",
1244             "hvm",
1245             "x86_64",
1246         )
1247         root = ET.fromstring(xml_data)
1248         disk = root.findall(".//disk")[0]
1249         self.assertDictEqual(
1250             {
1251                 "type": "network",
1252                 "device": "disk",
1253                 "source": {
1254                     "protocol": "rbd",
1255                     "name": "libvirt-pool/test-vm_system",
1256                     "host": [
1257                         {"name": "ses2.tf.local"},
1258                         {"name": "ses3.tf.local", "port": "1234"},
1259                     ],
1260                     "auth": {
1261                         "username": "libvirt",
1262                         "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1263                     },
1264                 },
1265                 "target": {"dev": "vda", "bus": "virtio"},
1266                 "driver": {
1267                     "name": "qemu",
1268                     "type": "raw",
1269                     "cache": "none",
1270                     "io": "native",
1271                 },
1272             },
1273             salt.utils.xmlutil.to_dict(disk, True),
1274         )
1275         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1276             &lt;pool type='rbd'&gt;
1277               &lt;name&gt;test-rbd&lt;/name&gt;
1278               &lt;uuid&gt;ede33e0a-9df0-479f-8afd-55085a01b244&lt;/uuid&gt;
1279               &lt;capacity unit='bytes'&gt;526133493760&lt;/capacity&gt;
1280               &lt;allocation unit='bytes'&gt;589928&lt;/allocation&gt;
1281               &lt;available unit='bytes'&gt;515081306112&lt;/available&gt;
1282               &lt;source&gt;
1283                 &lt;host name='ses2.tf.local'/&gt;
1284                 &lt;host name='ses3.tf.local' port='1234'/&gt;
1285                 &lt;name&gt;libvirt-pool&lt;/name&gt;
1286                 &lt;auth type='ceph' username='libvirt'&gt;
1287                   &lt;secret uuid='some-uuid'/&gt;
1288                 &lt;/auth&gt;
1289               &lt;/source&gt;
1290             &lt;/pool&gt;
1291         """
1292         self.mock_conn.secretLookupByUUIDString.return_value.usageID.return_value = (
1293             "pool_test-rbd"
1294         )
1295         diskp = virt._disk_profile(
1296             self.mock_conn,
1297             None,
1298             "kvm",
1299             [{"name": "system", "pool": "test-rbd"}],
1300             "test-vm",
1301         )
1302         xml_data = virt._gen_xml(
1303             self.mock_conn,
1304             "hello",
1305             1,
1306             512,
1307             diskp,
1308             nicp,
1309             "kvm",
1310             "hvm",
1311             "x86_64",
1312         )
1313         root = ET.fromstring(xml_data)
1314         self.assertDictEqual(
1315             {
1316                 "username": "libvirt",
1317                 "secret": {"type": "ceph", "usage": "pool_test-rbd"},
1318             },
1319             salt.utils.xmlutil.to_dict(root.find(".//disk/source/auth"), True),
1320         )
1321         self.mock_conn.secretLookupByUUIDString.assert_called_once_with("some-uuid")
1322         self.mock_conn.getStoragePoolCapabilities.return_value = """
1323             &lt;storagepoolCapabilities&gt;
1324               &lt;pool type='disk' supported='yes'&gt;
1325                 &lt;volOptions&gt;
1326                   &lt;defaultFormat type='none'/&gt;
1327                   &lt;enum name='targetFormatType'&gt;
1328                     &lt;value&gt;none&lt;/value&gt;
1329                     &lt;value&gt;linux&lt;/value&gt;
1330                     &lt;value&gt;fat16&lt;/value&gt;
1331                   &lt;/enum&gt;
1332                 &lt;/volOptions&gt;
1333               &lt;/pool&gt;
1334             &lt;/storagepoolCapabilities&gt;
1335         """
1336         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = """
1337             &lt;pool type='disk'&gt;
1338               &lt;name&gt;test-vdb&lt;/name&gt;
1339               &lt;source&gt;
1340                 &lt;device path='/dev/vdb'/&gt;
1341                 &lt;format type='gpt'/&gt;
1342               &lt;/source&gt;
1343             &lt;/pool&gt;
1344         """
1345         self.mock_conn.listStoragePools.return_value = ["test-vdb"]
1346         self.mock_conn.storagePoolLookupByName.return_value.listVolumes.return_value = [
1347             "vdb1",
1348         ]
1349         diskp = virt._disk_profile(
1350             self.mock_conn,
1351             None,
1352             "kvm",
1353             [{"name": "system", "pool": "test-vdb"}],
1354             "test-vm",
1355         )
1356         xml_data = virt._gen_xml(
1357             self.mock_conn,
1358             "hello",
1359             1,
1360             512,
1361             diskp,
1362             nicp,
1363             "kvm",
1364             "hvm",
1365             "x86_64",
1366         )
1367         root = ET.fromstring(xml_data)
1368         disk = root.findall(".//disk")[0]
1369         self.assertEqual(disk.attrib["type"], "volume")
1370         source = disk.find("source")
1371         self.assertEqual("test-vdb", source.attrib["pool"])
1372         self.assertEqual("vdb2", source.attrib["volume"])
1373         self.assertEqual("raw", disk.find("driver").get("type"))
1374     def test_get_xml_volume_xen_dir(self):
1375         self.mock_conn.listStoragePools.return_value = ["default"]
1376         pool_mock = MagicMock()
1377         pool_mock.XMLDesc.return_value = (
1378             "&lt;pool type='dir'&gt;&lt;target&gt;&lt;path&gt;/path/to/images&lt;/path&gt;&lt;/target&gt;&lt;/pool&gt;"
1379         )
1380         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/path/to/images/hello_system&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1381         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1382         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1383         diskp = virt._disk_profile(
1384             self.mock_conn,
1385             None,
1386             "xen",
1387             [{"name": "system", "pool": "default"}],
1388             "hello",
1389         )
1390         xml_data = virt._gen_xml(
1391             self.mock_conn,
1392             "hello",
1393             1,
1394             512,
1395             diskp,
1396             [],
1397             "xen",
1398             "hvm",
1399             "x86_64",
1400         )
1401         root = ET.fromstring(xml_data)
1402         disk = root.findall(".//disk")[0]
1403         self.assertEqual(disk.attrib["type"], "file")
1404         self.assertEqual(
1405             "/path/to/images/hello_system", disk.find("source").attrib["file"]
1406         )
1407     def test_get_xml_volume_xen_block(self):
1408         self.mock_conn.listStoragePools.return_value = ["default"]
1409         pool_mock = MagicMock()
1410         pool_mock.listVolumes.return_value = ["vol01"]
1411         volume_xml = "&lt;volume&gt;&lt;target&gt;&lt;path&gt;/dev/to/vol01&lt;/path&gt;&lt;/target&gt;&lt;/volume&gt;"
1412         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = volume_xml
1413         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1414         for pool_type in ["logical", "disk", "iscsi", "scsi"]:
1415             pool_mock.XMLDesc.return_value = "&lt;pool type='{}'&gt;&lt;source&gt;&lt;device path='/dev/sda'/&gt;&lt;/source&gt;&lt;/pool&gt;".format(
1416                 pool_type
1417             )
1418             diskp = virt._disk_profile(
1419                 self.mock_conn,
1420                 None,
1421                 "xen",
1422                 [{"name": "system", "pool": "default", "source_file": "vol01"}],
1423                 "hello",
1424             )
1425             xml_data = virt._gen_xml(
1426                 self.mock_conn,
1427                 "hello",
1428                 1,
1429                 512,
1430                 diskp,
1431                 [],
1432                 "xen",
1433                 "hvm",
1434                 "x86_64",
1435             )
1436             root = ET.fromstring(xml_data)
1437             disk = root.findall(".//disk")[0]
1438             self.assertEqual(disk.attrib["type"], "block")
1439             self.assertEqual("/dev/to/vol01", disk.find("source").attrib["dev"])
1440     def test_gen_xml_cdrom(self):
1441         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1442             "&lt;pool type='dir'/&gt;"
1443         )
1444         diskp = virt._disk_profile(
1445             self.mock_conn,
1446             None,
1447             "kvm",
1448             [
1449                 {"name": "system", "pool": "default"},
1450                 {
1451                     "name": "tested",
1452                     "device": "cdrom",
1453                     "source_file": None,
1454                     "model": "ide",
1455                 },
1456                 {
1457                     "name": "remote",
1458                     "device": "cdrom",
1459                     "source_file": (
1460                         "http://myhost:8080/url/to/image?query=foo&amp;filter=bar"
1461                     ),
1462                     "model": "ide",
1463                 },
1464             ],
1465             "hello",
1466         )
1467         nicp = virt._nic_profile(None, "kvm")
1468         xml_data = virt._gen_xml(
1469             self.mock_conn,
1470             "hello",
1471             1,
1472             512,
1473             diskp,
1474             nicp,
1475             "kvm",
1476             "hvm",
1477             "x86_64",
1478         )
1479         root = ET.fromstring(xml_data)
1480         disk = root.findall(".//disk")[1]
1481         self.assertEqual(disk.get("type"), "file")
1482         self.assertEqual(disk.attrib["device"], "cdrom")
1483         self.assertIsNone(disk.find("source"))
1484         self.assertEqual(disk.find("target").get("dev"), "hda")
1485         disk = root.findall(".//disk")[2]
1486         self.assertEqual(disk.get("type"), "network")
1487         self.assertEqual(disk.attrib["device"], "cdrom")
1488         self.assertEqual(
1489             {
1490                 "protocol": "http",
1491                 "name": "/url/to/image",
1492                 "query": "query=foo&amp;filter=bar",
1493                 "host": {"name": "myhost", "port": "8080"},
1494             },
1495             salt.utils.xmlutil.to_dict(disk.find("source"), True),
1496         )
1497     def test_controller_for_esxi(self):
1498         diskp = virt._disk_profile(self.mock_conn, "default", "vmware", [], "hello")
1499         nicp = virt._nic_profile("default", "vmware")
1500         xml_data = virt._gen_xml(
1501             self.mock_conn,
1502             "hello",
1503             1,
1504             512,
1505             diskp,
1506             nicp,
1507             "vmware",
1508             "hvm",
1509             "x86_64",
1510         )
1511         root = ET.fromstring(xml_data)
1512         controllers = root.findall(".//devices/controller")
1513         self.assertTrue(len(controllers) == 1)
1514         controller = controllers[0]
1515         self.assertEqual(controller.attrib["model"], "lsilogic")
1516     def test_controller_for_kvm(self):
1517         diskp = virt._disk_profile(self.mock_conn, "default", "kvm", [], "hello")
1518         nicp = virt._nic_profile("default", "kvm")
1519         xml_data = virt._gen_xml(
1520             self.mock_conn,
1521             "hello",
1522             1,
1523             512,
1524             diskp,
1525             nicp,
1526             "kvm",
1527             "hvm",
1528             "x86_64",
1529         )
1530         root = ET.fromstring(xml_data)
1531         controllers = root.findall(".//devices/controller")
1532         self.assertTrue(len(controllers) == 0)
1533     def test_diff_disks(self):
1534         old_disks = ET.fromstring(
1535         ).findall("disk")
1536         new_disks = ET.fromstring(
1537         ).findall("disk")
1538         ret = virt._diff_disk_lists(old_disks, new_disks)
1539         self.assertEqual(
1540             [
1541                 disk.find("source").get("file")
1542                 if disk.find("source") is not None
1543                 else None
1544                 for disk in ret["unchanged"]
1545             ],
1546             [],
1547         )
1548         self.assertEqual(
1549             [
1550                 disk.find("source").get("file")
1551                 if disk.find("source") is not None
1552                 else None
1553                 for disk in ret["new"]
1554             ],
1555             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1556         )
1557         self.assertEqual(
1558             [disk.find("target").get("dev") for disk in ret["sorted"]],
1559             ["vda", "vdb", "vdc", "hda"],
1560         )
1561         self.assertEqual(
1562             [
1563                 disk.find("source").get("file")
1564                 if disk.find("source") is not None
1565                 else None
1566                 for disk in ret["sorted"]
1567             ],
1568             ["/path/to/img3.qcow2", "/path/to/img0.qcow2", "/path/to/img4.qcow2", None],
1569         )
1570         self.assertEqual(ret["new"][1].find("target").get("bus"), "virtio")
1571         self.assertEqual(
1572             [
1573                 disk.find("source").get("file")
1574                 if disk.find("source") is not None
1575                 else None
1576                 for disk in ret["deleted"]
1577             ],
1578             [
1579                 "/path/to/img0.qcow2",
1580                 "/path/to/img1.qcow2",
1581                 "/path/to/img2.qcow2",
1582                 "/path/to/img4.qcow2",
1583                 None,
1584             ],
1585         )
1586     def test_init(self):
1587         xml = """
1588 &lt;capabilities&gt;
1589   &lt;host&gt;
1590     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
1591     &lt;cpu&gt;
1592       &lt;arch&gt;x86_64&lt;/arch&gt;
1593       &lt;model&gt;Nehalem&lt;/model&gt;
1594       &lt;vendor&gt;Intel&lt;/vendor&gt;
1595       &lt;microcode version='25'/&gt;
1596       &lt;topology sockets='1' cores='4' threads='2'/&gt;
1597       &lt;feature name='vme'/&gt;
1598       &lt;feature name='ds'/&gt;
1599       &lt;feature name='acpi'/&gt;
1600       &lt;pages unit='KiB' size='4'/&gt;
1601       &lt;pages unit='KiB' size='2048'/&gt;
1602     &lt;/cpu&gt;
1603     &lt;power_management&gt;
1604       &lt;suspend_mem/&gt;
1605       &lt;suspend_disk/&gt;
1606       &lt;suspend_hybrid/&gt;
1607     &lt;/power_management&gt;
1608     &lt;migration_features&gt;
1609       &lt;live/&gt;
1610       &lt;uri_transports&gt;
1611         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
1612         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
1613       &lt;/uri_transports&gt;
1614     &lt;/migration_features&gt;
1615     &lt;topology&gt;
1616       &lt;cells num='1'&gt;
1617         &lt;cell id='0'&gt;
1618           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
1619           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
1620           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
1621           &lt;distances&gt;
1622             &lt;sibling id='0' value='10'/&gt;
1623           &lt;/distances&gt;
1624           &lt;cpus num='8'&gt;
1625             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
1626             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
1627             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
1628             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
1629             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
1630             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
1631             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
1632             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
1633           &lt;/cpus&gt;
1634         &lt;/cell&gt;
1635       &lt;/cells&gt;
1636     &lt;/topology&gt;
1637     &lt;cache&gt;
1638       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
1639     &lt;/cache&gt;
1640     &lt;secmodel&gt;
1641       &lt;model&gt;apparmor&lt;/model&gt;
1642       &lt;doi&gt;0&lt;/doi&gt;
1643     &lt;/secmodel&gt;
1644     &lt;secmodel&gt;
1645       &lt;model&gt;dac&lt;/model&gt;
1646       &lt;doi&gt;0&lt;/doi&gt;
1647       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
1648       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
1649     &lt;/secmodel&gt;
1650   &lt;/host&gt;
1651   &lt;guest&gt;
1652     &lt;os_type&gt;hvm&lt;/os_type&gt;
1653     &lt;arch name='i686'&gt;
1654       &lt;wordsize&gt;32&lt;/wordsize&gt;
1655       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
1656       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1657       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1658       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1659       &lt;domain type='qemu'/&gt;
1660       &lt;domain type='kvm'&gt;
1661         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1662         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1663         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1664         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1665       &lt;/domain&gt;
1666     &lt;/arch&gt;
1667     &lt;features&gt;
1668       &lt;cpuselection/&gt;
1669       &lt;deviceboot/&gt;
1670       &lt;disksnapshot default='on' toggle='no'/&gt;
1671       &lt;acpi default='on' toggle='yes'/&gt;
1672       &lt;apic default='on' toggle='no'/&gt;
1673       &lt;pae/&gt;
1674       &lt;nonpae/&gt;
1675     &lt;/features&gt;
1676   &lt;/guest&gt;
1677   &lt;guest&gt;
1678     &lt;os_type&gt;hvm&lt;/os_type&gt;
1679     &lt;arch name='x86_64'&gt;
1680       &lt;wordsize&gt;64&lt;/wordsize&gt;
1681       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
1682       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1683       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1684       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1685       &lt;domain type='qemu'/&gt;
1686       &lt;domain type='kvm'&gt;
1687         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
1688         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
1689         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
1690         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
1691       &lt;/domain&gt;
1692     &lt;/arch&gt;
1693     &lt;features&gt;
1694       &lt;cpuselection/&gt;
1695       &lt;deviceboot/&gt;
1696       &lt;disksnapshot default='on' toggle='no'/&gt;
1697       &lt;acpi default='on' toggle='yes'/&gt;
1698       &lt;apic default='on' toggle='no'/&gt;
1699     &lt;/features&gt;
1700   &lt;/guest&gt;
1701 &lt;/capabilities&gt;
1702         """
1703         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
1704         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
1705         defineMock = MagicMock(return_value=1)
1706         self.mock_conn.defineXML = defineMock
1707         mock_chmod = MagicMock()
1708         mock_run = MagicMock()
1709         with patch.dict(
1710             os.__dict__, {"chmod": mock_chmod, "makedirs": MagicMock()}
1711         ):  # pylint: disable=no-member
1712             with patch.dict(
1713                 virt.__salt__, {"cmd.run": mock_run}
1714             ):  # pylint: disable=no-member
1715                 virt.init(
1716                     "test vm", 2, 1234, nic=None, disk=None, seed=False, start=False
1717                 )
1718                 definition = defineMock.call_args_list[0][0][0]
1719                 self.assertFalse("&lt;interface" in definition)
1720                 self.assertFalse("&lt;disk" in definition)
1721                 defineMock.reset_mock()
1722                 mock_run.reset_mock()
1723                 boot = {
1724                     "kernel": "/root/f8-i386-vmlinuz",
1725                     "initrd": "/root/f8-i386-initrd",
1726                     "cmdline": "console=ttyS0 ks=http://example.com/f8-i386/os/",
1727                 }
1728                 retval = virt.init(
1729                     "test vm boot params",
1730                     2,
1731                     1234,
1732                     nic=None,
1733                     disk=None,
1734                     seed=False,
1735                     start=False,
1736                     boot=boot,
1737                 )
1738                 definition = defineMock.call_args_list[0][0][0]
1739                 self.assertEqual("&lt;kernel" in definition, True)
1740                 self.assertEqual("&lt;initrd" in definition, True)
1741                 self.assertEqual("&lt;cmdline" in definition, True)
1742                 self.assertEqual(retval, True)
1743                 mock_response = MagicMock()
1744                 mock_response.read = MagicMock(return_value="filecontent")
1745                 cache_dir = tempfile.mkdtemp()
1746                 with patch.dict(virt.__dict__, {"CACHE_DIR": cache_dir}):
1747                     with patch(
1748                         "urllib.request.urlopen",
1749                         MagicMock(return_value=mock_response),
1750                     ):
1751                         with patch(
1752                             "salt.utils.files.fopen", return_value=mock_response
1753                         ):
1754                             defineMock.reset_mock()
1755                             mock_run.reset_mock()
1756                             boot = {
1757                                 "kernel": "https://www.example.com/download/vmlinuz",
1758                                 "initrd": "",
1759                                 "cmdline": (
1760                                     "console=ttyS0 ks=http://example.com/f8-i386/os/"
1761                                 ),
1762                             }
1763                             retval = virt.init(
1764                                 "test remote vm boot params",
1765                                 2,
1766                                 1234,
1767                                 nic=None,
1768                                 disk=None,
1769                                 seed=False,
1770                                 start=False,
1771                                 boot=boot,
1772                             )
1773                             definition = defineMock.call_args_list[0][0][0]
1774                             self.assertEqual(cache_dir in definition, True)
1775                     shutil.rmtree(cache_dir)
1776                 defineMock.reset_mock()
1777                 mock_run.reset_mock()
1778                 pool_mock = MagicMock()
1779                 pool_mock.XMLDesc.return_value = '&lt;pool type="dir"/&gt;'
1780                 self.mock_conn.storagePoolLookupByName.return_value = pool_mock
1781                 virt.init(
1782                     "test vm",
1783                     2,
1784                     1234,
1785                     nic=None,
1786                     disk=None,
1787                     disks=[
1788                         {"name": "system", "size": 10240},
1789                         {
1790                             "name": "cddrive",
1791                             "device": "cdrom",
1792                             "source_file": None,
1793                             "model": "ide",
1794                         },
1795                     ],
1796                     seed=False,
1797                     start=False,
1798                 )
1799                 definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1800                 expected_disk_path = os.path.join(root_dir, "test vm_system.qcow2")
1801                 self.assertEqual(
1802                     expected_disk_path,
1803                     definition.find("./devices/disk[1]/source").get("file"),
1804                 )
1805                 self.assertIsNone(definition.find("./devices/disk[2]/source"))
1806                 self.assertEqual(
1807                     mock_run.call_args[0][0],
1808                     'qemu-img create -f qcow2 "{}" 10240M'.format(expected_disk_path),
1809                 )
1810                 self.assertEqual(mock_chmod.call_args[0][0], expected_disk_path)
1811                 defineMock.reset_mock()
1812                 mock_run.reset_mock()
1813                 vol_mock = MagicMock()
1814                 pool_mock.storageVolLookupByName.return_value = vol_mock
1815                 pool_mock.listVolumes.return_value = ["test vm_data"]
1816                 stream_mock = MagicMock()
1817                 self.mock_conn.newStream.return_value = stream_mock
1818                 self.mock_conn.listStoragePools.return_value = ["default", "test"]
1819                 with patch.dict(
1820                     os.__dict__, {"open": MagicMock(), "close": MagicMock()}
1821                 ):
1822                     cache_mock = MagicMock()
1823                     with patch.dict(virt.__salt__, {"cp.cache_file": cache_mock}):
1824                         virt.init(
1825                             "test vm",
1826                             2,
1827                             1234,
1828                             nic=None,
1829                             disk=None,
1830                             disks=[
1831                                 {
1832                                     "name": "system",
1833                                     "size": 10240,
1834                                     "image": "/path/to/image",
1835                                     "pool": "test",
1836                                 },
1837                                 {"name": "data", "size": 10240, "pool": "default"},
1838                                 {
1839                                     "name": "test",
1840                                     "size": 1024,
1841                                     "pool": "default",
1842                                     "format": "qcow2",
1843                                     "backing_store_path": "/backing/path",
1844                                     "backing_store_format": "raw",
1845                                 },
1846                             ],
1847                             seed=False,
1848                             start=False,
1849                         )
1850                         definition = ET.fromstring(defineMock.call_args_list[0][0][0])
1851                         self.assertTrue(
1852                             all(
1853                                 [
1854                                     disk.get("type") == "volume"
1855                                     for disk in definition.findall("./devices/disk")
1856                                 ]
1857                             )
1858                         )
1859                         self.assertEqual(
1860                             ["test", "default", "default"],
1861                             [
1862                                 src.get("pool")
1863                                 for src in definition.findall("./devices/disk/source")
1864                             ],
1865                         )
1866                         self.assertEqual(
1867                             ["test vm_system", "test vm_data", "test vm_test"],
1868                             [
1869                                 src.get("volume")
1870                                 for src in definition.findall("./devices/disk/source")
1871                             ],
1872                         )
1873                         create_calls = pool_mock.createXML.call_args_list
1874                         vol_names = [
1875                             ET.fromstring(call[0][0]).find("name").text
1876                             for call in create_calls
1877                         ]
1878                         self.assertEqual(
1879                             ["test vm_system", "test vm_test"],
1880                             vol_names,
1881                         )
1882                         stream_mock.sendAll.assert_called_once()
1883                         stream_mock.finish.assert_called_once()
1884                         vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
1885     def test_update_backing_store(self):
1886         xml = """
1887             &lt;domain type='kvm' id='7'&gt;
1888               &lt;name&gt;my_vm&lt;/name&gt;
1889               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1890               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1891               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1892               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
1893               &lt;os&gt;
1894                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1895               &lt;/os&gt;
1896               &lt;devices&gt;
1897                 &lt;disk type='volume' device='disk'&gt;
1898                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
1899                   &lt;source pool='default' volume='my_vm_system' index='1'/&gt;
1900                   &lt;backingStore type='file' index='2'&gt;
1901                     &lt;format type='qcow2'/&gt;
1902                     &lt;source file='/path/to/base.qcow2'/&gt;
1903                     &lt;backingStore/&gt;
1904                   &lt;/backingStore&gt;
1905                   &lt;target dev='vda' bus='virtio'/&gt;
1906                   &lt;alias name='virtio-disk0'/&gt;
1907                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
1908                 &lt;/disk&gt;
1909               &lt;/devices&gt;
1910             &lt;/domain&gt;
1911         """
1912         domain_mock = self.set_mock_vm("my_vm", xml)
1913         domain_mock.OSType.return_value = "hvm"
1914         self.mock_conn.defineXML.return_value = True
1915         updatedev_mock = MagicMock(return_value=0)
1916         domain_mock.updateDeviceFlags = updatedev_mock
1917         self.mock_conn.listStoragePools.return_value = ["default"]
1918         self.mock_conn.storagePoolLookupByName.return_value.XMLDesc.return_value = (
1919             "&lt;pool type='dir'/&gt;"
1920         )
1921         ret = virt.update(
1922             "my_vm",
1923             disks=[
1924                 {
1925                     "name": "system",
1926                     "pool": "default",
1927                     "backing_store_path": "/path/to/base.qcow2",
1928                     "backing_store_format": "qcow2",
1929                 },
1930             ],
1931         )
1932         self.assertFalse(ret["definition"])
1933         self.assertFalse(ret["disk"]["attached"])
1934         self.assertFalse(ret["disk"]["detached"])
1935     def test_update_removables(self):
1936         xml = """
1937             &lt;domain type='kvm' id='7'&gt;
1938               &lt;name&gt;my_vm&lt;/name&gt;
1939               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
1940               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
1941               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
1942               &lt;os&gt;
1943                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
1944               &lt;/os&gt;
1945               &lt;devices&gt;
1946                 &lt;disk type='network' device='cdrom'&gt;
1947                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1948                   &lt;source protocol='https' name='/dvd-image-1.iso'&gt;
1949                     &lt;host name='test-srv.local' port='80'/&gt;
1950                   &lt;/source&gt;
1951                   &lt;backingStore/&gt;
1952                   &lt;target dev='hda' bus='ide'/&gt;
1953                   &lt;readonly/&gt;
1954                   &lt;alias name='ide0-0-0'/&gt;
1955                   &lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&gt;
1956                 &lt;/disk&gt;
1957                 &lt;disk type='file' device='cdrom'&gt;
1958                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1959                   &lt;target dev='hdb' bus='ide'/&gt;
1960                   &lt;readonly/&gt;
1961                   &lt;alias name='ide0-0-1'/&gt;
1962                   &lt;address type='drive' controller='0' bus='0' target='0' unit='1'/&gt;
1963                 &lt;/disk&gt;
1964                 &lt;disk type='file' device='cdrom'&gt;
1965                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1966                   &lt;source file='/srv/dvd-image-2.iso'/&gt;
1967                   &lt;backingStore/&gt;
1968                   &lt;target dev='hdc' bus='ide'/&gt;
1969                   &lt;readonly/&gt;
1970                   &lt;alias name='ide0-0-2'/&gt;
1971                   &lt;address type='drive' controller='0' bus='0' target='0' unit='2'/&gt;
1972                 &lt;/disk&gt;
1973                 &lt;disk type='file' device='cdrom'&gt;
1974                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1975                   &lt;source file='/srv/dvd-image-3.iso'/&gt;
1976                   &lt;backingStore/&gt;
1977                   &lt;target dev='hdd' bus='ide'/&gt;
1978                   &lt;readonly/&gt;
1979                   &lt;alias name='ide0-0-3'/&gt;
1980                   &lt;address type='drive' controller='0' bus='0' target='0' unit='3'/&gt;
1981                 &lt;/disk&gt;
1982                 &lt;disk type='network' device='cdrom'&gt;
1983                   &lt;driver name='qemu' type='raw' cache='none' io='native'/&gt;
1984                   &lt;source protocol='https' name='/dvd-image-6.iso'&gt;
1985                     &lt;host name='test-srv.local' port='80'/&gt;
1986                   &lt;/source&gt;
1987                   &lt;backingStore/&gt;
1988                   &lt;target dev='hde' bus='ide'/&gt;
1989                   &lt;readonly/&gt;
1990                 &lt;/disk&gt;
1991               &lt;/devices&gt;
1992             &lt;/domain&gt;
1993         """
1994         domain_mock = self.set_mock_vm("my_vm", xml)
1995         domain_mock.OSType.return_value = "hvm"
1996         self.mock_conn.defineXML.return_value = True
1997         updatedev_mock = MagicMock(return_value=0)
1998         domain_mock.updateDeviceFlags = updatedev_mock
1999         ret = virt.update(
2000             "my_vm",
2001             disks=[
2002                 {
2003                     "name": "dvd1",
2004                     "device": "cdrom",
2005                     "source_file": None,
2006                     "model": "ide",
2007                 },
2008                 {
2009                     "name": "dvd2",
2010                     "device": "cdrom",
2011                     "source_file": "/srv/dvd-image-4.iso",
2012                     "model": "ide",
2013                 },
2014                 {
2015                     "name": "dvd3",
2016                     "device": "cdrom",
2017                     "source_file": "/srv/dvd-image-2.iso",
2018                     "model": "ide",
2019                 },
2020                 {
2021                     "name": "dvd4",
2022                     "device": "cdrom",
2023                     "source_file": "/srv/dvd-image-5.iso",
2024                     "model": "ide",
2025                 },
2026                 {
2027                     "name": "dvd5",
2028                     "device": "cdrom",
2029                     "source_file": "/srv/dvd-image-6.iso",
2030                     "model": "ide",
2031                 },
2032             ],
2033         )
2034         self.assertTrue(ret["definition"])
2035         self.assertFalse(ret["disk"].get("attached"))
2036         self.assertFalse(ret["disk"].get("detached"))
2037         self.assertEqual(
2038             [
2039                 {
2040                     "type": "file",
2041                     "device": "cdrom",
2042                     "driver": {
2043                         "name": "qemu",
2044                         "type": "raw",
2045                         "cache": "none",
2046                         "io": "native",
2047                     },
2048                     "backingStore": None,
2049                     "target": {"dev": "hda", "bus": "ide"},
2050                     "readonly": None,
2051                     "alias": {"name": "ide0-0-0"},
2052                     "address": {
2053                         "type": "drive",
2054                         "controller": "0",
2055                         "bus": "0",
2056                         "target": "0",
2057                         "unit": "0",
2058                     },
2059                 },
2060                 {
2061                     "type": "file",
2062                     "device": "cdrom",
2063                     "driver": {
2064                         "name": "qemu",
2065                         "type": "raw",
2066                         "cache": "none",
2067                         "io": "native",
2068                     },
2069                     "target": {"dev": "hdb", "bus": "ide"},
2070                     "readonly": None,
2071                     "alias": {"name": "ide0-0-1"},
2072                     "address": {
2073                         "type": "drive",
2074                         "controller": "0",
2075                         "bus": "0",
2076                         "target": "0",
2077                         "unit": "1",
2078                     },
2079                     "source": {"file": "/srv/dvd-image-4.iso"},
2080                 },
2081                 {
2082                     "type": "file",
2083                     "device": "cdrom",
2084                     "driver": {
2085                         "name": "qemu",
2086                         "type": "raw",
2087                         "cache": "none",
2088                         "io": "native",
2089                     },
2090                     "backingStore": None,
2091                     "target": {"dev": "hdd", "bus": "ide"},
2092                     "readonly": None,
2093                     "alias": {"name": "ide0-0-3"},
2094                     "address": {
2095                         "type": "drive",
2096                         "controller": "0",
2097                         "bus": "0",
2098                         "target": "0",
2099                         "unit": "3",
2100                     },
2101                     "source": {"file": "/srv/dvd-image-5.iso"},
2102                 },
2103                 {
2104                     "type": "file",
2105                     "device": "cdrom",
2106                     "driver": {
2107                         "name": "qemu",
2108                         "type": "raw",
2109                         "cache": "none",
2110                         "io": "native",
2111                     },
2112                     "backingStore": None,
2113                     "target": {"dev": "hde", "bus": "ide"},
2114                     "readonly": None,
2115                     "source": {"file": "/srv/dvd-image-6.iso"},
2116                 },
2117             ],
2118             [
2119                 salt.utils.xmlutil.to_dict(ET.fromstring(disk), True)
2120                 for disk in ret["disk"]["updated"]
2121             ],
2122         )
2123     def test_update_xen_boot_params(self):
2124         root_dir = os.path.join(salt.syspaths.ROOT_DIR, "srv", "salt-images")
2125         xml_boot = """
2126             &lt;domain type='xen' id='8'&gt;
2127               &lt;name&gt;vm&lt;/name&gt;
2128               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2129               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2130               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2131               &lt;os&gt;
2132                 &lt;type arch='x86_64' machine='xenfv'&gt;hvm&lt;/type&gt;
2133                 &lt;loader type='rom'&gt;/usr/lib/xen/boot/hvmloader&lt;/loader&gt;
2134               &lt;/os&gt;
2135             &lt;/domain&gt;
2136         """
2137         domain_mock_boot = self.set_mock_vm("vm", xml_boot)
2138         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2139         define_mock_boot = MagicMock(return_value=True)
2140         define_mock_boot.setVcpusFlags = MagicMock(return_value=0)
2141         self.mock_conn.defineXML = define_mock_boot
2142         self.assertEqual(
2143             {
2144                 "cpu": False,
2145                 "definition": True,
2146                 "disk": {"attached": [], "detached": [], "updated": []},
2147                 "interface": {"attached": [], "detached": []},
2148             },
2149             virt.update("vm", cpu=2),
2150         )
2151         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2152         self.assertEqual(setxml.find("os").find("loader").attrib.get("type"), "rom")
2153         self.assertEqual(
2154             setxml.find("os").find("loader").text, "/usr/lib/xen/boot/hvmloader"
2155         )
2156     def test_update_existing_boot_params(self):
2157         xml_boot = """
2158             &lt;domain type='kvm' id='8'&gt;
2159               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2160               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2161               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2162               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2163               &lt;os&gt;
2164                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2165                 &lt;kernel&gt;/boot/oldkernel&lt;/kernel&gt;
2166                 &lt;initrd&gt;/boot/initrdold.img&lt;/initrd&gt;
2167                 &lt;cmdline&gt;console=ttyS0 ks=http://example.com/old/os/&lt;/cmdline&gt;
2168                 &lt;loader&gt;/usr/share/old/OVMF_CODE.fd&lt;/loader&gt;
2169                 &lt;nvram&gt;/usr/share/old/OVMF_VARS.ms.fd&lt;/nvram&gt;
2170               &lt;/os&gt;
2171             &lt;/domain&gt;
2172         """
2173         domain_mock_boot = self.set_mock_vm("vm_with_boot_param", xml_boot)
2174         domain_mock_boot.OSType = MagicMock(return_value="hvm")
2175         define_mock_boot = MagicMock(return_value=True)
2176         self.mock_conn.defineXML = define_mock_boot
2177         boot_new = {
2178             "kernel": "/root/new-vmlinuz",
2179             "initrd": "/root/new-initrd",
2180             "cmdline": "console=ttyS0 ks=http://example.com/new/os/",
2181         }
2182         uefi_boot_new = {
2183             "loader": "/usr/share/new/OVMF_CODE.fd",
2184             "nvram": "/usr/share/new/OVMF_VARS.ms.fd",
2185         }
2186         self.assertEqual(
2187             {
2188                 "definition": True,
2189                 "disk": {"attached": [], "detached": [], "updated": []},
2190                 "interface": {"attached": [], "detached": []},
2191             },
2192             virt.update("vm_with_boot_param", boot=boot_new),
2193         )
2194         setxml_boot = ET.fromstring(define_mock_boot.call_args[0][0])
2195         self.assertEqual(
2196             setxml_boot.find("os").find("kernel").text, "/root/new-vmlinuz"
2197         )
2198         self.assertEqual(setxml_boot.find("os").find("initrd").text, "/root/new-initrd")
2199         self.assertEqual(
2200             setxml_boot.find("os").find("cmdline").text,
2201             "console=ttyS0 ks=http://example.com/new/os/",
2202         )
2203         self.assertEqual(
2204             {
2205                 "definition": True,
2206                 "disk": {"attached": [], "detached": [], "updated": []},
2207                 "interface": {"attached": [], "detached": []},
2208             },
2209             virt.update("vm_with_boot_param", boot=uefi_boot_new),
2210         )
2211         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2212         self.assertEqual(
2213             setxml.find("os").find("loader").text, "/usr/share/new/OVMF_CODE.fd"
2214         )
2215         self.assertEqual(setxml.find("os").find("loader").attrib.get("readonly"), "yes")
2216         self.assertEqual(setxml.find("os").find("loader").attrib["type"], "pflash")
2217         self.assertEqual(
2218             setxml.find("os").find("nvram").attrib["template"],
2219             "/usr/share/new/OVMF_VARS.ms.fd",
2220         )
2221         kernel_none = {
2222             "kernel": None,
2223             "initrd": None,
2224             "cmdline": None,
2225         }
2226         uefi_none = {"loader": None, "nvram": None}
2227         self.assertEqual(
2228             {
2229                 "definition": True,
2230                 "disk": {"attached": [], "detached": [], "updated": []},
2231                 "interface": {"attached": [], "detached": []},
2232             },
2233             virt.update("vm_with_boot_param", boot=kernel_none),
2234         )
2235         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2236         self.assertEqual(setxml.find("os").find("kernel"), None)
2237         self.assertEqual(setxml.find("os").find("initrd"), None)
2238         self.assertEqual(setxml.find("os").find("cmdline"), None)
2239         self.assertEqual(
2240             {
2241                 "definition": True,
2242                 "disk": {"attached": [], "detached": [], "updated": []},
2243                 "interface": {"attached": [], "detached": []},
2244             },
2245             virt.update("vm_with_boot_param", boot={"efi": False}),
2246         )
2247         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2248         self.assertEqual(setxml.find("os").find("nvram"), None)
2249         self.assertEqual(setxml.find("os").find("loader"), None)
2250         self.assertEqual(
2251             {
2252                 "definition": True,
2253                 "disk": {"attached": [], "detached": [], "updated": []},
2254                 "interface": {"attached": [], "detached": []},
2255             },
2256             virt.update("vm_with_boot_param", boot=uefi_none),
2257         )
2258         setxml = ET.fromstring(define_mock_boot.call_args[0][0])
2259         self.assertEqual(setxml.find("os").find("loader"), None)
2260         self.assertEqual(setxml.find("os").find("nvram"), None)
2261     def test_update_existing_numatune_params(self):
2262         xml_numatune = """
2263             &lt;domain type='kvm' id='8'&gt;
2264               &lt;name&gt;vm_with_numatune_param&lt;/name&gt;
2265               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2266               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2267               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
2268               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
2269               &lt;numatune&gt;
2270                 &lt;memory mode="strict" nodeset="0-11"/&gt;
2271                 &lt;memnode cellid="1" mode="strict" nodeset="3"/&gt;
2272                 &lt;memnode cellid="3" mode="preferred" nodeset="7"/&gt;
2273               &lt;/numatune&gt;
2274               &lt;os&gt;
2275                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2276               &lt;/os&gt;
2277               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
2278             &lt;/domain&gt;
2279         """
2280         domain_mock = self.set_mock_vm("vm_with_numatune_param", xml_numatune)
2281         domain_mock.OSType = MagicMock(return_value="hvm")
2282         define_mock = MagicMock(return_value=True)
2283         self.mock_conn.defineXML = define_mock
2284         numatune = {
2285             "memory": {"mode": "preferred", "nodeset": "0-5"},
2286             "memnodes": {
2287                 0: {"mode": "strict", "nodeset": "4"},
2288                 3: {"mode": "preferred", "nodeset": "7"},
2289                 4: {"mode": "strict", "nodeset": "6"},
2290             },
2291         }
2292         self.assertEqual(
2293             {
2294                 "definition": True,
2295                 "disk": {"attached": [], "detached": [], "updated": []},
2296                 "interface": {"attached": [], "detached": []},
2297             },
2298             virt.update("vm_with_numatune_param", numatune=numatune),
2299         )
2300         setxml = ET.fromstring(define_mock.call_args[0][0])
2301         self.assertEqual(
2302             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2303         )
2304         self.assertEqual(
2305             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2306             ",".join([str(i) for i in range(0, 6)]),
2307         )
2308         self.assertEqual(
2309             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2310         )
2311         self.assertEqual(
2312             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2313         )
2314         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='1']"), None)
2315         self.assertEqual(
2316             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2317             "preferred",
2318         )
2319         self.assertEqual(
2320             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2321         )
2322         self.assertEqual(
2323             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("mode"), "strict"
2324         )
2325         self.assertEqual(
2326             setxml.find("./numatune/memnode/[@cellid='4']").attrib.get("nodeset"), "6"
2327         )
2328         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2329         numatune_mem_none = {
2330             "memory": None,
2331             "memnodes": {
2332                 0: {"mode": "strict", "nodeset": "4"},
2333                 3: {"mode": "preferred", "nodeset": "7"},
2334                 4: {"mode": "strict", "nodeset": "6"},
2335             },
2336         }
2337         self.assertEqual(
2338             {
2339                 "definition": True,
2340                 "disk": {"attached": [], "detached": [], "updated": []},
2341                 "interface": {"attached": [], "detached": []},
2342             },
2343             virt.update("vm_with_numatune_param", numatune=numatune_mem_none),
2344         )
2345         setxml = ET.fromstring(define_mock.call_args[0][0])
2346         self.assertEqual(setxml.find("numatune").find("memory"), None)
2347         self.assertEqual(
2348             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("mode"), "strict"
2349         )
2350         self.assertEqual(
2351             setxml.find("./numatune/memnode/[@cellid='0']").attrib.get("nodeset"), "4"
2352         )
2353         self.assertEqual(
2354             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("mode"),
2355             "preferred",
2356         )
2357         self.assertEqual(
2358             setxml.find("./numatune/memnode/[@cellid='3']").attrib.get("nodeset"), "7"
2359         )
2360         self.assertEqual(setxml.find("./numatune/memnode/[@cellid='2']"), None)
2361         numatune_mnodes_none = {
2362             "memory": {"mode": "preferred", "nodeset": "0-5"},
2363             "memnodes": None,
2364         }
2365         self.assertEqual(
2366             {
2367                 "definition": True,
2368                 "disk": {"attached": [], "detached": [], "updated": []},
2369                 "interface": {"attached": [], "detached": []},
2370             },
2371             virt.update("vm_with_numatune_param", numatune=numatune_mnodes_none),
2372         )
2373         setxml = ET.fromstring(define_mock.call_args[0][0])
2374         self.assertEqual(
2375             setxml.find("numatune").find("memory").attrib.get("mode"), "preferred"
2376         )
2377         self.assertEqual(
2378             setxml.find("numatune").find("memory").attrib.get("nodeset"),
2379             ",".join([str(i) for i in range(0, 6)]),
2380         )
2381         self.assertEqual(setxml.find("./numatune/memnode"), None)
2382         numatune_without_change = {
2383             "memory": {"mode": "strict", "nodeset": "0-5,6,7-11"},
2384             "memnodes": {
2385                 1: {"mode": "strict", "nodeset": "3"},
2386                 3: {"mode": "preferred", "nodeset": "7"},
2387             },
2388         }
2389         self.assertEqual(
2390             {
2391                 "definition": False,
2392                 "disk": {"attached": [], "detached": [], "updated": []},
2393                 "interface": {"attached": [], "detached": []},
2394             },
2395             virt.update("vm_with_numatune_param", numatune=numatune_without_change),
2396         )
2397         self.assertEqual(
2398             {
2399                 "definition": True,
2400                 "disk": {"attached": [], "detached": [], "updated": []},
2401                 "interface": {"attached": [], "detached": []},
2402             },
2403             virt.update(
2404                 "vm_with_numatune_param", numatune={"memory": None, "memnodes": None}
2405             ),
2406         )
2407         setxml = ET.fromstring(define_mock.call_args[0][0])
2408         self.assertEqual(setxml.find("numatune"), None)
2409     def test_update_existing_cpu_params(self):
2410         xml_with_existing_params = """
2411             &lt;domain type='kvm' id='8'&gt;
2412               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
2413               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
2414               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
2415               &lt;vcpu placement="static" cpuset="0-11" current="3"&gt;6&lt;/vcpu&gt;
2416               &lt;vcpus&gt;
2417                 &lt;vcpu id="0" enabled="yes" hotpluggable="no" order="1"/&gt;
2418                 &lt;vcpu id="1" enabled="no" hotpluggable="yes"/&gt;
2419                 &lt;vcpu id="2" enabled="no" hotpluggable="yes"/&gt;
2420                 &lt;vcpu id="3" enabled="no" hotpluggable="yes"/&gt;
2421                 &lt;vcpu id="4" enabled="no" hotpluggable="yes"/&gt;
2422                 &lt;vcpu id="5" enabled="no" hotpluggable="yes"/&gt;
2423                 &lt;vcpu id="6" enabled="no" hotpluggable="yes"/&gt;
2424                 &lt;vcpu id="7" enabled="no" hotpluggable="yes"/&gt;
2425                 &lt;vcpu id="8" enabled="no" hotpluggable="yes"/&gt;
2426                 &lt;vcpu id="9" enabled="no" hotpluggable="yes"/&gt;
2427                 &lt;vcpu id="10" enabled="no" hotpluggable="yes"/&gt;
2428                 &lt;vcpu id="11" enabled="no" hotpluggable="yes"/&gt;
2429               &lt;/vcpus&gt;
2430               &lt;cpu mode="custom" match="exact" check="full"&gt;
2431                  &lt;model fallback="allow" vendor_id="Genuine20201"&gt;core2duo&lt;/model&gt;
2432                  &lt;vendor&gt;Intel&lt;/vendor&gt;
2433                  &lt;topology sockets="2" cores="5" threads="2"/&gt;
2434                  &lt;cache level="3" mode="emulate"/&gt;
2435                  &lt;feature policy="optional" name="lahf_lm"/&gt;
2436                  &lt;feature policy="require" name="pcid"/&gt;
2437                  &lt;numa&gt;
2438                     &lt;cell id="0" cpus="0-3" memory="1073741824" unit="KiB" discard="no"&gt;
2439                         &lt;distances&gt;
2440                             &lt;sibling id="0" value="10"/&gt;
2441                             &lt;sibling id="1" value="21"/&gt;
2442                             &lt;sibling id="2" value="31"/&gt;
2443                             &lt;sibling id="3" value="41"/&gt;
2444                         &lt;/distances&gt;
2445                     &lt;/cell&gt;
2446                     &lt;cell id="1" cpus="4-6" memory="1073741824" unit="KiB" memAccess="private"&gt;
2447                         &lt;distances&gt;
2448                             &lt;sibling id="0" value="21"/&gt;
2449                             &lt;sibling id="1" value="10"/&gt;
2450                             &lt;sibling id="2" value="21"/&gt;
2451                             &lt;sibling id="3" value="31"/&gt;
2452                         &lt;/distances&gt;
2453                     &lt;/cell&gt;
2454                  &lt;/numa&gt;
2455               &lt;/cpu&gt;
2456               &lt;os&gt;
2457                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
2458               &lt;/os&gt;
2459               &lt;/domain&gt;
2460          """
2461         domain_mock = self.set_mock_vm(
2462             "vm_with_existing_param", xml_with_existing_params
2463         )
2464         domain_mock.OSType = MagicMock(return_value="hvm")
2465         define_mock = MagicMock(return_value=True)
2466         self.mock_conn.defineXML = define_mock
2467         setvcpus_mock = MagicMock(return_value=0)
2468         domain_mock.setVcpusFlags = setvcpus_mock
2469         cpu_attr = {"placement": "static", "cpuset": "0-5", "current": 3, "maximum": 5}
2470         self.assertEqual(
2471             {
2472                 "definition": True,
2473                 "cpu": True,
2474                 "disk": {"attached": [], "detached": [], "updated": []},
2475                 "interface": {"attached": [], "detached": []},
2476             },
2477             virt.update("vm_with_existing_param", cpu=cpu_attr),
2478         )
2479         setxml = ET.fromstring(define_mock.call_args[0][0])
2480         self.assertEqual(setxml.find("vcpu").text, "5")
2481         self.assertEqual(setxml.find("vcpu").attrib["placement"], "static")
2482         self.assertEqual(
2483             setxml.find("vcpu").attrib["cpuset"],
2484             ",".join([str(i) for i in range(0, 6)]),
2485         )
2486         self.assertEqual(setxml.find("vcpu").attrib["current"], "3")
2487         cpu_none = {"placement": "auto", "cpuset": None, "current": 2, "maximum": 5}
2488         self.assertEqual(
2489             {
2490                 "definition": True,
2491                 "cpu": True,
2492                 "disk": {"attached": [], "detached": [], "updated": []},
2493                 "interface": {"attached": [], "detached": []},
2494             },
2495             virt.update("vm_with_existing_param", cpu=cpu_none),
2496         )
2497         setxml = ET.fromstring(define_mock.call_args[0][0])
2498         self.assertEqual(setxml.find("vcpu").text, "5")
2499         self.assertEqual(setxml.find("vcpu").attrib["placement"], "auto")
2500         self.assertEqual(setxml.find("vcpu").attrib.get("cpuset"), None)
2501         self.assertEqual(setxml.find("vcpu").attrib.get("current"), "2")
2502         vcpus = {
2503             "vcpus": {
2504                 "0": {"enabled": False, "hotpluggable": True, "order": 5},
2505                 "3": {"enabled": True, "hotpluggable": False, "order": 3},
2506                 "7": {"enabled": True, "hotpluggable": False},
2507             }
2508         }
2509         self.assertEqual(
2510             {
2511                 "definition": True,
2512                 "disk": {"attached": [], "detached": [], "updated": []},
2513                 "interface": {"attached": [], "detached": []},
2514             },
2515             virt.update("vm_with_existing_param", cpu=vcpus),
2516         )
2517         setxml = ET.fromstring(define_mock.call_args[0][0])
2518         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["id"], "0")
2519         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["enabled"], "no")
2520         self.assertEqual(
2521             setxml.find("./vcpus/vcpu/[@id='0']").attrib["hotpluggable"], "yes"
2522         )
2523         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']").attrib["order"], "5")
2524         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["id"], "3")
2525         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2526         self.assertEqual(
2527             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2528         )
2529         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["order"], "3")
2530         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["id"], "7")
2531         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='7']").attrib["enabled"], "yes")
2532         self.assertEqual(
2533             setxml.find("./vcpus/vcpu/[@id='7']").attrib["hotpluggable"], "no"
2534         )
2535         self.assertEqual(
2536             setxml.find("./vcpus/vcpu/[@id='7']").attrib.get("order"), None
2537         )
2538         ind_vcpu = {
2539             "vcpus": {"3": {"enabled": True, "hotpluggable": False, "order": None}}
2540         }
2541         self.assertEqual(
2542             {
2543                 "definition": True,
2544                 "disk": {"attached": [], "detached": [], "updated": []},
2545                 "interface": {"attached": [], "detached": []},
2546             },
2547             virt.update("vm_with_existing_param", cpu=ind_vcpu),
2548         )
2549         setxml = ET.fromstring(define_mock.call_args[0][0])
2550         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='0']"), None)
2551         self.assertEqual(setxml.find("./vcpus/vcpu/[@id='3']").attrib["enabled"], "yes")
2552         self.assertEqual(
2553             setxml.find("./vcpus/vcpu/[@id='3']").attrib["hotpluggable"], "no"
2554         )
2555         self.assertEqual(
2556             setxml.find("./vcpus/vcpu/[@id='3']").attrib.get("order"), None
2557         )
2558         vcpus_none = {"vcpus": None}
2559         self.assertEqual(
2560             {
2561                 "definition": True,
2562                 "disk": {"attached": [], "detached": [], "updated": []},
2563                 "interface": {"attached": [], "detached": []},
2564             },
2565             virt.update("vm_with_existing_param", cpu=vcpus_none),
2566         )
2567         setxml = ET.fromstring(define_mock.call_args[0][0])
2568         self.assertEqual(setxml.find("vcpus"), None)
2569         cpu_atr_none = {"match": None, "mode": None, "check": None}
2570         self.assertEqual(
2571             {
2572                 "definition": True,
2573                 "disk": {"attached": [], "detached": [], "updated": []},
2574                 "interface": {"attached": [], "detached": []},
2575             },
2576             virt.update("vm_with_existing_param", cpu=cpu_atr_none),
2577         )
2578         setxml = ET.fromstring(define_mock.call_args[0][0])
2579         self.assertEqual(setxml.find("cpu").attrib, {})
2580         cpu_atr_mn = {"match": None}
2581         self.assertEqual(
2582             {
2583                 "definition": True,
2584                 "disk": {"attached": [], "detached": [], "updated": []},
2585                 "interface": {"attached": [], "detached": []},
2586             },
2587             virt.update("vm_with_existing_param", cpu=cpu_atr_mn),
2588         )
2589         setxml = ET.fromstring(define_mock.call_args[0][0])
2590         self.assertEqual(setxml.find("cpu").attrib.get("match"), None)
2591         self.assertEqual(setxml.find("cpu").attrib.get("mode"), "custom")
2592         self.assertEqual(setxml.find("cpu").attrib.get("check"), "full")
2593         cpu_model_none = {"model": None}
2594         self.assertEqual(
2595             {
2596                 "definition": True,
2597                 "disk": {"attached": [], "detached": [], "updated": []},
2598                 "interface": {"attached": [], "detached": []},
2599             },
2600             virt.update("vm_with_existing_param", cpu=cpu_model_none),
2601         )
2602         setxml = ET.fromstring(define_mock.call_args[0][0])
2603         self.assertEqual(setxml.find("cpu").find("model"), None)
2604         cpu_model_atr_none = {
2605             "model": {"name": "coresolo", "fallback": "forbid", "vendor_id": None}
2606         }
2607         self.assertEqual(
2608             {
2609                 "definition": True,
2610                 "disk": {"attached": [], "detached": [], "updated": []},
2611                 "interface": {"attached": [], "detached": []},
2612             },
2613             virt.update("vm_with_existing_param", cpu=cpu_model_atr_none),
2614         )
2615         setxml = ET.fromstring(define_mock.call_args[0][0])
2616         self.assertEqual(setxml.find("cpu").find("model").attrib.get("vendor_id"), None)
2617         self.assertEqual(
2618             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2619         )
2620         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2621         cpu_model_atr = {
2622             "model": {
2623                 "name": "coresolo",
2624                 "fallback": "forbid",
2625                 "vendor_id": "AuthenticAMD",
2626             }
2627         }
2628         self.assertEqual(
2629             {
2630                 "definition": True,
2631                 "disk": {"attached": [], "detached": [], "updated": []},
2632                 "interface": {"attached": [], "detached": []},
2633             },
2634             virt.update("vm_with_existing_param", cpu=cpu_model_atr),
2635         )
2636         setxml = ET.fromstring(define_mock.call_args[0][0])
2637         self.assertEqual(
2638             setxml.find("cpu").find("model").attrib.get("fallback"), "forbid"
2639         )
2640         self.assertEqual(
2641             setxml.find("cpu").find("model").attrib.get("vendor_id"), "AuthenticAMD"
2642         )
2643         self.assertEqual(setxml.find("cpu").find("model").text, "coresolo")
2644         cpu_vendor = {"vendor": "AMD"}
2645         self.assertEqual(
2646             {
2647                 "definition": True,
2648                 "disk": {"attached": [], "detached": [], "updated": []},
2649                 "interface": {"attached": [], "detached": []},
2650             },
2651             virt.update("vm_with_existing_param", cpu=cpu_vendor),
2652         )
2653         setxml = ET.fromstring(define_mock.call_args[0][0])
2654         self.assertEqual(setxml.find("cpu").find("vendor").text, "AMD")
2655         cpu_vendor_none = {"vendor": None}
2656         self.assertEqual(
2657             {
2658                 "definition": True,
2659                 "disk": {"attached": [], "detached": [], "updated": []},
2660                 "interface": {"attached": [], "detached": []},
2661             },
2662             virt.update("vm_with_existing_param", cpu=cpu_vendor_none),
2663         )
2664         setxml = ET.fromstring(define_mock.call_args[0][0])
2665         self.assertEqual(setxml.find("cpu").find("vendor"), None)
2666         cpu_topology = {"topology": {"sockets": 1, "cores": 12, "threads": 1}}
2667         self.assertEqual(
2668             {
2669                 "definition": True,
2670                 "disk": {"attached": [], "detached": [], "updated": []},
2671                 "interface": {"attached": [], "detached": []},
2672             },
2673             virt.update("vm_with_existing_param", cpu=cpu_topology),
2674         )
2675         setxml = ET.fromstring(define_mock.call_args[0][0])
2676         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("sockets"), "1")
2677         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2678         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2679         cpu_topology_atr_none = {
2680             "topology": {"sockets": None, "cores": 12, "threads": 1}
2681         }
2682         self.assertEqual(
2683             {
2684                 "definition": True,
2685                 "disk": {"attached": [], "detached": [], "updated": []},
2686                 "interface": {"attached": [], "detached": []},
2687             },
2688             virt.update("vm_with_existing_param", cpu=cpu_topology_atr_none),
2689         )
2690         setxml = ET.fromstring(define_mock.call_args[0][0])
2691         self.assertEqual(
2692             setxml.find("cpu").find("topology").attrib.get("sockets"), None
2693         )
2694         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("cores"), "12")
2695         self.assertEqual(setxml.find("cpu").find("topology").attrib.get("threads"), "1")
2696         cpu_topology_none = {"topology": None}
2697         self.assertEqual(
2698             {
2699                 "definition": True,
2700                 "disk": {"attached": [], "detached": [], "updated": []},
2701                 "interface": {"attached": [], "detached": []},
2702             },
2703             virt.update("vm_with_existing_param", cpu=cpu_topology_none),
2704         )
2705         setxml = ET.fromstring(define_mock.call_args[0][0])
2706         self.assertEqual(setxml.find("cpu").find("topology"), None)
2707         cpu_cache = {"cache": {"mode": "passthrough", "level": 2}}
2708         self.assertEqual(
2709             {
2710                 "definition": True,
2711                 "disk": {"attached": [], "detached": [], "updated": []},
2712                 "interface": {"attached": [], "detached": []},
2713             },
2714             virt.update("vm_with_existing_param", cpu=cpu_cache),
2715         )
2716         setxml = ET.fromstring(define_mock.call_args[0][0])
2717         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), "2")
2718         self.assertEqual(
2719             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2720         )
2721         cpu_cache_atr_none = {"cache": {"mode": "passthrough", "level": None}}
2722         self.assertEqual(
2723             {
2724                 "definition": True,
2725                 "disk": {"attached": [], "detached": [], "updated": []},
2726                 "interface": {"attached": [], "detached": []},
2727             },
2728             virt.update("vm_with_existing_param", cpu=cpu_cache_atr_none),
2729         )
2730         setxml = ET.fromstring(define_mock.call_args[0][0])
2731         self.assertEqual(setxml.find("cpu").find("cache").attrib.get("level"), None)
2732         self.assertEqual(
2733             setxml.find("cpu").find("cache").attrib.get("mode"), "passthrough"
2734         )
2735         cpu_cache_none = {"cache": None}
2736         self.assertEqual(
2737             {
2738                 "definition": True,
2739                 "disk": {"attached": [], "detached": [], "updated": []},
2740                 "interface": {"attached": [], "detached": []},
2741             },
2742             virt.update("vm_with_existing_param", cpu=cpu_cache_none),
2743         )
2744         setxml = ET.fromstring(define_mock.call_args[0][0])
2745         self.assertEqual(setxml.find("cpu").find("cache"), None)
2746         cpu_feature = {"features": {"lahf_lm": "require", "pcid": "optional"}}
2747         self.assertEqual(
2748             {
2749                 "definition": True,
2750                 "disk": {"attached": [], "detached": [], "updated": []},
2751                 "interface": {"attached": [], "detached": []},
2752             },
2753             virt.update("vm_with_existing_param", cpu=cpu_feature),
2754         )
2755         setxml = ET.fromstring(define_mock.call_args[0][0])
2756         self.assertEqual(
2757             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2758         )
2759         self.assertEqual(
2760             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2761             "require",
2762         )
2763         cpu_feature_atr_none = {"features": {"pcid": "optional", "lahf_lm": "disable"}}
2764         self.assertEqual(
2765             {
2766                 "definition": True,
2767                 "disk": {"attached": [], "detached": [], "updated": []},
2768                 "interface": {"attached": [], "detached": []},
2769             },
2770             virt.update("vm_with_existing_param", cpu=cpu_feature_atr_none),
2771         )
2772         setxml = ET.fromstring(define_mock.call_args[0][0])
2773         self.assertEqual(
2774             setxml.find("./cpu/feature[@name='lahf_lm']").attrib.get("policy"),
2775             "disable",
2776         )
2777         self.assertEqual(
2778             setxml.find("./cpu/feature[@name='pcid']").attrib.get("policy"), "optional"
2779         )
2780         cpu_feature_none = {"features": {"lahf_lm": None, "pcid": None}}
2781         self.assertEqual(
2782             {
2783                 "definition": True,
2784                 "disk": {"attached": [], "detached": [], "updated": []},
2785                 "interface": {"attached": [], "detached": []},
2786             },
2787             virt.update("vm_with_existing_param", cpu=cpu_feature_none),
2788         )
2789         setxml = ET.fromstring(define_mock.call_args[0][0])
2790         self.assertEqual(setxml.find("./cpu/feature"), None)
2791         numa_cell = {
2792             "numa": {
2793                 0: {
2794                     "cpus": "0-6",
2795                     "memory": "512m",
2796                     "discard": True,
2797                     "distances": {0: 15, 1: 16, 2: 17, 3: 18},
2798                 },
2799                 1: {
2800                     "cpus": "7-12",
2801                     "memory": "2g",
2802                     "discard": True,
2803                     "memAccess": "shared",
2804                     "distances": {0: 23, 1: 24, 2: 25, 3: 26},
2805                 },
2806             }
2807         }
2808         self.assertEqual(
2809             {
2810                 "definition": True,
2811                 "disk": {"attached": [], "detached": [], "updated": []},
2812                 "interface": {"attached": [], "detached": []},
2813             },
2814             virt.update("vm_with_existing_param", cpu=numa_cell),
2815         )
2816         setxml = ET.fromstring(define_mock.call_args[0][0])
2817         self.assertEqual(
2818             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2819             ",".join([str(i) for i in range(0, 7)]),
2820         )
2821         self.assertEqual(
2822             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2823             str(512 * 1024 ** 2),
2824         )
2825         self.assertEqual(
2826             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2827             "bytes",
2828         )
2829         self.assertEqual(
2830             setxml.find("./cpu/numa/cell/[@id='0']").attrib["discard"], "yes"
2831         )
2832         self.assertEqual(
2833             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2834                 "value"
2835             ],
2836             "15",
2837         )
2838         self.assertEqual(
2839             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']").attrib[
2840                 "value"
2841             ],
2842             "16",
2843         )
2844         self.assertEqual(
2845             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2846                 "value"
2847             ],
2848             "17",
2849         )
2850         self.assertEqual(
2851             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2852                 "value"
2853             ],
2854             "18",
2855         )
2856         self.assertEqual(
2857             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2858             ",".join([str(i) for i in range(7, 13)]),
2859         )
2860         self.assertEqual(
2861             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2862             str(int(2 * 1024 ** 3)),
2863         )
2864         self.assertEqual(
2865             setxml.find("./cpu/numa/cell/[@id='1']").get("unit"),
2866             "bytes",
2867         )
2868         self.assertEqual(
2869             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2870         )
2871         self.assertEqual(
2872             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memAccess"], "shared"
2873         )
2874         self.assertEqual(
2875             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2876                 "value"
2877             ],
2878             "23",
2879         )
2880         self.assertEqual(
2881             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2882                 "value"
2883             ],
2884             "24",
2885         )
2886         self.assertEqual(
2887             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2888                 "value"
2889             ],
2890             "25",
2891         )
2892         self.assertEqual(
2893             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']").attrib[
2894                 "value"
2895             ],
2896             "26",
2897         )
2898         numa_cell_atr_none = {
2899             "numa": {
2900                 "0": {
2901                     "cpus": "0-6",
2902                     "memory": "512m",
2903                     "discard": False,
2904                     "distances": {0: 15, 2: 17, 3: 18},
2905                 },
2906                 "1": {
2907                     "cpus": "7-12",
2908                     "memory": "2g",
2909                     "discard": True,
2910                     "distances": {0: 23, 1: 24, 2: 25},
2911                 },
2912             }
2913         }
2914         self.assertEqual(
2915             {
2916                 "definition": True,
2917                 "disk": {"attached": [], "detached": [], "updated": []},
2918                 "interface": {"attached": [], "detached": []},
2919             },
2920             virt.update("vm_with_existing_param", cpu=numa_cell_atr_none),
2921         )
2922         setxml = ET.fromstring(define_mock.call_args[0][0])
2923         self.assertEqual(
2924             setxml.find("./cpu/numa/cell/[@id='0']").attrib["cpus"],
2925             ",".join([str(i) for i in range(0, 7)]),
2926         )
2927         self.assertEqual(
2928             setxml.find("./cpu/numa/cell/[@id='0']").attrib["memory"],
2929             str(512 * 1024 ** 2),
2930         )
2931         self.assertEqual(
2932             setxml.find("./cpu/numa/cell/[@id='0']").get("unit"),
2933             "bytes",
2934         )
2935         self.assertEqual(
2936             setxml.find("./cpu/numa/cell/[@id='0']").attrib.get("discard"), "no"
2937         )
2938         self.assertEqual(
2939             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='0']").attrib[
2940                 "value"
2941             ],
2942             "15",
2943         )
2944         self.assertEqual(
2945             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='1']"), None
2946         )
2947         self.assertEqual(
2948             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='2']").attrib[
2949                 "value"
2950             ],
2951             "17",
2952         )
2953         self.assertEqual(
2954             setxml.find("./cpu/numa/cell/[@id='0']/distances/sibling/[@id='3']").attrib[
2955                 "value"
2956             ],
2957             "18",
2958         )
2959         self.assertEqual(
2960             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2961             ",".join([str(i) for i in range(7, 13)]),
2962         )
2963         self.assertEqual(
2964             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2965             str(int(2 * 1024 ** 3)),
2966         )
2967         self.assertEqual(
2968             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
2969         )
2970         self.assertEqual(
2971             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
2972                 "value"
2973             ],
2974             "23",
2975         )
2976         self.assertEqual(
2977             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
2978                 "value"
2979             ],
2980             "24",
2981         )
2982         self.assertEqual(
2983             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
2984                 "value"
2985             ],
2986             "25",
2987         )
2988         self.assertEqual(
2989             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"), None
2990         )
2991         self.assertEqual(
2992             setxml.find("./cpu/numa/cell/[@id='1']").attrib["cpus"],
2993             ",".join([str(i) for i in range(7, 13)]),
2994         )
2995         self.assertEqual(
2996             setxml.find("./cpu/numa/cell/[@id='1']").attrib["memory"],
2997             str(int(1024 ** 3 * 2)),
2998         )
2999         self.assertEqual(
3000             setxml.find("./cpu/numa/cell/[@id='1']").attrib["discard"], "yes"
3001         )
3002         self.assertEqual(
3003             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='0']").attrib[
3004                 "value"
3005             ],
3006             "23",
3007         )
3008         self.assertEqual(
3009             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='1']").attrib[
3010                 "value"
3011             ],
3012             "24",
3013         )
3014         self.assertEqual(
3015             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='2']").attrib[
3016                 "value"
3017             ],
3018             "25",
3019         )
3020         self.assertEqual(
3021             setxml.find("./cpu/numa/cell/[@id='1']/distances/sibling/[@id='3']"),
3022             None,
3023         )
3024     def test_update_memtune_params(self):
3025         xml_with_memtune_params = """
3026             &lt;domain type='kvm' id='8'&gt;
3027               &lt;name&gt;vm_with_boot_param&lt;/name&gt;
3028               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3029               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3030               &lt;maxMemory slots="12" unit="bytes"&gt;1048576&lt;/maxMemory&gt;
3031               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3032               &lt;memtune&gt;
3033                 &lt;hard_limit unit="KiB"&gt;1048576&lt;/hard_limit&gt;
3034                 &lt;soft_limit unit="KiB"&gt;2097152&lt;/soft_limit&gt;
3035                 &lt;swap_hard_limit unit="KiB"&gt;2621440&lt;/swap_hard_limit&gt;
3036                 &lt;min_guarantee unit='KiB'&gt;671088&lt;/min_guarantee&gt;
3037               &lt;/memtune&gt;
3038               &lt;os&gt;
3039                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3040               &lt;/os&gt;
3041             &lt;/domain&gt;
3042         """
3043         domain_mock = self.set_mock_vm("vm_with_memtune_param", xml_with_memtune_params)
3044         domain_mock.OSType = MagicMock(return_value="hvm")
3045         define_mock = MagicMock(return_value=True)
3046         self.mock_conn.defineXML = define_mock
3047         memtune_new_val = {
3048             "boot": "0.7g",
3049             "current": "2.5g",
3050             "max": "3096m",
3051             "slots": "10",
3052             "soft_limit": "2048m",
3053             "hard_limit": "1024",
3054             "swap_hard_limit": "2.5g",
3055             "min_guarantee": "1 g",
3056         }
3057         domain_mock.setMemoryFlags.return_value = 0
3058         self.assertEqual(
3059             {
3060                 "definition": True,
3061                 "disk": {"attached": [], "detached": [], "updated": []},
3062                 "interface": {"attached": [], "detached": []},
3063                 "mem": True,
3064             },
3065             virt.update("vm_with_memtune_param", mem=memtune_new_val),
3066         )
3067         self.assertEqual(
3068             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3069         )
3070         setxml = ET.fromstring(define_mock.call_args[0][0])
3071         self.assertEqual(
3072             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3073         )
3074         self.assertEqual(
3075             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3076         )
3077         self.assertEqual(
3078             setxml.find("memtune").find("swap_hard_limit").text,
3079             str(int(2.5 * 1024 ** 2)),
3080         )
3081         self.assertEqual(
3082             setxml.find("memtune").find("swap_hard_limit").get("unit"),
3083             "KiB",
3084         )
3085         self.assertEqual(
3086             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3087         )
3088         self.assertEqual(
3089             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3090         )
3091         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3092         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3093         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3094         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3095         max_slot_reverse = {
3096             "slots": "10",
3097             "max": "3096m",
3098         }
3099         self.assertEqual(
3100             {
3101                 "definition": True,
3102                 "disk": {"attached": [], "detached": [], "updated": []},
3103                 "interface": {"attached": [], "detached": []},
3104             },
3105             virt.update("vm_with_memtune_param", mem=max_slot_reverse),
3106         )
3107         setxml = ET.fromstring(define_mock.call_args[0][0])
3108         self.assertEqual(setxml.find("maxMemory").text, str(3096 * 1024 ** 2))
3109         self.assertEqual(setxml.find("maxMemory").get("unit"), "bytes")
3110         self.assertEqual(setxml.find("maxMemory").attrib.get("slots"), "10")
3111         max_swap_none = {
3112             "boot": "0.7g",
3113             "current": "2.5g",
3114             "max": None,
3115             "slots": "10",
3116             "soft_limit": "2048m",
3117             "hard_limit": "1024",
3118             "swap_hard_limit": None,
3119             "min_guarantee": "1 g",
3120         }
3121         domain_mock.setMemoryFlags.reset_mock()
3122         self.assertEqual(
3123             {
3124                 "definition": True,
3125                 "disk": {"attached": [], "detached": [], "updated": []},
3126                 "interface": {"attached": [], "detached": []},
3127                 "mem": True,
3128             },
3129             virt.update("vm_with_memtune_param", mem=max_swap_none),
3130         )
3131         self.assertEqual(
3132             domain_mock.setMemoryFlags.call_args[0][0], int(2.5 * 1024 ** 2)
3133         )
3134         setxml = ET.fromstring(define_mock.call_args[0][0])
3135         self.assertEqual(
3136             setxml.find("memtune").find("soft_limit").text, str(2048 * 1024)
3137         )
3138         self.assertEqual(
3139             setxml.find("memtune").find("hard_limit").text, str(1024 * 1024)
3140         )
3141         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3142         self.assertEqual(
3143             setxml.find("memtune").find("min_guarantee").text, str(1 * 1024 ** 3)
3144         )
3145         self.assertEqual(
3146             setxml.find("memtune").find("min_guarantee").attrib.get("unit"), "bytes"
3147         )
3148         self.assertEqual(setxml.find("maxMemory").text, None)
3149         self.assertEqual(setxml.find("currentMemory").text, str(int(2.5 * 1024 ** 3)))
3150         self.assertEqual(setxml.find("memory").text, str(int(0.7 * 1024 ** 3)))
3151         memtune_none = {
3152             "soft_limit": None,
3153             "hard_limit": None,
3154             "swap_hard_limit": None,
3155             "min_guarantee": None,
3156         }
3157         self.assertEqual(
3158             {
3159                 "definition": True,
3160                 "disk": {"attached": [], "detached": [], "updated": []},
3161                 "interface": {"attached": [], "detached": []},
3162             },
3163             virt.update("vm_with_memtune_param", mem=memtune_none),
3164         )
3165         setxml = ET.fromstring(define_mock.call_args[0][0])
3166         self.assertEqual(setxml.find("memtune").find("soft_limit"), None)
3167         self.assertEqual(setxml.find("memtune").find("hard_limit"), None)
3168         self.assertEqual(setxml.find("memtune").find("swap_hard_limit"), None)
3169         self.assertEqual(setxml.find("memtune").find("min_guarantee"), None)
3170         max_none = {
3171             "max": None,
3172         }
3173         self.assertEqual(
3174             {
3175                 "definition": True,
3176                 "disk": {"attached": [], "detached": [], "updated": []},
3177                 "interface": {"attached": [], "detached": []},
3178             },
3179             virt.update("vm_with_memtune_param", mem=max_none),
3180         )
3181         setxml = ET.fromstring(define_mock.call_args[0][0])
3182         self.assertEqual(setxml.find("maxMemory"), None)
3183         self.assertEqual(setxml.find("currentMemory").text, str(int(1 * 1024 ** 2)))
3184         self.assertEqual(setxml.find("memory").text, str(int(1 * 1024 ** 2)))
3185     def test_update_exist_memorybacking_params(self):
3186         xml_with_memback_params = """
3187             &lt;domain type='kvm' id='8'&gt;
3188               &lt;name&gt;vm_with_memback_param&lt;/name&gt;
3189               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3190               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3191               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3192               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3193               &lt;memoryBacking&gt;
3194                 &lt;hugepages&gt;
3195                   &lt;page size="2048" unit="KiB"/&gt;
3196                   &lt;page size="3145728" nodeset="1-4,^3" unit="KiB"/&gt;
3197                   &lt;page size="1048576" nodeset="3" unit="KiB"/&gt;
3198                 &lt;/hugepages&gt;
3199                 &lt;nosharepages/&gt;
3200                 &lt;locked/&gt;
3201                 &lt;source type="file"/&gt;
3202                 &lt;access mode="shared"/&gt;
3203                 &lt;discard/&gt;
3204               &lt;/memoryBacking&gt;
3205               &lt;os&gt;
3206                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3207               &lt;/os&gt;
3208               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
3209             &lt;/domain&gt;
3210         """
3211         domain_mock = self.set_mock_vm("vm_with_memback_param", xml_with_memback_params)
3212         domain_mock.OSType = MagicMock(return_value="hvm")
3213         define_mock = MagicMock(return_value=True)
3214         self.mock_conn.defineXML = define_mock
3215         mem_back_param = {
3216             "hugepages": [
3217                 {"nodeset": "1-4,^3", "size": "1g"},
3218                 {"nodeset": "3", "size": "2g"},
3219             ],
3220             "nosharepages": None,
3221             "locked": None,
3222             "source": "anonymous",
3223             "access": "private",
3224             "allocation": "ondemand",
3225             "discard": None,
3226         }
3227         self.assertEqual(
3228             {
3229                 "definition": True,
3230                 "disk": {"attached": [], "detached": [], "updated": []},
3231                 "interface": {"attached": [], "detached": []},
3232             },
3233             virt.update("vm_with_memback_param", mem=mem_back_param),
3234         )
3235         setxml = ET.fromstring(define_mock.call_args[0][0])
3236         self.assertDictEqual(
3237             {
3238                 p.get("nodeset"): {"size": p.get("size"), "unit": p.get("unit")}
3239                 for p in setxml.findall("memoryBacking/hugepages/page")
3240             },
3241             {
3242                 "1,2,4": {"size": str(1024 ** 3), "unit": "bytes"},
3243                 "3": {"size": str(2 * 1024 ** 3), "unit": "bytes"},
3244             },
3245         )
3246         self.assertEqual(setxml.find("./memoryBacking/nosharepages"), None)
3247         self.assertEqual(setxml.find("./memoryBacking/locked"), None)
3248         self.assertEqual(
3249             setxml.find("./memoryBacking/source").attrib["type"], "anonymous"
3250         )
3251         self.assertEqual(
3252             setxml.find("./memoryBacking/access").attrib["mode"], "private"
3253         )
3254         self.assertEqual(
3255             setxml.find("./memoryBacking/allocation").attrib["mode"], "ondemand"
3256         )
3257         self.assertEqual(setxml.find("./memoryBacking/discard"), None)
3258         unchanged_page = {
3259             "hugepages": [
3260                 {"size": "2m"},
3261                 {"nodeset": "1-4,^3", "size": "3g"},
3262                 {"nodeset": "3", "size": "1g"},
3263             ],
3264         }
3265         self.assertEqual(
3266             {
3267                 "definition": False,
3268                 "disk": {"attached": [], "detached": [], "updated": []},
3269                 "interface": {"attached": [], "detached": []},
3270             },
3271             virt.update("vm_with_memback_param", mem=unchanged_page),
3272         )
3273     def test_update_iothreads_params(self):
3274         xml_with_iothreads_params = """
3275             &lt;domain type='kvm' id='8'&gt;
3276               &lt;name&gt;xml_with_iothreads_params&lt;/name&gt;
3277               &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3278               &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3279               &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3280               &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3281               &lt;iothreads&gt;6&lt;/iothreads&gt;
3282               &lt;os&gt;
3283                 &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3284               &lt;/os&gt;
3285             &lt;/domain&gt;
3286         """
3287         domain_mock = self.set_mock_vm(
3288             "xml_with_iothreads_params", xml_with_iothreads_params
3289         )
3290         domain_mock.OSType = MagicMock(return_value="hvm")
3291         define_mock = MagicMock(return_value=True)
3292         self.mock_conn.defineXML = define_mock
3293         self.assertEqual(
3294             {
3295                 "definition": True,
3296                 "disk": {"attached": [], "detached": [], "updated": []},
3297                 "interface": {"attached": [], "detached": []},
3298             },
3299             virt.update("xml_with_iothreads_params", cpu={"iothreads": 7}),
3300         )
3301         setxml = ET.fromstring(define_mock.call_args[0][0])
3302         self.assertEqual(setxml.find("iothreads").text, "7")
3303     def test_update_cputune_paramters(self):
3304         xml_with_cputune_params = """
3305                     &lt;domain type='kvm' id='8'&gt;
3306                       &lt;name&gt;xml_with_cputune_params&lt;/name&gt;
3307                       &lt;memory unit='KiB'&gt;1048576&lt;/memory&gt;
3308                       &lt;currentMemory unit='KiB'&gt;1048576&lt;/currentMemory&gt;
3309                       &lt;maxMemory slots="12" unit="KiB"&gt;1048576&lt;/maxMemory&gt;
3310                       &lt;vcpu placement='auto'&gt;1&lt;/vcpu&gt;
3311                       &lt;iothreads&gt;4&lt;/iothreads&gt;
3312                       &lt;cputune&gt;
3313                         &lt;shares&gt;2048&lt;/shares&gt;
3314                         &lt;period&gt;1000000&lt;/period&gt;
3315                         &lt;quota&gt;-1&lt;/quota&gt;
3316                         &lt;global_period&gt;1000000&lt;/global_period&gt;
3317                         &lt;global_quota&gt;-1&lt;/global_quota&gt;
3318                         &lt;emulator_period&gt;1000000&lt;/emulator_period&gt;
3319                         &lt;emulator_quota&gt;-1&lt;/emulator_quota&gt;
3320                         &lt;iothread_period&gt;1000000&lt;/iothread_period&gt;
3321                         &lt;iothread_quota&gt;-1&lt;/iothread_quota&gt;
3322                         &lt;vcpupin vcpu="0" cpuset="0-2"/&gt;
3323                         &lt;vcpupin vcpu="1" cpuset="3"/&gt;
3324                         &lt;vcpupin vcpu="2" cpuset="4"/&gt;
3325                         &lt;vcpupin vcpu="3" cpuset="5-7"/&gt;
3326                         &lt;emulatorpin cpuset="1-2"/&gt;
3327                         &lt;iothreadpin iothread="1" cpuset="1-5"/&gt;
3328                         &lt;iothreadpin iothread="2" cpuset="6-7"/&gt;
3329                         &lt;vcpusched vcpus="0" scheduler="idle" priority="3"/&gt;
3330                         &lt;vcpusched vcpus="1" scheduler="rr" priority="1"/&gt;
3331                         &lt;vcpusched vcpus="2" scheduler="fifo" priority="2"/&gt;
3332                         &lt;iothreadsched iothreads="4" scheduler="fifo"/&gt;
3333                         &lt;emulatorsched scheduler="idle"/&gt;
3334                         &lt;cachetune vcpus="0-4"&gt;
3335                           &lt;cache id="0" level="2" type="both" size="4" unit="KiB"/&gt;
3336                           &lt;cache id="1" level="2" type="both" size="4" unit="KiB"/&gt;
3337                           &lt;monitor level="5" vcpus="0-2"/&gt;
3338                           &lt;monitor level="6" vcpus="1-3"/&gt;
3339                         &lt;/cachetune&gt;
3340                         &lt;cachetune vcpus="5-8"&gt;
3341                           &lt;monitor level="5" vcpus="5-6"/&gt;
3342                           &lt;monitor level="3" vcpus="7-8"/&gt;
3343                         &lt;/cachetune&gt;
3344                         &lt;memorytune vcpus="0-6"&gt;
3345                           &lt;node id="0" bandwidth="45"/&gt;
3346                         &lt;/memorytune&gt;
3347                         &lt;memorytune vcpus="7-8"&gt;
3348                           &lt;node id="0" bandwidth="120"/&gt;
3349                         &lt;/memorytune&gt;
3350                       &lt;/cputune&gt;
3351                       &lt;os&gt;
3352                         &lt;type arch='x86_64' machine='pc-i440fx-2.6'&gt;hvm&lt;/type&gt;
3353                       &lt;/os&gt;
3354                     &lt;/domain&gt;
3355                 """
3356         domain_mock = self.set_mock_vm(
3357             "xml_with_cputune_params", xml_with_cputune_params
3358         )
3359         domain_mock.OSType = MagicMock(return_value="hvm")
3360         define_mock = MagicMock(return_value=True)
3361         self.mock_conn.defineXML = define_mock
3362         cputune = {
3363             "shares": 1024,
3364             "period": 5000,
3365             "quota": -20,
3366             "global_period": 4000,
3367             "global_quota": -30,
3368             "emulator_period": 3000,
3369             "emulator_quota": -4,
3370             "iothread_period": 7000,
3371             "iothread_quota": -5,
3372             "vcpupin": {0: "1-4,^2", 1: "0,1", 2: "2,3", 3: "0,4"},
3373             "emulatorpin": "1-3",
3374             "iothreadpin": {1: "5-6", 2: "7-8"},
3375             "vcpusched": [
3376                 {"scheduler": "fifo", "priority": 1, "vcpus": "0"},
3377                 {"scheduler": "fifo", "priority": 2, "vcpus": "1"},
3378                 {"scheduler": "idle", "priority": 3, "vcpus": "2"},
3379             ],
3380             "iothreadsched": [
3381                 {"scheduler": "batch", "iothreads": "5-7", "priority": 1}
3382             ],
3383             "emulatorsched": {"scheduler": "rr", "priority": 2},
3384             "cachetune": {
3385                 "0-3": {
3386                     0: {"level": 3, "type": "both", "size": 3},
3387                     1: {"level": 3, "type": "both", "size": 3},
3388                     "monitor": {1: 3, "0-3": 3},
3389                 },
3390                 "4-5": {"monitor": {4: 3, 5: 2}},
3391             },
3392             "memorytune": {"0-2": {0: 60}, "3-4": {0: 50, 1: 70}},
3393         }
3394         self.assertEqual(
3395             {
3396                 "definition": True,
3397                 "disk": {"attached": [], "detached": [], "updated": []},
3398                 "interface": {"attached": [], "detached": []},
3399             },
3400             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3401         )
3402         setxml = ET.fromstring(define_mock.call_args[0][0])
3403         self.assertEqual(setxml.find("cputune").find("shares").text, "1024")
3404         self.assertEqual(setxml.find("cputune").find("period").text, "5000")
3405         self.assertEqual(setxml.find("cputune").find("quota").text, "-20")
3406         self.assertEqual(setxml.find("cputune").find("global_period").text, "4000")
3407         self.assertEqual(setxml.find("cputune").find("global_quota").text, "-30")
3408         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "3000")
3409         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3410         self.assertEqual(setxml.find("cputune").find("iothread_period").text, "7000")
3411         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3412         self.assertEqual(
3413             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3414             "1,3,4",
3415         )
3416         self.assertEqual(
3417             setxml.find("cputune").find("vcpupin[@vcpu='1']").attrib.get("cpuset"),
3418             "0,1",
3419         )
3420         self.assertEqual(
3421             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3422             "2,3",
3423         )
3424         self.assertEqual(
3425             setxml.find("cputune").find("vcpupin[@vcpu='3']").attrib.get("cpuset"),
3426             "0,4",
3427         )
3428         self.assertEqual(
3429             setxml.find("cputune").find("emulatorpin").attrib.get("cpuset"), "1,2,3"
3430         )
3431         self.assertEqual(
3432             setxml.find("cputune")
3433             .find("iothreadpin[@iothread='1']")
3434             .attrib.get("cpuset"),
3435             "5,6",
3436         )
3437         self.assertEqual(
3438             setxml.find("cputune")
3439             .find("iothreadpin[@iothread='2']")
3440             .attrib.get("cpuset"),
3441             "7,8",
3442         )
3443         self.assertDictEqual(
3444             {
3445                 s.get("vcpus"): {
3446                     "scheduler": s.get("scheduler"),
3447                     "priority": s.get("priority"),
3448                 }
3449                 for s in setxml.findall("cputune/vcpusched")
3450             },
3451             {
3452                 "0": {"scheduler": "fifo", "priority": "1"},
3453                 "1": {"scheduler": "fifo", "priority": "2"},
3454                 "2": {"scheduler": "idle", "priority": "3"},
3455             },
3456         )
3457         self.assertDictEqual(
3458             {
3459                 s.get("iothreads"): {
3460                     "scheduler": s.get("scheduler"),
3461                     "priority": s.get("priority"),
3462                 }
3463                 for s in setxml.findall("cputune/iothreadsched")
3464             },
3465             {"5,6,7": {"scheduler": "batch", "priority": "1"}},
3466         )
3467         self.assertEqual(setxml.find("cputune/emulatorsched").get("scheduler"), "rr")
3468         self.assertEqual(setxml.find("cputune/emulatorsched").get("priority"), "2")
3469         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3470         self.assertEqual(
3471             setxml.find(
3472                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3473             ).attrib.get("level"),
3474             "3",
3475         )
3476         self.assertEqual(
3477             setxml.find(
3478                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3479             ).attrib.get("type"),
3480             "both",
3481         )
3482         self.assertEqual(
3483             setxml.find(
3484                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"
3485             ).attrib.get("level"),
3486             "3",
3487         )
3488         self.assertNotEqual(
3489             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1']"),
3490             None,
3491         )
3492         self.assertNotEqual(
3493             setxml.find("./cputune/cachetune[@vcpus='4,5']").attrib.get("vcpus"), None
3494         )
3495         self.assertEqual(
3496             setxml.find("./cputune/cachetune[@vcpus='4,5']/cache[@id='0']"), None
3497         )
3498         self.assertEqual(
3499             setxml.find(
3500                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='4']"
3501             ).attrib.get("level"),
3502             "3",
3503         )
3504         self.assertEqual(
3505             setxml.find(
3506                 "./cputune/cachetune[@vcpus='4,5']/monitor[@vcpus='5']"
3507             ).attrib.get("level"),
3508             "2",
3509         )
3510         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3511         self.assertEqual(
3512             setxml.find(
3513                 "./cputune/memorytune[@vcpus='0,1,2']/node[@id='0']"
3514             ).attrib.get("bandwidth"),
3515             "60",
3516         )
3517         self.assertNotEqual(setxml.find("./cputune/memorytune[@vcpus='3,4']"), None)
3518         self.assertEqual(
3519             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3520                 "bandwidth"
3521             ),
3522             "50",
3523         )
3524         self.assertEqual(
3525             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3526                 "bandwidth"
3527             ),
3528             "70",
3529         )
3530         cputune = {
3531             "shares": None,
3532             "period": 20000,
3533             "quota": None,
3534             "global_period": 5000,
3535             "global_quota": None,
3536             "emulator_period": 2000,
3537             "emulator_quota": -4,
3538             "iothread_period": None,
3539             "iothread_quota": -5,
3540             "vcpupin": {0: "1-4,^2", 2: "2,4"},
3541             "emulatorpin": None,
3542             "iothreadpin": {1: "5-6"},
3543             "vcpusched": [{"scheduler": "idle", "priority": 5, "vcpus": "1"}],
3544             "iothreadsched": None,
3545             "cachetune": {
3546                 "0-3": {
3547                     0: {"level": 4, "type": "data", "size": 7},
3548                     "monitor": {"1-2": 11},
3549                 },
3550             },
3551             "memorytune": {"3-4": {0: 37, 1: 73}},
3552         }
3553         self.assertEqual(
3554             {
3555                 "definition": True,
3556                 "disk": {"attached": [], "detached": [], "updated": []},
3557                 "interface": {"attached": [], "detached": []},
3558             },
3559             virt.update("xml_with_cputune_params", cpu={"tuning": cputune}),
3560         )
3561         setxml = ET.fromstring(define_mock.call_args[0][0])
3562         self.assertEqual(setxml.find("cputune").find("shares"), None)
3563         self.assertEqual(setxml.find("cputune").find("period").text, "20000")
3564         self.assertEqual(setxml.find("cputune").find("quota"), None)
3565         self.assertEqual(setxml.find("cputune").find("global_period").text, "5000")
3566         self.assertEqual(setxml.find("cputune").find("global_quota"), None)
3567         self.assertEqual(setxml.find("cputune").find("emulator_period").text, "2000")
3568         self.assertEqual(setxml.find("cputune").find("emulator_quota").text, "-4")
3569         self.assertEqual(setxml.find("cputune").find("iothread_period"), None)
3570         self.assertEqual(setxml.find("cputune").find("iothread_quota").text, "-5")
3571         self.assertEqual(
3572             setxml.find("cputune").find("vcpupin[@vcpu='0']").attrib.get("cpuset"),
3573             "1,3,4",
3574         )
3575         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='1']"), None)
3576         self.assertEqual(
3577             setxml.find("cputune").find("vcpupin[@vcpu='2']").attrib.get("cpuset"),
3578             "2,4",
3579         )
3580         self.assertEqual(setxml.find("cputune").find("vcpupin[@vcpu='3']"), None)
3581         self.assertEqual(setxml.find("cputune").find("emulatorpin"), None)
3582         self.assertEqual(
3583             setxml.find("cputune")
3584             .find("iothreadpin[@iothread='1']")
3585             .attrib.get("cpuset"),
3586             "5,6",
3587         )
3588         self.assertEqual(
3589             setxml.find("cputune").find("iothreadpin[@iothread='2']"), None
3590         )
3591         self.assertDictEqual(
3592             {
3593                 s.get("vcpus"): {
3594                     "scheduler": s.get("scheduler"),
3595                     "priority": s.get("priority"),
3596                 }
3597                 for s in setxml.findall("cputune/vcpusched")
3598             },
3599             {"1": {"scheduler": "idle", "priority": "5"}},
3600         )
3601         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3602         self.assertIsNotNone(setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']"))
3603         self.assertEqual(
3604             setxml.find(
3605                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3606             ).attrib.get("size"),
3607             "7",
3608         )
3609         self.assertEqual(
3610             setxml.find(
3611                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3612             ).attrib.get("level"),
3613             "4",
3614         )
3615         self.assertEqual(
3616             setxml.find(
3617                 "./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='0']"
3618             ).attrib.get("type"),
3619             "data",
3620         )
3621         self.assertEqual(
3622             setxml.find(
3623                 "./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='1,2']"
3624             ).attrib.get("level"),
3625             "11",
3626         )
3627         self.assertEqual(
3628             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/monitor[@vcpus='3,4']"),
3629             None,
3630         )
3631         self.assertEqual(
3632             setxml.find("./cputune/cachetune[@vcpus='0,1,2,3']/cache[@id='1']"), None
3633         )
3634         self.assertEqual(setxml.find("./cputune/cachetune[@vcpus='4,5']"), None)
3635         self.assertEqual(setxml.find("./cputune/memorytune[@vcpus='0,1,2']"), None)
3636         self.assertEqual(
3637             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='0']").attrib.get(
3638                 "bandwidth"
3639             ),
3640             "37",
3641         )
3642         self.assertEqual(
3643             setxml.find("./cputune/memorytune[@vcpus='3,4']/node[@id='1']").attrib.get(
3644                 "bandwidth"
3645             ),
3646             "73",
3647         )
3648         cputune_subelement = {
3649             "vcpupin": None,
3650             "iothreadpin": None,
3651             "vcpusched": None,
3652             "iothreadsched": None,
3653             "cachetune": None,
3654             "memorytune": None,
3655         }
3656         self.assertEqual(
3657             {
3658                 "definition": True,
3659                 "disk": {"attached": [], "detached": [], "updated": []},
3660                 "interface": {"attached": [], "detached": []},
3661             },
3662             virt.update("xml_with_cputune_params", cpu={"tuning": cputune_subelement}),
3663         )
3664         setxml = ET.fromstring(define_mock.call_args[0][0])
3665         self.assertEqual(setxml.find("cputune").find("vcpupin"), None)
3666         self.assertEqual(setxml.find("cputune").find("iothreadpin"), None)
3667         self.assertEqual(setxml.find("cputune").find("vcpusched"), None)
3668         self.assertEqual(setxml.find("cputune").find("iothreadsched"), None)
3669         self.assertEqual(setxml.find("cputune").find("cachetune"), None)
3670         self.assertEqual(setxml.find("cputune").find("memorytune"), None)
3671     def test_handle_unit(self):
3672         valid_case = [
3673             ("2", 2097152),
3674             ("42", 44040192),
3675             ("5b", 5),
3676             ("2.3Kib", 2355),
3677             ("5.8Kb", 5800),
3678             ("16MiB", 16777216),
3679             ("20 GB", 20000000000),
3680             ("16KB", 16000),
3681             (".5k", 512),
3682             ("2.k", 2048),
3683         ]
3684         for key, val in valid_case:
3685             self.assertEqual(virt._handle_unit(key), val)
3686         invalid_case = [
3687             ("9ib", "invalid units"),
3688             ("8byte", "invalid units"),
3689             ("512bytes", "invalid units"),
3690             ("4 Kbytes", "invalid units"),
3691             ("3.4.MB", "invalid number"),
3692             ("", "invalid number"),
3693             ("bytes", "invalid number"),
3694             ("2HB", "invalid units"),
3695         ]
3696         for key, val in invalid_case:
3697             with self.assertRaises(SaltInvocationError):
3698                 virt._handle_unit(key)
3699     def test_mixed_dict_and_list_as_profile_objects(self):
3700         yaml_config = """
3701           virt:
3702              nic:
3703                 new-listonly-profile:
3704                    - bridge: br0
3705                      name: eth0
3706                    - model: virtio
3707                      name: eth1
3708                      source: test_network
3709                      type: network
3710                 new-list-with-legacy-names:
3711                    - eth0:
3712                         bridge: br0
3713                    - eth1:
3714                         bridge: br1
3715                         model: virtio
3716                 non-default-legacy-profile:
3717                    eth0:
3718                       bridge: br0
3719                    eth1:
3720                       bridge: br1
3721                       model: virtio
3722         Test virt.get_xml()
3723         domain = self.set_mock_vm("test-vm", xml)
3724         self.assertEqual(xml, virt.get_xml("test-vm"))
3725         self.assertEqual(xml, virt.get_xml(domain))
3726     def test_get_loader(self):
3727         xml = """&lt;domain type='kvm' id='7'&gt;
3728               &lt;name&gt;test-vm&lt;/name&gt;
3729               &lt;os&gt;
3730                 &lt;loader readonly='yes' type='pflash'&gt;/foo/bar&lt;/loader&gt;
3731               &lt;/os&gt;
3732             &lt;/domain&gt;
3733         """
3734         self.set_mock_vm("test-vm", xml)
3735         loader = virt.get_loader("test-vm")
3736         self.assertEqual("/foo/bar", loader["path"])
3737         self.assertEqual("yes", loader["readonly"])
3738     def test_cpu_baseline(self):
3739         capabilities_xml = dedent(
3740         Make sure that qemu-img info output is properly parsed
3741         Test virt.purge() with default parameters
3742         self.set_mock_vm("test-vm", xml)
3743         qemu_infos = """[{
3744             "virtual-size": 25769803776,
3745             "filename": "/disks/test.qcow2",
3746             "cluster-size": 65536,
3747             "format": "qcow2",
3748             "actual-size": 217088,
3749             "format-specific": {
3750                 "type": "qcow2",
3751                 "data": {
3752                     "compat": "1.1",
3753                     "lazy-refcounts": false,
3754                     "refcount-bits": 16,
3755                     "corrupt": false
3756                 }
3757             },
3758             "dirty-flag": false
3759         }]"""
3760         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3761         self.mock_popen.returncode = 0
3762         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3763             res = virt.purge("test-vm")
3764             self.assertTrue(res)
3765             mock_remove.assert_called_once()
3766             mock_remove.assert_any_call("/disks/test.qcow2")
3767     @patch("salt.modules.virt.stop", return_value=True)
3768     @patch("salt.modules.virt.undefine")
3769     def test_purge_volumes(self, mock_undefine, mock_stop):
3770         xml = """&lt;domain type='kvm' id='7'&gt;
3771               &lt;name&gt;test-vm&lt;/name&gt;
3772               &lt;devices&gt;
3773                 &lt;disk type='volume' device='disk'&gt;
3774                   &lt;driver name='qemu' type='qcow2' cache='none' io='native'/&gt;
3775                   &lt;source pool='default' volume='vm05_system'/&gt;
3776                   &lt;backingStore type='file' index='1'&gt;
3777                     &lt;format type='qcow2'/&gt;
3778                     &lt;source file='/var/lib/libvirt/images/vm04_system.qcow2'/&gt;
3779                     &lt;backingStore type='file' index='2'&gt;
3780                       &lt;format type='qcow2'/&gt;
3781                       &lt;source file='/var/testsuite-data/disk-image-template.qcow2'/&gt;
3782                       &lt;backingStore/&gt;
3783                     &lt;/backingStore&gt;
3784                   &lt;/backingStore&gt;
3785                   &lt;target dev='vda' bus='virtio'/&gt;
3786                   &lt;alias name='virtio-disk0'/&gt;
3787                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/&gt;
3788                 &lt;/disk&gt;
3789               &lt;/devices&gt;
3790             &lt;/domain&gt;
3791         """
3792         self.set_mock_vm("test-vm", xml)
3793         pool_mock = MagicMock()
3794         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3795             0,
3796             1234567,
3797             12345,
3798         ]
3799         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3800         ]
3801         pool_mock.listVolumes.return_value = ["vm05_system", "vm04_system.qcow2"]
3802         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3803         self.mock_conn.listStoragePools.return_value = ["default"]
3804         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3805             res = virt.purge("test-vm")
3806             self.assertTrue(res)
3807             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3808     @patch("salt.modules.virt.stop", return_value=True)
3809     @patch("salt.modules.virt.undefine")
3810     def test_purge_rbd(self, mock_undefine, mock_stop):
3811         xml = """&lt;domain type='kvm' id='7'&gt;
3812               &lt;name&gt;test-vm&lt;/name&gt;
3813               &lt;devices&gt;
3814                 &lt;disk type="network" device="disk"&gt;
3815                   &lt;driver name='raw' type='qcow2'/&gt;
3816                   &lt;source protocol='rbd' name='libvirt-pool/my_vm_data2'&gt;
3817                     &lt;host name='ses2.tf.local'/&gt;
3818                     &lt;host name='ses3.tf.local' port='1234'/&gt;
3819                     &lt;auth username='libvirt'&gt;
3820                       &lt;secret type='ceph' usage='pool_test-rbd'/&gt;
3821                     &lt;/auth&gt;
3822                   &lt;/source&gt;
3823                   &lt;target dev='vdc' bus='virtio'/&gt;
3824                   &lt;alias name='virtio-disk2'/&gt;
3825                   &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x2'/&gt;
3826                 &lt;/disk&gt;
3827               &lt;/devices&gt;
3828             &lt;/domain&gt;
3829         """
3830         self.set_mock_vm("test-vm", xml)
3831         pool_mock = MagicMock()
3832         pool_mock.storageVolLookupByName.return_value.info.return_value = [
3833             0,
3834             1234567,
3835             12345,
3836         ]
3837         pool_mock.XMLDesc.return_value = """
3838         &lt;pool type='rbd'&gt;
3839           &lt;name&gt;test-ses&lt;/name&gt;
3840           &lt;source&gt;
3841             &lt;host name='ses2.tf.local'/&gt;
3842             &lt;name&gt;libvirt-pool&lt;/name&gt;
3843             &lt;auth type='ceph' username='libvirt'&gt;
3844               &lt;secret usage='pool_test-ses'/&gt;
3845             &lt;/auth&gt;
3846           &lt;/source&gt;
3847         &lt;/pool&gt;
3848         """
3849         pool_mock.name.return_value = "test-ses"
3850         pool_mock.storageVolLookupByName.return_value.XMLDesc.return_value = [
3851         ]
3852         pool_mock.listVolumes.return_value = ["my_vm_data2"]
3853         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
3854         self.mock_conn.listStoragePools.return_value = ["test-ses"]
3855         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
3856         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=False)}):
3857             res = virt.purge("test-vm")
3858             self.assertTrue(res)
3859             pool_mock.storageVolLookupByName.return_value.delete.assert_called_once()
3860     @patch("salt.modules.virt.stop", return_value=True)
3861     @patch("salt.modules.virt.undefine")
3862     @patch("os.remove")
3863     def test_purge_removable(self, mock_remove, mock_undefine, mock_stop):
3864         xml = """&lt;domain type="kvm" id="7"&gt;
3865               &lt;name&gt;test-vm&lt;/name&gt;
3866               &lt;devices&gt;
3867                 &lt;disk type='file' device='disk'&gt;
3868                 &lt;driver name='qemu' type='qcow2'/&gt;
3869                 &lt;source file='/disks/test.qcow2'/&gt;
3870                 &lt;target dev='vda' bus='virtio'/&gt;
3871               &lt;/disk&gt;
3872               &lt;disk type='file' device='cdrom'&gt;
3873                 &lt;driver name='qemu' type='raw'/&gt;
3874                 &lt;source file='/disks/test-cdrom.iso'/&gt;
3875                 &lt;target dev='hda' bus='ide'/&gt;
3876                 &lt;readonly/&gt;
3877               &lt;/disk&gt;
3878               &lt;disk type='file' device='floppy'&gt;
3879                 &lt;driver name='qemu' type='raw'/&gt;
3880                 &lt;source file='/disks/test-floppy.iso'/&gt;
3881                 &lt;target dev='hdb' bus='ide'/&gt;
3882                 &lt;readonly/&gt;
3883               &lt;/disk&gt;
3884               &lt;/devices&gt;
3885             &lt;/domain&gt;
3886         """
3887         self.set_mock_vm("test-vm", xml)
3888         qemu_infos = """[{
3889             "virtual-size": 25769803776,
3890             "filename": "/disks/test.qcow2",
3891             "cluster-size": 65536,
3892             "format": "qcow2",
3893             "actual-size": 217088,
3894             "format-specific": {
3895                 "type": "qcow2",
3896                 "data": {
3897                     "compat": "1.1",
3898                     "lazy-refcounts": false,
3899                     "refcount-bits": 16,
3900                     "corrupt": false
3901                 }
3902             },
3903             "dirty-flag": false
3904         }]"""
3905         self.mock_popen.communicate.return_value = [qemu_infos, ""]
3906         with patch.dict(os.path.__dict__, {"exists": MagicMock(return_value=True)}):
3907             res = virt.purge<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>("test-vm", removables=True)
3908             self.assertTrue(res)
3909             mock_remove.assert_any_call("/disks/test.qcow2")
3910             mock_remove.assert_any_call("/disks/test-cdrom.iso")
3911     def</b></font> test_capabilities(self):
3912         xml = """
3913 &lt;capabilities&gt;
3914   &lt;host&gt;
3915     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
3916     &lt;cpu&gt;
3917       &lt;arch&gt;x86_64&lt;/arch&gt;
3918       &lt;model&gt;Nehalem&lt;/model&gt;
3919       &lt;vendor&gt;Intel&lt;/vendor&gt;
3920       &lt;microcode version='25'/&gt;
3921       &lt;topology sockets='1' cores='4' threads='2'/&gt;
3922       &lt;feature name='vme'/&gt;
3923       &lt;feature name='ds'/&gt;
3924       &lt;feature name='acpi'/&gt;
3925       &lt;pages unit='KiB' size='4'/&gt;
3926       &lt;pages unit='KiB' size='2048'/&gt;
3927     &lt;/cpu&gt;
3928     &lt;power_management&gt;
3929       &lt;suspend_mem/&gt;
3930       &lt;suspend_disk/&gt;
3931       &lt;suspend_hybrid/&gt;
3932     &lt;/power_management&gt;
3933     &lt;migration_features&gt;
3934       &lt;live/&gt;
3935       &lt;uri_transports&gt;
3936         &lt;uri_transport&gt;tcp&lt;/uri_transport&gt;
3937         &lt;uri_transport&gt;rdma&lt;/uri_transport&gt;
3938       &lt;/uri_transports&gt;
3939     &lt;/migration_features&gt;
3940     &lt;topology&gt;
3941       &lt;cells num='1'&gt;
3942         &lt;cell id='0'&gt;
3943           &lt;memory unit='KiB'&gt;12367120&lt;/memory&gt;
3944           &lt;pages unit='KiB' size='4'&gt;3091780&lt;/pages&gt;
3945           &lt;pages unit='KiB' size='2048'&gt;0&lt;/pages&gt;
3946           &lt;distances&gt;
3947             &lt;sibling id='0' value='10'/&gt;
3948           &lt;/distances&gt;
3949           &lt;cpus num='8'&gt;
3950             &lt;cpu id='0' socket_id='0' core_id='0' siblings='0,4'/&gt;
3951             &lt;cpu id='1' socket_id='0' core_id='1' siblings='1,5'/&gt;
3952             &lt;cpu id='2' socket_id='0' core_id='2' siblings='2,6'/&gt;
3953             &lt;cpu id='3' socket_id='0' core_id='3' siblings='3,7'/&gt;
3954             &lt;cpu id='4' socket_id='0' core_id='0' siblings='0,4'/&gt;
3955             &lt;cpu id='5' socket_id='0' core_id='1' siblings='1,5'/&gt;
3956             &lt;cpu id='6' socket_id='0' core_id='2' siblings='2,6'/&gt;
3957             &lt;cpu id='7' socket_id='0' core_id='3' siblings='3,7'/&gt;
3958           &lt;/cpus&gt;
3959         &lt;/cell&gt;
3960       &lt;/cells&gt;
3961     &lt;/topology&gt;
3962     &lt;cache&gt;
3963       &lt;bank id='0' level='3' type='both' size='8' unit='MiB' cpus='0-7'/&gt;
3964     &lt;/cache&gt;
3965     &lt;secmodel&gt;
3966       &lt;model&gt;apparmor&lt;/model&gt;
3967       &lt;doi&gt;0&lt;/doi&gt;
3968     &lt;/secmodel&gt;
3969     &lt;secmodel&gt;
3970       &lt;model&gt;dac&lt;/model&gt;
3971       &lt;doi&gt;0&lt;/doi&gt;
3972       &lt;baselabel type='kvm'&gt;+487:+486&lt;/baselabel&gt;
3973       &lt;baselabel type='qemu'&gt;+487:+486&lt;/baselabel&gt;
3974     &lt;/secmodel&gt;
3975   &lt;/host&gt;
3976   &lt;guest&gt;
3977     &lt;os_type&gt;hvm&lt;/os_type&gt;
3978     &lt;arch name='i686'&gt;
3979       &lt;wordsize&gt;32&lt;/wordsize&gt;
3980       &lt;emulator&gt;/usr/bin/qemu-system-i386&lt;/emulator&gt;
3981       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3982       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3983       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3984       &lt;domain type='qemu'/&gt;
3985       &lt;domain type='kvm'&gt;
3986         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
3987         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
3988         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
3989         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
3990       &lt;/domain&gt;
3991     &lt;/arch&gt;
3992     &lt;features&gt;
3993       &lt;cpuselection/&gt;
3994       &lt;deviceboot/&gt;
3995       &lt;disksnapshot default='on' toggle='no'/&gt;
3996       &lt;acpi default='off' toggle='yes'/&gt;
3997       &lt;apic default='on' toggle='no'/&gt;
3998       &lt;pae/&gt;
3999       &lt;nonpae/&gt;
4000     &lt;/features&gt;
4001   &lt;/guest&gt;
4002   &lt;guest&gt;
4003     &lt;os_type&gt;hvm&lt;/os_type&gt;
4004     &lt;arch name='x86_64'&gt;
4005       &lt;wordsize&gt;64&lt;/wordsize&gt;
4006       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4007       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4008       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4009       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4010       &lt;domain type='qemu'/&gt;
4011       &lt;domain type='kvm'&gt;
4012         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4013         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4014         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4015         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4016       &lt;/domain&gt;
4017     &lt;/arch&gt;
4018     &lt;features&gt;
4019       &lt;cpuselection/&gt;
4020       &lt;deviceboot/&gt;
4021       &lt;disksnapshot default='on' toggle='no'/&gt;
4022       &lt;acpi default='on' toggle='yes'/&gt;
4023       &lt;apic default='off' toggle='no'/&gt;
4024     &lt;/features&gt;
4025   &lt;/guest&gt;
4026   &lt;guest&gt;
4027     &lt;os_type&gt;xen&lt;/os_type&gt;
4028     &lt;arch name='x86_64'&gt;
4029       &lt;wordsize&gt;64&lt;/wordsize&gt;
4030       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4031       &lt;machine&gt;xenpv&lt;/machine&gt;
4032       &lt;domain type='xen'/&gt;
4033     &lt;/arch&gt;
4034   &lt;/guest&gt;
4035 &lt;/capabilities&gt;
4036         """
4037         self.mock_conn.getCapabilities.return_value = xml  # pylint: disable=no-member
4038         caps = virt.capabilities()
4039         expected = {
4040             "host": {
4041                 "uuid": "44454c4c-3400-105a-8033-b3c04f4b344a",
4042                 "cpu": {
4043                     "arch": "x86_64",
4044                     "model": "Nehalem",
4045                     "vendor": "Intel",
4046                     "microcode": "25",
4047                     "sockets": 1,
4048                     "cores": 4,
4049                     "threads": 2,
4050                     "features": ["vme", "ds", "acpi"],
4051                     "pages": [{"size": "4 KiB"}, {"size": "2048 KiB"}],
4052                 },
4053                 "power_management": ["suspend_mem", "suspend_disk", "suspend_hybrid"],
4054                 "migration": {"live": True, "transports": ["tcp", "rdma"]},
4055                 "topology": {
4056                     "cells": [
4057                         {
4058                             "id": 0,
4059                             "memory": "12367120 KiB",
4060                             "pages": [
4061                                 {"size": "4 KiB", "available": 3091780},
4062                                 {"size": "2048 KiB", "available": 0},
4063                             ],
4064                             "distances": {0: 10},
4065                             "cpus": [
4066                                 {
4067                                     "id": 0,
4068                                     "socket_id": 0,
4069                                     "core_id": 0,
4070                                     "siblings": "0,4",
4071                                 },
4072                                 {
4073                                     "id": 1,
4074                                     "socket_id": 0,
4075                                     "core_id": 1,
4076                                     "siblings": "1,5",
4077                                 },
4078                                 {
4079                                     "id": 2,
4080                                     "socket_id": 0,
4081                                     "core_id": 2,
4082                                     "siblings": "2,6",
4083                                 },
4084                                 {
4085                                     "id": 3,
4086                                     "socket_id": 0,
4087                                     "core_id": 3,
4088                                     "siblings": "3,7",
4089                                 },
4090                                 {
4091                                     "id": 4,
4092                                     "socket_id": 0,
4093                                     "core_id": 0,
4094                                     "siblings": "0,4",
4095                                 },
4096                                 {
4097                                     "id": 5,
4098                                     "socket_id": 0,
4099                                     "core_id": 1,
4100                                     "siblings": "1,5",
4101                                 },
4102                                 {
4103                                     "id": 6,
4104                                     "socket_id": 0,
4105                                     "core_id": 2,
4106                                     "siblings": "2,6",
4107                                 },
4108                                 {
4109                                     "id": 7,
4110                                     "socket_id": 0,
4111                                     "core_id": 3,
4112                                     "siblings": "3,7",
4113                                 },
4114                             ],
4115                         }
4116                     ]
4117                 },
4118                 "cache": {
4119                     "banks": [
4120                         {
4121                             "id": 0,
4122                             "level": 3,
4123                             "type": "both",
4124                             "size": "8 MiB",
4125                             "cpus": "0-7",
4126                         }
4127                     ]
4128                 },
4129                 "security": [
4130                     {"model": "apparmor", "doi": "0", "baselabels": []},
4131                     {
4132                         "model": "dac",
4133                         "doi": "0",
4134                         "baselabels": [
4135                             {"type": "kvm", "label": "+487:+486"},
4136                             {"type": "qemu", "label": "+487:+486"},
4137                         ],
4138                     },
4139                 ],
4140             },
4141             "guests": [
4142                 {
4143                     "os_type": "hvm",
4144                     "arch": {
4145                         "name": "i686",
4146                         "wordsize": 32,
4147                         "emulator": "/usr/bin/qemu-system-i386",
4148                         "machines": {
4149                             "pc-i440fx-2.6": {
4150                                 "maxcpus": 255,
4151                                 "alternate_names": ["pc"],
4152                             },
4153                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4154                         },
4155                         "domains": {
4156                             "qemu": {"emulator": None, "machines": {}},
4157                             "kvm": {
4158                                 "emulator": "/usr/bin/qemu-kvm",
4159                                 "machines": {
4160                                     "pc-i440fx-2.6": {
4161                                         "maxcpus": 255,
4162                                         "alternate_names": ["pc"],
4163                                     },
4164                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4165                                 },
4166                             },
4167                         },
4168                     },
4169                     "features": {
4170                         "cpuselection": {"default": True, "toggle": False},
4171                         "deviceboot": {"default": True, "toggle": False},
4172                         "disksnapshot": {"default": True, "toggle": False},
4173                         "acpi": {"default": False, "toggle": True},
4174                         "apic": {"default": True, "toggle": False},
4175                         "pae": {"default": True, "toggle": False},
4176                         "nonpae": {"default": True, "toggle": False},
4177                     },
4178                 },
4179                 {
4180                     "os_type": "hvm",
4181                     "arch": {
4182                         "name": "x86_64",
4183                         "wordsize": 64,
4184                         "emulator": "/usr/bin/qemu-system-x86_64",
4185                         "machines": {
4186                             "pc-i440fx-2.6": {
4187                                 "maxcpus": 255,
4188                                 "alternate_names": ["pc"],
4189                             },
4190                             "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4191                         },
4192                         "domains": {
4193                             "qemu": {"emulator": None, "machines": {}},
4194                             "kvm": {
4195                                 "emulator": "/usr/bin/qemu-kvm",
4196                                 "machines": {
4197                                     "pc-i440fx-2.6": {
4198                                         "maxcpus": 255,
4199                                         "alternate_names": ["pc"],
4200                                     },
4201                                     "pc-0.12": {"maxcpus": 255, "alternate_names": []},
4202                                 },
4203                             },
4204                         },
4205                     },
4206                     "features": {
4207                         "cpuselection": {"default": True, "toggle": False},
4208                         "deviceboot": {"default": True, "toggle": False},
4209                         "disksnapshot": {"default": True, "toggle": False},
4210                         "acpi": {"default": True, "toggle": True},
4211                         "apic": {"default": False, "toggle": False},
4212                     },
4213                 },
4214                 {
4215                     "os_type": "xen",
4216                     "arch": {
4217                         "name": "x86_64",
4218                         "wordsize": 64,
4219                         "emulator": "/usr/bin/qemu-system-x86_64",
4220                         "machines": {"xenpv": {"alternate_names": []}},
4221                         "domains": {"xen": {"emulator": None, "machines": {}}},
4222                     },
4223                 },
4224             ],
4225         }
4226         self.assertEqual(expected, caps)
4227     def test_domain_capabilities(self):
4228         xml = """
4229 &lt;domainCapabilities&gt;
4230   &lt;path&gt;/usr/bin/qemu-system-aarch64&lt;/path&gt;
4231   &lt;domain&gt;kvm&lt;/domain&gt;
4232   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4233   &lt;arch&gt;aarch64&lt;/arch&gt;
4234   &lt;vcpu max='255'/&gt;
4235   &lt;iothreads supported='yes'/&gt;
4236   &lt;os supported='yes'&gt;
4237     &lt;loader supported='yes'&gt;
4238       &lt;value&gt;/usr/share/AAVMF/AAVMF_CODE.fd&lt;/value&gt;
4239       &lt;value&gt;/usr/share/AAVMF/AAVMF32_CODE.fd&lt;/value&gt;
4240       &lt;value&gt;/usr/share/OVMF/OVMF_CODE.fd&lt;/value&gt;
4241       &lt;enum name='type'&gt;
4242         &lt;value&gt;rom&lt;/value&gt;
4243         &lt;value&gt;pflash&lt;/value&gt;
4244       &lt;/enum&gt;
4245       &lt;enum name='readonly'&gt;
4246         &lt;value&gt;yes&lt;/value&gt;
4247         &lt;value&gt;no&lt;/value&gt;
4248       &lt;/enum&gt;
4249     &lt;/loader&gt;
4250   &lt;/os&gt;
4251   &lt;cpu&gt;
4252     &lt;mode name='host-passthrough' supported='yes'/&gt;
4253     &lt;mode name='host-model' supported='yes'&gt;
4254       &lt;model fallback='forbid'&gt;sample-cpu&lt;/model&gt;
4255       &lt;vendor&gt;ACME&lt;/vendor&gt;
4256       &lt;feature policy='require' name='vme'/&gt;
4257       &lt;feature policy='require' name='ss'/&gt;
4258     &lt;/mode&gt;
4259     &lt;mode name='custom' supported='yes'&gt;
4260       &lt;model usable='unknown'&gt;pxa262&lt;/model&gt;
4261       &lt;model usable='yes'&gt;pxa270-a0&lt;/model&gt;
4262       &lt;model usable='no'&gt;arm1136&lt;/model&gt;
4263     &lt;/mode&gt;
4264   &lt;/cpu&gt;
4265   &lt;devices&gt;
4266     &lt;disk supported='yes'&gt;
4267       &lt;enum name='diskDevice'&gt;
4268         &lt;value&gt;disk&lt;/value&gt;
4269         &lt;value&gt;cdrom&lt;/value&gt;
4270         &lt;value&gt;floppy&lt;/value&gt;
4271         &lt;value&gt;lun&lt;/value&gt;
4272       &lt;/enum&gt;
4273       &lt;enum name='bus'&gt;
4274         &lt;value&gt;fdc&lt;/value&gt;
4275         &lt;value&gt;scsi&lt;/value&gt;
4276         &lt;value&gt;virtio&lt;/value&gt;
4277         &lt;value&gt;usb&lt;/value&gt;
4278         &lt;value&gt;sata&lt;/value&gt;
4279       &lt;/enum&gt;
4280     &lt;/disk&gt;
4281     &lt;graphics supported='yes'&gt;
4282       &lt;enum name='type'&gt;
4283         &lt;value&gt;sdl&lt;/value&gt;
4284         &lt;value&gt;vnc&lt;/value&gt;
4285       &lt;/enum&gt;
4286     &lt;/graphics&gt;
4287     &lt;video supported='yes'&gt;
4288       &lt;enum name='modelType'&gt;
4289         &lt;value&gt;vga&lt;/value&gt;
4290         &lt;value&gt;virtio&lt;/value&gt;
4291       &lt;/enum&gt;
4292     &lt;/video&gt;
4293     &lt;hostdev supported='yes'&gt;
4294       &lt;enum name='mode'&gt;
4295         &lt;value&gt;subsystem&lt;/value&gt;
4296       &lt;/enum&gt;
4297       &lt;enum name='startupPolicy'&gt;
4298         &lt;value&gt;default&lt;/value&gt;
4299         &lt;value&gt;mandatory&lt;/value&gt;
4300         &lt;value&gt;requisite&lt;/value&gt;
4301         &lt;value&gt;optional&lt;/value&gt;
4302       &lt;/enum&gt;
4303       &lt;enum name='subsysType'&gt;
4304         &lt;value&gt;usb&lt;/value&gt;
4305         &lt;value&gt;pci&lt;/value&gt;
4306         &lt;value&gt;scsi&lt;/value&gt;
4307       &lt;/enum&gt;
4308       &lt;enum name='capsType'/&gt;
4309       &lt;enum name='pciBackend'&gt;
4310         &lt;value&gt;default&lt;/value&gt;
4311         &lt;value&gt;kvm&lt;/value&gt;
4312         &lt;value&gt;vfio&lt;/value&gt;
4313       &lt;/enum&gt;
4314     &lt;/hostdev&gt;
4315   &lt;/devices&gt;
4316   &lt;features&gt;
4317     &lt;gic supported='yes'&gt;
4318       &lt;enum name='version'&gt;
4319         &lt;value&gt;3&lt;/value&gt;
4320       &lt;/enum&gt;
4321     &lt;/gic&gt;
4322     &lt;vmcoreinfo supported='yes'/&gt;
4323   &lt;/features&gt;
4324 &lt;/domainCapabilities&gt;
4325         """
4326         self.mock_conn.getDomainCapabilities.return_value = (
4327             xml  # pylint: disable=no-member
4328         )
4329         caps = virt.domain_capabilities()
4330         expected = {
4331             "emulator": "/usr/bin/qemu-system-aarch64",
4332             "domain": "kvm",
4333             "machine": "virt-2.12",
4334             "arch": "aarch64",
4335             "max_vcpus": 255,
4336             "iothreads": True,
4337             "os": {
4338                 "loader": {
4339                     "type": ["rom", "pflash"],
4340                     "readonly": ["yes", "no"],
4341                     "values": [
4342                         "/usr/share/AAVMF/AAVMF_CODE.fd",
4343                         "/usr/share/AAVMF/AAVMF32_CODE.fd",
4344                         "/usr/share/OVMF/OVMF_CODE.fd",
4345                     ],
4346                 }
4347             },
4348             "cpu": {
4349                 "host-passthrough": True,
4350                 "host-model": {
4351                     "model": {"name": "sample-cpu", "fallback": "forbid"},
4352                     "vendor": "ACME",
4353                     "features": {"vme": "require", "ss": "require"},
4354                 },
4355                 "custom": {
4356                     "models": {"pxa262": "unknown", "pxa270-a0": "yes", "arm1136": "no"}
4357                 },
4358             },
4359             "devices": {
4360                 "disk": {
4361                     "diskDevice": ["disk", "cdrom", "floppy", "lun"],
4362                     "bus": ["fdc", "scsi", "virtio", "usb", "sata"],
4363                 },
4364                 "graphics": {"type": ["sdl", "vnc"]},
4365                 "video": {"modelType": ["vga", "virtio"]},
4366                 "hostdev": {
4367                     "mode": ["subsystem"],
4368                     "startupPolicy": ["default", "mandatory", "requisite", "optional"],
4369                     "subsysType": ["usb", "pci", "scsi"],
4370                     "capsType": [],
4371                     "pciBackend": ["default", "kvm", "vfio"],
4372                 },
4373             },
4374             "features": {"gic": {"version": ["3"]}, "vmcoreinfo": {}},
4375         }
4376         self.assertEqual(expected, caps)
4377     def test_all_capabilities(self):
4378         domainXml = """
4379 &lt;domainCapabilities&gt;
4380   &lt;path&gt;/usr/bin/qemu-system-x86_64&lt;/path&gt;
4381   &lt;domain&gt;kvm&lt;/domain&gt;
4382   &lt;machine&gt;virt-2.12&lt;/machine&gt;
4383   &lt;arch&gt;x86_64&lt;/arch&gt;
4384   &lt;vcpu max='255'/&gt;
4385   &lt;iothreads supported='yes'/&gt;
4386 &lt;/domainCapabilities&gt;
4387         """
4388         hostXml = """
4389 &lt;capabilities&gt;
4390   &lt;host&gt;
4391     &lt;uuid&gt;44454c4c-3400-105a-8033-b3c04f4b344a&lt;/uuid&gt;
4392     &lt;cpu&gt;
4393       &lt;arch&gt;x86_64&lt;/arch&gt;
4394       &lt;model&gt;Nehalem&lt;/model&gt;
4395       &lt;vendor&gt;Intel&lt;/vendor&gt;
4396       &lt;microcode version='25'/&gt;
4397       &lt;topology sockets='1' cores='4' threads='2'/&gt;
4398     &lt;/cpu&gt;
4399   &lt;/host&gt;
4400   &lt;guest&gt;
4401     &lt;os_type&gt;hvm&lt;/os_type&gt;
4402     &lt;arch name='x86_64'&gt;
4403       &lt;wordsize&gt;64&lt;/wordsize&gt;
4404       &lt;emulator&gt;/usr/bin/qemu-system-x86_64&lt;/emulator&gt;
4405       &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4406       &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4407       &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4408       &lt;domain type='qemu'/&gt;
4409       &lt;domain type='kvm'&gt;
4410         &lt;emulator&gt;/usr/bin/qemu-kvm&lt;/emulator&gt;
4411         &lt;machine maxCpus='255'&gt;pc-i440fx-2.6&lt;/machine&gt;
4412         &lt;machine canonical='pc-i440fx-2.6' maxCpus='255'&gt;pc&lt;/machine&gt;
4413         &lt;machine maxCpus='255'&gt;pc-0.12&lt;/machine&gt;
4414       &lt;/domain&gt;
4415     &lt;/arch&gt;
4416   &lt;/guest&gt;
4417 &lt;/capabilities&gt;
4418         """
4419         self.mock_conn.getCapabilities.return_value = hostXml
4420         self.mock_conn.getDomainCapabilities.side_effect = [
4421             domainXml,
4422             domainXml.replace("&lt;domain&gt;kvm", "&lt;domain&gt;qemu"),
4423         ]
4424         caps = virt.all_capabilities()
4425         self.assertEqual(
4426             "44454c4c-3400-105a-8033-b3c04f4b344a", caps["host"]["host"]["uuid"]
4427         )
4428         self.assertEqual(
4429             {"qemu", "kvm"},
4430             {domainCaps["domain"] for domainCaps in caps["domains"]},
4431         )
4432         self.assertEqual(
4433             {call[0] for call in self.mock_conn.getDomainCapabilities.call_args_list},
4434             {
4435                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "kvm"),
4436                 ("/usr/bin/qemu-system-x86_64", "x86_64", None, "qemu"),
4437             },
4438         )
4439     def test_network_tag(self):
4440         xml_data = virt._gen_net_xml("network", "main", "bridge", "openvswitch", 1001)
4441         root = ET.fromstring(xml_data)
4442         self.assertEqual(root.find("name").text, "network")
4443         self.assertEqual(root.find("bridge").attrib["name"], "main")
4444         self.assertEqual(root.find("forward").attrib["mode"], "bridge")
4445         self.assertEqual(root.find("virtualport").attrib["type"], "openvswitch")
4446         self.assertEqual(root.find("vlan/tag").attrib["id"], "1001")
4447     def test_list_networks(self):
4448         names = ["net1", "default", "net2"]
4449         net_mocks = [MagicMock(), MagicMock(), MagicMock()]
4450         for i, value in enumerate(names):
4451             net_mocks[i].name.return_value = value
4452         self.mock_conn.listAllNetworks.return_value = (
4453             net_mocks  # pylint: disable=no-member
4454         )
4455         actual = virt.list_networks()
4456         self.assertEqual(names, actual)
4457     def test_network_info(self):
4458         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4459         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4460         net_mock = MagicMock()
4461         net_mock.name.return_value = "foo"
4462         net_mock.UUIDString.return_value = "some-uuid"
4463         net_mock.bridgeName.return_value = "br0"
4464         net_mock.autostart.return_value = True
4465         net_mock.isActive.return_value = False
4466         net_mock.isPersistent.return_value = True
4467         net_mock.DHCPLeases.return_value = [
4468             {
4469                 "iface": "virbr0",
4470                 "expirytime": 1527757552,
4471                 "type": 0,
4472                 "mac": "52:54:00:01:71:bd",
4473                 "ipaddr": "192.168.122.45",
4474                 "prefix": 24,
4475                 "hostname": "py3-test",
4476                 "clientid": "01:52:54:00:01:71:bd",
4477                 "iaid": None,
4478             }
4479         ]
4480         self.mock_conn.listAllNetworks.return_value = [net_mock]
4481         net = virt.network_info("foo")
4482         self.assertEqual(
4483             {
4484                 "foo": {
4485                     "uuid": "some-uuid",
4486                     "bridge": "br0",
4487                     "autostart": True,
4488                     "active": False,
4489                     "persistent": True,
4490                     "leases": [
4491                         {
4492                             "iface": "virbr0",
4493                             "expirytime": 1527757552,
4494                             "type": "ipv4",
4495                             "mac": "52:54:00:01:71:bd",
4496                             "ipaddr": "192.168.122.45",
4497                             "prefix": 24,
4498                             "hostname": "py3-test",
4499                             "clientid": "01:52:54:00:01:71:bd",
4500                             "iaid": None,
4501                         }
4502                     ],
4503                 }
4504             },
4505             net,
4506         )
4507     def test_network_info_all(self):
4508         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV4 = 0
4509         self.mock_libvirt.VIR_IP_ADDR_TYPE_IPV6 = 1
4510         net_mocks = []
4511         for i in range(2):
4512             net_mock = MagicMock()
4513             net_mock.name.return_value = "net{}".format(i)
4514             net_mock.UUIDString.return_value = "some-uuid"
4515             net_mock.bridgeName.return_value = "br{}".format(i)
4516             net_mock.autostart.return_value = True
4517             net_mock.isActive.return_value = False
4518             net_mock.isPersistent.return_value = True
4519             net_mock.DHCPLeases.return_value = []
4520             net_mocks.append(net_mock)
4521         self.mock_conn.listAllNetworks.return_value = net_mocks
4522         net = virt.network_info()
4523         self.assertEqual(
4524             {
4525                 "net0": {
4526                     "uuid": "some-uuid",
4527                     "bridge": "br0",
4528                     "autostart": True,
4529                     "active": False,
4530                     "persistent": True,
4531                     "leases": [],
4532                 },
4533                 "net1": {
4534                     "uuid": "some-uuid",
4535                     "bridge": "br1",
4536                     "autostart": True,
4537                     "active": False,
4538                     "persistent": True,
4539                     "leases": [],
4540                 },
4541             },
4542             net,
4543         )
4544     def test_network_info_notfound(self):
4545         self.mock_conn.listAllNetworks.return_value = []
4546         net = virt.network_info("foo")
4547         self.assertEqual({}, net)
4548     def test_network_get_xml(self):
4549         network_mock = MagicMock()
4550         network_mock.XMLDesc.return_value = "&lt;net&gt;Raw XML&lt;/net&gt;"
4551         self.mock_conn.networkLookupByName.return_value = network_mock
4552         self.assertEqual("&lt;net&gt;Raw XML&lt;/net&gt;", virt.network_get_xml("default"))
4553     def test_pool(self):
4554         xml_data = virt._gen_pool_xml("pool", "logical", "/dev/base")
4555         root = ET.fromstring(xml_data)
4556         self.assertEqual(root.find("name").text, "pool")
4557         self.assertEqual(root.attrib["type"], "logical")
4558         self.assertEqual(root.find("target/path").text, "/dev/base")
4559     def test_pool_with_source(self):
4560         xml_data = virt._gen_pool_xml(
4561             "pool", "logical", "/dev/base", source_devices=[{"path": "/dev/sda"}]
4562         )
4563         root = ET.fromstring(xml_data)
4564         self.assertEqual(root.find("name").text, "pool")
4565         self.assertEqual(root.attrib["type"], "logical")
4566         self.assertEqual(root.find("target/path").text, "/dev/base")
4567         self.assertEqual(root.find("source/device").attrib["path"], "/dev/sda")
4568     def test_pool_with_scsi(self):
4569         xml_data = virt._gen_pool_xml(
4570             "pool",
4571             "scsi",
4572             "/dev/disk/by-path",
4573             source_devices=[{"path": "/dev/sda"}],
4574             source_adapter={
4575                 "type": "scsi_host",
4576                 "parent_address": {
4577                     "unique_id": 5,
4578                     "address": {
4579                         "domain": "0x0000",
4580                         "bus": "0x00",
4581                         "slot": "0x1f",
4582                         "function": "0x2",
4583                     },
4584                 },
4585             },
4586             source_name="srcname",
4587         )
4588         root = ET.fromstring(xml_data)
4589         self.assertEqual(root.find("name").text, "pool")
4590         self.assertEqual(root.attrib["type"], "scsi")
4591         self.assertEqual(root.find("target/path").text, "/dev/disk/by-path")
4592         self.assertEqual(root.find("source/device"), None)
4593         self.assertEqual(root.find("source/name"), None)
4594         self.assertEqual(root.find("source/adapter").attrib["type"], "scsi_host")
4595         self.assertEqual(
4596             root.find("source/adapter/parentaddr").attrib["unique_id"], "5"
4597         )
4598         self.assertEqual(
4599             root.find("source/adapter/parentaddr/address").attrib["domain"], "0x0000"
4600         )
4601         self.assertEqual(
4602             root.find("source/adapter/parentaddr/address").attrib["bus"], "0x00"
4603         )
4604         self.assertEqual(
4605             root.find("source/adapter/parentaddr/address").attrib["slot"], "0x1f"
4606         )
4607         self.assertEqual(
4608             root.find("source/adapter/parentaddr/address").attrib["function"], "0x2"
4609         )
4610     def test_pool_with_rbd(self):
4611         xml_data = virt._gen_pool_xml(
4612             "pool",
4613             "rbd",
4614             source_devices=[{"path": "/dev/sda"}],
4615             source_hosts=["1.2.3.4", "my.ceph.monitor:69"],
4616             source_auth={
4617                 "type": "ceph",
4618                 "username": "admin",
4619                 "secret": {"type": "uuid", "value": "someuuid"},
4620             },
4621             source_name="srcname",
4622             source_adapter={"type": "scsi_host", "name": "host0"},
4623             source_dir="/some/dir",
4624             source_format="fmt",
4625         )
4626         root = ET.fromstring(xml_data)
4627         self.assertEqual(root.find("name").text, "pool")
4628         self.assertEqual(root.attrib["type"], "rbd")
4629         self.assertEqual(root.find("target"), None)
4630         self.assertEqual(root.find("source/device"), None)
4631         self.assertEqual(root.find("source/name").text, "srcname")
4632         self.assertEqual(root.find("source/adapter"), None)
4633         self.assertEqual(root.find("source/dir"), None)
4634         self.assertEqual(root.find("source/format"), None)
4635         self.assertEqual(root.findall("source/host")[0].attrib["name"], "1.2.3.4")
4636         self.assertTrue("port" not in root.findall("source/host")[0].attrib)
4637         self.assertEqual(
4638             root.findall("source/host")[1].attrib["name"], "my.ceph.monitor"
4639         )
4640         self.assertEqual(root.findall("source/host")[1].attrib["port"], "69")
4641         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4642         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4643         self.assertEqual(root.find("source/auth/secret").attrib["uuid"], "someuuid")
4644     def test_pool_with_netfs(self):
4645         xml_data = virt._gen_pool_xml(
4646             "pool",
4647             "netfs",
4648             target="/path/to/target",
4649             permissions={
4650                 "mode": "0770",
4651                 "owner": 1000,
4652                 "group": 100,
4653                 "label": "seclabel",
4654             },
4655             source_devices=[{"path": "/dev/sda"}],
4656             source_hosts=["nfs.host"],
4657             source_name="srcname",
4658             source_adapter={"type": "scsi_host", "name": "host0"},
4659             source_dir="/some/dir",
4660             source_format="nfs",
4661         )
4662         root = ET.fromstring(xml_data)
4663         self.assertEqual(root.find("name").text, "pool")
4664         self.assertEqual(root.attrib["type"], "netfs")
4665         self.assertEqual(root.find("target/path").text, "/path/to/target")
4666         self.assertEqual(root.find("target/permissions/mode").text, "0770")
4667         self.assertEqual(root.find("target/permissions/owner").text, "1000")
4668         self.assertEqual(root.find("target/permissions/group").text, "100")
4669         self.assertEqual(root.find("target/permissions/label").text, "seclabel")
4670         self.assertEqual(root.find("source/device"), None)
4671         self.assertEqual(root.find("source/name"), None)
4672         self.assertEqual(root.find("source/adapter"), None)
4673         self.assertEqual(root.find("source/dir").attrib["path"], "/some/dir")
4674         self.assertEqual(root.find("source/format").attrib["type"], "nfs")
4675         self.assertEqual(root.find("source/host").attrib["name"], "nfs.host")
4676         self.assertEqual(root.find("source/auth"), None)
4677     def test_pool_with_iscsi_direct(self):
4678         xml_data = virt._gen_pool_xml(
4679             "pool",
4680             "iscsi-direct",
4681             source_hosts=["iscsi.example.com"],
4682             source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4683             source_initiator="iqn.2013-06.com.example:iscsi-initiator",
4684         )
4685         root = ET.fromstring(xml_data)
4686         self.assertEqual(root.find("name").text, "pool")
4687         self.assertEqual(root.attrib["type"], "iscsi-direct")
4688         self.assertEqual(root.find("target"), None)
4689         self.assertEqual(
4690             root.find("source/device").attrib["path"],
4691             "iqn.2013-06.com.example:iscsi-pool",
4692         )
4693         self.assertEqual(
4694             root.findall("source/host")[0].attrib["name"], "iscsi.example.com"
4695         )
4696         self.assertEqual(
4697             root.find("source/initiator/iqn").attrib["name"],
4698             "iqn.2013-06.com.example:iscsi-initiator",
4699         )
4700     def test_pool_define(self):
4701         mock_pool = MagicMock()
4702         mock_secret = MagicMock()
4703         mock_secret_define = MagicMock(return_value=mock_secret)
4704         self.mock_conn.secretDefineXML = mock_secret_define
4705         self.mock_conn.storagePoolCreateXML = MagicMock(return_value=mock_pool)
4706         self.mock_conn.storagePoolDefineXML = MagicMock(return_value=mock_pool)
4707         mocks = [
4708             mock_pool,
4709             mock_secret,
4710             mock_secret_define,
4711             self.mock_conn.storagePoolCreateXML,
4712             self.mock_conn.secretDefineXML,
4713             self.mock_conn.storagePoolDefineXML,
4714         ]
4715         self.assertTrue(
4716             virt.pool_define(
4717                 "default",
4718                 "rbd",
4719                 source_hosts=["one.example.com", "two.example.com"],
4720                 source_name="rbdvol",
4721                 source_auth={
4722                     "type": "ceph",
4723                     "username": "admin",
4724                     "secret": {"type": "uuid", "value": "someuuid"},
4725                 },
4726             )
4727         )
4728         self.mock_conn.storagePoolDefineXML.assert_called_once()
4729         self.mock_conn.storagePoolCreateXML.assert_not_called()
4730         mock_pool.create.assert_called_once()
4731         mock_secret_define.assert_not_called()
4732         for mock in mocks:
4733             mock.reset_mock()
4734         self.assertTrue(
4735             virt.pool_define(
4736                 "default",
4737                 "rbd",
4738                 transient=True,
4739                 source_hosts=["one.example.com", "two.example.com"],
4740                 source_name="rbdvol",
4741                 source_auth={"username": "admin", "password": "c2VjcmV0"},
4742             )
4743         )
4744         self.mock_conn.storagePoolDefineXML.assert_not_called()
4745         pool_xml = self.mock_conn.storagePoolCreateXML.call_args[0][0]
4746         root = ET.fromstring(pool_xml)
4747         self.assertEqual(root.find("source/auth").attrib["type"], "ceph")
4748         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4749         self.assertEqual(
4750             root.find("source/auth/secret").attrib["usage"], "pool_default"
4751         )
4752         mock_pool.create.assert_not_called()
4753         mock_secret.setValue.assert_called_once_with(b"secret")
4754         secret_xml = mock_secret_define.call_args[0][0]
4755         root = ET.fromstring(secret_xml)
4756         self.assertEqual(root.find("usage/name").text, "pool_default")
4757         self.assertEqual(root.find("usage").attrib["type"], "ceph")
4758         self.assertEqual(root.attrib["private"], "yes")
4759         self.assertEqual(
4760             root.find("description").text, "Passphrase for default pool created by Salt"
4761         )
4762         for mock in mocks:
4763             mock.reset_mock()
4764         self.assertTrue(
4765             virt.pool_define(
4766                 "default",
4767                 "iscsi",
4768                 target="/dev/disk/by-path",
4769                 source_hosts=["iscsi.example.com"],
4770                 source_devices=[{"path": "iqn.2013-06.com.example:iscsi-pool"}],
4771                 source_auth={"username": "admin", "password": "secret"},
4772                 start=False,
4773             )
4774         )
4775         self.mock_conn.storagePoolCreateXML.assert_not_called()
4776         pool_xml = self.mock_conn.storagePoolDefineXML.call_args[0][0]
4777         root = ET.fromstring(pool_xml)
4778         self.assertEqual(root.find("source/auth").attrib["type"], "chap")
4779         self.assertEqual(root.find("source/auth").attrib["username"], "admin")
4780         self.assertEqual(
4781             root.find("source/auth/secret").attrib["usage"], "pool_default"
4782         )
4783         mock_pool.create.assert_not_called()
4784         mock_secret.setValue.assert_called_once_with("secret")
4785         secret_xml = mock_secret_define.call_args[0][0]
4786         root = ET.fromstring(secret_xml)
4787         self.assertEqual(root.find("usage/target").text, "pool_default")
4788         self.assertEqual(root.find("usage").attrib["type"], "iscsi")
4789         self.assertEqual(root.attrib["private"], "yes")
4790         self.assertEqual(
4791             root.find("description").text, "Passphrase for default pool created by Salt"
4792         )
4793     def test_list_pools(self):
4794         names = ["pool1", "default", "pool2"]
4795         pool_mocks = [MagicMock(), MagicMock(), MagicMock()]
4796         for i, value in enumerate(names):
4797             pool_mocks[i].name.return_value = value
4798         self.mock_conn.listAllStoragePools.return_value = (
4799             pool_mocks  # pylint: disable=no-member
4800         )
4801         actual = virt.list_pools()
4802         self.assertEqual(names, actual)
4803     def test_pool_info(self):
4804         pool_mock = MagicMock()
4805         pool_mock.name.return_value = "foo"
4806         pool_mock.UUIDString.return_value = "some-uuid"
4807         pool_mock.info.return_value = [0, 1234, 5678, 123]
4808         pool_mock.autostart.return_value = True
4809         pool_mock.isPersistent.return_value = True
4810         pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4811   &lt;name&gt;default&lt;/name&gt;
4812   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4813   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4814   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4815   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4816   &lt;source&gt;
4817   &lt;/source&gt;
4818   &lt;target&gt;
4819     &lt;path&gt;/srv/vms&lt;/path&gt;
4820     &lt;permissions&gt;
4821       &lt;mode&gt;0755&lt;/mode&gt;
4822       &lt;owner&gt;0&lt;/owner&gt;
4823       &lt;group&gt;0&lt;/group&gt;
4824     &lt;/permissions&gt;
4825   &lt;/target&gt;
4826 &lt;/pool&gt;"""
4827         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4828         pool = virt.pool_info("foo")
4829         self.assertEqual(
4830             {
4831                 "foo": {
4832                     "uuid": "some-uuid",
4833                     "state": "inactive",
4834                     "capacity": 1234,
4835                     "allocation": 5678,
4836                     "free": 123,
4837                     "autostart": True,
4838                     "persistent": True,
4839                     "type": "dir",
4840                     "target_path": "/srv/vms",
4841                 }
4842             },
4843             pool,
4844         )
4845     def test_pool_info_notarget(self):
4846         pool_mock = MagicMock()
4847         pool_mock.name.return_value = "ceph"
4848         pool_mock.UUIDString.return_value = "some-uuid"
4849         pool_mock.info.return_value = [0, 0, 0, 0]
4850         pool_mock.autostart.return_value = True
4851         pool_mock.isPersistent.return_value = True
4852         pool_mock.XMLDesc.return_value = """&lt;pool type='rbd'&gt;
4853   &lt;name&gt;ceph&lt;/name&gt;
4854   &lt;uuid&gt;some-uuid&lt;/uuid&gt;
4855   &lt;capacity unit='bytes'&gt;0&lt;/capacity&gt;
4856   &lt;allocation unit='bytes'&gt;0&lt;/allocation&gt;
4857   &lt;available unit='bytes'&gt;0&lt;/available&gt;
4858   &lt;source&gt;
4859     &lt;host name='localhost' port='6789'/&gt;
4860     &lt;host name='localhost' port='6790'/&gt;
4861     &lt;name&gt;rbd&lt;/name&gt;
4862     &lt;auth type='ceph' username='admin'&gt;
4863       &lt;secret uuid='2ec115d7-3a88-3ceb-bc12-0ac909a6fd87'/&gt;
4864     &lt;/auth&gt;
4865   &lt;/source&gt;
4866 &lt;/pool&gt;"""
4867         self.mock_conn.listAllStoragePools.return_value = [pool_mock]
4868         pool = virt.pool_info("ceph")
4869         self.assertEqual(
4870             {
4871                 "ceph": {
4872                     "uuid": "some-uuid",
4873                     "state": "inactive",
4874                     "capacity": 0,
4875                     "allocation": 0,
4876                     "free": 0,
4877                     "autostart": True,
4878                     "persistent": True,
4879                     "type": "rbd",
4880                     "target_path": None,
4881                 }
4882             },
4883             pool,
4884         )
4885     def test_pool_info_notfound(self):
4886         self.mock_conn.listAllStoragePools.return_value = []
4887         pool = virt.pool_info("foo")
4888         self.assertEqual({}, pool)
4889     def test_pool_info_all(self):
4890         pool_mocks = []
4891         for i in range(2):
4892             pool_mock = MagicMock()
4893             pool_mock.name.return_value = "pool{}".format(i)
4894             pool_mock.UUIDString.return_value = "some-uuid-{}".format(i)
4895             pool_mock.info.return_value = [0, 1234, 5678, 123]
4896             pool_mock.autostart.return_value = True
4897             pool_mock.isPersistent.return_value = True
4898             pool_mock.XMLDesc.return_value = """&lt;pool type='dir'&gt;
4899   &lt;name&gt;default&lt;/name&gt;
4900   &lt;uuid&gt;d92682d0-33cf-4e10-9837-a216c463e158&lt;/uuid&gt;
4901   &lt;capacity unit='bytes'&gt;854374301696&lt;/capacity&gt;
4902   &lt;allocation unit='bytes'&gt;596275986432&lt;/allocation&gt;
4903   &lt;available unit='bytes'&gt;258098315264&lt;/available&gt;
4904   &lt;source&gt;
4905   &lt;/source&gt;
4906   &lt;target&gt;
4907     &lt;path&gt;/srv/vms&lt;/path&gt;
4908     &lt;permissions&gt;
4909       &lt;mode&gt;0755&lt;/mode&gt;
4910       &lt;owner&gt;0&lt;/owner&gt;
4911       &lt;group&gt;0&lt;/group&gt;
4912     &lt;/permissions&gt;
4913   &lt;/target&gt;
4914 &lt;/pool&gt;"""
4915             pool_mocks.append(pool_mock)
4916         self.mock_conn.listAllStoragePools.return_value = pool_mocks
4917         pool = virt.pool_info()
4918         self.assertEqual(
4919             {
4920                 "pool0": {
4921                     "uuid": "some-uuid-0",
4922                     "state": "inactive",
4923                     "capacity": 1234,
4924                     "allocation": 5678,
4925                     "free": 123,
4926                     "autostart": True,
4927                     "persistent": True,
4928                     "type": "dir",
4929                     "target_path": "/srv/vms",
4930                 },
4931                 "pool1": {
4932                     "uuid": "some-uuid-1",
4933                     "state": "inactive",
4934                     "capacity": 1234,
4935                     "allocation": 5678,
4936                     "free": 123,
4937                     "autostart": True,
4938                     "persistent": True,
4939                     "type": "dir",
4940                     "target_path": "/srv/vms",
4941                 },
4942             },
4943             pool,
4944         )
4945     def test_pool_get_xml(self):
4946         pool_mock = MagicMock()
4947         pool_mock.XMLDesc.return_value = "&lt;pool&gt;Raw XML&lt;/pool&gt;"
4948         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
4949         self.assertEqual("&lt;pool&gt;Raw XML&lt;/pool&gt;", virt.pool_get_xml("default"))
4950     def test_pool_list_volumes(self):
4951         names = ["volume1", "volume2"]
4952         mock_pool = MagicMock()
4953         mock_pool.listVolumes.return_value = names
4954         self.mock_conn.storagePoolLookupByName.return_value = mock_pool
4955         self.assertEqual(names, virt.pool_list_volumes("default"))
4956     @patch("salt.modules.virt._is_bhyve_hyper", return_value=False)
4957     @patch("salt.modules.virt._is_kvm_hyper", return_value=True)
4958     @patch("salt.modules.virt._is_xen_hyper", return_value=False)
4959     def test_get_hypervisor(self, isxen_mock, iskvm_mock, is_bhyve_mock):
4960         self.assertEqual("kvm", virt.get_hypervisor())
4961         iskvm_mock.return_value = False
4962         self.assertIsNone(virt.get_hypervisor())
4963         is_bhyve_mock.return_value = False
4964         self.assertIsNone(virt.get_hypervisor())
4965         isxen_mock.return_value = True
4966         self.assertEqual("xen", virt.get_hypervisor())
4967     def test_pool_delete(self):
4968         mock_pool = MagicMock()
4969         mock_pool.delete = MagicMock(return_value=0)
4970         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4971         res = virt.pool_delete("test-pool")
4972         self.assertTrue(res)
4973         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-pool")
4974         mock_pool.delete.assert_called_once_with(
4975             self.mock_libvirt.VIR_STORAGE_POOL_DELETE_NORMAL
4976         )
4977     def test_pool_undefine_secret(self):
4978         mock_pool = MagicMock()
4979         mock_pool.undefine = MagicMock(return_value=0)
4980         mock_pool.XMLDesc.return_value = """
4981             &lt;pool type='rbd'&gt;
4982               &lt;name&gt;test-ses&lt;/name&gt;
4983               &lt;source&gt;
4984                 &lt;host name='myhost'/&gt;
4985                 &lt;name&gt;libvirt-pool&lt;/name&gt;
4986                 &lt;auth type='ceph' username='libvirt'&gt;
4987                   &lt;secret usage='pool_test-ses'/&gt;
4988                 &lt;/auth&gt;
4989               &lt;/source&gt;
4990             &lt;/pool&gt;
4991         """
4992         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mock_pool)
4993         mock_undefine = MagicMock(return_value=0)
4994         self.mock_conn.secretLookupByUsage.return_value.undefine = mock_undefine
4995         res = virt.pool_undefine("test-ses")
4996         self.assertTrue(res)
4997         self.mock_conn.storagePoolLookupByName.assert_called_once_with("test-ses")
4998         mock_pool.undefine.assert_called_once_with()
4999         self.mock_conn.secretLookupByUsage.assert_called_once_with(
5000             self.mock_libvirt.VIR_SECRET_USAGE_TYPE_CEPH, "pool_test-ses"
5001         )
5002         mock_undefine.assert_called_once()
5003     def test_full_info(self):
5004         xml = """&lt;domain type='kvm' id='7'&gt;
5005               &lt;uuid&gt;28deee33-4859-4f23-891c-ee239cffec94&lt;/uuid&gt;
5006               &lt;name&gt;test-vm&lt;/name&gt;
5007               &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;
5008               &lt;on_reboot&gt;restart&lt;/on_reboot&gt;
5009               &lt;on_crash&gt;destroy&lt;/on_crash&gt;
5010               &lt;devices&gt;
5011                 &lt;disk type='file' device='disk'&gt;
5012                 &lt;driver name='qemu' type='qcow2'/&gt;
5013                 &lt;source file='/disks/test.qcow2'/&gt;
5014                 &lt;target dev='vda' bus='virtio'/&gt;
5015               &lt;/disk&gt;
5016               &lt;disk type='file' device='cdrom'&gt;
5017                 &lt;driver name='qemu' type='raw'/&gt;
5018                 &lt;source file='/disks/test-cdrom.iso'/&gt;
5019                 &lt;target dev='hda' bus='ide'/&gt;
5020                 &lt;readonly/&gt;
5021               &lt;/disk&gt;
5022               &lt;interface type='bridge'&gt;
5023                 &lt;mac address='ac:de:48:b6:8b:59'/&gt;
5024                 &lt;source bridge='br0'/&gt;
5025                 &lt;model type='virtio'/&gt;
5026                 &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
5027               &lt;/interface&gt;
5028               &lt;graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'&gt;
5029                 &lt;listen type='address' address='0.0.0.0'/&gt;
5030               &lt;/graphics&gt;
5031               &lt;/devices&gt;
5032             &lt;/domain&gt;
5033         """
5034         self.set_mock_vm("test-vm", xml)
5035         qemu_infos = """[{
5036             "virtual-size": 25769803776,
5037             "filename": "/disks/test.qcow2",
5038             "cluster-size": 65536,
5039             "format": "qcow2",
5040             "actual-size": 217088,
5041             "format-specific": {
5042                 "type": "qcow2",
5043                 "data": {
5044                     "compat": "1.1",
5045                     "lazy-refcounts": false,
5046                     "refcount-bits": 16,
5047                     "corrupt": false
5048                 }
5049             },
5050             "full-backing-filename": "/disks/mybacking.qcow2",
5051             "backing-filename": "mybacking.qcow2",
5052             "dirty-flag": false
5053         },
5054         {
5055             "virtual-size": 25769803776,
5056             "filename": "/disks/mybacking.qcow2",
5057             "cluster-size": 65536,
5058             "format": "qcow2",
5059             "actual-size": 393744384,
5060             "format-specific": {
5061                 "type": "qcow2",
5062                 "data": {
5063                     "compat": "1.1",
5064                     "lazy-refcounts": false,
5065                     "refcount-bits": 16,
5066                     "corrupt": false
5067                 }
5068             },
5069             "dirty-flag": false
5070         }]"""
5071         self.mock_popen.communicate.return_value = [qemu_infos, ""]
5072         self.mock_popen.returncode = 0
5073         self.mock_conn.getInfo = MagicMock(
5074             return_value=["x86_64", 4096, 8, 2712, 1, 2, 4, 2]
5075         )
5076         actual = virt.full_info()
5077         qemu_img_call = [
5078             call
5079             for call in self.mock_subprocess.Popen.call_args_list
5080             if "qemu-img" in call[0][0]
5081         ][0]
5082         self.assertIn("info", qemu_img_call[0][0])
5083         self.assertIn("-U", qemu_img_call[0][0])
5084         self.assertEqual(2816, actual["freemem"])
5085         self.assertEqual(6, actual["freecpu"])
5086         self.assertEqual(4, actual["node_info"]["cpucores"])
5087         self.assertEqual(2712, actual["node_info"]["cpumhz"])
5088         self.assertEqual("x86_64", actual["node_info"]["cpumodel"])
5089         self.assertEqual(8, actual["node_info"]["cpus"])
5090         self.assertEqual(2, actual["node_info"]["cputhreads"])
5091         self.assertEqual(1, actual["node_info"]["numanodes"])
5092         self.assertEqual(4096, actual["node_info"]["phymemory"])
5093         self.assertEqual(2, actual["node_info"]["sockets"])
5094         self.assertEqual(2, actual["vm_info"]["test-vm"]["cpu"])
5095         self.assertEqual(1234, actual["vm_info"]["test-vm"]["cputime"])
5096         self.assertEqual(1024 * 1024, actual["vm_info"]["test-vm"]["mem"])
5097         self.assertEqual(2048 * 1024, actual["vm_info"]["test-vm"]["maxMem"])
5098         self.assertEqual("shutdown", actual["vm_info"]["test-vm"]["state"])
5099         self.assertEqual(
5100             "28deee33-4859-4f23-891c-ee239cffec94", actual["vm_info"]["test-vm"]["uuid"]
5101         )
5102         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_crash"])
5103         self.assertEqual("restart", actual["vm_info"]["test-vm"]["on_reboot"])
5104         self.assertEqual("destroy", actual["vm_info"]["test-vm"]["on_poweroff"])
5105         nic = actual["vm_info"]["test-vm"]["nics"]["ac:de:48:b6:8b:59"]
5106         self.assertEqual("bridge", nic["type"])
5107         self.assertEqual("ac:de:48:b6:8b:59", nic["mac"])
5108         disks = actual["vm_info"]["test-vm"]["disks"]
5109         disk = disks.get("vda")
5110         self.assertEqual("/disks/test.qcow2", disk["file"])
5111         self.assertEqual("disk", disk["type"])
5112         self.assertEqual("/disks/mybacking.qcow2", disk["backing file"]["file"])
5113         cdrom = disks.get("hda")
5114         self.assertEqual("/disks/test-cdrom.iso", cdrom["file"])
5115         self.assertEqual("cdrom", cdrom["type"])
5116         self.assertFalse("backing file" in cdrom.keys())
5117         graphics = actual["vm_info"]["test-vm"]["graphics"]
5118         self.assertEqual("vnc", graphics["type"])
5119         self.assertEqual("5900", graphics["port"])
5120         self.assertEqual("0.0.0.0", graphics["listen"])
5121     def test_pool_update(self):
5122         current_xml = """&lt;pool type='dir'&gt;
5123           &lt;name&gt;default&lt;/name&gt;
5124           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5125           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5126           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5127           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5128           &lt;source&gt;
5129           &lt;/source&gt;
5130           &lt;target&gt;
5131             &lt;path&gt;/path/to/pool&lt;/path&gt;
5132             &lt;permissions&gt;
5133               &lt;mode&gt;0775&lt;/mode&gt;
5134               &lt;owner&gt;0&lt;/owner&gt;
5135               &lt;group&gt;100&lt;/group&gt;
5136             &lt;/permissions&gt;
5137           &lt;/target&gt;
5138         &lt;/pool&gt;"""
5139         expected_xml = (
5140             '&lt;pool type="netfs"&gt;'
5141             "&lt;name&gt;default&lt;/name&gt;"
5142             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5143             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5144             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5145             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5146             "&lt;target&gt;"
5147             "&lt;path&gt;/mnt/cifs&lt;/path&gt;"
5148             "&lt;permissions&gt;"
5149             "&lt;mode&gt;0774&lt;/mode&gt;"
5150             "&lt;owner&gt;1234&lt;/owner&gt;"
5151             "&lt;group&gt;123&lt;/group&gt;"
5152             "&lt;/permissions&gt;"
5153             "&lt;/target&gt;"
5154             "&lt;source&gt;"
5155             '&lt;dir path="samba_share" /&gt;'
5156             '&lt;host name="one.example.com" /&gt;'
5157             '&lt;host name="two.example.com" /&gt;'
5158             '&lt;format type="cifs" /&gt;'
5159             "&lt;/source&gt;"
5160             "&lt;/pool&gt;"
5161         )
5162         mocked_pool = MagicMock()
5163         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5164         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5165         self.mock_conn.storagePoolDefineXML = MagicMock()
5166         self.assertTrue(
5167             virt.pool_update(
5168                 "default",
5169                 "netfs",
5170                 target="/mnt/cifs",
5171                 permissions={"mode": "0774", "owner": "1234", "group": "123"},
5172                 source_format="cifs",
5173                 source_dir="samba_share",
5174                 source_hosts=["one.example.com", "two.example.com"],
5175             )
5176         )
5177         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5178     def test_pool_update_nochange(self):
5179         current_xml = """&lt;pool type='dir'&gt;
5180           &lt;name&gt;default&lt;/name&gt;
5181           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5182           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5183           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5184           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5185           &lt;source&gt;
5186           &lt;/source&gt;
5187           &lt;target&gt;
5188             &lt;path&gt;/path/to/pool&lt;/path&gt;
5189             &lt;permissions&gt;
5190               &lt;mode&gt;0775&lt;/mode&gt;
5191               &lt;owner&gt;0&lt;/owner&gt;
5192               &lt;group&gt;100&lt;/group&gt;
5193             &lt;/permissions&gt;
5194           &lt;/target&gt;
5195         &lt;/pool&gt;"""
5196         mocked_pool = MagicMock()
5197         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5198         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5199         self.mock_conn.storagePoolDefineXML = MagicMock()
5200         self.assertFalse(
5201             virt.pool_update(
5202                 "default",
5203                 "dir",
5204                 target="/path/to/pool",
5205                 permissions={"mode": "0775", "owner": "0", "group": "100"},
5206                 test=True,
5207             )
5208         )
5209         self.mock_conn.storagePoolDefineXML.assert_not_called()
5210     def test_pool_update_password(self):
5211         current_xml = """&lt;pool type='rbd'&gt;
5212           &lt;name&gt;default&lt;/name&gt;
5213           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5214           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5215           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5216           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5217           &lt;source&gt;
5218             &lt;name&gt;iscsi-images&lt;/name&gt;
5219             &lt;host name='ses4.tf.local'/&gt;
5220             &lt;host name='ses5.tf.local'/&gt;
5221             &lt;auth username='libvirt' type='ceph'&gt;
5222               &lt;secret uuid='14e9a0f1-8fbf-4097-b816-5b094c182212'/&gt;
5223             &lt;/auth&gt;
5224           &lt;/source&gt;
5225         &lt;/pool&gt;"""
5226         mock_secret = MagicMock()
5227         self.mock_conn.secretLookupByUUIDString = MagicMock(return_value=mock_secret)
5228         mocked_pool = MagicMock()
5229         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5230         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5231         self.mock_conn.storagePoolDefineXML = MagicMock()
5232         self.assertFalse(
5233             virt.pool_update(
5234                 "default",
5235                 "rbd",
5236                 source_name="iscsi-images",
5237                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5238                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5239             )
5240         )
5241         self.mock_conn.storagePoolDefineXML.assert_not_called()
5242         mock_secret.setValue.assert_called_once_with(b"secret")
5243         self.mock_conn.secretLookupByUUIDString = MagicMock(
5244             side_effect=self.mock_libvirt.libvirtError("secret not found")
5245         )
5246         self.assertFalse(
5247             virt.pool_update(
5248                 "default",
5249                 "rbd",
5250                 source_name="iscsi-images",
5251                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5252                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5253             )
5254         )
5255         self.mock_conn.storagePoolDefineXML.assert_not_called()
5256         self.mock_conn.secretDefineXML.assert_called_once()
5257         mock_secret.setValue.assert_called_once_with(b"secret")
5258     def test_pool_update_password_create(self):
5259         current_xml = """&lt;pool type='rbd'&gt;
5260           &lt;name&gt;default&lt;/name&gt;
5261           &lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;
5262           &lt;capacity unit='bytes'&gt;1999421108224&lt;/capacity&gt;
5263           &lt;allocation unit='bytes'&gt;713207042048&lt;/allocation&gt;
5264           &lt;available unit='bytes'&gt;1286214066176&lt;/available&gt;
5265           &lt;source&gt;
5266             &lt;name&gt;iscsi-images&lt;/name&gt;
5267             &lt;host name='ses4.tf.local'/&gt;
5268             &lt;host name='ses5.tf.local'/&gt;
5269           &lt;/source&gt;
5270         &lt;/pool&gt;"""
5271         expected_xml = (
5272             '&lt;pool type="rbd"&gt;'
5273             "&lt;name&gt;default&lt;/name&gt;"
5274             "&lt;uuid&gt;20fbe05c-ab40-418a-9afa-136d512f0ede&lt;/uuid&gt;"
5275             '&lt;capacity unit="bytes"&gt;1999421108224&lt;/capacity&gt;'
5276             '&lt;allocation unit="bytes"&gt;713207042048&lt;/allocation&gt;'
5277             '&lt;available unit="bytes"&gt;1286214066176&lt;/available&gt;'
5278             "&lt;source&gt;"
5279             '&lt;host name="ses4.tf.local" /&gt;'
5280             '&lt;host name="ses5.tf.local" /&gt;'
5281             '&lt;auth type="ceph" username="libvirt"&gt;'
5282             '&lt;secret usage="pool_default" /&gt;'
5283             "&lt;/auth&gt;"
5284             "&lt;name&gt;iscsi-images&lt;/name&gt;"
5285             "&lt;/source&gt;"
5286             "&lt;/pool&gt;"
5287         )
5288         mock_secret = MagicMock()
5289         self.mock_conn.secretDefineXML = MagicMock(return_value=mock_secret)
5290         mocked_pool = MagicMock()
5291         mocked_pool.XMLDesc = MagicMock(return_value=current_xml)
5292         self.mock_conn.storagePoolLookupByName = MagicMock(return_value=mocked_pool)
5293         self.mock_conn.storagePoolDefineXML = MagicMock()
5294         self.assertTrue(
5295             virt.pool_update(
5296                 "default",
5297                 "rbd",
5298                 source_name="iscsi-images",
5299                 source_hosts=["ses4.tf.local", "ses5.tf.local"],
5300                 source_auth={"username": "libvirt", "password": "c2VjcmV0"},
5301             )
5302         )
5303         self.mock_conn.storagePoolDefineXML.assert_called_once_with(expected_xml)
5304         mock_secret.setValue.assert_called_once_with(b"secret")
5305     def test_volume_infos(self):
5306         vms_disks = [
5307         ]
5308         mock_vms = []
5309         for idx, disk in enumerate(vms_disks):
5310             vm = MagicMock()
5311             vm.name.return_value = "vm{}".format(idx)
5312             vm.XMLDesc.return_value = """
5313                     &lt;domain type='kvm' id='1'&gt;
5314                       &lt;name&gt;vm{}&lt;/name&gt;
5315                       &lt;devices&gt;{}&lt;/devices&gt;
5316                     &lt;/domain&gt;
5317                 """.format(
5318                 idx, disk
5319             )
5320             mock_vms.append(vm)
5321         mock_pool_data = [
5322             {
5323                 "name": "pool0",
5324                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5325                 "volumes": [
5326                     {
5327                         "key": "/key/of/vol0",
5328                         "name": "vol0",
5329                         "path": "/path/to/vol0.qcow2",
5330                         "info": [0, 123456789, 123456],
5331                         "backingStore": None,
5332                     }
5333                 ],
5334             },
5335             {
5336                 "name": "pool1",
5337                 "state": self.mock_libvirt.VIR_STORAGE_POOL_RUNNING,
5338                 "volumes": [
5339                     {
5340                         "key": "/key/of/vol0bad",
5341                         "name": "vol0bad",
5342                         "path": "/path/to/vol0bad.qcow2",
5343                         "info": None,
5344                         "backingStore": None,
5345                     },
5346                     {
5347                         "key": "/key/of/vol1",
5348                         "name": "vol1",
5349                         "path": "/path/to/vol1.qcow2",
5350                         "info": [0, 12345, 1234],
5351                         "backingStore": None,
5352                     },
5353                     {
5354                         "key": "/key/of/vol2",
5355                         "name": "vol2",
5356                         "path": "/path/to/vol2.qcow2",
5357                         "info": [0, 12345, 1234],
5358                         "backingStore": "/path/to/vol0.qcow2",
5359                     },
5360                 ],
5361             },
5362         ]
5363         mock_pools = []
5364         for pool_data in mock_pool_data:
5365             mock_pool = MagicMock()
5366             mock_pool.name.return_value = pool_data["name"]  # pylint: disable=no-member
5367             mock_pool.info.return_value = [pool_data["state"]]
5368             mock_volumes = []
5369             for vol_data in pool_data["volumes"]:
5370                 mock_volume = MagicMock()
5371                 mock_volume.name.return_value = vol_data["name"]
5372                 mock_volume.key.return_value = vol_data["key"]
5373                 mock_volume.path.return_value = "/path/to/{}.qcow2".format(
5374                     vol_data["name"]
5375                 )
5376                 if vol_data["info"]:
5377                     mock_volume.info.return_value = vol_data["info"]
5378                     backing_store = (
5379                             vol_data["backingStore"]
5380                         )
5381                         if vol_data["backingStore"]
5382                         else "&lt;backingStore/&gt;"
5383                     )
5384                     mock_volume.XMLDesc.return_value = """
5385                         &lt;volume type='file'&gt;
5386                           &lt;name&gt;{0}&lt;/name&gt;
5387                           &lt;target&gt;
5388                             &lt;format type="qcow2"/&gt;
5389                             &lt;path&gt;/path/to/{0}.qcow2&lt;/path&gt;
5390                           &lt;/target&gt;
5391                           {1}
5392                         &lt;/volume&gt;
5393                     """.format(
5394                         vol_data["name"], backing_store
5395                     )
5396                 else:
5397                     mock_volume.info.side_effect = self.mock_libvirt.libvirtError(
5398                         "No such volume"
5399                     )
5400                     mock_volume.XMLDesc.side_effect = self.mock_libvirt.libvirtError(
5401                         "No such volume"
5402                     )
5403                 mock_volumes.append(mock_volume)
5404             mock_pool.listAllVolumes.return_value = (
5405                 mock_volumes  # pylint: disable=no-member
5406             )
5407             mock_pools.append(mock_pool)
5408         inactive_pool = MagicMock()
5409         inactive_pool.name.return_value = "pool2"
5410         inactive_pool.info.return_value = [self.mock_libvirt.VIR_STORAGE_POOL_INACTIVE]
5411         inactive_pool.listAllVolumes.side_effect = self.mock_libvirt.libvirtError(
5412             "pool is inactive"
5413         )
5414         mock_pools.append(inactive_pool)
5415         self.mock_conn.listAllStoragePools.return_value = (
5416             mock_pools  # pylint: disable=no-member
5417         )
5418         with patch("salt.modules.virt._get_domain", MagicMock(return_value=mock_vms)):
5419             actual = virt.volume_infos("pool0", "vol0")
5420             self.assertEqual(1, len(actual.keys()))
5421             self.assertEqual(1, len(actual["pool0"].keys()))
5422             self.assertEqual(["vm0", "vm2"], sorted(actual["pool0"]["vol0"]["used_by"]))
5423             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5424             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5425             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5426             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5427             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5428             self.assertEqual(
5429                 virt.volume_infos("pool1", None),
5430                 {
5431                     "pool1": {
5432                         "vol1": {
5433                             "type": "file",
5434                             "key": "/key/of/vol1",
5435                             "path": "/path/to/vol1.qcow2",
5436                             "capacity": 12345,
5437                             "allocation": 1234,
5438                             "used_by": [],
5439                             "backing_store": None,
5440                             "format": "qcow2",
5441                         },
5442                         "vol2": {
5443                             "type": "file",
5444                             "key": "/key/of/vol2",
5445                             "path": "/path/to/vol2.qcow2",
5446                             "capacity": 12345,
5447                             "allocation": 1234,
5448                             "used_by": ["vm2"],
5449                             "backing_store": {
5450                                 "path": "/path/to/vol0.qcow2",
5451                                 "format": "qcow2",
5452                             },
5453                             "format": "qcow2",
5454                         },
5455                     }
5456                 },
5457             )
5458             self.assertEqual(
5459                 virt.volume_infos(None, "vol2"),
5460                 {
5461                     "pool1": {
5462                         "vol2": {
5463                             "type": "file",
5464                             "key": "/key/of/vol2",
5465                             "path": "/path/to/vol2.qcow2",
5466                             "capacity": 12345,
5467                             "allocation": 1234,
5468                             "used_by": ["vm2"],
5469                             "backing_store": {
5470                                 "path": "/path/to/vol0.qcow2",
5471                                 "format": "qcow2",
5472                             },
5473                             "format": "qcow2",
5474                         }
5475                     }
5476                 },
5477             )
5478         with patch(
5479             "salt.modules.virt._get_domain", MagicMock(return_value=mock_vms[0])
5480         ):
5481             actual = virt.volume_infos("pool0", "vol0")
5482             self.assertEqual(1, len(actual.keys()))
5483             self.assertEqual(1, len(actual["pool0"].keys()))
5484             self.assertEqual(["vm0"], sorted(actual["pool0"]["vol0"]["used_by"]))
5485             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5486             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5487             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5488             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5489             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5490             self.assertEqual(
5491                 virt.volume_infos("pool1", None),
5492                 {
5493                     "pool1": {
5494                         "vol1": {
5495                             "type": "file",
5496                             "key": "/key/of/vol1",
5497                             "path": "/path/to/vol1.qcow2",
5498                             "capacity": 12345,
5499                             "allocation": 1234,
5500                             "used_by": [],
5501                             "backing_store": None,
5502                             "format": "qcow2",
5503                         },
5504                         "vol2": {
5505                             "type": "file",
5506                             "key": "/key/of/vol2",
5507                             "path": "/path/to/vol2.qcow2",
5508                             "capacity": 12345,
5509                             "allocation": 1234,
5510                             "used_by": [],
5511                             "backing_store": {
5512                                 "path": "/path/to/vol0.qcow2",
5513                                 "format": "qcow2",
5514                             },
5515                             "format": "qcow2",
5516                         },
5517                     }
5518                 },
5519             )
5520             self.assertEqual(
5521                 virt.volume_infos(None, "vol2"),
5522                 {
5523                     "pool1": {
5524                         "vol2": {
5525                             "type": "file",
5526                             "key": "/key/of/vol2",
5527                             "path": "/path/to/vol2.qcow2",
5528                             "capacity": 12345,
5529                             "allocation": 1234,
5530                             "used_by": [],
5531                             "backing_store": {
5532                                 "path": "/path/to/vol0.qcow2",
5533                                 "format": "qcow2",
5534                             },
5535                             "format": "qcow2",
5536                         }
5537                     }
5538                 },
5539             )
5540         with patch(
5541             "salt.modules.virt._get_domain",
5542             MagicMock(side_effect=CommandExecutionError("no VM")),
5543         ):
5544             actual = virt.volume_infos("pool0", "vol0")
5545             self.assertEqual(1, len(actual.keys()))
5546             self.assertEqual(1, len(actual["pool0"].keys()))
5547             self.assertEqual([], sorted(actual["pool0"]["vol0"]["used_by"]))
5548             self.assertEqual("/path/to/vol0.qcow2", actual["pool0"]["vol0"]["path"])
5549             self.assertEqual("file", actual["pool0"]["vol0"]["type"])
5550             self.assertEqual("/key/of/vol0", actual["pool0"]["vol0"]["key"])
5551             self.assertEqual(123456789, actual["pool0"]["vol0"]["capacity"])
5552             self.assertEqual(123456, actual["pool0"]["vol0"]["allocation"])
5553             self.assertEqual(
5554                 virt.volume_infos("pool1", None),
5555                 {
5556                     "pool1": {
5557                         "vol1": {
5558                             "type": "file",
5559                             "key": "/key/of/vol1",
5560                             "path": "/path/to/vol1.qcow2",
5561                             "capacity": 12345,
5562                             "allocation": 1234,
5563                             "used_by": [],
5564                             "backing_store": None,
5565                             "format": "qcow2",
5566                         },
5567                         "vol2": {
5568                             "type": "file",
5569                             "key": "/key/of/vol2",
5570                             "path": "/path/to/vol2.qcow2",
5571                             "capacity": 12345,
5572                             "allocation": 1234,
5573                             "used_by": [],
5574                             "backing_store": {
5575                                 "path": "/path/to/vol0.qcow2",
5576                                 "format": "qcow2",
5577                             },
5578                             "format": "qcow2",
5579                         },
5580                     }
5581                 },
5582             )
5583             self.assertEqual(
5584                 virt.volume_infos(None, "vol2"),
5585                 {
5586                     "pool1": {
5587                         "vol2": {
5588                             "type": "file",
5589                             "key": "/key/of/vol2",
5590                             "path": "/path/to/vol2.qcow2",
5591                             "capacity": 12345,
5592                             "allocation": 1234,
5593                             "used_by": [],
5594                             "backing_store": {
5595                                 "path": "/path/to/vol0.qcow2",
5596                                 "format": "qcow2",
5597                             },
5598                             "format": "qcow2",
5599                         }
5600                     }
5601                 },
5602             )
5603     def test_volume_delete(self):
5604         mock_delete = MagicMock(side_effect=[0, 1])
5605         mock_volume = MagicMock()
5606         mock_volume.delete = mock_delete  # pylint: disable=no-member
5607         mock_pool = MagicMock()
5608         mock_pool.storageVolLookupByName.side_effect = [
5609             mock_volume,
5610             mock_volume,
5611             self.mock_libvirt.libvirtError("Missing volume"),
5612             mock_volume,
5613         ]
5614         self.mock_conn.storagePoolLookupByName.side_effect = [
5615             mock_pool,
5616             mock_pool,
5617             mock_pool,
5618             self.mock_libvirt.libvirtError("Missing pool"),
5619         ]
5620         self.assertTrue(virt.volume_delete("default", "test_volume"))
5621         self.assertFalse(virt.volume_delete("default", "test_volume"))
5622         with self.assertRaises(self.mock_libvirt.libvirtError):
5623             virt.volume_delete("default", "missing")
5624             virt.volume_delete("missing", "test_volume")
5625         self.assertEqual(mock_delete.call_count, 2)
5626     def test_pool_capabilities(self):
5627         xml_caps = """
5628 &lt;storagepoolCapabilities&gt;
5629   &lt;pool type='disk' supported='yes'&gt;
5630     &lt;poolOptions&gt;
5631       &lt;defaultFormat type='unknown'/&gt;
5632       &lt;enum name='sourceFormatType'&gt;
5633         &lt;value&gt;unknown&lt;/value&gt;
5634         &lt;value&gt;dos&lt;/value&gt;
5635         &lt;value&gt;dvh&lt;/value&gt;
5636       &lt;/enum&gt;
5637     &lt;/poolOptions&gt;
5638     &lt;volOptions&gt;
5639       &lt;defaultFormat type='none'/&gt;
5640       &lt;enum name='targetFormatType'&gt;
5641         &lt;value&gt;none&lt;/value&gt;
5642         &lt;value&gt;linux&lt;/value&gt;
5643       &lt;/enum&gt;
5644     &lt;/volOptions&gt;
5645   &lt;/pool&gt;
5646   &lt;pool type='iscsi' supported='yes'&gt;
5647   &lt;/pool&gt;
5648   &lt;pool type='rbd' supported='yes'&gt;
5649     &lt;volOptions&gt;
5650       &lt;defaultFormat type='raw'/&gt;
5651       &lt;enum name='targetFormatType'&gt;
5652       &lt;/enum&gt;
5653     &lt;/volOptions&gt;
5654   &lt;/pool&gt;
5655   &lt;pool type='sheepdog' supported='no'&gt;
5656   &lt;/pool&gt;
5657 &lt;/storagepoolCapabilities&gt;
5658         """
5659         self.mock_conn.getStoragePoolCapabilities = MagicMock(return_value=xml_caps)
5660         actual = virt.pool_capabilities()
5661         self.assertEqual(
5662             {
5663                 "computed": False,
5664                 "pool_types": [
5665                     {
5666                         "name": "disk",
5667                         "supported": True,
5668                         "options": {
5669                             "pool": {
5670                                 "default_format": "unknown",
5671                                 "sourceFormatType": ["unknown", "dos", "dvh"],
5672                             },
5673                             "volume": {
5674                                 "default_format": "none",
5675                                 "targetFormatType": ["none", "linux"],
5676                             },
5677                         },
5678                     },
5679                     {"name": "iscsi", "supported": True},
5680                     {
5681                         "name": "rbd",
5682                         "supported": True,
5683                         "options": {
5684                             "volume": {"default_format": "raw", "targetFormatType": []}
5685                         },
5686                     },
5687                     {"name": "sheepdog", "supported": False},
5688                 ],
5689             },
5690             actual,
5691         )
5692     @patch("salt.modules.virt.get_hypervisor", return_value="kvm")
5693     def test_pool_capabilities_computed(self, mock_get_hypervisor):
5694         self.mock_conn.getLibVersion = MagicMock(return_value=4006000)
5695         del self.mock_conn.getStoragePoolCapabilities
5696         actual = virt.pool_capabilities()
5697         self.assertTrue(actual["computed"])
5698         backends = actual["pool_types"]
5699         self.assertFalse(
5700             [backend for backend in backends if backend["name"] == "iscsi-direct"][0][
5701                 "supported"
5702             ]
5703         )
5704         self.assertTrue(
5705             [backend for backend in backends if backend["name"] == "gluster"][0][
5706                 "supported"
5707             ]
5708         )
5709         self.assertFalse(
5710             [backend for backend in backends if backend["name"] == "zfs"][0][
5711                 "supported"
5712             ]
5713         )
5714         mock_get_hypervisor.return_value = "xen"
5715         backends = virt.pool_capabilities()["pool_types"]
5716         self.assertFalse(
5717             [backend for backend in backends if backend["name"] == "gluster"][0][
5718                 "supported"
5719             ]
5720         )
5721         mock_get_hypervisor.return_value = "bhyve"
5722         backends = virt.pool_capabilities()["pool_types"]
5723         self.assertFalse(
5724             [backend for backend in backends if backend["name"] == "gluster"][0][
5725                 "supported"
5726             ]
5727         )
5728         self.assertTrue(
5729             [backend for backend in backends if backend["name"] == "zfs"][0][
5730                 "supported"
5731             ]
5732         )
5733         self.assertNotIn(
5734             "options",
5735             [backend for backend in backends if backend["name"] == "iscsi"][0],
5736         )
5737         self.assertNotIn(
5738             "pool",
5739             [backend for backend in backends if backend["name"] == "dir"][0]["options"],
5740         )
5741         self.assertNotIn(
5742             "volume",
5743             [backend for backend in backends if backend["name"] == "logical"][0][
5744                 "options"
5745             ],
5746         )
5747         self.assertEqual(
5748             {
5749                 "pool": {
5750                     "default_format": "auto",
5751                     "sourceFormatType": ["auto", "nfs", "glusterfs", "cifs"],
5752                 },
5753                 "volume": {
5754                     "default_format": "raw",
5755                     "targetFormatType": [
5756                         "none",
5757                         "raw",
5758                         "dir",
5759                         "bochs",
5760                         "cloop",
5761                         "dmg",
5762                         "iso",
5763                         "vpc",
5764                         "vdi",
5765                         "fat",
5766                         "vhd",
5767                         "ploop",
5768                         "cow",
5769                         "qcow",
5770                         "qcow2",
5771                         "qed",
5772                         "vmdk",
5773                     ],
5774                 },
5775             },
5776             [backend for backend in backends if backend["name"] == "netfs"][0][
5777                 "options"
5778             ],
5779         )
5780     def test_get_domain(self):
5781         self.mock_conn.listDomainsID.return_value = []
5782         self.mock_conn.listDefinedDomains.return_value = []
5783         self.assertEqual([], virt._get_domain(self.mock_conn))
5784         self.assertRaisesRegex(
5785             CommandExecutionError,
5786             "No virtual machines found.",
5787             virt._get_domain,
5788             self.mock_conn,
5789             "vm2",
5790         )
5791         self.mock_conn.listDomainsID.return_value = [1]
5792         def create_mock_vm(idx):
5793             mock_vm = MagicMock()
5794             mock_vm.name.return_value = "vm{}".format(idx)
5795             return mock_vm
5796         mock_vms = [create_mock_vm(idx) for idx in range(3)]
5797         self.mock_conn.lookupByID.return_value = mock_vms[0]
5798         self.mock_conn.listDefinedDomains.return_value = ["vm1", "vm2"]
5799         self.mock_conn.lookupByName.side_effect = mock_vms
5800         self.assertEqual(mock_vms, virt._get_domain(self.mock_conn))
5801         self.mock_conn.lookupByName.side_effect = None
5802         self.mock_conn.lookupByName.return_value = mock_vms[0]
5803         self.assertEqual(mock_vms[0], virt._get_domain(self.mock_conn, inactive=False))
5804         self.mock_conn.lookupByName.return_value = None
5805         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5806         self.assertEqual(
5807             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, active=False)
5808         )
5809         self.mock_conn.reset_mock()
5810         self.mock_conn.lookupByName.return_value = None
5811         self.mock_conn.lookupByName.side_effect = [mock_vms[1], mock_vms[2]]
5812         self.assertEqual(
5813             [mock_vms[1], mock_vms[2]], virt._get_domain(self.mock_conn, "vm1", "vm2")
5814         )
5815         self.assertRaisesRegex(
5816             CommandExecutionError,
5817             'The VM "vm2" is not present',
5818             virt._get_domain,
5819             self.mock_conn,
5820             "vm2",
5821             inactive=False,
5822         )
5823     def test_volume_define(self):
5824         pool_mock = MagicMock()
5825         pool_mock.XMLDesc.return_value = "&lt;pool type='dir'&gt;&lt;/pool&gt;"
5826         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5827         self.assertTrue(
5828             virt.volume_define(
5829                 "testpool",
5830                 "myvm_system.qcow2",
5831                 8192,
5832                 allocation=4096,
5833                 format="qcow2",
5834                 type="file",
5835             )
5836         )
5837         expected_xml = (
5838             "&lt;volume type='file'&gt;\n"
5839             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5840             "  &lt;source&gt;\n"
5841             "  &lt;/source&gt;\n"
5842             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5843             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5844             "  &lt;target&gt;\n"
5845             "    &lt;format type='qcow2'/&gt;\n"
5846             "  &lt;/target&gt;\n"
5847             "&lt;/volume&gt;"
5848         )
5849         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5850         pool_mock.reset_mock()
5851         self.assertTrue(
5852             virt.volume_define(
5853                 "testpool",
5854                 "myvm_system.qcow2",
5855                 8192,
5856                 allocation=4096,
5857                 format="qcow2",
5858                 type="file",
5859                 backing_store={"path": "/path/to/base.raw", "format": "raw"},
5860             )
5861         )
5862         expected_xml = (
5863             "&lt;volume type='file'&gt;\n"
5864             "  &lt;name&gt;myvm_system.qcow2&lt;/name&gt;\n"
5865             "  &lt;source&gt;\n"
5866             "  &lt;/source&gt;\n"
5867             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5868             "  &lt;allocation unit='KiB'&gt;4194304&lt;/allocation&gt;\n"
5869             "  &lt;target&gt;\n"
5870             "    &lt;format type='qcow2'/&gt;\n"
5871             "  &lt;/target&gt;\n"
5872             "  &lt;backingStore&gt;\n"
5873             "    &lt;path&gt;/path/to/base.raw&lt;/path&gt;\n"
5874             "    &lt;format type='raw'/&gt;\n"
5875             "  &lt;/backingStore&gt;\n"
5876             "&lt;/volume&gt;"
5877         )
5878         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5879         pool_mock.reset_mock()
5880         pool_mock.XMLDesc.return_value = "&lt;pool type='logical'&gt;&lt;/pool&gt;"
5881         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5882         self.assertTrue(
5883             virt.volume_define(
5884                 "testVG",
5885                 "myvm_system",
5886                 8192,
5887                 backing_store={"path": "/dev/testVG/base"},
5888             )
5889         )
5890         expected_xml = (
5891             "&lt;volume&gt;\n"
5892             "  &lt;name&gt;myvm_system&lt;/name&gt;\n"
5893             "  &lt;source&gt;\n"
5894             "  &lt;/source&gt;\n"
5895             "  &lt;capacity unit='KiB'&gt;8388608&lt;/capacity&gt;\n"
5896             "  &lt;allocation unit='KiB'&gt;8388608&lt;/allocation&gt;\n"
5897             "  &lt;target&gt;\n"
5898             "  &lt;/target&gt;\n"
5899             "  &lt;backingStore&gt;\n"
5900             "    &lt;path&gt;/dev/testVG/base&lt;/path&gt;\n"
5901             "  &lt;/backingStore&gt;\n"
5902             "&lt;/volume&gt;"
5903         )
5904         pool_mock.createXML.assert_called_once_with(expected_xml, 0)
5905     def test_volume_upload(self):
5906         pool_mock = MagicMock()
5907         vol_mock = MagicMock()
5908         pool_mock.storageVolLookupByName.return_value = vol_mock
5909         self.mock_conn.storagePoolLookupByName.return_value = pool_mock
5910         stream_mock = MagicMock()
5911         self.mock_conn.newStream.return_value = stream_mock
5912         open_mock = MagicMock()
5913         close_mock = MagicMock()
5914         with patch.dict(
5915             os.__dict__, {"open": open_mock, "close": close_mock}
5916         ):  # pylint: disable=no-member
5917             self.assertTrue(virt.volume_upload("pool0", "vol1.qcow2", "/path/to/file"))
5918             stream_mock.sendAll.assert_called_once()
5919             stream_mock.finish.assert_called_once()
5920             self.mock_conn.close.assert_called_once()
5921             vol_mock.upload.assert_called_once_with(stream_mock, 0, 0, 0)
5922             stream_mock.sendAll.reset_mock()
5923             vol_mock.upload.reset_mock()
5924             self.assertTrue(
5925                 virt.volume_upload(
5926                     "pool0",
5927                     "vol1.qcow2",
5928                     "/path/to/file",
5929                     offset=123,
5930                     length=456,
5931                     sparse=True,
5932                 )
5933             )
5934             stream_mock.sendAll.assert_not_called()
5935             stream_mock.sparseSendAll.assert_called_once()
5936             vol_mock.upload.assert_called_once_with(
5937                 stream_mock,
5938                 123,
5939                 456,
5940                 self.mock_libvirt.VIR_STORAGE_VOL_UPLOAD_SPARSE_STREAM,
5941             )
5942             vol_mock.upload.side_effect = self.mock_libvirt.libvirtError("Unsupported")
5943             self.assertRaisesRegex(
5944                 CommandExecutionError,
5945                 "Unsupported",
5946                 virt.volume_upload,
5947                 "pool0",
5948                 "vol1.qcow2",
5949                 "/path/to/file",
5950             )
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
